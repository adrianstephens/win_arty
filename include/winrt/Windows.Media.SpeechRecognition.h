#pragma once
// generated by isopod tools
// namespaces:
// Windows.Media.SpeechRecognition

#include "Windows.Media.SpeechRecognition.0.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IIterable;
template<typename T> struct IVector;
template<typename T> struct IVectorView;
template<typename K, typename V> struct IMapView;
}}
namespace Globalization {
struct Language;
}
namespace Storage {
struct StorageFile;
}}

// defs

template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability> : enum_type<int> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionConfidence> : enum_type<int> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionScenario> : enum_type<int> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionConstraintType> : enum_type<int> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognizerState> : enum_type<int> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionAudioProblem> : enum_type<int> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionResultStatus> : enum_type<int> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechContinuousRecognitionMode> : enum_type<int> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognitionCompilationResult> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognizerTimeouts> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognizerUIOptions> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognitionResult> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognitionSemanticInterpretation> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechRecognitionSemanticInterpretation> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognitionResult2> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionResult> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechRecognitionResult, Windows::Media::SpeechRecognition::ISpeechRecognitionResult2> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint> : overridable_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognitionTopicConstraint> : interface_type<Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognitionTopicConstraintFactory> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechRecognitionTopicConstraint>, custom_activators {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognitionListConstraint> : interface_type<Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognitionListConstraintFactory> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechRecognitionListConstraint>, custom_activators {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognitionGrammarFileConstraint> : interface_type<Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognitionGrammarFileConstraintFactory> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechRecognitionGrammarFileConstraint>, custom_activators {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognitionVoiceCommandDefinitionConstraint> : interface_type<Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognitionQualityDegradingEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognizerStateChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognizer> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechRecognizerTimeouts> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechRecognizerUIOptions> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechRecognitionCompilationResult> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognizerStatics2> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognizerStatics> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognizerFactory> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognizer2> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognizer> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechRecognizer, Windows::Media::SpeechRecognition::ISpeechRecognizer2>, custom_activators {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechRecognitionQualityDegradingEventArgs> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechRecognizerStateChangedEventArgs> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechRecognitionVoiceCommandDefinitionConstraint> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechContinuousRecognitionSession> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechContinuousRecognitionSession> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognitionHypothesisGeneratedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechRecognitionHypothesisGeneratedEventArgs> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechRecognitionHypothesis> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechRecognitionHypothesis> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechContinuousRecognitionCompletedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechContinuousRecognitionCompletedEventArgs> {};
template<> struct def<Windows::Media::SpeechRecognition::ISpeechContinuousRecognitionResultGeneratedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs> : class_type<Platform::Object, Windows::Media::SpeechRecognition::ISpeechContinuousRecognitionResultGeneratedEventArgs> {};
template<> struct def<Windows::Media::SpeechRecognition::IVoiceCommandManager> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::VoiceCommandManager> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Media::SpeechRecognition::IVoiceCommandSet> : interface_type<> {};
template<> struct def<Windows::Media::SpeechRecognition::VoiceCommandSet> : class_type<Platform::Object, Windows::Media::SpeechRecognition::IVoiceCommandSet> {};

// uuids

template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognitionCompilationResult> { define_guid(0x407E6C5D, 0x6AC7, 0x4DA4, 0x9C, 0xC1, 0x2F, 0xCE, 0x32, 0xCF, 0x74, 0x89);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognizerTimeouts> { define_guid(0x2EF76FCA, 0x6A3C, 0x4DCA, 0xA1, 0x53, 0xDF, 0x1B, 0xC8, 0x8A, 0x79, 0xAF);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognizerUIOptions> { define_guid(0x7888D641, 0xB92B, 0x44BA, 0xA2, 0x5F, 0xD1, 0x86, 0x46, 0x30, 0x64, 0x1F);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognitionResult> { define_guid(0x4E303157, 0x34E, 0x4652, 0x85, 0x7E, 0xD0, 0x45, 0x4C, 0xC4, 0xBE, 0xEC);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognitionSemanticInterpretation> { define_guid(0xAAE1DA9B, 0x7E32, 0x4C1F, 0x89, 0xFE, 0xC, 0x65, 0xF4, 0x86, 0xF5, 0x2E);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognitionResult2> { define_guid(0xAF7ED1BA, 0x451B, 0x4166, 0xA0, 0xC1, 0x1F, 0xFE, 0x84, 0x3, 0x2D, 0x3);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint> { define_guid(0x79AC1628, 0x4D68, 0x43C4, 0x89, 0x11, 0x40, 0xDC, 0x41, 0x1, 0xB5, 0x5B);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognitionTopicConstraint> { define_guid(0xBF6FDF19, 0x825D, 0x4E69, 0xA6, 0x81, 0x36, 0xE4, 0x8C, 0xF1, 0xC9, 0x3E);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognitionTopicConstraintFactory> { define_guid(0x6E6863DF, 0xEC05, 0x47D7, 0xA5, 0xDF, 0x56, 0xA3, 0x43, 0x1E, 0x58, 0xD2);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognitionListConstraint> { define_guid(0x9C487E9, 0xE4AD, 0x4526, 0x81, 0xF2, 0x49, 0x46, 0xFB, 0x48, 0x1D, 0x98);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognitionListConstraintFactory> { define_guid(0x40F3CDC7, 0x562A, 0x426A, 0x9F, 0x3B, 0x3B, 0x4E, 0x28, 0x2B, 0xE1, 0xD5);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognitionGrammarFileConstraint> { define_guid(0xB5031A8F, 0x85CA, 0x4FA4, 0xB1, 0x1A, 0x47, 0x4F, 0xC4, 0x1B, 0x38, 0x35);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognitionGrammarFileConstraintFactory> { define_guid(0x3DA770EB, 0xC479, 0x4C27, 0x9F, 0x19, 0x89, 0x97, 0x4E, 0xF3, 0x92, 0xD1);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognitionVoiceCommandDefinitionConstraint> { define_guid(0xF2791C2B, 0x1EF4, 0x4AE7, 0x9D, 0x77, 0xB6, 0xFF, 0x10, 0xB8, 0xA3, 0xC2);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognitionQualityDegradingEventArgs> { define_guid(0x4FE24105, 0x8C3A, 0x4C7E, 0x8D, 0xA, 0x5B, 0xD4, 0xF5, 0xB1, 0x4A, 0xD8);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognizerStateChangedEventArgs> { define_guid(0x563D4F09, 0xBA03, 0x4BAD, 0xAD, 0x81, 0xDD, 0xC6, 0xC4, 0xDA, 0xB0, 0xC3);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognizer> { define_guid(0xBC3C9CB, 0xC26A, 0x40F2, 0xAE, 0xB5, 0x80, 0x96, 0xB2, 0xE4, 0x80, 0x73);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognizerStatics2> { define_guid(0x1D1B0D95, 0x7565, 0x4EF9, 0xA2, 0xF3, 0xBA, 0x15, 0x16, 0x2A, 0x96, 0xCF);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognizerStatics> { define_guid(0x87A35EAC, 0xA7DC, 0x4B0B, 0xBC, 0xC9, 0x24, 0xF4, 0x7C, 0xB, 0x7E, 0xBF);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognizerFactory> { define_guid(0x60C488DD, 0x7FB8, 0x4033, 0xAC, 0x70, 0xD0, 0x46, 0xF6, 0x48, 0x18, 0xE1);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognizer2> { define_guid(0x63C9BAF1, 0x91E3, 0x4EA4, 0x86, 0xA1, 0x7C, 0x38, 0x67, 0xD0, 0x84, 0xA6);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechContinuousRecognitionSession> { define_guid(0x6A213C04, 0x6614, 0x49F8, 0x99, 0xA2, 0xB5, 0xE9, 0xB3, 0xA0, 0x85, 0xC8);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognitionHypothesisGeneratedEventArgs> { define_guid(0x55161A7A, 0x8023, 0x5866, 0x41, 0x1D, 0x12, 0x13, 0xBB, 0x27, 0x14, 0x76);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechRecognitionHypothesis> { define_guid(0x7A7B25B0, 0x99C5, 0x4F7D, 0xBF, 0x84, 0x10, 0xAA, 0x13, 0x2, 0xB6, 0x34);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechContinuousRecognitionCompletedEventArgs> { define_guid(0xE3D069BB, 0xE30C, 0x5E18, 0x42, 0x4B, 0x7F, 0xBE, 0x81, 0xF8, 0xFB, 0xD0);};
template<> struct uuid<Windows::Media::SpeechRecognition::ISpeechContinuousRecognitionResultGeneratedEventArgs> { define_guid(0x19091E1E, 0x6E7E, 0x5A46, 0x40, 0xFB, 0x76, 0x59, 0x4F, 0x78, 0x65, 0x4);};
template<> struct uuid<Windows::Media::SpeechRecognition::IVoiceCommandManager> { define_guid(0xAA3A8DD5, 0xB6E7, 0x4EE2, 0xBA, 0xA9, 0xDD, 0x6B, 0xAC, 0xED, 0xA, 0x2B);};
template<> struct uuid<Windows::Media::SpeechRecognition::IVoiceCommandSet> { define_guid(0xBEDDA75, 0x46E6, 0x4B11, 0xA0, 0x88, 0x5C, 0x68, 0x63, 0x28, 0x99, 0xB5);};

// types

namespace Windows { namespace Media { namespace SpeechRecognition {

// ISpeechRecognitionCompilationResult
struct ISpeechRecognitionCompilationResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(SpeechRecognitionResultStatus *value);
};
template<typename X> struct ISpeechRecognitionCompilationResult_adaptor : X {
	union {
		struct : property {
			SpeechRecognitionResultStatus get() { SpeechRecognitionResultStatus value; hrcheck(enc(&ISpeechRecognitionCompilationResult_adaptor::Status)->_get_Status(&value)); return value; }
			SpeechRecognitionResultStatus operator()() { return get(); }
			operator SpeechRecognitionResultStatus () { return get(); }
		} Status;
	};
	ISpeechRecognitionCompilationResult_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognitionCompilationResult, X> : Windows::Media::SpeechRecognition::ISpeechRecognitionCompilationResult_adaptor<X> { typedef adapt ISpeechRecognitionCompilationResult; };
struct ISpeechRecognitionCompilationResult : ISpeechRecognitionCompilationResult_raw, generate<ISpeechRecognitionCompilationResult> {};

// ISpeechRecognizerTimeouts
struct ISpeechRecognizerTimeouts_raw : IInspectable {
	virtual STDMETHODIMP _get_InitialSilenceTimeout(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_InitialSilenceTimeout(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_EndSilenceTimeout(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_EndSilenceTimeout(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_BabbleTimeout(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_BabbleTimeout(Foundation::TimeSpan value);
};
template<typename X> struct ISpeechRecognizerTimeouts_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ISpeechRecognizerTimeouts_adaptor::BabbleTimeout)->_get_BabbleTimeout(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ISpeechRecognizerTimeouts_adaptor::BabbleTimeout)->_put_BabbleTimeout(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} BabbleTimeout;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ISpeechRecognizerTimeouts_adaptor::EndSilenceTimeout)->_get_EndSilenceTimeout(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ISpeechRecognizerTimeouts_adaptor::EndSilenceTimeout)->_put_EndSilenceTimeout(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} EndSilenceTimeout;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ISpeechRecognizerTimeouts_adaptor::InitialSilenceTimeout)->_get_InitialSilenceTimeout(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ISpeechRecognizerTimeouts_adaptor::InitialSilenceTimeout)->_put_InitialSilenceTimeout(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} InitialSilenceTimeout;
	};
	ISpeechRecognizerTimeouts_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognizerTimeouts, X> : Windows::Media::SpeechRecognition::ISpeechRecognizerTimeouts_adaptor<X> { typedef adapt ISpeechRecognizerTimeouts; };
struct ISpeechRecognizerTimeouts : ISpeechRecognizerTimeouts_raw, generate<ISpeechRecognizerTimeouts> {};

// ISpeechRecognizerUIOptions
struct ISpeechRecognizerUIOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_ExampleText(HSTRING *value);
	virtual STDMETHODIMP _put_ExampleText(HSTRING value);
	virtual STDMETHODIMP _get_AudiblePrompt(HSTRING *value);
	virtual STDMETHODIMP _put_AudiblePrompt(HSTRING value);
	virtual STDMETHODIMP _get_IsReadBackEnabled(bool *value);
	virtual STDMETHODIMP _put_IsReadBackEnabled(bool value);
	virtual STDMETHODIMP _get_ShowConfirmation(bool *value);
	virtual STDMETHODIMP _put_ShowConfirmation(bool value);
};
template<typename X> struct ISpeechRecognizerUIOptions_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISpeechRecognizerUIOptions_adaptor::AudiblePrompt)->_get_AudiblePrompt(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISpeechRecognizerUIOptions_adaptor::AudiblePrompt)->_put_AudiblePrompt(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} AudiblePrompt;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISpeechRecognizerUIOptions_adaptor::ExampleText)->_get_ExampleText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISpeechRecognizerUIOptions_adaptor::ExampleText)->_put_ExampleText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ExampleText;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISpeechRecognizerUIOptions_adaptor::IsReadBackEnabled)->_get_IsReadBackEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISpeechRecognizerUIOptions_adaptor::IsReadBackEnabled)->_put_IsReadBackEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsReadBackEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISpeechRecognizerUIOptions_adaptor::ShowConfirmation)->_get_ShowConfirmation(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISpeechRecognizerUIOptions_adaptor::ShowConfirmation)->_put_ShowConfirmation(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ShowConfirmation;
	};
	ISpeechRecognizerUIOptions_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognizerUIOptions, X> : Windows::Media::SpeechRecognition::ISpeechRecognizerUIOptions_adaptor<X> { typedef adapt ISpeechRecognizerUIOptions; };
struct ISpeechRecognizerUIOptions : ISpeechRecognizerUIOptions_raw, generate<ISpeechRecognizerUIOptions> {};

// ISpeechRecognitionResult
struct ISpeechRecognitionResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(SpeechRecognitionResultStatus *value);
	virtual STDMETHODIMP _get_Text(HSTRING *value);
	virtual STDMETHODIMP _get_Confidence(SpeechRecognitionConfidence *value);
	virtual STDMETHODIMP _get_SemanticInterpretation(SpeechRecognitionSemanticInterpretation* *value);
	virtual STDMETHODIMP _GetAlternates(unsigned maxAlternates, Foundation::Collections::IVectorView<SpeechRecognitionResult*>* *alternates);
	virtual STDMETHODIMP _get_Constraint(ISpeechRecognitionConstraint* *value);
	virtual STDMETHODIMP _get_RulePath(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _get_RawConfidence(double *value);
};
template<typename X> struct ISpeechRecognitionResult_adaptor : X {
	union {
		struct : property {
			SpeechRecognitionConfidence get() { SpeechRecognitionConfidence value; hrcheck(enc(&ISpeechRecognitionResult_adaptor::Confidence)->_get_Confidence(&value)); return value; }
			SpeechRecognitionConfidence operator()() { return get(); }
			operator SpeechRecognitionConfidence () { return get(); }
		} Confidence;
		struct : property {
			ptr<ISpeechRecognitionConstraint> get() { ISpeechRecognitionConstraint* value; hrcheck(enc(&ISpeechRecognitionResult_adaptor::Constraint)->_get_Constraint(&value)); return from_abi(value); }
			ptr<ISpeechRecognitionConstraint> operator()() { return get(); }
			operator ptr<ISpeechRecognitionConstraint> () { return get(); }
			ptr<ISpeechRecognitionConstraint> operator->() { return get(); }
		} Constraint;
		struct : property {
			double get() { double value; hrcheck(enc(&ISpeechRecognitionResult_adaptor::RawConfidence)->_get_RawConfidence(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} RawConfidence;
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&ISpeechRecognitionResult_adaptor::RulePath)->_get_RulePath(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} RulePath;
		struct : property {
			ptr<SpeechRecognitionSemanticInterpretation> get() { SpeechRecognitionSemanticInterpretation* value; hrcheck(enc(&ISpeechRecognitionResult_adaptor::SemanticInterpretation)->_get_SemanticInterpretation(&value)); return from_abi(value); }
			ptr<SpeechRecognitionSemanticInterpretation> operator()() { return get(); }
			operator ptr<SpeechRecognitionSemanticInterpretation> () { return get(); }
			ptr<SpeechRecognitionSemanticInterpretation> operator->() { return get(); }
		} SemanticInterpretation;
		struct : property {
			SpeechRecognitionResultStatus get() { SpeechRecognitionResultStatus value; hrcheck(enc(&ISpeechRecognitionResult_adaptor::Status)->_get_Status(&value)); return value; }
			SpeechRecognitionResultStatus operator()() { return get(); }
			operator SpeechRecognitionResultStatus () { return get(); }
		} Status;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISpeechRecognitionResult_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Text;
	};
	ptr<Foundation::Collections::IVectorView<ptr<SpeechRecognitionResult>>> GetAlternates(unsigned maxAlternates) { Foundation::Collections::IVectorView<SpeechRecognitionResult*>* alternates; hrcheck(X::get()->_GetAlternates(maxAlternates, &alternates)); return from_abi(alternates); }
	ISpeechRecognitionResult_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognitionResult, X> : Windows::Media::SpeechRecognition::ISpeechRecognitionResult_adaptor<X> { typedef adapt ISpeechRecognitionResult; };
struct ISpeechRecognitionResult : ISpeechRecognitionResult_raw, generate<ISpeechRecognitionResult> {};

// ISpeechRecognitionSemanticInterpretation
struct ISpeechRecognitionSemanticInterpretation_raw : IInspectable {
	virtual STDMETHODIMP _get_Properties(Foundation::Collections::IMapView<HSTRING, Foundation::Collections::IVectorView<HSTRING>*>* *value);
};
template<typename X> struct ISpeechRecognitionSemanticInterpretation_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, ptr<Foundation::Collections::IVectorView<hstring>>>> get() { Foundation::Collections::IMapView<HSTRING, Foundation::Collections::IVectorView<HSTRING>*>* value; hrcheck(enc(&ISpeechRecognitionSemanticInterpretation_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<Foundation::Collections::IVectorView<hstring>>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, ptr<Foundation::Collections::IVectorView<hstring>>>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<Foundation::Collections::IVectorView<hstring>>>> operator->() { return get(); }
		} Properties;
	};
	ISpeechRecognitionSemanticInterpretation_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognitionSemanticInterpretation, X> : Windows::Media::SpeechRecognition::ISpeechRecognitionSemanticInterpretation_adaptor<X> { typedef adapt ISpeechRecognitionSemanticInterpretation; };
struct ISpeechRecognitionSemanticInterpretation : ISpeechRecognitionSemanticInterpretation_raw, generate<ISpeechRecognitionSemanticInterpretation> {};

// SpeechRecognitionSemanticInterpretation
template<typename X> struct statics<SpeechRecognitionSemanticInterpretation, X> : X {
	typedef typename X::root_type SpeechRecognitionSemanticInterpretation;
};
struct SpeechRecognitionSemanticInterpretation : generate<SpeechRecognitionSemanticInterpretation> {};

// ISpeechRecognitionResult2
struct ISpeechRecognitionResult2_raw : IInspectable {
	virtual STDMETHODIMP _get_PhraseStartTime(Foundation::DateTime *value);
	virtual STDMETHODIMP _get_PhraseDuration(Foundation::TimeSpan *value);
};
template<typename X> struct ISpeechRecognitionResult2_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ISpeechRecognitionResult2_adaptor::PhraseDuration)->_get_PhraseDuration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} PhraseDuration;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&ISpeechRecognitionResult2_adaptor::PhraseStartTime)->_get_PhraseStartTime(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} PhraseStartTime;
	};
	ISpeechRecognitionResult2_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognitionResult2, X> : Windows::Media::SpeechRecognition::ISpeechRecognitionResult2_adaptor<X> { typedef adapt ISpeechRecognitionResult2; };
struct ISpeechRecognitionResult2 : ISpeechRecognitionResult2_raw, generate<ISpeechRecognitionResult2> {};

// SpeechRecognitionResult
template<typename X> struct statics<SpeechRecognitionResult, X> : X {
	typedef typename X::root_type SpeechRecognitionResult;
};
struct SpeechRecognitionResult : generate<SpeechRecognitionResult> {};

// ISpeechRecognitionConstraint
struct ISpeechRecognitionConstraint_raw : IInspectable {
	virtual STDMETHODIMP _get_IsEnabled(bool *value) = 0;
	virtual STDMETHODIMP _put_IsEnabled(bool value) = 0;
	virtual STDMETHODIMP _get_Tag(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_Tag(HSTRING value) = 0;
	virtual STDMETHODIMP _get_Type(SpeechRecognitionConstraintType *value) = 0;
	virtual STDMETHODIMP _get_Probability(SpeechRecognitionConstraintProbability *value) = 0;
	virtual STDMETHODIMP _put_Probability(SpeechRecognitionConstraintProbability value) = 0;
};
template<typename X> struct ISpeechRecognitionConstraint_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISpeechRecognitionConstraint_adaptor::IsEnabled)->_get_IsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISpeechRecognitionConstraint_adaptor::IsEnabled)->_put_IsEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsEnabled;
		struct : property {
			SpeechRecognitionConstraintProbability get() { SpeechRecognitionConstraintProbability value; hrcheck(enc(&ISpeechRecognitionConstraint_adaptor::Probability)->_get_Probability(&value)); return value; }
			SpeechRecognitionConstraintProbability operator()() { return get(); }
			operator SpeechRecognitionConstraintProbability () { return get(); }
			void put(SpeechRecognitionConstraintProbability value) { hrcheck(enc(&ISpeechRecognitionConstraint_adaptor::Probability)->_put_Probability(value)); }
			void operator=(SpeechRecognitionConstraintProbability value) { put(value); }
			void operator()(SpeechRecognitionConstraintProbability value) { put(value); }
		} Probability;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISpeechRecognitionConstraint_adaptor::Tag)->_get_Tag(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISpeechRecognitionConstraint_adaptor::Tag)->_put_Tag(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Tag;
		struct : property {
			SpeechRecognitionConstraintType get() { SpeechRecognitionConstraintType value; hrcheck(enc(&ISpeechRecognitionConstraint_adaptor::Type)->_get_Type(&value)); return value; }
			SpeechRecognitionConstraintType operator()() { return get(); }
			operator SpeechRecognitionConstraintType () { return get(); }
		} Type;
	};
	ISpeechRecognitionConstraint_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognitionConstraint, X> : Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint_adaptor<X> { typedef adapt ISpeechRecognitionConstraint; };
template<typename X> struct ISpeechRecognitionConstraint_unadaptor : X {
	STDMETHODIMP _get_IsEnabled(bool *value) { return hrtry([&, this] { get_prop(value, IsEnabled); }); }
	STDMETHODIMP _put_IsEnabled(bool value) { return hrtry([&, this] { put_prop(value, IsEnabled); }); }
	STDMETHODIMP _get_Tag(HSTRING *value) { return hrtry([&, this] { get_prop(value, Tag); }); }
	STDMETHODIMP _put_Tag(HSTRING value) { return hrtry([&, this] { put_prop(value, Tag); }); }
	STDMETHODIMP _get_Type(SpeechRecognitionConstraintType *value) { return hrtry([&, this] { get_prop(value, Type); }); }
	STDMETHODIMP _get_Probability(SpeechRecognitionConstraintProbability *value) { return hrtry([&, this] { get_prop(value, Probability); }); }
	STDMETHODIMP _put_Probability(SpeechRecognitionConstraintProbability value) { return hrtry([&, this] { put_prop(value, Probability); }); }
};
template<typename X> struct unadapt<ISpeechRecognitionConstraint, X> : Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint_unadaptor<X> {};
struct ISpeechRecognitionConstraint : ISpeechRecognitionConstraint_raw, generate<ISpeechRecognitionConstraint> {};

// ISpeechRecognitionTopicConstraint
struct ISpeechRecognitionTopicConstraint_raw : IInspectable {
	virtual STDMETHODIMP _get_Scenario(SpeechRecognitionScenario *value);
	virtual STDMETHODIMP _get_TopicHint(HSTRING *value);
};
template<typename X> struct ISpeechRecognitionTopicConstraint_adaptor : X {
	union {
		struct : property {
			SpeechRecognitionScenario get() { SpeechRecognitionScenario value; hrcheck(enc(&ISpeechRecognitionTopicConstraint_adaptor::Scenario)->_get_Scenario(&value)); return value; }
			SpeechRecognitionScenario operator()() { return get(); }
			operator SpeechRecognitionScenario () { return get(); }
		} Scenario;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISpeechRecognitionTopicConstraint_adaptor::TopicHint)->_get_TopicHint(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} TopicHint;
	};
	ISpeechRecognitionTopicConstraint_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognitionTopicConstraint, X> : Windows::Media::SpeechRecognition::ISpeechRecognitionTopicConstraint_adaptor<X> { typedef adapt ISpeechRecognitionTopicConstraint; };
struct ISpeechRecognitionTopicConstraint : ISpeechRecognitionTopicConstraint_raw, generate<ISpeechRecognitionTopicConstraint> {};

// ISpeechRecognitionTopicConstraintFactory
struct ISpeechRecognitionTopicConstraintFactory : IInspectable {
	virtual STDMETHODIMP _Create(SpeechRecognitionScenario scenario, HSTRING topicHint, SpeechRecognitionTopicConstraint* *constraint);
	virtual STDMETHODIMP _CreateWithTag(SpeechRecognitionScenario scenario, HSTRING topicHint, HSTRING tag, SpeechRecognitionTopicConstraint* *constraint);
};

// SpeechRecognitionTopicConstraint
template<typename> struct SpeechRecognitionTopicConstraint_statics {
	static SpeechRecognitionTopicConstraint *activate(SpeechRecognitionScenario scenario, hstring_ref topicHint) { SpeechRecognitionTopicConstraint *constraint; hrcheck(get_activation_factory<SpeechRecognitionTopicConstraint, ISpeechRecognitionTopicConstraintFactory>()->_Create(scenario, topicHint, &constraint)); return constraint; }
	static SpeechRecognitionTopicConstraint *activate(SpeechRecognitionScenario scenario, hstring_ref topicHint, hstring_ref tag) { SpeechRecognitionTopicConstraint *constraint; hrcheck(get_activation_factory<SpeechRecognitionTopicConstraint, ISpeechRecognitionTopicConstraintFactory>()->_CreateWithTag(scenario, topicHint, tag, &constraint)); return constraint; }
};

template<typename X> struct statics<SpeechRecognitionTopicConstraint, X> : X, Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint_statics<void> {
	using Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint_statics<void>::activate;
	typedef typename X::root_type SpeechRecognitionTopicConstraint;
};
struct SpeechRecognitionTopicConstraint : generate<SpeechRecognitionTopicConstraint> {};

// ISpeechRecognitionListConstraint
struct ISpeechRecognitionListConstraint_raw : IInspectable {
	virtual STDMETHODIMP _get_Commands(Foundation::Collections::IVector<HSTRING>* *value);
};
template<typename X> struct ISpeechRecognitionListConstraint_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&ISpeechRecognitionListConstraint_adaptor::Commands)->_get_Commands(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} Commands;
	};
	ISpeechRecognitionListConstraint_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognitionListConstraint, X> : Windows::Media::SpeechRecognition::ISpeechRecognitionListConstraint_adaptor<X> { typedef adapt ISpeechRecognitionListConstraint; };
struct ISpeechRecognitionListConstraint : ISpeechRecognitionListConstraint_raw, generate<ISpeechRecognitionListConstraint> {};

// ISpeechRecognitionListConstraintFactory
struct ISpeechRecognitionListConstraintFactory : IInspectable {
	virtual STDMETHODIMP _Create(Foundation::Collections::IIterable<HSTRING>* commands, SpeechRecognitionListConstraint* *constraint);
	virtual STDMETHODIMP _CreateWithTag(Foundation::Collections::IIterable<HSTRING>* commands, HSTRING tag, SpeechRecognitionListConstraint* *constraint);
};

// SpeechRecognitionListConstraint
template<typename> struct SpeechRecognitionListConstraint_statics {
	static SpeechRecognitionListConstraint *activate(pptr<Foundation::Collections::IIterable<hstring>> commands) { SpeechRecognitionListConstraint *constraint; hrcheck(get_activation_factory<SpeechRecognitionListConstraint, ISpeechRecognitionListConstraintFactory>()->_Create(to_abi(commands), &constraint)); return constraint; }
	static SpeechRecognitionListConstraint *activate(pptr<Foundation::Collections::IIterable<hstring>> commands, hstring_ref tag) { SpeechRecognitionListConstraint *constraint; hrcheck(get_activation_factory<SpeechRecognitionListConstraint, ISpeechRecognitionListConstraintFactory>()->_CreateWithTag(to_abi(commands), tag, &constraint)); return constraint; }
};

template<typename X> struct statics<SpeechRecognitionListConstraint, X> : X, Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint_statics<void> {
	using Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint_statics<void>::activate;
	typedef typename X::root_type SpeechRecognitionListConstraint;
};
struct SpeechRecognitionListConstraint : generate<SpeechRecognitionListConstraint> {};

// ISpeechRecognitionGrammarFileConstraint
struct ISpeechRecognitionGrammarFileConstraint_raw : IInspectable {
	virtual STDMETHODIMP _get_GrammarFile(Storage::StorageFile* *value);
};
template<typename X> struct ISpeechRecognitionGrammarFileConstraint_adaptor : X {
	union {
		struct : property {
			ptr<Storage::StorageFile> get() { Storage::StorageFile* value; hrcheck(enc(&ISpeechRecognitionGrammarFileConstraint_adaptor::GrammarFile)->_get_GrammarFile(&value)); return from_abi(value); }
			ptr<Storage::StorageFile> operator()() { return get(); }
			operator ptr<Storage::StorageFile> () { return get(); }
			ptr<Storage::StorageFile> operator->() { return get(); }
		} GrammarFile;
	};
	ISpeechRecognitionGrammarFileConstraint_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognitionGrammarFileConstraint, X> : Windows::Media::SpeechRecognition::ISpeechRecognitionGrammarFileConstraint_adaptor<X> { typedef adapt ISpeechRecognitionGrammarFileConstraint; };
struct ISpeechRecognitionGrammarFileConstraint : ISpeechRecognitionGrammarFileConstraint_raw, generate<ISpeechRecognitionGrammarFileConstraint> {};

// ISpeechRecognitionGrammarFileConstraintFactory
struct ISpeechRecognitionGrammarFileConstraintFactory : IInspectable {
	virtual STDMETHODIMP _Create(Storage::StorageFile* file, SpeechRecognitionGrammarFileConstraint* *constraint);
	virtual STDMETHODIMP _CreateWithTag(Storage::StorageFile* file, HSTRING tag, SpeechRecognitionGrammarFileConstraint* *constraint);
};

// SpeechRecognitionGrammarFileConstraint
template<typename> struct SpeechRecognitionGrammarFileConstraint_statics {
	static SpeechRecognitionGrammarFileConstraint *activate(pptr<Storage::StorageFile> file) { SpeechRecognitionGrammarFileConstraint *constraint; hrcheck(get_activation_factory<SpeechRecognitionGrammarFileConstraint, ISpeechRecognitionGrammarFileConstraintFactory>()->_Create(file, &constraint)); return constraint; }
	static SpeechRecognitionGrammarFileConstraint *activate(pptr<Storage::StorageFile> file, hstring_ref tag) { SpeechRecognitionGrammarFileConstraint *constraint; hrcheck(get_activation_factory<SpeechRecognitionGrammarFileConstraint, ISpeechRecognitionGrammarFileConstraintFactory>()->_CreateWithTag(file, tag, &constraint)); return constraint; }
};

template<typename X> struct statics<SpeechRecognitionGrammarFileConstraint, X> : X, Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint_statics<void> {
	using Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint_statics<void>::activate;
	typedef typename X::root_type SpeechRecognitionGrammarFileConstraint;
};
struct SpeechRecognitionGrammarFileConstraint : generate<SpeechRecognitionGrammarFileConstraint> {};

// ISpeechRecognitionVoiceCommandDefinitionConstraint
struct ISpeechRecognitionVoiceCommandDefinitionConstraint : IInspectable, generate<ISpeechRecognitionVoiceCommandDefinitionConstraint> {};

// ISpeechRecognitionQualityDegradingEventArgs
struct ISpeechRecognitionQualityDegradingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Problem(SpeechRecognitionAudioProblem *value);
};
template<typename X> struct ISpeechRecognitionQualityDegradingEventArgs_adaptor : X {
	union {
		struct : property {
			SpeechRecognitionAudioProblem get() { SpeechRecognitionAudioProblem value; hrcheck(enc(&ISpeechRecognitionQualityDegradingEventArgs_adaptor::Problem)->_get_Problem(&value)); return value; }
			SpeechRecognitionAudioProblem operator()() { return get(); }
			operator SpeechRecognitionAudioProblem () { return get(); }
		} Problem;
	};
	ISpeechRecognitionQualityDegradingEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognitionQualityDegradingEventArgs, X> : Windows::Media::SpeechRecognition::ISpeechRecognitionQualityDegradingEventArgs_adaptor<X> { typedef adapt ISpeechRecognitionQualityDegradingEventArgs; };
struct ISpeechRecognitionQualityDegradingEventArgs : ISpeechRecognitionQualityDegradingEventArgs_raw, generate<ISpeechRecognitionQualityDegradingEventArgs> {};

// ISpeechRecognizerStateChangedEventArgs
struct ISpeechRecognizerStateChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_State(SpeechRecognizerState *value);
};
template<typename X> struct ISpeechRecognizerStateChangedEventArgs_adaptor : X {
	union {
		struct : property {
			SpeechRecognizerState get() { SpeechRecognizerState value; hrcheck(enc(&ISpeechRecognizerStateChangedEventArgs_adaptor::State)->_get_State(&value)); return value; }
			SpeechRecognizerState operator()() { return get(); }
			operator SpeechRecognizerState () { return get(); }
		} State;
	};
	ISpeechRecognizerStateChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognizerStateChangedEventArgs, X> : Windows::Media::SpeechRecognition::ISpeechRecognizerStateChangedEventArgs_adaptor<X> { typedef adapt ISpeechRecognizerStateChangedEventArgs; };
struct ISpeechRecognizerStateChangedEventArgs : ISpeechRecognizerStateChangedEventArgs_raw, generate<ISpeechRecognizerStateChangedEventArgs> {};

// ISpeechRecognizer
struct ISpeechRecognizer_raw : IInspectable {
	virtual STDMETHODIMP _get_CurrentLanguage(Globalization::Language* *language);
	virtual STDMETHODIMP _get_Constraints(Foundation::Collections::IVector<ISpeechRecognitionConstraint*>* *value);
	virtual STDMETHODIMP _get_Timeouts(SpeechRecognizerTimeouts* *value);
	virtual STDMETHODIMP _get_UIOptions(SpeechRecognizerUIOptions* *value);
	virtual STDMETHODIMP _CompileConstraintsAsync(Foundation::IAsyncOperation<SpeechRecognitionCompilationResult*>* *asyncOperation);
	virtual STDMETHODIMP _RecognizeAsync(Foundation::IAsyncOperation<SpeechRecognitionResult*>* *asyncOperation);
	virtual STDMETHODIMP _RecognizeWithUIAsync(Foundation::IAsyncOperation<SpeechRecognitionResult*>* *asyncOperation);
	virtual STDMETHODIMP _add_RecognitionQualityDegrading(Foundation::TypedEventHandler<SpeechRecognizer*, SpeechRecognitionQualityDegradingEventArgs*>* speechRecognitionQualityDegradingHandler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_RecognitionQualityDegrading(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _add_StateChanged(Foundation::TypedEventHandler<SpeechRecognizer*, SpeechRecognizerStateChangedEventArgs*>* stateChangedHandler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_StateChanged(Foundation::EventRegistrationToken cookie);
};
template<typename X> struct ISpeechRecognizer_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<ISpeechRecognitionConstraint>>> get() { Foundation::Collections::IVector<ISpeechRecognitionConstraint*>* value; hrcheck(enc(&ISpeechRecognizer_adaptor::Constraints)->_get_Constraints(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<ISpeechRecognitionConstraint>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<ISpeechRecognitionConstraint>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<ISpeechRecognitionConstraint>>> operator->() { return get(); }
		} Constraints;
		struct : property {
			ptr<Globalization::Language> get() { Globalization::Language* language; hrcheck(enc(&ISpeechRecognizer_adaptor::CurrentLanguage)->_get_CurrentLanguage(&language)); return from_abi(language); }
			ptr<Globalization::Language> operator()() { return get(); }
			operator ptr<Globalization::Language> () { return get(); }
			ptr<Globalization::Language> operator->() { return get(); }
		} CurrentLanguage;
		struct : property {
			ptr<SpeechRecognizerTimeouts> get() { SpeechRecognizerTimeouts* value; hrcheck(enc(&ISpeechRecognizer_adaptor::Timeouts)->_get_Timeouts(&value)); return from_abi(value); }
			ptr<SpeechRecognizerTimeouts> operator()() { return get(); }
			operator ptr<SpeechRecognizerTimeouts> () { return get(); }
			ptr<SpeechRecognizerTimeouts> operator->() { return get(); }
		} Timeouts;
		struct : property {
			ptr<SpeechRecognizerUIOptions> get() { SpeechRecognizerUIOptions* value; hrcheck(enc(&ISpeechRecognizer_adaptor::UIOptions)->_get_UIOptions(&value)); return from_abi(value); }
			ptr<SpeechRecognizerUIOptions> operator()() { return get(); }
			operator ptr<SpeechRecognizerUIOptions> () { return get(); }
			ptr<SpeechRecognizerUIOptions> operator->() { return get(); }
		} UIOptions;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SpeechRecognizer>, ptr<SpeechRecognitionQualityDegradingEventArgs>>> speechRecognitionQualityDegradingHandler) { Foundation::EventRegistrationToken cookie; hrcheck(enc(&ISpeechRecognizer_adaptor::RecognitionQualityDegrading)->_add_RecognitionQualityDegrading(to_abi(speechRecognitionQualityDegradingHandler), &cookie)); return cookie; }
			void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(enc(&ISpeechRecognizer_adaptor::RecognitionQualityDegrading)->_remove_RecognitionQualityDegrading(cookie)); }
		} RecognitionQualityDegrading;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SpeechRecognizer>, ptr<SpeechRecognizerStateChangedEventArgs>>> stateChangedHandler) { Foundation::EventRegistrationToken cookie; hrcheck(enc(&ISpeechRecognizer_adaptor::StateChanged)->_add_StateChanged(to_abi(stateChangedHandler), &cookie)); return cookie; }
			void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(enc(&ISpeechRecognizer_adaptor::StateChanged)->_remove_StateChanged(cookie)); }
		} StateChanged;
	};
	ptr<Foundation::IAsyncOperation<ptr<SpeechRecognitionCompilationResult>>> CompileConstraintsAsync() { Foundation::IAsyncOperation<SpeechRecognitionCompilationResult*>* asyncOperation; hrcheck(X::get()->_CompileConstraintsAsync(&asyncOperation)); return from_abi(asyncOperation); }
	ptr<Foundation::IAsyncOperation<ptr<SpeechRecognitionResult>>> RecognizeAsync() { Foundation::IAsyncOperation<SpeechRecognitionResult*>* asyncOperation; hrcheck(X::get()->_RecognizeAsync(&asyncOperation)); return from_abi(asyncOperation); }
	ptr<Foundation::IAsyncOperation<ptr<SpeechRecognitionResult>>> RecognizeWithUIAsync() { Foundation::IAsyncOperation<SpeechRecognitionResult*>* asyncOperation; hrcheck(X::get()->_RecognizeWithUIAsync(&asyncOperation)); return from_abi(asyncOperation); }
	ISpeechRecognizer_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognizer, X> : Windows::Media::SpeechRecognition::ISpeechRecognizer_adaptor<X> { typedef adapt ISpeechRecognizer; };
struct ISpeechRecognizer : ISpeechRecognizer_raw, generate<ISpeechRecognizer> {};

// SpeechRecognizerTimeouts
template<typename X> struct statics<SpeechRecognizerTimeouts, X> : X {
	typedef typename X::root_type SpeechRecognizerTimeouts;
};
struct SpeechRecognizerTimeouts : generate<SpeechRecognizerTimeouts> {};

// SpeechRecognizerUIOptions
template<typename X> struct statics<SpeechRecognizerUIOptions, X> : X {
	typedef typename X::root_type SpeechRecognizerUIOptions;
};
struct SpeechRecognizerUIOptions : generate<SpeechRecognizerUIOptions> {};

// SpeechRecognitionCompilationResult
template<typename X> struct statics<SpeechRecognitionCompilationResult, X> : X {
	typedef typename X::root_type SpeechRecognitionCompilationResult;
};
struct SpeechRecognitionCompilationResult : generate<SpeechRecognitionCompilationResult> {};

// ISpeechRecognizerStatics2
struct ISpeechRecognizerStatics2 : IInspectable {
	virtual STDMETHODIMP _TrySetSystemSpeechLanguageAsync(Globalization::Language* speechLanguage, Foundation::IAsyncOperation<bool>* *result);
};

// ISpeechRecognizerStatics
struct ISpeechRecognizerStatics : IInspectable {
	virtual STDMETHODIMP _get_SystemSpeechLanguage(Globalization::Language* *language);
	virtual STDMETHODIMP _get_SupportedTopicLanguages(Foundation::Collections::IVectorView<Globalization::Language*>* *languages);
	virtual STDMETHODIMP _get_SupportedGrammarLanguages(Foundation::Collections::IVectorView<Globalization::Language*>* *languages);
};

// ISpeechRecognizerFactory
struct ISpeechRecognizerFactory : IInspectable {
	virtual STDMETHODIMP _Create(Globalization::Language* language, SpeechRecognizer* *recognizer);
};

// ISpeechRecognizer2
struct ISpeechRecognizer2_raw : IInspectable {
	virtual STDMETHODIMP _get_ContinuousRecognitionSession(SpeechContinuousRecognitionSession* *value);
	virtual STDMETHODIMP _get_State(SpeechRecognizerState *value);
	virtual STDMETHODIMP _StopRecognitionAsync(Foundation::IAsyncAction* *value);
	virtual STDMETHODIMP _add_HypothesisGenerated(Foundation::TypedEventHandler<SpeechRecognizer*, SpeechRecognitionHypothesisGeneratedEventArgs*>* value, Foundation::EventRegistrationToken *returnValue);
	virtual STDMETHODIMP _remove_HypothesisGenerated(Foundation::EventRegistrationToken value);
};
template<typename X> struct ISpeechRecognizer2_adaptor : X {
	union {
		struct : property {
			ptr<SpeechContinuousRecognitionSession> get() { SpeechContinuousRecognitionSession* value; hrcheck(enc(&ISpeechRecognizer2_adaptor::ContinuousRecognitionSession)->_get_ContinuousRecognitionSession(&value)); return from_abi(value); }
			ptr<SpeechContinuousRecognitionSession> operator()() { return get(); }
			operator ptr<SpeechContinuousRecognitionSession> () { return get(); }
			ptr<SpeechContinuousRecognitionSession> operator->() { return get(); }
		} ContinuousRecognitionSession;
		struct : property {
			SpeechRecognizerState get() { SpeechRecognizerState value; hrcheck(enc(&ISpeechRecognizer2_adaptor::State)->_get_State(&value)); return value; }
			SpeechRecognizerState operator()() { return get(); }
			operator SpeechRecognizerState () { return get(); }
		} State;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SpeechRecognizer>, ptr<SpeechRecognitionHypothesisGeneratedEventArgs>>> value) { Foundation::EventRegistrationToken returnValue; hrcheck(enc(&ISpeechRecognizer2_adaptor::HypothesisGenerated)->_add_HypothesisGenerated(to_abi(value), &returnValue)); return returnValue; }
			void operator-=(const Foundation::EventRegistrationToken& value) { hrcheck(enc(&ISpeechRecognizer2_adaptor::HypothesisGenerated)->_remove_HypothesisGenerated(value)); }
		} HypothesisGenerated;
	};
	ptr<Foundation::IAsyncAction> StopRecognitionAsync() { Foundation::IAsyncAction* value; hrcheck(X::get()->_StopRecognitionAsync(&value)); return from_abi(value); }
	ISpeechRecognizer2_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognizer2, X> : Windows::Media::SpeechRecognition::ISpeechRecognizer2_adaptor<X> { typedef adapt ISpeechRecognizer2; };
struct ISpeechRecognizer2 : ISpeechRecognizer2_raw, generate<ISpeechRecognizer2> {};

// SpeechRecognizer
template<typename> struct SpeechRecognizer_statics {
	static struct _SupportedGrammarLanguages : property {
		ptr<Foundation::Collections::IVectorView<ptr<Globalization::Language>>> get() { Foundation::Collections::IVectorView<Globalization::Language*>* languages; hrcheck(get_activation_factory<SpeechRecognizer, ISpeechRecognizerStatics>()->_get_SupportedGrammarLanguages(&languages)); return from_abi(languages); }
		ptr<Foundation::Collections::IVectorView<ptr<Globalization::Language>>> operator()() { return get(); }
		operator ptr<Foundation::Collections::IVectorView<ptr<Globalization::Language>>> () { return get(); }
		ptr<Foundation::Collections::IVectorView<ptr<Globalization::Language>>> operator->() { return get(); }
	} SupportedGrammarLanguages;
	static struct _SupportedTopicLanguages : property {
		ptr<Foundation::Collections::IVectorView<ptr<Globalization::Language>>> get() { Foundation::Collections::IVectorView<Globalization::Language*>* languages; hrcheck(get_activation_factory<SpeechRecognizer, ISpeechRecognizerStatics>()->_get_SupportedTopicLanguages(&languages)); return from_abi(languages); }
		ptr<Foundation::Collections::IVectorView<ptr<Globalization::Language>>> operator()() { return get(); }
		operator ptr<Foundation::Collections::IVectorView<ptr<Globalization::Language>>> () { return get(); }
		ptr<Foundation::Collections::IVectorView<ptr<Globalization::Language>>> operator->() { return get(); }
	} SupportedTopicLanguages;
	static struct _SystemSpeechLanguage : property {
		ptr<Globalization::Language> get() { Globalization::Language* language; hrcheck(get_activation_factory<SpeechRecognizer, ISpeechRecognizerStatics>()->_get_SystemSpeechLanguage(&language)); return from_abi(language); }
		ptr<Globalization::Language> operator()() { return get(); }
		operator ptr<Globalization::Language> () { return get(); }
		ptr<Globalization::Language> operator->() { return get(); }
	} SystemSpeechLanguage;
	static ptr<Foundation::IAsyncOperation<bool>> TrySetSystemSpeechLanguageAsync(pptr<Globalization::Language> speechLanguage) { Foundation::IAsyncOperation<bool>* result; hrcheck(get_activation_factory<SpeechRecognizer, ISpeechRecognizerStatics2>()->_TrySetSystemSpeechLanguageAsync(speechLanguage, &result)); return from_abi(result); }
	static SpeechRecognizer *activate() { SpeechRecognizer *t; get_activation_factory<SpeechRecognizer>()->ActivateInstance((IInspectable**)&t); return t; }
	static SpeechRecognizer *activate(pptr<Globalization::Language> language) { SpeechRecognizer *recognizer; hrcheck(get_activation_factory<SpeechRecognizer, ISpeechRecognizerFactory>()->_Create(language, &recognizer)); return recognizer; }
};
template<typename X> typename SpeechRecognizer_statics<X>::_SupportedGrammarLanguages SpeechRecognizer_statics<X>::SupportedGrammarLanguages;
template<typename X> typename SpeechRecognizer_statics<X>::_SupportedTopicLanguages SpeechRecognizer_statics<X>::SupportedTopicLanguages;
template<typename X> typename SpeechRecognizer_statics<X>::_SystemSpeechLanguage SpeechRecognizer_statics<X>::SystemSpeechLanguage;

template<typename X> struct statics<SpeechRecognizer, X> : X, Windows::Media::SpeechRecognition::SpeechRecognizer_statics<void> {
	using Windows::Media::SpeechRecognition::SpeechRecognizer_statics<void>::activate;
	typedef typename X::root_type SpeechRecognizer;
};
struct SpeechRecognizer : generate<SpeechRecognizer> {};

// SpeechRecognitionQualityDegradingEventArgs
template<typename X> struct statics<SpeechRecognitionQualityDegradingEventArgs, X> : X {
	typedef typename X::root_type SpeechRecognitionQualityDegradingEventArgs;
};
struct SpeechRecognitionQualityDegradingEventArgs : generate<SpeechRecognitionQualityDegradingEventArgs> {};

// SpeechRecognizerStateChangedEventArgs
template<typename X> struct statics<SpeechRecognizerStateChangedEventArgs, X> : X {
	typedef typename X::root_type SpeechRecognizerStateChangedEventArgs;
};
struct SpeechRecognizerStateChangedEventArgs : generate<SpeechRecognizerStateChangedEventArgs> {};

// SpeechRecognitionVoiceCommandDefinitionConstraint
template<typename X> struct statics<SpeechRecognitionVoiceCommandDefinitionConstraint, X> : X {
	typedef typename X::root_type SpeechRecognitionVoiceCommandDefinitionConstraint;
};
struct SpeechRecognitionVoiceCommandDefinitionConstraint : generate<SpeechRecognitionVoiceCommandDefinitionConstraint> {};

// ISpeechContinuousRecognitionSession
struct ISpeechContinuousRecognitionSession_raw : IInspectable {
	virtual STDMETHODIMP _get_AutoStopSilenceTimeout(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_AutoStopSilenceTimeout(Foundation::TimeSpan value);
	virtual STDMETHODIMP _StartAsync(Foundation::IAsyncAction* *value);
	virtual STDMETHODIMP _StartWithModeAsync(SpeechContinuousRecognitionMode mode, Foundation::IAsyncAction* *value);
	virtual STDMETHODIMP _StopAsync(Foundation::IAsyncAction* *value);
	virtual STDMETHODIMP _CancelAsync(Foundation::IAsyncAction* *value);
	virtual STDMETHODIMP _PauseAsync(Foundation::IAsyncAction* *value);
	virtual STDMETHODIMP _Resume();
	virtual STDMETHODIMP _add_Completed(Foundation::TypedEventHandler<SpeechContinuousRecognitionSession*, SpeechContinuousRecognitionCompletedEventArgs*>* value, Foundation::EventRegistrationToken *returnValue);
	virtual STDMETHODIMP _remove_Completed(Foundation::EventRegistrationToken value);
	virtual STDMETHODIMP _add_ResultGenerated(Foundation::TypedEventHandler<SpeechContinuousRecognitionSession*, SpeechContinuousRecognitionResultGeneratedEventArgs*>* value, Foundation::EventRegistrationToken *returnValue);
	virtual STDMETHODIMP _remove_ResultGenerated(Foundation::EventRegistrationToken value);
};
template<typename X> struct ISpeechContinuousRecognitionSession_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ISpeechContinuousRecognitionSession_adaptor::AutoStopSilenceTimeout)->_get_AutoStopSilenceTimeout(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ISpeechContinuousRecognitionSession_adaptor::AutoStopSilenceTimeout)->_put_AutoStopSilenceTimeout(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} AutoStopSilenceTimeout;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SpeechContinuousRecognitionSession>, ptr<SpeechContinuousRecognitionCompletedEventArgs>>> value) { Foundation::EventRegistrationToken returnValue; hrcheck(enc(&ISpeechContinuousRecognitionSession_adaptor::Completed)->_add_Completed(to_abi(value), &returnValue)); return returnValue; }
			void operator-=(const Foundation::EventRegistrationToken& value) { hrcheck(enc(&ISpeechContinuousRecognitionSession_adaptor::Completed)->_remove_Completed(value)); }
		} Completed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SpeechContinuousRecognitionSession>, ptr<SpeechContinuousRecognitionResultGeneratedEventArgs>>> value) { Foundation::EventRegistrationToken returnValue; hrcheck(enc(&ISpeechContinuousRecognitionSession_adaptor::ResultGenerated)->_add_ResultGenerated(to_abi(value), &returnValue)); return returnValue; }
			void operator-=(const Foundation::EventRegistrationToken& value) { hrcheck(enc(&ISpeechContinuousRecognitionSession_adaptor::ResultGenerated)->_remove_ResultGenerated(value)); }
		} ResultGenerated;
	};
	ptr<Foundation::IAsyncAction> StartAsync() { Foundation::IAsyncAction* value; hrcheck(X::get()->_StartAsync(&value)); return from_abi(value); }
	ptr<Foundation::IAsyncAction> StartAsync(SpeechContinuousRecognitionMode mode) { Foundation::IAsyncAction* value; hrcheck(X::get()->_StartWithModeAsync(mode, &value)); return from_abi(value); }
	ptr<Foundation::IAsyncAction> StopAsync() { Foundation::IAsyncAction* value; hrcheck(X::get()->_StopAsync(&value)); return from_abi(value); }
	ptr<Foundation::IAsyncAction> CancelAsync() { Foundation::IAsyncAction* value; hrcheck(X::get()->_CancelAsync(&value)); return from_abi(value); }
	ptr<Foundation::IAsyncAction> PauseAsync() { Foundation::IAsyncAction* value; hrcheck(X::get()->_PauseAsync(&value)); return from_abi(value); }
	void Resume() { hrcheck(X::get()->_Resume()); }
	ISpeechContinuousRecognitionSession_adaptor() {}
};
template<typename X> struct adapt<ISpeechContinuousRecognitionSession, X> : Windows::Media::SpeechRecognition::ISpeechContinuousRecognitionSession_adaptor<X> { typedef adapt ISpeechContinuousRecognitionSession; };
struct ISpeechContinuousRecognitionSession : ISpeechContinuousRecognitionSession_raw, generate<ISpeechContinuousRecognitionSession> {};

// SpeechContinuousRecognitionSession
template<typename X> struct statics<SpeechContinuousRecognitionSession, X> : X {
	typedef typename X::root_type SpeechContinuousRecognitionSession;
};
struct SpeechContinuousRecognitionSession : generate<SpeechContinuousRecognitionSession> {
	using ISpeechContinuousRecognitionSession::StartAsync;
};

// ISpeechRecognitionHypothesisGeneratedEventArgs
struct ISpeechRecognitionHypothesisGeneratedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Hypothesis(SpeechRecognitionHypothesis* *value);
};
template<typename X> struct ISpeechRecognitionHypothesisGeneratedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<SpeechRecognitionHypothesis> get() { SpeechRecognitionHypothesis* value; hrcheck(enc(&ISpeechRecognitionHypothesisGeneratedEventArgs_adaptor::Hypothesis)->_get_Hypothesis(&value)); return from_abi(value); }
			ptr<SpeechRecognitionHypothesis> operator()() { return get(); }
			operator ptr<SpeechRecognitionHypothesis> () { return get(); }
			ptr<SpeechRecognitionHypothesis> operator->() { return get(); }
		} Hypothesis;
	};
	ISpeechRecognitionHypothesisGeneratedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognitionHypothesisGeneratedEventArgs, X> : Windows::Media::SpeechRecognition::ISpeechRecognitionHypothesisGeneratedEventArgs_adaptor<X> { typedef adapt ISpeechRecognitionHypothesisGeneratedEventArgs; };
struct ISpeechRecognitionHypothesisGeneratedEventArgs : ISpeechRecognitionHypothesisGeneratedEventArgs_raw, generate<ISpeechRecognitionHypothesisGeneratedEventArgs> {};

// SpeechRecognitionHypothesisGeneratedEventArgs
template<typename X> struct statics<SpeechRecognitionHypothesisGeneratedEventArgs, X> : X {
	typedef typename X::root_type SpeechRecognitionHypothesisGeneratedEventArgs;
};
struct SpeechRecognitionHypothesisGeneratedEventArgs : generate<SpeechRecognitionHypothesisGeneratedEventArgs> {};

// ISpeechRecognitionHypothesis
struct ISpeechRecognitionHypothesis_raw : IInspectable {
	virtual STDMETHODIMP _get_Text(HSTRING *value);
};
template<typename X> struct ISpeechRecognitionHypothesis_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISpeechRecognitionHypothesis_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Text;
	};
	ISpeechRecognitionHypothesis_adaptor() {}
};
template<typename X> struct adapt<ISpeechRecognitionHypothesis, X> : Windows::Media::SpeechRecognition::ISpeechRecognitionHypothesis_adaptor<X> { typedef adapt ISpeechRecognitionHypothesis; };
struct ISpeechRecognitionHypothesis : ISpeechRecognitionHypothesis_raw, generate<ISpeechRecognitionHypothesis> {};

// SpeechRecognitionHypothesis
template<typename X> struct statics<SpeechRecognitionHypothesis, X> : X {
	typedef typename X::root_type SpeechRecognitionHypothesis;
};
struct SpeechRecognitionHypothesis : generate<SpeechRecognitionHypothesis> {};

// ISpeechContinuousRecognitionCompletedEventArgs
struct ISpeechContinuousRecognitionCompletedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(SpeechRecognitionResultStatus *value);
};
template<typename X> struct ISpeechContinuousRecognitionCompletedEventArgs_adaptor : X {
	union {
		struct : property {
			SpeechRecognitionResultStatus get() { SpeechRecognitionResultStatus value; hrcheck(enc(&ISpeechContinuousRecognitionCompletedEventArgs_adaptor::Status)->_get_Status(&value)); return value; }
			SpeechRecognitionResultStatus operator()() { return get(); }
			operator SpeechRecognitionResultStatus () { return get(); }
		} Status;
	};
	ISpeechContinuousRecognitionCompletedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISpeechContinuousRecognitionCompletedEventArgs, X> : Windows::Media::SpeechRecognition::ISpeechContinuousRecognitionCompletedEventArgs_adaptor<X> { typedef adapt ISpeechContinuousRecognitionCompletedEventArgs; };
struct ISpeechContinuousRecognitionCompletedEventArgs : ISpeechContinuousRecognitionCompletedEventArgs_raw, generate<ISpeechContinuousRecognitionCompletedEventArgs> {};

// SpeechContinuousRecognitionCompletedEventArgs
template<typename X> struct statics<SpeechContinuousRecognitionCompletedEventArgs, X> : X {
	typedef typename X::root_type SpeechContinuousRecognitionCompletedEventArgs;
};
struct SpeechContinuousRecognitionCompletedEventArgs : generate<SpeechContinuousRecognitionCompletedEventArgs> {};

// ISpeechContinuousRecognitionResultGeneratedEventArgs
struct ISpeechContinuousRecognitionResultGeneratedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Result(SpeechRecognitionResult* *value);
};
template<typename X> struct ISpeechContinuousRecognitionResultGeneratedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<SpeechRecognitionResult> get() { SpeechRecognitionResult* value; hrcheck(enc(&ISpeechContinuousRecognitionResultGeneratedEventArgs_adaptor::Result)->_get_Result(&value)); return from_abi(value); }
			ptr<SpeechRecognitionResult> operator()() { return get(); }
			operator ptr<SpeechRecognitionResult> () { return get(); }
			ptr<SpeechRecognitionResult> operator->() { return get(); }
		} Result;
	};
	ISpeechContinuousRecognitionResultGeneratedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISpeechContinuousRecognitionResultGeneratedEventArgs, X> : Windows::Media::SpeechRecognition::ISpeechContinuousRecognitionResultGeneratedEventArgs_adaptor<X> { typedef adapt ISpeechContinuousRecognitionResultGeneratedEventArgs; };
struct ISpeechContinuousRecognitionResultGeneratedEventArgs : ISpeechContinuousRecognitionResultGeneratedEventArgs_raw, generate<ISpeechContinuousRecognitionResultGeneratedEventArgs> {};

// SpeechContinuousRecognitionResultGeneratedEventArgs
template<typename X> struct statics<SpeechContinuousRecognitionResultGeneratedEventArgs, X> : X {
	typedef typename X::root_type SpeechContinuousRecognitionResultGeneratedEventArgs;
};
struct SpeechContinuousRecognitionResultGeneratedEventArgs : generate<SpeechContinuousRecognitionResultGeneratedEventArgs> {};

// IVoiceCommandManager
struct IVoiceCommandManager : IInspectable {
	virtual STDMETHODIMP _InstallCommandSetsFromStorageFileAsync(Storage::StorageFile* file, Foundation::IAsyncAction* *installAction);
	virtual STDMETHODIMP _get_InstalledCommandSets(Foundation::Collections::IMapView<HSTRING, VoiceCommandSet*>* *voiceCommandSets);
};

// VoiceCommandManager
template<typename> struct VoiceCommandManager_statics {
	static struct _InstalledCommandSets : property {
		ptr<Foundation::Collections::IMapView<hstring, ptr<VoiceCommandSet>>> get() { Foundation::Collections::IMapView<HSTRING, VoiceCommandSet*>* voiceCommandSets; hrcheck(get_activation_factory<VoiceCommandManager, IVoiceCommandManager>()->_get_InstalledCommandSets(&voiceCommandSets)); return from_abi(voiceCommandSets); }
		ptr<Foundation::Collections::IMapView<hstring, ptr<VoiceCommandSet>>> operator()() { return get(); }
		operator ptr<Foundation::Collections::IMapView<hstring, ptr<VoiceCommandSet>>> () { return get(); }
		ptr<Foundation::Collections::IMapView<hstring, ptr<VoiceCommandSet>>> operator->() { return get(); }
	} InstalledCommandSets;
	static ptr<Foundation::IAsyncAction> InstallCommandSetsFromStorageFileAsync(pptr<Storage::StorageFile> file) { Foundation::IAsyncAction* installAction; hrcheck(get_activation_factory<VoiceCommandManager, IVoiceCommandManager>()->_InstallCommandSetsFromStorageFileAsync(file, &installAction)); return from_abi(installAction); }
};
template<typename X> typename VoiceCommandManager_statics<X>::_InstalledCommandSets VoiceCommandManager_statics<X>::InstalledCommandSets;

template<typename X> struct statics<VoiceCommandManager, X> : X, Windows::Media::SpeechRecognition::VoiceCommandManager_statics<void> {
	typedef typename X::root_type VoiceCommandManager;
};
struct VoiceCommandManager : generate<VoiceCommandManager> {};

// IVoiceCommandSet
struct IVoiceCommandSet_raw : IInspectable {
	virtual STDMETHODIMP _get_Language(HSTRING *value);
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _SetPhraseListAsync(HSTRING phraseListName, Foundation::Collections::IIterable<HSTRING>* phraseList, Foundation::IAsyncAction* *updateAction);
};
template<typename X> struct IVoiceCommandSet_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVoiceCommandSet_adaptor::Language)->_get_Language(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Language;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVoiceCommandSet_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
	};
	ptr<Foundation::IAsyncAction> SetPhraseListAsync(hstring_ref phraseListName, pptr<Foundation::Collections::IIterable<hstring>> phraseList) { Foundation::IAsyncAction* updateAction; hrcheck(X::get()->_SetPhraseListAsync(phraseListName, to_abi(phraseList), &updateAction)); return from_abi(updateAction); }
	IVoiceCommandSet_adaptor() {}
};
template<typename X> struct adapt<IVoiceCommandSet, X> : Windows::Media::SpeechRecognition::IVoiceCommandSet_adaptor<X> { typedef adapt IVoiceCommandSet; };
struct IVoiceCommandSet : IVoiceCommandSet_raw, generate<IVoiceCommandSet> {};

// VoiceCommandSet
template<typename X> struct statics<VoiceCommandSet, X> : X {
	typedef typename X::root_type VoiceCommandSet;
};
struct VoiceCommandSet : generate<VoiceCommandSet> {};
}}}
} // namespace iso_winrt
