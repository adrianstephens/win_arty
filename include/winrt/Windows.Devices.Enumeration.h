#pragma once
// generated by isopod tools
// namespaces:
// Windows.Devices.Enumeration

#include "Windows.Devices.Enumeration.0.h"
#include "Windows.UI.Popups.0.h"
#include "Windows.UI.0.h"
#include "Windows.Foundation.Collections.h"
#include "Windows.Storage.Streams.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace ApplicationModel { namespace Background {
struct DeviceWatcherTrigger;
}}}

// defs

template<> struct def<Windows::Devices::Enumeration::IDeviceConnectionChangeTriggerDetails> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails> : class_type<Platform::Object, Windows::Devices::Enumeration::IDeviceConnectionChangeTriggerDetails> {};
template<> struct def<Windows::Devices::Enumeration::DevicePickerDisplayStatusOptions> : enum_type<unsigned> {};
template<> struct def<Windows::Devices::Enumeration::IDevicePickerAppearance> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DevicePickerAppearance> : class_type<Platform::Object, Windows::Devices::Enumeration::IDevicePickerAppearance> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceSelectedEventArgs> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DeviceSelectedEventArgs> : class_type<Platform::Object, Windows::Devices::Enumeration::IDeviceSelectedEventArgs> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceDisconnectButtonClickedEventArgs> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs> : class_type<Platform::Object, Windows::Devices::Enumeration::IDeviceDisconnectButtonClickedEventArgs> {};
template<> struct def<Windows::Devices::Enumeration::DeviceClass> : enum_type<int> {};
template<> struct def<Windows::Devices::Enumeration::IDevicePickerFilter> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DevicePickerFilter> : class_type<Platform::Object, Windows::Devices::Enumeration::IDevicePickerFilter> {};
template<> struct def<Windows::Devices::Enumeration::IDevicePicker> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DevicePicker> : class_type<Platform::Object, Windows::Devices::Enumeration::IDevicePicker> {};
template<> struct def<Windows::Devices::Enumeration::DeviceWatcherStatus> : enum_type<int> {};
template<> struct def<Windows::Devices::Enumeration::DeviceThumbnail> : class_type<Platform::Object, Windows::Storage::Streams::IRandomAccessStreamWithContentType, Windows::Storage::Streams::IContentTypeProvider, Windows::Storage::Streams::IRandomAccessStream, Windows::Storage::Streams::IOutputStream, Windows::Foundation::IClosable, Windows::Storage::Streams::IInputStream> {};
template<> struct def<Windows::Devices::Enumeration::Panel> : enum_type<int> {};
template<> struct def<Windows::Devices::Enumeration::IEnclosureLocation> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::IEnclosureLocation2> : interface_type<Windows::Devices::Enumeration::IEnclosureLocation> {};
template<> struct def<Windows::Devices::Enumeration::EnclosureLocation> : class_type<Platform::Object, Windows::Devices::Enumeration::IEnclosureLocation, Windows::Devices::Enumeration::IEnclosureLocation2> {};
template<> struct def<Windows::Devices::Enumeration::DeviceInformationKind> : enum_type<int> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceInformationUpdate> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceInformationUpdate2> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DeviceInformationUpdate> : class_type<Platform::Object, Windows::Devices::Enumeration::IDeviceInformationUpdate, Windows::Devices::Enumeration::IDeviceInformationUpdate2> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceInformationStatics2> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceInformationStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceInformation2> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceInformation> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DeviceInformation> : class_type<Platform::Object, Windows::Devices::Enumeration::IDeviceInformation, Windows::Devices::Enumeration::IDeviceInformation2> {};
template<> struct def<Windows::Devices::Enumeration::DeviceInformationCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVectorView<ptr<Windows::Devices::Enumeration::DeviceInformation>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Devices::Enumeration::DeviceInformation>>> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceWatcher> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DeviceWatcherEventKind> : enum_type<int> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceWatcher2> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DeviceWatcher> : class_type<Platform::Object, Windows::Devices::Enumeration::IDeviceWatcher, Windows::Devices::Enumeration::IDeviceWatcher2> {};
template<> struct def<Windows::Devices::Enumeration::DevicePairingKinds> : enum_type<unsigned> {};
template<> struct def<Windows::Devices::Enumeration::DevicePairingResultStatus> : enum_type<int> {};
template<> struct def<Windows::Devices::Enumeration::DeviceUnpairingResultStatus> : enum_type<int> {};
template<> struct def<Windows::Devices::Enumeration::DevicePairingProtectionLevel> : enum_type<int> {};
template<> struct def<Windows::Devices::Enumeration::IDevicePairingResult> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DevicePairingResult> : class_type<Platform::Object, Windows::Devices::Enumeration::IDevicePairingResult> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceUnpairingResult> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DeviceUnpairingResult> : class_type<Platform::Object, Windows::Devices::Enumeration::IDeviceUnpairingResult> {};
template<> struct def<Windows::Devices::Enumeration::IDevicePairingSettings> : overridable_type<> {};
template<> struct def<Windows::Devices::Enumeration::IDevicePairingRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DevicePairingRequestedEventArgs> : class_type<Platform::Object, Windows::Devices::Enumeration::IDevicePairingRequestedEventArgs> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceInformationCustomPairing> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DeviceInformationCustomPairing> : class_type<Platform::Object, Windows::Devices::Enumeration::IDeviceInformationCustomPairing> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceInformationPairing> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceInformationPairing2> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceInformationPairingStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DeviceInformationPairing> : class_type<Platform::Object, Windows::Devices::Enumeration::IDeviceInformationPairing, Windows::Devices::Enumeration::IDeviceInformationPairing2> {};
template<> struct def<Windows::Devices::Enumeration::DeviceAccessStatus> : enum_type<int> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceAccessChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceAccessChangedEventArgs2> : interface_type<Windows::Devices::Enumeration::IDeviceAccessChangedEventArgs> {};
template<> struct def<Windows::Devices::Enumeration::DeviceAccessChangedEventArgs> : class_type<Platform::Object, Windows::Devices::Enumeration::IDeviceAccessChangedEventArgs, Windows::Devices::Enumeration::IDeviceAccessChangedEventArgs2> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceAccessInformation> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceAccessInformationStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DeviceAccessInformation> : class_type<Platform::Object, Windows::Devices::Enumeration::IDeviceAccessInformation> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceWatcherEvent> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DeviceWatcherEvent> : class_type<Platform::Object, Windows::Devices::Enumeration::IDeviceWatcherEvent> {};
template<> struct def<Windows::Devices::Enumeration::IDeviceWatcherTriggerDetails> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::DeviceWatcherTriggerDetails> : class_type<Platform::Object, Windows::Devices::Enumeration::IDeviceWatcherTriggerDetails> {};

// uuids

template<> struct uuid<Windows::Devices::Enumeration::IDeviceConnectionChangeTriggerDetails> { define_guid(0xB8578C0C, 0xBBC1, 0x484B, 0xBF, 0xFA, 0x7B, 0x31, 0xDC, 0xC2, 0x0, 0xB2);};
template<> struct uuid<Windows::Devices::Enumeration::IDevicePickerAppearance> { define_guid(0xE69A12C6, 0xE627, 0x4ED8, 0x9B, 0x6C, 0x46, 0xA, 0xF4, 0x45, 0xE5, 0x6D);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceSelectedEventArgs> { define_guid(0x269EDADE, 0x1D2F, 0x4940, 0x84, 0x2, 0x41, 0x56, 0xB8, 0x1D, 0x3C, 0x77);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceDisconnectButtonClickedEventArgs> { define_guid(0x8E44B56D, 0xF902, 0x4A00, 0xB5, 0x36, 0xF3, 0x79, 0x92, 0xE6, 0xA2, 0xA7);};
template<> struct uuid<Windows::Devices::Enumeration::IDevicePickerFilter> { define_guid(0x91DB92A2, 0x57CB, 0x48F1, 0x9B, 0x59, 0xA5, 0x9B, 0x7A, 0x1F, 0x2, 0xA2);};
template<> struct uuid<Windows::Devices::Enumeration::IDevicePicker> { define_guid(0x84997AA2, 0x34A, 0x4440, 0x88, 0x13, 0x7D, 0xB, 0xD4, 0x79, 0xBF, 0x5A);};
template<> struct uuid<Windows::Devices::Enumeration::IEnclosureLocation> { define_guid(0x42340A27, 0x5810, 0x459C, 0xAA, 0xBB, 0xC6, 0x5E, 0x1F, 0x81, 0x3E, 0xCF);};
template<> struct uuid<Windows::Devices::Enumeration::IEnclosureLocation2> { define_guid(0x2885995B, 0xE07D, 0x485D, 0x8A, 0x9E, 0xBD, 0xF2, 0x9A, 0xEF, 0x4F, 0x66);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceInformationUpdate> { define_guid(0x8F315305, 0xD972, 0x44B7, 0xA3, 0x7E, 0x9E, 0x82, 0x2C, 0x78, 0x21, 0x3B);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceInformationUpdate2> { define_guid(0x5D9D148C, 0xA873, 0x485E, 0xBA, 0xA6, 0xAA, 0x62, 0x7, 0x88, 0xE3, 0xCC);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceInformationStatics2> { define_guid(0x493B4F34, 0xA84F, 0x45FD, 0x91, 0x67, 0x15, 0xD1, 0xCB, 0x1B, 0xD1, 0xF9);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceInformationStatics> { define_guid(0xC17F100E, 0x3A46, 0x4A78, 0x80, 0x13, 0x76, 0x9D, 0xC9, 0xB9, 0x73, 0x90);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceInformation2> { define_guid(0xF156A638, 0x7997, 0x48D9, 0xA1, 0xC, 0x26, 0x9D, 0x46, 0x53, 0x3F, 0x48);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceInformation> { define_guid(0xABA0FB95, 0x4398, 0x489D, 0x8E, 0x44, 0xE6, 0x13, 0x9, 0x27, 0x1, 0x1F);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceWatcher> { define_guid(0xC9EAB97D, 0x8F6B, 0x4F96, 0xA9, 0xF4, 0xAB, 0xC8, 0x14, 0xE2, 0x22, 0x71);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceWatcher2> { define_guid(0xFF08456E, 0xED14, 0x49E9, 0x9A, 0x69, 0x81, 0x17, 0xC5, 0x4A, 0xE9, 0x71);};
template<> struct uuid<Windows::Devices::Enumeration::IDevicePairingResult> { define_guid(0x72B02BF, 0xDD95, 0x4025, 0x9B, 0x37, 0xDE, 0x51, 0xAD, 0xBA, 0x37, 0xB7);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceUnpairingResult> { define_guid(0x66F44AD3, 0x79D9, 0x444B, 0x92, 0xCF, 0xA9, 0x2E, 0xF7, 0x25, 0x71, 0xC7);};
template<> struct uuid<Windows::Devices::Enumeration::IDevicePairingSettings> { define_guid(0x482CB27C, 0x83BB, 0x420E, 0xBE, 0x51, 0x66, 0x2, 0xB2, 0x22, 0xDE, 0x54);};
template<> struct uuid<Windows::Devices::Enumeration::IDevicePairingRequestedEventArgs> { define_guid(0xF717FC56, 0xDE6B, 0x487F, 0x83, 0x76, 0x1, 0x80, 0xAC, 0xA6, 0x99, 0x63);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceInformationCustomPairing> { define_guid(0x85138C02, 0x4EE6, 0x4914, 0x83, 0x70, 0x10, 0x7A, 0x39, 0x14, 0x4C, 0xE);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceInformationPairing> { define_guid(0x2C4769F5, 0xF684, 0x40D5, 0x84, 0x69, 0xE8, 0xDB, 0xAA, 0xB7, 0x4, 0x85);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceInformationPairing2> { define_guid(0xF68612FD, 0xAEE, 0x4328, 0x85, 0xCC, 0x1C, 0x74, 0x2B, 0xB1, 0x79, 0xD);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceInformationPairingStatics> { define_guid(0xE915C408, 0x36D4, 0x49A1, 0xBF, 0x13, 0x51, 0x41, 0x73, 0x79, 0x9B, 0x6B);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceAccessChangedEventArgs> { define_guid(0xDEDA0BCC, 0x4F9D, 0x4F58, 0x9D, 0xBA, 0xA9, 0xBC, 0x80, 0x4, 0x8, 0xD5);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceAccessChangedEventArgs2> { define_guid(0x82523262, 0x934B, 0x4B30, 0xA1, 0x78, 0xAD, 0xC3, 0x9F, 0x2F, 0x2B, 0xE3);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceAccessInformation> { define_guid(0xBAA9A73, 0x6DE5, 0x4915, 0x8D, 0xDD, 0x9A, 0x5, 0x54, 0xA6, 0xF5, 0x45);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceAccessInformationStatics> { define_guid(0x574BD3D3, 0x5F30, 0x45CD, 0x8A, 0x94, 0x72, 0x4F, 0xE5, 0x97, 0x30, 0x84);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceWatcherEvent> { define_guid(0x74AA9C0B, 0x1DBD, 0x47FD, 0xB6, 0x35, 0x3C, 0xC5, 0x56, 0xD0, 0xFF, 0x8B);};
template<> struct uuid<Windows::Devices::Enumeration::IDeviceWatcherTriggerDetails> { define_guid(0x38808119, 0x4CB7, 0x4E57, 0xA5, 0x6D, 0x77, 0x6D, 0x7, 0xCB, 0xFE, 0xF9);};

// types

namespace Windows { namespace Devices { namespace Enumeration {

// IDeviceConnectionChangeTriggerDetails
struct IDeviceConnectionChangeTriggerDetails_raw : IInspectable {
	virtual STDMETHODIMP _get_DeviceId(HSTRING *value);
};
template<typename X> struct IDeviceConnectionChangeTriggerDetails_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDeviceConnectionChangeTriggerDetails_adaptor::DeviceId)->_get_DeviceId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DeviceId;
	};
	IDeviceConnectionChangeTriggerDetails_adaptor() {}
};
template<typename X> struct adapt<IDeviceConnectionChangeTriggerDetails, X> : Windows::Devices::Enumeration::IDeviceConnectionChangeTriggerDetails_adaptor<X> { typedef adapt IDeviceConnectionChangeTriggerDetails; };
struct IDeviceConnectionChangeTriggerDetails : IDeviceConnectionChangeTriggerDetails_raw, generate<IDeviceConnectionChangeTriggerDetails> {};

// DeviceConnectionChangeTriggerDetails
template<typename X> struct statics<DeviceConnectionChangeTriggerDetails, X> : X {
	typedef typename X::root_type DeviceConnectionChangeTriggerDetails;
};
struct DeviceConnectionChangeTriggerDetails : generate<DeviceConnectionChangeTriggerDetails> {};

// IDevicePickerAppearance
struct IDevicePickerAppearance_raw : IInspectable {
	virtual STDMETHODIMP _get_Title(HSTRING *value);
	virtual STDMETHODIMP _put_Title(HSTRING value);
	virtual STDMETHODIMP _get_ForegroundColor(UI::Color *value);
	virtual STDMETHODIMP _put_ForegroundColor(UI::Color value);
	virtual STDMETHODIMP _get_BackgroundColor(UI::Color *value);
	virtual STDMETHODIMP _put_BackgroundColor(UI::Color value);
	virtual STDMETHODIMP _get_AccentColor(UI::Color *value);
	virtual STDMETHODIMP _put_AccentColor(UI::Color value);
	virtual STDMETHODIMP _get_SelectedForegroundColor(UI::Color *value);
	virtual STDMETHODIMP _put_SelectedForegroundColor(UI::Color value);
	virtual STDMETHODIMP _get_SelectedBackgroundColor(UI::Color *value);
	virtual STDMETHODIMP _put_SelectedBackgroundColor(UI::Color value);
	virtual STDMETHODIMP _get_SelectedAccentColor(UI::Color *value);
	virtual STDMETHODIMP _put_SelectedAccentColor(UI::Color value);
};
template<typename X> struct IDevicePickerAppearance_adaptor : X {
	union {
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&IDevicePickerAppearance_adaptor::AccentColor)->_get_AccentColor(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IDevicePickerAppearance_adaptor::AccentColor)->_put_AccentColor(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} AccentColor;
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&IDevicePickerAppearance_adaptor::BackgroundColor)->_get_BackgroundColor(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IDevicePickerAppearance_adaptor::BackgroundColor)->_put_BackgroundColor(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} BackgroundColor;
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&IDevicePickerAppearance_adaptor::ForegroundColor)->_get_ForegroundColor(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IDevicePickerAppearance_adaptor::ForegroundColor)->_put_ForegroundColor(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} ForegroundColor;
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&IDevicePickerAppearance_adaptor::SelectedAccentColor)->_get_SelectedAccentColor(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IDevicePickerAppearance_adaptor::SelectedAccentColor)->_put_SelectedAccentColor(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} SelectedAccentColor;
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&IDevicePickerAppearance_adaptor::SelectedBackgroundColor)->_get_SelectedBackgroundColor(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IDevicePickerAppearance_adaptor::SelectedBackgroundColor)->_put_SelectedBackgroundColor(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} SelectedBackgroundColor;
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&IDevicePickerAppearance_adaptor::SelectedForegroundColor)->_get_SelectedForegroundColor(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IDevicePickerAppearance_adaptor::SelectedForegroundColor)->_put_SelectedForegroundColor(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} SelectedForegroundColor;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDevicePickerAppearance_adaptor::Title)->_get_Title(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDevicePickerAppearance_adaptor::Title)->_put_Title(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Title;
	};
	IDevicePickerAppearance_adaptor() {}
};
template<typename X> struct adapt<IDevicePickerAppearance, X> : Windows::Devices::Enumeration::IDevicePickerAppearance_adaptor<X> { typedef adapt IDevicePickerAppearance; };
struct IDevicePickerAppearance : IDevicePickerAppearance_raw, generate<IDevicePickerAppearance> {};

// DevicePickerAppearance
template<typename X> struct statics<DevicePickerAppearance, X> : X {
	typedef typename X::root_type DevicePickerAppearance;
};
struct DevicePickerAppearance : generate<DevicePickerAppearance> {};

// IDeviceSelectedEventArgs
struct IDeviceSelectedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_SelectedDevice(DeviceInformation* *value);
};
template<typename X> struct IDeviceSelectedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<DeviceInformation> get() { DeviceInformation* value; hrcheck(enc(&IDeviceSelectedEventArgs_adaptor::SelectedDevice)->_get_SelectedDevice(&value)); return from_abi(value); }
			ptr<DeviceInformation> operator()() { return get(); }
			operator ptr<DeviceInformation> () { return get(); }
			ptr<DeviceInformation> operator->() { return get(); }
		} SelectedDevice;
	};
	IDeviceSelectedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDeviceSelectedEventArgs, X> : Windows::Devices::Enumeration::IDeviceSelectedEventArgs_adaptor<X> { typedef adapt IDeviceSelectedEventArgs; };
struct IDeviceSelectedEventArgs : IDeviceSelectedEventArgs_raw, generate<IDeviceSelectedEventArgs> {};

// DeviceSelectedEventArgs
template<typename X> struct statics<DeviceSelectedEventArgs, X> : X {
	typedef typename X::root_type DeviceSelectedEventArgs;
};
struct DeviceSelectedEventArgs : generate<DeviceSelectedEventArgs> {};

// IDeviceDisconnectButtonClickedEventArgs
struct IDeviceDisconnectButtonClickedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Device(DeviceInformation* *value);
};
template<typename X> struct IDeviceDisconnectButtonClickedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<DeviceInformation> get() { DeviceInformation* value; hrcheck(enc(&IDeviceDisconnectButtonClickedEventArgs_adaptor::Device)->_get_Device(&value)); return from_abi(value); }
			ptr<DeviceInformation> operator()() { return get(); }
			operator ptr<DeviceInformation> () { return get(); }
			ptr<DeviceInformation> operator->() { return get(); }
		} Device;
	};
	IDeviceDisconnectButtonClickedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDeviceDisconnectButtonClickedEventArgs, X> : Windows::Devices::Enumeration::IDeviceDisconnectButtonClickedEventArgs_adaptor<X> { typedef adapt IDeviceDisconnectButtonClickedEventArgs; };
struct IDeviceDisconnectButtonClickedEventArgs : IDeviceDisconnectButtonClickedEventArgs_raw, generate<IDeviceDisconnectButtonClickedEventArgs> {};

// DeviceDisconnectButtonClickedEventArgs
template<typename X> struct statics<DeviceDisconnectButtonClickedEventArgs, X> : X {
	typedef typename X::root_type DeviceDisconnectButtonClickedEventArgs;
};
struct DeviceDisconnectButtonClickedEventArgs : generate<DeviceDisconnectButtonClickedEventArgs> {};

// IDevicePickerFilter
struct IDevicePickerFilter_raw : IInspectable {
	virtual STDMETHODIMP _get_SupportedDeviceClasses(Foundation::Collections::IVector<DeviceClass>* *value);
	virtual STDMETHODIMP _get_SupportedDeviceSelectors(Foundation::Collections::IVector<HSTRING>* *value);
};
template<typename X> struct IDevicePickerFilter_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<DeviceClass>> get() { Foundation::Collections::IVector<DeviceClass>* value; hrcheck(enc(&IDevicePickerFilter_adaptor::SupportedDeviceClasses)->_get_SupportedDeviceClasses(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<DeviceClass>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<DeviceClass>> () { return get(); }
			ptr<Foundation::Collections::IVector<DeviceClass>> operator->() { return get(); }
		} SupportedDeviceClasses;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IDevicePickerFilter_adaptor::SupportedDeviceSelectors)->_get_SupportedDeviceSelectors(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} SupportedDeviceSelectors;
	};
	IDevicePickerFilter_adaptor() {}
};
template<typename X> struct adapt<IDevicePickerFilter, X> : Windows::Devices::Enumeration::IDevicePickerFilter_adaptor<X> { typedef adapt IDevicePickerFilter; };
struct IDevicePickerFilter : IDevicePickerFilter_raw, generate<IDevicePickerFilter> {};

// DevicePickerFilter
template<typename X> struct statics<DevicePickerFilter, X> : X {
	typedef typename X::root_type DevicePickerFilter;
};
struct DevicePickerFilter : generate<DevicePickerFilter> {};

// IDevicePicker
struct IDevicePicker_raw : IInspectable {
	virtual STDMETHODIMP _get_Filter(DevicePickerFilter* *filter);
	virtual STDMETHODIMP _get_Appearance(DevicePickerAppearance* *value);
	virtual STDMETHODIMP _get_RequestedProperties(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _add_DeviceSelected(Foundation::TypedEventHandler<DevicePicker*, DeviceSelectedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DeviceSelected(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DisconnectButtonClicked(Foundation::TypedEventHandler<DevicePicker*, DeviceDisconnectButtonClickedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DisconnectButtonClicked(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DevicePickerDismissed(Foundation::TypedEventHandler<DevicePicker*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DevicePickerDismissed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _Show(Foundation::Rect selection);
	virtual STDMETHODIMP _ShowWithPlacement(Foundation::Rect selection, UI::Popups::Placement placement);
	virtual STDMETHODIMP _PickSingleDeviceAsync(Foundation::Rect selection, Foundation::IAsyncOperation<DeviceInformation*>* *operation);
	virtual STDMETHODIMP _PickSingleDeviceAsyncWithPlacement(Foundation::Rect selection, UI::Popups::Placement placement, Foundation::IAsyncOperation<DeviceInformation*>* *operation);
	virtual STDMETHODIMP _Hide();
	virtual STDMETHODIMP _SetDisplayStatus(DeviceInformation* device, HSTRING status, DevicePickerDisplayStatusOptions options);
};
template<typename X> struct IDevicePicker_adaptor : X {
	union {
		struct : property {
			ptr<DevicePickerAppearance> get() { DevicePickerAppearance* value; hrcheck(enc(&IDevicePicker_adaptor::Appearance)->_get_Appearance(&value)); return from_abi(value); }
			ptr<DevicePickerAppearance> operator()() { return get(); }
			operator ptr<DevicePickerAppearance> () { return get(); }
			ptr<DevicePickerAppearance> operator->() { return get(); }
		} Appearance;
		struct : property {
			ptr<DevicePickerFilter> get() { DevicePickerFilter* filter; hrcheck(enc(&IDevicePicker_adaptor::Filter)->_get_Filter(&filter)); return from_abi(filter); }
			ptr<DevicePickerFilter> operator()() { return get(); }
			operator ptr<DevicePickerFilter> () { return get(); }
			ptr<DevicePickerFilter> operator->() { return get(); }
		} Filter;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IDevicePicker_adaptor::RequestedProperties)->_get_RequestedProperties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} RequestedProperties;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DevicePicker>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDevicePicker_adaptor::DevicePickerDismissed)->_add_DevicePickerDismissed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDevicePicker_adaptor::DevicePickerDismissed)->_remove_DevicePickerDismissed(token)); }
		} DevicePickerDismissed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DevicePicker>, ptr<DeviceSelectedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDevicePicker_adaptor::DeviceSelected)->_add_DeviceSelected(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDevicePicker_adaptor::DeviceSelected)->_remove_DeviceSelected(token)); }
		} DeviceSelected;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DevicePicker>, ptr<DeviceDisconnectButtonClickedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDevicePicker_adaptor::DisconnectButtonClicked)->_add_DisconnectButtonClicked(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDevicePicker_adaptor::DisconnectButtonClicked)->_remove_DisconnectButtonClicked(token)); }
		} DisconnectButtonClicked;
	};
	void Show(const Foundation::Rect& selection) { hrcheck(X::get()->_Show(selection)); }
	void Show(const Foundation::Rect& selection, UI::Popups::Placement placement) { hrcheck(X::get()->_ShowWithPlacement(selection, placement)); }
	ptr<Foundation::IAsyncOperation<ptr<DeviceInformation>>> PickSingleDeviceAsync(const Foundation::Rect& selection) { Foundation::IAsyncOperation<DeviceInformation*>* operation; hrcheck(X::get()->_PickSingleDeviceAsync(selection, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<DeviceInformation>>> PickSingleDeviceAsync(const Foundation::Rect& selection, UI::Popups::Placement placement) { Foundation::IAsyncOperation<DeviceInformation*>* operation; hrcheck(X::get()->_PickSingleDeviceAsyncWithPlacement(selection, placement, &operation)); return from_abi(operation); }
	void Hide() { hrcheck(X::get()->_Hide()); }
	void SetDisplayStatus(pptr<DeviceInformation> device, hstring_ref status, DevicePickerDisplayStatusOptions options) { hrcheck(X::get()->_SetDisplayStatus(device, status, options)); }
	IDevicePicker_adaptor() {}
};
template<typename X> struct adapt<IDevicePicker, X> : Windows::Devices::Enumeration::IDevicePicker_adaptor<X> { typedef adapt IDevicePicker; };
struct IDevicePicker : IDevicePicker_raw, generate<IDevicePicker> {};

// DevicePicker
template<typename X> struct statics<DevicePicker, X> : X {
	typedef typename X::root_type DevicePicker;
};
struct DevicePicker : generate<DevicePicker> {
	using IDevicePicker::PickSingleDeviceAsync;
	using IDevicePicker::Show;
};

// DeviceThumbnail
template<typename X> struct statics<DeviceThumbnail, X> : X {
	typedef typename X::root_type DeviceThumbnail;
};
struct DeviceThumbnail : generate<DeviceThumbnail> {};

// IEnclosureLocation
struct IEnclosureLocation_raw : IInspectable {
	virtual STDMETHODIMP _get_InDock(bool *value);
	virtual STDMETHODIMP _get_InLid(bool *value);
	virtual STDMETHODIMP _get_Panel(Enumeration::Panel *value);
};
template<typename X> struct IEnclosureLocation_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IEnclosureLocation_adaptor::InDock)->_get_InDock(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} InDock;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IEnclosureLocation_adaptor::InLid)->_get_InLid(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} InLid;
		struct : property {
			Enumeration::Panel get() { Enumeration::Panel value; hrcheck(enc(&IEnclosureLocation_adaptor::Panel)->_get_Panel(&value)); return value; }
			Enumeration::Panel operator()() { return get(); }
			operator Enumeration::Panel () { return get(); }
		} Panel;
	};
	IEnclosureLocation_adaptor() {}
};
template<typename X> struct adapt<IEnclosureLocation, X> : Windows::Devices::Enumeration::IEnclosureLocation_adaptor<X> { typedef adapt IEnclosureLocation; };
struct IEnclosureLocation : IEnclosureLocation_raw, generate<IEnclosureLocation> {};

// IEnclosureLocation2
struct IEnclosureLocation2_raw : IInspectable {
	virtual STDMETHODIMP _get_RotationAngleInDegreesClockwise(unsigned *value);
};
template<typename X> struct IEnclosureLocation2_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IEnclosureLocation2_adaptor::RotationAngleInDegreesClockwise)->_get_RotationAngleInDegreesClockwise(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} RotationAngleInDegreesClockwise;
	};
	IEnclosureLocation2_adaptor() {}
};
template<typename X> struct adapt<IEnclosureLocation2, X> : Windows::Devices::Enumeration::IEnclosureLocation2_adaptor<X> { typedef adapt IEnclosureLocation2; };
struct IEnclosureLocation2 : IEnclosureLocation2_raw, generate<IEnclosureLocation2> {};

// EnclosureLocation
template<typename X> struct statics<EnclosureLocation, X> : X {
	typedef typename X::root_type EnclosureLocation;
};
struct EnclosureLocation : generate<EnclosureLocation> {};

// IDeviceInformationUpdate
struct IDeviceInformationUpdate_raw : IInspectable {
	virtual STDMETHODIMP _get_Id(HSTRING *value);
	virtual STDMETHODIMP _get_Properties(Foundation::Collections::IMapView<HSTRING, IInspectable*>* *value);
};
template<typename X> struct IDeviceInformationUpdate_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDeviceInformationUpdate_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, object>> get() { Foundation::Collections::IMapView<HSTRING, IInspectable*>* value; hrcheck(enc(&IDeviceInformationUpdate_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMapView<hstring, object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, object>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, object>> operator->() { return get(); }
		} Properties;
	};
	IDeviceInformationUpdate_adaptor() {}
};
template<typename X> struct adapt<IDeviceInformationUpdate, X> : Windows::Devices::Enumeration::IDeviceInformationUpdate_adaptor<X> { typedef adapt IDeviceInformationUpdate; };
struct IDeviceInformationUpdate : IDeviceInformationUpdate_raw, generate<IDeviceInformationUpdate> {};

// IDeviceInformationUpdate2
struct IDeviceInformationUpdate2_raw : IInspectable {
	virtual STDMETHODIMP _get_Kind(DeviceInformationKind *value);
};
template<typename X> struct IDeviceInformationUpdate2_adaptor : X {
	union {
		struct : property {
			DeviceInformationKind get() { DeviceInformationKind value; hrcheck(enc(&IDeviceInformationUpdate2_adaptor::Kind)->_get_Kind(&value)); return value; }
			DeviceInformationKind operator()() { return get(); }
			operator DeviceInformationKind () { return get(); }
		} Kind;
	};
	IDeviceInformationUpdate2_adaptor() {}
};
template<typename X> struct adapt<IDeviceInformationUpdate2, X> : Windows::Devices::Enumeration::IDeviceInformationUpdate2_adaptor<X> { typedef adapt IDeviceInformationUpdate2; };
struct IDeviceInformationUpdate2 : IDeviceInformationUpdate2_raw, generate<IDeviceInformationUpdate2> {};

// DeviceInformationUpdate
template<typename X> struct statics<DeviceInformationUpdate, X> : X {
	typedef typename X::root_type DeviceInformationUpdate;
};
struct DeviceInformationUpdate : generate<DeviceInformationUpdate> {};

// IDeviceInformationStatics2
struct IDeviceInformationStatics2 : IInspectable {
	virtual STDMETHODIMP _GetAqsFilterFromDeviceClass(DeviceClass deviceClass, HSTRING *aqsFilter);
	virtual STDMETHODIMP _CreateFromIdAsyncWithKindAndAdditionalProperties(HSTRING deviceId, Foundation::Collections::IIterable<HSTRING>* additionalProperties, DeviceInformationKind kind, Foundation::IAsyncOperation<DeviceInformation*>* *asyncOp);
	virtual STDMETHODIMP _FindAllAsyncWithKindAqsFilterAndAdditionalProperties(HSTRING aqsFilter, Foundation::Collections::IIterable<HSTRING>* additionalProperties, DeviceInformationKind kind, Foundation::IAsyncOperation<DeviceInformationCollection*>* *asyncOp);
	virtual STDMETHODIMP _CreateWatcherWithKindAqsFilterAndAdditionalProperties(HSTRING aqsFilter, Foundation::Collections::IIterable<HSTRING>* additionalProperties, DeviceInformationKind kind, DeviceWatcher* *watcher);
};

// IDeviceInformationStatics
struct IDeviceInformationStatics : IInspectable {
	virtual STDMETHODIMP _CreateFromIdAsync(HSTRING deviceId, Foundation::IAsyncOperation<DeviceInformation*>* *asyncOp);
	virtual STDMETHODIMP _CreateFromIdAsyncAdditionalProperties(HSTRING deviceId, Foundation::Collections::IIterable<HSTRING>* additionalProperties, Foundation::IAsyncOperation<DeviceInformation*>* *asyncOp);
	virtual STDMETHODIMP _FindAllAsync(Foundation::IAsyncOperation<DeviceInformationCollection*>* *asyncOp);
	virtual STDMETHODIMP _FindAllAsyncDeviceClass(DeviceClass deviceClass, Foundation::IAsyncOperation<DeviceInformationCollection*>* *asyncOp);
	virtual STDMETHODIMP _FindAllAsyncAqsFilter(HSTRING aqsFilter, Foundation::IAsyncOperation<DeviceInformationCollection*>* *asyncOp);
	virtual STDMETHODIMP _FindAllAsyncAqsFilterAndAdditionalProperties(HSTRING aqsFilter, Foundation::Collections::IIterable<HSTRING>* additionalProperties, Foundation::IAsyncOperation<DeviceInformationCollection*>* *asyncOp);
	virtual STDMETHODIMP _CreateWatcher(DeviceWatcher* *watcher);
	virtual STDMETHODIMP _CreateWatcherDeviceClass(DeviceClass deviceClass, DeviceWatcher* *watcher);
	virtual STDMETHODIMP _CreateWatcherAqsFilter(HSTRING aqsFilter, DeviceWatcher* *watcher);
	virtual STDMETHODIMP _CreateWatcherAqsFilterAndAdditionalProperties(HSTRING aqsFilter, Foundation::Collections::IIterable<HSTRING>* additionalProperties, DeviceWatcher* *watcher);
};

// IDeviceInformation2
struct IDeviceInformation2_raw : IInspectable {
	virtual STDMETHODIMP _get_Kind(DeviceInformationKind *value);
	virtual STDMETHODIMP _get_Pairing(DeviceInformationPairing* *value);
};
template<typename X> struct IDeviceInformation2_adaptor : X {
	union {
		struct : property {
			DeviceInformationKind get() { DeviceInformationKind value; hrcheck(enc(&IDeviceInformation2_adaptor::Kind)->_get_Kind(&value)); return value; }
			DeviceInformationKind operator()() { return get(); }
			operator DeviceInformationKind () { return get(); }
		} Kind;
		struct : property {
			ptr<DeviceInformationPairing> get() { DeviceInformationPairing* value; hrcheck(enc(&IDeviceInformation2_adaptor::Pairing)->_get_Pairing(&value)); return from_abi(value); }
			ptr<DeviceInformationPairing> operator()() { return get(); }
			operator ptr<DeviceInformationPairing> () { return get(); }
			ptr<DeviceInformationPairing> operator->() { return get(); }
		} Pairing;
	};
	IDeviceInformation2_adaptor() {}
};
template<typename X> struct adapt<IDeviceInformation2, X> : Windows::Devices::Enumeration::IDeviceInformation2_adaptor<X> { typedef adapt IDeviceInformation2; };
struct IDeviceInformation2 : IDeviceInformation2_raw, generate<IDeviceInformation2> {};

// IDeviceInformation
struct IDeviceInformation_raw : IInspectable {
	virtual STDMETHODIMP _get_Id(HSTRING *value);
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_IsEnabled(bool *value);
	virtual STDMETHODIMP _get_IsDefault(bool *value);
	virtual STDMETHODIMP _get_EnclosureLocation(Enumeration::EnclosureLocation* *value);
	virtual STDMETHODIMP _get_Properties(Foundation::Collections::IMapView<HSTRING, IInspectable*>* *value);
	virtual STDMETHODIMP _Update(DeviceInformationUpdate* updateInfo);
	virtual STDMETHODIMP _GetThumbnailAsync(Foundation::IAsyncOperation<DeviceThumbnail*>* *asyncOp);
	virtual STDMETHODIMP _GetGlyphThumbnailAsync(Foundation::IAsyncOperation<DeviceThumbnail*>* *asyncOp);
};
template<typename X> struct IDeviceInformation_adaptor : X {
	union {
		struct : property {
			ptr<Enumeration::EnclosureLocation> get() { Enumeration::EnclosureLocation* value; hrcheck(enc(&IDeviceInformation_adaptor::EnclosureLocation)->_get_EnclosureLocation(&value)); return from_abi(value); }
			ptr<Enumeration::EnclosureLocation> operator()() { return get(); }
			operator ptr<Enumeration::EnclosureLocation> () { return get(); }
			ptr<Enumeration::EnclosureLocation> operator->() { return get(); }
		} EnclosureLocation;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDeviceInformation_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDeviceInformation_adaptor::IsDefault)->_get_IsDefault(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsDefault;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDeviceInformation_adaptor::IsEnabled)->_get_IsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsEnabled;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDeviceInformation_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, object>> get() { Foundation::Collections::IMapView<HSTRING, IInspectable*>* value; hrcheck(enc(&IDeviceInformation_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMapView<hstring, object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, object>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, object>> operator->() { return get(); }
		} Properties;
	};
	void Update(pptr<DeviceInformationUpdate> updateInfo) { hrcheck(X::get()->_Update(updateInfo)); }
	ptr<Foundation::IAsyncOperation<ptr<DeviceThumbnail>>> GetThumbnailAsync() { Foundation::IAsyncOperation<DeviceThumbnail*>* asyncOp; hrcheck(X::get()->_GetThumbnailAsync(&asyncOp)); return from_abi(asyncOp); }
	ptr<Foundation::IAsyncOperation<ptr<DeviceThumbnail>>> GetGlyphThumbnailAsync() { Foundation::IAsyncOperation<DeviceThumbnail*>* asyncOp; hrcheck(X::get()->_GetGlyphThumbnailAsync(&asyncOp)); return from_abi(asyncOp); }
	IDeviceInformation_adaptor() {}
};
template<typename X> struct adapt<IDeviceInformation, X> : Windows::Devices::Enumeration::IDeviceInformation_adaptor<X> { typedef adapt IDeviceInformation; };
struct IDeviceInformation : IDeviceInformation_raw, generate<IDeviceInformation> {};

// DeviceInformation
template<typename> struct DeviceInformation_statics {
	static hstring GetAqsFilterFromDeviceClass(DeviceClass deviceClass) { HSTRING aqsFilter; hrcheck(get_activation_factory<DeviceInformation, IDeviceInformationStatics2>()->_GetAqsFilterFromDeviceClass(deviceClass, &aqsFilter)); return from_abi(aqsFilter); }
	static ptr<Foundation::IAsyncOperation<ptr<DeviceInformation>>> CreateFromIdAsync(hstring_ref deviceId, pptr<Foundation::Collections::IIterable<hstring>> additionalProperties, DeviceInformationKind kind) { Foundation::IAsyncOperation<DeviceInformation*>* asyncOp; hrcheck(get_activation_factory<DeviceInformation, IDeviceInformationStatics2>()->_CreateFromIdAsyncWithKindAndAdditionalProperties(deviceId, to_abi(additionalProperties), kind, &asyncOp)); return from_abi(asyncOp); }
	static ptr<Foundation::IAsyncOperation<ptr<DeviceInformationCollection>>> FindAllAsync(hstring_ref aqsFilter, pptr<Foundation::Collections::IIterable<hstring>> additionalProperties, DeviceInformationKind kind) { Foundation::IAsyncOperation<DeviceInformationCollection*>* asyncOp; hrcheck(get_activation_factory<DeviceInformation, IDeviceInformationStatics2>()->_FindAllAsyncWithKindAqsFilterAndAdditionalProperties(aqsFilter, to_abi(additionalProperties), kind, &asyncOp)); return from_abi(asyncOp); }
	static ptr<DeviceWatcher> CreateWatcher(hstring_ref aqsFilter, pptr<Foundation::Collections::IIterable<hstring>> additionalProperties, DeviceInformationKind kind) { DeviceWatcher* watcher; hrcheck(get_activation_factory<DeviceInformation, IDeviceInformationStatics2>()->_CreateWatcherWithKindAqsFilterAndAdditionalProperties(aqsFilter, to_abi(additionalProperties), kind, &watcher)); return from_abi(watcher); }
	static ptr<Foundation::IAsyncOperation<ptr<DeviceInformation>>> CreateFromIdAsync(hstring_ref deviceId) { Foundation::IAsyncOperation<DeviceInformation*>* asyncOp; hrcheck(get_activation_factory<DeviceInformation, IDeviceInformationStatics>()->_CreateFromIdAsync(deviceId, &asyncOp)); return from_abi(asyncOp); }
	static ptr<Foundation::IAsyncOperation<ptr<DeviceInformation>>> CreateFromIdAsync(hstring_ref deviceId, pptr<Foundation::Collections::IIterable<hstring>> additionalProperties) { Foundation::IAsyncOperation<DeviceInformation*>* asyncOp; hrcheck(get_activation_factory<DeviceInformation, IDeviceInformationStatics>()->_CreateFromIdAsyncAdditionalProperties(deviceId, to_abi(additionalProperties), &asyncOp)); return from_abi(asyncOp); }
	static ptr<Foundation::IAsyncOperation<ptr<DeviceInformationCollection>>> FindAllAsync() { Foundation::IAsyncOperation<DeviceInformationCollection*>* asyncOp; hrcheck(get_activation_factory<DeviceInformation, IDeviceInformationStatics>()->_FindAllAsync(&asyncOp)); return from_abi(asyncOp); }
	static ptr<Foundation::IAsyncOperation<ptr<DeviceInformationCollection>>> FindAllAsync(DeviceClass deviceClass) { Foundation::IAsyncOperation<DeviceInformationCollection*>* asyncOp; hrcheck(get_activation_factory<DeviceInformation, IDeviceInformationStatics>()->_FindAllAsyncDeviceClass(deviceClass, &asyncOp)); return from_abi(asyncOp); }
	static ptr<Foundation::IAsyncOperation<ptr<DeviceInformationCollection>>> FindAllAsync(hstring_ref aqsFilter) { Foundation::IAsyncOperation<DeviceInformationCollection*>* asyncOp; hrcheck(get_activation_factory<DeviceInformation, IDeviceInformationStatics>()->_FindAllAsyncAqsFilter(aqsFilter, &asyncOp)); return from_abi(asyncOp); }
	static ptr<Foundation::IAsyncOperation<ptr<DeviceInformationCollection>>> FindAllAsync(hstring_ref aqsFilter, pptr<Foundation::Collections::IIterable<hstring>> additionalProperties) { Foundation::IAsyncOperation<DeviceInformationCollection*>* asyncOp; hrcheck(get_activation_factory<DeviceInformation, IDeviceInformationStatics>()->_FindAllAsyncAqsFilterAndAdditionalProperties(aqsFilter, to_abi(additionalProperties), &asyncOp)); return from_abi(asyncOp); }
	static ptr<DeviceWatcher> CreateWatcher() { DeviceWatcher* watcher; hrcheck(get_activation_factory<DeviceInformation, IDeviceInformationStatics>()->_CreateWatcher(&watcher)); return from_abi(watcher); }
	static ptr<DeviceWatcher> CreateWatcher(DeviceClass deviceClass) { DeviceWatcher* watcher; hrcheck(get_activation_factory<DeviceInformation, IDeviceInformationStatics>()->_CreateWatcherDeviceClass(deviceClass, &watcher)); return from_abi(watcher); }
	static ptr<DeviceWatcher> CreateWatcher(hstring_ref aqsFilter) { DeviceWatcher* watcher; hrcheck(get_activation_factory<DeviceInformation, IDeviceInformationStatics>()->_CreateWatcherAqsFilter(aqsFilter, &watcher)); return from_abi(watcher); }
	static ptr<DeviceWatcher> CreateWatcher(hstring_ref aqsFilter, pptr<Foundation::Collections::IIterable<hstring>> additionalProperties) { DeviceWatcher* watcher; hrcheck(get_activation_factory<DeviceInformation, IDeviceInformationStatics>()->_CreateWatcherAqsFilterAndAdditionalProperties(aqsFilter, to_abi(additionalProperties), &watcher)); return from_abi(watcher); }
};

template<typename X> struct statics<DeviceInformation, X> : X, Windows::Devices::Enumeration::DeviceInformation_statics<void> {
	typedef typename X::root_type DeviceInformation;
};
struct DeviceInformation : generate<DeviceInformation> {};

// DeviceInformationCollection
template<typename X> struct statics<DeviceInformationCollection, X> : X {
	typedef typename X::root_type DeviceInformationCollection;
};
struct DeviceInformationCollection : generate<DeviceInformationCollection> {};

// IDeviceWatcher
struct IDeviceWatcher_raw : IInspectable {
	virtual STDMETHODIMP _add_Added(Foundation::TypedEventHandler<DeviceWatcher*, DeviceInformation*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Added(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Updated(Foundation::TypedEventHandler<DeviceWatcher*, DeviceInformationUpdate*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Updated(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Removed(Foundation::TypedEventHandler<DeviceWatcher*, DeviceInformationUpdate*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Removed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_EnumerationCompleted(Foundation::TypedEventHandler<DeviceWatcher*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_EnumerationCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Stopped(Foundation::TypedEventHandler<DeviceWatcher*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Stopped(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_Status(DeviceWatcherStatus *status);
	virtual STDMETHODIMP _Start();
	virtual STDMETHODIMP _Stop();
};
template<typename X> struct IDeviceWatcher_adaptor : X {
	union {
		struct : property {
			DeviceWatcherStatus get() { DeviceWatcherStatus status; hrcheck(enc(&IDeviceWatcher_adaptor::Status)->_get_Status(&status)); return status; }
			DeviceWatcherStatus operator()() { return get(); }
			operator DeviceWatcherStatus () { return get(); }
		} Status;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DeviceWatcher>, ptr<DeviceInformation>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDeviceWatcher_adaptor::Added)->_add_Added(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDeviceWatcher_adaptor::Added)->_remove_Added(token)); }
		} Added;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DeviceWatcher>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDeviceWatcher_adaptor::EnumerationCompleted)->_add_EnumerationCompleted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDeviceWatcher_adaptor::EnumerationCompleted)->_remove_EnumerationCompleted(token)); }
		} EnumerationCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DeviceWatcher>, ptr<DeviceInformationUpdate>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDeviceWatcher_adaptor::Removed)->_add_Removed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDeviceWatcher_adaptor::Removed)->_remove_Removed(token)); }
		} Removed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DeviceWatcher>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDeviceWatcher_adaptor::Stopped)->_add_Stopped(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDeviceWatcher_adaptor::Stopped)->_remove_Stopped(token)); }
		} Stopped;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DeviceWatcher>, ptr<DeviceInformationUpdate>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDeviceWatcher_adaptor::Updated)->_add_Updated(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDeviceWatcher_adaptor::Updated)->_remove_Updated(token)); }
		} Updated;
	};
	void Start() { hrcheck(X::get()->_Start()); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	IDeviceWatcher_adaptor() {}
};
template<typename X> struct adapt<IDeviceWatcher, X> : Windows::Devices::Enumeration::IDeviceWatcher_adaptor<X> { typedef adapt IDeviceWatcher; };
struct IDeviceWatcher : IDeviceWatcher_raw, generate<IDeviceWatcher> {};

// IDeviceWatcher2
struct IDeviceWatcher2_raw : IInspectable {
	virtual STDMETHODIMP _GetBackgroundTrigger(Foundation::Collections::IIterable<DeviceWatcherEventKind>* requestedEventKinds, ApplicationModel::Background::DeviceWatcherTrigger* *trigger);
};
template<typename X> struct IDeviceWatcher2_adaptor : X {
	ptr<ApplicationModel::Background::DeviceWatcherTrigger> GetBackgroundTrigger(pptr<Foundation::Collections::IIterable<DeviceWatcherEventKind>> requestedEventKinds) { ApplicationModel::Background::DeviceWatcherTrigger* trigger; hrcheck(X::get()->_GetBackgroundTrigger(to_abi(requestedEventKinds), &trigger)); return from_abi(trigger); }
};
template<typename X> struct adapt<IDeviceWatcher2, X> : Windows::Devices::Enumeration::IDeviceWatcher2_adaptor<X> { typedef adapt IDeviceWatcher2; };
struct IDeviceWatcher2 : IDeviceWatcher2_raw, generate<IDeviceWatcher2> {};

// DeviceWatcher
template<typename X> struct statics<DeviceWatcher, X> : X {
	typedef typename X::root_type DeviceWatcher;
};
struct DeviceWatcher : generate<DeviceWatcher> {};

// IDevicePairingResult
struct IDevicePairingResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(DevicePairingResultStatus *status);
	virtual STDMETHODIMP _get_ProtectionLevelUsed(DevicePairingProtectionLevel *value);
};
template<typename X> struct IDevicePairingResult_adaptor : X {
	union {
		struct : property {
			DevicePairingProtectionLevel get() { DevicePairingProtectionLevel value; hrcheck(enc(&IDevicePairingResult_adaptor::ProtectionLevelUsed)->_get_ProtectionLevelUsed(&value)); return value; }
			DevicePairingProtectionLevel operator()() { return get(); }
			operator DevicePairingProtectionLevel () { return get(); }
		} ProtectionLevelUsed;
		struct : property {
			DevicePairingResultStatus get() { DevicePairingResultStatus status; hrcheck(enc(&IDevicePairingResult_adaptor::Status)->_get_Status(&status)); return status; }
			DevicePairingResultStatus operator()() { return get(); }
			operator DevicePairingResultStatus () { return get(); }
		} Status;
	};
	IDevicePairingResult_adaptor() {}
};
template<typename X> struct adapt<IDevicePairingResult, X> : Windows::Devices::Enumeration::IDevicePairingResult_adaptor<X> { typedef adapt IDevicePairingResult; };
struct IDevicePairingResult : IDevicePairingResult_raw, generate<IDevicePairingResult> {};

// DevicePairingResult
template<typename X> struct statics<DevicePairingResult, X> : X {
	typedef typename X::root_type DevicePairingResult;
};
struct DevicePairingResult : generate<DevicePairingResult> {};

// IDeviceUnpairingResult
struct IDeviceUnpairingResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(DeviceUnpairingResultStatus *status);
};
template<typename X> struct IDeviceUnpairingResult_adaptor : X {
	union {
		struct : property {
			DeviceUnpairingResultStatus get() { DeviceUnpairingResultStatus status; hrcheck(enc(&IDeviceUnpairingResult_adaptor::Status)->_get_Status(&status)); return status; }
			DeviceUnpairingResultStatus operator()() { return get(); }
			operator DeviceUnpairingResultStatus () { return get(); }
		} Status;
	};
	IDeviceUnpairingResult_adaptor() {}
};
template<typename X> struct adapt<IDeviceUnpairingResult, X> : Windows::Devices::Enumeration::IDeviceUnpairingResult_adaptor<X> { typedef adapt IDeviceUnpairingResult; };
struct IDeviceUnpairingResult : IDeviceUnpairingResult_raw, generate<IDeviceUnpairingResult> {};

// DeviceUnpairingResult
template<typename X> struct statics<DeviceUnpairingResult, X> : X {
	typedef typename X::root_type DeviceUnpairingResult;
};
struct DeviceUnpairingResult : generate<DeviceUnpairingResult> {};

// IDevicePairingSettings
struct IDevicePairingSettings : IInspectable, generate<IDevicePairingSettings> {};

// IDevicePairingRequestedEventArgs
struct IDevicePairingRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_DeviceInformation(Enumeration::DeviceInformation* *value);
	virtual STDMETHODIMP _get_PairingKind(DevicePairingKinds *value);
	virtual STDMETHODIMP _get_Pin(HSTRING *value);
	virtual STDMETHODIMP _Accept();
	virtual STDMETHODIMP _AcceptWithPin(HSTRING pin);
	virtual STDMETHODIMP _GetDeferral(Foundation::Deferral* *result);
};
template<typename X> struct IDevicePairingRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Enumeration::DeviceInformation> get() { Enumeration::DeviceInformation* value; hrcheck(enc(&IDevicePairingRequestedEventArgs_adaptor::DeviceInformation)->_get_DeviceInformation(&value)); return from_abi(value); }
			ptr<Enumeration::DeviceInformation> operator()() { return get(); }
			operator ptr<Enumeration::DeviceInformation> () { return get(); }
			ptr<Enumeration::DeviceInformation> operator->() { return get(); }
		} DeviceInformation;
		struct : property {
			DevicePairingKinds get() { DevicePairingKinds value; hrcheck(enc(&IDevicePairingRequestedEventArgs_adaptor::PairingKind)->_get_PairingKind(&value)); return value; }
			DevicePairingKinds operator()() { return get(); }
			operator DevicePairingKinds () { return get(); }
		} PairingKind;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDevicePairingRequestedEventArgs_adaptor::Pin)->_get_Pin(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Pin;
	};
	void Accept() { hrcheck(X::get()->_Accept()); }
	void Accept(hstring_ref pin) { hrcheck(X::get()->_AcceptWithPin(pin)); }
	ptr<Foundation::Deferral> GetDeferral() { Foundation::Deferral* result; hrcheck(X::get()->_GetDeferral(&result)); return from_abi(result); }
	IDevicePairingRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDevicePairingRequestedEventArgs, X> : Windows::Devices::Enumeration::IDevicePairingRequestedEventArgs_adaptor<X> { typedef adapt IDevicePairingRequestedEventArgs; };
struct IDevicePairingRequestedEventArgs : IDevicePairingRequestedEventArgs_raw, generate<IDevicePairingRequestedEventArgs> {};

// DevicePairingRequestedEventArgs
template<typename X> struct statics<DevicePairingRequestedEventArgs, X> : X {
	typedef typename X::root_type DevicePairingRequestedEventArgs;
};
struct DevicePairingRequestedEventArgs : generate<DevicePairingRequestedEventArgs> {
	using IDevicePairingRequestedEventArgs::Accept;
};

// IDeviceInformationCustomPairing
struct IDeviceInformationCustomPairing_raw : IInspectable {
	virtual STDMETHODIMP _PairAsync(DevicePairingKinds pairingKindsSupported, Foundation::IAsyncOperation<DevicePairingResult*>* *result);
	virtual STDMETHODIMP _PairWithProtectionLevelAsync(DevicePairingKinds pairingKindsSupported, DevicePairingProtectionLevel minProtectionLevel, Foundation::IAsyncOperation<DevicePairingResult*>* *result);
	virtual STDMETHODIMP _PairWithProtectionLevelAndSettingsAsync(DevicePairingKinds pairingKindsSupported, DevicePairingProtectionLevel minProtectionLevel, IDevicePairingSettings* devicePairingSettings, Foundation::IAsyncOperation<DevicePairingResult*>* *result);
	virtual STDMETHODIMP _add_PairingRequested(Foundation::TypedEventHandler<DeviceInformationCustomPairing*, DevicePairingRequestedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PairingRequested(Foundation::EventRegistrationToken token);
};
template<typename X> struct IDeviceInformationCustomPairing_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DeviceInformationCustomPairing>, ptr<DevicePairingRequestedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDeviceInformationCustomPairing_adaptor::PairingRequested)->_add_PairingRequested(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDeviceInformationCustomPairing_adaptor::PairingRequested)->_remove_PairingRequested(token)); }
		} PairingRequested;
	};
	ptr<Foundation::IAsyncOperation<ptr<DevicePairingResult>>> PairAsync(DevicePairingKinds pairingKindsSupported) { Foundation::IAsyncOperation<DevicePairingResult*>* result; hrcheck(X::get()->_PairAsync(pairingKindsSupported, &result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<DevicePairingResult>>> PairAsync(DevicePairingKinds pairingKindsSupported, DevicePairingProtectionLevel minProtectionLevel) { Foundation::IAsyncOperation<DevicePairingResult*>* result; hrcheck(X::get()->_PairWithProtectionLevelAsync(pairingKindsSupported, minProtectionLevel, &result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<DevicePairingResult>>> PairAsync(DevicePairingKinds pairingKindsSupported, DevicePairingProtectionLevel minProtectionLevel, pptr<IDevicePairingSettings> devicePairingSettings) { Foundation::IAsyncOperation<DevicePairingResult*>* result; hrcheck(X::get()->_PairWithProtectionLevelAndSettingsAsync(pairingKindsSupported, minProtectionLevel, devicePairingSettings, &result)); return from_abi(result); }
	IDeviceInformationCustomPairing_adaptor() {}
};
template<typename X> struct adapt<IDeviceInformationCustomPairing, X> : Windows::Devices::Enumeration::IDeviceInformationCustomPairing_adaptor<X> { typedef adapt IDeviceInformationCustomPairing; };
struct IDeviceInformationCustomPairing : IDeviceInformationCustomPairing_raw, generate<IDeviceInformationCustomPairing> {};

// DeviceInformationCustomPairing
template<typename X> struct statics<DeviceInformationCustomPairing, X> : X {
	typedef typename X::root_type DeviceInformationCustomPairing;
};
struct DeviceInformationCustomPairing : generate<DeviceInformationCustomPairing> {
	using IDeviceInformationCustomPairing::PairAsync;
};

// IDeviceInformationPairing
struct IDeviceInformationPairing_raw : IInspectable {
	virtual STDMETHODIMP _get_IsPaired(bool *value);
	virtual STDMETHODIMP _get_CanPair(bool *value);
	virtual STDMETHODIMP _PairAsync(Foundation::IAsyncOperation<DevicePairingResult*>* *result);
	virtual STDMETHODIMP _PairWithProtectionLevelAsync(DevicePairingProtectionLevel minProtectionLevel, Foundation::IAsyncOperation<DevicePairingResult*>* *result);
};
template<typename X> struct IDeviceInformationPairing_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDeviceInformationPairing_adaptor::CanPair)->_get_CanPair(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanPair;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDeviceInformationPairing_adaptor::IsPaired)->_get_IsPaired(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsPaired;
	};
	ptr<Foundation::IAsyncOperation<ptr<DevicePairingResult>>> PairAsync() { Foundation::IAsyncOperation<DevicePairingResult*>* result; hrcheck(X::get()->_PairAsync(&result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<DevicePairingResult>>> PairAsync(DevicePairingProtectionLevel minProtectionLevel) { Foundation::IAsyncOperation<DevicePairingResult*>* result; hrcheck(X::get()->_PairWithProtectionLevelAsync(minProtectionLevel, &result)); return from_abi(result); }
	IDeviceInformationPairing_adaptor() {}
};
template<typename X> struct adapt<IDeviceInformationPairing, X> : Windows::Devices::Enumeration::IDeviceInformationPairing_adaptor<X> { typedef adapt IDeviceInformationPairing; };
struct IDeviceInformationPairing : IDeviceInformationPairing_raw, generate<IDeviceInformationPairing> {};

// IDeviceInformationPairing2
struct IDeviceInformationPairing2_raw : IInspectable {
	virtual STDMETHODIMP _get_ProtectionLevel(DevicePairingProtectionLevel *value);
	virtual STDMETHODIMP _get_Custom(DeviceInformationCustomPairing* *value);
	virtual STDMETHODIMP _PairWithProtectionLevelAndSettingsAsync(DevicePairingProtectionLevel minProtectionLevel, IDevicePairingSettings* devicePairingSettings, Foundation::IAsyncOperation<DevicePairingResult*>* *result);
	virtual STDMETHODIMP _UnpairAsync(Foundation::IAsyncOperation<DeviceUnpairingResult*>* *result);
};
template<typename X> struct IDeviceInformationPairing2_adaptor : X {
	union {
		struct : property {
			ptr<DeviceInformationCustomPairing> get() { DeviceInformationCustomPairing* value; hrcheck(enc(&IDeviceInformationPairing2_adaptor::Custom)->_get_Custom(&value)); return from_abi(value); }
			ptr<DeviceInformationCustomPairing> operator()() { return get(); }
			operator ptr<DeviceInformationCustomPairing> () { return get(); }
			ptr<DeviceInformationCustomPairing> operator->() { return get(); }
		} Custom;
		struct : property {
			DevicePairingProtectionLevel get() { DevicePairingProtectionLevel value; hrcheck(enc(&IDeviceInformationPairing2_adaptor::ProtectionLevel)->_get_ProtectionLevel(&value)); return value; }
			DevicePairingProtectionLevel operator()() { return get(); }
			operator DevicePairingProtectionLevel () { return get(); }
		} ProtectionLevel;
	};
	ptr<Foundation::IAsyncOperation<ptr<DevicePairingResult>>> PairAsync(DevicePairingProtectionLevel minProtectionLevel, pptr<IDevicePairingSettings> devicePairingSettings) { Foundation::IAsyncOperation<DevicePairingResult*>* result; hrcheck(X::get()->_PairWithProtectionLevelAndSettingsAsync(minProtectionLevel, devicePairingSettings, &result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<DeviceUnpairingResult>>> UnpairAsync() { Foundation::IAsyncOperation<DeviceUnpairingResult*>* result; hrcheck(X::get()->_UnpairAsync(&result)); return from_abi(result); }
	IDeviceInformationPairing2_adaptor() {}
};
template<typename X> struct adapt<IDeviceInformationPairing2, X> : Windows::Devices::Enumeration::IDeviceInformationPairing2_adaptor<X> { typedef adapt IDeviceInformationPairing2; };
struct IDeviceInformationPairing2 : IDeviceInformationPairing2_raw, generate<IDeviceInformationPairing2> {};

// IDeviceInformationPairingStatics
struct IDeviceInformationPairingStatics : IInspectable {
	virtual STDMETHODIMP _TryRegisterForAllInboundPairingRequests(DevicePairingKinds pairingKindsSupported, bool *result);
};

// DeviceInformationPairing
template<typename> struct DeviceInformationPairing_statics {
	static bool TryRegisterForAllInboundPairingRequests(DevicePairingKinds pairingKindsSupported) { bool result; hrcheck(get_activation_factory<DeviceInformationPairing, IDeviceInformationPairingStatics>()->_TryRegisterForAllInboundPairingRequests(pairingKindsSupported, &result)); return result; }
};

template<typename X> struct statics<DeviceInformationPairing, X> : X, Windows::Devices::Enumeration::DeviceInformationPairing_statics<void> {
	typedef typename X::root_type DeviceInformationPairing;
};
struct DeviceInformationPairing : generate<DeviceInformationPairing> {
	using IDeviceInformationPairing::PairAsync;
	using IDeviceInformationPairing2::PairAsync;
};

// IDeviceAccessChangedEventArgs
struct IDeviceAccessChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(DeviceAccessStatus *value);
};
template<typename X> struct IDeviceAccessChangedEventArgs_adaptor : X {
	union {
		struct : property {
			DeviceAccessStatus get() { DeviceAccessStatus value; hrcheck(enc(&IDeviceAccessChangedEventArgs_adaptor::Status)->_get_Status(&value)); return value; }
			DeviceAccessStatus operator()() { return get(); }
			operator DeviceAccessStatus () { return get(); }
		} Status;
	};
	IDeviceAccessChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDeviceAccessChangedEventArgs, X> : Windows::Devices::Enumeration::IDeviceAccessChangedEventArgs_adaptor<X> { typedef adapt IDeviceAccessChangedEventArgs; };
struct IDeviceAccessChangedEventArgs : IDeviceAccessChangedEventArgs_raw, generate<IDeviceAccessChangedEventArgs> {};

// IDeviceAccessChangedEventArgs2
struct IDeviceAccessChangedEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _get_Id(HSTRING *value);
};
template<typename X> struct IDeviceAccessChangedEventArgs2_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDeviceAccessChangedEventArgs2_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
	};
	IDeviceAccessChangedEventArgs2_adaptor() {}
};
template<typename X> struct adapt<IDeviceAccessChangedEventArgs2, X> : Windows::Devices::Enumeration::IDeviceAccessChangedEventArgs2_adaptor<X> { typedef adapt IDeviceAccessChangedEventArgs2; };
struct IDeviceAccessChangedEventArgs2 : IDeviceAccessChangedEventArgs2_raw, generate<IDeviceAccessChangedEventArgs2> {};

// DeviceAccessChangedEventArgs
template<typename X> struct statics<DeviceAccessChangedEventArgs, X> : X {
	typedef typename X::root_type DeviceAccessChangedEventArgs;
};
struct DeviceAccessChangedEventArgs : generate<DeviceAccessChangedEventArgs> {};

// IDeviceAccessInformation
struct IDeviceAccessInformation_raw : IInspectable {
	virtual STDMETHODIMP _add_AccessChanged(Foundation::TypedEventHandler<DeviceAccessInformation*, DeviceAccessChangedEventArgs*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_AccessChanged(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _get_CurrentStatus(DeviceAccessStatus *status);
};
template<typename X> struct IDeviceAccessInformation_adaptor : X {
	union {
		struct : property {
			DeviceAccessStatus get() { DeviceAccessStatus status; hrcheck(enc(&IDeviceAccessInformation_adaptor::CurrentStatus)->_get_CurrentStatus(&status)); return status; }
			DeviceAccessStatus operator()() { return get(); }
			operator DeviceAccessStatus () { return get(); }
		} CurrentStatus;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DeviceAccessInformation>, ptr<DeviceAccessChangedEventArgs>>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(enc(&IDeviceAccessInformation_adaptor::AccessChanged)->_add_AccessChanged(to_abi(handler), &cookie)); return cookie; }
			void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(enc(&IDeviceAccessInformation_adaptor::AccessChanged)->_remove_AccessChanged(cookie)); }
		} AccessChanged;
	};
	IDeviceAccessInformation_adaptor() {}
};
template<typename X> struct adapt<IDeviceAccessInformation, X> : Windows::Devices::Enumeration::IDeviceAccessInformation_adaptor<X> { typedef adapt IDeviceAccessInformation; };
struct IDeviceAccessInformation : IDeviceAccessInformation_raw, generate<IDeviceAccessInformation> {};

// IDeviceAccessInformationStatics
struct IDeviceAccessInformationStatics : IInspectable {
	virtual STDMETHODIMP _CreateFromId(HSTRING deviceId, DeviceAccessInformation* *value);
	virtual STDMETHODIMP _CreateFromDeviceClassId(Platform::Guid deviceClassId, DeviceAccessInformation* *value);
	virtual STDMETHODIMP _CreateFromDeviceClass(DeviceClass deviceClass, DeviceAccessInformation* *value);
};

// DeviceAccessInformation
template<typename> struct DeviceAccessInformation_statics {
	static ptr<DeviceAccessInformation> CreateFromId(hstring_ref deviceId) { DeviceAccessInformation* value; hrcheck(get_activation_factory<DeviceAccessInformation, IDeviceAccessInformationStatics>()->_CreateFromId(deviceId, &value)); return from_abi(value); }
	static ptr<DeviceAccessInformation> CreateFromDeviceClassId(const Platform::Guid& deviceClassId) { DeviceAccessInformation* value; hrcheck(get_activation_factory<DeviceAccessInformation, IDeviceAccessInformationStatics>()->_CreateFromDeviceClassId(deviceClassId, &value)); return from_abi(value); }
	static ptr<DeviceAccessInformation> CreateFromDeviceClass(DeviceClass deviceClass) { DeviceAccessInformation* value; hrcheck(get_activation_factory<DeviceAccessInformation, IDeviceAccessInformationStatics>()->_CreateFromDeviceClass(deviceClass, &value)); return from_abi(value); }
};

template<typename X> struct statics<DeviceAccessInformation, X> : X, Windows::Devices::Enumeration::DeviceAccessInformation_statics<void> {
	typedef typename X::root_type DeviceAccessInformation;
};
struct DeviceAccessInformation : generate<DeviceAccessInformation> {};

// IDeviceWatcherEvent
struct IDeviceWatcherEvent_raw : IInspectable {
	virtual STDMETHODIMP _get_Kind(DeviceWatcherEventKind *value);
	virtual STDMETHODIMP _get_DeviceInformation(Enumeration::DeviceInformation* *value);
	virtual STDMETHODIMP _get_DeviceInformationUpdate(Enumeration::DeviceInformationUpdate* *value);
};
template<typename X> struct IDeviceWatcherEvent_adaptor : X {
	union {
		struct : property {
			ptr<Enumeration::DeviceInformation> get() { Enumeration::DeviceInformation* value; hrcheck(enc(&IDeviceWatcherEvent_adaptor::DeviceInformation)->_get_DeviceInformation(&value)); return from_abi(value); }
			ptr<Enumeration::DeviceInformation> operator()() { return get(); }
			operator ptr<Enumeration::DeviceInformation> () { return get(); }
			ptr<Enumeration::DeviceInformation> operator->() { return get(); }
		} DeviceInformation;
		struct : property {
			ptr<Enumeration::DeviceInformationUpdate> get() { Enumeration::DeviceInformationUpdate* value; hrcheck(enc(&IDeviceWatcherEvent_adaptor::DeviceInformationUpdate)->_get_DeviceInformationUpdate(&value)); return from_abi(value); }
			ptr<Enumeration::DeviceInformationUpdate> operator()() { return get(); }
			operator ptr<Enumeration::DeviceInformationUpdate> () { return get(); }
			ptr<Enumeration::DeviceInformationUpdate> operator->() { return get(); }
		} DeviceInformationUpdate;
		struct : property {
			DeviceWatcherEventKind get() { DeviceWatcherEventKind value; hrcheck(enc(&IDeviceWatcherEvent_adaptor::Kind)->_get_Kind(&value)); return value; }
			DeviceWatcherEventKind operator()() { return get(); }
			operator DeviceWatcherEventKind () { return get(); }
		} Kind;
	};
	IDeviceWatcherEvent_adaptor() {}
};
template<typename X> struct adapt<IDeviceWatcherEvent, X> : Windows::Devices::Enumeration::IDeviceWatcherEvent_adaptor<X> { typedef adapt IDeviceWatcherEvent; };
struct IDeviceWatcherEvent : IDeviceWatcherEvent_raw, generate<IDeviceWatcherEvent> {};

// DeviceWatcherEvent
template<typename X> struct statics<DeviceWatcherEvent, X> : X {
	typedef typename X::root_type DeviceWatcherEvent;
};
struct DeviceWatcherEvent : generate<DeviceWatcherEvent> {};

// IDeviceWatcherTriggerDetails
struct IDeviceWatcherTriggerDetails_raw : IInspectable {
	virtual STDMETHODIMP _get_DeviceWatcherEvents(Foundation::Collections::IVectorView<DeviceWatcherEvent*>* *value);
};
template<typename X> struct IDeviceWatcherTriggerDetails_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<DeviceWatcherEvent>>> get() { Foundation::Collections::IVectorView<DeviceWatcherEvent*>* value; hrcheck(enc(&IDeviceWatcherTriggerDetails_adaptor::DeviceWatcherEvents)->_get_DeviceWatcherEvents(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<DeviceWatcherEvent>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<DeviceWatcherEvent>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<DeviceWatcherEvent>>> operator->() { return get(); }
		} DeviceWatcherEvents;
	};
	IDeviceWatcherTriggerDetails_adaptor() {}
};
template<typename X> struct adapt<IDeviceWatcherTriggerDetails, X> : Windows::Devices::Enumeration::IDeviceWatcherTriggerDetails_adaptor<X> { typedef adapt IDeviceWatcherTriggerDetails; };
struct IDeviceWatcherTriggerDetails : IDeviceWatcherTriggerDetails_raw, generate<IDeviceWatcherTriggerDetails> {};

// DeviceWatcherTriggerDetails
template<typename X> struct statics<DeviceWatcherTriggerDetails, X> : X {
	typedef typename X::root_type DeviceWatcherTriggerDetails;
};
struct DeviceWatcherTriggerDetails : generate<DeviceWatcherTriggerDetails> {};
}}}
} // namespace iso_winrt
