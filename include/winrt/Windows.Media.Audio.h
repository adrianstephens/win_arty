#pragma once
// generated by isopod tools
// namespaces:
// Windows.Media.Audio

#include "Windows.Media.Audio.0.h"
#include "Windows.Foundation.Numerics.0.h"
#include "Windows.Media.Capture.0.h"
#include "Windows.Media.Render.0.h"
#include "Windows.Media.Devices.0.h"
#include "Windows.Media.0.h"
#include "Windows.Media.Transcoding.0.h"
#include "Windows.Foundation.h"
#include "Windows.Media.Effects.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Devices { namespace Enumeration {
struct DeviceInformation;
}}
namespace Foundation { namespace Collections {
struct IPropertySet;
template<typename T> struct IVectorView;
template<typename T> struct IVector;
}}
namespace Media { namespace Core {
struct MediaSource;
}
namespace MediaProperties {
struct MediaEncodingProfile;
struct AudioEncodingProperties;
}}
namespace Storage {
struct StorageFile;
struct IStorageFile;
}}

// defs

template<> struct def<Windows::Media::Audio::IAudioStateMonitorStatics> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IAudioStateMonitor> : interface_type<> {};
template<> struct def<Windows::Media::Audio::AudioStateMonitor> : class_type<Platform::Object, Windows::Media::Audio::IAudioStateMonitor> {};
template<> struct def<Windows::Media::Audio::AudioGraphCreationStatus> : enum_type<int> {};
template<> struct def<Windows::Media::Audio::QuantumSizeSelectionMode> : enum_type<int> {};
template<> struct def<Windows::Media::Audio::ICreateAudioGraphResult> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IAudioGraphStatics> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IAudioGraph3> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IAudioGraph> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Media::Audio::IAudioGraph2> : interface_type<Windows::Media::Audio::IAudioGraph> {};
template<> struct def<Windows::Media::Audio::AudioGraph> : class_type<Platform::Object, Windows::Media::Audio::IAudioGraph, Windows::Media::Audio::IAudioGraph3, Windows::Media::Audio::IAudioGraph2> {};
template<> struct def<Windows::Media::Audio::CreateAudioGraphResult> : class_type<Platform::Object, Windows::Media::Audio::ICreateAudioGraphResult> {};
template<> struct def<Windows::Media::Audio::IAudioGraphSettingsFactory> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IAudioGraphSettings2> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IAudioGraphSettings> : interface_type<> {};
template<> struct def<Windows::Media::Audio::AudioGraphSettings> : class_type<Platform::Object, Windows::Media::Audio::IAudioGraphSettings, Windows::Media::Audio::IAudioGraphSettings2>, custom_activators {};
template<> struct def<Windows::Media::Audio::AudioDeviceNodeCreationStatus> : enum_type<int> {};
template<> struct def<Windows::Media::Audio::AudioFileNodeCreationStatus> : enum_type<int> {};
template<> struct def<Windows::Media::Audio::ICreateAudioDeviceInputNodeResult> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IAudioNode> : overridable_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Media::Audio::IAudioInputNode> : overridable_type<Windows::Media::Audio::IAudioNode> {};
template<> struct def<Windows::Media::Audio::IAudioInputNode2> : overridable_type<Windows::Media::Audio::IAudioInputNode> {};
template<> struct def<Windows::Media::Audio::IAudioDeviceInputNode> : interface_type<Windows::Media::Audio::IAudioInputNode> {};
template<> struct def<Windows::Media::Audio::AudioDeviceInputNode> : class_type<Platform::Object, Windows::Media::Audio::IAudioDeviceInputNode, Windows::Media::Audio::IAudioInputNode2> {};
template<> struct def<Windows::Media::Audio::CreateAudioDeviceInputNodeResult> : class_type<Platform::Object, Windows::Media::Audio::ICreateAudioDeviceInputNodeResult> {};
template<> struct def<Windows::Media::Audio::ICreateAudioDeviceOutputNodeResult> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IAudioNodeWithListener> : overridable_type<Windows::Media::Audio::IAudioNode> {};
template<> struct def<Windows::Media::Audio::IAudioDeviceOutputNode> : interface_type<Windows::Media::Audio::IAudioNode> {};
template<> struct def<Windows::Media::Audio::AudioDeviceOutputNode> : class_type<Platform::Object, Windows::Media::Audio::IAudioDeviceOutputNode, Windows::Media::Audio::IAudioNodeWithListener> {};
template<> struct def<Windows::Media::Audio::CreateAudioDeviceOutputNodeResult> : class_type<Platform::Object, Windows::Media::Audio::ICreateAudioDeviceOutputNodeResult> {};
template<> struct def<Windows::Media::Audio::ICreateAudioFileInputNodeResult> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IAudioFileInputNode> : interface_type<Windows::Media::Audio::IAudioInputNode> {};
template<> struct def<Windows::Media::Audio::AudioFileInputNode> : class_type<Platform::Object, Windows::Media::Audio::IAudioFileInputNode, Windows::Media::Audio::IAudioInputNode2> {};
template<> struct def<Windows::Media::Audio::CreateAudioFileInputNodeResult> : class_type<Platform::Object, Windows::Media::Audio::ICreateAudioFileInputNodeResult> {};
template<> struct def<Windows::Media::Audio::ICreateAudioFileOutputNodeResult> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IAudioFileOutputNode> : interface_type<Windows::Media::Audio::IAudioNode> {};
template<> struct def<Windows::Media::Audio::AudioFileOutputNode> : class_type<Platform::Object, Windows::Media::Audio::IAudioFileOutputNode> {};
template<> struct def<Windows::Media::Audio::CreateAudioFileOutputNodeResult> : class_type<Platform::Object, Windows::Media::Audio::ICreateAudioFileOutputNodeResult> {};
template<> struct def<Windows::Media::Audio::MediaSourceAudioInputNodeCreationStatus> : enum_type<int> {};
template<> struct def<Windows::Media::Audio::ICreateMediaSourceAudioInputNodeResult> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IMediaSourceAudioInputNode> : interface_type<Windows::Media::Audio::IAudioInputNode2> {};
template<> struct def<Windows::Media::Audio::MediaSourceAudioInputNode> : class_type<Platform::Object, Windows::Media::Audio::IMediaSourceAudioInputNode> {};
template<> struct def<Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult> : class_type<Platform::Object, Windows::Media::Audio::ICreateMediaSourceAudioInputNodeResult> {};
template<> struct def<Windows::Media::Audio::AudioGraphUnrecoverableError> : enum_type<int> {};
template<> struct def<Windows::Media::Audio::IAudioGraphUnrecoverableErrorOccurredEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs> : class_type<Platform::Object, Windows::Media::Audio::IAudioGraphUnrecoverableErrorOccurredEventArgs> {};
template<> struct def<Windows::Media::Audio::AudioGraphBatchUpdater> : class_type<Platform::Object, Windows::Foundation::IClosable> {};
template<> struct def<Windows::Media::Audio::IAudioFrameInputNode> : interface_type<Windows::Media::Audio::IAudioInputNode> {};
template<> struct def<Windows::Media::Audio::AudioFrameInputNode> : class_type<Platform::Object, Windows::Media::Audio::IAudioFrameInputNode, Windows::Media::Audio::IAudioInputNode2> {};
template<> struct def<Windows::Media::Audio::IAudioFrameOutputNode> : interface_type<Windows::Media::Audio::IAudioNode> {};
template<> struct def<Windows::Media::Audio::AudioFrameOutputNode> : class_type<Platform::Object, Windows::Media::Audio::IAudioFrameOutputNode> {};
template<> struct def<Windows::Media::Audio::AudioSubmixNode> : class_type<Platform::Object, Windows::Media::Audio::IAudioInputNode, Windows::Media::Audio::IAudioInputNode2> {};
template<> struct def<Windows::Media::Audio::AudioNodeEmitterSettings> : enum_type<unsigned> {};
template<> struct def<Windows::Media::Audio::IAudioNodeEmitterFactory> : interface_type<> {};
template<> struct def<Windows::Media::Audio::SpatialAudioModel> : enum_type<int> {};
template<> struct def<Windows::Media::Audio::IAudioNodeEmitter2> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IAudioNodeEmitter> : interface_type<> {};
template<> struct def<Windows::Media::Audio::AudioNodeEmitter> : class_type<Platform::Object, Windows::Media::Audio::IAudioNodeEmitter, Windows::Media::Audio::IAudioNodeEmitter2>, custom_activators {};
template<> struct def<Windows::Media::Audio::IAudioNodeListener> : interface_type<> {};
template<> struct def<Windows::Media::Audio::AudioNodeListener> : class_type<Platform::Object, Windows::Media::Audio::IAudioNodeListener> {};
template<> struct def<Windows::Media::Audio::IAudioGraphConnection> : interface_type<> {};
template<> struct def<Windows::Media::Audio::AudioGraphConnection> : class_type<Platform::Object, Windows::Media::Audio::IAudioGraphConnection> {};
template<> struct def<Windows::Media::Audio::IAudioFrameCompletedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Audio::AudioFrameCompletedEventArgs> : class_type<Platform::Object, Windows::Media::Audio::IAudioFrameCompletedEventArgs> {};
template<> struct def<Windows::Media::Audio::IFrameInputNodeQuantumStartedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs> : class_type<Platform::Object, Windows::Media::Audio::IFrameInputNodeQuantumStartedEventArgs> {};
template<> struct def<Windows::Media::Audio::IEqualizerBand> : interface_type<> {};
template<> struct def<Windows::Media::Audio::EqualizerBand> : class_type<Platform::Object, Windows::Media::Audio::IEqualizerBand> {};
template<> struct def<Windows::Media::Audio::IEqualizerEffectDefinitionFactory> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IEqualizerEffectDefinition> : interface_type<Windows::Media::Effects::IAudioEffectDefinition> {};
template<> struct def<Windows::Media::Audio::EqualizerEffectDefinition> : class_type<Platform::Object, Windows::Media::Audio::IEqualizerEffectDefinition>, custom_activators {};
template<> struct def<Windows::Media::Audio::IReverbEffectDefinitionFactory> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IReverbEffectDefinition> : interface_type<Windows::Media::Effects::IAudioEffectDefinition> {};
template<> struct def<Windows::Media::Audio::ReverbEffectDefinition> : class_type<Platform::Object, Windows::Media::Audio::IReverbEffectDefinition>, custom_activators {};
template<> struct def<Windows::Media::Audio::IEchoEffectDefinitionFactory> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IEchoEffectDefinition> : interface_type<Windows::Media::Effects::IAudioEffectDefinition> {};
template<> struct def<Windows::Media::Audio::EchoEffectDefinition> : class_type<Platform::Object, Windows::Media::Audio::IEchoEffectDefinition>, custom_activators {};
template<> struct def<Windows::Media::Audio::ILimiterEffectDefinitionFactory> : interface_type<> {};
template<> struct def<Windows::Media::Audio::ILimiterEffectDefinition> : interface_type<Windows::Media::Effects::IAudioEffectDefinition> {};
template<> struct def<Windows::Media::Audio::LimiterEffectDefinition> : class_type<Platform::Object, Windows::Media::Audio::ILimiterEffectDefinition>, custom_activators {};
template<> struct def<Windows::Media::Audio::AudioNodeEmitterShapeKind> : enum_type<int> {};
template<> struct def<Windows::Media::Audio::AudioNodeEmitterDecayKind> : enum_type<int> {};
template<> struct def<Windows::Media::Audio::IAudioNodeEmitterConeProperties> : interface_type<> {};
template<> struct def<Windows::Media::Audio::AudioNodeEmitterConeProperties> : class_type<Platform::Object, Windows::Media::Audio::IAudioNodeEmitterConeProperties> {};
template<> struct def<Windows::Media::Audio::IAudioNodeEmitterShape> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IAudioNodeEmitterShapeStatics> : interface_type<> {};
template<> struct def<Windows::Media::Audio::AudioNodeEmitterShape> : class_type<Platform::Object, Windows::Media::Audio::IAudioNodeEmitterShape> {};
template<> struct def<Windows::Media::Audio::IAudioNodeEmitterNaturalDecayModelProperties> : interface_type<> {};
template<> struct def<Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties> : class_type<Platform::Object, Windows::Media::Audio::IAudioNodeEmitterNaturalDecayModelProperties> {};
template<> struct def<Windows::Media::Audio::IAudioNodeEmitterDecayModel> : interface_type<> {};
template<> struct def<Windows::Media::Audio::IAudioNodeEmitterDecayModelStatics> : interface_type<> {};
template<> struct def<Windows::Media::Audio::AudioNodeEmitterDecayModel> : class_type<Platform::Object, Windows::Media::Audio::IAudioNodeEmitterDecayModel> {};

// uuids

template<> struct uuid<Windows::Media::Audio::IAudioStateMonitorStatics> { define_guid(0x6374EA4C, 0x1B3B, 0x4001, 0x94, 0xD9, 0xDD, 0x22, 0x53, 0x30, 0xFA, 0x40);};
template<> struct uuid<Windows::Media::Audio::IAudioStateMonitor> { define_guid(0x1D13D136, 0x199, 0x4CDC, 0xB8, 0x4E, 0xE7, 0x2C, 0x2B, 0x58, 0x1E, 0xCE);};
template<> struct uuid<Windows::Media::Audio::ICreateAudioGraphResult> { define_guid(0x5453EF7E, 0x7BDE, 0x4B76, 0xBB, 0x5D, 0x48, 0xF7, 0x9C, 0xFC, 0x8C, 0xB);};
template<> struct uuid<Windows::Media::Audio::IAudioGraphStatics> { define_guid(0x76EC3132, 0xE159, 0x4AB7, 0xA8, 0x2A, 0x17, 0xBE, 0xB4, 0xB3, 0x1E, 0x94);};
template<> struct uuid<Windows::Media::Audio::IAudioGraph3> { define_guid(0xDDCD25AE, 0x1185, 0x42A7, 0x83, 0x1D, 0x6A, 0x9B, 0xF, 0xC8, 0x68, 0x20);};
template<> struct uuid<Windows::Media::Audio::IAudioGraph> { define_guid(0x1AD46EED, 0xE48C, 0x4E14, 0x96, 0x60, 0x2C, 0x4F, 0x83, 0xE9, 0xCD, 0xD8);};
template<> struct uuid<Windows::Media::Audio::IAudioGraph2> { define_guid(0x4E4C3BD5, 0x4FC1, 0x45F6, 0xA9, 0x47, 0x3C, 0xD3, 0x8F, 0x4F, 0xD8, 0x39);};
template<> struct uuid<Windows::Media::Audio::IAudioGraphSettingsFactory> { define_guid(0xA5D91CC6, 0xC2EB, 0x4A61, 0xA2, 0x14, 0x1D, 0x66, 0xD7, 0x5F, 0x83, 0xDA);};
template<> struct uuid<Windows::Media::Audio::IAudioGraphSettings2> { define_guid(0x72919787, 0x4DAB, 0x46E3, 0xB4, 0xC9, 0xD8, 0xE1, 0xA2, 0x63, 0x60, 0x62);};
template<> struct uuid<Windows::Media::Audio::IAudioGraphSettings> { define_guid(0x1D59647F, 0xE6FE, 0x4628, 0x84, 0xF8, 0x9D, 0x8B, 0xDB, 0xA2, 0x57, 0x85);};
template<> struct uuid<Windows::Media::Audio::ICreateAudioDeviceInputNodeResult> { define_guid(0x16EEC7A8, 0x1CA7, 0x40EF, 0x91, 0xA4, 0xD3, 0x46, 0xE0, 0xAA, 0x1B, 0xBA);};
template<> struct uuid<Windows::Media::Audio::IAudioNode> { define_guid(0x15389D7F, 0xDBD8, 0x4819, 0xBF, 0x3, 0x66, 0x8E, 0x93, 0x57, 0xCD, 0x6D);};
template<> struct uuid<Windows::Media::Audio::IAudioInputNode> { define_guid(0xD148005C, 0x8428, 0x4784, 0xB7, 0xFD, 0xA9, 0x9D, 0x46, 0x8C, 0x5D, 0x20);};
template<> struct uuid<Windows::Media::Audio::IAudioInputNode2> { define_guid(0x905156B7, 0xCA68, 0x4C6D, 0xA8, 0xBC, 0xE3, 0xEE, 0x17, 0xFE, 0x3F, 0xD2);};
template<> struct uuid<Windows::Media::Audio::IAudioDeviceInputNode> { define_guid(0xB01B6BE1, 0x6F4E, 0x49E2, 0xAC, 0x1, 0x55, 0x9D, 0x62, 0xBE, 0xB3, 0xA9);};
template<> struct uuid<Windows::Media::Audio::ICreateAudioDeviceOutputNodeResult> { define_guid(0xF7776D27, 0x1D9A, 0x47F7, 0x9C, 0xD4, 0x28, 0x59, 0xCC, 0x1B, 0x7B, 0xFF);};
template<> struct uuid<Windows::Media::Audio::IAudioNodeWithListener> { define_guid(0xE0F907C, 0x79FF, 0x4544, 0x9E, 0xEB, 0x1, 0x25, 0x7B, 0x15, 0x10, 0x5A);};
template<> struct uuid<Windows::Media::Audio::IAudioDeviceOutputNode> { define_guid(0x362EDBFF, 0xFF1C, 0x4434, 0x9E, 0xF, 0xBD, 0x2E, 0xF5, 0x22, 0xAC, 0x82);};
template<> struct uuid<Windows::Media::Audio::ICreateAudioFileInputNodeResult> { define_guid(0xCE83D61C, 0xE297, 0x4C50, 0x9C, 0xE7, 0x1C, 0x7A, 0x69, 0xD6, 0xBD, 0x9);};
template<> struct uuid<Windows::Media::Audio::IAudioFileInputNode> { define_guid(0x905B67C8, 0x6F65, 0x4CD4, 0x88, 0x90, 0x46, 0x94, 0x84, 0x3C, 0x27, 0x6D);};
template<> struct uuid<Windows::Media::Audio::ICreateAudioFileOutputNodeResult> { define_guid(0x47D6BA7B, 0xE909, 0x453F, 0x86, 0x6E, 0x55, 0x40, 0xCD, 0xA7, 0x34, 0xFF);};
template<> struct uuid<Windows::Media::Audio::IAudioFileOutputNode> { define_guid(0x50E01980, 0x5166, 0x4093, 0x80, 0xF8, 0xAD, 0xA0, 0x0, 0x89, 0xE9, 0xCF);};
template<> struct uuid<Windows::Media::Audio::ICreateMediaSourceAudioInputNodeResult> { define_guid(0x46A658A3, 0x53C0, 0x4D59, 0x9E, 0x51, 0xCC, 0x1D, 0x10, 0x44, 0xA4, 0xC4);};
template<> struct uuid<Windows::Media::Audio::IMediaSourceAudioInputNode> { define_guid(0x99D8983B, 0xA88A, 0x4041, 0x8E, 0x4F, 0xDD, 0xBA, 0xC0, 0xC9, 0x1F, 0xD3);};
template<> struct uuid<Windows::Media::Audio::IAudioGraphUnrecoverableErrorOccurredEventArgs> { define_guid(0xC3D9CBE0, 0x3FF6, 0x4FB3, 0xB2, 0x62, 0x50, 0xD4, 0x35, 0xC5, 0x54, 0x23);};
template<> struct uuid<Windows::Media::Audio::IAudioFrameInputNode> { define_guid(0x1B266C7, 0xFD96, 0x4FF5, 0xA3, 0xC5, 0xD2, 0x7A, 0x9B, 0xF4, 0x42, 0x37);};
template<> struct uuid<Windows::Media::Audio::IAudioFrameOutputNode> { define_guid(0xB847371B, 0x3299, 0x45F5, 0x88, 0xB3, 0xC9, 0xD1, 0x2A, 0x3F, 0x1C, 0xC8);};
template<> struct uuid<Windows::Media::Audio::IAudioNodeEmitterFactory> { define_guid(0xFDC8489A, 0x6AD6, 0x4CE4, 0xB7, 0xF7, 0xA9, 0x93, 0x70, 0xDF, 0x7E, 0xE9);};
template<> struct uuid<Windows::Media::Audio::IAudioNodeEmitter2> { define_guid(0x4AB6EECB, 0xEC29, 0x47F8, 0x81, 0x8C, 0xB6, 0xB6, 0x60, 0xA5, 0xAE, 0xB1);};
template<> struct uuid<Windows::Media::Audio::IAudioNodeEmitter> { define_guid(0x3676971D, 0x880A, 0x47B8, 0xAD, 0xF7, 0x13, 0x23, 0xA9, 0xD9, 0x65, 0xBE);};
template<> struct uuid<Windows::Media::Audio::IAudioNodeListener> { define_guid(0xD9722E16, 0xC0A, 0x41DA, 0xB7, 0x55, 0x6C, 0x77, 0x83, 0x5F, 0xB1, 0xEB);};
template<> struct uuid<Windows::Media::Audio::IAudioGraphConnection> { define_guid(0x763070ED, 0xD04E, 0x4FAC, 0xB2, 0x33, 0x60, 0xB, 0x42, 0xED, 0xD4, 0x69);};
template<> struct uuid<Windows::Media::Audio::IAudioFrameCompletedEventArgs> { define_guid(0xDC7C829E, 0x208, 0x4504, 0xA5, 0xA8, 0xF0, 0xF2, 0x68, 0x92, 0xA, 0x65);};
template<> struct uuid<Windows::Media::Audio::IFrameInputNodeQuantumStartedEventArgs> { define_guid(0x3D9BD498, 0xA306, 0x4F06, 0xBD, 0x9F, 0xE9, 0xEF, 0xC8, 0x22, 0x63, 0x4);};
template<> struct uuid<Windows::Media::Audio::IEqualizerBand> { define_guid(0xC00A5A6A, 0x262D, 0x4B85, 0x9B, 0xB7, 0x43, 0x28, 0xB, 0x62, 0xED, 0xC);};
template<> struct uuid<Windows::Media::Audio::IEqualizerEffectDefinitionFactory> { define_guid(0xD2876FC4, 0xD410, 0x4EB5, 0x9E, 0x69, 0xC9, 0xAA, 0x12, 0x77, 0xEA, 0xF0);};
template<> struct uuid<Windows::Media::Audio::IEqualizerEffectDefinition> { define_guid(0x23F6F1F, 0x83FE, 0x449A, 0xA8, 0x22, 0xC6, 0x96, 0x44, 0x2D, 0x16, 0xB0);};
template<> struct uuid<Windows::Media::Audio::IReverbEffectDefinitionFactory> { define_guid(0xA7D5CBFE, 0x100B, 0x4FF0, 0x9D, 0xA6, 0xDC, 0x4E, 0x5, 0xA7, 0x59, 0xF0);};
template<> struct uuid<Windows::Media::Audio::IReverbEffectDefinition> { define_guid(0x4606AA89, 0xF563, 0x4D0A, 0x8F, 0x6E, 0xF0, 0xCD, 0xDF, 0xF3, 0x5D, 0x84);};
template<> struct uuid<Windows::Media::Audio::IEchoEffectDefinitionFactory> { define_guid(0xD4E2257, 0xAAF2, 0x4E86, 0xA5, 0x4C, 0xFB, 0x79, 0xDB, 0x8F, 0x6C, 0x12);};
template<> struct uuid<Windows::Media::Audio::IEchoEffectDefinition> { define_guid(0xE4D3FAA, 0x36B8, 0x4C91, 0xB9, 0xDA, 0x11, 0xF4, 0x4A, 0x8A, 0x66, 0x10);};
template<> struct uuid<Windows::Media::Audio::ILimiterEffectDefinitionFactory> { define_guid(0xECBAE6F1, 0x61FF, 0x45EF, 0xB8, 0xF5, 0x48, 0x65, 0x9A, 0x57, 0xC7, 0x2D);};
template<> struct uuid<Windows::Media::Audio::ILimiterEffectDefinition> { define_guid(0x6B755D19, 0x2603, 0x47BA, 0xBD, 0xEB, 0x39, 0x5, 0x5E, 0x34, 0x86, 0xDC);};
template<> struct uuid<Windows::Media::Audio::IAudioNodeEmitterConeProperties> { define_guid(0xE99B2CEE, 0x2CA, 0x4375, 0x93, 0x26, 0xC, 0x6A, 0xE4, 0xBC, 0xDF, 0xB5);};
template<> struct uuid<Windows::Media::Audio::IAudioNodeEmitterShape> { define_guid(0xEA0311C5, 0xE73D, 0x44BC, 0x85, 0x9C, 0x45, 0x55, 0x3B, 0xBC, 0x48, 0x28);};
template<> struct uuid<Windows::Media::Audio::IAudioNodeEmitterShapeStatics> { define_guid(0x57BB2771, 0xFFA5, 0x4B86, 0xA7, 0x79, 0xE2, 0x64, 0xAE, 0xB9, 0x14, 0x5F);};
template<> struct uuid<Windows::Media::Audio::IAudioNodeEmitterNaturalDecayModelProperties> { define_guid(0x48934BCF, 0xCF2C, 0x4EFC, 0x93, 0x31, 0x75, 0xBD, 0x22, 0xDF, 0x1F, 0xC);};
template<> struct uuid<Windows::Media::Audio::IAudioNodeEmitterDecayModel> { define_guid(0x1D1D5AF7, 0xD53, 0x4FA9, 0xBD, 0x84, 0xD5, 0x81, 0x6A, 0x86, 0xF3, 0xFF);};
template<> struct uuid<Windows::Media::Audio::IAudioNodeEmitterDecayModelStatics> { define_guid(0xC7787CA8, 0xF178, 0x462F, 0xBC, 0x81, 0x8D, 0xD5, 0xCB, 0xE5, 0xDA, 0xE8);};

// types

namespace Windows { namespace Media { namespace Audio {

// IAudioStateMonitorStatics
struct IAudioStateMonitorStatics : IInspectable {
	virtual STDMETHODIMP _CreateForRenderMonitoring(AudioStateMonitor* *result);
	virtual STDMETHODIMP _CreateForRenderMonitoringWithCategory(Render::AudioRenderCategory category, AudioStateMonitor* *result);
	virtual STDMETHODIMP _CreateForRenderMonitoringWithCategoryAndDeviceRole(Render::AudioRenderCategory category, Devices::AudioDeviceRole role, AudioStateMonitor* *result);
	virtual STDMETHODIMP _CreateForRenderMonitoringWithCategoryAndDeviceId(Render::AudioRenderCategory category, HSTRING deviceId, AudioStateMonitor* *result);
	virtual STDMETHODIMP _CreateForCaptureMonitoring(AudioStateMonitor* *result);
	virtual STDMETHODIMP _CreateForCaptureMonitoringWithCategory(Capture::MediaCategory category, AudioStateMonitor* *result);
	virtual STDMETHODIMP _CreateForCaptureMonitoringWithCategoryAndDeviceRole(Capture::MediaCategory category, Devices::AudioDeviceRole role, AudioStateMonitor* *result);
	virtual STDMETHODIMP _CreateForCaptureMonitoringWithCategoryAndDeviceId(Capture::MediaCategory category, HSTRING deviceId, AudioStateMonitor* *result);
};

// IAudioStateMonitor
struct IAudioStateMonitor_raw : IInspectable {
	virtual STDMETHODIMP _add_SoundLevelChanged(Foundation::TypedEventHandler<AudioStateMonitor*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SoundLevelChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_SoundLevel(Media::SoundLevel *value);
};
template<typename X> struct IAudioStateMonitor_adaptor : X {
	union {
		struct : property {
			Media::SoundLevel get() { Media::SoundLevel value; hrcheck(enc(&IAudioStateMonitor_adaptor::SoundLevel)->_get_SoundLevel(&value)); return value; }
			Media::SoundLevel operator()() { return get(); }
			operator Media::SoundLevel () { return get(); }
		} SoundLevel;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AudioStateMonitor>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAudioStateMonitor_adaptor::SoundLevelChanged)->_add_SoundLevelChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAudioStateMonitor_adaptor::SoundLevelChanged)->_remove_SoundLevelChanged(token)); }
		} SoundLevelChanged;
	};
	IAudioStateMonitor_adaptor() {}
};
template<typename X> struct adapt<IAudioStateMonitor, X> : Windows::Media::Audio::IAudioStateMonitor_adaptor<X> { typedef adapt IAudioStateMonitor; };
struct IAudioStateMonitor : IAudioStateMonitor_raw, generate<IAudioStateMonitor> {};

// AudioStateMonitor
template<typename> struct AudioStateMonitor_statics {
	static ptr<AudioStateMonitor> CreateForRenderMonitoring() { AudioStateMonitor* result; hrcheck(get_activation_factory<AudioStateMonitor, IAudioStateMonitorStatics>()->_CreateForRenderMonitoring(&result)); return from_abi(result); }
	static ptr<AudioStateMonitor> CreateForRenderMonitoring(Render::AudioRenderCategory category) { AudioStateMonitor* result; hrcheck(get_activation_factory<AudioStateMonitor, IAudioStateMonitorStatics>()->_CreateForRenderMonitoringWithCategory(category, &result)); return from_abi(result); }
	static ptr<AudioStateMonitor> CreateForRenderMonitoring(Render::AudioRenderCategory category, Devices::AudioDeviceRole role) { AudioStateMonitor* result; hrcheck(get_activation_factory<AudioStateMonitor, IAudioStateMonitorStatics>()->_CreateForRenderMonitoringWithCategoryAndDeviceRole(category, role, &result)); return from_abi(result); }
	static ptr<AudioStateMonitor> CreateForRenderMonitoringWithCategoryAndDeviceId(Render::AudioRenderCategory category, hstring_ref deviceId) { AudioStateMonitor* result; hrcheck(get_activation_factory<AudioStateMonitor, IAudioStateMonitorStatics>()->_CreateForRenderMonitoringWithCategoryAndDeviceId(category, deviceId, &result)); return from_abi(result); }
	static ptr<AudioStateMonitor> CreateForCaptureMonitoring() { AudioStateMonitor* result; hrcheck(get_activation_factory<AudioStateMonitor, IAudioStateMonitorStatics>()->_CreateForCaptureMonitoring(&result)); return from_abi(result); }
	static ptr<AudioStateMonitor> CreateForCaptureMonitoring(Capture::MediaCategory category) { AudioStateMonitor* result; hrcheck(get_activation_factory<AudioStateMonitor, IAudioStateMonitorStatics>()->_CreateForCaptureMonitoringWithCategory(category, &result)); return from_abi(result); }
	static ptr<AudioStateMonitor> CreateForCaptureMonitoring(Capture::MediaCategory category, Devices::AudioDeviceRole role) { AudioStateMonitor* result; hrcheck(get_activation_factory<AudioStateMonitor, IAudioStateMonitorStatics>()->_CreateForCaptureMonitoringWithCategoryAndDeviceRole(category, role, &result)); return from_abi(result); }
	static ptr<AudioStateMonitor> CreateForCaptureMonitoringWithCategoryAndDeviceId(Capture::MediaCategory category, hstring_ref deviceId) { AudioStateMonitor* result; hrcheck(get_activation_factory<AudioStateMonitor, IAudioStateMonitorStatics>()->_CreateForCaptureMonitoringWithCategoryAndDeviceId(category, deviceId, &result)); return from_abi(result); }
};

template<typename X> struct statics<AudioStateMonitor, X> : X, Windows::Media::Audio::AudioStateMonitor_statics<void> {
	typedef typename X::root_type AudioStateMonitor;
};
struct AudioStateMonitor : generate<AudioStateMonitor> {};

// ICreateAudioGraphResult
struct ICreateAudioGraphResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(AudioGraphCreationStatus *value);
	virtual STDMETHODIMP _get_Graph(AudioGraph* *value);
};
template<typename X> struct ICreateAudioGraphResult_adaptor : X {
	union {
		struct : property {
			ptr<AudioGraph> get() { AudioGraph* value; hrcheck(enc(&ICreateAudioGraphResult_adaptor::Graph)->_get_Graph(&value)); return from_abi(value); }
			ptr<AudioGraph> operator()() { return get(); }
			operator ptr<AudioGraph> () { return get(); }
			ptr<AudioGraph> operator->() { return get(); }
		} Graph;
		struct : property {
			AudioGraphCreationStatus get() { AudioGraphCreationStatus value; hrcheck(enc(&ICreateAudioGraphResult_adaptor::Status)->_get_Status(&value)); return value; }
			AudioGraphCreationStatus operator()() { return get(); }
			operator AudioGraphCreationStatus () { return get(); }
		} Status;
	};
	ICreateAudioGraphResult_adaptor() {}
};
template<typename X> struct adapt<ICreateAudioGraphResult, X> : Windows::Media::Audio::ICreateAudioGraphResult_adaptor<X> { typedef adapt ICreateAudioGraphResult; };
struct ICreateAudioGraphResult : ICreateAudioGraphResult_raw, generate<ICreateAudioGraphResult> {};

// IAudioGraphStatics
struct IAudioGraphStatics : IInspectable {
	virtual STDMETHODIMP _CreateAsync(AudioGraphSettings* settings, Foundation::IAsyncOperation<CreateAudioGraphResult*>* *result);
};

// IAudioGraph3
struct IAudioGraph3_raw : IInspectable {
	virtual STDMETHODIMP _CreateMediaSourceAudioInputNodeAsync(Core::MediaSource* mediaSource, Foundation::IAsyncOperation<CreateMediaSourceAudioInputNodeResult*>* *operation);
	virtual STDMETHODIMP _CreateMediaSourceAudioInputNodeWithEmitterAsync(Core::MediaSource* mediaSource, AudioNodeEmitter* emitter, Foundation::IAsyncOperation<CreateMediaSourceAudioInputNodeResult*>* *operation);
};
template<typename X> struct IAudioGraph3_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<CreateMediaSourceAudioInputNodeResult>>> CreateMediaSourceAudioInputNodeAsync(pptr<Core::MediaSource> mediaSource) { Foundation::IAsyncOperation<CreateMediaSourceAudioInputNodeResult*>* operation; hrcheck(X::get()->_CreateMediaSourceAudioInputNodeAsync(mediaSource, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<CreateMediaSourceAudioInputNodeResult>>> CreateMediaSourceAudioInputNodeAsync(pptr<Core::MediaSource> mediaSource, pptr<AudioNodeEmitter> emitter) { Foundation::IAsyncOperation<CreateMediaSourceAudioInputNodeResult*>* operation; hrcheck(X::get()->_CreateMediaSourceAudioInputNodeWithEmitterAsync(mediaSource, emitter, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IAudioGraph3, X> : Windows::Media::Audio::IAudioGraph3_adaptor<X> { typedef adapt IAudioGraph3; };
struct IAudioGraph3 : IAudioGraph3_raw, generate<IAudioGraph3> {};

// IAudioGraph
struct IAudioGraph_raw : IInspectable {
	virtual STDMETHODIMP _CreateFrameInputNode(AudioFrameInputNode* *frameInputNode);
	virtual STDMETHODIMP _CreateFrameInputNodeWithFormat(MediaProperties::AudioEncodingProperties* encodingProperties, AudioFrameInputNode* *frameInputNode);
	virtual STDMETHODIMP _CreateDeviceInputNodeAsync(Capture::MediaCategory category, Foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult*>* *result);
	virtual STDMETHODIMP _CreateDeviceInputNodeWithFormatAsync(Capture::MediaCategory category, MediaProperties::AudioEncodingProperties* encodingProperties, Foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult*>* *result);
	virtual STDMETHODIMP _CreateDeviceInputNodeWithFormatOnDeviceAsync(Capture::MediaCategory category, MediaProperties::AudioEncodingProperties* encodingProperties, Windows::Devices::Enumeration::DeviceInformation* device, Foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult*>* *result);
	virtual STDMETHODIMP _CreateFrameOutputNode(AudioFrameOutputNode* *frameOutputNode);
	virtual STDMETHODIMP _CreateFrameOutputNodeWithFormat(MediaProperties::AudioEncodingProperties* encodingProperties, AudioFrameOutputNode* *frameOutputNode);
	virtual STDMETHODIMP _CreateDeviceOutputNodeAsync(Foundation::IAsyncOperation<CreateAudioDeviceOutputNodeResult*>* *result);
	virtual STDMETHODIMP _CreateFileInputNodeAsync(Storage::IStorageFile* file, Foundation::IAsyncOperation<CreateAudioFileInputNodeResult*>* *result);
	virtual STDMETHODIMP _CreateFileOutputNodeAsync(Storage::IStorageFile* file, Foundation::IAsyncOperation<CreateAudioFileOutputNodeResult*>* *result);
	virtual STDMETHODIMP _CreateFileOutputNodeWithFileProfileAsync(Storage::IStorageFile* file, MediaProperties::MediaEncodingProfile* fileEncodingProfile, Foundation::IAsyncOperation<CreateAudioFileOutputNodeResult*>* *result);
	virtual STDMETHODIMP _CreateSubmixNode(AudioSubmixNode* *submixNode);
	virtual STDMETHODIMP _CreateSubmixNodeWithFormat(MediaProperties::AudioEncodingProperties* encodingProperties, AudioSubmixNode* *submixNode);
	virtual STDMETHODIMP _Start();
	virtual STDMETHODIMP _Stop();
	virtual STDMETHODIMP _ResetAllNodes();
	virtual STDMETHODIMP _add_QuantumStarted(Foundation::TypedEventHandler<AudioGraph*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_QuantumStarted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_QuantumProcessed(Foundation::TypedEventHandler<AudioGraph*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_QuantumProcessed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_UnrecoverableErrorOccurred(Foundation::TypedEventHandler<AudioGraph*, AudioGraphUnrecoverableErrorOccurredEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_UnrecoverableErrorOccurred(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_CompletedQuantumCount(unsigned __int64 *value);
	virtual STDMETHODIMP _get_EncodingProperties(MediaProperties::AudioEncodingProperties* *value);
	virtual STDMETHODIMP _get_LatencyInSamples(int *value);
	virtual STDMETHODIMP _get_PrimaryRenderDevice(Windows::Devices::Enumeration::DeviceInformation* *value);
	virtual STDMETHODIMP _get_RenderDeviceAudioProcessing(AudioProcessing *value);
	virtual STDMETHODIMP _get_SamplesPerQuantum(int *value);
};
template<typename X> struct IAudioGraph_adaptor : X {
	union {
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IAudioGraph_adaptor::CompletedQuantumCount)->_get_CompletedQuantumCount(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} CompletedQuantumCount;
		struct : property {
			ptr<MediaProperties::AudioEncodingProperties> get() { MediaProperties::AudioEncodingProperties* value; hrcheck(enc(&IAudioGraph_adaptor::EncodingProperties)->_get_EncodingProperties(&value)); return from_abi(value); }
			ptr<MediaProperties::AudioEncodingProperties> operator()() { return get(); }
			operator ptr<MediaProperties::AudioEncodingProperties> () { return get(); }
			ptr<MediaProperties::AudioEncodingProperties> operator->() { return get(); }
		} EncodingProperties;
		struct : property {
			int get() { int value; hrcheck(enc(&IAudioGraph_adaptor::LatencyInSamples)->_get_LatencyInSamples(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} LatencyInSamples;
		struct : property {
			ptr<Windows::Devices::Enumeration::DeviceInformation> get() { Windows::Devices::Enumeration::DeviceInformation* value; hrcheck(enc(&IAudioGraph_adaptor::PrimaryRenderDevice)->_get_PrimaryRenderDevice(&value)); return from_abi(value); }
			ptr<Windows::Devices::Enumeration::DeviceInformation> operator()() { return get(); }
			operator ptr<Windows::Devices::Enumeration::DeviceInformation> () { return get(); }
			ptr<Windows::Devices::Enumeration::DeviceInformation> operator->() { return get(); }
		} PrimaryRenderDevice;
		struct : property {
			AudioProcessing get() { AudioProcessing value; hrcheck(enc(&IAudioGraph_adaptor::RenderDeviceAudioProcessing)->_get_RenderDeviceAudioProcessing(&value)); return value; }
			AudioProcessing operator()() { return get(); }
			operator AudioProcessing () { return get(); }
		} RenderDeviceAudioProcessing;
		struct : property {
			int get() { int value; hrcheck(enc(&IAudioGraph_adaptor::SamplesPerQuantum)->_get_SamplesPerQuantum(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} SamplesPerQuantum;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AudioGraph>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAudioGraph_adaptor::QuantumProcessed)->_add_QuantumProcessed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAudioGraph_adaptor::QuantumProcessed)->_remove_QuantumProcessed(token)); }
		} QuantumProcessed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AudioGraph>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAudioGraph_adaptor::QuantumStarted)->_add_QuantumStarted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAudioGraph_adaptor::QuantumStarted)->_remove_QuantumStarted(token)); }
		} QuantumStarted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AudioGraph>, ptr<AudioGraphUnrecoverableErrorOccurredEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAudioGraph_adaptor::UnrecoverableErrorOccurred)->_add_UnrecoverableErrorOccurred(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAudioGraph_adaptor::UnrecoverableErrorOccurred)->_remove_UnrecoverableErrorOccurred(token)); }
		} UnrecoverableErrorOccurred;
	};
	ptr<AudioFrameInputNode> CreateFrameInputNode() { AudioFrameInputNode* frameInputNode; hrcheck(X::get()->_CreateFrameInputNode(&frameInputNode)); return from_abi(frameInputNode); }
	ptr<AudioFrameInputNode> CreateFrameInputNode(pptr<MediaProperties::AudioEncodingProperties> encodingProperties) { AudioFrameInputNode* frameInputNode; hrcheck(X::get()->_CreateFrameInputNodeWithFormat(encodingProperties, &frameInputNode)); return from_abi(frameInputNode); }
	ptr<Foundation::IAsyncOperation<ptr<CreateAudioDeviceInputNodeResult>>> CreateDeviceInputNodeAsync(Capture::MediaCategory category) { Foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult*>* result; hrcheck(X::get()->_CreateDeviceInputNodeAsync(category, &result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<CreateAudioDeviceInputNodeResult>>> CreateDeviceInputNodeAsync(Capture::MediaCategory category, pptr<MediaProperties::AudioEncodingProperties> encodingProperties) { Foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult*>* result; hrcheck(X::get()->_CreateDeviceInputNodeWithFormatAsync(category, encodingProperties, &result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<CreateAudioDeviceInputNodeResult>>> CreateDeviceInputNodeAsync(Capture::MediaCategory category, pptr<MediaProperties::AudioEncodingProperties> encodingProperties, pptr<Windows::Devices::Enumeration::DeviceInformation> device) { Foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult*>* result; hrcheck(X::get()->_CreateDeviceInputNodeWithFormatOnDeviceAsync(category, encodingProperties, device, &result)); return from_abi(result); }
	ptr<AudioFrameOutputNode> CreateFrameOutputNode() { AudioFrameOutputNode* frameOutputNode; hrcheck(X::get()->_CreateFrameOutputNode(&frameOutputNode)); return from_abi(frameOutputNode); }
	ptr<AudioFrameOutputNode> CreateFrameOutputNode(pptr<MediaProperties::AudioEncodingProperties> encodingProperties) { AudioFrameOutputNode* frameOutputNode; hrcheck(X::get()->_CreateFrameOutputNodeWithFormat(encodingProperties, &frameOutputNode)); return from_abi(frameOutputNode); }
	ptr<Foundation::IAsyncOperation<ptr<CreateAudioDeviceOutputNodeResult>>> CreateDeviceOutputNodeAsync() { Foundation::IAsyncOperation<CreateAudioDeviceOutputNodeResult*>* result; hrcheck(X::get()->_CreateDeviceOutputNodeAsync(&result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<CreateAudioFileInputNodeResult>>> CreateFileInputNodeAsync(pptr<Storage::IStorageFile> file) { Foundation::IAsyncOperation<CreateAudioFileInputNodeResult*>* result; hrcheck(X::get()->_CreateFileInputNodeAsync(file, &result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<CreateAudioFileOutputNodeResult>>> CreateFileOutputNodeAsync(pptr<Storage::IStorageFile> file) { Foundation::IAsyncOperation<CreateAudioFileOutputNodeResult*>* result; hrcheck(X::get()->_CreateFileOutputNodeAsync(file, &result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<CreateAudioFileOutputNodeResult>>> CreateFileOutputNodeAsync(pptr<Storage::IStorageFile> file, pptr<MediaProperties::MediaEncodingProfile> fileEncodingProfile) { Foundation::IAsyncOperation<CreateAudioFileOutputNodeResult*>* result; hrcheck(X::get()->_CreateFileOutputNodeWithFileProfileAsync(file, fileEncodingProfile, &result)); return from_abi(result); }
	ptr<AudioSubmixNode> CreateSubmixNode() { AudioSubmixNode* submixNode; hrcheck(X::get()->_CreateSubmixNode(&submixNode)); return from_abi(submixNode); }
	ptr<AudioSubmixNode> CreateSubmixNode(pptr<MediaProperties::AudioEncodingProperties> encodingProperties) { AudioSubmixNode* submixNode; hrcheck(X::get()->_CreateSubmixNodeWithFormat(encodingProperties, &submixNode)); return from_abi(submixNode); }
	void Start() { hrcheck(X::get()->_Start()); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	void ResetAllNodes() { hrcheck(X::get()->_ResetAllNodes()); }
	IAudioGraph_adaptor() {}
};
template<typename X> struct adapt<IAudioGraph, X> : Windows::Media::Audio::IAudioGraph_adaptor<X> { typedef adapt IAudioGraph; };
struct IAudioGraph : IAudioGraph_raw, generate<IAudioGraph> {};

// IAudioGraph2
struct IAudioGraph2_raw : IInspectable {
	virtual STDMETHODIMP _CreateFrameInputNodeWithFormatAndEmitter(MediaProperties::AudioEncodingProperties* encodingProperties, AudioNodeEmitter* emitter, AudioFrameInputNode* *frameInputNode);
	virtual STDMETHODIMP _CreateDeviceInputNodeWithFormatAndEmitterOnDeviceAsync(Capture::MediaCategory category, MediaProperties::AudioEncodingProperties* encodingProperties, Windows::Devices::Enumeration::DeviceInformation* device, AudioNodeEmitter* emitter, Foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult*>* *result);
	virtual STDMETHODIMP _CreateFileInputNodeWithEmitterAsync(Storage::IStorageFile* file, AudioNodeEmitter* emitter, Foundation::IAsyncOperation<CreateAudioFileInputNodeResult*>* *result);
	virtual STDMETHODIMP _CreateSubmixNodeWithFormatAndEmitter(MediaProperties::AudioEncodingProperties* encodingProperties, AudioNodeEmitter* emitter, AudioSubmixNode* *submixNode);
	virtual STDMETHODIMP _CreateBatchUpdater(AudioGraphBatchUpdater* *updater);
};
template<typename X> struct IAudioGraph2_adaptor : X {
	ptr<AudioFrameInputNode> CreateFrameInputNode(pptr<MediaProperties::AudioEncodingProperties> encodingProperties, pptr<AudioNodeEmitter> emitter) { AudioFrameInputNode* frameInputNode; hrcheck(X::get()->_CreateFrameInputNodeWithFormatAndEmitter(encodingProperties, emitter, &frameInputNode)); return from_abi(frameInputNode); }
	ptr<Foundation::IAsyncOperation<ptr<CreateAudioDeviceInputNodeResult>>> CreateDeviceInputNodeAsync(Capture::MediaCategory category, pptr<MediaProperties::AudioEncodingProperties> encodingProperties, pptr<Windows::Devices::Enumeration::DeviceInformation> device, pptr<AudioNodeEmitter> emitter) { Foundation::IAsyncOperation<CreateAudioDeviceInputNodeResult*>* result; hrcheck(X::get()->_CreateDeviceInputNodeWithFormatAndEmitterOnDeviceAsync(category, encodingProperties, device, emitter, &result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<CreateAudioFileInputNodeResult>>> CreateFileInputNodeAsync(pptr<Storage::IStorageFile> file, pptr<AudioNodeEmitter> emitter) { Foundation::IAsyncOperation<CreateAudioFileInputNodeResult*>* result; hrcheck(X::get()->_CreateFileInputNodeWithEmitterAsync(file, emitter, &result)); return from_abi(result); }
	ptr<AudioSubmixNode> CreateSubmixNode(pptr<MediaProperties::AudioEncodingProperties> encodingProperties, pptr<AudioNodeEmitter> emitter) { AudioSubmixNode* submixNode; hrcheck(X::get()->_CreateSubmixNodeWithFormatAndEmitter(encodingProperties, emitter, &submixNode)); return from_abi(submixNode); }
	ptr<AudioGraphBatchUpdater> CreateBatchUpdater() { AudioGraphBatchUpdater* updater; hrcheck(X::get()->_CreateBatchUpdater(&updater)); return from_abi(updater); }
};
template<typename X> struct adapt<IAudioGraph2, X> : Windows::Media::Audio::IAudioGraph2_adaptor<X> { typedef adapt IAudioGraph2; };
struct IAudioGraph2 : IAudioGraph2_raw, generate<IAudioGraph2> {};

// AudioGraph
template<typename> struct AudioGraph_statics {
	static ptr<Foundation::IAsyncOperation<ptr<CreateAudioGraphResult>>> CreateAsync(pptr<AudioGraphSettings> settings) { Foundation::IAsyncOperation<CreateAudioGraphResult*>* result; hrcheck(get_activation_factory<AudioGraph, IAudioGraphStatics>()->_CreateAsync(settings, &result)); return from_abi(result); }
};

template<typename X> struct statics<AudioGraph, X> : X, Windows::Media::Audio::AudioGraph_statics<void> {
	typedef typename X::root_type AudioGraph;
};
struct AudioGraph : generate<AudioGraph> {
	using IAudioGraph::CreateFileOutputNodeAsync;
	using IAudioGraph::CreateFileInputNodeAsync;
	using IAudioGraph2::CreateFileInputNodeAsync;
	using IAudioGraph::CreateFrameOutputNode;
	using IAudioGraph3::CreateMediaSourceAudioInputNodeAsync;
	using IAudioGraph::CreateFrameInputNode;
	using IAudioGraph2::CreateFrameInputNode;
	using IAudioGraph::CreateDeviceInputNodeAsync;
	using IAudioGraph2::CreateDeviceInputNodeAsync;
	using IAudioGraph::CreateSubmixNode;
	using IAudioGraph2::CreateSubmixNode;
};

// CreateAudioGraphResult
template<typename X> struct statics<CreateAudioGraphResult, X> : X {
	typedef typename X::root_type CreateAudioGraphResult;
};
struct CreateAudioGraphResult : generate<CreateAudioGraphResult> {};

// IAudioGraphSettingsFactory
struct IAudioGraphSettingsFactory : IInspectable {
	virtual STDMETHODIMP _Create(Render::AudioRenderCategory audioRenderCategory, AudioGraphSettings* *value);
};

// IAudioGraphSettings2
struct IAudioGraphSettings2_raw : IInspectable {
	virtual STDMETHODIMP _put_MaxPlaybackSpeedFactor(double value);
	virtual STDMETHODIMP _get_MaxPlaybackSpeedFactor(double *value);
};
template<typename X> struct IAudioGraphSettings2_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioGraphSettings2_adaptor::MaxPlaybackSpeedFactor)->_get_MaxPlaybackSpeedFactor(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IAudioGraphSettings2_adaptor::MaxPlaybackSpeedFactor)->_put_MaxPlaybackSpeedFactor(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MaxPlaybackSpeedFactor;
	};
	IAudioGraphSettings2_adaptor() {}
};
template<typename X> struct adapt<IAudioGraphSettings2, X> : Windows::Media::Audio::IAudioGraphSettings2_adaptor<X> { typedef adapt IAudioGraphSettings2; };
struct IAudioGraphSettings2 : IAudioGraphSettings2_raw, generate<IAudioGraphSettings2> {};

// IAudioGraphSettings
struct IAudioGraphSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_EncodingProperties(MediaProperties::AudioEncodingProperties* *value);
	virtual STDMETHODIMP _put_EncodingProperties(MediaProperties::AudioEncodingProperties* value);
	virtual STDMETHODIMP _get_PrimaryRenderDevice(Windows::Devices::Enumeration::DeviceInformation* *value);
	virtual STDMETHODIMP _put_PrimaryRenderDevice(Windows::Devices::Enumeration::DeviceInformation* value);
	virtual STDMETHODIMP _get_QuantumSizeSelectionMode(Audio::QuantumSizeSelectionMode *value);
	virtual STDMETHODIMP _put_QuantumSizeSelectionMode(Audio::QuantumSizeSelectionMode value);
	virtual STDMETHODIMP _get_DesiredSamplesPerQuantum(int *value);
	virtual STDMETHODIMP _put_DesiredSamplesPerQuantum(int value);
	virtual STDMETHODIMP _get_AudioRenderCategory(Render::AudioRenderCategory *value);
	virtual STDMETHODIMP _put_AudioRenderCategory(Render::AudioRenderCategory value);
	virtual STDMETHODIMP _get_DesiredRenderDeviceAudioProcessing(AudioProcessing *value);
	virtual STDMETHODIMP _put_DesiredRenderDeviceAudioProcessing(AudioProcessing value);
};
template<typename X> struct IAudioGraphSettings_adaptor : X {
	union {
		struct : property {
			Render::AudioRenderCategory get() { Render::AudioRenderCategory value; hrcheck(enc(&IAudioGraphSettings_adaptor::AudioRenderCategory)->_get_AudioRenderCategory(&value)); return value; }
			Render::AudioRenderCategory operator()() { return get(); }
			operator Render::AudioRenderCategory () { return get(); }
			void put(Render::AudioRenderCategory value) { hrcheck(enc(&IAudioGraphSettings_adaptor::AudioRenderCategory)->_put_AudioRenderCategory(value)); }
			void operator=(Render::AudioRenderCategory value) { put(value); }
			void operator()(Render::AudioRenderCategory value) { put(value); }
		} AudioRenderCategory;
		struct : property {
			AudioProcessing get() { AudioProcessing value; hrcheck(enc(&IAudioGraphSettings_adaptor::DesiredRenderDeviceAudioProcessing)->_get_DesiredRenderDeviceAudioProcessing(&value)); return value; }
			AudioProcessing operator()() { return get(); }
			operator AudioProcessing () { return get(); }
			void put(AudioProcessing value) { hrcheck(enc(&IAudioGraphSettings_adaptor::DesiredRenderDeviceAudioProcessing)->_put_DesiredRenderDeviceAudioProcessing(value)); }
			void operator=(AudioProcessing value) { put(value); }
			void operator()(AudioProcessing value) { put(value); }
		} DesiredRenderDeviceAudioProcessing;
		struct : property {
			int get() { int value; hrcheck(enc(&IAudioGraphSettings_adaptor::DesiredSamplesPerQuantum)->_get_DesiredSamplesPerQuantum(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IAudioGraphSettings_adaptor::DesiredSamplesPerQuantum)->_put_DesiredSamplesPerQuantum(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} DesiredSamplesPerQuantum;
		struct : property {
			ptr<MediaProperties::AudioEncodingProperties> get() { MediaProperties::AudioEncodingProperties* value; hrcheck(enc(&IAudioGraphSettings_adaptor::EncodingProperties)->_get_EncodingProperties(&value)); return from_abi(value); }
			ptr<MediaProperties::AudioEncodingProperties> operator()() { return get(); }
			operator ptr<MediaProperties::AudioEncodingProperties> () { return get(); }
			ptr<MediaProperties::AudioEncodingProperties> operator->() { return get(); }
			void put(pptr<MediaProperties::AudioEncodingProperties> value) { hrcheck(enc(&IAudioGraphSettings_adaptor::EncodingProperties)->_put_EncodingProperties(value)); }
			void operator=(pptr<MediaProperties::AudioEncodingProperties> value) { put(value); }
			void operator()(pptr<MediaProperties::AudioEncodingProperties> value) { put(value); }
		} EncodingProperties;
		struct : property {
			ptr<Windows::Devices::Enumeration::DeviceInformation> get() { Windows::Devices::Enumeration::DeviceInformation* value; hrcheck(enc(&IAudioGraphSettings_adaptor::PrimaryRenderDevice)->_get_PrimaryRenderDevice(&value)); return from_abi(value); }
			ptr<Windows::Devices::Enumeration::DeviceInformation> operator()() { return get(); }
			operator ptr<Windows::Devices::Enumeration::DeviceInformation> () { return get(); }
			ptr<Windows::Devices::Enumeration::DeviceInformation> operator->() { return get(); }
			void put(pptr<Windows::Devices::Enumeration::DeviceInformation> value) { hrcheck(enc(&IAudioGraphSettings_adaptor::PrimaryRenderDevice)->_put_PrimaryRenderDevice(value)); }
			void operator=(pptr<Windows::Devices::Enumeration::DeviceInformation> value) { put(value); }
			void operator()(pptr<Windows::Devices::Enumeration::DeviceInformation> value) { put(value); }
		} PrimaryRenderDevice;
		struct : property {
			Audio::QuantumSizeSelectionMode get() { Audio::QuantumSizeSelectionMode value; hrcheck(enc(&IAudioGraphSettings_adaptor::QuantumSizeSelectionMode)->_get_QuantumSizeSelectionMode(&value)); return value; }
			Audio::QuantumSizeSelectionMode operator()() { return get(); }
			operator Audio::QuantumSizeSelectionMode () { return get(); }
			void put(Audio::QuantumSizeSelectionMode value) { hrcheck(enc(&IAudioGraphSettings_adaptor::QuantumSizeSelectionMode)->_put_QuantumSizeSelectionMode(value)); }
			void operator=(Audio::QuantumSizeSelectionMode value) { put(value); }
			void operator()(Audio::QuantumSizeSelectionMode value) { put(value); }
		} QuantumSizeSelectionMode;
	};
	IAudioGraphSettings_adaptor() {}
};
template<typename X> struct adapt<IAudioGraphSettings, X> : Windows::Media::Audio::IAudioGraphSettings_adaptor<X> { typedef adapt IAudioGraphSettings; };
struct IAudioGraphSettings : IAudioGraphSettings_raw, generate<IAudioGraphSettings> {};

// AudioGraphSettings
template<typename> struct AudioGraphSettings_statics {
	static AudioGraphSettings *activate(Render::AudioRenderCategory audioRenderCategory) { AudioGraphSettings *value; hrcheck(get_activation_factory<AudioGraphSettings, IAudioGraphSettingsFactory>()->_Create(audioRenderCategory, &value)); return value; }
};

template<typename X> struct statics<AudioGraphSettings, X> : X, Windows::Media::Audio::AudioGraphSettings_statics<void> {
	using Windows::Media::Audio::AudioGraphSettings_statics<void>::activate;
	typedef typename X::root_type AudioGraphSettings;
};
struct AudioGraphSettings : generate<AudioGraphSettings> {};

// ICreateAudioDeviceInputNodeResult
struct ICreateAudioDeviceInputNodeResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(AudioDeviceNodeCreationStatus *value);
	virtual STDMETHODIMP _get_DeviceInputNode(AudioDeviceInputNode* *value);
};
template<typename X> struct ICreateAudioDeviceInputNodeResult_adaptor : X {
	union {
		struct : property {
			ptr<AudioDeviceInputNode> get() { AudioDeviceInputNode* value; hrcheck(enc(&ICreateAudioDeviceInputNodeResult_adaptor::DeviceInputNode)->_get_DeviceInputNode(&value)); return from_abi(value); }
			ptr<AudioDeviceInputNode> operator()() { return get(); }
			operator ptr<AudioDeviceInputNode> () { return get(); }
			ptr<AudioDeviceInputNode> operator->() { return get(); }
		} DeviceInputNode;
		struct : property {
			AudioDeviceNodeCreationStatus get() { AudioDeviceNodeCreationStatus value; hrcheck(enc(&ICreateAudioDeviceInputNodeResult_adaptor::Status)->_get_Status(&value)); return value; }
			AudioDeviceNodeCreationStatus operator()() { return get(); }
			operator AudioDeviceNodeCreationStatus () { return get(); }
		} Status;
	};
	ICreateAudioDeviceInputNodeResult_adaptor() {}
};
template<typename X> struct adapt<ICreateAudioDeviceInputNodeResult, X> : Windows::Media::Audio::ICreateAudioDeviceInputNodeResult_adaptor<X> { typedef adapt ICreateAudioDeviceInputNodeResult; };
struct ICreateAudioDeviceInputNodeResult : ICreateAudioDeviceInputNodeResult_raw, generate<ICreateAudioDeviceInputNodeResult> {};

// IAudioNode
struct IAudioNode_raw : IInspectable {
	virtual STDMETHODIMP _get_EffectDefinitions(Foundation::Collections::IVector<Effects::IAudioEffectDefinition*>* *value) = 0;
	virtual STDMETHODIMP _put_OutgoingGain(double value) = 0;
	virtual STDMETHODIMP _get_OutgoingGain(double *value) = 0;
	virtual STDMETHODIMP _get_EncodingProperties(MediaProperties::AudioEncodingProperties* *value) = 0;
	virtual STDMETHODIMP _get_ConsumeInput(bool *value) = 0;
	virtual STDMETHODIMP _put_ConsumeInput(bool value) = 0;
	virtual STDMETHODIMP _Start() = 0;
	virtual STDMETHODIMP _Stop() = 0;
	virtual STDMETHODIMP _Reset() = 0;
	virtual STDMETHODIMP _DisableEffectsByDefinition(Effects::IAudioEffectDefinition* definition) = 0;
	virtual STDMETHODIMP _EnableEffectsByDefinition(Effects::IAudioEffectDefinition* definition) = 0;
};
template<typename X> struct IAudioNode_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAudioNode_adaptor::ConsumeInput)->_get_ConsumeInput(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IAudioNode_adaptor::ConsumeInput)->_put_ConsumeInput(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ConsumeInput;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Effects::IAudioEffectDefinition>>> get() { Foundation::Collections::IVector<Effects::IAudioEffectDefinition*>* value; hrcheck(enc(&IAudioNode_adaptor::EffectDefinitions)->_get_EffectDefinitions(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Effects::IAudioEffectDefinition>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Effects::IAudioEffectDefinition>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Effects::IAudioEffectDefinition>>> operator->() { return get(); }
		} EffectDefinitions;
		struct : property {
			ptr<MediaProperties::AudioEncodingProperties> get() { MediaProperties::AudioEncodingProperties* value; hrcheck(enc(&IAudioNode_adaptor::EncodingProperties)->_get_EncodingProperties(&value)); return from_abi(value); }
			ptr<MediaProperties::AudioEncodingProperties> operator()() { return get(); }
			operator ptr<MediaProperties::AudioEncodingProperties> () { return get(); }
			ptr<MediaProperties::AudioEncodingProperties> operator->() { return get(); }
		} EncodingProperties;
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioNode_adaptor::OutgoingGain)->_get_OutgoingGain(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IAudioNode_adaptor::OutgoingGain)->_put_OutgoingGain(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} OutgoingGain;
	};
	void Start() { hrcheck(X::get()->_Start()); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	void Reset() { hrcheck(X::get()->_Reset()); }
	void DisableEffectsByDefinition(pptr<Effects::IAudioEffectDefinition> definition) { hrcheck(X::get()->_DisableEffectsByDefinition(definition)); }
	void EnableEffectsByDefinition(pptr<Effects::IAudioEffectDefinition> definition) { hrcheck(X::get()->_EnableEffectsByDefinition(definition)); }
	IAudioNode_adaptor() {}
};
template<typename X> struct adapt<IAudioNode, X> : Windows::Media::Audio::IAudioNode_adaptor<X> { typedef adapt IAudioNode; };
template<typename X> struct IAudioNode_unadaptor : X {
	STDMETHODIMP _get_EffectDefinitions(Foundation::Collections::IVector<Effects::IAudioEffectDefinition*>* *value) { return hrtry([&, this] { get_prop(value, EffectDefinitions); }); }
	STDMETHODIMP _put_OutgoingGain(double value) { return hrtry([&, this] { put_prop(value, OutgoingGain); }); }
	STDMETHODIMP _get_OutgoingGain(double *value) { return hrtry([&, this] { get_prop(value, OutgoingGain); }); }
	STDMETHODIMP _get_EncodingProperties(MediaProperties::AudioEncodingProperties* *value) { return hrtry([&, this] { get_prop(value, EncodingProperties); }); }
	STDMETHODIMP _get_ConsumeInput(bool *value) { return hrtry([&, this] { get_prop(value, ConsumeInput); }); }
	STDMETHODIMP _put_ConsumeInput(bool value) { return hrtry([&, this] { put_prop(value, ConsumeInput); }); }
	STDMETHODIMP _Start() { return hrtry([&, this] { X::get()->Start(); }); }
	STDMETHODIMP _Stop() { return hrtry([&, this] { X::get()->Stop(); }); }
	STDMETHODIMP _Reset() { return hrtry([&, this] { X::get()->Reset(); }); }
	STDMETHODIMP _DisableEffectsByDefinition(Effects::IAudioEffectDefinition* definition) { return hrtry([&, this] { X::get()->DisableEffectsByDefinition(definition); }); }
	STDMETHODIMP _EnableEffectsByDefinition(Effects::IAudioEffectDefinition* definition) { return hrtry([&, this] { X::get()->EnableEffectsByDefinition(definition); }); }
};
template<typename X> struct unadapt<IAudioNode, X> : Windows::Media::Audio::IAudioNode_unadaptor<X> {};
struct IAudioNode : IAudioNode_raw, generate<IAudioNode> {};

// IAudioInputNode
struct IAudioInputNode_raw : IInspectable {
	virtual STDMETHODIMP _get_OutgoingConnections(Foundation::Collections::IVectorView<AudioGraphConnection*>* *value) = 0;
	virtual STDMETHODIMP _AddOutgoingConnection(IAudioNode* destination) = 0;
	virtual STDMETHODIMP _AddOutgoingConnectionWithGain(IAudioNode* destination, double gain) = 0;
	virtual STDMETHODIMP _RemoveOutgoingConnection(IAudioNode* destination) = 0;
};
template<typename X> struct IAudioInputNode_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<AudioGraphConnection>>> get() { Foundation::Collections::IVectorView<AudioGraphConnection*>* value; hrcheck(enc(&IAudioInputNode_adaptor::OutgoingConnections)->_get_OutgoingConnections(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<AudioGraphConnection>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<AudioGraphConnection>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<AudioGraphConnection>>> operator->() { return get(); }
		} OutgoingConnections;
	};
	void AddOutgoingConnection(pptr<IAudioNode> destination) { hrcheck(X::get()->_AddOutgoingConnection(destination)); }
	void AddOutgoingConnection(pptr<IAudioNode> destination, double gain) { hrcheck(X::get()->_AddOutgoingConnectionWithGain(destination, gain)); }
	void RemoveOutgoingConnection(pptr<IAudioNode> destination) { hrcheck(X::get()->_RemoveOutgoingConnection(destination)); }
	IAudioInputNode_adaptor() {}
};
template<typename X> struct adapt<IAudioInputNode, X> : Windows::Media::Audio::IAudioInputNode_adaptor<X> { typedef adapt IAudioInputNode; };
template<typename X> struct IAudioInputNode_unadaptor : X {
	STDMETHODIMP _get_OutgoingConnections(Foundation::Collections::IVectorView<AudioGraphConnection*>* *value) { return hrtry([&, this] { get_prop(value, OutgoingConnections); }); }
	STDMETHODIMP _AddOutgoingConnection(IAudioNode* destination) { return hrtry([&, this] { X::get()->AddOutgoingConnection(destination); }); }
	STDMETHODIMP _AddOutgoingConnectionWithGain(IAudioNode* destination, double gain) { return hrtry([&, this] { X::get()->AddOutgoingConnection(destination, gain); }); }
	STDMETHODIMP _RemoveOutgoingConnection(IAudioNode* destination) { return hrtry([&, this] { X::get()->RemoveOutgoingConnection(destination); }); }
};
template<typename X> struct unadapt<IAudioInputNode, X> : Windows::Media::Audio::IAudioInputNode_unadaptor<X> {};
struct IAudioInputNode : IAudioInputNode_raw, generate<IAudioInputNode> {};

// IAudioInputNode2
struct IAudioInputNode2_raw : IInspectable {
	virtual STDMETHODIMP _get_Emitter(AudioNodeEmitter* *value) = 0;
};
template<typename X> struct IAudioInputNode2_adaptor : X {
	union {
		struct : property {
			ptr<AudioNodeEmitter> get() { AudioNodeEmitter* value; hrcheck(enc(&IAudioInputNode2_adaptor::Emitter)->_get_Emitter(&value)); return from_abi(value); }
			ptr<AudioNodeEmitter> operator()() { return get(); }
			operator ptr<AudioNodeEmitter> () { return get(); }
			ptr<AudioNodeEmitter> operator->() { return get(); }
		} Emitter;
	};
	IAudioInputNode2_adaptor() {}
};
template<typename X> struct adapt<IAudioInputNode2, X> : Windows::Media::Audio::IAudioInputNode2_adaptor<X> { typedef adapt IAudioInputNode2; };
template<typename X> struct IAudioInputNode2_unadaptor : X {
	STDMETHODIMP _get_Emitter(AudioNodeEmitter* *value) { return hrtry([&, this] { get_prop(value, Emitter); }); }
};
template<typename X> struct unadapt<IAudioInputNode2, X> : Windows::Media::Audio::IAudioInputNode2_unadaptor<X> {};
struct IAudioInputNode2 : IAudioInputNode2_raw, generate<IAudioInputNode2> {};

// IAudioDeviceInputNode
struct IAudioDeviceInputNode_raw : IInspectable {
	virtual STDMETHODIMP _get_Device(Windows::Devices::Enumeration::DeviceInformation* *value);
};
template<typename X> struct IAudioDeviceInputNode_adaptor : X {
	union {
		struct : property {
			ptr<Windows::Devices::Enumeration::DeviceInformation> get() { Windows::Devices::Enumeration::DeviceInformation* value; hrcheck(enc(&IAudioDeviceInputNode_adaptor::Device)->_get_Device(&value)); return from_abi(value); }
			ptr<Windows::Devices::Enumeration::DeviceInformation> operator()() { return get(); }
			operator ptr<Windows::Devices::Enumeration::DeviceInformation> () { return get(); }
			ptr<Windows::Devices::Enumeration::DeviceInformation> operator->() { return get(); }
		} Device;
	};
	IAudioDeviceInputNode_adaptor() {}
};
template<typename X> struct adapt<IAudioDeviceInputNode, X> : Windows::Media::Audio::IAudioDeviceInputNode_adaptor<X> { typedef adapt IAudioDeviceInputNode; };
struct IAudioDeviceInputNode : IAudioDeviceInputNode_raw, generate<IAudioDeviceInputNode> {};

// AudioDeviceInputNode
template<typename X> struct statics<AudioDeviceInputNode, X> : X {
	typedef typename X::root_type AudioDeviceInputNode;
};
struct AudioDeviceInputNode : generate<AudioDeviceInputNode> {
	using IAudioInputNode::AddOutgoingConnection;
};

// CreateAudioDeviceInputNodeResult
template<typename X> struct statics<CreateAudioDeviceInputNodeResult, X> : X {
	typedef typename X::root_type CreateAudioDeviceInputNodeResult;
};
struct CreateAudioDeviceInputNodeResult : generate<CreateAudioDeviceInputNodeResult> {};

// ICreateAudioDeviceOutputNodeResult
struct ICreateAudioDeviceOutputNodeResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(AudioDeviceNodeCreationStatus *value);
	virtual STDMETHODIMP _get_DeviceOutputNode(AudioDeviceOutputNode* *value);
};
template<typename X> struct ICreateAudioDeviceOutputNodeResult_adaptor : X {
	union {
		struct : property {
			ptr<AudioDeviceOutputNode> get() { AudioDeviceOutputNode* value; hrcheck(enc(&ICreateAudioDeviceOutputNodeResult_adaptor::DeviceOutputNode)->_get_DeviceOutputNode(&value)); return from_abi(value); }
			ptr<AudioDeviceOutputNode> operator()() { return get(); }
			operator ptr<AudioDeviceOutputNode> () { return get(); }
			ptr<AudioDeviceOutputNode> operator->() { return get(); }
		} DeviceOutputNode;
		struct : property {
			AudioDeviceNodeCreationStatus get() { AudioDeviceNodeCreationStatus value; hrcheck(enc(&ICreateAudioDeviceOutputNodeResult_adaptor::Status)->_get_Status(&value)); return value; }
			AudioDeviceNodeCreationStatus operator()() { return get(); }
			operator AudioDeviceNodeCreationStatus () { return get(); }
		} Status;
	};
	ICreateAudioDeviceOutputNodeResult_adaptor() {}
};
template<typename X> struct adapt<ICreateAudioDeviceOutputNodeResult, X> : Windows::Media::Audio::ICreateAudioDeviceOutputNodeResult_adaptor<X> { typedef adapt ICreateAudioDeviceOutputNodeResult; };
struct ICreateAudioDeviceOutputNodeResult : ICreateAudioDeviceOutputNodeResult_raw, generate<ICreateAudioDeviceOutputNodeResult> {};

// IAudioNodeWithListener
struct IAudioNodeWithListener_raw : IInspectable {
	virtual STDMETHODIMP _put_Listener(AudioNodeListener* value) = 0;
	virtual STDMETHODIMP _get_Listener(AudioNodeListener* *value) = 0;
};
template<typename X> struct IAudioNodeWithListener_adaptor : X {
	union {
		struct : property {
			ptr<AudioNodeListener> get() { AudioNodeListener* value; hrcheck(enc(&IAudioNodeWithListener_adaptor::Listener)->_get_Listener(&value)); return from_abi(value); }
			ptr<AudioNodeListener> operator()() { return get(); }
			operator ptr<AudioNodeListener> () { return get(); }
			ptr<AudioNodeListener> operator->() { return get(); }
			void put(pptr<AudioNodeListener> value) { hrcheck(enc(&IAudioNodeWithListener_adaptor::Listener)->_put_Listener(value)); }
			void operator=(pptr<AudioNodeListener> value) { put(value); }
			void operator()(pptr<AudioNodeListener> value) { put(value); }
		} Listener;
	};
	IAudioNodeWithListener_adaptor() {}
};
template<typename X> struct adapt<IAudioNodeWithListener, X> : Windows::Media::Audio::IAudioNodeWithListener_adaptor<X> { typedef adapt IAudioNodeWithListener; };
template<typename X> struct IAudioNodeWithListener_unadaptor : X {
	STDMETHODIMP _put_Listener(AudioNodeListener* value) { return hrtry([&, this] { put_prop(value, Listener); }); }
	STDMETHODIMP _get_Listener(AudioNodeListener* *value) { return hrtry([&, this] { get_prop(value, Listener); }); }
};
template<typename X> struct unadapt<IAudioNodeWithListener, X> : Windows::Media::Audio::IAudioNodeWithListener_unadaptor<X> {};
struct IAudioNodeWithListener : IAudioNodeWithListener_raw, generate<IAudioNodeWithListener> {};

// IAudioDeviceOutputNode
struct IAudioDeviceOutputNode_raw : IInspectable {
	virtual STDMETHODIMP _get_Device(Windows::Devices::Enumeration::DeviceInformation* *value);
};
template<typename X> struct IAudioDeviceOutputNode_adaptor : X {
	union {
		struct : property {
			ptr<Windows::Devices::Enumeration::DeviceInformation> get() { Windows::Devices::Enumeration::DeviceInformation* value; hrcheck(enc(&IAudioDeviceOutputNode_adaptor::Device)->_get_Device(&value)); return from_abi(value); }
			ptr<Windows::Devices::Enumeration::DeviceInformation> operator()() { return get(); }
			operator ptr<Windows::Devices::Enumeration::DeviceInformation> () { return get(); }
			ptr<Windows::Devices::Enumeration::DeviceInformation> operator->() { return get(); }
		} Device;
	};
	IAudioDeviceOutputNode_adaptor() {}
};
template<typename X> struct adapt<IAudioDeviceOutputNode, X> : Windows::Media::Audio::IAudioDeviceOutputNode_adaptor<X> { typedef adapt IAudioDeviceOutputNode; };
struct IAudioDeviceOutputNode : IAudioDeviceOutputNode_raw, generate<IAudioDeviceOutputNode> {};

// AudioDeviceOutputNode
template<typename X> struct statics<AudioDeviceOutputNode, X> : X {
	typedef typename X::root_type AudioDeviceOutputNode;
};
struct AudioDeviceOutputNode : generate<AudioDeviceOutputNode> {};

// CreateAudioDeviceOutputNodeResult
template<typename X> struct statics<CreateAudioDeviceOutputNodeResult, X> : X {
	typedef typename X::root_type CreateAudioDeviceOutputNodeResult;
};
struct CreateAudioDeviceOutputNodeResult : generate<CreateAudioDeviceOutputNodeResult> {};

// ICreateAudioFileInputNodeResult
struct ICreateAudioFileInputNodeResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(AudioFileNodeCreationStatus *value);
	virtual STDMETHODIMP _get_FileInputNode(AudioFileInputNode* *value);
};
template<typename X> struct ICreateAudioFileInputNodeResult_adaptor : X {
	union {
		struct : property {
			ptr<AudioFileInputNode> get() { AudioFileInputNode* value; hrcheck(enc(&ICreateAudioFileInputNodeResult_adaptor::FileInputNode)->_get_FileInputNode(&value)); return from_abi(value); }
			ptr<AudioFileInputNode> operator()() { return get(); }
			operator ptr<AudioFileInputNode> () { return get(); }
			ptr<AudioFileInputNode> operator->() { return get(); }
		} FileInputNode;
		struct : property {
			AudioFileNodeCreationStatus get() { AudioFileNodeCreationStatus value; hrcheck(enc(&ICreateAudioFileInputNodeResult_adaptor::Status)->_get_Status(&value)); return value; }
			AudioFileNodeCreationStatus operator()() { return get(); }
			operator AudioFileNodeCreationStatus () { return get(); }
		} Status;
	};
	ICreateAudioFileInputNodeResult_adaptor() {}
};
template<typename X> struct adapt<ICreateAudioFileInputNodeResult, X> : Windows::Media::Audio::ICreateAudioFileInputNodeResult_adaptor<X> { typedef adapt ICreateAudioFileInputNodeResult; };
struct ICreateAudioFileInputNodeResult : ICreateAudioFileInputNodeResult_raw, generate<ICreateAudioFileInputNodeResult> {};

// IAudioFileInputNode
struct IAudioFileInputNode_raw : IInspectable {
	virtual STDMETHODIMP _put_PlaybackSpeedFactor(double value);
	virtual STDMETHODIMP _get_PlaybackSpeedFactor(double *value);
	virtual STDMETHODIMP _get_Position(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _Seek(Foundation::TimeSpan position);
	virtual STDMETHODIMP _get_StartTime(Foundation::IReference<Foundation::TimeSpan>* *value);
	virtual STDMETHODIMP _put_StartTime(Foundation::IReference<Foundation::TimeSpan>* value);
	virtual STDMETHODIMP _get_EndTime(Foundation::IReference<Foundation::TimeSpan>* *value);
	virtual STDMETHODIMP _put_EndTime(Foundation::IReference<Foundation::TimeSpan>* value);
	virtual STDMETHODIMP _get_LoopCount(Foundation::IReference<int>* *value);
	virtual STDMETHODIMP _put_LoopCount(Foundation::IReference<int>* value);
	virtual STDMETHODIMP _get_Duration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_SourceFile(Storage::StorageFile* *value);
	virtual STDMETHODIMP _add_FileCompleted(Foundation::TypedEventHandler<AudioFileInputNode*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_FileCompleted(Foundation::EventRegistrationToken token);
};
template<typename X> struct IAudioFileInputNode_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IAudioFileInputNode_adaptor::Duration)->_get_Duration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} Duration;
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IAudioFileInputNode_adaptor::EndTime)->_get_EndTime(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&IAudioFileInputNode_adaptor::EndTime)->_put_EndTime(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} EndTime;
		struct : property {
			ptr<Foundation::IReference<int>> get() { Foundation::IReference<int>* value; hrcheck(enc(&IAudioFileInputNode_adaptor::LoopCount)->_get_LoopCount(&value)); return from_abi(value); }
			ptr<Foundation::IReference<int>> operator()() { return get(); }
			operator ptr<Foundation::IReference<int>> () { return get(); }
			ptr<Foundation::IReference<int>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<int>> value) { hrcheck(enc(&IAudioFileInputNode_adaptor::LoopCount)->_put_LoopCount(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
		} LoopCount;
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioFileInputNode_adaptor::PlaybackSpeedFactor)->_get_PlaybackSpeedFactor(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IAudioFileInputNode_adaptor::PlaybackSpeedFactor)->_put_PlaybackSpeedFactor(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} PlaybackSpeedFactor;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IAudioFileInputNode_adaptor::Position)->_get_Position(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} Position;
		struct : property {
			ptr<Storage::StorageFile> get() { Storage::StorageFile* value; hrcheck(enc(&IAudioFileInputNode_adaptor::SourceFile)->_get_SourceFile(&value)); return from_abi(value); }
			ptr<Storage::StorageFile> operator()() { return get(); }
			operator ptr<Storage::StorageFile> () { return get(); }
			ptr<Storage::StorageFile> operator->() { return get(); }
		} SourceFile;
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IAudioFileInputNode_adaptor::StartTime)->_get_StartTime(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&IAudioFileInputNode_adaptor::StartTime)->_put_StartTime(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} StartTime;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AudioFileInputNode>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAudioFileInputNode_adaptor::FileCompleted)->_add_FileCompleted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAudioFileInputNode_adaptor::FileCompleted)->_remove_FileCompleted(token)); }
		} FileCompleted;
	};
	void Seek(const Foundation::TimeSpan& position) { hrcheck(X::get()->_Seek(position)); }
	IAudioFileInputNode_adaptor() {}
};
template<typename X> struct adapt<IAudioFileInputNode, X> : Windows::Media::Audio::IAudioFileInputNode_adaptor<X> { typedef adapt IAudioFileInputNode; };
struct IAudioFileInputNode : IAudioFileInputNode_raw, generate<IAudioFileInputNode> {};

// AudioFileInputNode
template<typename X> struct statics<AudioFileInputNode, X> : X {
	typedef typename X::root_type AudioFileInputNode;
};
struct AudioFileInputNode : generate<AudioFileInputNode> {
	using IAudioInputNode::AddOutgoingConnection;
};

// CreateAudioFileInputNodeResult
template<typename X> struct statics<CreateAudioFileInputNodeResult, X> : X {
	typedef typename X::root_type CreateAudioFileInputNodeResult;
};
struct CreateAudioFileInputNodeResult : generate<CreateAudioFileInputNodeResult> {};

// ICreateAudioFileOutputNodeResult
struct ICreateAudioFileOutputNodeResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(AudioFileNodeCreationStatus *value);
	virtual STDMETHODIMP _get_FileOutputNode(AudioFileOutputNode* *value);
};
template<typename X> struct ICreateAudioFileOutputNodeResult_adaptor : X {
	union {
		struct : property {
			ptr<AudioFileOutputNode> get() { AudioFileOutputNode* value; hrcheck(enc(&ICreateAudioFileOutputNodeResult_adaptor::FileOutputNode)->_get_FileOutputNode(&value)); return from_abi(value); }
			ptr<AudioFileOutputNode> operator()() { return get(); }
			operator ptr<AudioFileOutputNode> () { return get(); }
			ptr<AudioFileOutputNode> operator->() { return get(); }
		} FileOutputNode;
		struct : property {
			AudioFileNodeCreationStatus get() { AudioFileNodeCreationStatus value; hrcheck(enc(&ICreateAudioFileOutputNodeResult_adaptor::Status)->_get_Status(&value)); return value; }
			AudioFileNodeCreationStatus operator()() { return get(); }
			operator AudioFileNodeCreationStatus () { return get(); }
		} Status;
	};
	ICreateAudioFileOutputNodeResult_adaptor() {}
};
template<typename X> struct adapt<ICreateAudioFileOutputNodeResult, X> : Windows::Media::Audio::ICreateAudioFileOutputNodeResult_adaptor<X> { typedef adapt ICreateAudioFileOutputNodeResult; };
struct ICreateAudioFileOutputNodeResult : ICreateAudioFileOutputNodeResult_raw, generate<ICreateAudioFileOutputNodeResult> {};

// IAudioFileOutputNode
struct IAudioFileOutputNode_raw : IInspectable {
	virtual STDMETHODIMP _get_File(Storage::IStorageFile* *value);
	virtual STDMETHODIMP _get_FileEncodingProfile(MediaProperties::MediaEncodingProfile* *value);
	virtual STDMETHODIMP _FinalizeAsync(Foundation::IAsyncOperation<Transcoding::TranscodeFailureReason>* *result);
};
template<typename X> struct IAudioFileOutputNode_adaptor : X {
	union {
		struct : property {
			ptr<Storage::IStorageFile> get() { Storage::IStorageFile* value; hrcheck(enc(&IAudioFileOutputNode_adaptor::File)->_get_File(&value)); return from_abi(value); }
			ptr<Storage::IStorageFile> operator()() { return get(); }
			operator ptr<Storage::IStorageFile> () { return get(); }
			ptr<Storage::IStorageFile> operator->() { return get(); }
		} File;
		struct : property {
			ptr<MediaProperties::MediaEncodingProfile> get() { MediaProperties::MediaEncodingProfile* value; hrcheck(enc(&IAudioFileOutputNode_adaptor::FileEncodingProfile)->_get_FileEncodingProfile(&value)); return from_abi(value); }
			ptr<MediaProperties::MediaEncodingProfile> operator()() { return get(); }
			operator ptr<MediaProperties::MediaEncodingProfile> () { return get(); }
			ptr<MediaProperties::MediaEncodingProfile> operator->() { return get(); }
		} FileEncodingProfile;
	};
	ptr<Foundation::IAsyncOperation<Transcoding::TranscodeFailureReason>> FinalizeAsync() { Foundation::IAsyncOperation<Transcoding::TranscodeFailureReason>* result; hrcheck(X::get()->_FinalizeAsync(&result)); return from_abi(result); }
	IAudioFileOutputNode_adaptor() {}
};
template<typename X> struct adapt<IAudioFileOutputNode, X> : Windows::Media::Audio::IAudioFileOutputNode_adaptor<X> { typedef adapt IAudioFileOutputNode; };
struct IAudioFileOutputNode : IAudioFileOutputNode_raw, generate<IAudioFileOutputNode> {};

// AudioFileOutputNode
template<typename X> struct statics<AudioFileOutputNode, X> : X {
	typedef typename X::root_type AudioFileOutputNode;
};
struct AudioFileOutputNode : generate<AudioFileOutputNode> {};

// CreateAudioFileOutputNodeResult
template<typename X> struct statics<CreateAudioFileOutputNodeResult, X> : X {
	typedef typename X::root_type CreateAudioFileOutputNodeResult;
};
struct CreateAudioFileOutputNodeResult : generate<CreateAudioFileOutputNodeResult> {};

// ICreateMediaSourceAudioInputNodeResult
struct ICreateMediaSourceAudioInputNodeResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(MediaSourceAudioInputNodeCreationStatus *value);
	virtual STDMETHODIMP _get_Node(MediaSourceAudioInputNode* *value);
};
template<typename X> struct ICreateMediaSourceAudioInputNodeResult_adaptor : X {
	union {
		struct : property {
			ptr<MediaSourceAudioInputNode> get() { MediaSourceAudioInputNode* value; hrcheck(enc(&ICreateMediaSourceAudioInputNodeResult_adaptor::Node)->_get_Node(&value)); return from_abi(value); }
			ptr<MediaSourceAudioInputNode> operator()() { return get(); }
			operator ptr<MediaSourceAudioInputNode> () { return get(); }
			ptr<MediaSourceAudioInputNode> operator->() { return get(); }
		} Node;
		struct : property {
			MediaSourceAudioInputNodeCreationStatus get() { MediaSourceAudioInputNodeCreationStatus value; hrcheck(enc(&ICreateMediaSourceAudioInputNodeResult_adaptor::Status)->_get_Status(&value)); return value; }
			MediaSourceAudioInputNodeCreationStatus operator()() { return get(); }
			operator MediaSourceAudioInputNodeCreationStatus () { return get(); }
		} Status;
	};
	ICreateMediaSourceAudioInputNodeResult_adaptor() {}
};
template<typename X> struct adapt<ICreateMediaSourceAudioInputNodeResult, X> : Windows::Media::Audio::ICreateMediaSourceAudioInputNodeResult_adaptor<X> { typedef adapt ICreateMediaSourceAudioInputNodeResult; };
struct ICreateMediaSourceAudioInputNodeResult : ICreateMediaSourceAudioInputNodeResult_raw, generate<ICreateMediaSourceAudioInputNodeResult> {};

// IMediaSourceAudioInputNode
struct IMediaSourceAudioInputNode_raw : IInspectable {
	virtual STDMETHODIMP _put_PlaybackSpeedFactor(double value);
	virtual STDMETHODIMP _get_PlaybackSpeedFactor(double *value);
	virtual STDMETHODIMP _get_Position(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _Seek(Foundation::TimeSpan position);
	virtual STDMETHODIMP _get_StartTime(Foundation::IReference<Foundation::TimeSpan>* *value);
	virtual STDMETHODIMP _put_StartTime(Foundation::IReference<Foundation::TimeSpan>* value);
	virtual STDMETHODIMP _get_EndTime(Foundation::IReference<Foundation::TimeSpan>* *value);
	virtual STDMETHODIMP _put_EndTime(Foundation::IReference<Foundation::TimeSpan>* value);
	virtual STDMETHODIMP _get_LoopCount(Foundation::IReference<int>* *value);
	virtual STDMETHODIMP _put_LoopCount(Foundation::IReference<int>* value);
	virtual STDMETHODIMP _get_Duration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_MediaSource(Core::MediaSource* *value);
	virtual STDMETHODIMP _add_MediaSourceCompleted(Foundation::TypedEventHandler<MediaSourceAudioInputNode*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_MediaSourceCompleted(Foundation::EventRegistrationToken token);
};
template<typename X> struct IMediaSourceAudioInputNode_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaSourceAudioInputNode_adaptor::Duration)->_get_Duration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} Duration;
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IMediaSourceAudioInputNode_adaptor::EndTime)->_get_EndTime(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&IMediaSourceAudioInputNode_adaptor::EndTime)->_put_EndTime(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} EndTime;
		struct : property {
			ptr<Foundation::IReference<int>> get() { Foundation::IReference<int>* value; hrcheck(enc(&IMediaSourceAudioInputNode_adaptor::LoopCount)->_get_LoopCount(&value)); return from_abi(value); }
			ptr<Foundation::IReference<int>> operator()() { return get(); }
			operator ptr<Foundation::IReference<int>> () { return get(); }
			ptr<Foundation::IReference<int>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<int>> value) { hrcheck(enc(&IMediaSourceAudioInputNode_adaptor::LoopCount)->_put_LoopCount(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
		} LoopCount;
		struct : property {
			ptr<Core::MediaSource> get() { Core::MediaSource* value; hrcheck(enc(&IMediaSourceAudioInputNode_adaptor::MediaSource)->_get_MediaSource(&value)); return from_abi(value); }
			ptr<Core::MediaSource> operator()() { return get(); }
			operator ptr<Core::MediaSource> () { return get(); }
			ptr<Core::MediaSource> operator->() { return get(); }
		} MediaSource;
		struct : property {
			double get() { double value; hrcheck(enc(&IMediaSourceAudioInputNode_adaptor::PlaybackSpeedFactor)->_get_PlaybackSpeedFactor(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IMediaSourceAudioInputNode_adaptor::PlaybackSpeedFactor)->_put_PlaybackSpeedFactor(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} PlaybackSpeedFactor;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaSourceAudioInputNode_adaptor::Position)->_get_Position(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} Position;
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IMediaSourceAudioInputNode_adaptor::StartTime)->_get_StartTime(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&IMediaSourceAudioInputNode_adaptor::StartTime)->_put_StartTime(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} StartTime;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaSourceAudioInputNode>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaSourceAudioInputNode_adaptor::MediaSourceCompleted)->_add_MediaSourceCompleted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaSourceAudioInputNode_adaptor::MediaSourceCompleted)->_remove_MediaSourceCompleted(token)); }
		} MediaSourceCompleted;
	};
	void Seek(const Foundation::TimeSpan& position) { hrcheck(X::get()->_Seek(position)); }
	IMediaSourceAudioInputNode_adaptor() {}
};
template<typename X> struct adapt<IMediaSourceAudioInputNode, X> : Windows::Media::Audio::IMediaSourceAudioInputNode_adaptor<X> { typedef adapt IMediaSourceAudioInputNode; };
struct IMediaSourceAudioInputNode : IMediaSourceAudioInputNode_raw, generate<IMediaSourceAudioInputNode> {};

// MediaSourceAudioInputNode
template<typename X> struct statics<MediaSourceAudioInputNode, X> : X {
	typedef typename X::root_type MediaSourceAudioInputNode;
};
struct MediaSourceAudioInputNode : generate<MediaSourceAudioInputNode> {
	using IAudioInputNode::AddOutgoingConnection;
};

// CreateMediaSourceAudioInputNodeResult
template<typename X> struct statics<CreateMediaSourceAudioInputNodeResult, X> : X {
	typedef typename X::root_type CreateMediaSourceAudioInputNodeResult;
};
struct CreateMediaSourceAudioInputNodeResult : generate<CreateMediaSourceAudioInputNodeResult> {};

// IAudioGraphUnrecoverableErrorOccurredEventArgs
struct IAudioGraphUnrecoverableErrorOccurredEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Error(AudioGraphUnrecoverableError *value);
};
template<typename X> struct IAudioGraphUnrecoverableErrorOccurredEventArgs_adaptor : X {
	union {
		struct : property {
			AudioGraphUnrecoverableError get() { AudioGraphUnrecoverableError value; hrcheck(enc(&IAudioGraphUnrecoverableErrorOccurredEventArgs_adaptor::Error)->_get_Error(&value)); return value; }
			AudioGraphUnrecoverableError operator()() { return get(); }
			operator AudioGraphUnrecoverableError () { return get(); }
		} Error;
	};
	IAudioGraphUnrecoverableErrorOccurredEventArgs_adaptor() {}
};
template<typename X> struct adapt<IAudioGraphUnrecoverableErrorOccurredEventArgs, X> : Windows::Media::Audio::IAudioGraphUnrecoverableErrorOccurredEventArgs_adaptor<X> { typedef adapt IAudioGraphUnrecoverableErrorOccurredEventArgs; };
struct IAudioGraphUnrecoverableErrorOccurredEventArgs : IAudioGraphUnrecoverableErrorOccurredEventArgs_raw, generate<IAudioGraphUnrecoverableErrorOccurredEventArgs> {};

// AudioGraphUnrecoverableErrorOccurredEventArgs
template<typename X> struct statics<AudioGraphUnrecoverableErrorOccurredEventArgs, X> : X {
	typedef typename X::root_type AudioGraphUnrecoverableErrorOccurredEventArgs;
};
struct AudioGraphUnrecoverableErrorOccurredEventArgs : generate<AudioGraphUnrecoverableErrorOccurredEventArgs> {};

// AudioGraphBatchUpdater
template<typename X> struct statics<AudioGraphBatchUpdater, X> : X {
	typedef typename X::root_type AudioGraphBatchUpdater;
};
struct AudioGraphBatchUpdater : generate<AudioGraphBatchUpdater> {};

// IAudioFrameInputNode
struct IAudioFrameInputNode_raw : IInspectable {
	virtual STDMETHODIMP _put_PlaybackSpeedFactor(double value);
	virtual STDMETHODIMP _get_PlaybackSpeedFactor(double *value);
	virtual STDMETHODIMP _AddFrame(AudioFrame* frame);
	virtual STDMETHODIMP _DiscardQueuedFrames();
	virtual STDMETHODIMP _get_QueuedSampleCount(unsigned __int64 *value);
	virtual STDMETHODIMP _add_AudioFrameCompleted(Foundation::TypedEventHandler<AudioFrameInputNode*, AudioFrameCompletedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_AudioFrameCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_QuantumStarted(Foundation::TypedEventHandler<AudioFrameInputNode*, FrameInputNodeQuantumStartedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_QuantumStarted(Foundation::EventRegistrationToken token);
};
template<typename X> struct IAudioFrameInputNode_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioFrameInputNode_adaptor::PlaybackSpeedFactor)->_get_PlaybackSpeedFactor(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IAudioFrameInputNode_adaptor::PlaybackSpeedFactor)->_put_PlaybackSpeedFactor(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} PlaybackSpeedFactor;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IAudioFrameInputNode_adaptor::QueuedSampleCount)->_get_QueuedSampleCount(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} QueuedSampleCount;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AudioFrameInputNode>, ptr<AudioFrameCompletedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAudioFrameInputNode_adaptor::AudioFrameCompleted)->_add_AudioFrameCompleted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAudioFrameInputNode_adaptor::AudioFrameCompleted)->_remove_AudioFrameCompleted(token)); }
		} AudioFrameCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AudioFrameInputNode>, ptr<FrameInputNodeQuantumStartedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAudioFrameInputNode_adaptor::QuantumStarted)->_add_QuantumStarted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAudioFrameInputNode_adaptor::QuantumStarted)->_remove_QuantumStarted(token)); }
		} QuantumStarted;
	};
	void AddFrame(pptr<AudioFrame> frame) { hrcheck(X::get()->_AddFrame(frame)); }
	void DiscardQueuedFrames() { hrcheck(X::get()->_DiscardQueuedFrames()); }
	IAudioFrameInputNode_adaptor() {}
};
template<typename X> struct adapt<IAudioFrameInputNode, X> : Windows::Media::Audio::IAudioFrameInputNode_adaptor<X> { typedef adapt IAudioFrameInputNode; };
struct IAudioFrameInputNode : IAudioFrameInputNode_raw, generate<IAudioFrameInputNode> {};

// AudioFrameInputNode
template<typename X> struct statics<AudioFrameInputNode, X> : X {
	typedef typename X::root_type AudioFrameInputNode;
};
struct AudioFrameInputNode : generate<AudioFrameInputNode> {
	using IAudioInputNode::AddOutgoingConnection;
};

// IAudioFrameOutputNode
struct IAudioFrameOutputNode_raw : IInspectable {
	virtual STDMETHODIMP _GetFrame(AudioFrame* *audioFrame);
};
template<typename X> struct IAudioFrameOutputNode_adaptor : X {
	ptr<AudioFrame> GetFrame() { AudioFrame* audioFrame; hrcheck(X::get()->_GetFrame(&audioFrame)); return from_abi(audioFrame); }
};
template<typename X> struct adapt<IAudioFrameOutputNode, X> : Windows::Media::Audio::IAudioFrameOutputNode_adaptor<X> { typedef adapt IAudioFrameOutputNode; };
struct IAudioFrameOutputNode : IAudioFrameOutputNode_raw, generate<IAudioFrameOutputNode> {};

// AudioFrameOutputNode
template<typename X> struct statics<AudioFrameOutputNode, X> : X {
	typedef typename X::root_type AudioFrameOutputNode;
};
struct AudioFrameOutputNode : generate<AudioFrameOutputNode> {};

// AudioSubmixNode
template<typename X> struct statics<AudioSubmixNode, X> : X {
	typedef typename X::root_type AudioSubmixNode;
};
struct AudioSubmixNode : generate<AudioSubmixNode> {
	using IAudioInputNode::AddOutgoingConnection;
};

// IAudioNodeEmitterFactory
struct IAudioNodeEmitterFactory : IInspectable {
	virtual STDMETHODIMP _CreateAudioNodeEmitter(AudioNodeEmitterShape* shape, AudioNodeEmitterDecayModel* decayModel, AudioNodeEmitterSettings settings, AudioNodeEmitter* *emitter);
};

// IAudioNodeEmitter2
struct IAudioNodeEmitter2_raw : IInspectable {
	virtual STDMETHODIMP _get_SpatialAudioModel(Audio::SpatialAudioModel *value);
	virtual STDMETHODIMP _put_SpatialAudioModel(Audio::SpatialAudioModel value);
};
template<typename X> struct IAudioNodeEmitter2_adaptor : X {
	union {
		struct : property {
			Audio::SpatialAudioModel get() { Audio::SpatialAudioModel value; hrcheck(enc(&IAudioNodeEmitter2_adaptor::SpatialAudioModel)->_get_SpatialAudioModel(&value)); return value; }
			Audio::SpatialAudioModel operator()() { return get(); }
			operator Audio::SpatialAudioModel () { return get(); }
			void put(Audio::SpatialAudioModel value) { hrcheck(enc(&IAudioNodeEmitter2_adaptor::SpatialAudioModel)->_put_SpatialAudioModel(value)); }
			void operator=(Audio::SpatialAudioModel value) { put(value); }
			void operator()(Audio::SpatialAudioModel value) { put(value); }
		} SpatialAudioModel;
	};
	IAudioNodeEmitter2_adaptor() {}
};
template<typename X> struct adapt<IAudioNodeEmitter2, X> : Windows::Media::Audio::IAudioNodeEmitter2_adaptor<X> { typedef adapt IAudioNodeEmitter2; };
struct IAudioNodeEmitter2 : IAudioNodeEmitter2_raw, generate<IAudioNodeEmitter2> {};

// IAudioNodeEmitter
struct IAudioNodeEmitter_raw : IInspectable {
	virtual STDMETHODIMP _get_Position(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_Position(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_Direction(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_Direction(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_Shape(AudioNodeEmitterShape* *value);
	virtual STDMETHODIMP _get_DecayModel(AudioNodeEmitterDecayModel* *value);
	virtual STDMETHODIMP _get_Gain(double *value);
	virtual STDMETHODIMP _put_Gain(double value);
	virtual STDMETHODIMP _get_DistanceScale(double *value);
	virtual STDMETHODIMP _put_DistanceScale(double value);
	virtual STDMETHODIMP _get_DopplerScale(double *value);
	virtual STDMETHODIMP _put_DopplerScale(double value);
	virtual STDMETHODIMP _get_DopplerVelocity(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_DopplerVelocity(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_IsDopplerDisabled(bool *value);
};
template<typename X> struct IAudioNodeEmitter_adaptor : X {
	union {
		struct : property {
			ptr<AudioNodeEmitterDecayModel> get() { AudioNodeEmitterDecayModel* value; hrcheck(enc(&IAudioNodeEmitter_adaptor::DecayModel)->_get_DecayModel(&value)); return from_abi(value); }
			ptr<AudioNodeEmitterDecayModel> operator()() { return get(); }
			operator ptr<AudioNodeEmitterDecayModel> () { return get(); }
			ptr<AudioNodeEmitterDecayModel> operator->() { return get(); }
		} DecayModel;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IAudioNodeEmitter_adaptor::Direction)->_get_Direction(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IAudioNodeEmitter_adaptor::Direction)->_put_Direction(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} Direction;
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioNodeEmitter_adaptor::DistanceScale)->_get_DistanceScale(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IAudioNodeEmitter_adaptor::DistanceScale)->_put_DistanceScale(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DistanceScale;
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioNodeEmitter_adaptor::DopplerScale)->_get_DopplerScale(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IAudioNodeEmitter_adaptor::DopplerScale)->_put_DopplerScale(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DopplerScale;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IAudioNodeEmitter_adaptor::DopplerVelocity)->_get_DopplerVelocity(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IAudioNodeEmitter_adaptor::DopplerVelocity)->_put_DopplerVelocity(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} DopplerVelocity;
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioNodeEmitter_adaptor::Gain)->_get_Gain(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IAudioNodeEmitter_adaptor::Gain)->_put_Gain(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Gain;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAudioNodeEmitter_adaptor::IsDopplerDisabled)->_get_IsDopplerDisabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsDopplerDisabled;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IAudioNodeEmitter_adaptor::Position)->_get_Position(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IAudioNodeEmitter_adaptor::Position)->_put_Position(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} Position;
		struct : property {
			ptr<AudioNodeEmitterShape> get() { AudioNodeEmitterShape* value; hrcheck(enc(&IAudioNodeEmitter_adaptor::Shape)->_get_Shape(&value)); return from_abi(value); }
			ptr<AudioNodeEmitterShape> operator()() { return get(); }
			operator ptr<AudioNodeEmitterShape> () { return get(); }
			ptr<AudioNodeEmitterShape> operator->() { return get(); }
		} Shape;
	};
	IAudioNodeEmitter_adaptor() {}
};
template<typename X> struct adapt<IAudioNodeEmitter, X> : Windows::Media::Audio::IAudioNodeEmitter_adaptor<X> { typedef adapt IAudioNodeEmitter; };
struct IAudioNodeEmitter : IAudioNodeEmitter_raw, generate<IAudioNodeEmitter> {};

// AudioNodeEmitter
template<typename> struct AudioNodeEmitter_statics {
	static AudioNodeEmitter *activate(pptr<AudioNodeEmitterShape> shape, pptr<AudioNodeEmitterDecayModel> decayModel, AudioNodeEmitterSettings settings) { AudioNodeEmitter *emitter; hrcheck(get_activation_factory<AudioNodeEmitter, IAudioNodeEmitterFactory>()->_CreateAudioNodeEmitter(shape, decayModel, settings, &emitter)); return emitter; }
	static AudioNodeEmitter *activate() { AudioNodeEmitter *t; get_activation_factory<AudioNodeEmitter>()->ActivateInstance((IInspectable**)&t); return t; }
};

template<typename X> struct statics<AudioNodeEmitter, X> : X, Windows::Media::Audio::AudioNodeEmitter_statics<void> {
	using Windows::Media::Audio::AudioNodeEmitter_statics<void>::activate;
	typedef typename X::root_type AudioNodeEmitter;
};
struct AudioNodeEmitter : generate<AudioNodeEmitter> {};

// IAudioNodeListener
struct IAudioNodeListener_raw : IInspectable {
	virtual STDMETHODIMP _get_Position(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_Position(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_Orientation(Foundation::Numerics::Quaternion *value);
	virtual STDMETHODIMP _put_Orientation(Foundation::Numerics::Quaternion value);
	virtual STDMETHODIMP _get_SpeedOfSound(double *value);
	virtual STDMETHODIMP _put_SpeedOfSound(double value);
	virtual STDMETHODIMP _get_DopplerVelocity(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_DopplerVelocity(Foundation::Numerics::Vector3 value);
};
template<typename X> struct IAudioNodeListener_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IAudioNodeListener_adaptor::DopplerVelocity)->_get_DopplerVelocity(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IAudioNodeListener_adaptor::DopplerVelocity)->_put_DopplerVelocity(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} DopplerVelocity;
		struct : property {
			Foundation::Numerics::Quaternion get() { Foundation::Numerics::Quaternion value; hrcheck(enc(&IAudioNodeListener_adaptor::Orientation)->_get_Orientation(&value)); return value; }
			Foundation::Numerics::Quaternion operator()() { return get(); }
			operator Foundation::Numerics::Quaternion () { return get(); }
			void put(const Foundation::Numerics::Quaternion& value) { hrcheck(enc(&IAudioNodeListener_adaptor::Orientation)->_put_Orientation(value)); }
			void operator=(const Foundation::Numerics::Quaternion& value) { put(value); }
			void operator()(const Foundation::Numerics::Quaternion& value) { put(value); }
		} Orientation;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IAudioNodeListener_adaptor::Position)->_get_Position(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IAudioNodeListener_adaptor::Position)->_put_Position(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} Position;
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioNodeListener_adaptor::SpeedOfSound)->_get_SpeedOfSound(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IAudioNodeListener_adaptor::SpeedOfSound)->_put_SpeedOfSound(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} SpeedOfSound;
	};
	IAudioNodeListener_adaptor() {}
};
template<typename X> struct adapt<IAudioNodeListener, X> : Windows::Media::Audio::IAudioNodeListener_adaptor<X> { typedef adapt IAudioNodeListener; };
struct IAudioNodeListener : IAudioNodeListener_raw, generate<IAudioNodeListener> {};

// AudioNodeListener
template<typename X> struct statics<AudioNodeListener, X> : X {
	typedef typename X::root_type AudioNodeListener;
};
struct AudioNodeListener : generate<AudioNodeListener> {};

// IAudioGraphConnection
struct IAudioGraphConnection_raw : IInspectable {
	virtual STDMETHODIMP _get_Destination(IAudioNode* *value);
	virtual STDMETHODIMP _put_Gain(double value);
	virtual STDMETHODIMP _get_Gain(double *value);
};
template<typename X> struct IAudioGraphConnection_adaptor : X {
	union {
		struct : property {
			ptr<IAudioNode> get() { IAudioNode* value; hrcheck(enc(&IAudioGraphConnection_adaptor::Destination)->_get_Destination(&value)); return from_abi(value); }
			ptr<IAudioNode> operator()() { return get(); }
			operator ptr<IAudioNode> () { return get(); }
			ptr<IAudioNode> operator->() { return get(); }
		} Destination;
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioGraphConnection_adaptor::Gain)->_get_Gain(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IAudioGraphConnection_adaptor::Gain)->_put_Gain(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Gain;
	};
	IAudioGraphConnection_adaptor() {}
};
template<typename X> struct adapt<IAudioGraphConnection, X> : Windows::Media::Audio::IAudioGraphConnection_adaptor<X> { typedef adapt IAudioGraphConnection; };
struct IAudioGraphConnection : IAudioGraphConnection_raw, generate<IAudioGraphConnection> {};

// AudioGraphConnection
template<typename X> struct statics<AudioGraphConnection, X> : X {
	typedef typename X::root_type AudioGraphConnection;
};
struct AudioGraphConnection : generate<AudioGraphConnection> {};

// IAudioFrameCompletedEventArgs
struct IAudioFrameCompletedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Frame(AudioFrame* *value);
};
template<typename X> struct IAudioFrameCompletedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<AudioFrame> get() { AudioFrame* value; hrcheck(enc(&IAudioFrameCompletedEventArgs_adaptor::Frame)->_get_Frame(&value)); return from_abi(value); }
			ptr<AudioFrame> operator()() { return get(); }
			operator ptr<AudioFrame> () { return get(); }
			ptr<AudioFrame> operator->() { return get(); }
		} Frame;
	};
	IAudioFrameCompletedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IAudioFrameCompletedEventArgs, X> : Windows::Media::Audio::IAudioFrameCompletedEventArgs_adaptor<X> { typedef adapt IAudioFrameCompletedEventArgs; };
struct IAudioFrameCompletedEventArgs : IAudioFrameCompletedEventArgs_raw, generate<IAudioFrameCompletedEventArgs> {};

// AudioFrameCompletedEventArgs
template<typename X> struct statics<AudioFrameCompletedEventArgs, X> : X {
	typedef typename X::root_type AudioFrameCompletedEventArgs;
};
struct AudioFrameCompletedEventArgs : generate<AudioFrameCompletedEventArgs> {};

// IFrameInputNodeQuantumStartedEventArgs
struct IFrameInputNodeQuantumStartedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_RequiredSamples(int *value);
};
template<typename X> struct IFrameInputNodeQuantumStartedEventArgs_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IFrameInputNodeQuantumStartedEventArgs_adaptor::RequiredSamples)->_get_RequiredSamples(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} RequiredSamples;
	};
	IFrameInputNodeQuantumStartedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IFrameInputNodeQuantumStartedEventArgs, X> : Windows::Media::Audio::IFrameInputNodeQuantumStartedEventArgs_adaptor<X> { typedef adapt IFrameInputNodeQuantumStartedEventArgs; };
struct IFrameInputNodeQuantumStartedEventArgs : IFrameInputNodeQuantumStartedEventArgs_raw, generate<IFrameInputNodeQuantumStartedEventArgs> {};

// FrameInputNodeQuantumStartedEventArgs
template<typename X> struct statics<FrameInputNodeQuantumStartedEventArgs, X> : X {
	typedef typename X::root_type FrameInputNodeQuantumStartedEventArgs;
};
struct FrameInputNodeQuantumStartedEventArgs : generate<FrameInputNodeQuantumStartedEventArgs> {};

// IEqualizerBand
struct IEqualizerBand_raw : IInspectable {
	virtual STDMETHODIMP _get_Bandwidth(double *value);
	virtual STDMETHODIMP _put_Bandwidth(double value);
	virtual STDMETHODIMP _get_FrequencyCenter(double *value);
	virtual STDMETHODIMP _put_FrequencyCenter(double value);
	virtual STDMETHODIMP _get_Gain(double *value);
	virtual STDMETHODIMP _put_Gain(double value);
};
template<typename X> struct IEqualizerBand_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IEqualizerBand_adaptor::Bandwidth)->_get_Bandwidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IEqualizerBand_adaptor::Bandwidth)->_put_Bandwidth(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Bandwidth;
		struct : property {
			double get() { double value; hrcheck(enc(&IEqualizerBand_adaptor::FrequencyCenter)->_get_FrequencyCenter(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IEqualizerBand_adaptor::FrequencyCenter)->_put_FrequencyCenter(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FrequencyCenter;
		struct : property {
			double get() { double value; hrcheck(enc(&IEqualizerBand_adaptor::Gain)->_get_Gain(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IEqualizerBand_adaptor::Gain)->_put_Gain(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Gain;
	};
	IEqualizerBand_adaptor() {}
};
template<typename X> struct adapt<IEqualizerBand, X> : Windows::Media::Audio::IEqualizerBand_adaptor<X> { typedef adapt IEqualizerBand; };
struct IEqualizerBand : IEqualizerBand_raw, generate<IEqualizerBand> {};

// EqualizerBand
template<typename X> struct statics<EqualizerBand, X> : X {
	typedef typename X::root_type EqualizerBand;
};
struct EqualizerBand : generate<EqualizerBand> {};

// IEqualizerEffectDefinitionFactory
struct IEqualizerEffectDefinitionFactory : IInspectable {
	virtual STDMETHODIMP _Create(AudioGraph* audioGraph, EqualizerEffectDefinition* *value);
};

// IEqualizerEffectDefinition
struct IEqualizerEffectDefinition_raw : IInspectable {
	virtual STDMETHODIMP _get_Bands(Foundation::Collections::IVectorView<EqualizerBand*>* *value);
};
template<typename X> struct IEqualizerEffectDefinition_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<EqualizerBand>>> get() { Foundation::Collections::IVectorView<EqualizerBand*>* value; hrcheck(enc(&IEqualizerEffectDefinition_adaptor::Bands)->_get_Bands(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<EqualizerBand>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<EqualizerBand>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<EqualizerBand>>> operator->() { return get(); }
		} Bands;
	};
	IEqualizerEffectDefinition_adaptor() {}
};
template<typename X> struct adapt<IEqualizerEffectDefinition, X> : Windows::Media::Audio::IEqualizerEffectDefinition_adaptor<X> { typedef adapt IEqualizerEffectDefinition; };
struct IEqualizerEffectDefinition : IEqualizerEffectDefinition_raw, generate<IEqualizerEffectDefinition> {};

// EqualizerEffectDefinition
template<typename> struct EqualizerEffectDefinition_statics {
	static EqualizerEffectDefinition *activate(pptr<AudioGraph> audioGraph) { EqualizerEffectDefinition *value; hrcheck(get_activation_factory<EqualizerEffectDefinition, IEqualizerEffectDefinitionFactory>()->_Create(audioGraph, &value)); return value; }
};

template<typename X> struct statics<EqualizerEffectDefinition, X> : X, Windows::Media::Audio::EqualizerEffectDefinition_statics<void> {
	using Windows::Media::Audio::EqualizerEffectDefinition_statics<void>::activate;
	typedef typename X::root_type EqualizerEffectDefinition;
};
struct EqualizerEffectDefinition : generate<EqualizerEffectDefinition> {};

// IReverbEffectDefinitionFactory
struct IReverbEffectDefinitionFactory : IInspectable {
	virtual STDMETHODIMP _Create(AudioGraph* audioGraph, ReverbEffectDefinition* *value);
};

// IReverbEffectDefinition
struct IReverbEffectDefinition_raw : IInspectable {
	virtual STDMETHODIMP _put_WetDryMix(double value);
	virtual STDMETHODIMP _get_WetDryMix(double *value);
	virtual STDMETHODIMP _put_ReflectionsDelay(unsigned value);
	virtual STDMETHODIMP _get_ReflectionsDelay(unsigned *value);
	virtual STDMETHODIMP _put_ReverbDelay(unsigned char value);
	virtual STDMETHODIMP _get_ReverbDelay(unsigned char *value);
	virtual STDMETHODIMP _put_RearDelay(unsigned char value);
	virtual STDMETHODIMP _get_RearDelay(unsigned char *value);
	virtual STDMETHODIMP _put_PositionLeft(unsigned char value);
	virtual STDMETHODIMP _get_PositionLeft(unsigned char *value);
	virtual STDMETHODIMP _put_PositionRight(unsigned char value);
	virtual STDMETHODIMP _get_PositionRight(unsigned char *value);
	virtual STDMETHODIMP _put_PositionMatrixLeft(unsigned char value);
	virtual STDMETHODIMP _get_PositionMatrixLeft(unsigned char *value);
	virtual STDMETHODIMP _put_PositionMatrixRight(unsigned char value);
	virtual STDMETHODIMP _get_PositionMatrixRight(unsigned char *value);
	virtual STDMETHODIMP _put_EarlyDiffusion(unsigned char value);
	virtual STDMETHODIMP _get_EarlyDiffusion(unsigned char *value);
	virtual STDMETHODIMP _put_LateDiffusion(unsigned char value);
	virtual STDMETHODIMP _get_LateDiffusion(unsigned char *value);
	virtual STDMETHODIMP _put_LowEQGain(unsigned char value);
	virtual STDMETHODIMP _get_LowEQGain(unsigned char *value);
	virtual STDMETHODIMP _put_LowEQCutoff(unsigned char value);
	virtual STDMETHODIMP _get_LowEQCutoff(unsigned char *value);
	virtual STDMETHODIMP _put_HighEQGain(unsigned char value);
	virtual STDMETHODIMP _get_HighEQGain(unsigned char *value);
	virtual STDMETHODIMP _put_HighEQCutoff(unsigned char value);
	virtual STDMETHODIMP _get_HighEQCutoff(unsigned char *value);
	virtual STDMETHODIMP _put_RoomFilterFreq(double value);
	virtual STDMETHODIMP _get_RoomFilterFreq(double *value);
	virtual STDMETHODIMP _put_RoomFilterMain(double value);
	virtual STDMETHODIMP _get_RoomFilterMain(double *value);
	virtual STDMETHODIMP _put_RoomFilterHF(double value);
	virtual STDMETHODIMP _get_RoomFilterHF(double *value);
	virtual STDMETHODIMP _put_ReflectionsGain(double value);
	virtual STDMETHODIMP _get_ReflectionsGain(double *value);
	virtual STDMETHODIMP _put_ReverbGain(double value);
	virtual STDMETHODIMP _get_ReverbGain(double *value);
	virtual STDMETHODIMP _put_DecayTime(double value);
	virtual STDMETHODIMP _get_DecayTime(double *value);
	virtual STDMETHODIMP _put_Density(double value);
	virtual STDMETHODIMP _get_Density(double *value);
	virtual STDMETHODIMP _put_RoomSize(double value);
	virtual STDMETHODIMP _get_RoomSize(double *value);
	virtual STDMETHODIMP _put_DisableLateField(bool value);
	virtual STDMETHODIMP _get_DisableLateField(bool *value);
};
template<typename X> struct IReverbEffectDefinition_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IReverbEffectDefinition_adaptor::DecayTime)->_get_DecayTime(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::DecayTime)->_put_DecayTime(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DecayTime;
		struct : property {
			double get() { double value; hrcheck(enc(&IReverbEffectDefinition_adaptor::Density)->_get_Density(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::Density)->_put_Density(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Density;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IReverbEffectDefinition_adaptor::DisableLateField)->_get_DisableLateField(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::DisableLateField)->_put_DisableLateField(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} DisableLateField;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IReverbEffectDefinition_adaptor::EarlyDiffusion)->_get_EarlyDiffusion(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::EarlyDiffusion)->_put_EarlyDiffusion(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} EarlyDiffusion;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IReverbEffectDefinition_adaptor::HighEQCutoff)->_get_HighEQCutoff(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::HighEQCutoff)->_put_HighEQCutoff(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} HighEQCutoff;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IReverbEffectDefinition_adaptor::HighEQGain)->_get_HighEQGain(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::HighEQGain)->_put_HighEQGain(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} HighEQGain;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IReverbEffectDefinition_adaptor::LateDiffusion)->_get_LateDiffusion(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::LateDiffusion)->_put_LateDiffusion(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} LateDiffusion;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IReverbEffectDefinition_adaptor::LowEQCutoff)->_get_LowEQCutoff(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::LowEQCutoff)->_put_LowEQCutoff(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} LowEQCutoff;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IReverbEffectDefinition_adaptor::LowEQGain)->_get_LowEQGain(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::LowEQGain)->_put_LowEQGain(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} LowEQGain;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IReverbEffectDefinition_adaptor::PositionLeft)->_get_PositionLeft(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::PositionLeft)->_put_PositionLeft(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} PositionLeft;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IReverbEffectDefinition_adaptor::PositionMatrixLeft)->_get_PositionMatrixLeft(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::PositionMatrixLeft)->_put_PositionMatrixLeft(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} PositionMatrixLeft;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IReverbEffectDefinition_adaptor::PositionMatrixRight)->_get_PositionMatrixRight(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::PositionMatrixRight)->_put_PositionMatrixRight(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} PositionMatrixRight;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IReverbEffectDefinition_adaptor::PositionRight)->_get_PositionRight(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::PositionRight)->_put_PositionRight(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} PositionRight;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IReverbEffectDefinition_adaptor::RearDelay)->_get_RearDelay(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::RearDelay)->_put_RearDelay(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} RearDelay;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IReverbEffectDefinition_adaptor::ReflectionsDelay)->_get_ReflectionsDelay(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::ReflectionsDelay)->_put_ReflectionsDelay(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} ReflectionsDelay;
		struct : property {
			double get() { double value; hrcheck(enc(&IReverbEffectDefinition_adaptor::ReflectionsGain)->_get_ReflectionsGain(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::ReflectionsGain)->_put_ReflectionsGain(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ReflectionsGain;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IReverbEffectDefinition_adaptor::ReverbDelay)->_get_ReverbDelay(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::ReverbDelay)->_put_ReverbDelay(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} ReverbDelay;
		struct : property {
			double get() { double value; hrcheck(enc(&IReverbEffectDefinition_adaptor::ReverbGain)->_get_ReverbGain(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::ReverbGain)->_put_ReverbGain(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ReverbGain;
		struct : property {
			double get() { double value; hrcheck(enc(&IReverbEffectDefinition_adaptor::RoomFilterFreq)->_get_RoomFilterFreq(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::RoomFilterFreq)->_put_RoomFilterFreq(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} RoomFilterFreq;
		struct : property {
			double get() { double value; hrcheck(enc(&IReverbEffectDefinition_adaptor::RoomFilterHF)->_get_RoomFilterHF(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::RoomFilterHF)->_put_RoomFilterHF(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} RoomFilterHF;
		struct : property {
			double get() { double value; hrcheck(enc(&IReverbEffectDefinition_adaptor::RoomFilterMain)->_get_RoomFilterMain(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::RoomFilterMain)->_put_RoomFilterMain(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} RoomFilterMain;
		struct : property {
			double get() { double value; hrcheck(enc(&IReverbEffectDefinition_adaptor::RoomSize)->_get_RoomSize(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::RoomSize)->_put_RoomSize(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} RoomSize;
		struct : property {
			double get() { double value; hrcheck(enc(&IReverbEffectDefinition_adaptor::WetDryMix)->_get_WetDryMix(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IReverbEffectDefinition_adaptor::WetDryMix)->_put_WetDryMix(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} WetDryMix;
	};
	IReverbEffectDefinition_adaptor() {}
};
template<typename X> struct adapt<IReverbEffectDefinition, X> : Windows::Media::Audio::IReverbEffectDefinition_adaptor<X> { typedef adapt IReverbEffectDefinition; };
struct IReverbEffectDefinition : IReverbEffectDefinition_raw, generate<IReverbEffectDefinition> {};

// ReverbEffectDefinition
template<typename> struct ReverbEffectDefinition_statics {
	static ReverbEffectDefinition *activate(pptr<AudioGraph> audioGraph) { ReverbEffectDefinition *value; hrcheck(get_activation_factory<ReverbEffectDefinition, IReverbEffectDefinitionFactory>()->_Create(audioGraph, &value)); return value; }
};

template<typename X> struct statics<ReverbEffectDefinition, X> : X, Windows::Media::Audio::ReverbEffectDefinition_statics<void> {
	using Windows::Media::Audio::ReverbEffectDefinition_statics<void>::activate;
	typedef typename X::root_type ReverbEffectDefinition;
};
struct ReverbEffectDefinition : generate<ReverbEffectDefinition> {};

// IEchoEffectDefinitionFactory
struct IEchoEffectDefinitionFactory : IInspectable {
	virtual STDMETHODIMP _Create(AudioGraph* audioGraph, EchoEffectDefinition* *value);
};

// IEchoEffectDefinition
struct IEchoEffectDefinition_raw : IInspectable {
	virtual STDMETHODIMP _put_WetDryMix(double value);
	virtual STDMETHODIMP _get_WetDryMix(double *value);
	virtual STDMETHODIMP _put_Feedback(double value);
	virtual STDMETHODIMP _get_Feedback(double *value);
	virtual STDMETHODIMP _put_Delay(double value);
	virtual STDMETHODIMP _get_Delay(double *value);
};
template<typename X> struct IEchoEffectDefinition_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IEchoEffectDefinition_adaptor::Delay)->_get_Delay(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IEchoEffectDefinition_adaptor::Delay)->_put_Delay(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Delay;
		struct : property {
			double get() { double value; hrcheck(enc(&IEchoEffectDefinition_adaptor::Feedback)->_get_Feedback(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IEchoEffectDefinition_adaptor::Feedback)->_put_Feedback(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Feedback;
		struct : property {
			double get() { double value; hrcheck(enc(&IEchoEffectDefinition_adaptor::WetDryMix)->_get_WetDryMix(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IEchoEffectDefinition_adaptor::WetDryMix)->_put_WetDryMix(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} WetDryMix;
	};
	IEchoEffectDefinition_adaptor() {}
};
template<typename X> struct adapt<IEchoEffectDefinition, X> : Windows::Media::Audio::IEchoEffectDefinition_adaptor<X> { typedef adapt IEchoEffectDefinition; };
struct IEchoEffectDefinition : IEchoEffectDefinition_raw, generate<IEchoEffectDefinition> {};

// EchoEffectDefinition
template<typename> struct EchoEffectDefinition_statics {
	static EchoEffectDefinition *activate(pptr<AudioGraph> audioGraph) { EchoEffectDefinition *value; hrcheck(get_activation_factory<EchoEffectDefinition, IEchoEffectDefinitionFactory>()->_Create(audioGraph, &value)); return value; }
};

template<typename X> struct statics<EchoEffectDefinition, X> : X, Windows::Media::Audio::EchoEffectDefinition_statics<void> {
	using Windows::Media::Audio::EchoEffectDefinition_statics<void>::activate;
	typedef typename X::root_type EchoEffectDefinition;
};
struct EchoEffectDefinition : generate<EchoEffectDefinition> {};

// ILimiterEffectDefinitionFactory
struct ILimiterEffectDefinitionFactory : IInspectable {
	virtual STDMETHODIMP _Create(AudioGraph* audioGraph, LimiterEffectDefinition* *value);
};

// ILimiterEffectDefinition
struct ILimiterEffectDefinition_raw : IInspectable {
	virtual STDMETHODIMP _put_Release(unsigned value);
	virtual STDMETHODIMP _get_Release(unsigned *value);
	virtual STDMETHODIMP _put_Loudness(unsigned value);
	virtual STDMETHODIMP _get_Loudness(unsigned *value);
};
template<typename X> struct ILimiterEffectDefinition_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&ILimiterEffectDefinition_adaptor::Loudness)->_get_Loudness(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&ILimiterEffectDefinition_adaptor::Loudness)->_put_Loudness(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} Loudness;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&ILimiterEffectDefinition_adaptor::release)->_get_Release(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&ILimiterEffectDefinition_adaptor::release)->_put_Release(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} release;
	};
	ILimiterEffectDefinition_adaptor() {}
};
template<typename X> struct adapt<ILimiterEffectDefinition, X> : Windows::Media::Audio::ILimiterEffectDefinition_adaptor<X> { typedef adapt ILimiterEffectDefinition; };
struct ILimiterEffectDefinition : ILimiterEffectDefinition_raw, generate<ILimiterEffectDefinition> {};

// LimiterEffectDefinition
template<typename> struct LimiterEffectDefinition_statics {
	static LimiterEffectDefinition *activate(pptr<AudioGraph> audioGraph) { LimiterEffectDefinition *value; hrcheck(get_activation_factory<LimiterEffectDefinition, ILimiterEffectDefinitionFactory>()->_Create(audioGraph, &value)); return value; }
};

template<typename X> struct statics<LimiterEffectDefinition, X> : X, Windows::Media::Audio::LimiterEffectDefinition_statics<void> {
	using Windows::Media::Audio::LimiterEffectDefinition_statics<void>::activate;
	typedef typename X::root_type LimiterEffectDefinition;
};
struct LimiterEffectDefinition : generate<LimiterEffectDefinition> {};

// IAudioNodeEmitterConeProperties
struct IAudioNodeEmitterConeProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_InnerAngle(double *value);
	virtual STDMETHODIMP _get_OuterAngle(double *value);
	virtual STDMETHODIMP _get_OuterAngleGain(double *value);
};
template<typename X> struct IAudioNodeEmitterConeProperties_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioNodeEmitterConeProperties_adaptor::InnerAngle)->_get_InnerAngle(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} InnerAngle;
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioNodeEmitterConeProperties_adaptor::OuterAngle)->_get_OuterAngle(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} OuterAngle;
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioNodeEmitterConeProperties_adaptor::OuterAngleGain)->_get_OuterAngleGain(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} OuterAngleGain;
	};
	IAudioNodeEmitterConeProperties_adaptor() {}
};
template<typename X> struct adapt<IAudioNodeEmitterConeProperties, X> : Windows::Media::Audio::IAudioNodeEmitterConeProperties_adaptor<X> { typedef adapt IAudioNodeEmitterConeProperties; };
struct IAudioNodeEmitterConeProperties : IAudioNodeEmitterConeProperties_raw, generate<IAudioNodeEmitterConeProperties> {};

// AudioNodeEmitterConeProperties
template<typename X> struct statics<AudioNodeEmitterConeProperties, X> : X {
	typedef typename X::root_type AudioNodeEmitterConeProperties;
};
struct AudioNodeEmitterConeProperties : generate<AudioNodeEmitterConeProperties> {};

// IAudioNodeEmitterShape
struct IAudioNodeEmitterShape_raw : IInspectable {
	virtual STDMETHODIMP _get_Kind(AudioNodeEmitterShapeKind *value);
	virtual STDMETHODIMP _get_ConeProperties(AudioNodeEmitterConeProperties* *value);
};
template<typename X> struct IAudioNodeEmitterShape_adaptor : X {
	union {
		struct : property {
			ptr<AudioNodeEmitterConeProperties> get() { AudioNodeEmitterConeProperties* value; hrcheck(enc(&IAudioNodeEmitterShape_adaptor::ConeProperties)->_get_ConeProperties(&value)); return from_abi(value); }
			ptr<AudioNodeEmitterConeProperties> operator()() { return get(); }
			operator ptr<AudioNodeEmitterConeProperties> () { return get(); }
			ptr<AudioNodeEmitterConeProperties> operator->() { return get(); }
		} ConeProperties;
		struct : property {
			AudioNodeEmitterShapeKind get() { AudioNodeEmitterShapeKind value; hrcheck(enc(&IAudioNodeEmitterShape_adaptor::Kind)->_get_Kind(&value)); return value; }
			AudioNodeEmitterShapeKind operator()() { return get(); }
			operator AudioNodeEmitterShapeKind () { return get(); }
		} Kind;
	};
	IAudioNodeEmitterShape_adaptor() {}
};
template<typename X> struct adapt<IAudioNodeEmitterShape, X> : Windows::Media::Audio::IAudioNodeEmitterShape_adaptor<X> { typedef adapt IAudioNodeEmitterShape; };
struct IAudioNodeEmitterShape : IAudioNodeEmitterShape_raw, generate<IAudioNodeEmitterShape> {};

// IAudioNodeEmitterShapeStatics
struct IAudioNodeEmitterShapeStatics : IInspectable {
	virtual STDMETHODIMP _CreateCone(double innerAngle, double outerAngle, double outerAngleGain, AudioNodeEmitterShape* *shape);
	virtual STDMETHODIMP _CreateOmnidirectional(AudioNodeEmitterShape* *shape);
};

// AudioNodeEmitterShape
template<typename> struct AudioNodeEmitterShape_statics {
	static ptr<AudioNodeEmitterShape> CreateCone(double innerAngle, double outerAngle, double outerAngleGain) { AudioNodeEmitterShape* shape; hrcheck(get_activation_factory<AudioNodeEmitterShape, IAudioNodeEmitterShapeStatics>()->_CreateCone(innerAngle, outerAngle, outerAngleGain, &shape)); return from_abi(shape); }
	static ptr<AudioNodeEmitterShape> CreateOmnidirectional() { AudioNodeEmitterShape* shape; hrcheck(get_activation_factory<AudioNodeEmitterShape, IAudioNodeEmitterShapeStatics>()->_CreateOmnidirectional(&shape)); return from_abi(shape); }
};

template<typename X> struct statics<AudioNodeEmitterShape, X> : X, Windows::Media::Audio::AudioNodeEmitterShape_statics<void> {
	typedef typename X::root_type AudioNodeEmitterShape;
};
struct AudioNodeEmitterShape : generate<AudioNodeEmitterShape> {};

// IAudioNodeEmitterNaturalDecayModelProperties
struct IAudioNodeEmitterNaturalDecayModelProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_UnityGainDistance(double *value);
	virtual STDMETHODIMP _get_CutoffDistance(double *value);
};
template<typename X> struct IAudioNodeEmitterNaturalDecayModelProperties_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioNodeEmitterNaturalDecayModelProperties_adaptor::CutoffDistance)->_get_CutoffDistance(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} CutoffDistance;
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioNodeEmitterNaturalDecayModelProperties_adaptor::UnityGainDistance)->_get_UnityGainDistance(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} UnityGainDistance;
	};
	IAudioNodeEmitterNaturalDecayModelProperties_adaptor() {}
};
template<typename X> struct adapt<IAudioNodeEmitterNaturalDecayModelProperties, X> : Windows::Media::Audio::IAudioNodeEmitterNaturalDecayModelProperties_adaptor<X> { typedef adapt IAudioNodeEmitterNaturalDecayModelProperties; };
struct IAudioNodeEmitterNaturalDecayModelProperties : IAudioNodeEmitterNaturalDecayModelProperties_raw, generate<IAudioNodeEmitterNaturalDecayModelProperties> {};

// AudioNodeEmitterNaturalDecayModelProperties
template<typename X> struct statics<AudioNodeEmitterNaturalDecayModelProperties, X> : X {
	typedef typename X::root_type AudioNodeEmitterNaturalDecayModelProperties;
};
struct AudioNodeEmitterNaturalDecayModelProperties : generate<AudioNodeEmitterNaturalDecayModelProperties> {};

// IAudioNodeEmitterDecayModel
struct IAudioNodeEmitterDecayModel_raw : IInspectable {
	virtual STDMETHODIMP _get_Kind(AudioNodeEmitterDecayKind *value);
	virtual STDMETHODIMP _get_MinGain(double *value);
	virtual STDMETHODIMP _get_MaxGain(double *value);
	virtual STDMETHODIMP _get_NaturalProperties(AudioNodeEmitterNaturalDecayModelProperties* *value);
};
template<typename X> struct IAudioNodeEmitterDecayModel_adaptor : X {
	union {
		struct : property {
			AudioNodeEmitterDecayKind get() { AudioNodeEmitterDecayKind value; hrcheck(enc(&IAudioNodeEmitterDecayModel_adaptor::Kind)->_get_Kind(&value)); return value; }
			AudioNodeEmitterDecayKind operator()() { return get(); }
			operator AudioNodeEmitterDecayKind () { return get(); }
		} Kind;
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioNodeEmitterDecayModel_adaptor::MaxGain)->_get_MaxGain(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} MaxGain;
		struct : property {
			double get() { double value; hrcheck(enc(&IAudioNodeEmitterDecayModel_adaptor::MinGain)->_get_MinGain(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} MinGain;
		struct : property {
			ptr<AudioNodeEmitterNaturalDecayModelProperties> get() { AudioNodeEmitterNaturalDecayModelProperties* value; hrcheck(enc(&IAudioNodeEmitterDecayModel_adaptor::NaturalProperties)->_get_NaturalProperties(&value)); return from_abi(value); }
			ptr<AudioNodeEmitterNaturalDecayModelProperties> operator()() { return get(); }
			operator ptr<AudioNodeEmitterNaturalDecayModelProperties> () { return get(); }
			ptr<AudioNodeEmitterNaturalDecayModelProperties> operator->() { return get(); }
		} NaturalProperties;
	};
	IAudioNodeEmitterDecayModel_adaptor() {}
};
template<typename X> struct adapt<IAudioNodeEmitterDecayModel, X> : Windows::Media::Audio::IAudioNodeEmitterDecayModel_adaptor<X> { typedef adapt IAudioNodeEmitterDecayModel; };
struct IAudioNodeEmitterDecayModel : IAudioNodeEmitterDecayModel_raw, generate<IAudioNodeEmitterDecayModel> {};

// IAudioNodeEmitterDecayModelStatics
struct IAudioNodeEmitterDecayModelStatics : IInspectable {
	virtual STDMETHODIMP _CreateNatural(double minGain, double maxGain, double unityGainDistance, double cutoffDistance, AudioNodeEmitterDecayModel* *decayModel);
	virtual STDMETHODIMP _CreateCustom(double minGain, double maxGain, AudioNodeEmitterDecayModel* *decayModel);
};

// AudioNodeEmitterDecayModel
template<typename> struct AudioNodeEmitterDecayModel_statics {
	static ptr<AudioNodeEmitterDecayModel> CreateNatural(double minGain, double maxGain, double unityGainDistance, double cutoffDistance) { AudioNodeEmitterDecayModel* decayModel; hrcheck(get_activation_factory<AudioNodeEmitterDecayModel, IAudioNodeEmitterDecayModelStatics>()->_CreateNatural(minGain, maxGain, unityGainDistance, cutoffDistance, &decayModel)); return from_abi(decayModel); }
	static ptr<AudioNodeEmitterDecayModel> CreateCustom(double minGain, double maxGain) { AudioNodeEmitterDecayModel* decayModel; hrcheck(get_activation_factory<AudioNodeEmitterDecayModel, IAudioNodeEmitterDecayModelStatics>()->_CreateCustom(minGain, maxGain, &decayModel)); return from_abi(decayModel); }
};

template<typename X> struct statics<AudioNodeEmitterDecayModel, X> : X, Windows::Media::Audio::AudioNodeEmitterDecayModel_statics<void> {
	typedef typename X::root_type AudioNodeEmitterDecayModel;
};
struct AudioNodeEmitterDecayModel : generate<AudioNodeEmitterDecayModel> {};
}}}
} // namespace iso_winrt
