#pragma once
// generated by isopod tools
// namespaces:
// Windows.Services.Store

#include "Windows.Services.Store.0.h"
#include "Windows.Web.Http.0.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace ApplicationModel {
struct Package;
}
namespace Foundation { namespace Collections {
template<typename T> struct IVector;
template<typename T> struct IIterable;
template<typename K, typename V> struct IMapView;
template<typename T> struct IVectorView;
}}
namespace System {
struct User;
}}

// defs

template<> struct def<Windows::Services::Store::StoreContract> : value_type<> {};
template<> struct def<Windows::Services::Store::StorePurchaseStatus> : enum_type<int> {};
template<> struct def<Windows::Services::Store::StoreConsumableStatus> : enum_type<int> {};
template<> struct def<Windows::Services::Store::StoreDurationUnit> : enum_type<int> {};
template<> struct def<Windows::Services::Store::StorePackageUpdateState> : enum_type<int> {};
template<> struct def<Windows::Services::Store::StoreCanLicenseStatus> : enum_type<int> {};
template<> struct def<Windows::Services::Store::StoreQueueItemState> : enum_type<int> {};
template<> struct def<Windows::Services::Store::StoreQueueItemExtendedState> : enum_type<int> {};
template<> struct def<Windows::Services::Store::StoreQueueItemKind> : enum_type<int> {};
template<> struct def<Windows::Services::Store::StorePackageUpdateStatus> : value_type<HSTRING, unsigned __int64, unsigned __int64, double, double, Windows::Services::Store::StorePackageUpdateState> {};
template<> struct def<Windows::Services::Store::StoreUninstallStorePackageStatus> : enum_type<int> {};
template<> struct def<Windows::Services::Store::IStoreProductPagedQueryResult> : interface_type<> {};
template<> struct def<Windows::Services::Store::IStoreProduct> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreProduct> : class_type<Platform::Object, Windows::Services::Store::IStoreProduct> {};
template<> struct def<Windows::Services::Store::StoreProductPagedQueryResult> : class_type<Platform::Object, Windows::Services::Store::IStoreProductPagedQueryResult> {};
template<> struct def<Windows::Services::Store::IStoreProductQueryResult> : interface_type<> {};
template<> struct def<Windows::Services::Store::IStoreProductResult> : interface_type<> {};
template<> struct def<Windows::Services::Store::IStorePurchaseProperties> : interface_type<> {};
template<> struct def<Windows::Services::Store::IStorePurchasePropertiesFactory> : interface_type<> {};
template<> struct def<Windows::Services::Store::StorePurchaseProperties> : class_type<Platform::Object, Windows::Services::Store::IStorePurchaseProperties>, custom_activators {};
template<> struct def<Windows::Services::Store::IStoreCollectionData> : interface_type<> {};
template<> struct def<Windows::Services::Store::IStoreLicense> : interface_type<> {};
template<> struct def<Windows::Services::Store::IStoreAppLicense> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreLicense> : class_type<Platform::Object, Windows::Services::Store::IStoreLicense> {};
template<> struct def<Windows::Services::Store::IStoreSendRequestResult> : interface_type<> {};
template<> struct def<Windows::Services::Store::IStoreSendRequestResult2> : interface_type<> {};
template<> struct def<Windows::Services::Store::IStoreImage> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreImage> : class_type<Platform::Object, Windows::Services::Store::IStoreImage> {};
template<> struct def<Windows::Services::Store::IStoreVideo> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreVideo> : class_type<Platform::Object, Windows::Services::Store::IStoreVideo> {};
template<> struct def<Windows::Services::Store::IStoreSku> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreSku> : class_type<Platform::Object, Windows::Services::Store::IStoreSku> {};
template<> struct def<Windows::Services::Store::IStorePrice> : interface_type<> {};
template<> struct def<Windows::Services::Store::StorePrice> : class_type<Platform::Object, Windows::Services::Store::IStorePrice> {};
template<> struct def<Windows::Services::Store::IStorePurchaseResult> : interface_type<> {};
template<> struct def<Windows::Services::Store::StorePurchaseResult> : class_type<Platform::Object, Windows::Services::Store::IStorePurchaseResult> {};
template<> struct def<Windows::Services::Store::IStoreAvailability> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreAvailability> : class_type<Platform::Object, Windows::Services::Store::IStoreAvailability> {};
template<> struct def<Windows::Services::Store::StoreCollectionData> : class_type<Platform::Object, Windows::Services::Store::IStoreCollectionData> {};
template<> struct def<Windows::Services::Store::IStoreSubscriptionInfo> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreSubscriptionInfo> : class_type<Platform::Object, Windows::Services::Store::IStoreSubscriptionInfo> {};
template<> struct def<Windows::Services::Store::IStoreConsumableResult> : interface_type<> {};
template<> struct def<Windows::Services::Store::IStoreContextStatics> : interface_type<> {};
template<> struct def<Windows::Services::Store::IStoreContext3> : interface_type<> {};
template<> struct def<Windows::Services::Store::IStoreContext2> : interface_type<> {};
template<> struct def<Windows::Services::Store::IStoreContext> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreContext> : class_type<Platform::Object, Windows::Services::Store::IStoreContext, Windows::Services::Store::IStoreContext2, Windows::Services::Store::IStoreContext3> {};
template<> struct def<Windows::Services::Store::IStoreRequestHelperStatics> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreSendRequestResult> : class_type<Platform::Object, Windows::Services::Store::IStoreSendRequestResult, Windows::Services::Store::IStoreSendRequestResult2> {};
template<> struct def<Windows::Services::Store::StoreAppLicense> : class_type<Platform::Object, Windows::Services::Store::IStoreAppLicense> {};
template<> struct def<Windows::Services::Store::StoreProductResult> : class_type<Platform::Object, Windows::Services::Store::IStoreProductResult> {};
template<> struct def<Windows::Services::Store::StoreProductQueryResult> : class_type<Platform::Object, Windows::Services::Store::IStoreProductQueryResult> {};
template<> struct def<Windows::Services::Store::StoreConsumableResult> : class_type<Platform::Object, Windows::Services::Store::IStoreConsumableResult> {};
template<> struct def<Windows::Services::Store::IStoreAcquireLicenseResult> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreAcquireLicenseResult> : class_type<Platform::Object, Windows::Services::Store::IStoreAcquireLicenseResult> {};
template<> struct def<Windows::Services::Store::IStorePackageUpdate> : interface_type<> {};
template<> struct def<Windows::Services::Store::StorePackageUpdate> : class_type<Platform::Object, Windows::Services::Store::IStorePackageUpdate> {};
template<> struct def<Windows::Services::Store::IStorePackageUpdateResult2> : interface_type<> {};
template<> struct def<Windows::Services::Store::IStorePackageUpdateResult> : interface_type<> {};
template<> struct def<Windows::Services::Store::StorePackageUpdateResult> : class_type<Platform::Object, Windows::Services::Store::IStorePackageUpdateResult, Windows::Services::Store::IStorePackageUpdateResult2> {};
template<> struct def<Windows::Services::Store::IStoreCanAcquireLicenseResult> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreCanAcquireLicenseResult> : class_type<Platform::Object, Windows::Services::Store::IStoreCanAcquireLicenseResult> {};
template<> struct def<Windows::Services::Store::IStoreProductOptions> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreProductOptions> : class_type<Platform::Object, Windows::Services::Store::IStoreProductOptions> {};
template<> struct def<Windows::Services::Store::IStoreQueueItem> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreQueueItem> : class_type<Platform::Object, Windows::Services::Store::IStoreQueueItem> {};
template<> struct def<Windows::Services::Store::IStorePackageInstallOptions> : interface_type<> {};
template<> struct def<Windows::Services::Store::StorePackageInstallOptions> : class_type<Platform::Object, Windows::Services::Store::IStorePackageInstallOptions> {};
template<> struct def<Windows::Services::Store::IStoreUninstallStorePackageResult> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreUninstallStorePackageResult> : class_type<Platform::Object, Windows::Services::Store::IStoreUninstallStorePackageResult> {};
template<> struct def<Windows::Services::Store::IStoreQueueItemStatus> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreQueueItemStatus> : class_type<Platform::Object, Windows::Services::Store::IStoreQueueItemStatus> {};
template<> struct def<Windows::Services::Store::IStoreQueueItemCompletedEventArgs> : interface_type<> {};
template<> struct def<Windows::Services::Store::StoreQueueItemCompletedEventArgs> : class_type<Platform::Object, Windows::Services::Store::IStoreQueueItemCompletedEventArgs> {};
template<> struct def<Windows::Services::Store::IStorePackageLicense> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Services::Store::StorePackageLicense> : class_type<Platform::Object, Windows::Services::Store::IStorePackageLicense> {};
template<> struct def<Windows::Services::Store::StoreRequestHelper> : class_type<Platform::Object, Platform::Object> {};

// uuids

template<> struct uuid<Windows::Services::Store::IStoreProductPagedQueryResult> { define_guid(0xC92718C5, 0x4DD5, 0x4869, 0xA4, 0x62, 0xEC, 0xC6, 0x87, 0x2E, 0x43, 0xC5);};
template<> struct uuid<Windows::Services::Store::IStoreProduct> { define_guid(0x320E2C52, 0xD760, 0x450A, 0xA4, 0x2B, 0x67, 0xD1, 0xE9, 0x1, 0xAC, 0x90);};
template<> struct uuid<Windows::Services::Store::IStoreProductQueryResult> { define_guid(0xD805E6C5, 0xD456, 0x4FF6, 0x80, 0x49, 0x90, 0x76, 0xD5, 0x16, 0x5F, 0x73);};
template<> struct uuid<Windows::Services::Store::IStoreProductResult> { define_guid(0xB7674F73, 0x3C87, 0x4EE1, 0x82, 0x1, 0xF4, 0x28, 0x35, 0x9B, 0xD3, 0xAF);};
template<> struct uuid<Windows::Services::Store::IStorePurchaseProperties> { define_guid(0x836278F3, 0xFF87, 0x4364, 0xA5, 0xB4, 0xFD, 0x21, 0x53, 0xEB, 0xE4, 0x3B);};
template<> struct uuid<Windows::Services::Store::IStorePurchasePropertiesFactory> { define_guid(0xA768F59E, 0xFEFD, 0x489F, 0x9A, 0x17, 0x22, 0xA5, 0x93, 0xE6, 0x8B, 0x9D);};
template<> struct uuid<Windows::Services::Store::IStoreCollectionData> { define_guid(0x8AA4C3B3, 0x5BB3, 0x441A, 0x2A, 0xB4, 0x4D, 0xAB, 0x73, 0xD5, 0xCE, 0x67);};
template<> struct uuid<Windows::Services::Store::IStoreLicense> { define_guid(0x26DC9579, 0x4C4F, 0x4F30, 0xBC, 0x89, 0x64, 0x9F, 0x60, 0xE3, 0x60, 0x55);};
template<> struct uuid<Windows::Services::Store::IStoreAppLicense> { define_guid(0xF389F9DE, 0x73C0, 0x45CE, 0x9B, 0xAB, 0xB2, 0xFE, 0x3E, 0x5E, 0xAF, 0xD3);};
template<> struct uuid<Windows::Services::Store::IStoreSendRequestResult> { define_guid(0xC73ABE60, 0x8272, 0x4502, 0x8A, 0x69, 0x6E, 0x75, 0x15, 0x3A, 0x42, 0x99);};
template<> struct uuid<Windows::Services::Store::IStoreSendRequestResult2> { define_guid(0x2901296F, 0xC0B0, 0x49D0, 0x8E, 0x8D, 0xAA, 0x94, 0xA, 0xF9, 0xC1, 0xB);};
template<> struct uuid<Windows::Services::Store::IStoreImage> { define_guid(0x81FD248, 0xADB4, 0x4B64, 0xA9, 0x93, 0x78, 0x47, 0x89, 0x92, 0x6E, 0xD5);};
template<> struct uuid<Windows::Services::Store::IStoreVideo> { define_guid(0xF26CB184, 0x6F5E, 0x4DC2, 0x88, 0x6C, 0x3C, 0x63, 0x8, 0x3C, 0x2F, 0x94);};
template<> struct uuid<Windows::Services::Store::IStoreSku> { define_guid(0x397E6F55, 0x4440, 0x4F03, 0x86, 0x3C, 0x91, 0xF3, 0xFE, 0xC8, 0x3D, 0x79);};
template<> struct uuid<Windows::Services::Store::IStorePrice> { define_guid(0x55BA94C4, 0x15F1, 0x407C, 0x8F, 0x6, 0x0, 0x63, 0x80, 0xF4, 0xDF, 0xB);};
template<> struct uuid<Windows::Services::Store::IStorePurchaseResult> { define_guid(0xADD28552, 0xF96A, 0x463D, 0xA7, 0xBB, 0xC2, 0xB, 0x4F, 0xCA, 0x69, 0x52);};
template<> struct uuid<Windows::Services::Store::IStoreAvailability> { define_guid(0xFA060325, 0xFFD, 0x4493, 0xAD, 0x43, 0xF1, 0xF9, 0x91, 0x8F, 0x69, 0xFA);};
template<> struct uuid<Windows::Services::Store::IStoreSubscriptionInfo> { define_guid(0x4189776A, 0x559, 0x43AC, 0xA9, 0xC6, 0x3A, 0xB0, 0x1, 0x1F, 0xB8, 0xEB);};
template<> struct uuid<Windows::Services::Store::IStoreConsumableResult> { define_guid(0xEA5DAB72, 0x6A00, 0x4052, 0xBE, 0x5B, 0xBF, 0xDA, 0xB4, 0x43, 0x33, 0x52);};
template<> struct uuid<Windows::Services::Store::IStoreContextStatics> { define_guid(0x9C06EE5F, 0x15C0, 0x4E72, 0x93, 0x30, 0xD6, 0x19, 0x1C, 0xEB, 0xD1, 0x9C);};
template<> struct uuid<Windows::Services::Store::IStoreContext3> { define_guid(0xE26226CA, 0x1A01, 0x4730, 0x85, 0xA6, 0xEC, 0xC8, 0x96, 0xE4, 0xAE, 0x38);};
template<> struct uuid<Windows::Services::Store::IStoreContext2> { define_guid(0x18BC54DA, 0x7BD9, 0x452C, 0x91, 0x16, 0x3B, 0xBD, 0x6, 0xFF, 0xC6, 0x3A);};
template<> struct uuid<Windows::Services::Store::IStoreContext> { define_guid(0xAC98B6BE, 0xF4FD, 0x4912, 0xBA, 0xBD, 0x50, 0x35, 0xE5, 0xE8, 0xBC, 0xAB);};
template<> struct uuid<Windows::Services::Store::IStoreRequestHelperStatics> { define_guid(0x6CE5E5F9, 0xA0C9, 0x4B2C, 0x96, 0xA6, 0xA1, 0x71, 0xC6, 0x30, 0x3, 0x8D);};
template<> struct uuid<Windows::Services::Store::IStoreAcquireLicenseResult> { define_guid(0xFBD7946D, 0xF040, 0x4CB3, 0x9A, 0x39, 0x29, 0xBC, 0xEC, 0xDB, 0xE2, 0x2D);};
template<> struct uuid<Windows::Services::Store::IStorePackageUpdate> { define_guid(0x140FA150, 0x3CBF, 0x4A35, 0xB9, 0x1F, 0x48, 0x27, 0x1C, 0x31, 0xB0, 0x72);};
template<> struct uuid<Windows::Services::Store::IStorePackageUpdateResult2> { define_guid(0x71D012E, 0xBC62, 0x4F2E, 0x87, 0xEA, 0x99, 0xD8, 0x1, 0xAE, 0xAF, 0x98);};
template<> struct uuid<Windows::Services::Store::IStorePackageUpdateResult> { define_guid(0xE79142ED, 0x61F9, 0x4893, 0xB4, 0xFE, 0xCF, 0x19, 0x16, 0x3, 0xAF, 0x7B);};
template<> struct uuid<Windows::Services::Store::IStoreCanAcquireLicenseResult> { define_guid(0x3A693DB3, 0x88, 0x482F, 0x86, 0xD5, 0xBD, 0x46, 0x52, 0x26, 0x63, 0xAD);};
template<> struct uuid<Windows::Services::Store::IStoreProductOptions> { define_guid(0x5B34A0F9, 0xA113, 0x4811, 0x83, 0x26, 0x16, 0x19, 0x9C, 0x92, 0x7F, 0x31);};
template<> struct uuid<Windows::Services::Store::IStoreQueueItem> { define_guid(0x56D5C32B, 0xF830, 0x4293, 0x91, 0x88, 0xCA, 0xD2, 0xDC, 0xDE, 0x73, 0x57);};
template<> struct uuid<Windows::Services::Store::IStorePackageInstallOptions> { define_guid(0x1D3D630C, 0xCCD, 0x44DD, 0x8C, 0x59, 0x80, 0x81, 0xA, 0x72, 0x99, 0x73);};
template<> struct uuid<Windows::Services::Store::IStoreUninstallStorePackageResult> { define_guid(0x9FCA39FD, 0x126F, 0x4CDA, 0xB8, 0x1, 0x13, 0x46, 0xB8, 0xD0, 0xA2, 0x60);};
template<> struct uuid<Windows::Services::Store::IStoreQueueItemStatus> { define_guid(0x9BD6796F, 0x9CC3, 0x4EC3, 0xB2, 0xEF, 0x7B, 0xE4, 0x33, 0xB3, 0x1, 0x74);};
template<> struct uuid<Windows::Services::Store::IStoreQueueItemCompletedEventArgs> { define_guid(0x1247DF6C, 0xB44A, 0x439B, 0xBB, 0x7, 0x1D, 0x30, 0x3, 0xD0, 0x5, 0xC2);};
template<> struct uuid<Windows::Services::Store::IStorePackageLicense> { define_guid(0xC465714, 0x14E1, 0x4973, 0xBD, 0x14, 0xF7, 0x77, 0x24, 0x27, 0x1E, 0x99);};

// types

namespace Windows { namespace Services { namespace Store {

// IStoreProductPagedQueryResult
struct IStoreProductPagedQueryResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Products(Foundation::Collections::IMapView<HSTRING, StoreProduct*>* *value);
	virtual STDMETHODIMP _get_HasMoreResults(bool *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
	virtual STDMETHODIMP _GetNextAsync(Foundation::IAsyncOperation<StoreProductPagedQueryResult*>* *operation);
};
template<typename X> struct IStoreProductPagedQueryResult_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IStoreProductPagedQueryResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStoreProductPagedQueryResult_adaptor::HasMoreResults)->_get_HasMoreResults(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasMoreResults;
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, ptr<StoreProduct>>> get() { Foundation::Collections::IMapView<HSTRING, StoreProduct*>* value; hrcheck(enc(&IStoreProductPagedQueryResult_adaptor::Products)->_get_Products(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<StoreProduct>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, ptr<StoreProduct>>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<StoreProduct>>> operator->() { return get(); }
		} Products;
	};
	ptr<Foundation::IAsyncOperation<ptr<StoreProductPagedQueryResult>>> GetNextAsync() { Foundation::IAsyncOperation<StoreProductPagedQueryResult*>* operation; hrcheck(X::get()->_GetNextAsync(&operation)); return from_abi(operation); }
	IStoreProductPagedQueryResult_adaptor() {}
};
template<typename X> struct adapt<IStoreProductPagedQueryResult, X> : Windows::Services::Store::IStoreProductPagedQueryResult_adaptor<X> { typedef adapt IStoreProductPagedQueryResult; };
struct IStoreProductPagedQueryResult : IStoreProductPagedQueryResult_raw, generate<IStoreProductPagedQueryResult> {};

// IStoreProduct
struct IStoreProduct_raw : IInspectable {
	virtual STDMETHODIMP _get_StoreId(HSTRING *value);
	virtual STDMETHODIMP _get_Language(HSTRING *value);
	virtual STDMETHODIMP _get_Title(HSTRING *value);
	virtual STDMETHODIMP _get_Description(HSTRING *value);
	virtual STDMETHODIMP _get_ProductKind(HSTRING *value);
	virtual STDMETHODIMP _get_HasDigitalDownload(bool *value);
	virtual STDMETHODIMP _get_Keywords(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _get_Images(Foundation::Collections::IVectorView<StoreImage*>* *value);
	virtual STDMETHODIMP _get_Videos(Foundation::Collections::IVectorView<StoreVideo*>* *value);
	virtual STDMETHODIMP _get_Skus(Foundation::Collections::IVectorView<StoreSku*>* *value);
	virtual STDMETHODIMP _get_IsInUserCollection(bool *value);
	virtual STDMETHODIMP _get_Price(StorePrice* *value);
	virtual STDMETHODIMP _get_ExtendedJsonData(HSTRING *value);
	virtual STDMETHODIMP _get_LinkUri(Foundation::Uri* *value);
	virtual STDMETHODIMP _GetIsAnySkuInstalledAsync(Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _RequestPurchaseAsync(Foundation::IAsyncOperation<StorePurchaseResult*>* *operation);
	virtual STDMETHODIMP _RequestPurchaseWithPurchasePropertiesAsync(StorePurchaseProperties* storePurchaseProperties, Foundation::IAsyncOperation<StorePurchaseResult*>* *operation);
	virtual STDMETHODIMP _get_InAppOfferToken(HSTRING *value);
};
template<typename X> struct IStoreProduct_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreProduct_adaptor::Description)->_get_Description(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Description;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreProduct_adaptor::ExtendedJsonData)->_get_ExtendedJsonData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ExtendedJsonData;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStoreProduct_adaptor::HasDigitalDownload)->_get_HasDigitalDownload(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasDigitalDownload;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<StoreImage>>> get() { Foundation::Collections::IVectorView<StoreImage*>* value; hrcheck(enc(&IStoreProduct_adaptor::Images)->_get_Images(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<StoreImage>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<StoreImage>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<StoreImage>>> operator->() { return get(); }
		} Images;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreProduct_adaptor::InAppOfferToken)->_get_InAppOfferToken(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} InAppOfferToken;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStoreProduct_adaptor::IsInUserCollection)->_get_IsInUserCollection(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsInUserCollection;
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&IStoreProduct_adaptor::Keywords)->_get_Keywords(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} Keywords;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreProduct_adaptor::Language)->_get_Language(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Language;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IStoreProduct_adaptor::LinkUri)->_get_LinkUri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} LinkUri;
		struct : property {
			ptr<StorePrice> get() { StorePrice* value; hrcheck(enc(&IStoreProduct_adaptor::Price)->_get_Price(&value)); return from_abi(value); }
			ptr<StorePrice> operator()() { return get(); }
			operator ptr<StorePrice> () { return get(); }
			ptr<StorePrice> operator->() { return get(); }
		} Price;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreProduct_adaptor::ProductKind)->_get_ProductKind(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ProductKind;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<StoreSku>>> get() { Foundation::Collections::IVectorView<StoreSku*>* value; hrcheck(enc(&IStoreProduct_adaptor::Skus)->_get_Skus(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<StoreSku>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<StoreSku>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<StoreSku>>> operator->() { return get(); }
		} Skus;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreProduct_adaptor::StoreId)->_get_StoreId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} StoreId;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreProduct_adaptor::Title)->_get_Title(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Title;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<StoreVideo>>> get() { Foundation::Collections::IVectorView<StoreVideo*>* value; hrcheck(enc(&IStoreProduct_adaptor::Videos)->_get_Videos(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<StoreVideo>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<StoreVideo>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<StoreVideo>>> operator->() { return get(); }
		} Videos;
	};
	ptr<Foundation::IAsyncOperation<bool>> GetIsAnySkuInstalledAsync() { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_GetIsAnySkuInstalledAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorePurchaseResult>>> RequestPurchaseAsync() { Foundation::IAsyncOperation<StorePurchaseResult*>* operation; hrcheck(X::get()->_RequestPurchaseAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorePurchaseResult>>> RequestPurchaseAsync(pptr<StorePurchaseProperties> storePurchaseProperties) { Foundation::IAsyncOperation<StorePurchaseResult*>* operation; hrcheck(X::get()->_RequestPurchaseWithPurchasePropertiesAsync(storePurchaseProperties, &operation)); return from_abi(operation); }
	IStoreProduct_adaptor() {}
};
template<typename X> struct adapt<IStoreProduct, X> : Windows::Services::Store::IStoreProduct_adaptor<X> { typedef adapt IStoreProduct; };
struct IStoreProduct : IStoreProduct_raw, generate<IStoreProduct> {};

// StoreProduct
template<typename X> struct statics<StoreProduct, X> : X {
	typedef typename X::root_type StoreProduct;
};
struct StoreProduct : generate<StoreProduct> {
	using IStoreProduct::RequestPurchaseAsync;
};

// StoreProductPagedQueryResult
template<typename X> struct statics<StoreProductPagedQueryResult, X> : X {
	typedef typename X::root_type StoreProductPagedQueryResult;
};
struct StoreProductPagedQueryResult : generate<StoreProductPagedQueryResult> {};

// IStoreProductQueryResult
struct IStoreProductQueryResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Products(Foundation::Collections::IMapView<HSTRING, StoreProduct*>* *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IStoreProductQueryResult_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IStoreProductQueryResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, ptr<StoreProduct>>> get() { Foundation::Collections::IMapView<HSTRING, StoreProduct*>* value; hrcheck(enc(&IStoreProductQueryResult_adaptor::Products)->_get_Products(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<StoreProduct>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, ptr<StoreProduct>>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<StoreProduct>>> operator->() { return get(); }
		} Products;
	};
	IStoreProductQueryResult_adaptor() {}
};
template<typename X> struct adapt<IStoreProductQueryResult, X> : Windows::Services::Store::IStoreProductQueryResult_adaptor<X> { typedef adapt IStoreProductQueryResult; };
struct IStoreProductQueryResult : IStoreProductQueryResult_raw, generate<IStoreProductQueryResult> {};

// IStoreProductResult
struct IStoreProductResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Product(StoreProduct* *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IStoreProductResult_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IStoreProductResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			ptr<StoreProduct> get() { StoreProduct* value; hrcheck(enc(&IStoreProductResult_adaptor::Product)->_get_Product(&value)); return from_abi(value); }
			ptr<StoreProduct> operator()() { return get(); }
			operator ptr<StoreProduct> () { return get(); }
			ptr<StoreProduct> operator->() { return get(); }
		} Product;
	};
	IStoreProductResult_adaptor() {}
};
template<typename X> struct adapt<IStoreProductResult, X> : Windows::Services::Store::IStoreProductResult_adaptor<X> { typedef adapt IStoreProductResult; };
struct IStoreProductResult : IStoreProductResult_raw, generate<IStoreProductResult> {};

// IStorePurchaseProperties
struct IStorePurchaseProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _put_Name(HSTRING value);
	virtual STDMETHODIMP _get_ExtendedJsonData(HSTRING *value);
	virtual STDMETHODIMP _put_ExtendedJsonData(HSTRING value);
};
template<typename X> struct IStorePurchaseProperties_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorePurchaseProperties_adaptor::ExtendedJsonData)->_get_ExtendedJsonData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IStorePurchaseProperties_adaptor::ExtendedJsonData)->_put_ExtendedJsonData(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ExtendedJsonData;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorePurchaseProperties_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IStorePurchaseProperties_adaptor::Name)->_put_Name(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Name;
	};
	IStorePurchaseProperties_adaptor() {}
};
template<typename X> struct adapt<IStorePurchaseProperties, X> : Windows::Services::Store::IStorePurchaseProperties_adaptor<X> { typedef adapt IStorePurchaseProperties; };
struct IStorePurchaseProperties : IStorePurchaseProperties_raw, generate<IStorePurchaseProperties> {};

// IStorePurchasePropertiesFactory
struct IStorePurchasePropertiesFactory : IInspectable {
	virtual STDMETHODIMP _Create(HSTRING name, StorePurchaseProperties* *storePurchaseProperties);
};

// StorePurchaseProperties
template<typename> struct StorePurchaseProperties_statics {
	static StorePurchaseProperties *activate(hstring_ref name) { StorePurchaseProperties *storePurchaseProperties; hrcheck(get_activation_factory<StorePurchaseProperties, IStorePurchasePropertiesFactory>()->_Create(name, &storePurchaseProperties)); return storePurchaseProperties; }
};

template<typename X> struct statics<StorePurchaseProperties, X> : X, Windows::Services::Store::StorePurchaseProperties_statics<void> {
	using Windows::Services::Store::StorePurchaseProperties_statics<void>::activate;
	typedef typename X::root_type StorePurchaseProperties;
};
struct StorePurchaseProperties : generate<StorePurchaseProperties> {};

// IStoreCollectionData
struct IStoreCollectionData_raw : IInspectable {
	virtual STDMETHODIMP _get_IsTrial(bool *value);
	virtual STDMETHODIMP _get_CampaignId(HSTRING *value);
	virtual STDMETHODIMP _get_DeveloperOfferId(HSTRING *value);
	virtual STDMETHODIMP _get_AcquiredDate(Foundation::DateTime *value);
	virtual STDMETHODIMP _get_StartDate(Foundation::DateTime *value);
	virtual STDMETHODIMP _get_EndDate(Foundation::DateTime *value);
	virtual STDMETHODIMP _get_TrialTimeRemaining(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_ExtendedJsonData(HSTRING *value);
};
template<typename X> struct IStoreCollectionData_adaptor : X {
	union {
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IStoreCollectionData_adaptor::AcquiredDate)->_get_AcquiredDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} AcquiredDate;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreCollectionData_adaptor::CampaignId)->_get_CampaignId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} CampaignId;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreCollectionData_adaptor::DeveloperOfferId)->_get_DeveloperOfferId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DeveloperOfferId;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IStoreCollectionData_adaptor::EndDate)->_get_EndDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} EndDate;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreCollectionData_adaptor::ExtendedJsonData)->_get_ExtendedJsonData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ExtendedJsonData;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStoreCollectionData_adaptor::IsTrial)->_get_IsTrial(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsTrial;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IStoreCollectionData_adaptor::StartDate)->_get_StartDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} StartDate;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IStoreCollectionData_adaptor::TrialTimeRemaining)->_get_TrialTimeRemaining(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} TrialTimeRemaining;
	};
	IStoreCollectionData_adaptor() {}
};
template<typename X> struct adapt<IStoreCollectionData, X> : Windows::Services::Store::IStoreCollectionData_adaptor<X> { typedef adapt IStoreCollectionData; };
struct IStoreCollectionData : IStoreCollectionData_raw, generate<IStoreCollectionData> {};

// IStoreLicense
struct IStoreLicense_raw : IInspectable {
	virtual STDMETHODIMP _get_SkuStoreId(HSTRING *value);
	virtual STDMETHODIMP _get_IsActive(bool *value);
	virtual STDMETHODIMP _get_ExpirationDate(Foundation::DateTime *value);
	virtual STDMETHODIMP _get_ExtendedJsonData(HSTRING *value);
	virtual STDMETHODIMP _get_InAppOfferToken(HSTRING *value);
};
template<typename X> struct IStoreLicense_adaptor : X {
	union {
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IStoreLicense_adaptor::ExpirationDate)->_get_ExpirationDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} ExpirationDate;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreLicense_adaptor::ExtendedJsonData)->_get_ExtendedJsonData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ExtendedJsonData;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreLicense_adaptor::InAppOfferToken)->_get_InAppOfferToken(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} InAppOfferToken;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStoreLicense_adaptor::IsActive)->_get_IsActive(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsActive;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreLicense_adaptor::SkuStoreId)->_get_SkuStoreId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} SkuStoreId;
	};
	IStoreLicense_adaptor() {}
};
template<typename X> struct adapt<IStoreLicense, X> : Windows::Services::Store::IStoreLicense_adaptor<X> { typedef adapt IStoreLicense; };
struct IStoreLicense : IStoreLicense_raw, generate<IStoreLicense> {};

// IStoreAppLicense
struct IStoreAppLicense_raw : IInspectable {
	virtual STDMETHODIMP _get_SkuStoreId(HSTRING *value);
	virtual STDMETHODIMP _get_IsActive(bool *value);
	virtual STDMETHODIMP _get_IsTrial(bool *value);
	virtual STDMETHODIMP _get_ExpirationDate(Foundation::DateTime *value);
	virtual STDMETHODIMP _get_ExtendedJsonData(HSTRING *value);
	virtual STDMETHODIMP _get_AddOnLicenses(Foundation::Collections::IMapView<HSTRING, StoreLicense*>* *value);
	virtual STDMETHODIMP _get_TrialTimeRemaining(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_IsTrialOwnedByThisUser(bool *value);
	virtual STDMETHODIMP _get_TrialUniqueId(HSTRING *value);
};
template<typename X> struct IStoreAppLicense_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, ptr<StoreLicense>>> get() { Foundation::Collections::IMapView<HSTRING, StoreLicense*>* value; hrcheck(enc(&IStoreAppLicense_adaptor::AddOnLicenses)->_get_AddOnLicenses(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<StoreLicense>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, ptr<StoreLicense>>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<StoreLicense>>> operator->() { return get(); }
		} AddOnLicenses;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IStoreAppLicense_adaptor::ExpirationDate)->_get_ExpirationDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} ExpirationDate;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreAppLicense_adaptor::ExtendedJsonData)->_get_ExtendedJsonData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ExtendedJsonData;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStoreAppLicense_adaptor::IsActive)->_get_IsActive(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsActive;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStoreAppLicense_adaptor::IsTrial)->_get_IsTrial(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsTrial;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStoreAppLicense_adaptor::IsTrialOwnedByThisUser)->_get_IsTrialOwnedByThisUser(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsTrialOwnedByThisUser;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreAppLicense_adaptor::SkuStoreId)->_get_SkuStoreId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} SkuStoreId;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IStoreAppLicense_adaptor::TrialTimeRemaining)->_get_TrialTimeRemaining(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} TrialTimeRemaining;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreAppLicense_adaptor::TrialUniqueId)->_get_TrialUniqueId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} TrialUniqueId;
	};
	IStoreAppLicense_adaptor() {}
};
template<typename X> struct adapt<IStoreAppLicense, X> : Windows::Services::Store::IStoreAppLicense_adaptor<X> { typedef adapt IStoreAppLicense; };
struct IStoreAppLicense : IStoreAppLicense_raw, generate<IStoreAppLicense> {};

// StoreLicense
template<typename X> struct statics<StoreLicense, X> : X {
	typedef typename X::root_type StoreLicense;
};
struct StoreLicense : generate<StoreLicense> {};

// IStoreSendRequestResult
struct IStoreSendRequestResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Response(HSTRING *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IStoreSendRequestResult_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IStoreSendRequestResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreSendRequestResult_adaptor::Response)->_get_Response(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Response;
	};
	IStoreSendRequestResult_adaptor() {}
};
template<typename X> struct adapt<IStoreSendRequestResult, X> : Windows::Services::Store::IStoreSendRequestResult_adaptor<X> { typedef adapt IStoreSendRequestResult; };
struct IStoreSendRequestResult : IStoreSendRequestResult_raw, generate<IStoreSendRequestResult> {};

// IStoreSendRequestResult2
struct IStoreSendRequestResult2_raw : IInspectable {
	virtual STDMETHODIMP _get_HttpStatusCode(Web::Http::HttpStatusCode *value);
};
template<typename X> struct IStoreSendRequestResult2_adaptor : X {
	union {
		struct : property {
			Web::Http::HttpStatusCode get() { Web::Http::HttpStatusCode value; hrcheck(enc(&IStoreSendRequestResult2_adaptor::HttpStatusCode)->_get_HttpStatusCode(&value)); return value; }
			Web::Http::HttpStatusCode operator()() { return get(); }
			operator Web::Http::HttpStatusCode () { return get(); }
		} HttpStatusCode;
	};
	IStoreSendRequestResult2_adaptor() {}
};
template<typename X> struct adapt<IStoreSendRequestResult2, X> : Windows::Services::Store::IStoreSendRequestResult2_adaptor<X> { typedef adapt IStoreSendRequestResult2; };
struct IStoreSendRequestResult2 : IStoreSendRequestResult2_raw, generate<IStoreSendRequestResult2> {};

// IStoreImage
struct IStoreImage_raw : IInspectable {
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_ImagePurposeTag(HSTRING *value);
	virtual STDMETHODIMP _get_Width(unsigned *value);
	virtual STDMETHODIMP _get_Height(unsigned *value);
	virtual STDMETHODIMP _get_Caption(HSTRING *value);
};
template<typename X> struct IStoreImage_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreImage_adaptor::Caption)->_get_Caption(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Caption;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IStoreImage_adaptor::Height)->_get_Height(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Height;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreImage_adaptor::ImagePurposeTag)->_get_ImagePurposeTag(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ImagePurposeTag;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IStoreImage_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IStoreImage_adaptor::Width)->_get_Width(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Width;
	};
	IStoreImage_adaptor() {}
};
template<typename X> struct adapt<IStoreImage, X> : Windows::Services::Store::IStoreImage_adaptor<X> { typedef adapt IStoreImage; };
struct IStoreImage : IStoreImage_raw, generate<IStoreImage> {};

// StoreImage
template<typename X> struct statics<StoreImage, X> : X {
	typedef typename X::root_type StoreImage;
};
struct StoreImage : generate<StoreImage> {};

// IStoreVideo
struct IStoreVideo_raw : IInspectable {
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_VideoPurposeTag(HSTRING *value);
	virtual STDMETHODIMP _get_Width(unsigned *value);
	virtual STDMETHODIMP _get_Height(unsigned *value);
	virtual STDMETHODIMP _get_Caption(HSTRING *value);
	virtual STDMETHODIMP _get_PreviewImage(StoreImage* *value);
};
template<typename X> struct IStoreVideo_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreVideo_adaptor::Caption)->_get_Caption(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Caption;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IStoreVideo_adaptor::Height)->_get_Height(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Height;
		struct : property {
			ptr<StoreImage> get() { StoreImage* value; hrcheck(enc(&IStoreVideo_adaptor::PreviewImage)->_get_PreviewImage(&value)); return from_abi(value); }
			ptr<StoreImage> operator()() { return get(); }
			operator ptr<StoreImage> () { return get(); }
			ptr<StoreImage> operator->() { return get(); }
		} PreviewImage;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IStoreVideo_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreVideo_adaptor::VideoPurposeTag)->_get_VideoPurposeTag(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} VideoPurposeTag;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IStoreVideo_adaptor::Width)->_get_Width(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Width;
	};
	IStoreVideo_adaptor() {}
};
template<typename X> struct adapt<IStoreVideo, X> : Windows::Services::Store::IStoreVideo_adaptor<X> { typedef adapt IStoreVideo; };
struct IStoreVideo : IStoreVideo_raw, generate<IStoreVideo> {};

// StoreVideo
template<typename X> struct statics<StoreVideo, X> : X {
	typedef typename X::root_type StoreVideo;
};
struct StoreVideo : generate<StoreVideo> {};

// IStoreSku
struct IStoreSku_raw : IInspectable {
	virtual STDMETHODIMP _get_StoreId(HSTRING *value);
	virtual STDMETHODIMP _get_Language(HSTRING *value);
	virtual STDMETHODIMP _get_Title(HSTRING *value);
	virtual STDMETHODIMP _get_Description(HSTRING *value);
	virtual STDMETHODIMP _get_IsTrial(bool *value);
	virtual STDMETHODIMP _get_CustomDeveloperData(HSTRING *value);
	virtual STDMETHODIMP _get_Images(Foundation::Collections::IVectorView<StoreImage*>* *value);
	virtual STDMETHODIMP _get_Videos(Foundation::Collections::IVectorView<StoreVideo*>* *value);
	virtual STDMETHODIMP _get_Availabilities(Foundation::Collections::IVectorView<StoreAvailability*>* *value);
	virtual STDMETHODIMP _get_Price(StorePrice* *value);
	virtual STDMETHODIMP _get_ExtendedJsonData(HSTRING *value);
	virtual STDMETHODIMP _get_IsInUserCollection(bool *value);
	virtual STDMETHODIMP _get_BundledSkus(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _get_CollectionData(StoreCollectionData* *value);
	virtual STDMETHODIMP _GetIsInstalledAsync(Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _RequestPurchaseAsync(Foundation::IAsyncOperation<StorePurchaseResult*>* *operation);
	virtual STDMETHODIMP _RequestPurchaseWithPurchasePropertiesAsync(StorePurchaseProperties* storePurchaseProperties, Foundation::IAsyncOperation<StorePurchaseResult*>* *operation);
	virtual STDMETHODIMP _get_IsSubscription(bool *value);
	virtual STDMETHODIMP _get_SubscriptionInfo(StoreSubscriptionInfo* *value);
};
template<typename X> struct IStoreSku_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<StoreAvailability>>> get() { Foundation::Collections::IVectorView<StoreAvailability*>* value; hrcheck(enc(&IStoreSku_adaptor::Availabilities)->_get_Availabilities(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<StoreAvailability>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<StoreAvailability>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<StoreAvailability>>> operator->() { return get(); }
		} Availabilities;
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&IStoreSku_adaptor::BundledSkus)->_get_BundledSkus(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} BundledSkus;
		struct : property {
			ptr<StoreCollectionData> get() { StoreCollectionData* value; hrcheck(enc(&IStoreSku_adaptor::CollectionData)->_get_CollectionData(&value)); return from_abi(value); }
			ptr<StoreCollectionData> operator()() { return get(); }
			operator ptr<StoreCollectionData> () { return get(); }
			ptr<StoreCollectionData> operator->() { return get(); }
		} CollectionData;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreSku_adaptor::CustomDeveloperData)->_get_CustomDeveloperData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} CustomDeveloperData;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreSku_adaptor::Description)->_get_Description(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Description;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreSku_adaptor::ExtendedJsonData)->_get_ExtendedJsonData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ExtendedJsonData;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<StoreImage>>> get() { Foundation::Collections::IVectorView<StoreImage*>* value; hrcheck(enc(&IStoreSku_adaptor::Images)->_get_Images(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<StoreImage>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<StoreImage>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<StoreImage>>> operator->() { return get(); }
		} Images;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStoreSku_adaptor::IsInUserCollection)->_get_IsInUserCollection(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsInUserCollection;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStoreSku_adaptor::IsSubscription)->_get_IsSubscription(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsSubscription;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStoreSku_adaptor::IsTrial)->_get_IsTrial(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsTrial;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreSku_adaptor::Language)->_get_Language(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Language;
		struct : property {
			ptr<StorePrice> get() { StorePrice* value; hrcheck(enc(&IStoreSku_adaptor::Price)->_get_Price(&value)); return from_abi(value); }
			ptr<StorePrice> operator()() { return get(); }
			operator ptr<StorePrice> () { return get(); }
			ptr<StorePrice> operator->() { return get(); }
		} Price;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreSku_adaptor::StoreId)->_get_StoreId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} StoreId;
		struct : property {
			ptr<StoreSubscriptionInfo> get() { StoreSubscriptionInfo* value; hrcheck(enc(&IStoreSku_adaptor::SubscriptionInfo)->_get_SubscriptionInfo(&value)); return from_abi(value); }
			ptr<StoreSubscriptionInfo> operator()() { return get(); }
			operator ptr<StoreSubscriptionInfo> () { return get(); }
			ptr<StoreSubscriptionInfo> operator->() { return get(); }
		} SubscriptionInfo;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreSku_adaptor::Title)->_get_Title(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Title;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<StoreVideo>>> get() { Foundation::Collections::IVectorView<StoreVideo*>* value; hrcheck(enc(&IStoreSku_adaptor::Videos)->_get_Videos(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<StoreVideo>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<StoreVideo>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<StoreVideo>>> operator->() { return get(); }
		} Videos;
	};
	ptr<Foundation::IAsyncOperation<bool>> GetIsInstalledAsync() { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_GetIsInstalledAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorePurchaseResult>>> RequestPurchaseAsync() { Foundation::IAsyncOperation<StorePurchaseResult*>* operation; hrcheck(X::get()->_RequestPurchaseAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorePurchaseResult>>> RequestPurchaseAsync(pptr<StorePurchaseProperties> storePurchaseProperties) { Foundation::IAsyncOperation<StorePurchaseResult*>* operation; hrcheck(X::get()->_RequestPurchaseWithPurchasePropertiesAsync(storePurchaseProperties, &operation)); return from_abi(operation); }
	IStoreSku_adaptor() {}
};
template<typename X> struct adapt<IStoreSku, X> : Windows::Services::Store::IStoreSku_adaptor<X> { typedef adapt IStoreSku; };
struct IStoreSku : IStoreSku_raw, generate<IStoreSku> {};

// StoreSku
template<typename X> struct statics<StoreSku, X> : X {
	typedef typename X::root_type StoreSku;
};
struct StoreSku : generate<StoreSku> {
	using IStoreSku::RequestPurchaseAsync;
};

// IStorePrice
struct IStorePrice_raw : IInspectable {
	virtual STDMETHODIMP _get_FormattedBasePrice(HSTRING *value);
	virtual STDMETHODIMP _get_FormattedPrice(HSTRING *value);
	virtual STDMETHODIMP _get_IsOnSale(bool *value);
	virtual STDMETHODIMP _get_SaleEndDate(Foundation::DateTime *value);
	virtual STDMETHODIMP _get_CurrencyCode(HSTRING *value);
	virtual STDMETHODIMP _get_FormattedRecurrencePrice(HSTRING *value);
};
template<typename X> struct IStorePrice_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorePrice_adaptor::CurrencyCode)->_get_CurrencyCode(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} CurrencyCode;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorePrice_adaptor::FormattedBasePrice)->_get_FormattedBasePrice(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} FormattedBasePrice;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorePrice_adaptor::FormattedPrice)->_get_FormattedPrice(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} FormattedPrice;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorePrice_adaptor::FormattedRecurrencePrice)->_get_FormattedRecurrencePrice(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} FormattedRecurrencePrice;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStorePrice_adaptor::IsOnSale)->_get_IsOnSale(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsOnSale;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IStorePrice_adaptor::SaleEndDate)->_get_SaleEndDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} SaleEndDate;
	};
	IStorePrice_adaptor() {}
};
template<typename X> struct adapt<IStorePrice, X> : Windows::Services::Store::IStorePrice_adaptor<X> { typedef adapt IStorePrice; };
struct IStorePrice : IStorePrice_raw, generate<IStorePrice> {};

// StorePrice
template<typename X> struct statics<StorePrice, X> : X {
	typedef typename X::root_type StorePrice;
};
struct StorePrice : generate<StorePrice> {};

// IStorePurchaseResult
struct IStorePurchaseResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(StorePurchaseStatus *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IStorePurchaseResult_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IStorePurchaseResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			StorePurchaseStatus get() { StorePurchaseStatus value; hrcheck(enc(&IStorePurchaseResult_adaptor::Status)->_get_Status(&value)); return value; }
			StorePurchaseStatus operator()() { return get(); }
			operator StorePurchaseStatus () { return get(); }
		} Status;
	};
	IStorePurchaseResult_adaptor() {}
};
template<typename X> struct adapt<IStorePurchaseResult, X> : Windows::Services::Store::IStorePurchaseResult_adaptor<X> { typedef adapt IStorePurchaseResult; };
struct IStorePurchaseResult : IStorePurchaseResult_raw, generate<IStorePurchaseResult> {};

// StorePurchaseResult
template<typename X> struct statics<StorePurchaseResult, X> : X {
	typedef typename X::root_type StorePurchaseResult;
};
struct StorePurchaseResult : generate<StorePurchaseResult> {};

// IStoreAvailability
struct IStoreAvailability_raw : IInspectable {
	virtual STDMETHODIMP _get_StoreId(HSTRING *value);
	virtual STDMETHODIMP _get_EndDate(Foundation::DateTime *value);
	virtual STDMETHODIMP _get_Price(StorePrice* *value);
	virtual STDMETHODIMP _get_ExtendedJsonData(HSTRING *value);
	virtual STDMETHODIMP _RequestPurchaseAsync(Foundation::IAsyncOperation<StorePurchaseResult*>* *operation);
	virtual STDMETHODIMP _RequestPurchaseWithPurchasePropertiesAsync(StorePurchaseProperties* storePurchaseProperties, Foundation::IAsyncOperation<StorePurchaseResult*>* *operation);
};
template<typename X> struct IStoreAvailability_adaptor : X {
	union {
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IStoreAvailability_adaptor::EndDate)->_get_EndDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} EndDate;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreAvailability_adaptor::ExtendedJsonData)->_get_ExtendedJsonData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ExtendedJsonData;
		struct : property {
			ptr<StorePrice> get() { StorePrice* value; hrcheck(enc(&IStoreAvailability_adaptor::Price)->_get_Price(&value)); return from_abi(value); }
			ptr<StorePrice> operator()() { return get(); }
			operator ptr<StorePrice> () { return get(); }
			ptr<StorePrice> operator->() { return get(); }
		} Price;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreAvailability_adaptor::StoreId)->_get_StoreId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} StoreId;
	};
	ptr<Foundation::IAsyncOperation<ptr<StorePurchaseResult>>> RequestPurchaseAsync() { Foundation::IAsyncOperation<StorePurchaseResult*>* operation; hrcheck(X::get()->_RequestPurchaseAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorePurchaseResult>>> RequestPurchaseAsync(pptr<StorePurchaseProperties> storePurchaseProperties) { Foundation::IAsyncOperation<StorePurchaseResult*>* operation; hrcheck(X::get()->_RequestPurchaseWithPurchasePropertiesAsync(storePurchaseProperties, &operation)); return from_abi(operation); }
	IStoreAvailability_adaptor() {}
};
template<typename X> struct adapt<IStoreAvailability, X> : Windows::Services::Store::IStoreAvailability_adaptor<X> { typedef adapt IStoreAvailability; };
struct IStoreAvailability : IStoreAvailability_raw, generate<IStoreAvailability> {};

// StoreAvailability
template<typename X> struct statics<StoreAvailability, X> : X {
	typedef typename X::root_type StoreAvailability;
};
struct StoreAvailability : generate<StoreAvailability> {
	using IStoreAvailability::RequestPurchaseAsync;
};

// StoreCollectionData
template<typename X> struct statics<StoreCollectionData, X> : X {
	typedef typename X::root_type StoreCollectionData;
};
struct StoreCollectionData : generate<StoreCollectionData> {};

// IStoreSubscriptionInfo
struct IStoreSubscriptionInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_BillingPeriod(unsigned *value);
	virtual STDMETHODIMP _get_BillingPeriodUnit(StoreDurationUnit *value);
	virtual STDMETHODIMP _get_HasTrialPeriod(bool *value);
	virtual STDMETHODIMP _get_TrialPeriod(unsigned *value);
	virtual STDMETHODIMP _get_TrialPeriodUnit(StoreDurationUnit *value);
};
template<typename X> struct IStoreSubscriptionInfo_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IStoreSubscriptionInfo_adaptor::BillingPeriod)->_get_BillingPeriod(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} BillingPeriod;
		struct : property {
			StoreDurationUnit get() { StoreDurationUnit value; hrcheck(enc(&IStoreSubscriptionInfo_adaptor::BillingPeriodUnit)->_get_BillingPeriodUnit(&value)); return value; }
			StoreDurationUnit operator()() { return get(); }
			operator StoreDurationUnit () { return get(); }
		} BillingPeriodUnit;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStoreSubscriptionInfo_adaptor::HasTrialPeriod)->_get_HasTrialPeriod(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasTrialPeriod;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IStoreSubscriptionInfo_adaptor::TrialPeriod)->_get_TrialPeriod(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} TrialPeriod;
		struct : property {
			StoreDurationUnit get() { StoreDurationUnit value; hrcheck(enc(&IStoreSubscriptionInfo_adaptor::TrialPeriodUnit)->_get_TrialPeriodUnit(&value)); return value; }
			StoreDurationUnit operator()() { return get(); }
			operator StoreDurationUnit () { return get(); }
		} TrialPeriodUnit;
	};
	IStoreSubscriptionInfo_adaptor() {}
};
template<typename X> struct adapt<IStoreSubscriptionInfo, X> : Windows::Services::Store::IStoreSubscriptionInfo_adaptor<X> { typedef adapt IStoreSubscriptionInfo; };
struct IStoreSubscriptionInfo : IStoreSubscriptionInfo_raw, generate<IStoreSubscriptionInfo> {};

// StoreSubscriptionInfo
template<typename X> struct statics<StoreSubscriptionInfo, X> : X {
	typedef typename X::root_type StoreSubscriptionInfo;
};
struct StoreSubscriptionInfo : generate<StoreSubscriptionInfo> {};

// IStoreConsumableResult
struct IStoreConsumableResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(StoreConsumableStatus *value);
	virtual STDMETHODIMP _get_TrackingId(Platform::Guid *value);
	virtual STDMETHODIMP _get_BalanceRemaining(unsigned *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IStoreConsumableResult_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IStoreConsumableResult_adaptor::BalanceRemaining)->_get_BalanceRemaining(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} BalanceRemaining;
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IStoreConsumableResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			StoreConsumableStatus get() { StoreConsumableStatus value; hrcheck(enc(&IStoreConsumableResult_adaptor::Status)->_get_Status(&value)); return value; }
			StoreConsumableStatus operator()() { return get(); }
			operator StoreConsumableStatus () { return get(); }
		} Status;
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IStoreConsumableResult_adaptor::TrackingId)->_get_TrackingId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} TrackingId;
	};
	IStoreConsumableResult_adaptor() {}
};
template<typename X> struct adapt<IStoreConsumableResult, X> : Windows::Services::Store::IStoreConsumableResult_adaptor<X> { typedef adapt IStoreConsumableResult; };
struct IStoreConsumableResult : IStoreConsumableResult_raw, generate<IStoreConsumableResult> {};

// IStoreContextStatics
struct IStoreContextStatics : IInspectable {
	virtual STDMETHODIMP _GetDefault(StoreContext* *value);
	virtual STDMETHODIMP _GetForUser(System::User* user, StoreContext* *value);
};

// IStoreContext3
struct IStoreContext3_raw : IInspectable {
	virtual STDMETHODIMP _get_CanSilentlyDownloadStorePackageUpdates(bool *value);
	virtual STDMETHODIMP _TrySilentDownloadStorePackageUpdatesAsync(Foundation::Collections::IIterable<StorePackageUpdate*>* storePackageUpdates, Foundation::IAsyncOperationWithProgress<StorePackageUpdateResult*, StorePackageUpdateStatus>* *operation);
	virtual STDMETHODIMP _TrySilentDownloadAndInstallStorePackageUpdatesAsync(Foundation::Collections::IIterable<StorePackageUpdate*>* storePackageUpdates, Foundation::IAsyncOperationWithProgress<StorePackageUpdateResult*, StorePackageUpdateStatus>* *operation);
	virtual STDMETHODIMP _CanAcquireStoreLicenseForOptionalPackageAsync(ApplicationModel::Package* optionalPackage, Foundation::IAsyncOperation<StoreCanAcquireLicenseResult*>* *operation);
	virtual STDMETHODIMP _CanAcquireStoreLicenseAsync(HSTRING productStoreId, Foundation::IAsyncOperation<StoreCanAcquireLicenseResult*>* *operation);
	virtual STDMETHODIMP _GetStoreProductsWithOptionsAsync(Foundation::Collections::IIterable<HSTRING>* productKinds, Foundation::Collections::IIterable<HSTRING>* storeIds, StoreProductOptions* storeProductOptions, Foundation::IAsyncOperation<StoreProductQueryResult*>* *operation);
	virtual STDMETHODIMP _GetAssociatedStoreQueueItemsAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StoreQueueItem*>*>* *operation);
	virtual STDMETHODIMP _GetStoreQueueItemsAsync(Foundation::Collections::IIterable<HSTRING>* storeIds, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StoreQueueItem*>*>* *operation);
	virtual STDMETHODIMP _RequestDownloadAndInstallStorePackagesWithInstallOptionsAsync(Foundation::Collections::IIterable<HSTRING>* storeIds, StorePackageInstallOptions* storePackageInstallOptions, Foundation::IAsyncOperationWithProgress<StorePackageUpdateResult*, StorePackageUpdateStatus>* *operation);
	virtual STDMETHODIMP _DownloadAndInstallStorePackagesAsync(Foundation::Collections::IIterable<HSTRING>* storeIds, Foundation::IAsyncOperationWithProgress<StorePackageUpdateResult*, StorePackageUpdateStatus>* *operation);
	virtual STDMETHODIMP _RequestUninstallStorePackageAsync(ApplicationModel::Package* package, Foundation::IAsyncOperation<StoreUninstallStorePackageResult*>* *operation);
	virtual STDMETHODIMP _RequestUninstallStorePackageByStoreIdAsync(HSTRING storeId, Foundation::IAsyncOperation<StoreUninstallStorePackageResult*>* *operation);
	virtual STDMETHODIMP _UninstallStorePackageAsync(ApplicationModel::Package* package, Foundation::IAsyncOperation<StoreUninstallStorePackageResult*>* *operation);
	virtual STDMETHODIMP _UninstallStorePackageByStoreIdAsync(HSTRING storeId, Foundation::IAsyncOperation<StoreUninstallStorePackageResult*>* *operation);
};
template<typename X> struct IStoreContext3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStoreContext3_adaptor::CanSilentlyDownloadStorePackageUpdates)->_get_CanSilentlyDownloadStorePackageUpdates(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanSilentlyDownloadStorePackageUpdates;
	};
	ptr<Foundation::IAsyncOperationWithProgress<ptr<StorePackageUpdateResult>, StorePackageUpdateStatus>> TrySilentDownloadStorePackageUpdatesAsync(pptr<Foundation::Collections::IIterable<ptr<StorePackageUpdate>>> storePackageUpdates) { Foundation::IAsyncOperationWithProgress<StorePackageUpdateResult*, StorePackageUpdateStatus>* operation; hrcheck(X::get()->_TrySilentDownloadStorePackageUpdatesAsync(to_abi(storePackageUpdates), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<StorePackageUpdateResult>, StorePackageUpdateStatus>> TrySilentDownloadAndInstallStorePackageUpdatesAsync(pptr<Foundation::Collections::IIterable<ptr<StorePackageUpdate>>> storePackageUpdates) { Foundation::IAsyncOperationWithProgress<StorePackageUpdateResult*, StorePackageUpdateStatus>* operation; hrcheck(X::get()->_TrySilentDownloadAndInstallStorePackageUpdatesAsync(to_abi(storePackageUpdates), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreCanAcquireLicenseResult>>> CanAcquireStoreLicenseForOptionalPackageAsync(pptr<ApplicationModel::Package> optionalPackage) { Foundation::IAsyncOperation<StoreCanAcquireLicenseResult*>* operation; hrcheck(X::get()->_CanAcquireStoreLicenseForOptionalPackageAsync(optionalPackage, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreCanAcquireLicenseResult>>> CanAcquireStoreLicenseAsync(hstring_ref productStoreId) { Foundation::IAsyncOperation<StoreCanAcquireLicenseResult*>* operation; hrcheck(X::get()->_CanAcquireStoreLicenseAsync(productStoreId, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreProductQueryResult>>> GetStoreProductsAsync(pptr<Foundation::Collections::IIterable<hstring>> productKinds, pptr<Foundation::Collections::IIterable<hstring>> storeIds, pptr<StoreProductOptions> storeProductOptions) { Foundation::IAsyncOperation<StoreProductQueryResult*>* operation; hrcheck(X::get()->_GetStoreProductsWithOptionsAsync(to_abi(productKinds), to_abi(storeIds), storeProductOptions, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<StoreQueueItem>>>>> GetAssociatedStoreQueueItemsAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StoreQueueItem*>*>* operation; hrcheck(X::get()->_GetAssociatedStoreQueueItemsAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<StoreQueueItem>>>>> GetStoreQueueItemsAsync(pptr<Foundation::Collections::IIterable<hstring>> storeIds) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StoreQueueItem*>*>* operation; hrcheck(X::get()->_GetStoreQueueItemsAsync(to_abi(storeIds), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<StorePackageUpdateResult>, StorePackageUpdateStatus>> RequestDownloadAndInstallStorePackagesAsync(pptr<Foundation::Collections::IIterable<hstring>> storeIds, pptr<StorePackageInstallOptions> storePackageInstallOptions) { Foundation::IAsyncOperationWithProgress<StorePackageUpdateResult*, StorePackageUpdateStatus>* operation; hrcheck(X::get()->_RequestDownloadAndInstallStorePackagesWithInstallOptionsAsync(to_abi(storeIds), storePackageInstallOptions, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<StorePackageUpdateResult>, StorePackageUpdateStatus>> DownloadAndInstallStorePackagesAsync(pptr<Foundation::Collections::IIterable<hstring>> storeIds) { Foundation::IAsyncOperationWithProgress<StorePackageUpdateResult*, StorePackageUpdateStatus>* operation; hrcheck(X::get()->_DownloadAndInstallStorePackagesAsync(to_abi(storeIds), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreUninstallStorePackageResult>>> RequestUninstallStorePackageAsync(pptr<ApplicationModel::Package> package) { Foundation::IAsyncOperation<StoreUninstallStorePackageResult*>* operation; hrcheck(X::get()->_RequestUninstallStorePackageAsync(package, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreUninstallStorePackageResult>>> RequestUninstallStorePackageByStoreIdAsync(hstring_ref storeId) { Foundation::IAsyncOperation<StoreUninstallStorePackageResult*>* operation; hrcheck(X::get()->_RequestUninstallStorePackageByStoreIdAsync(storeId, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreUninstallStorePackageResult>>> UninstallStorePackageAsync(pptr<ApplicationModel::Package> package) { Foundation::IAsyncOperation<StoreUninstallStorePackageResult*>* operation; hrcheck(X::get()->_UninstallStorePackageAsync(package, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreUninstallStorePackageResult>>> UninstallStorePackageByStoreIdAsync(hstring_ref storeId) { Foundation::IAsyncOperation<StoreUninstallStorePackageResult*>* operation; hrcheck(X::get()->_UninstallStorePackageByStoreIdAsync(storeId, &operation)); return from_abi(operation); }
	IStoreContext3_adaptor() {}
};
template<typename X> struct adapt<IStoreContext3, X> : Windows::Services::Store::IStoreContext3_adaptor<X> { typedef adapt IStoreContext3; };
struct IStoreContext3 : IStoreContext3_raw, generate<IStoreContext3> {};

// IStoreContext2
struct IStoreContext2_raw : IInspectable {
	virtual STDMETHODIMP _FindStoreProductForPackageAsync(Foundation::Collections::IIterable<HSTRING>* productKinds, ApplicationModel::Package* package, Foundation::IAsyncOperation<StoreProductResult*>* *operation);
};
template<typename X> struct IStoreContext2_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<StoreProductResult>>> FindStoreProductForPackageAsync(pptr<Foundation::Collections::IIterable<hstring>> productKinds, pptr<ApplicationModel::Package> package) { Foundation::IAsyncOperation<StoreProductResult*>* operation; hrcheck(X::get()->_FindStoreProductForPackageAsync(to_abi(productKinds), package, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IStoreContext2, X> : Windows::Services::Store::IStoreContext2_adaptor<X> { typedef adapt IStoreContext2; };
struct IStoreContext2 : IStoreContext2_raw, generate<IStoreContext2> {};

// IStoreContext
struct IStoreContext_raw : IInspectable {
	virtual STDMETHODIMP _get_User(System::User* *value);
	virtual STDMETHODIMP _add_OfflineLicensesChanged(Foundation::TypedEventHandler<StoreContext*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_OfflineLicensesChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _GetCustomerPurchaseIdAsync(HSTRING serviceTicket, HSTRING publisherUserId, Foundation::IAsyncOperation<HSTRING>* *operation);
	virtual STDMETHODIMP _GetCustomerCollectionsIdAsync(HSTRING serviceTicket, HSTRING publisherUserId, Foundation::IAsyncOperation<HSTRING>* *operation);
	virtual STDMETHODIMP _GetAppLicenseAsync(Foundation::IAsyncOperation<StoreAppLicense*>* *operation);
	virtual STDMETHODIMP _GetStoreProductForCurrentAppAsync(Foundation::IAsyncOperation<StoreProductResult*>* *operation);
	virtual STDMETHODIMP _GetStoreProductsAsync(Foundation::Collections::IIterable<HSTRING>* productKinds, Foundation::Collections::IIterable<HSTRING>* storeIds, Foundation::IAsyncOperation<StoreProductQueryResult*>* *operation);
	virtual STDMETHODIMP _GetAssociatedStoreProductsAsync(Foundation::Collections::IIterable<HSTRING>* productKinds, Foundation::IAsyncOperation<StoreProductQueryResult*>* *operation);
	virtual STDMETHODIMP _GetAssociatedStoreProductsWithPagingAsync(Foundation::Collections::IIterable<HSTRING>* productKinds, unsigned maxItemsToRetrievePerPage, Foundation::IAsyncOperation<StoreProductPagedQueryResult*>* *operation);
	virtual STDMETHODIMP _GetUserCollectionAsync(Foundation::Collections::IIterable<HSTRING>* productKinds, Foundation::IAsyncOperation<StoreProductQueryResult*>* *operation);
	virtual STDMETHODIMP _GetUserCollectionWithPagingAsync(Foundation::Collections::IIterable<HSTRING>* productKinds, unsigned maxItemsToRetrievePerPage, Foundation::IAsyncOperation<StoreProductPagedQueryResult*>* *operation);
	virtual STDMETHODIMP _ReportConsumableFulfillmentAsync(HSTRING productStoreId, unsigned quantity, Platform::Guid trackingId, Foundation::IAsyncOperation<StoreConsumableResult*>* *operation);
	virtual STDMETHODIMP _GetConsumableBalanceRemainingAsync(HSTRING productStoreId, Foundation::IAsyncOperation<StoreConsumableResult*>* *operation);
	virtual STDMETHODIMP _AcquireStoreLicenseForOptionalPackageAsync(ApplicationModel::Package* optionalPackage, Foundation::IAsyncOperation<StoreAcquireLicenseResult*>* *operation);
	virtual STDMETHODIMP _RequestPurchaseAsync(HSTRING storeId, Foundation::IAsyncOperation<StorePurchaseResult*>* *operation);
	virtual STDMETHODIMP _RequestPurchaseWithPurchasePropertiesAsync(HSTRING storeId, StorePurchaseProperties* storePurchaseProperties, Foundation::IAsyncOperation<StorePurchaseResult*>* *operation);
	virtual STDMETHODIMP _GetAppAndOptionalStorePackageUpdatesAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorePackageUpdate*>*>* *operation);
	virtual STDMETHODIMP _RequestDownloadStorePackageUpdatesAsync(Foundation::Collections::IIterable<StorePackageUpdate*>* storePackageUpdates, Foundation::IAsyncOperationWithProgress<StorePackageUpdateResult*, StorePackageUpdateStatus>* *operation);
	virtual STDMETHODIMP _RequestDownloadAndInstallStorePackageUpdatesAsync(Foundation::Collections::IIterable<StorePackageUpdate*>* storePackageUpdates, Foundation::IAsyncOperationWithProgress<StorePackageUpdateResult*, StorePackageUpdateStatus>* *operation);
	virtual STDMETHODIMP _RequestDownloadAndInstallStorePackagesAsync(Foundation::Collections::IIterable<HSTRING>* storeIds, Foundation::IAsyncOperationWithProgress<StorePackageUpdateResult*, StorePackageUpdateStatus>* *operation);
};
template<typename X> struct IStoreContext_adaptor : X {
	union {
		struct : property {
			ptr<System::User> get() { System::User* value; hrcheck(enc(&IStoreContext_adaptor::User)->_get_User(&value)); return from_abi(value); }
			ptr<System::User> operator()() { return get(); }
			operator ptr<System::User> () { return get(); }
			ptr<System::User> operator->() { return get(); }
		} User;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<StoreContext>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IStoreContext_adaptor::OfflineLicensesChanged)->_add_OfflineLicensesChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IStoreContext_adaptor::OfflineLicensesChanged)->_remove_OfflineLicensesChanged(token)); }
		} OfflineLicensesChanged;
	};
	ptr<Foundation::IAsyncOperation<hstring>> GetCustomerPurchaseIdAsync(hstring_ref serviceTicket, hstring_ref publisherUserId) { Foundation::IAsyncOperation<HSTRING>* operation; hrcheck(X::get()->_GetCustomerPurchaseIdAsync(serviceTicket, publisherUserId, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<hstring>> GetCustomerCollectionsIdAsync(hstring_ref serviceTicket, hstring_ref publisherUserId) { Foundation::IAsyncOperation<HSTRING>* operation; hrcheck(X::get()->_GetCustomerCollectionsIdAsync(serviceTicket, publisherUserId, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreAppLicense>>> GetAppLicenseAsync() { Foundation::IAsyncOperation<StoreAppLicense*>* operation; hrcheck(X::get()->_GetAppLicenseAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreProductResult>>> GetStoreProductForCurrentAppAsync() { Foundation::IAsyncOperation<StoreProductResult*>* operation; hrcheck(X::get()->_GetStoreProductForCurrentAppAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreProductQueryResult>>> GetStoreProductsAsync(pptr<Foundation::Collections::IIterable<hstring>> productKinds, pptr<Foundation::Collections::IIterable<hstring>> storeIds) { Foundation::IAsyncOperation<StoreProductQueryResult*>* operation; hrcheck(X::get()->_GetStoreProductsAsync(to_abi(productKinds), to_abi(storeIds), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreProductQueryResult>>> GetAssociatedStoreProductsAsync(pptr<Foundation::Collections::IIterable<hstring>> productKinds) { Foundation::IAsyncOperation<StoreProductQueryResult*>* operation; hrcheck(X::get()->_GetAssociatedStoreProductsAsync(to_abi(productKinds), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreProductPagedQueryResult>>> GetAssociatedStoreProductsWithPagingAsync(pptr<Foundation::Collections::IIterable<hstring>> productKinds, unsigned maxItemsToRetrievePerPage) { Foundation::IAsyncOperation<StoreProductPagedQueryResult*>* operation; hrcheck(X::get()->_GetAssociatedStoreProductsWithPagingAsync(to_abi(productKinds), maxItemsToRetrievePerPage, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreProductQueryResult>>> GetUserCollectionAsync(pptr<Foundation::Collections::IIterable<hstring>> productKinds) { Foundation::IAsyncOperation<StoreProductQueryResult*>* operation; hrcheck(X::get()->_GetUserCollectionAsync(to_abi(productKinds), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreProductPagedQueryResult>>> GetUserCollectionWithPagingAsync(pptr<Foundation::Collections::IIterable<hstring>> productKinds, unsigned maxItemsToRetrievePerPage) { Foundation::IAsyncOperation<StoreProductPagedQueryResult*>* operation; hrcheck(X::get()->_GetUserCollectionWithPagingAsync(to_abi(productKinds), maxItemsToRetrievePerPage, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreConsumableResult>>> ReportConsumableFulfillmentAsync(hstring_ref productStoreId, unsigned quantity, const Platform::Guid& trackingId) { Foundation::IAsyncOperation<StoreConsumableResult*>* operation; hrcheck(X::get()->_ReportConsumableFulfillmentAsync(productStoreId, quantity, trackingId, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreConsumableResult>>> GetConsumableBalanceRemainingAsync(hstring_ref productStoreId) { Foundation::IAsyncOperation<StoreConsumableResult*>* operation; hrcheck(X::get()->_GetConsumableBalanceRemainingAsync(productStoreId, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StoreAcquireLicenseResult>>> AcquireStoreLicenseForOptionalPackageAsync(pptr<ApplicationModel::Package> optionalPackage) { Foundation::IAsyncOperation<StoreAcquireLicenseResult*>* operation; hrcheck(X::get()->_AcquireStoreLicenseForOptionalPackageAsync(optionalPackage, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorePurchaseResult>>> RequestPurchaseAsync(hstring_ref storeId) { Foundation::IAsyncOperation<StorePurchaseResult*>* operation; hrcheck(X::get()->_RequestPurchaseAsync(storeId, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorePurchaseResult>>> RequestPurchaseAsync(hstring_ref storeId, pptr<StorePurchaseProperties> storePurchaseProperties) { Foundation::IAsyncOperation<StorePurchaseResult*>* operation; hrcheck(X::get()->_RequestPurchaseWithPurchasePropertiesAsync(storeId, storePurchaseProperties, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<StorePackageUpdate>>>>> GetAppAndOptionalStorePackageUpdatesAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorePackageUpdate*>*>* operation; hrcheck(X::get()->_GetAppAndOptionalStorePackageUpdatesAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<StorePackageUpdateResult>, StorePackageUpdateStatus>> RequestDownloadStorePackageUpdatesAsync(pptr<Foundation::Collections::IIterable<ptr<StorePackageUpdate>>> storePackageUpdates) { Foundation::IAsyncOperationWithProgress<StorePackageUpdateResult*, StorePackageUpdateStatus>* operation; hrcheck(X::get()->_RequestDownloadStorePackageUpdatesAsync(to_abi(storePackageUpdates), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<StorePackageUpdateResult>, StorePackageUpdateStatus>> RequestDownloadAndInstallStorePackageUpdatesAsync(pptr<Foundation::Collections::IIterable<ptr<StorePackageUpdate>>> storePackageUpdates) { Foundation::IAsyncOperationWithProgress<StorePackageUpdateResult*, StorePackageUpdateStatus>* operation; hrcheck(X::get()->_RequestDownloadAndInstallStorePackageUpdatesAsync(to_abi(storePackageUpdates), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<StorePackageUpdateResult>, StorePackageUpdateStatus>> RequestDownloadAndInstallStorePackagesAsync(pptr<Foundation::Collections::IIterable<hstring>> storeIds) { Foundation::IAsyncOperationWithProgress<StorePackageUpdateResult*, StorePackageUpdateStatus>* operation; hrcheck(X::get()->_RequestDownloadAndInstallStorePackagesAsync(to_abi(storeIds), &operation)); return from_abi(operation); }
	IStoreContext_adaptor() {}
};
template<typename X> struct adapt<IStoreContext, X> : Windows::Services::Store::IStoreContext_adaptor<X> { typedef adapt IStoreContext; };
struct IStoreContext : IStoreContext_raw, generate<IStoreContext> {};

// StoreContext
template<typename> struct StoreContext_statics {
	static ptr<StoreContext> GetDefault() { StoreContext* value; hrcheck(get_activation_factory<StoreContext, IStoreContextStatics>()->_GetDefault(&value)); return from_abi(value); }
	static ptr<StoreContext> GetForUser(pptr<System::User> user) { StoreContext* value; hrcheck(get_activation_factory<StoreContext, IStoreContextStatics>()->_GetForUser(user, &value)); return from_abi(value); }
};

template<typename X> struct statics<StoreContext, X> : X, Windows::Services::Store::StoreContext_statics<void> {
	typedef typename X::root_type StoreContext;
};
struct StoreContext : generate<StoreContext> {
	using IStoreContext::RequestDownloadAndInstallStorePackagesAsync;
	using IStoreContext3::RequestDownloadAndInstallStorePackagesAsync;
	using IStoreContext::GetStoreProductsAsync;
	using IStoreContext3::GetStoreProductsAsync;
	using IStoreContext::RequestPurchaseAsync;
};

// IStoreRequestHelperStatics
struct IStoreRequestHelperStatics : IInspectable {
	virtual STDMETHODIMP _SendRequestAsync(StoreContext* context, unsigned requestKind, HSTRING parametersAsJson, Foundation::IAsyncOperation<StoreSendRequestResult*>* *operation);
};

// StoreSendRequestResult
template<typename X> struct statics<StoreSendRequestResult, X> : X {
	typedef typename X::root_type StoreSendRequestResult;
};
struct StoreSendRequestResult : generate<StoreSendRequestResult> {};

// StoreAppLicense
template<typename X> struct statics<StoreAppLicense, X> : X {
	typedef typename X::root_type StoreAppLicense;
};
struct StoreAppLicense : generate<StoreAppLicense> {};

// StoreProductResult
template<typename X> struct statics<StoreProductResult, X> : X {
	typedef typename X::root_type StoreProductResult;
};
struct StoreProductResult : generate<StoreProductResult> {};

// StoreProductQueryResult
template<typename X> struct statics<StoreProductQueryResult, X> : X {
	typedef typename X::root_type StoreProductQueryResult;
};
struct StoreProductQueryResult : generate<StoreProductQueryResult> {};

// StoreConsumableResult
template<typename X> struct statics<StoreConsumableResult, X> : X {
	typedef typename X::root_type StoreConsumableResult;
};
struct StoreConsumableResult : generate<StoreConsumableResult> {};

// IStoreAcquireLicenseResult
struct IStoreAcquireLicenseResult_raw : IInspectable {
	virtual STDMETHODIMP _get_StorePackageLicense(Store::StorePackageLicense* *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IStoreAcquireLicenseResult_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IStoreAcquireLicenseResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			ptr<Store::StorePackageLicense> get() { Store::StorePackageLicense* value; hrcheck(enc(&IStoreAcquireLicenseResult_adaptor::StorePackageLicense)->_get_StorePackageLicense(&value)); return from_abi(value); }
			ptr<Store::StorePackageLicense> operator()() { return get(); }
			operator ptr<Store::StorePackageLicense> () { return get(); }
			ptr<Store::StorePackageLicense> operator->() { return get(); }
		} StorePackageLicense;
	};
	IStoreAcquireLicenseResult_adaptor() {}
};
template<typename X> struct adapt<IStoreAcquireLicenseResult, X> : Windows::Services::Store::IStoreAcquireLicenseResult_adaptor<X> { typedef adapt IStoreAcquireLicenseResult; };
struct IStoreAcquireLicenseResult : IStoreAcquireLicenseResult_raw, generate<IStoreAcquireLicenseResult> {};

// StoreAcquireLicenseResult
template<typename X> struct statics<StoreAcquireLicenseResult, X> : X {
	typedef typename X::root_type StoreAcquireLicenseResult;
};
struct StoreAcquireLicenseResult : generate<StoreAcquireLicenseResult> {};

// IStorePackageUpdate
struct IStorePackageUpdate_raw : IInspectable {
	virtual STDMETHODIMP _get_Package(ApplicationModel::Package* *value);
	virtual STDMETHODIMP _get_Mandatory(bool *value);
};
template<typename X> struct IStorePackageUpdate_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStorePackageUpdate_adaptor::Mandatory)->_get_Mandatory(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Mandatory;
		struct : property {
			ptr<ApplicationModel::Package> get() { ApplicationModel::Package* value; hrcheck(enc(&IStorePackageUpdate_adaptor::Package)->_get_Package(&value)); return from_abi(value); }
			ptr<ApplicationModel::Package> operator()() { return get(); }
			operator ptr<ApplicationModel::Package> () { return get(); }
			ptr<ApplicationModel::Package> operator->() { return get(); }
		} Package;
	};
	IStorePackageUpdate_adaptor() {}
};
template<typename X> struct adapt<IStorePackageUpdate, X> : Windows::Services::Store::IStorePackageUpdate_adaptor<X> { typedef adapt IStorePackageUpdate; };
struct IStorePackageUpdate : IStorePackageUpdate_raw, generate<IStorePackageUpdate> {};

// StorePackageUpdate
template<typename X> struct statics<StorePackageUpdate, X> : X {
	typedef typename X::root_type StorePackageUpdate;
};
struct StorePackageUpdate : generate<StorePackageUpdate> {};

// IStorePackageUpdateResult2
struct IStorePackageUpdateResult2_raw : IInspectable {
	virtual STDMETHODIMP _get_StoreQueueItems(Foundation::Collections::IVectorView<StoreQueueItem*>* *value);
};
template<typename X> struct IStorePackageUpdateResult2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<StoreQueueItem>>> get() { Foundation::Collections::IVectorView<StoreQueueItem*>* value; hrcheck(enc(&IStorePackageUpdateResult2_adaptor::StoreQueueItems)->_get_StoreQueueItems(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<StoreQueueItem>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<StoreQueueItem>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<StoreQueueItem>>> operator->() { return get(); }
		} StoreQueueItems;
	};
	IStorePackageUpdateResult2_adaptor() {}
};
template<typename X> struct adapt<IStorePackageUpdateResult2, X> : Windows::Services::Store::IStorePackageUpdateResult2_adaptor<X> { typedef adapt IStorePackageUpdateResult2; };
struct IStorePackageUpdateResult2 : IStorePackageUpdateResult2_raw, generate<IStorePackageUpdateResult2> {};

// IStorePackageUpdateResult
struct IStorePackageUpdateResult_raw : IInspectable {
	virtual STDMETHODIMP _get_OverallState(StorePackageUpdateState *value);
	virtual STDMETHODIMP _get_StorePackageUpdateStatuses(Foundation::Collections::IVectorView<StorePackageUpdateStatus>* *value);
};
template<typename X> struct IStorePackageUpdateResult_adaptor : X {
	union {
		struct : property {
			StorePackageUpdateState get() { StorePackageUpdateState value; hrcheck(enc(&IStorePackageUpdateResult_adaptor::OverallState)->_get_OverallState(&value)); return value; }
			StorePackageUpdateState operator()() { return get(); }
			operator StorePackageUpdateState () { return get(); }
		} OverallState;
		struct : property {
			ptr<Foundation::Collections::IVectorView<StorePackageUpdateStatus>> get() { Foundation::Collections::IVectorView<StorePackageUpdateStatus>* value; hrcheck(enc(&IStorePackageUpdateResult_adaptor::StorePackageUpdateStatuses)->_get_StorePackageUpdateStatuses(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<StorePackageUpdateStatus>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<StorePackageUpdateStatus>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<StorePackageUpdateStatus>> operator->() { return get(); }
		} StorePackageUpdateStatuses;
	};
	IStorePackageUpdateResult_adaptor() {}
};
template<typename X> struct adapt<IStorePackageUpdateResult, X> : Windows::Services::Store::IStorePackageUpdateResult_adaptor<X> { typedef adapt IStorePackageUpdateResult; };
struct IStorePackageUpdateResult : IStorePackageUpdateResult_raw, generate<IStorePackageUpdateResult> {};

// StorePackageUpdateResult
template<typename X> struct statics<StorePackageUpdateResult, X> : X {
	typedef typename X::root_type StorePackageUpdateResult;
};
struct StorePackageUpdateResult : generate<StorePackageUpdateResult> {};

// IStoreCanAcquireLicenseResult
struct IStoreCanAcquireLicenseResult_raw : IInspectable {
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
	virtual STDMETHODIMP _get_LicensableSku(HSTRING *value);
	virtual STDMETHODIMP _get_Status(StoreCanLicenseStatus *value);
};
template<typename X> struct IStoreCanAcquireLicenseResult_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IStoreCanAcquireLicenseResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreCanAcquireLicenseResult_adaptor::LicensableSku)->_get_LicensableSku(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} LicensableSku;
		struct : property {
			StoreCanLicenseStatus get() { StoreCanLicenseStatus value; hrcheck(enc(&IStoreCanAcquireLicenseResult_adaptor::Status)->_get_Status(&value)); return value; }
			StoreCanLicenseStatus operator()() { return get(); }
			operator StoreCanLicenseStatus () { return get(); }
		} Status;
	};
	IStoreCanAcquireLicenseResult_adaptor() {}
};
template<typename X> struct adapt<IStoreCanAcquireLicenseResult, X> : Windows::Services::Store::IStoreCanAcquireLicenseResult_adaptor<X> { typedef adapt IStoreCanAcquireLicenseResult; };
struct IStoreCanAcquireLicenseResult : IStoreCanAcquireLicenseResult_raw, generate<IStoreCanAcquireLicenseResult> {};

// StoreCanAcquireLicenseResult
template<typename X> struct statics<StoreCanAcquireLicenseResult, X> : X {
	typedef typename X::root_type StoreCanAcquireLicenseResult;
};
struct StoreCanAcquireLicenseResult : generate<StoreCanAcquireLicenseResult> {};

// IStoreProductOptions
struct IStoreProductOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_ActionFilters(Foundation::Collections::IVector<HSTRING>* *value);
};
template<typename X> struct IStoreProductOptions_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IStoreProductOptions_adaptor::ActionFilters)->_get_ActionFilters(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} ActionFilters;
	};
	IStoreProductOptions_adaptor() {}
};
template<typename X> struct adapt<IStoreProductOptions, X> : Windows::Services::Store::IStoreProductOptions_adaptor<X> { typedef adapt IStoreProductOptions; };
struct IStoreProductOptions : IStoreProductOptions_raw, generate<IStoreProductOptions> {};

// StoreProductOptions
template<typename X> struct statics<StoreProductOptions, X> : X {
	typedef typename X::root_type StoreProductOptions;
};
struct StoreProductOptions : generate<StoreProductOptions> {};

// IStoreQueueItem
struct IStoreQueueItem_raw : IInspectable {
	virtual STDMETHODIMP _get_ProductId(HSTRING *value);
	virtual STDMETHODIMP _get_PackageFamilyName(HSTRING *value);
	virtual STDMETHODIMP _get_InstallKind(StoreQueueItemKind *value);
	virtual STDMETHODIMP _GetCurrentStatus(StoreQueueItemStatus* *result);
	virtual STDMETHODIMP _add_Completed(Foundation::TypedEventHandler<StoreQueueItem*, StoreQueueItemCompletedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Completed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_StatusChanged(Foundation::TypedEventHandler<StoreQueueItem*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_StatusChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IStoreQueueItem_adaptor : X {
	union {
		struct : property {
			StoreQueueItemKind get() { StoreQueueItemKind value; hrcheck(enc(&IStoreQueueItem_adaptor::InstallKind)->_get_InstallKind(&value)); return value; }
			StoreQueueItemKind operator()() { return get(); }
			operator StoreQueueItemKind () { return get(); }
		} InstallKind;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreQueueItem_adaptor::PackageFamilyName)->_get_PackageFamilyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PackageFamilyName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStoreQueueItem_adaptor::ProductId)->_get_ProductId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ProductId;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<StoreQueueItem>, ptr<StoreQueueItemCompletedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IStoreQueueItem_adaptor::Completed)->_add_Completed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IStoreQueueItem_adaptor::Completed)->_remove_Completed(token)); }
		} Completed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<StoreQueueItem>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IStoreQueueItem_adaptor::StatusChanged)->_add_StatusChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IStoreQueueItem_adaptor::StatusChanged)->_remove_StatusChanged(token)); }
		} StatusChanged;
	};
	ptr<StoreQueueItemStatus> GetCurrentStatus() { StoreQueueItemStatus* result; hrcheck(X::get()->_GetCurrentStatus(&result)); return from_abi(result); }
	IStoreQueueItem_adaptor() {}
};
template<typename X> struct adapt<IStoreQueueItem, X> : Windows::Services::Store::IStoreQueueItem_adaptor<X> { typedef adapt IStoreQueueItem; };
struct IStoreQueueItem : IStoreQueueItem_raw, generate<IStoreQueueItem> {};

// StoreQueueItem
template<typename X> struct statics<StoreQueueItem, X> : X {
	typedef typename X::root_type StoreQueueItem;
};
struct StoreQueueItem : generate<StoreQueueItem> {};

// IStorePackageInstallOptions
struct IStorePackageInstallOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_AllowForcedAppRestart(bool *value);
	virtual STDMETHODIMP _put_AllowForcedAppRestart(bool value);
};
template<typename X> struct IStorePackageInstallOptions_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStorePackageInstallOptions_adaptor::AllowForcedAppRestart)->_get_AllowForcedAppRestart(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IStorePackageInstallOptions_adaptor::AllowForcedAppRestart)->_put_AllowForcedAppRestart(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AllowForcedAppRestart;
	};
	IStorePackageInstallOptions_adaptor() {}
};
template<typename X> struct adapt<IStorePackageInstallOptions, X> : Windows::Services::Store::IStorePackageInstallOptions_adaptor<X> { typedef adapt IStorePackageInstallOptions; };
struct IStorePackageInstallOptions : IStorePackageInstallOptions_raw, generate<IStorePackageInstallOptions> {};

// StorePackageInstallOptions
template<typename X> struct statics<StorePackageInstallOptions, X> : X {
	typedef typename X::root_type StorePackageInstallOptions;
};
struct StorePackageInstallOptions : generate<StorePackageInstallOptions> {};

// IStoreUninstallStorePackageResult
struct IStoreUninstallStorePackageResult_raw : IInspectable {
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
	virtual STDMETHODIMP _get_Status(StoreUninstallStorePackageStatus *value);
};
template<typename X> struct IStoreUninstallStorePackageResult_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IStoreUninstallStorePackageResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			StoreUninstallStorePackageStatus get() { StoreUninstallStorePackageStatus value; hrcheck(enc(&IStoreUninstallStorePackageResult_adaptor::Status)->_get_Status(&value)); return value; }
			StoreUninstallStorePackageStatus operator()() { return get(); }
			operator StoreUninstallStorePackageStatus () { return get(); }
		} Status;
	};
	IStoreUninstallStorePackageResult_adaptor() {}
};
template<typename X> struct adapt<IStoreUninstallStorePackageResult, X> : Windows::Services::Store::IStoreUninstallStorePackageResult_adaptor<X> { typedef adapt IStoreUninstallStorePackageResult; };
struct IStoreUninstallStorePackageResult : IStoreUninstallStorePackageResult_raw, generate<IStoreUninstallStorePackageResult> {};

// StoreUninstallStorePackageResult
template<typename X> struct statics<StoreUninstallStorePackageResult, X> : X {
	typedef typename X::root_type StoreUninstallStorePackageResult;
};
struct StoreUninstallStorePackageResult : generate<StoreUninstallStorePackageResult> {};

// IStoreQueueItemStatus
struct IStoreQueueItemStatus_raw : IInspectable {
	virtual STDMETHODIMP _get_PackageInstallState(StoreQueueItemState *value);
	virtual STDMETHODIMP _get_PackageInstallExtendedState(StoreQueueItemExtendedState *value);
	virtual STDMETHODIMP _get_UpdateStatus(StorePackageUpdateStatus *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IStoreQueueItemStatus_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IStoreQueueItemStatus_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			StoreQueueItemExtendedState get() { StoreQueueItemExtendedState value; hrcheck(enc(&IStoreQueueItemStatus_adaptor::PackageInstallExtendedState)->_get_PackageInstallExtendedState(&value)); return value; }
			StoreQueueItemExtendedState operator()() { return get(); }
			operator StoreQueueItemExtendedState () { return get(); }
		} PackageInstallExtendedState;
		struct : property {
			StoreQueueItemState get() { StoreQueueItemState value; hrcheck(enc(&IStoreQueueItemStatus_adaptor::PackageInstallState)->_get_PackageInstallState(&value)); return value; }
			StoreQueueItemState operator()() { return get(); }
			operator StoreQueueItemState () { return get(); }
		} PackageInstallState;
		struct : property {
			StorePackageUpdateStatus get() { StorePackageUpdateStatus value; hrcheck(enc(&IStoreQueueItemStatus_adaptor::UpdateStatus)->_get_UpdateStatus(&value)); return value; }
			StorePackageUpdateStatus operator()() { return get(); }
			operator StorePackageUpdateStatus () { return get(); }
		} UpdateStatus;
	};
	IStoreQueueItemStatus_adaptor() {}
};
template<typename X> struct adapt<IStoreQueueItemStatus, X> : Windows::Services::Store::IStoreQueueItemStatus_adaptor<X> { typedef adapt IStoreQueueItemStatus; };
struct IStoreQueueItemStatus : IStoreQueueItemStatus_raw, generate<IStoreQueueItemStatus> {};

// StoreQueueItemStatus
template<typename X> struct statics<StoreQueueItemStatus, X> : X {
	typedef typename X::root_type StoreQueueItemStatus;
};
struct StoreQueueItemStatus : generate<StoreQueueItemStatus> {};

// IStoreQueueItemCompletedEventArgs
struct IStoreQueueItemCompletedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(StoreQueueItemStatus* *value);
};
template<typename X> struct IStoreQueueItemCompletedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<StoreQueueItemStatus> get() { StoreQueueItemStatus* value; hrcheck(enc(&IStoreQueueItemCompletedEventArgs_adaptor::Status)->_get_Status(&value)); return from_abi(value); }
			ptr<StoreQueueItemStatus> operator()() { return get(); }
			operator ptr<StoreQueueItemStatus> () { return get(); }
			ptr<StoreQueueItemStatus> operator->() { return get(); }
		} Status;
	};
	IStoreQueueItemCompletedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IStoreQueueItemCompletedEventArgs, X> : Windows::Services::Store::IStoreQueueItemCompletedEventArgs_adaptor<X> { typedef adapt IStoreQueueItemCompletedEventArgs; };
struct IStoreQueueItemCompletedEventArgs : IStoreQueueItemCompletedEventArgs_raw, generate<IStoreQueueItemCompletedEventArgs> {};

// StoreQueueItemCompletedEventArgs
template<typename X> struct statics<StoreQueueItemCompletedEventArgs, X> : X {
	typedef typename X::root_type StoreQueueItemCompletedEventArgs;
};
struct StoreQueueItemCompletedEventArgs : generate<StoreQueueItemCompletedEventArgs> {};

// IStorePackageLicense
struct IStorePackageLicense_raw : IInspectable {
	virtual STDMETHODIMP _add_LicenseLost(Foundation::TypedEventHandler<StorePackageLicense*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_LicenseLost(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_Package(ApplicationModel::Package* *value);
	virtual STDMETHODIMP _get_IsValid(bool *value);
	virtual STDMETHODIMP _ReleaseLicense();
};
template<typename X> struct IStorePackageLicense_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStorePackageLicense_adaptor::IsValid)->_get_IsValid(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsValid;
		struct : property {
			ptr<ApplicationModel::Package> get() { ApplicationModel::Package* value; hrcheck(enc(&IStorePackageLicense_adaptor::Package)->_get_Package(&value)); return from_abi(value); }
			ptr<ApplicationModel::Package> operator()() { return get(); }
			operator ptr<ApplicationModel::Package> () { return get(); }
			ptr<ApplicationModel::Package> operator->() { return get(); }
		} Package;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<StorePackageLicense>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IStorePackageLicense_adaptor::LicenseLost)->_add_LicenseLost(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IStorePackageLicense_adaptor::LicenseLost)->_remove_LicenseLost(token)); }
		} LicenseLost;
	};
	void ReleaseLicense() { hrcheck(X::get()->_ReleaseLicense()); }
	IStorePackageLicense_adaptor() {}
};
template<typename X> struct adapt<IStorePackageLicense, X> : Windows::Services::Store::IStorePackageLicense_adaptor<X> { typedef adapt IStorePackageLicense; };
struct IStorePackageLicense : IStorePackageLicense_raw, generate<IStorePackageLicense> {};

// StorePackageLicense
template<typename X> struct statics<StorePackageLicense, X> : X {
	typedef typename X::root_type StorePackageLicense;
};
struct StorePackageLicense : generate<StorePackageLicense> {};

// StoreRequestHelper
template<typename> struct StoreRequestHelper_statics {
	static ptr<Foundation::IAsyncOperation<ptr<StoreSendRequestResult>>> SendRequestAsync(pptr<StoreContext> context, unsigned requestKind, hstring_ref parametersAsJson) { Foundation::IAsyncOperation<StoreSendRequestResult*>* operation; hrcheck(get_activation_factory<StoreRequestHelper, IStoreRequestHelperStatics>()->_SendRequestAsync(context, requestKind, parametersAsJson, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<StoreRequestHelper, X> : X, Windows::Services::Store::StoreRequestHelper_statics<void> {
	typedef typename X::root_type StoreRequestHelper;
};
struct StoreRequestHelper : generate<StoreRequestHelper> {};
}}}
} // namespace iso_winrt
