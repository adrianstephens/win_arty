#pragma once
// generated by isopod tools
// namespaces:
// Windows.System.Diagnostics.TraceReporting

#include "Windows.System.Diagnostics.TraceReporting.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename K, typename V> struct IMapView;
template<typename T> struct IVectorView;
}}}

// defs

template<> struct def<Windows::System::Diagnostics::TraceReporting::PlatformDiagnosticEscalationType> : enum_type<int> {};
template<> struct def<Windows::System::Diagnostics::TraceReporting::PlatformDiagnosticTraceSlotType> : enum_type<int> {};
template<> struct def<Windows::System::Diagnostics::TraceReporting::PlatformDiagnosticTracePriority> : enum_type<int> {};
template<> struct def<Windows::System::Diagnostics::TraceReporting::PlatformDiagnosticTraceSlotState> : enum_type<int> {};
template<> struct def<Windows::System::Diagnostics::TraceReporting::PlatformDiagnosticActionState> : enum_type<int> {};
template<> struct def<Windows::System::Diagnostics::TraceReporting::PlatformDiagnosticEventBufferLatencies> : enum_type<unsigned> {};
template<> struct def<Windows::System::Diagnostics::TraceReporting::IPlatformDiagnosticTraceInfo> : interface_type<> {};
template<> struct def<Windows::System::Diagnostics::TraceReporting::IPlatformDiagnosticTraceRuntimeInfo> : interface_type<> {};
template<> struct def<Windows::System::Diagnostics::TraceReporting::PlatformDiagnosticTraceInfo> : class_type<Platform::Object, Windows::System::Diagnostics::TraceReporting::IPlatformDiagnosticTraceInfo> {};
template<> struct def<Windows::System::Diagnostics::TraceReporting::PlatformDiagnosticTraceRuntimeInfo> : class_type<Platform::Object, Windows::System::Diagnostics::TraceReporting::IPlatformDiagnosticTraceRuntimeInfo> {};
template<> struct def<Windows::System::Diagnostics::TraceReporting::IPlatformDiagnosticActionsStatics> : interface_type<> {};
template<> struct def<Windows::System::Diagnostics::TraceReporting::PlatformDiagnosticActions> : class_type<Platform::Object, Platform::Object> {};

// uuids

template<> struct uuid<Windows::System::Diagnostics::TraceReporting::IPlatformDiagnosticTraceInfo> { define_guid(0xF870ED97, 0xD597, 0x4BF7, 0x88, 0xDC, 0xCF, 0x5C, 0x7D, 0xC2, 0xA1, 0xD2);};
template<> struct uuid<Windows::System::Diagnostics::TraceReporting::IPlatformDiagnosticTraceRuntimeInfo> { define_guid(0x3D4D5E2D, 0x1D8, 0x4768, 0x85, 0x54, 0x1E, 0xB1, 0xCA, 0x61, 0x9, 0x86);};
template<> struct uuid<Windows::System::Diagnostics::TraceReporting::IPlatformDiagnosticActionsStatics> { define_guid(0xC1145CFA, 0x9292, 0x4267, 0x89, 0xA, 0x9E, 0xA3, 0xED, 0x7, 0x23, 0x12);};

// types

namespace Windows { namespace System { namespace Diagnostics { namespace TraceReporting {

// IPlatformDiagnosticTraceInfo
struct IPlatformDiagnosticTraceInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_ScenarioId(Platform::Guid *value);
	virtual STDMETHODIMP _get_ProfileHash(unsigned __int64 *value);
	virtual STDMETHODIMP _get_IsExclusive(bool *value);
	virtual STDMETHODIMP _get_IsAutoLogger(bool *value);
	virtual STDMETHODIMP _get_MaxTraceDurationFileTime(__int64 *value);
	virtual STDMETHODIMP _get_Priority(PlatformDiagnosticTracePriority *value);
};
template<typename X> struct IPlatformDiagnosticTraceInfo_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPlatformDiagnosticTraceInfo_adaptor::IsAutoLogger)->_get_IsAutoLogger(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsAutoLogger;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPlatformDiagnosticTraceInfo_adaptor::IsExclusive)->_get_IsExclusive(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsExclusive;
		struct : property {
			__int64 get() { __int64 value; hrcheck(enc(&IPlatformDiagnosticTraceInfo_adaptor::MaxTraceDurationFileTime)->_get_MaxTraceDurationFileTime(&value)); return value; }
			__int64 operator()() { return get(); }
			operator __int64 () { return get(); }
		} MaxTraceDurationFileTime;
		struct : property {
			PlatformDiagnosticTracePriority get() { PlatformDiagnosticTracePriority value; hrcheck(enc(&IPlatformDiagnosticTraceInfo_adaptor::Priority)->_get_Priority(&value)); return value; }
			PlatformDiagnosticTracePriority operator()() { return get(); }
			operator PlatformDiagnosticTracePriority () { return get(); }
		} Priority;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IPlatformDiagnosticTraceInfo_adaptor::ProfileHash)->_get_ProfileHash(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} ProfileHash;
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPlatformDiagnosticTraceInfo_adaptor::ScenarioId)->_get_ScenarioId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} ScenarioId;
	};
	IPlatformDiagnosticTraceInfo_adaptor() {}
};
template<typename X> struct adapt<IPlatformDiagnosticTraceInfo, X> : Windows::System::Diagnostics::TraceReporting::IPlatformDiagnosticTraceInfo_adaptor<X> { typedef adapt IPlatformDiagnosticTraceInfo; };
struct IPlatformDiagnosticTraceInfo : IPlatformDiagnosticTraceInfo_raw, generate<IPlatformDiagnosticTraceInfo> {};

// IPlatformDiagnosticTraceRuntimeInfo
struct IPlatformDiagnosticTraceRuntimeInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_RuntimeFileTime(__int64 *value);
	virtual STDMETHODIMP _get_EtwRuntimeFileTime(__int64 *value);
};
template<typename X> struct IPlatformDiagnosticTraceRuntimeInfo_adaptor : X {
	union {
		struct : property {
			__int64 get() { __int64 value; hrcheck(enc(&IPlatformDiagnosticTraceRuntimeInfo_adaptor::EtwRuntimeFileTime)->_get_EtwRuntimeFileTime(&value)); return value; }
			__int64 operator()() { return get(); }
			operator __int64 () { return get(); }
		} EtwRuntimeFileTime;
		struct : property {
			__int64 get() { __int64 value; hrcheck(enc(&IPlatformDiagnosticTraceRuntimeInfo_adaptor::RuntimeFileTime)->_get_RuntimeFileTime(&value)); return value; }
			__int64 operator()() { return get(); }
			operator __int64 () { return get(); }
		} RuntimeFileTime;
	};
	IPlatformDiagnosticTraceRuntimeInfo_adaptor() {}
};
template<typename X> struct adapt<IPlatformDiagnosticTraceRuntimeInfo, X> : Windows::System::Diagnostics::TraceReporting::IPlatformDiagnosticTraceRuntimeInfo_adaptor<X> { typedef adapt IPlatformDiagnosticTraceRuntimeInfo; };
struct IPlatformDiagnosticTraceRuntimeInfo : IPlatformDiagnosticTraceRuntimeInfo_raw, generate<IPlatformDiagnosticTraceRuntimeInfo> {};

// PlatformDiagnosticTraceInfo
template<typename X> struct statics<PlatformDiagnosticTraceInfo, X> : X {
	typedef typename X::root_type PlatformDiagnosticTraceInfo;
};
struct PlatformDiagnosticTraceInfo : generate<PlatformDiagnosticTraceInfo> {};

// PlatformDiagnosticTraceRuntimeInfo
template<typename X> struct statics<PlatformDiagnosticTraceRuntimeInfo, X> : X {
	typedef typename X::root_type PlatformDiagnosticTraceRuntimeInfo;
};
struct PlatformDiagnosticTraceRuntimeInfo : generate<PlatformDiagnosticTraceRuntimeInfo> {};

// IPlatformDiagnosticActionsStatics
struct IPlatformDiagnosticActionsStatics : IInspectable {
	virtual STDMETHODIMP _IsScenarioEnabled(Platform::Guid scenarioId, bool *isActive);
	virtual STDMETHODIMP _TryEscalateScenario(Platform::Guid scenarioId, PlatformDiagnosticEscalationType escalationType, HSTRING outputDirectory, bool timestampOutputDirectory, bool forceEscalationUpload, Foundation::Collections::IMapView<HSTRING, HSTRING>* triggers, bool *result);
	virtual STDMETHODIMP _DownloadLatestSettingsForNamespace(HSTRING partner, HSTRING feature, bool isScenarioNamespace, bool downloadOverCostedNetwork, bool downloadOverBattery, PlatformDiagnosticActionState *result);
	virtual STDMETHODIMP _GetActiveScenarioList(Foundation::Collections::IVectorView<Platform::Guid>* *scenarioIds);
	virtual STDMETHODIMP _ForceUpload(PlatformDiagnosticEventBufferLatencies latency, bool uploadOverCostedNetwork, bool uploadOverBattery, PlatformDiagnosticActionState *result);
	virtual STDMETHODIMP _IsTraceRunning(PlatformDiagnosticTraceSlotType slotType, Platform::Guid scenarioId, unsigned __int64 traceProfileHash, PlatformDiagnosticTraceSlotState *slotState);
	virtual STDMETHODIMP _GetActiveTraceRuntime(PlatformDiagnosticTraceSlotType slotType, PlatformDiagnosticTraceRuntimeInfo* *traceRuntimeInfo);
	virtual STDMETHODIMP _GetKnownTraceList(PlatformDiagnosticTraceSlotType slotType, Foundation::Collections::IVectorView<PlatformDiagnosticTraceInfo*>* *traceInfo);
};

// PlatformDiagnosticActions
template<typename> struct PlatformDiagnosticActions_statics {
	static bool IsScenarioEnabled(const Platform::Guid& scenarioId) { bool isActive; hrcheck(get_activation_factory<PlatformDiagnosticActions, IPlatformDiagnosticActionsStatics>()->_IsScenarioEnabled(scenarioId, &isActive)); return isActive; }
	static bool TryEscalateScenario(const Platform::Guid& scenarioId, PlatformDiagnosticEscalationType escalationType, hstring_ref outputDirectory, bool timestampOutputDirectory, bool forceEscalationUpload, pptr<Foundation::Collections::IMapView<hstring, hstring>> triggers) { bool result; hrcheck(get_activation_factory<PlatformDiagnosticActions, IPlatformDiagnosticActionsStatics>()->_TryEscalateScenario(scenarioId, escalationType, outputDirectory, timestampOutputDirectory, forceEscalationUpload, to_abi(triggers), &result)); return result; }
	static PlatformDiagnosticActionState DownloadLatestSettingsForNamespace(hstring_ref partner, hstring_ref feature, bool isScenarioNamespace, bool downloadOverCostedNetwork, bool downloadOverBattery) { PlatformDiagnosticActionState result; hrcheck(get_activation_factory<PlatformDiagnosticActions, IPlatformDiagnosticActionsStatics>()->_DownloadLatestSettingsForNamespace(partner, feature, isScenarioNamespace, downloadOverCostedNetwork, downloadOverBattery, &result)); return result; }
	static ptr<Foundation::Collections::IVectorView<Platform::Guid>> GetActiveScenarioList() { Foundation::Collections::IVectorView<Platform::Guid>* scenarioIds; hrcheck(get_activation_factory<PlatformDiagnosticActions, IPlatformDiagnosticActionsStatics>()->_GetActiveScenarioList(&scenarioIds)); return from_abi(scenarioIds); }
	static PlatformDiagnosticActionState ForceUpload(PlatformDiagnosticEventBufferLatencies latency, bool uploadOverCostedNetwork, bool uploadOverBattery) { PlatformDiagnosticActionState result; hrcheck(get_activation_factory<PlatformDiagnosticActions, IPlatformDiagnosticActionsStatics>()->_ForceUpload(latency, uploadOverCostedNetwork, uploadOverBattery, &result)); return result; }
	static PlatformDiagnosticTraceSlotState IsTraceRunning(PlatformDiagnosticTraceSlotType slotType, const Platform::Guid& scenarioId, unsigned __int64 traceProfileHash) { PlatformDiagnosticTraceSlotState slotState; hrcheck(get_activation_factory<PlatformDiagnosticActions, IPlatformDiagnosticActionsStatics>()->_IsTraceRunning(slotType, scenarioId, traceProfileHash, &slotState)); return slotState; }
	static ptr<PlatformDiagnosticTraceRuntimeInfo> GetActiveTraceRuntime(PlatformDiagnosticTraceSlotType slotType) { PlatformDiagnosticTraceRuntimeInfo* traceRuntimeInfo; hrcheck(get_activation_factory<PlatformDiagnosticActions, IPlatformDiagnosticActionsStatics>()->_GetActiveTraceRuntime(slotType, &traceRuntimeInfo)); return from_abi(traceRuntimeInfo); }
	static ptr<Foundation::Collections::IVectorView<ptr<PlatformDiagnosticTraceInfo>>> GetKnownTraceList(PlatformDiagnosticTraceSlotType slotType) { Foundation::Collections::IVectorView<PlatformDiagnosticTraceInfo*>* traceInfo; hrcheck(get_activation_factory<PlatformDiagnosticActions, IPlatformDiagnosticActionsStatics>()->_GetKnownTraceList(slotType, &traceInfo)); return from_abi(traceInfo); }
};

template<typename X> struct statics<PlatformDiagnosticActions, X> : X, Windows::System::Diagnostics::TraceReporting::PlatformDiagnosticActions_statics<void> {
	typedef typename X::root_type PlatformDiagnosticActions;
};
struct PlatformDiagnosticActions : generate<PlatformDiagnosticActions> {};
}}}}
} // namespace iso_winrt
