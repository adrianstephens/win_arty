#pragma once
// generated by isopod tools
// namespaces:
// Windows.Storage.Streams

#include "Windows.Storage.Streams.0.h"
#include "Windows.Storage.0.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace System {
struct User;
}}

// defs

template<> struct def<Windows::Storage::Streams::ByteOrder> : enum_type<int> {};
template<> struct def<Windows::Storage::Streams::UnicodeEncoding> : enum_type<int> {};
template<> struct def<Windows::Storage::Streams::DataReaderLoadOperation> : class_type<Platform::Object, Windows::Foundation::IAsyncOperation<unsigned>, Windows::Foundation::IAsyncInfo> {};
template<> struct def<Windows::Storage::Streams::InputStreamOptions> : enum_type<unsigned> {};
template<> struct def<Windows::Storage::Streams::IDataReader> : overridable_type<> {};
template<> struct def<Windows::Storage::Streams::IDataReaderFactory> : interface_type<> {};
template<> struct def<Windows::Storage::Streams::IDataReaderStatics> : interface_type<> {};
template<> struct def<Windows::Storage::Streams::DataReader> : class_type<Platform::Object, Windows::Storage::Streams::IDataReader, Windows::Foundation::IClosable>, custom_activators {};
template<> struct def<Windows::Storage::Streams::DataWriterStoreOperation> : class_type<Platform::Object, Windows::Foundation::IAsyncOperation<unsigned>, Windows::Foundation::IAsyncInfo> {};
template<> struct def<Windows::Storage::Streams::IDataWriter> : overridable_type<> {};
template<> struct def<Windows::Storage::Streams::IDataWriterFactory> : interface_type<> {};
template<> struct def<Windows::Storage::Streams::DataWriter> : class_type<Platform::Object, Windows::Storage::Streams::IDataWriter, Windows::Foundation::IClosable>, custom_activators {};
template<> struct def<Windows::Storage::Streams::IBufferFactory> : interface_type<> {};
template<> struct def<Windows::Storage::Streams::IBufferStatics> : interface_type<> {};
template<> struct def<Windows::Storage::Streams::IBuffer> : overridable_type<> {};
template<> struct def<Windows::Storage::Streams::Buffer> : class_type<Platform::Object, Windows::Storage::Streams::IBuffer>, custom_activators {};
template<> struct def<Windows::Storage::Streams::IContentTypeProvider> : overridable_type<> {};
template<> struct def<Windows::Storage::Streams::IInputStream> : overridable_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Storage::Streams::IOutputStream> : overridable_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Storage::Streams::IRandomAccessStream> : overridable_type<Windows::Storage::Streams::IOutputStream, Windows::Storage::Streams::IInputStream> {};
template<> struct def<Windows::Storage::Streams::IRandomAccessStreamWithContentType> : overridable_type<Windows::Storage::Streams::IRandomAccessStream, Windows::Storage::Streams::IContentTypeProvider> {};
template<> struct def<Windows::Storage::Streams::IRandomAccessStreamReference> : overridable_type<> {};
template<> struct def<Windows::Storage::Streams::IRandomAccessStreamStatics> : interface_type<> {};
template<> struct def<Windows::Storage::Streams::RandomAccessStream> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Storage::Streams::IInputStreamReference> : overridable_type<> {};
template<> struct def<Windows::Storage::Streams::IRandomAccessStreamReferenceStatics> : interface_type<> {};
template<> struct def<Windows::Storage::Streams::RandomAccessStreamReference> : class_type<Platform::Object, Windows::Storage::Streams::IRandomAccessStreamReference> {};
template<> struct def<Windows::Storage::Streams::FileOpenDisposition> : enum_type<int> {};
template<> struct def<Windows::Storage::Streams::IFileRandomAccessStreamStatics> : interface_type<> {};
template<> struct def<Windows::Storage::Streams::FileRandomAccessStream> : class_type<Platform::Object, Windows::Storage::Streams::IRandomAccessStream> {};
template<> struct def<Windows::Storage::Streams::FileInputStream> : class_type<Platform::Object, Windows::Storage::Streams::IInputStream> {};
template<> struct def<Windows::Storage::Streams::FileOutputStream> : class_type<Platform::Object, Windows::Storage::Streams::IOutputStream> {};
template<> struct def<Windows::Storage::Streams::RandomAccessStreamOverStream> : class_type<Platform::Object, Windows::Storage::Streams::IRandomAccessStream> {};
template<> struct def<Windows::Storage::Streams::InputStreamOverStream> : class_type<Platform::Object, Windows::Storage::Streams::IInputStream> {};
template<> struct def<Windows::Storage::Streams::OutputStreamOverStream> : class_type<Platform::Object, Windows::Storage::Streams::IOutputStream> {};
template<> struct def<Windows::Storage::Streams::InMemoryRandomAccessStream> : class_type<Platform::Object, Windows::Storage::Streams::IRandomAccessStream> {};

// uuids

template<> struct uuid<Windows::Storage::Streams::IDataReader> { define_guid(0xE2B50029, 0xB4C1, 0x4314, 0xA4, 0xB8, 0xFB, 0x81, 0x3A, 0x2F, 0x27, 0x5E);};
template<> struct uuid<Windows::Storage::Streams::IDataReaderFactory> { define_guid(0xD7527847, 0x57DA, 0x4E15, 0x91, 0x4C, 0x6, 0x80, 0x66, 0x99, 0xA0, 0x98);};
template<> struct uuid<Windows::Storage::Streams::IDataReaderStatics> { define_guid(0x11FCBFC8, 0xF93A, 0x471B, 0xB1, 0x21, 0xF3, 0x79, 0xE3, 0x49, 0x31, 0x3C);};
template<> struct uuid<Windows::Storage::Streams::IDataWriter> { define_guid(0x64B89265, 0xD341, 0x4922, 0xB3, 0x8A, 0xDD, 0x4A, 0xF8, 0x80, 0x8C, 0x4E);};
template<> struct uuid<Windows::Storage::Streams::IDataWriterFactory> { define_guid(0x338C67C2, 0x8B84, 0x4C2B, 0x9C, 0x50, 0x7B, 0x87, 0x67, 0x84, 0x7A, 0x1F);};
template<> struct uuid<Windows::Storage::Streams::IBufferFactory> { define_guid(0x71AF914D, 0xC10F, 0x484B, 0xBC, 0x50, 0x14, 0xBC, 0x62, 0x3B, 0x3A, 0x27);};
template<> struct uuid<Windows::Storage::Streams::IBufferStatics> { define_guid(0xE901E65B, 0xD716, 0x475A, 0xA9, 0xA, 0xAF, 0x72, 0x29, 0xB1, 0xE7, 0x41);};
template<> struct uuid<Windows::Storage::Streams::IBuffer> { define_guid(0x905A0FE0, 0xBC53, 0x11DF, 0x8C, 0x49, 0x0, 0x1E, 0x4F, 0xC6, 0x86, 0xDA);};
template<> struct uuid<Windows::Storage::Streams::IContentTypeProvider> { define_guid(0x97D098A5, 0x3B99, 0x4DE9, 0x88, 0xA5, 0xE1, 0x1D, 0x2F, 0x50, 0xC7, 0x95);};
template<> struct uuid<Windows::Storage::Streams::IInputStream> { define_guid(0x905A0FE2, 0xBC53, 0x11DF, 0x8C, 0x49, 0x0, 0x1E, 0x4F, 0xC6, 0x86, 0xDA);};
template<> struct uuid<Windows::Storage::Streams::IOutputStream> { define_guid(0x905A0FE6, 0xBC53, 0x11DF, 0x8C, 0x49, 0x0, 0x1E, 0x4F, 0xC6, 0x86, 0xDA);};
template<> struct uuid<Windows::Storage::Streams::IRandomAccessStream> { define_guid(0x905A0FE1, 0xBC53, 0x11DF, 0x8C, 0x49, 0x0, 0x1E, 0x4F, 0xC6, 0x86, 0xDA);};
template<> struct uuid<Windows::Storage::Streams::IRandomAccessStreamWithContentType> { define_guid(0xCC254827, 0x4B3D, 0x438F, 0x92, 0x32, 0x10, 0xC7, 0x6B, 0xC7, 0xE0, 0x38);};
template<> struct uuid<Windows::Storage::Streams::IRandomAccessStreamReference> { define_guid(0x33EE3134, 0x1DD6, 0x4E3A, 0x80, 0x67, 0xD1, 0xC1, 0x62, 0xE8, 0x64, 0x2B);};
template<> struct uuid<Windows::Storage::Streams::IRandomAccessStreamStatics> { define_guid(0x524CEDCF, 0x6E29, 0x4CE5, 0x95, 0x73, 0x6B, 0x75, 0x3D, 0xB6, 0x6C, 0x3A);};
template<> struct uuid<Windows::Storage::Streams::IInputStreamReference> { define_guid(0x43929D18, 0x5EC9, 0x4B5A, 0x91, 0x9C, 0x42, 0x5, 0xB0, 0xC8, 0x4, 0xB6);};
template<> struct uuid<Windows::Storage::Streams::IRandomAccessStreamReferenceStatics> { define_guid(0x857309DC, 0x3FBF, 0x4E7D, 0x98, 0x6F, 0xEF, 0x3B, 0x1A, 0x7, 0xA9, 0x64);};
template<> struct uuid<Windows::Storage::Streams::IFileRandomAccessStreamStatics> { define_guid(0x73550107, 0x3B57, 0x4B5D, 0x83, 0x45, 0x55, 0x4D, 0x2F, 0xC6, 0x21, 0xF0);};

// types

namespace Windows { namespace Storage { namespace Streams {

// DataReaderLoadOperation
template<typename X> struct statics<DataReaderLoadOperation, X> : X {
	typedef typename X::root_type DataReaderLoadOperation;
};
struct DataReaderLoadOperation : generate<DataReaderLoadOperation> {};

// IDataReader
struct IDataReader_raw : IInspectable {
	virtual STDMETHODIMP _get_UnconsumedBufferLength(unsigned *value) = 0;
	virtual STDMETHODIMP _get_UnicodeEncoding(Streams::UnicodeEncoding *value) = 0;
	virtual STDMETHODIMP _put_UnicodeEncoding(Streams::UnicodeEncoding value) = 0;
	virtual STDMETHODIMP _get_ByteOrder(Streams::ByteOrder *value) = 0;
	virtual STDMETHODIMP _put_ByteOrder(Streams::ByteOrder value) = 0;
	virtual STDMETHODIMP _get_InputStreamOptions(Streams::InputStreamOptions *value) = 0;
	virtual STDMETHODIMP _put_InputStreamOptions(Streams::InputStreamOptions value) = 0;
	virtual STDMETHODIMP _ReadByte(unsigned char *value) = 0;
	virtual STDMETHODIMP _ReadBytes(unsigned valueSize, unsigned char *value) = 0;
	virtual STDMETHODIMP _ReadBuffer(unsigned length, IBuffer* *buffer) = 0;
	virtual STDMETHODIMP _ReadBoolean(bool *value) = 0;
	virtual STDMETHODIMP _ReadGuid(Platform::Guid *value) = 0;
	virtual STDMETHODIMP _ReadInt16(short *value) = 0;
	virtual STDMETHODIMP _ReadInt32(int *value) = 0;
	virtual STDMETHODIMP _ReadInt64(__int64 *value) = 0;
	virtual STDMETHODIMP _ReadUInt16(unsigned short *value) = 0;
	virtual STDMETHODIMP _ReadUInt32(unsigned *value) = 0;
	virtual STDMETHODIMP _ReadUInt64(unsigned __int64 *value) = 0;
	virtual STDMETHODIMP _ReadSingle(float *value) = 0;
	virtual STDMETHODIMP _ReadDouble(double *value) = 0;
	virtual STDMETHODIMP _ReadString(unsigned codeUnitCount, HSTRING *value) = 0;
	virtual STDMETHODIMP _ReadDateTime(Foundation::DateTime *value) = 0;
	virtual STDMETHODIMP _ReadTimeSpan(Foundation::TimeSpan *value) = 0;
	virtual STDMETHODIMP _LoadAsync(unsigned count, DataReaderLoadOperation* *operation) = 0;
	virtual STDMETHODIMP _DetachBuffer(IBuffer* *buffer) = 0;
	virtual STDMETHODIMP _DetachStream(IInputStream* *stream) = 0;
};
template<typename X> struct IDataReader_adaptor : X {
	union {
		struct : property {
			Streams::ByteOrder get() { Streams::ByteOrder value; hrcheck(enc(&IDataReader_adaptor::ByteOrder)->_get_ByteOrder(&value)); return value; }
			Streams::ByteOrder operator()() { return get(); }
			operator Streams::ByteOrder () { return get(); }
			void put(Streams::ByteOrder value) { hrcheck(enc(&IDataReader_adaptor::ByteOrder)->_put_ByteOrder(value)); }
			void operator=(Streams::ByteOrder value) { put(value); }
			void operator()(Streams::ByteOrder value) { put(value); }
		} ByteOrder;
		struct : property {
			Streams::InputStreamOptions get() { Streams::InputStreamOptions value; hrcheck(enc(&IDataReader_adaptor::InputStreamOptions)->_get_InputStreamOptions(&value)); return value; }
			Streams::InputStreamOptions operator()() { return get(); }
			operator Streams::InputStreamOptions () { return get(); }
			void put(Streams::InputStreamOptions value) { hrcheck(enc(&IDataReader_adaptor::InputStreamOptions)->_put_InputStreamOptions(value)); }
			void operator=(Streams::InputStreamOptions value) { put(value); }
			void operator()(Streams::InputStreamOptions value) { put(value); }
		} InputStreamOptions;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IDataReader_adaptor::UnconsumedBufferLength)->_get_UnconsumedBufferLength(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} UnconsumedBufferLength;
		struct : property {
			Streams::UnicodeEncoding get() { Streams::UnicodeEncoding value; hrcheck(enc(&IDataReader_adaptor::UnicodeEncoding)->_get_UnicodeEncoding(&value)); return value; }
			Streams::UnicodeEncoding operator()() { return get(); }
			operator Streams::UnicodeEncoding () { return get(); }
			void put(Streams::UnicodeEncoding value) { hrcheck(enc(&IDataReader_adaptor::UnicodeEncoding)->_put_UnicodeEncoding(value)); }
			void operator=(Streams::UnicodeEncoding value) { put(value); }
			void operator()(Streams::UnicodeEncoding value) { put(value); }
		} UnicodeEncoding;
	};
	unsigned char ReadByte() { unsigned char value; hrcheck(X::get()->_ReadByte(&value)); return value; }
	void ReadBytes(const szarray<unsigned char>& value) { hrcheck(X::get()->_ReadBytes(value.size, to_abi(value.p))); }
	ptr<IBuffer> ReadBuffer(unsigned length) { IBuffer* buffer; hrcheck(X::get()->_ReadBuffer(length, &buffer)); return from_abi(buffer); }
	bool ReadBoolean() { bool value; hrcheck(X::get()->_ReadBoolean(&value)); return value; }
	Platform::Guid ReadGuid() { Platform::Guid value; hrcheck(X::get()->_ReadGuid(&value)); return value; }
	short ReadInt16() { short value; hrcheck(X::get()->_ReadInt16(&value)); return value; }
	int ReadInt32() { int value; hrcheck(X::get()->_ReadInt32(&value)); return value; }
	__int64 ReadInt64() { __int64 value; hrcheck(X::get()->_ReadInt64(&value)); return value; }
	unsigned short ReadUInt16() { unsigned short value; hrcheck(X::get()->_ReadUInt16(&value)); return value; }
	unsigned ReadUInt32() { unsigned value; hrcheck(X::get()->_ReadUInt32(&value)); return value; }
	unsigned __int64 ReadUInt64() { unsigned __int64 value; hrcheck(X::get()->_ReadUInt64(&value)); return value; }
	float ReadSingle() { float value; hrcheck(X::get()->_ReadSingle(&value)); return value; }
	double ReadDouble() { double value; hrcheck(X::get()->_ReadDouble(&value)); return value; }
	hstring ReadString(unsigned codeUnitCount) { HSTRING value; hrcheck(X::get()->_ReadString(codeUnitCount, &value)); return from_abi(value); }
	Foundation::DateTime ReadDateTime() { Foundation::DateTime value; hrcheck(X::get()->_ReadDateTime(&value)); return value; }
	Foundation::TimeSpan ReadTimeSpan() { Foundation::TimeSpan value; hrcheck(X::get()->_ReadTimeSpan(&value)); return value; }
	ptr<DataReaderLoadOperation> LoadAsync(unsigned count) { DataReaderLoadOperation* operation; hrcheck(X::get()->_LoadAsync(count, &operation)); return from_abi(operation); }
	ptr<IBuffer> DetachBuffer() { IBuffer* buffer; hrcheck(X::get()->_DetachBuffer(&buffer)); return from_abi(buffer); }
	ptr<IInputStream> DetachStream() { IInputStream* stream; hrcheck(X::get()->_DetachStream(&stream)); return from_abi(stream); }
	IDataReader_adaptor() {}
};
template<typename X> struct adapt<IDataReader, X> : Windows::Storage::Streams::IDataReader_adaptor<X> { typedef adapt IDataReader; };
template<typename X> struct IDataReader_unadaptor : X {
	STDMETHODIMP _get_UnconsumedBufferLength(unsigned *value) { return hrtry([&, this] { get_prop(value, UnconsumedBufferLength); }); }
	STDMETHODIMP _get_UnicodeEncoding(Streams::UnicodeEncoding *value) { return hrtry([&, this] { get_prop(value, UnicodeEncoding); }); }
	STDMETHODIMP _put_UnicodeEncoding(Streams::UnicodeEncoding value) { return hrtry([&, this] { put_prop(value, UnicodeEncoding); }); }
	STDMETHODIMP _get_ByteOrder(Streams::ByteOrder *value) { return hrtry([&, this] { get_prop(value, ByteOrder); }); }
	STDMETHODIMP _put_ByteOrder(Streams::ByteOrder value) { return hrtry([&, this] { put_prop(value, ByteOrder); }); }
	STDMETHODIMP _get_InputStreamOptions(Streams::InputStreamOptions *value) { return hrtry([&, this] { get_prop(value, InputStreamOptions); }); }
	STDMETHODIMP _put_InputStreamOptions(Streams::InputStreamOptions value) { return hrtry([&, this] { put_prop(value, InputStreamOptions); }); }
	STDMETHODIMP _ReadByte(unsigned char *value) { return hrtry([&, this] { *value = X::get()->ReadByte(); }); }
	STDMETHODIMP _ReadBytes(unsigned valueSize, unsigned char *value) { return hrtry([&, this] { X::get()->ReadBytes({(unsigned char*)value, valueSize}); }); }
	STDMETHODIMP _ReadBuffer(unsigned length, IBuffer* *buffer) { return hrtry([&, this] { *buffer = to_abi(X::get()->ReadBuffer(length)); }); }
	STDMETHODIMP _ReadBoolean(bool *value) { return hrtry([&, this] { *value = X::get()->ReadBoolean(); }); }
	STDMETHODIMP _ReadGuid(Platform::Guid *value) { return hrtry([&, this] { *value = X::get()->ReadGuid(); }); }
	STDMETHODIMP _ReadInt16(short *value) { return hrtry([&, this] { *value = X::get()->ReadInt16(); }); }
	STDMETHODIMP _ReadInt32(int *value) { return hrtry([&, this] { *value = X::get()->ReadInt32(); }); }
	STDMETHODIMP _ReadInt64(__int64 *value) { return hrtry([&, this] { *value = X::get()->ReadInt64(); }); }
	STDMETHODIMP _ReadUInt16(unsigned short *value) { return hrtry([&, this] { *value = X::get()->ReadUInt16(); }); }
	STDMETHODIMP _ReadUInt32(unsigned *value) { return hrtry([&, this] { *value = X::get()->ReadUInt32(); }); }
	STDMETHODIMP _ReadUInt64(unsigned __int64 *value) { return hrtry([&, this] { *value = X::get()->ReadUInt64(); }); }
	STDMETHODIMP _ReadSingle(float *value) { return hrtry([&, this] { *value = X::get()->ReadSingle(); }); }
	STDMETHODIMP _ReadDouble(double *value) { return hrtry([&, this] { *value = X::get()->ReadDouble(); }); }
	STDMETHODIMP _ReadString(unsigned codeUnitCount, HSTRING *value) { return hrtry([&, this] { *value = to_abi(X::get()->ReadString(codeUnitCount)); }); }
	STDMETHODIMP _ReadDateTime(Foundation::DateTime *value) { return hrtry([&, this] { *value = X::get()->ReadDateTime(); }); }
	STDMETHODIMP _ReadTimeSpan(Foundation::TimeSpan *value) { return hrtry([&, this] { *value = X::get()->ReadTimeSpan(); }); }
	STDMETHODIMP _LoadAsync(unsigned count, DataReaderLoadOperation* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->LoadAsync(count)); }); }
	STDMETHODIMP _DetachBuffer(IBuffer* *buffer) { return hrtry([&, this] { *buffer = to_abi(X::get()->DetachBuffer()); }); }
	STDMETHODIMP _DetachStream(IInputStream* *stream) { return hrtry([&, this] { *stream = to_abi(X::get()->DetachStream()); }); }
};
template<typename X> struct unadapt<IDataReader, X> : Windows::Storage::Streams::IDataReader_unadaptor<X> {};
struct IDataReader : IDataReader_raw, generate<IDataReader> {};

// IDataReaderFactory
struct IDataReaderFactory : IInspectable {
	virtual STDMETHODIMP _CreateDataReader(IInputStream* inputStream, DataReader* *dataReader);
};

// IDataReaderStatics
struct IDataReaderStatics : IInspectable {
	virtual STDMETHODIMP _FromBuffer(IBuffer* buffer, DataReader* *dataReader);
};

// DataReader
template<typename> struct DataReader_statics {
	static ptr<DataReader> FromBuffer(pptr<IBuffer> buffer) { DataReader* dataReader; hrcheck(get_activation_factory<DataReader, IDataReaderStatics>()->_FromBuffer(buffer, &dataReader)); return from_abi(dataReader); }
	static DataReader *activate(pptr<IInputStream> inputStream) { DataReader *dataReader; hrcheck(get_activation_factory<DataReader, IDataReaderFactory>()->_CreateDataReader(inputStream, &dataReader)); return dataReader; }
};

template<typename X> struct statics<DataReader, X> : X, Windows::Storage::Streams::DataReader_statics<void> {
	using Windows::Storage::Streams::DataReader_statics<void>::activate;
	typedef typename X::root_type DataReader;
};
struct DataReader : generate<DataReader> {};

// DataWriterStoreOperation
template<typename X> struct statics<DataWriterStoreOperation, X> : X {
	typedef typename X::root_type DataWriterStoreOperation;
};
struct DataWriterStoreOperation : generate<DataWriterStoreOperation> {};

// IDataWriter
struct IDataWriter_raw : IInspectable {
	virtual STDMETHODIMP _get_UnstoredBufferLength(unsigned *value) = 0;
	virtual STDMETHODIMP _get_UnicodeEncoding(Streams::UnicodeEncoding *value) = 0;
	virtual STDMETHODIMP _put_UnicodeEncoding(Streams::UnicodeEncoding value) = 0;
	virtual STDMETHODIMP _get_ByteOrder(Streams::ByteOrder *value) = 0;
	virtual STDMETHODIMP _put_ByteOrder(Streams::ByteOrder value) = 0;
	virtual STDMETHODIMP _WriteByte(unsigned char value) = 0;
	virtual STDMETHODIMP _WriteBytes(unsigned valueSize, unsigned char *value) = 0;
	virtual STDMETHODIMP _WriteBuffer(IBuffer* buffer) = 0;
	virtual STDMETHODIMP _WriteBufferRange(IBuffer* buffer, unsigned start, unsigned count) = 0;
	virtual STDMETHODIMP _WriteBoolean(bool value) = 0;
	virtual STDMETHODIMP _WriteGuid(Platform::Guid value) = 0;
	virtual STDMETHODIMP _WriteInt16(short value) = 0;
	virtual STDMETHODIMP _WriteInt32(int value) = 0;
	virtual STDMETHODIMP _WriteInt64(__int64 value) = 0;
	virtual STDMETHODIMP _WriteUInt16(unsigned short value) = 0;
	virtual STDMETHODIMP _WriteUInt32(unsigned value) = 0;
	virtual STDMETHODIMP _WriteUInt64(unsigned __int64 value) = 0;
	virtual STDMETHODIMP _WriteSingle(float value) = 0;
	virtual STDMETHODIMP _WriteDouble(double value) = 0;
	virtual STDMETHODIMP _WriteDateTime(Foundation::DateTime value) = 0;
	virtual STDMETHODIMP _WriteTimeSpan(Foundation::TimeSpan value) = 0;
	virtual STDMETHODIMP _WriteString(HSTRING value, unsigned *codeUnitCount) = 0;
	virtual STDMETHODIMP _MeasureString(HSTRING value, unsigned *codeUnitCount) = 0;
	virtual STDMETHODIMP _StoreAsync(DataWriterStoreOperation* *operation) = 0;
	virtual STDMETHODIMP _FlushAsync(Foundation::IAsyncOperation<bool>* *operation) = 0;
	virtual STDMETHODIMP _DetachBuffer(IBuffer* *buffer) = 0;
	virtual STDMETHODIMP _DetachStream(IOutputStream* *outputStream) = 0;
};
template<typename X> struct IDataWriter_adaptor : X {
	union {
		struct : property {
			Streams::ByteOrder get() { Streams::ByteOrder value; hrcheck(enc(&IDataWriter_adaptor::ByteOrder)->_get_ByteOrder(&value)); return value; }
			Streams::ByteOrder operator()() { return get(); }
			operator Streams::ByteOrder () { return get(); }
			void put(Streams::ByteOrder value) { hrcheck(enc(&IDataWriter_adaptor::ByteOrder)->_put_ByteOrder(value)); }
			void operator=(Streams::ByteOrder value) { put(value); }
			void operator()(Streams::ByteOrder value) { put(value); }
		} ByteOrder;
		struct : property {
			Streams::UnicodeEncoding get() { Streams::UnicodeEncoding value; hrcheck(enc(&IDataWriter_adaptor::UnicodeEncoding)->_get_UnicodeEncoding(&value)); return value; }
			Streams::UnicodeEncoding operator()() { return get(); }
			operator Streams::UnicodeEncoding () { return get(); }
			void put(Streams::UnicodeEncoding value) { hrcheck(enc(&IDataWriter_adaptor::UnicodeEncoding)->_put_UnicodeEncoding(value)); }
			void operator=(Streams::UnicodeEncoding value) { put(value); }
			void operator()(Streams::UnicodeEncoding value) { put(value); }
		} UnicodeEncoding;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IDataWriter_adaptor::UnstoredBufferLength)->_get_UnstoredBufferLength(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} UnstoredBufferLength;
	};
	void WriteByte(unsigned char value) { hrcheck(X::get()->_WriteByte(value)); }
	void WriteBytes(const szarray<unsigned char>& value) { hrcheck(X::get()->_WriteBytes(value.size, to_abi(value.p))); }
	void WriteBuffer(pptr<IBuffer> buffer) { hrcheck(X::get()->_WriteBuffer(buffer)); }
	void WriteBuffer(pptr<IBuffer> buffer, unsigned start, unsigned count) { hrcheck(X::get()->_WriteBufferRange(buffer, start, count)); }
	void WriteBoolean(bool value) { hrcheck(X::get()->_WriteBoolean(value)); }
	void WriteGuid(const Platform::Guid& value) { hrcheck(X::get()->_WriteGuid(value)); }
	void WriteInt16(short value) { hrcheck(X::get()->_WriteInt16(value)); }
	void WriteInt32(int value) { hrcheck(X::get()->_WriteInt32(value)); }
	void WriteInt64(__int64 value) { hrcheck(X::get()->_WriteInt64(value)); }
	void WriteUInt16(unsigned short value) { hrcheck(X::get()->_WriteUInt16(value)); }
	void WriteUInt32(unsigned value) { hrcheck(X::get()->_WriteUInt32(value)); }
	void WriteUInt64(unsigned __int64 value) { hrcheck(X::get()->_WriteUInt64(value)); }
	void WriteSingle(float value) { hrcheck(X::get()->_WriteSingle(value)); }
	void WriteDouble(double value) { hrcheck(X::get()->_WriteDouble(value)); }
	void WriteDateTime(const Foundation::DateTime& value) { hrcheck(X::get()->_WriteDateTime(value)); }
	void WriteTimeSpan(const Foundation::TimeSpan& value) { hrcheck(X::get()->_WriteTimeSpan(value)); }
	unsigned WriteString(hstring_ref value) { unsigned codeUnitCount; hrcheck(X::get()->_WriteString(value, &codeUnitCount)); return codeUnitCount; }
	unsigned MeasureString(hstring_ref value) { unsigned codeUnitCount; hrcheck(X::get()->_MeasureString(value, &codeUnitCount)); return codeUnitCount; }
	ptr<DataWriterStoreOperation> StoreAsync() { DataWriterStoreOperation* operation; hrcheck(X::get()->_StoreAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<bool>> FlushAsync() { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_FlushAsync(&operation)); return from_abi(operation); }
	ptr<IBuffer> DetachBuffer() { IBuffer* buffer; hrcheck(X::get()->_DetachBuffer(&buffer)); return from_abi(buffer); }
	ptr<IOutputStream> DetachStream() { IOutputStream* outputStream; hrcheck(X::get()->_DetachStream(&outputStream)); return from_abi(outputStream); }
	IDataWriter_adaptor() {}
};
template<typename X> struct adapt<IDataWriter, X> : Windows::Storage::Streams::IDataWriter_adaptor<X> { typedef adapt IDataWriter; };
template<typename X> struct IDataWriter_unadaptor : X {
	STDMETHODIMP _get_UnstoredBufferLength(unsigned *value) { return hrtry([&, this] { get_prop(value, UnstoredBufferLength); }); }
	STDMETHODIMP _get_UnicodeEncoding(Streams::UnicodeEncoding *value) { return hrtry([&, this] { get_prop(value, UnicodeEncoding); }); }
	STDMETHODIMP _put_UnicodeEncoding(Streams::UnicodeEncoding value) { return hrtry([&, this] { put_prop(value, UnicodeEncoding); }); }
	STDMETHODIMP _get_ByteOrder(Streams::ByteOrder *value) { return hrtry([&, this] { get_prop(value, ByteOrder); }); }
	STDMETHODIMP _put_ByteOrder(Streams::ByteOrder value) { return hrtry([&, this] { put_prop(value, ByteOrder); }); }
	STDMETHODIMP _WriteByte(unsigned char value) { return hrtry([&, this] { X::get()->WriteByte(value); }); }
	STDMETHODIMP _WriteBytes(unsigned valueSize, unsigned char *value) { return hrtry([&, this] { X::get()->WriteBytes({(unsigned char*)value, valueSize}); }); }
	STDMETHODIMP _WriteBuffer(IBuffer* buffer) { return hrtry([&, this] { X::get()->WriteBuffer(buffer); }); }
	STDMETHODIMP _WriteBufferRange(IBuffer* buffer, unsigned start, unsigned count) { return hrtry([&, this] { X::get()->WriteBuffer(buffer, start, count); }); }
	STDMETHODIMP _WriteBoolean(bool value) { return hrtry([&, this] { X::get()->WriteBoolean(value); }); }
	STDMETHODIMP _WriteGuid(Platform::Guid value) { return hrtry([&, this] { X::get()->WriteGuid(value); }); }
	STDMETHODIMP _WriteInt16(short value) { return hrtry([&, this] { X::get()->WriteInt16(value); }); }
	STDMETHODIMP _WriteInt32(int value) { return hrtry([&, this] { X::get()->WriteInt32(value); }); }
	STDMETHODIMP _WriteInt64(__int64 value) { return hrtry([&, this] { X::get()->WriteInt64(value); }); }
	STDMETHODIMP _WriteUInt16(unsigned short value) { return hrtry([&, this] { X::get()->WriteUInt16(value); }); }
	STDMETHODIMP _WriteUInt32(unsigned value) { return hrtry([&, this] { X::get()->WriteUInt32(value); }); }
	STDMETHODIMP _WriteUInt64(unsigned __int64 value) { return hrtry([&, this] { X::get()->WriteUInt64(value); }); }
	STDMETHODIMP _WriteSingle(float value) { return hrtry([&, this] { X::get()->WriteSingle(value); }); }
	STDMETHODIMP _WriteDouble(double value) { return hrtry([&, this] { X::get()->WriteDouble(value); }); }
	STDMETHODIMP _WriteDateTime(Foundation::DateTime value) { return hrtry([&, this] { X::get()->WriteDateTime(value); }); }
	STDMETHODIMP _WriteTimeSpan(Foundation::TimeSpan value) { return hrtry([&, this] { X::get()->WriteTimeSpan(value); }); }
	STDMETHODIMP _WriteString(HSTRING value, unsigned *codeUnitCount) { return hrtry([&, this] { *codeUnitCount = X::get()->WriteString(value); }); }
	STDMETHODIMP _MeasureString(HSTRING value, unsigned *codeUnitCount) { return hrtry([&, this] { *codeUnitCount = X::get()->MeasureString(value); }); }
	STDMETHODIMP _StoreAsync(DataWriterStoreOperation* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->StoreAsync()); }); }
	STDMETHODIMP _FlushAsync(Foundation::IAsyncOperation<bool>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->FlushAsync()); }); }
	STDMETHODIMP _DetachBuffer(IBuffer* *buffer) { return hrtry([&, this] { *buffer = to_abi(X::get()->DetachBuffer()); }); }
	STDMETHODIMP _DetachStream(IOutputStream* *outputStream) { return hrtry([&, this] { *outputStream = to_abi(X::get()->DetachStream()); }); }
};
template<typename X> struct unadapt<IDataWriter, X> : Windows::Storage::Streams::IDataWriter_unadaptor<X> {};
struct IDataWriter : IDataWriter_raw, generate<IDataWriter> {};

// IDataWriterFactory
struct IDataWriterFactory : IInspectable {
	virtual STDMETHODIMP _CreateDataWriter(IOutputStream* outputStream, DataWriter* *dataWriter);
};

// DataWriter
template<typename> struct DataWriter_statics {
	static DataWriter *activate(pptr<IOutputStream> outputStream) { DataWriter *dataWriter; hrcheck(get_activation_factory<DataWriter, IDataWriterFactory>()->_CreateDataWriter(outputStream, &dataWriter)); return dataWriter; }
	static DataWriter *activate() { DataWriter *t; get_activation_factory<DataWriter>()->ActivateInstance((IInspectable**)&t); return t; }
};

template<typename X> struct statics<DataWriter, X> : X, Windows::Storage::Streams::DataWriter_statics<void> {
	using Windows::Storage::Streams::DataWriter_statics<void>::activate;
	typedef typename X::root_type DataWriter;
};
struct DataWriter : generate<DataWriter> {
	using IDataWriter::WriteBuffer;
};

// IBufferFactory
struct IBufferFactory : IInspectable {
	virtual STDMETHODIMP _Create(unsigned capacity, Buffer* *value);
};

// IBufferStatics
struct IBufferStatics : IInspectable {
	virtual STDMETHODIMP _CreateCopyFromMemoryBuffer(Foundation::IMemoryBuffer* input, Buffer* *value);
	virtual STDMETHODIMP _CreateMemoryBufferOverIBuffer(IBuffer* input, Foundation::MemoryBuffer* *value);
};

// IBuffer
struct IBuffer_raw : IInspectable {
	virtual STDMETHODIMP _get_Capacity(unsigned *value) = 0;
	virtual STDMETHODIMP _get_Length(unsigned *value) = 0;
	virtual STDMETHODIMP _put_Length(unsigned value) = 0;
};
template<typename X> struct IBuffer_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IBuffer_adaptor::Capacity)->_get_Capacity(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Capacity;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IBuffer_adaptor::Length)->_get_Length(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IBuffer_adaptor::Length)->_put_Length(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} Length;
	};
	IBuffer_adaptor() {}
};
template<typename X> struct adapt<IBuffer, X> : Windows::Storage::Streams::IBuffer_adaptor<X> { typedef adapt IBuffer; };
template<typename X> struct IBuffer_unadaptor : X {
	STDMETHODIMP _get_Capacity(unsigned *value) { return hrtry([&, this] { get_prop(value, Capacity); }); }
	STDMETHODIMP _get_Length(unsigned *value) { return hrtry([&, this] { get_prop(value, Length); }); }
	STDMETHODIMP _put_Length(unsigned value) { return hrtry([&, this] { put_prop(value, Length); }); }
};
template<typename X> struct unadapt<IBuffer, X> : Windows::Storage::Streams::IBuffer_unadaptor<X> {};
struct IBuffer : IBuffer_raw, generate<IBuffer> {};

// Buffer
template<typename> struct Buffer_statics {
	static ptr<Buffer> CreateCopyFromMemoryBuffer(pptr<Foundation::IMemoryBuffer> input) { Buffer* value; hrcheck(get_activation_factory<Buffer, IBufferStatics>()->_CreateCopyFromMemoryBuffer(input, &value)); return from_abi(value); }
	static ptr<Foundation::MemoryBuffer> CreateMemoryBufferOverIBuffer(pptr<IBuffer> input) { Foundation::MemoryBuffer* value; hrcheck(get_activation_factory<Buffer, IBufferStatics>()->_CreateMemoryBufferOverIBuffer(input, &value)); return from_abi(value); }
	static Buffer *activate(unsigned capacity) { Buffer *value; hrcheck(get_activation_factory<Buffer, IBufferFactory>()->_Create(capacity, &value)); return value; }
};

template<typename X> struct statics<Buffer, X> : X, Windows::Storage::Streams::Buffer_statics<void> {
	using Windows::Storage::Streams::Buffer_statics<void>::activate;
	typedef typename X::root_type Buffer;
};
struct Buffer : generate<Buffer> {};

// IContentTypeProvider
struct IContentTypeProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_ContentType(HSTRING *value) = 0;
};
template<typename X> struct IContentTypeProvider_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IContentTypeProvider_adaptor::ContentType)->_get_ContentType(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ContentType;
	};
	IContentTypeProvider_adaptor() {}
};
template<typename X> struct adapt<IContentTypeProvider, X> : Windows::Storage::Streams::IContentTypeProvider_adaptor<X> { typedef adapt IContentTypeProvider; };
template<typename X> struct IContentTypeProvider_unadaptor : X {
	STDMETHODIMP _get_ContentType(HSTRING *value) { return hrtry([&, this] { get_prop(value, ContentType); }); }
};
template<typename X> struct unadapt<IContentTypeProvider, X> : Windows::Storage::Streams::IContentTypeProvider_unadaptor<X> {};
struct IContentTypeProvider : IContentTypeProvider_raw, generate<IContentTypeProvider> {};

// IInputStream
struct IInputStream_raw : IInspectable {
	virtual STDMETHODIMP _ReadAsync(IBuffer* buffer, unsigned count, InputStreamOptions options, Foundation::IAsyncOperationWithProgress<IBuffer*, unsigned>* *operation) = 0;
};
template<typename X> struct IInputStream_adaptor : X {
	ptr<Foundation::IAsyncOperationWithProgress<ptr<IBuffer>, unsigned>> ReadAsync(pptr<IBuffer> buffer, unsigned count, InputStreamOptions options) { Foundation::IAsyncOperationWithProgress<IBuffer*, unsigned>* operation; hrcheck(X::get()->_ReadAsync(buffer, count, options, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IInputStream, X> : Windows::Storage::Streams::IInputStream_adaptor<X> { typedef adapt IInputStream; };
template<typename X> struct IInputStream_unadaptor : X {
	STDMETHODIMP _ReadAsync(IBuffer* buffer, unsigned count, InputStreamOptions options, Foundation::IAsyncOperationWithProgress<IBuffer*, unsigned>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->ReadAsync(buffer, count, options)); }); }
};
template<typename X> struct unadapt<IInputStream, X> : Windows::Storage::Streams::IInputStream_unadaptor<X> {};
struct IInputStream : IInputStream_raw, generate<IInputStream> {};

// IOutputStream
struct IOutputStream_raw : IInspectable {
	virtual STDMETHODIMP _WriteAsync(IBuffer* buffer, Foundation::IAsyncOperationWithProgress<unsigned, unsigned>* *operation) = 0;
	virtual STDMETHODIMP _FlushAsync(Foundation::IAsyncOperation<bool>* *operation) = 0;
};
template<typename X> struct IOutputStream_adaptor : X {
	ptr<Foundation::IAsyncOperationWithProgress<unsigned, unsigned>> WriteAsync(pptr<IBuffer> buffer) { Foundation::IAsyncOperationWithProgress<unsigned, unsigned>* operation; hrcheck(X::get()->_WriteAsync(buffer, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<bool>> FlushAsync() { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_FlushAsync(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IOutputStream, X> : Windows::Storage::Streams::IOutputStream_adaptor<X> { typedef adapt IOutputStream; };
template<typename X> struct IOutputStream_unadaptor : X {
	STDMETHODIMP _WriteAsync(IBuffer* buffer, Foundation::IAsyncOperationWithProgress<unsigned, unsigned>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->WriteAsync(buffer)); }); }
	STDMETHODIMP _FlushAsync(Foundation::IAsyncOperation<bool>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->FlushAsync()); }); }
};
template<typename X> struct unadapt<IOutputStream, X> : Windows::Storage::Streams::IOutputStream_unadaptor<X> {};
struct IOutputStream : IOutputStream_raw, generate<IOutputStream> {};

// IRandomAccessStream
struct IRandomAccessStream_raw : IInspectable {
	virtual STDMETHODIMP _get_Size(unsigned __int64 *value) = 0;
	virtual STDMETHODIMP _put_Size(unsigned __int64 value) = 0;
	virtual STDMETHODIMP _GetInputStreamAt(unsigned __int64 position, IInputStream* *stream) = 0;
	virtual STDMETHODIMP _GetOutputStreamAt(unsigned __int64 position, IOutputStream* *stream) = 0;
	virtual STDMETHODIMP _get_Position(unsigned __int64 *value) = 0;
	virtual STDMETHODIMP _Seek(unsigned __int64 position) = 0;
	virtual STDMETHODIMP _CloneStream(IRandomAccessStream* *stream) = 0;
	virtual STDMETHODIMP _get_CanRead(bool *value) = 0;
	virtual STDMETHODIMP _get_CanWrite(bool *value) = 0;
};
template<typename X> struct IRandomAccessStream_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRandomAccessStream_adaptor::CanRead)->_get_CanRead(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanRead;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRandomAccessStream_adaptor::CanWrite)->_get_CanWrite(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanWrite;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IRandomAccessStream_adaptor::Position)->_get_Position(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} Position;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IRandomAccessStream_adaptor::Size)->_get_Size(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
			void put(unsigned __int64 value) { hrcheck(enc(&IRandomAccessStream_adaptor::Size)->_put_Size(value)); }
			void operator=(unsigned __int64 value) { put(value); }
			void operator()(unsigned __int64 value) { put(value); }
		} Size;
	};
	ptr<IInputStream> GetInputStreamAt(unsigned __int64 position) { IInputStream* stream; hrcheck(X::get()->_GetInputStreamAt(position, &stream)); return from_abi(stream); }
	ptr<IOutputStream> GetOutputStreamAt(unsigned __int64 position) { IOutputStream* stream; hrcheck(X::get()->_GetOutputStreamAt(position, &stream)); return from_abi(stream); }
	void Seek(unsigned __int64 position) { hrcheck(X::get()->_Seek(position)); }
	ptr<IRandomAccessStream> CloneStream() { IRandomAccessStream* stream; hrcheck(X::get()->_CloneStream(&stream)); return from_abi(stream); }
	IRandomAccessStream_adaptor() {}
};
template<typename X> struct adapt<IRandomAccessStream, X> : Windows::Storage::Streams::IRandomAccessStream_adaptor<X> { typedef adapt IRandomAccessStream; };
template<typename X> struct IRandomAccessStream_unadaptor : X {
	STDMETHODIMP _get_Size(unsigned __int64 *value) { return hrtry([&, this] { get_prop(value, Size); }); }
	STDMETHODIMP _put_Size(unsigned __int64 value) { return hrtry([&, this] { put_prop(value, Size); }); }
	STDMETHODIMP _GetInputStreamAt(unsigned __int64 position, IInputStream* *stream) { return hrtry([&, this] { *stream = to_abi(X::get()->GetInputStreamAt(position)); }); }
	STDMETHODIMP _GetOutputStreamAt(unsigned __int64 position, IOutputStream* *stream) { return hrtry([&, this] { *stream = to_abi(X::get()->GetOutputStreamAt(position)); }); }
	STDMETHODIMP _get_Position(unsigned __int64 *value) { return hrtry([&, this] { get_prop(value, Position); }); }
	STDMETHODIMP _Seek(unsigned __int64 position) { return hrtry([&, this] { X::get()->Seek(position); }); }
	STDMETHODIMP _CloneStream(IRandomAccessStream* *stream) { return hrtry([&, this] { *stream = to_abi(X::get()->CloneStream()); }); }
	STDMETHODIMP _get_CanRead(bool *value) { return hrtry([&, this] { get_prop(value, CanRead); }); }
	STDMETHODIMP _get_CanWrite(bool *value) { return hrtry([&, this] { get_prop(value, CanWrite); }); }
};
template<typename X> struct unadapt<IRandomAccessStream, X> : Windows::Storage::Streams::IRandomAccessStream_unadaptor<X> {};
struct IRandomAccessStream : IRandomAccessStream_raw, generate<IRandomAccessStream> {};

// IRandomAccessStreamWithContentType
struct IRandomAccessStreamWithContentType : IInspectable, generate<IRandomAccessStreamWithContentType> {};

// IRandomAccessStreamReference
struct IRandomAccessStreamReference_raw : IInspectable {
	virtual STDMETHODIMP _OpenReadAsync(Foundation::IAsyncOperation<IRandomAccessStreamWithContentType*>* *operation) = 0;
};
template<typename X> struct IRandomAccessStreamReference_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<IRandomAccessStreamWithContentType>>> OpenReadAsync() { Foundation::IAsyncOperation<IRandomAccessStreamWithContentType*>* operation; hrcheck(X::get()->_OpenReadAsync(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IRandomAccessStreamReference, X> : Windows::Storage::Streams::IRandomAccessStreamReference_adaptor<X> { typedef adapt IRandomAccessStreamReference; };
template<typename X> struct IRandomAccessStreamReference_unadaptor : X {
	STDMETHODIMP _OpenReadAsync(Foundation::IAsyncOperation<IRandomAccessStreamWithContentType*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->OpenReadAsync()); }); }
};
template<typename X> struct unadapt<IRandomAccessStreamReference, X> : Windows::Storage::Streams::IRandomAccessStreamReference_unadaptor<X> {};
struct IRandomAccessStreamReference : IRandomAccessStreamReference_raw, generate<IRandomAccessStreamReference> {};

// IRandomAccessStreamStatics
struct IRandomAccessStreamStatics : IInspectable {
	virtual STDMETHODIMP _CopyAsync(IInputStream* source, IOutputStream* destination, Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>* *operation);
	virtual STDMETHODIMP _CopySizeAsync(IInputStream* source, IOutputStream* destination, unsigned __int64 bytesToCopy, Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>* *operation);
	virtual STDMETHODIMP _CopyAndCloseAsync(IInputStream* source, IOutputStream* destination, Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>* *operation);
};

// RandomAccessStream
template<typename> struct RandomAccessStream_statics {
	static ptr<Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>> CopyAsync(pptr<IInputStream> source, pptr<IOutputStream> destination) { Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>* operation; hrcheck(get_activation_factory<RandomAccessStream, IRandomAccessStreamStatics>()->_CopyAsync(source, destination, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>> CopyAsync(pptr<IInputStream> source, pptr<IOutputStream> destination, unsigned __int64 bytesToCopy) { Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>* operation; hrcheck(get_activation_factory<RandomAccessStream, IRandomAccessStreamStatics>()->_CopySizeAsync(source, destination, bytesToCopy, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>> CopyAndCloseAsync(pptr<IInputStream> source, pptr<IOutputStream> destination) { Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>* operation; hrcheck(get_activation_factory<RandomAccessStream, IRandomAccessStreamStatics>()->_CopyAndCloseAsync(source, destination, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<RandomAccessStream, X> : X, Windows::Storage::Streams::RandomAccessStream_statics<void> {
	typedef typename X::root_type RandomAccessStream;
};
struct RandomAccessStream : generate<RandomAccessStream> {};

// IInputStreamReference
struct IInputStreamReference_raw : IInspectable {
	virtual STDMETHODIMP _OpenSequentialReadAsync(Foundation::IAsyncOperation<IInputStream*>* *operation) = 0;
};
template<typename X> struct IInputStreamReference_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<IInputStream>>> OpenSequentialReadAsync() { Foundation::IAsyncOperation<IInputStream*>* operation; hrcheck(X::get()->_OpenSequentialReadAsync(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IInputStreamReference, X> : Windows::Storage::Streams::IInputStreamReference_adaptor<X> { typedef adapt IInputStreamReference; };
template<typename X> struct IInputStreamReference_unadaptor : X {
	STDMETHODIMP _OpenSequentialReadAsync(Foundation::IAsyncOperation<IInputStream*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->OpenSequentialReadAsync()); }); }
};
template<typename X> struct unadapt<IInputStreamReference, X> : Windows::Storage::Streams::IInputStreamReference_unadaptor<X> {};
struct IInputStreamReference : IInputStreamReference_raw, generate<IInputStreamReference> {};

// IRandomAccessStreamReferenceStatics
struct IRandomAccessStreamReferenceStatics : IInspectable {
	virtual STDMETHODIMP _CreateFromFile(IStorageFile* file, RandomAccessStreamReference* *streamReference);
	virtual STDMETHODIMP _CreateFromUri(Foundation::Uri* uri, RandomAccessStreamReference* *streamReference);
	virtual STDMETHODIMP _CreateFromStream(IRandomAccessStream* stream, RandomAccessStreamReference* *streamReference);
};

// RandomAccessStreamReference
template<typename> struct RandomAccessStreamReference_statics {
	static ptr<RandomAccessStreamReference> CreateFromFile(pptr<IStorageFile> file) { RandomAccessStreamReference* streamReference; hrcheck(get_activation_factory<RandomAccessStreamReference, IRandomAccessStreamReferenceStatics>()->_CreateFromFile(file, &streamReference)); return from_abi(streamReference); }
	static ptr<RandomAccessStreamReference> CreateFromUri(pptr<Foundation::Uri> uri) { RandomAccessStreamReference* streamReference; hrcheck(get_activation_factory<RandomAccessStreamReference, IRandomAccessStreamReferenceStatics>()->_CreateFromUri(uri, &streamReference)); return from_abi(streamReference); }
	static ptr<RandomAccessStreamReference> CreateFromStream(pptr<IRandomAccessStream> stream) { RandomAccessStreamReference* streamReference; hrcheck(get_activation_factory<RandomAccessStreamReference, IRandomAccessStreamReferenceStatics>()->_CreateFromStream(stream, &streamReference)); return from_abi(streamReference); }
};

template<typename X> struct statics<RandomAccessStreamReference, X> : X, Windows::Storage::Streams::RandomAccessStreamReference_statics<void> {
	typedef typename X::root_type RandomAccessStreamReference;
};
struct RandomAccessStreamReference : generate<RandomAccessStreamReference> {};

// IFileRandomAccessStreamStatics
struct IFileRandomAccessStreamStatics : IInspectable {
	virtual STDMETHODIMP _OpenAsync(HSTRING filePath, FileAccessMode accessMode, Foundation::IAsyncOperation<IRandomAccessStream*>* *operation);
	virtual STDMETHODIMP _OpenWithOptionsAsync(HSTRING filePath, FileAccessMode accessMode, StorageOpenOptions sharingOptions, FileOpenDisposition openDisposition, Foundation::IAsyncOperation<IRandomAccessStream*>* *operation);
	virtual STDMETHODIMP _OpenTransactedWriteAsync(HSTRING filePath, Foundation::IAsyncOperation<StorageStreamTransaction*>* *operation);
	virtual STDMETHODIMP _OpenTransactedWriteWithOptionsAsync(HSTRING filePath, StorageOpenOptions openOptions, FileOpenDisposition openDisposition, Foundation::IAsyncOperation<StorageStreamTransaction*>* *operation);
	virtual STDMETHODIMP _OpenForUserAsync(System::User* user, HSTRING filePath, FileAccessMode accessMode, Foundation::IAsyncOperation<IRandomAccessStream*>* *operation);
	virtual STDMETHODIMP _OpenForUserWithOptionsAsync(System::User* user, HSTRING filePath, FileAccessMode accessMode, StorageOpenOptions sharingOptions, FileOpenDisposition openDisposition, Foundation::IAsyncOperation<IRandomAccessStream*>* *operation);
	virtual STDMETHODIMP _OpenTransactedWriteForUserAsync(System::User* user, HSTRING filePath, Foundation::IAsyncOperation<StorageStreamTransaction*>* *operation);
	virtual STDMETHODIMP _OpenTransactedWriteForUserWithOptionsAsync(System::User* user, HSTRING filePath, StorageOpenOptions openOptions, FileOpenDisposition openDisposition, Foundation::IAsyncOperation<StorageStreamTransaction*>* *operation);
};

// FileRandomAccessStream
template<typename> struct FileRandomAccessStream_statics {
	static ptr<Foundation::IAsyncOperation<ptr<IRandomAccessStream>>> OpenAsync(hstring_ref filePath, FileAccessMode accessMode) { Foundation::IAsyncOperation<IRandomAccessStream*>* operation; hrcheck(get_activation_factory<FileRandomAccessStream, IFileRandomAccessStreamStatics>()->_OpenAsync(filePath, accessMode, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<IRandomAccessStream>>> OpenAsync(hstring_ref filePath, FileAccessMode accessMode, StorageOpenOptions sharingOptions, FileOpenDisposition openDisposition) { Foundation::IAsyncOperation<IRandomAccessStream*>* operation; hrcheck(get_activation_factory<FileRandomAccessStream, IFileRandomAccessStreamStatics>()->_OpenWithOptionsAsync(filePath, accessMode, sharingOptions, openDisposition, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageStreamTransaction>>> OpenTransactedWriteAsync(hstring_ref filePath) { Foundation::IAsyncOperation<StorageStreamTransaction*>* operation; hrcheck(get_activation_factory<FileRandomAccessStream, IFileRandomAccessStreamStatics>()->_OpenTransactedWriteAsync(filePath, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageStreamTransaction>>> OpenTransactedWriteAsync(hstring_ref filePath, StorageOpenOptions openOptions, FileOpenDisposition openDisposition) { Foundation::IAsyncOperation<StorageStreamTransaction*>* operation; hrcheck(get_activation_factory<FileRandomAccessStream, IFileRandomAccessStreamStatics>()->_OpenTransactedWriteWithOptionsAsync(filePath, openOptions, openDisposition, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<IRandomAccessStream>>> OpenForUserAsync(pptr<System::User> user, hstring_ref filePath, FileAccessMode accessMode) { Foundation::IAsyncOperation<IRandomAccessStream*>* operation; hrcheck(get_activation_factory<FileRandomAccessStream, IFileRandomAccessStreamStatics>()->_OpenForUserAsync(user, filePath, accessMode, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<IRandomAccessStream>>> OpenForUserAsync(pptr<System::User> user, hstring_ref filePath, FileAccessMode accessMode, StorageOpenOptions sharingOptions, FileOpenDisposition openDisposition) { Foundation::IAsyncOperation<IRandomAccessStream*>* operation; hrcheck(get_activation_factory<FileRandomAccessStream, IFileRandomAccessStreamStatics>()->_OpenForUserWithOptionsAsync(user, filePath, accessMode, sharingOptions, openDisposition, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageStreamTransaction>>> OpenTransactedWriteForUserAsync(pptr<System::User> user, hstring_ref filePath) { Foundation::IAsyncOperation<StorageStreamTransaction*>* operation; hrcheck(get_activation_factory<FileRandomAccessStream, IFileRandomAccessStreamStatics>()->_OpenTransactedWriteForUserAsync(user, filePath, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageStreamTransaction>>> OpenTransactedWriteForUserAsync(pptr<System::User> user, hstring_ref filePath, StorageOpenOptions openOptions, FileOpenDisposition openDisposition) { Foundation::IAsyncOperation<StorageStreamTransaction*>* operation; hrcheck(get_activation_factory<FileRandomAccessStream, IFileRandomAccessStreamStatics>()->_OpenTransactedWriteForUserWithOptionsAsync(user, filePath, openOptions, openDisposition, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<FileRandomAccessStream, X> : X, Windows::Storage::Streams::FileRandomAccessStream_statics<void> {
	typedef typename X::root_type FileRandomAccessStream;
};
struct FileRandomAccessStream : generate<FileRandomAccessStream> {};

// FileInputStream
template<typename X> struct statics<FileInputStream, X> : X {
	typedef typename X::root_type FileInputStream;
};
struct FileInputStream : generate<FileInputStream> {};

// FileOutputStream
template<typename X> struct statics<FileOutputStream, X> : X {
	typedef typename X::root_type FileOutputStream;
};
struct FileOutputStream : generate<FileOutputStream> {};

// RandomAccessStreamOverStream
template<typename X> struct statics<RandomAccessStreamOverStream, X> : X {
	typedef typename X::root_type RandomAccessStreamOverStream;
};
struct RandomAccessStreamOverStream : generate<RandomAccessStreamOverStream> {};

// InputStreamOverStream
template<typename X> struct statics<InputStreamOverStream, X> : X {
	typedef typename X::root_type InputStreamOverStream;
};
struct InputStreamOverStream : generate<InputStreamOverStream> {};

// OutputStreamOverStream
template<typename X> struct statics<OutputStreamOverStream, X> : X {
	typedef typename X::root_type OutputStreamOverStream;
};
struct OutputStreamOverStream : generate<OutputStreamOverStream> {};

// InMemoryRandomAccessStream
template<typename X> struct statics<InMemoryRandomAccessStream, X> : X {
	typedef typename X::root_type InMemoryRandomAccessStream;
};
struct InMemoryRandomAccessStream : generate<InMemoryRandomAccessStream> {};
}}}
} // namespace iso_winrt
