#pragma once
// generated by isopod tools
// namespaces:
// Windows.Devices.Haptics

#include "Windows.Devices.Haptics.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IVectorView;
}}}

// defs

template<> struct def<Windows::Devices::Haptics::IKnownSimpleHapticsControllerWaveformsStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Haptics::ISimpleHapticsControllerFeedback> : interface_type<> {};
template<> struct def<Windows::Devices::Haptics::ISimpleHapticsController> : interface_type<> {};
template<> struct def<Windows::Devices::Haptics::SimpleHapticsControllerFeedback> : class_type<Platform::Object, Windows::Devices::Haptics::ISimpleHapticsControllerFeedback> {};
template<> struct def<Windows::Devices::Haptics::SimpleHapticsController> : class_type<Platform::Object, Windows::Devices::Haptics::ISimpleHapticsController> {};
template<> struct def<Windows::Devices::Haptics::KnownSimpleHapticsControllerWaveforms> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Devices::Haptics::VibrationAccessStatus> : enum_type<int> {};
template<> struct def<Windows::Devices::Haptics::IVibrationDeviceStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Haptics::IVibrationDevice> : interface_type<> {};
template<> struct def<Windows::Devices::Haptics::VibrationDevice> : class_type<Platform::Object, Windows::Devices::Haptics::IVibrationDevice> {};

// uuids

template<> struct uuid<Windows::Devices::Haptics::IKnownSimpleHapticsControllerWaveformsStatics> { define_guid(0x3D577EF7, 0x4CEE, 0x11E6, 0xB5, 0x35, 0x0, 0x1B, 0xDC, 0x6, 0xAB, 0x3B);};
template<> struct uuid<Windows::Devices::Haptics::ISimpleHapticsControllerFeedback> { define_guid(0x3D577EF8, 0x4CEE, 0x11E6, 0xB5, 0x35, 0x0, 0x1B, 0xDC, 0x6, 0xAB, 0x3B);};
template<> struct uuid<Windows::Devices::Haptics::ISimpleHapticsController> { define_guid(0x3D577EF9, 0x4CEE, 0x11E6, 0xB5, 0x35, 0x0, 0x1B, 0xDC, 0x6, 0xAB, 0x3B);};
template<> struct uuid<Windows::Devices::Haptics::IVibrationDeviceStatics> { define_guid(0x53E2EDED, 0x2290, 0x4AC9, 0x8E, 0xB3, 0x1A, 0x84, 0x12, 0x2E, 0xB7, 0x1C);};
template<> struct uuid<Windows::Devices::Haptics::IVibrationDevice> { define_guid(0x40F21A3E, 0x8844, 0x47FF, 0xB3, 0x12, 0x6, 0x18, 0x5A, 0x38, 0x44, 0xDA);};

// types

namespace Windows { namespace Devices { namespace Haptics {

// IKnownSimpleHapticsControllerWaveformsStatics
struct IKnownSimpleHapticsControllerWaveformsStatics : IInspectable {
	virtual STDMETHODIMP _get_Click(unsigned short *value);
	virtual STDMETHODIMP _get_BuzzContinuous(unsigned short *value);
	virtual STDMETHODIMP _get_RumbleContinuous(unsigned short *value);
	virtual STDMETHODIMP _get_Press(unsigned short *value);
	virtual STDMETHODIMP _get_Release(unsigned short *value);
};

// ISimpleHapticsControllerFeedback
struct ISimpleHapticsControllerFeedback_raw : IInspectable {
	virtual STDMETHODIMP _get_Waveform(unsigned short *value);
	virtual STDMETHODIMP _get_Duration(Foundation::TimeSpan *value);
};
template<typename X> struct ISimpleHapticsControllerFeedback_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ISimpleHapticsControllerFeedback_adaptor::Duration)->_get_Duration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} Duration;
		struct : property {
			unsigned short get() { unsigned short value; hrcheck(enc(&ISimpleHapticsControllerFeedback_adaptor::Waveform)->_get_Waveform(&value)); return value; }
			unsigned short operator()() { return get(); }
			operator unsigned short () { return get(); }
		} Waveform;
	};
	ISimpleHapticsControllerFeedback_adaptor() {}
};
template<typename X> struct adapt<ISimpleHapticsControllerFeedback, X> : Windows::Devices::Haptics::ISimpleHapticsControllerFeedback_adaptor<X> { typedef adapt ISimpleHapticsControllerFeedback; };
struct ISimpleHapticsControllerFeedback : ISimpleHapticsControllerFeedback_raw, generate<ISimpleHapticsControllerFeedback> {};

// ISimpleHapticsController
struct ISimpleHapticsController_raw : IInspectable {
	virtual STDMETHODIMP _get_Id(HSTRING *value);
	virtual STDMETHODIMP _get_SupportedFeedback(Foundation::Collections::IVectorView<SimpleHapticsControllerFeedback*>* *value);
	virtual STDMETHODIMP _get_IsIntensitySupported(bool *value);
	virtual STDMETHODIMP _get_IsPlayCountSupported(bool *value);
	virtual STDMETHODIMP _get_IsPlayDurationSupported(bool *value);
	virtual STDMETHODIMP _get_IsReplayPauseIntervalSupported(bool *value);
	virtual STDMETHODIMP _StopFeedback();
	virtual STDMETHODIMP _SendHapticFeedback(SimpleHapticsControllerFeedback* feedback);
	virtual STDMETHODIMP _SendHapticFeedbackWithIntensity(SimpleHapticsControllerFeedback* feedback, double intensity);
	virtual STDMETHODIMP _SendHapticFeedbackForDuration(SimpleHapticsControllerFeedback* feedback, double intensity, Foundation::TimeSpan playDuration);
	virtual STDMETHODIMP _SendHapticFeedbackForPlayCount(SimpleHapticsControllerFeedback* feedback, double intensity, int playCount, Foundation::TimeSpan replayPauseInterval);
};
template<typename X> struct ISimpleHapticsController_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISimpleHapticsController_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISimpleHapticsController_adaptor::IsIntensitySupported)->_get_IsIntensitySupported(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsIntensitySupported;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISimpleHapticsController_adaptor::IsPlayCountSupported)->_get_IsPlayCountSupported(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsPlayCountSupported;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISimpleHapticsController_adaptor::IsPlayDurationSupported)->_get_IsPlayDurationSupported(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsPlayDurationSupported;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISimpleHapticsController_adaptor::IsReplayPauseIntervalSupported)->_get_IsReplayPauseIntervalSupported(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsReplayPauseIntervalSupported;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<SimpleHapticsControllerFeedback>>> get() { Foundation::Collections::IVectorView<SimpleHapticsControllerFeedback*>* value; hrcheck(enc(&ISimpleHapticsController_adaptor::SupportedFeedback)->_get_SupportedFeedback(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<SimpleHapticsControllerFeedback>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<SimpleHapticsControllerFeedback>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<SimpleHapticsControllerFeedback>>> operator->() { return get(); }
		} SupportedFeedback;
	};
	void StopFeedback() { hrcheck(X::get()->_StopFeedback()); }
	void SendHapticFeedback(pptr<SimpleHapticsControllerFeedback> feedback) { hrcheck(X::get()->_SendHapticFeedback(feedback)); }
	void SendHapticFeedback(pptr<SimpleHapticsControllerFeedback> feedback, double intensity) { hrcheck(X::get()->_SendHapticFeedbackWithIntensity(feedback, intensity)); }
	void SendHapticFeedbackForDuration(pptr<SimpleHapticsControllerFeedback> feedback, double intensity, const Foundation::TimeSpan& playDuration) { hrcheck(X::get()->_SendHapticFeedbackForDuration(feedback, intensity, playDuration)); }
	void SendHapticFeedbackForPlayCount(pptr<SimpleHapticsControllerFeedback> feedback, double intensity, int playCount, const Foundation::TimeSpan& replayPauseInterval) { hrcheck(X::get()->_SendHapticFeedbackForPlayCount(feedback, intensity, playCount, replayPauseInterval)); }
	ISimpleHapticsController_adaptor() {}
};
template<typename X> struct adapt<ISimpleHapticsController, X> : Windows::Devices::Haptics::ISimpleHapticsController_adaptor<X> { typedef adapt ISimpleHapticsController; };
struct ISimpleHapticsController : ISimpleHapticsController_raw, generate<ISimpleHapticsController> {};

// SimpleHapticsControllerFeedback
template<typename X> struct statics<SimpleHapticsControllerFeedback, X> : X {
	typedef typename X::root_type SimpleHapticsControllerFeedback;
};
struct SimpleHapticsControllerFeedback : generate<SimpleHapticsControllerFeedback> {};

// SimpleHapticsController
template<typename X> struct statics<SimpleHapticsController, X> : X {
	typedef typename X::root_type SimpleHapticsController;
};
struct SimpleHapticsController : generate<SimpleHapticsController> {
	using ISimpleHapticsController::SendHapticFeedback;
};

// KnownSimpleHapticsControllerWaveforms
template<typename> struct KnownSimpleHapticsControllerWaveforms_statics {
	static struct _BuzzContinuous : property {
		unsigned short get() { unsigned short value; hrcheck(get_activation_factory<KnownSimpleHapticsControllerWaveforms, IKnownSimpleHapticsControllerWaveformsStatics>()->_get_BuzzContinuous(&value)); return value; }
		unsigned short operator()() { return get(); }
		operator unsigned short () { return get(); }
	} BuzzContinuous;
	static struct _Click : property {
		unsigned short get() { unsigned short value; hrcheck(get_activation_factory<KnownSimpleHapticsControllerWaveforms, IKnownSimpleHapticsControllerWaveformsStatics>()->_get_Click(&value)); return value; }
		unsigned short operator()() { return get(); }
		operator unsigned short () { return get(); }
	} Click;
	static struct _Press : property {
		unsigned short get() { unsigned short value; hrcheck(get_activation_factory<KnownSimpleHapticsControllerWaveforms, IKnownSimpleHapticsControllerWaveformsStatics>()->_get_Press(&value)); return value; }
		unsigned short operator()() { return get(); }
		operator unsigned short () { return get(); }
	} Press;
	static struct _Release : property {
		unsigned short get() { unsigned short value; hrcheck(get_activation_factory<KnownSimpleHapticsControllerWaveforms, IKnownSimpleHapticsControllerWaveformsStatics>()->_get_Release(&value)); return value; }
		unsigned short operator()() { return get(); }
		operator unsigned short () { return get(); }
	} release;
	static struct _RumbleContinuous : property {
		unsigned short get() { unsigned short value; hrcheck(get_activation_factory<KnownSimpleHapticsControllerWaveforms, IKnownSimpleHapticsControllerWaveformsStatics>()->_get_RumbleContinuous(&value)); return value; }
		unsigned short operator()() { return get(); }
		operator unsigned short () { return get(); }
	} RumbleContinuous;
};
template<typename X> typename KnownSimpleHapticsControllerWaveforms_statics<X>::_BuzzContinuous KnownSimpleHapticsControllerWaveforms_statics<X>::BuzzContinuous;
template<typename X> typename KnownSimpleHapticsControllerWaveforms_statics<X>::_Click KnownSimpleHapticsControllerWaveforms_statics<X>::Click;
template<typename X> typename KnownSimpleHapticsControllerWaveforms_statics<X>::_Press KnownSimpleHapticsControllerWaveforms_statics<X>::Press;
template<typename X> typename KnownSimpleHapticsControllerWaveforms_statics<X>::_Release KnownSimpleHapticsControllerWaveforms_statics<X>::Release;
template<typename X> typename KnownSimpleHapticsControllerWaveforms_statics<X>::_RumbleContinuous KnownSimpleHapticsControllerWaveforms_statics<X>::RumbleContinuous;

template<typename X> struct statics<KnownSimpleHapticsControllerWaveforms, X> : X, Windows::Devices::Haptics::KnownSimpleHapticsControllerWaveforms_statics<void> {
	typedef typename X::root_type KnownSimpleHapticsControllerWaveforms;
};
struct KnownSimpleHapticsControllerWaveforms : generate<KnownSimpleHapticsControllerWaveforms> {};

// IVibrationDeviceStatics
struct IVibrationDeviceStatics : IInspectable {
	virtual STDMETHODIMP _RequestAccessAsync(Foundation::IAsyncOperation<VibrationAccessStatus>* *operation);
	virtual STDMETHODIMP _GetDeviceSelector(HSTRING *result);
	virtual STDMETHODIMP _FromIdAsync(HSTRING deviceId, Foundation::IAsyncOperation<VibrationDevice*>* *operation);
	virtual STDMETHODIMP _GetDefaultAsync(Foundation::IAsyncOperation<VibrationDevice*>* *operation);
	virtual STDMETHODIMP _FindAllAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<VibrationDevice*>*>* *operation);
};

// IVibrationDevice
struct IVibrationDevice_raw : IInspectable {
	virtual STDMETHODIMP _get_Id(HSTRING *value);
	virtual STDMETHODIMP _get_SimpleHapticsController(Haptics::SimpleHapticsController* *value);
};
template<typename X> struct IVibrationDevice_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVibrationDevice_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
		struct : property {
			ptr<Haptics::SimpleHapticsController> get() { Haptics::SimpleHapticsController* value; hrcheck(enc(&IVibrationDevice_adaptor::SimpleHapticsController)->_get_SimpleHapticsController(&value)); return from_abi(value); }
			ptr<Haptics::SimpleHapticsController> operator()() { return get(); }
			operator ptr<Haptics::SimpleHapticsController> () { return get(); }
			ptr<Haptics::SimpleHapticsController> operator->() { return get(); }
		} SimpleHapticsController;
	};
	IVibrationDevice_adaptor() {}
};
template<typename X> struct adapt<IVibrationDevice, X> : Windows::Devices::Haptics::IVibrationDevice_adaptor<X> { typedef adapt IVibrationDevice; };
struct IVibrationDevice : IVibrationDevice_raw, generate<IVibrationDevice> {};

// VibrationDevice
template<typename> struct VibrationDevice_statics {
	static ptr<Foundation::IAsyncOperation<VibrationAccessStatus>> RequestAccessAsync() { Foundation::IAsyncOperation<VibrationAccessStatus>* operation; hrcheck(get_activation_factory<VibrationDevice, IVibrationDeviceStatics>()->_RequestAccessAsync(&operation)); return from_abi(operation); }
	static hstring GetDeviceSelector() { HSTRING result; hrcheck(get_activation_factory<VibrationDevice, IVibrationDeviceStatics>()->_GetDeviceSelector(&result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<VibrationDevice>>> FromIdAsync(hstring_ref deviceId) { Foundation::IAsyncOperation<VibrationDevice*>* operation; hrcheck(get_activation_factory<VibrationDevice, IVibrationDeviceStatics>()->_FromIdAsync(deviceId, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<VibrationDevice>>> GetDefaultAsync() { Foundation::IAsyncOperation<VibrationDevice*>* operation; hrcheck(get_activation_factory<VibrationDevice, IVibrationDeviceStatics>()->_GetDefaultAsync(&operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<VibrationDevice>>>>> FindAllAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<VibrationDevice*>*>* operation; hrcheck(get_activation_factory<VibrationDevice, IVibrationDeviceStatics>()->_FindAllAsync(&operation)); return from_abi(operation); }
};

template<typename X> struct statics<VibrationDevice, X> : X, Windows::Devices::Haptics::VibrationDevice_statics<void> {
	typedef typename X::root_type VibrationDevice;
};
struct VibrationDevice : generate<VibrationDevice> {};
}}}
} // namespace iso_winrt
