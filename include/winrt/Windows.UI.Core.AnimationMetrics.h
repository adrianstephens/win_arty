#pragma once
// generated by isopod tools
// namespaces:
// Windows.UI.Core.AnimationMetrics

#include "Windows.UI.Core.AnimationMetrics.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IVectorView;
}}}

// defs

template<> struct def<Windows::UI::Core::AnimationMetrics::AnimationMetricsContract> : value_type<> {};
template<> struct def<Windows::UI::Core::AnimationMetrics::PropertyAnimationType> : enum_type<int> {};
template<> struct def<Windows::UI::Core::AnimationMetrics::IPropertyAnimation> : overridable_type<> {};
template<> struct def<Windows::UI::Core::AnimationMetrics::IScaleAnimation> : interface_type<Windows::UI::Core::AnimationMetrics::IPropertyAnimation> {};
template<> struct def<Windows::UI::Core::AnimationMetrics::IOpacityAnimation> : interface_type<Windows::UI::Core::AnimationMetrics::IPropertyAnimation> {};
template<> struct def<Windows::UI::Core::AnimationMetrics::AnimationEffect> : enum_type<int> {};
template<> struct def<Windows::UI::Core::AnimationMetrics::AnimationEffectTarget> : enum_type<int> {};
template<> struct def<Windows::UI::Core::AnimationMetrics::IAnimationDescription> : interface_type<> {};
template<> struct def<Windows::UI::Core::AnimationMetrics::IAnimationDescriptionFactory> : interface_type<> {};
template<> struct def<Windows::UI::Core::AnimationMetrics::AnimationDescription> : class_type<Platform::Object, Windows::UI::Core::AnimationMetrics::IAnimationDescription>, custom_activators {};
template<> struct def<Windows::UI::Core::AnimationMetrics::PropertyAnimation> : class_type<Platform::Object, Windows::UI::Core::AnimationMetrics::IPropertyAnimation> {};
template<> struct def<Windows::UI::Core::AnimationMetrics::ScaleAnimation> : class_type<Platform::Object, Windows::UI::Core::AnimationMetrics::IScaleAnimation> {};
template<> struct def<Windows::UI::Core::AnimationMetrics::TranslationAnimation> : class_type<Platform::Object, Windows::UI::Core::AnimationMetrics::IPropertyAnimation> {};
template<> struct def<Windows::UI::Core::AnimationMetrics::OpacityAnimation> : class_type<Platform::Object, Windows::UI::Core::AnimationMetrics::IOpacityAnimation> {};

// uuids

template<> struct uuid<Windows::UI::Core::AnimationMetrics::IPropertyAnimation> { define_guid(0x3A01B4DA, 0x4D8C, 0x411E, 0xB6, 0x15, 0x1A, 0xDE, 0x68, 0x3A, 0x99, 0x3);};
template<> struct uuid<Windows::UI::Core::AnimationMetrics::IScaleAnimation> { define_guid(0x23552C7, 0x71AB, 0x428C, 0x9C, 0x9F, 0xD3, 0x17, 0x80, 0x96, 0x49, 0x95);};
template<> struct uuid<Windows::UI::Core::AnimationMetrics::IOpacityAnimation> { define_guid(0x803AABE5, 0xEE7E, 0x455F, 0x84, 0xE9, 0x25, 0x6, 0xAF, 0xB8, 0xD2, 0xB4);};
template<> struct uuid<Windows::UI::Core::AnimationMetrics::IAnimationDescription> { define_guid(0x7D11A549, 0xBE3D, 0x41DE, 0xB0, 0x81, 0x5, 0xC1, 0x49, 0x96, 0x2F, 0x9B);};
template<> struct uuid<Windows::UI::Core::AnimationMetrics::IAnimationDescriptionFactory> { define_guid(0xC6E27ABE, 0xC1FB, 0x48B5, 0x92, 0x71, 0xEC, 0xC7, 0xA, 0xC8, 0x6E, 0xF0);};

// types

namespace Windows { namespace UI { namespace Core { namespace AnimationMetrics {

// IPropertyAnimation
struct IPropertyAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_Type(PropertyAnimationType *value) = 0;
	virtual STDMETHODIMP _get_Delay(Foundation::TimeSpan *value) = 0;
	virtual STDMETHODIMP _get_Duration(Foundation::TimeSpan *value) = 0;
	virtual STDMETHODIMP _get_Control1(Foundation::Point *value) = 0;
	virtual STDMETHODIMP _get_Control2(Foundation::Point *value) = 0;
};
template<typename X> struct IPropertyAnimation_adaptor : X {
	union {
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IPropertyAnimation_adaptor::Control1)->_get_Control1(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
		} Control1;
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IPropertyAnimation_adaptor::Control2)->_get_Control2(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
		} Control2;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IPropertyAnimation_adaptor::Delay)->_get_Delay(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} Delay;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IPropertyAnimation_adaptor::Duration)->_get_Duration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} Duration;
		struct : property {
			PropertyAnimationType get() { PropertyAnimationType value; hrcheck(enc(&IPropertyAnimation_adaptor::Type)->_get_Type(&value)); return value; }
			PropertyAnimationType operator()() { return get(); }
			operator PropertyAnimationType () { return get(); }
		} Type;
	};
	IPropertyAnimation_adaptor() {}
};
template<typename X> struct adapt<IPropertyAnimation, X> : Windows::UI::Core::AnimationMetrics::IPropertyAnimation_adaptor<X> { typedef adapt IPropertyAnimation; };
template<typename X> struct IPropertyAnimation_unadaptor : X {
	STDMETHODIMP _get_Type(PropertyAnimationType *value) { return hrtry([&, this] { get_prop(value, Type); }); }
	STDMETHODIMP _get_Delay(Foundation::TimeSpan *value) { return hrtry([&, this] { get_prop(value, Delay); }); }
	STDMETHODIMP _get_Duration(Foundation::TimeSpan *value) { return hrtry([&, this] { get_prop(value, Duration); }); }
	STDMETHODIMP _get_Control1(Foundation::Point *value) { return hrtry([&, this] { get_prop(value, Control1); }); }
	STDMETHODIMP _get_Control2(Foundation::Point *value) { return hrtry([&, this] { get_prop(value, Control2); }); }
};
template<typename X> struct unadapt<IPropertyAnimation, X> : Windows::UI::Core::AnimationMetrics::IPropertyAnimation_unadaptor<X> {};
struct IPropertyAnimation : IPropertyAnimation_raw, generate<IPropertyAnimation> {};

// IScaleAnimation
struct IScaleAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_InitialScaleX(Foundation::IReference<float>* *value);
	virtual STDMETHODIMP _get_InitialScaleY(Foundation::IReference<float>* *value);
	virtual STDMETHODIMP _get_FinalScaleX(float *value);
	virtual STDMETHODIMP _get_FinalScaleY(float *value);
	virtual STDMETHODIMP _get_NormalizedOrigin(Foundation::Point *value);
};
template<typename X> struct IScaleAnimation_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&IScaleAnimation_adaptor::FinalScaleX)->_get_FinalScaleX(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} FinalScaleX;
		struct : property {
			float get() { float value; hrcheck(enc(&IScaleAnimation_adaptor::FinalScaleY)->_get_FinalScaleY(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} FinalScaleY;
		struct : property {
			ptr<Foundation::IReference<float>> get() { Foundation::IReference<float>* value; hrcheck(enc(&IScaleAnimation_adaptor::InitialScaleX)->_get_InitialScaleX(&value)); return from_abi(value); }
			ptr<Foundation::IReference<float>> operator()() { return get(); }
			operator ptr<Foundation::IReference<float>> () { return get(); }
			ptr<Foundation::IReference<float>> operator->() { return get(); }
		} InitialScaleX;
		struct : property {
			ptr<Foundation::IReference<float>> get() { Foundation::IReference<float>* value; hrcheck(enc(&IScaleAnimation_adaptor::InitialScaleY)->_get_InitialScaleY(&value)); return from_abi(value); }
			ptr<Foundation::IReference<float>> operator()() { return get(); }
			operator ptr<Foundation::IReference<float>> () { return get(); }
			ptr<Foundation::IReference<float>> operator->() { return get(); }
		} InitialScaleY;
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IScaleAnimation_adaptor::NormalizedOrigin)->_get_NormalizedOrigin(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
		} NormalizedOrigin;
	};
	IScaleAnimation_adaptor() {}
};
template<typename X> struct adapt<IScaleAnimation, X> : Windows::UI::Core::AnimationMetrics::IScaleAnimation_adaptor<X> { typedef adapt IScaleAnimation; };
struct IScaleAnimation : IScaleAnimation_raw, generate<IScaleAnimation> {};

// IOpacityAnimation
struct IOpacityAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_InitialOpacity(Foundation::IReference<float>* *value);
	virtual STDMETHODIMP _get_FinalOpacity(float *value);
};
template<typename X> struct IOpacityAnimation_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&IOpacityAnimation_adaptor::FinalOpacity)->_get_FinalOpacity(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} FinalOpacity;
		struct : property {
			ptr<Foundation::IReference<float>> get() { Foundation::IReference<float>* value; hrcheck(enc(&IOpacityAnimation_adaptor::InitialOpacity)->_get_InitialOpacity(&value)); return from_abi(value); }
			ptr<Foundation::IReference<float>> operator()() { return get(); }
			operator ptr<Foundation::IReference<float>> () { return get(); }
			ptr<Foundation::IReference<float>> operator->() { return get(); }
		} InitialOpacity;
	};
	IOpacityAnimation_adaptor() {}
};
template<typename X> struct adapt<IOpacityAnimation, X> : Windows::UI::Core::AnimationMetrics::IOpacityAnimation_adaptor<X> { typedef adapt IOpacityAnimation; };
struct IOpacityAnimation : IOpacityAnimation_raw, generate<IOpacityAnimation> {};

// IAnimationDescription
struct IAnimationDescription_raw : IInspectable {
	virtual STDMETHODIMP _get_Animations(Foundation::Collections::IVectorView<IPropertyAnimation*>* *value);
	virtual STDMETHODIMP _get_StaggerDelay(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_StaggerDelayFactor(float *value);
	virtual STDMETHODIMP _get_DelayLimit(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_ZOrder(int *value);
};
template<typename X> struct IAnimationDescription_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<IPropertyAnimation>>> get() { Foundation::Collections::IVectorView<IPropertyAnimation*>* value; hrcheck(enc(&IAnimationDescription_adaptor::Animations)->_get_Animations(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<IPropertyAnimation>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<IPropertyAnimation>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<IPropertyAnimation>>> operator->() { return get(); }
		} Animations;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IAnimationDescription_adaptor::DelayLimit)->_get_DelayLimit(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} DelayLimit;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IAnimationDescription_adaptor::StaggerDelay)->_get_StaggerDelay(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} StaggerDelay;
		struct : property {
			float get() { float value; hrcheck(enc(&IAnimationDescription_adaptor::StaggerDelayFactor)->_get_StaggerDelayFactor(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} StaggerDelayFactor;
		struct : property {
			int get() { int value; hrcheck(enc(&IAnimationDescription_adaptor::ZOrder)->_get_ZOrder(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} ZOrder;
	};
	IAnimationDescription_adaptor() {}
};
template<typename X> struct adapt<IAnimationDescription, X> : Windows::UI::Core::AnimationMetrics::IAnimationDescription_adaptor<X> { typedef adapt IAnimationDescription; };
struct IAnimationDescription : IAnimationDescription_raw, generate<IAnimationDescription> {};

// IAnimationDescriptionFactory
struct IAnimationDescriptionFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(AnimationEffect effect, AnimationEffectTarget target, AnimationDescription* *animation);
};

// AnimationDescription
template<typename> struct AnimationDescription_statics {
	static AnimationDescription *activate(AnimationEffect effect, AnimationEffectTarget target) { AnimationDescription *animation; hrcheck(get_activation_factory<AnimationDescription, IAnimationDescriptionFactory>()->_CreateInstance(effect, target, &animation)); return animation; }
};

template<typename X> struct statics<AnimationDescription, X> : X, Windows::UI::Core::AnimationMetrics::AnimationDescription_statics<void> {
	using Windows::UI::Core::AnimationMetrics::AnimationDescription_statics<void>::activate;
	typedef typename X::root_type AnimationDescription;
};
struct AnimationDescription : generate<AnimationDescription> {};

// PropertyAnimation
template<typename X> struct statics<PropertyAnimation, X> : X {
	typedef typename X::root_type PropertyAnimation;
};
struct PropertyAnimation : generate<PropertyAnimation> {};

// ScaleAnimation
template<typename X> struct statics<ScaleAnimation, X> : X {
	typedef typename X::root_type ScaleAnimation;
};
struct ScaleAnimation : generate<ScaleAnimation> {};

// TranslationAnimation
template<typename X> struct statics<TranslationAnimation, X> : X {
	typedef typename X::root_type TranslationAnimation;
};
struct TranslationAnimation : generate<TranslationAnimation> {};

// OpacityAnimation
template<typename X> struct statics<OpacityAnimation, X> : X {
	typedef typename X::root_type OpacityAnimation;
};
struct OpacityAnimation : generate<OpacityAnimation> {};
}}}}
} // namespace iso_winrt
