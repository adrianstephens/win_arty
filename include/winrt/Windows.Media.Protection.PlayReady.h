#pragma once
// generated by isopod tools
// namespaces:
// Windows.Media.Protection.PlayReady

#include "Windows.Media.Protection.PlayReady.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.Media.Protection.h"
#include "Windows.Foundation.Collections.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Media { namespace Core {
struct MediaStreamSample;
struct MediaStreamSource;
struct VideoStreamDescriptor;
struct AudioStreamDescriptor;
struct IMediaStreamDescriptor;
}}
namespace Storage {
struct IStorageFile;
}}

// defs

template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyDecryptorSetup> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyEncryptionAlgorithm> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyContentHeader> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyContentHeaderFactory2> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyContentHeaderFactory> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyContentHeader2> : interface_type<Windows::Media::Protection::PlayReady::IPlayReadyContentHeader> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyContentHeader> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::IPlayReadyContentHeader, Windows::Media::Protection::PlayReady::IPlayReadyContentHeader2>, custom_activators {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadySoapMessage> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadySoapMessage> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::IPlayReadySoapMessage> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyContentResolver> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyContentResolver> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest> : overridable_type<Windows::Media::Protection::IMediaProtectionServiceRequest> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyIndividualizationServiceRequest> : interface_type<Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::IPlayReadyIndividualizationServiceRequest> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyDomainJoinServiceRequest> : interface_type<Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::IPlayReadyDomainJoinServiceRequest> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyDomainLeaveServiceRequest> : interface_type<Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::IPlayReadyDomainLeaveServiceRequest> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyLicenseIterableFactory> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyLicense> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable> : class_type<Platform::Object, Windows::Foundation::Collections::IIterable<ptr<Windows::Media::Protection::PlayReady::IPlayReadyLicense>>>, custom_activators {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest> : overridable_type<Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest2> : interface_type<Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest3> : interface_type<Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest2> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest, Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest3> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyMeteringReportServiceRequest> : interface_type<Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::IPlayReadyMeteringReportServiceRequest> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyRevocationServiceRequest> : interface_type<Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::IPlayReadyRevocationServiceRequest> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyLicenseManagement> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyLicenseManagement> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyLicense2> : interface_type<Windows::Media::Protection::PlayReady::IPlayReadyLicense> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyLicense> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::IPlayReadyLicense, Windows::Media::Protection::PlayReady::IPlayReadyLicense2> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator> : class_type<Platform::Object, Windows::Foundation::Collections::IIterator<ptr<Windows::Media::Protection::PlayReady::IPlayReadyLicense>>> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyDomain> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyDomain> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::IPlayReadyDomain> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyDomainIterableFactory> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyDomainIterable> : class_type<Platform::Object, Windows::Foundation::Collections::IIterable<ptr<Windows::Media::Protection::PlayReady::IPlayReadyDomain>>>, custom_activators {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyDomainIterator> : class_type<Platform::Object, Windows::Foundation::Collections::IIterator<ptr<Windows::Media::Protection::PlayReady::IPlayReadyDomain>>> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyStatics> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyStatics2> : interface_type<Windows::Media::Protection::PlayReady::IPlayReadyStatics> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyHardwareDRMFeatures> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyStatics3> : interface_type<Windows::Media::Protection::PlayReady::IPlayReadyStatics2> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyStatics4> : interface_type<Windows::Media::Protection::PlayReady::IPlayReadyStatics3> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyStatics> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequestFactory> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest> : overridable_type<Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>, custom_activators {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadySecureStopIterableFactory> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable> : class_type<Platform::Object, Windows::Foundation::Collections::IIterable<ptr<Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>>>, custom_activators {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator> : class_type<Platform::Object, Windows::Foundation::Collections::IIterator<ptr<Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>>> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyITADataFormat> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyITADataGenerator> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::IPlayReadyITADataGenerator> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2> : overridable_type<Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession> {};
template<> struct def<Windows::Media::Protection::PlayReady::IPlayReadyLicenseSessionFactory> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::PlayReadyLicenseSession> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession, Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2>, custom_activators {};
template<> struct def<Windows::Media::Protection::PlayReady::NDCertificateType> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::PlayReady::NDCertificatePlatformID> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::PlayReady::NDCertificateFeature> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::PlayReady::NDProximityDetectionType> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::PlayReady::NDMediaStreamType> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::PlayReady::NDContentIDType> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::PlayReady::NDClosedCaptionFormat> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::PlayReady::NDStartAsyncOptions> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDDownloadEngine> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDCustomData> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDStreamParser> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDStreamParserNotifier> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::NDStreamParserNotifier> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::INDStreamParserNotifier> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDSendResult> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDMessenger> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDTCPMessengerFactory> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::NDTCPMessenger> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::INDMessenger>, custom_activators {};
template<> struct def<Windows::Media::Protection::PlayReady::INDTransmitterProperties> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDStartResult> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDLicenseFetchResult> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptorFactory> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>, custom_activators {};
template<> struct def<Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDCustomDataFactory> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::NDCustomData> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::INDCustomData>, custom_activators {};
template<> struct def<Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDClient> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDClientFactory> : interface_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::NDClient> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::INDClient>, custom_activators {};
template<> struct def<Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::INDStorageFileHelper> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::PlayReady::NDStorageFileHelper> : class_type<Platform::Object, Windows::Media::Protection::PlayReady::INDStorageFileHelper> {};

// uuids

template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyContentHeader> { define_guid(0x9A438A6A, 0x7F4C, 0x452E, 0x88, 0xBD, 0x1, 0x48, 0xC6, 0x38, 0x7A, 0x2C);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyContentHeaderFactory2> { define_guid(0xD1239CF5, 0xAE6D, 0x4778, 0x97, 0xFD, 0x6E, 0x3A, 0x2E, 0xEA, 0xDB, 0xEB);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyContentHeaderFactory> { define_guid(0xCB97C8FF, 0xB758, 0x4776, 0xBF, 0x1, 0x21, 0x7A, 0x8B, 0x51, 0xB, 0x2C);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyContentHeader2> { define_guid(0x359C79F4, 0x2180, 0x498C, 0x96, 0x5B, 0xE7, 0x54, 0xD8, 0x75, 0xEA, 0xB2);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadySoapMessage> { define_guid(0xB659FCB5, 0xCE41, 0x41BA, 0x8A, 0xD, 0x61, 0xDF, 0x5F, 0xFF, 0xA1, 0x39);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyContentResolver> { define_guid(0xFBFD2523, 0x906D, 0x4982, 0xA6, 0xB8, 0x68, 0x49, 0x56, 0x5A, 0x7C, 0xE8);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest> { define_guid(0x8BAD2836, 0xA703, 0x45A6, 0xA1, 0x80, 0x76, 0xF3, 0x56, 0x5A, 0xA7, 0x25);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyIndividualizationServiceRequest> { define_guid(0x21F5A86B, 0x8C, 0x4611, 0xAB, 0x2F, 0xAA, 0xA6, 0xC6, 0x9F, 0xE, 0x24);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyDomainJoinServiceRequest> { define_guid(0x171B4A5A, 0x405F, 0x4739, 0xB0, 0x40, 0x67, 0xB9, 0xF0, 0xC3, 0x87, 0x58);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyDomainLeaveServiceRequest> { define_guid(0x62D58BE, 0x97AD, 0x4917, 0xAA, 0x3, 0x46, 0xD4, 0xC2, 0x52, 0xD4, 0x64);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyLicenseIterableFactory> { define_guid(0xD4179F08, 0x837, 0x4978, 0x8E, 0x68, 0xBE, 0x42, 0x93, 0xC8, 0xD7, 0xA6);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyLicense> { define_guid(0xEE474C4E, 0xFA3C, 0x414D, 0xA9, 0xF2, 0x3F, 0xFC, 0x1E, 0xF8, 0x32, 0xD4);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest> { define_guid(0x5D85FF45, 0x3E9F, 0x4F48, 0x93, 0xE1, 0x95, 0x30, 0xC8, 0xD5, 0x8C, 0x3E);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest2> { define_guid(0xB7FA5EB5, 0xFE0C, 0xB225, 0xBC, 0x60, 0x5A, 0x9E, 0xDD, 0x32, 0xCE, 0xB5);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest3> { define_guid(0x394E5F4D, 0x7F75, 0x430D, 0xB2, 0xE7, 0x7F, 0x75, 0xF3, 0x4B, 0x2D, 0x75);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyMeteringReportServiceRequest> { define_guid(0xC12B231C, 0xECD, 0x4F11, 0xA1, 0x85, 0x1E, 0x24, 0xA4, 0xA6, 0x7F, 0xB7);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyRevocationServiceRequest> { define_guid(0x543D66AC, 0xFAF0, 0x4560, 0x84, 0xA5, 0xE, 0x4A, 0xCE, 0xC9, 0x39, 0xE4);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyLicenseManagement> { define_guid(0xAAEB2141, 0x957, 0x4405, 0xB8, 0x92, 0x8B, 0xF3, 0xEC, 0x5D, 0xAD, 0xD9);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyLicense2> { define_guid(0x30F4E7A7, 0xD8E3, 0x48A0, 0xBC, 0xDA, 0xFF, 0x9F, 0x40, 0x53, 0x4, 0x36);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyDomain> { define_guid(0xADCC93AC, 0x97E6, 0x43EF, 0x95, 0xE4, 0xD7, 0x86, 0x8F, 0x3B, 0x16, 0xA9);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyDomainIterableFactory> { define_guid(0x4DF384EE, 0x3121, 0x4DF3, 0xA5, 0xE8, 0xD0, 0xC2, 0x4C, 0x5, 0x0, 0xFC);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyStatics> { define_guid(0x5E69C00D, 0x247C, 0x469A, 0x8F, 0x31, 0x5C, 0x1A, 0x15, 0x71, 0xD9, 0xC6);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyStatics2> { define_guid(0x1F8D6A92, 0x5F9A, 0x423E, 0x94, 0x66, 0xB3, 0x39, 0x69, 0xAF, 0x7A, 0x3D);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyStatics3> { define_guid(0x3FA33F71, 0x2DD3, 0x4BED, 0xAE, 0x49, 0xF7, 0x14, 0x8E, 0x63, 0xE7, 0x10);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyStatics4> { define_guid(0x50A91300, 0xD824, 0x4231, 0x9D, 0x5E, 0x78, 0xEF, 0x88, 0x44, 0xC7, 0xD7);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequestFactory> { define_guid(0xE448AC9, 0xE67E, 0x494E, 0x9F, 0x49, 0x62, 0x85, 0x43, 0x8C, 0x76, 0xCF);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest> { define_guid(0xB5501EE5, 0x1BF, 0x4401, 0x96, 0x77, 0x5, 0x63, 0xA, 0x6A, 0x4C, 0xC8);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadySecureStopIterableFactory> { define_guid(0x5F1F0165, 0x4214, 0x4D9E, 0x81, 0xEB, 0xE8, 0x9F, 0x9D, 0x29, 0x4A, 0xEE);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyITADataGenerator> { define_guid(0x24446B8E, 0x10B9, 0x4530, 0xB2, 0x5B, 0x90, 0x1A, 0x80, 0x29, 0xA9, 0xB2);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession> { define_guid(0xA1723A39, 0x87FA, 0x4FDD, 0xAB, 0xBB, 0xA9, 0x72, 0xE, 0x84, 0x52, 0x59);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2> { define_guid(0x4909BE3A, 0x3AED, 0x4656, 0x8A, 0xD7, 0xEE, 0xF, 0xD7, 0x79, 0x95, 0x10);};
template<> struct uuid<Windows::Media::Protection::PlayReady::IPlayReadyLicenseSessionFactory> { define_guid(0x62492699, 0x6527, 0x429E, 0x98, 0xBE, 0x48, 0xD7, 0x98, 0xAC, 0x27, 0x39);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDDownloadEngine> { define_guid(0x2D223D65, 0xC4B6, 0x4438, 0x8D, 0x46, 0xB9, 0x6E, 0x6D, 0xF, 0xB2, 0x1F);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier> { define_guid(0xD720B4D4, 0xF4B8, 0x4530, 0xA8, 0x9, 0x91, 0x93, 0xA5, 0x71, 0xE7, 0xFC);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor> { define_guid(0x5498D33A, 0xE686, 0x4935, 0xA5, 0x67, 0x7C, 0xA7, 0x7A, 0xD2, 0xF, 0xA4);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDCustomData> { define_guid(0xF5CB0FDC, 0x2D09, 0x4F19, 0xB5, 0xE1, 0x76, 0xA0, 0xB3, 0xEE, 0x92, 0x67);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDStreamParser> { define_guid(0xE0BAA198, 0x9796, 0x41C9, 0x86, 0x95, 0x59, 0x43, 0x7E, 0x67, 0xE6, 0x6A);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDStreamParserNotifier> { define_guid(0xC167ACD0, 0x2CE6, 0x426C, 0xAC, 0xE5, 0x5E, 0x92, 0x75, 0xFE, 0xA7, 0x15);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDSendResult> { define_guid(0xE3685517, 0xA584, 0x479D, 0x90, 0xB7, 0xD6, 0x89, 0xC7, 0xBF, 0x7C, 0x80);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDMessenger> { define_guid(0xD42DF95D, 0xA75B, 0x47BF, 0x82, 0x49, 0xBC, 0x83, 0x82, 0xD, 0xA3, 0x8A);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDTCPMessengerFactory> { define_guid(0x7DD85CFE, 0x1B99, 0x4F68, 0x8F, 0x82, 0x81, 0x77, 0xF7, 0xCE, 0xDF, 0x2B);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDTransmitterProperties> { define_guid(0xE536AF23, 0xAC4F, 0x4ADC, 0x8C, 0x66, 0x4F, 0xF7, 0xC2, 0x70, 0x2D, 0xD6);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDStartResult> { define_guid(0x79F6E96E, 0xF50F, 0x4015, 0x8B, 0xA4, 0xC2, 0xBC, 0x34, 0x4E, 0xBD, 0x4E);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDLicenseFetchResult> { define_guid(0x21D39698, 0xAA62, 0x45FF, 0xA5, 0xFF, 0x80, 0x37, 0xE5, 0x43, 0x38, 0x25);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptorFactory> { define_guid(0xD0031202, 0xCFAC, 0x4F00, 0xAE, 0x6A, 0x97, 0xAF, 0x80, 0xB8, 0x48, 0xF2);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs> { define_guid(0x9E39B64D, 0xAB5B, 0x4905, 0xAC, 0xDC, 0x78, 0x7A, 0x77, 0xC6, 0x37, 0x4D);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDCustomDataFactory> { define_guid(0xD65405AB, 0x3424, 0x4833, 0x8C, 0x9A, 0xAF, 0x5F, 0xDE, 0xB2, 0x28, 0x72);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs> { define_guid(0x2A706328, 0xDA25, 0x4F8C, 0x9E, 0xB7, 0x5D, 0xF, 0xC3, 0x65, 0x8B, 0xCA);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs> { define_guid(0x1EE30A1A, 0x11B2, 0x4558, 0x88, 0x65, 0xE3, 0xA5, 0x16, 0x92, 0x25, 0x17);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDClient> { define_guid(0x3BD6781B, 0x61B8, 0x46E2, 0x99, 0xA5, 0x8A, 0xBC, 0xB6, 0xB9, 0xF7, 0xD6);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDClientFactory> { define_guid(0x3E53DD62, 0xFEE8, 0x451F, 0xB0, 0xD4, 0xF7, 0x6, 0xCC, 0xA3, 0xE0, 0x37);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs> { define_guid(0x4738D29F, 0xC345, 0x4649, 0x84, 0x68, 0xB8, 0xC5, 0xFC, 0x35, 0x71, 0x90);};
template<> struct uuid<Windows::Media::Protection::PlayReady::INDStorageFileHelper> { define_guid(0xD8F0BEF8, 0x91D2, 0x4D47, 0xA3, 0xF9, 0xEA, 0xFF, 0x4E, 0xDB, 0x72, 0x9F);};

// types

namespace Windows { namespace Media { namespace Protection { namespace PlayReady {

// IPlayReadyContentHeader
struct IPlayReadyContentHeader_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyId(Platform::Guid *value);
	virtual STDMETHODIMP _get_KeyIdString(HSTRING *value);
	virtual STDMETHODIMP _get_LicenseAcquisitionUrl(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_LicenseAcquisitionUserInterfaceUrl(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_DomainServiceId(Platform::Guid *value);
	virtual STDMETHODIMP _get_EncryptionType(PlayReadyEncryptionAlgorithm *value);
	virtual STDMETHODIMP _get_CustomAttributes(HSTRING *value);
	virtual STDMETHODIMP _get_DecryptorSetup(PlayReadyDecryptorSetup *value);
	virtual STDMETHODIMP _GetSerializedHeader(unsigned *headerBytesSize, unsigned char **headerBytes);
	virtual STDMETHODIMP _get_HeaderWithEmbeddedUpdates(PlayReadyContentHeader* *value);
};
template<typename X> struct IPlayReadyContentHeader_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPlayReadyContentHeader_adaptor::CustomAttributes)->_get_CustomAttributes(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} CustomAttributes;
		struct : property {
			PlayReadyDecryptorSetup get() { PlayReadyDecryptorSetup value; hrcheck(enc(&IPlayReadyContentHeader_adaptor::DecryptorSetup)->_get_DecryptorSetup(&value)); return value; }
			PlayReadyDecryptorSetup operator()() { return get(); }
			operator PlayReadyDecryptorSetup () { return get(); }
		} DecryptorSetup;
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPlayReadyContentHeader_adaptor::DomainServiceId)->_get_DomainServiceId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} DomainServiceId;
		struct : property {
			PlayReadyEncryptionAlgorithm get() { PlayReadyEncryptionAlgorithm value; hrcheck(enc(&IPlayReadyContentHeader_adaptor::EncryptionType)->_get_EncryptionType(&value)); return value; }
			PlayReadyEncryptionAlgorithm operator()() { return get(); }
			operator PlayReadyEncryptionAlgorithm () { return get(); }
		} EncryptionType;
		struct : property {
			ptr<PlayReadyContentHeader> get() { PlayReadyContentHeader* value; hrcheck(enc(&IPlayReadyContentHeader_adaptor::HeaderWithEmbeddedUpdates)->_get_HeaderWithEmbeddedUpdates(&value)); return from_abi(value); }
			ptr<PlayReadyContentHeader> operator()() { return get(); }
			operator ptr<PlayReadyContentHeader> () { return get(); }
			ptr<PlayReadyContentHeader> operator->() { return get(); }
		} HeaderWithEmbeddedUpdates;
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPlayReadyContentHeader_adaptor::KeyId)->_get_KeyId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} KeyId;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPlayReadyContentHeader_adaptor::KeyIdString)->_get_KeyIdString(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} KeyIdString;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IPlayReadyContentHeader_adaptor::LicenseAcquisitionUrl)->_get_LicenseAcquisitionUrl(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} LicenseAcquisitionUrl;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IPlayReadyContentHeader_adaptor::LicenseAcquisitionUserInterfaceUrl)->_get_LicenseAcquisitionUserInterfaceUrl(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} LicenseAcquisitionUserInterfaceUrl;
	};
	szarray<unsigned char> GetSerializedHeader() { szarray<unsigned char> headerBytes; hrcheck(X::get()->_GetSerializedHeader(&headerBytes.size, &headerBytes.p)); return headerBytes; }
	IPlayReadyContentHeader_adaptor() {}
};
template<typename X> struct adapt<IPlayReadyContentHeader, X> : Windows::Media::Protection::PlayReady::IPlayReadyContentHeader_adaptor<X> { typedef adapt IPlayReadyContentHeader; };
struct IPlayReadyContentHeader : IPlayReadyContentHeader_raw, generate<IPlayReadyContentHeader> {};

// IPlayReadyContentHeaderFactory2
struct IPlayReadyContentHeaderFactory2 : IInspectable {
	virtual STDMETHODIMP _CreateInstanceFromComponents2(unsigned dwFlags, unsigned contentKeyIdsSize, Platform::Guid *contentKeyIds, unsigned contentKeyIdStringsSize, HSTRING *contentKeyIdStrings, PlayReadyEncryptionAlgorithm contentEncryptionAlgorithm, Foundation::Uri* licenseAcquisitionUrl, Foundation::Uri* licenseAcquisitionUserInterfaceUrl, HSTRING customAttributes, Platform::Guid domainServiceId, PlayReadyContentHeader* *instance);
};

// IPlayReadyContentHeaderFactory
struct IPlayReadyContentHeaderFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceFromWindowsMediaDrmHeader(unsigned headerBytesSize, unsigned char *headerBytes, Foundation::Uri* licenseAcquisitionUrl, Foundation::Uri* licenseAcquisitionUserInterfaceUrl, HSTRING customAttributes, Platform::Guid domainServiceId, PlayReadyContentHeader* *instance);
	virtual STDMETHODIMP _CreateInstanceFromComponents(Platform::Guid contentKeyId, HSTRING contentKeyIdString, PlayReadyEncryptionAlgorithm contentEncryptionAlgorithm, Foundation::Uri* licenseAcquisitionUrl, Foundation::Uri* licenseAcquisitionUserInterfaceUrl, HSTRING customAttributes, Platform::Guid domainServiceId, PlayReadyContentHeader* *instance);
	virtual STDMETHODIMP _CreateInstanceFromPlayReadyHeader(unsigned headerBytesSize, unsigned char *headerBytes, PlayReadyContentHeader* *instance);
};

// IPlayReadyContentHeader2
struct IPlayReadyContentHeader2_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyIds(unsigned *contentKeyIdsSize, Platform::Guid **contentKeyIds);
	virtual STDMETHODIMP _get_KeyIdStrings(unsigned *contentKeyIdStringsSize, HSTRING **contentKeyIdStrings);
};
template<typename X> struct IPlayReadyContentHeader2_adaptor : X {
	union {
		struct : property {
			szarray<hstring> get() { szarray<HSTRING> contentKeyIdStrings; hrcheck(enc(&IPlayReadyContentHeader2_adaptor::KeyIdStrings)->_get_KeyIdStrings(&contentKeyIdStrings.size, &contentKeyIdStrings.p)); return from_abi(contentKeyIdStrings); }
			szarray<hstring> operator()() { return get(); }
			operator szarray<hstring> () { return get(); }
		} KeyIdStrings;
		struct : property {
			szarray<Platform::Guid> get() { szarray<Platform::Guid> contentKeyIds; hrcheck(enc(&IPlayReadyContentHeader2_adaptor::KeyIds)->_get_KeyIds(&contentKeyIds.size, &contentKeyIds.p)); return contentKeyIds; }
			szarray<Platform::Guid> operator()() { return get(); }
			operator szarray<Platform::Guid> () { return get(); }
		} KeyIds;
	};
	IPlayReadyContentHeader2_adaptor() {}
};
template<typename X> struct adapt<IPlayReadyContentHeader2, X> : Windows::Media::Protection::PlayReady::IPlayReadyContentHeader2_adaptor<X> { typedef adapt IPlayReadyContentHeader2; };
struct IPlayReadyContentHeader2 : IPlayReadyContentHeader2_raw, generate<IPlayReadyContentHeader2> {};

// PlayReadyContentHeader
template<typename> struct PlayReadyContentHeader_statics {
	static PlayReadyContentHeader *activate(const szarray<unsigned char>& headerBytes, pptr<Foundation::Uri> licenseAcquisitionUrl, pptr<Foundation::Uri> licenseAcquisitionUserInterfaceUrl, hstring_ref customAttributes, const Platform::Guid& domainServiceId) { PlayReadyContentHeader *instance; hrcheck(get_activation_factory<PlayReadyContentHeader, IPlayReadyContentHeaderFactory>()->_CreateInstanceFromWindowsMediaDrmHeader(headerBytes.size, to_abi(headerBytes.p), licenseAcquisitionUrl, licenseAcquisitionUserInterfaceUrl, customAttributes, domainServiceId, &instance)); return instance; }
	static PlayReadyContentHeader *activate(const Platform::Guid& contentKeyId, hstring_ref contentKeyIdString, PlayReadyEncryptionAlgorithm contentEncryptionAlgorithm, pptr<Foundation::Uri> licenseAcquisitionUrl, pptr<Foundation::Uri> licenseAcquisitionUserInterfaceUrl, hstring_ref customAttributes, const Platform::Guid& domainServiceId) { PlayReadyContentHeader *instance; hrcheck(get_activation_factory<PlayReadyContentHeader, IPlayReadyContentHeaderFactory>()->_CreateInstanceFromComponents(contentKeyId, contentKeyIdString, contentEncryptionAlgorithm, licenseAcquisitionUrl, licenseAcquisitionUserInterfaceUrl, customAttributes, domainServiceId, &instance)); return instance; }
	static PlayReadyContentHeader *activate(const szarray<unsigned char>& headerBytes) { PlayReadyContentHeader *instance; hrcheck(get_activation_factory<PlayReadyContentHeader, IPlayReadyContentHeaderFactory>()->_CreateInstanceFromPlayReadyHeader(headerBytes.size, to_abi(headerBytes.p), &instance)); return instance; }
	static PlayReadyContentHeader *activate(unsigned dwFlags, const szarray<Platform::Guid>& contentKeyIds, const szarray<hstring>& contentKeyIdStrings, PlayReadyEncryptionAlgorithm contentEncryptionAlgorithm, pptr<Foundation::Uri> licenseAcquisitionUrl, pptr<Foundation::Uri> licenseAcquisitionUserInterfaceUrl, hstring_ref customAttributes, const Platform::Guid& domainServiceId) { PlayReadyContentHeader *instance; hrcheck(get_activation_factory<PlayReadyContentHeader, IPlayReadyContentHeaderFactory2>()->_CreateInstanceFromComponents2(dwFlags, contentKeyIds.size, to_abi(contentKeyIds.p), contentKeyIdStrings.size, to_abi(contentKeyIdStrings.p), contentEncryptionAlgorithm, licenseAcquisitionUrl, licenseAcquisitionUserInterfaceUrl, customAttributes, domainServiceId, &instance)); return instance; }
};

template<typename X> struct statics<PlayReadyContentHeader, X> : X, Windows::Media::Protection::PlayReady::PlayReadyContentHeader_statics<void> {
	using Windows::Media::Protection::PlayReady::PlayReadyContentHeader_statics<void>::activate;
	typedef typename X::root_type PlayReadyContentHeader;
};
struct PlayReadyContentHeader : generate<PlayReadyContentHeader> {};

// IPlayReadySoapMessage
struct IPlayReadySoapMessage_raw : IInspectable {
	virtual STDMETHODIMP _GetMessageBody(unsigned *messageBodyBytesSize, unsigned char **messageBodyBytes);
	virtual STDMETHODIMP _get_MessageHeaders(Foundation::Collections::IPropertySet* *value);
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *messageUri);
};
template<typename X> struct IPlayReadySoapMessage_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IPropertySet> get() { Foundation::Collections::IPropertySet* value; hrcheck(enc(&IPlayReadySoapMessage_adaptor::MessageHeaders)->_get_MessageHeaders(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IPropertySet> operator()() { return get(); }
			operator ptr<Foundation::Collections::IPropertySet> () { return get(); }
			ptr<Foundation::Collections::IPropertySet> operator->() { return get(); }
		} MessageHeaders;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* messageUri; hrcheck(enc(&IPlayReadySoapMessage_adaptor::Uri)->_get_Uri(&messageUri)); return from_abi(messageUri); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
	};
	szarray<unsigned char> GetMessageBody() { szarray<unsigned char> messageBodyBytes; hrcheck(X::get()->_GetMessageBody(&messageBodyBytes.size, &messageBodyBytes.p)); return messageBodyBytes; }
	IPlayReadySoapMessage_adaptor() {}
};
template<typename X> struct adapt<IPlayReadySoapMessage, X> : Windows::Media::Protection::PlayReady::IPlayReadySoapMessage_adaptor<X> { typedef adapt IPlayReadySoapMessage; };
struct IPlayReadySoapMessage : IPlayReadySoapMessage_raw, generate<IPlayReadySoapMessage> {};

// PlayReadySoapMessage
template<typename X> struct statics<PlayReadySoapMessage, X> : X {
	typedef typename X::root_type PlayReadySoapMessage;
};
struct PlayReadySoapMessage : generate<PlayReadySoapMessage> {};

// IPlayReadyContentResolver
struct IPlayReadyContentResolver : IInspectable {
	virtual STDMETHODIMP _ServiceRequest(PlayReadyContentHeader* contentHeader, IPlayReadyServiceRequest* *serviceRequest);
};

// PlayReadyContentResolver
template<typename> struct PlayReadyContentResolver_statics {
	static ptr<IPlayReadyServiceRequest> ServiceRequest(pptr<PlayReadyContentHeader> contentHeader) { IPlayReadyServiceRequest* serviceRequest; hrcheck(get_activation_factory<PlayReadyContentResolver, IPlayReadyContentResolver>()->_ServiceRequest(contentHeader, &serviceRequest)); return from_abi(serviceRequest); }
};

template<typename X> struct statics<PlayReadyContentResolver, X> : X, Windows::Media::Protection::PlayReady::PlayReadyContentResolver_statics<void> {
	typedef typename X::root_type PlayReadyContentResolver;
};
struct PlayReadyContentResolver : generate<PlayReadyContentResolver> {};

// IPlayReadyServiceRequest
struct IPlayReadyServiceRequest_raw : IInspectable {
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value) = 0;
	virtual STDMETHODIMP _put_Uri(Foundation::Uri* value) = 0;
	virtual STDMETHODIMP _get_ResponseCustomData(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_ChallengeCustomData(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_ChallengeCustomData(HSTRING value) = 0;
	virtual STDMETHODIMP _BeginServiceRequest(Foundation::IAsyncAction* *action) = 0;
	virtual STDMETHODIMP _NextServiceRequest(IPlayReadyServiceRequest* *serviceRequest) = 0;
	virtual STDMETHODIMP _GenerateManualEnablingChallenge(PlayReadySoapMessage* *challengeMessage) = 0;
	virtual STDMETHODIMP _ProcessManualEnablingResponse(unsigned responseBytesSize, unsigned char *responseBytes, Foundation::HResult *result) = 0;
};
template<typename X> struct IPlayReadyServiceRequest_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPlayReadyServiceRequest_adaptor::ChallengeCustomData)->_get_ChallengeCustomData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPlayReadyServiceRequest_adaptor::ChallengeCustomData)->_put_ChallengeCustomData(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ChallengeCustomData;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPlayReadyServiceRequest_adaptor::ResponseCustomData)->_get_ResponseCustomData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ResponseCustomData;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IPlayReadyServiceRequest_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IPlayReadyServiceRequest_adaptor::Uri)->_put_Uri(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} Uri;
	};
	ptr<Foundation::IAsyncAction> BeginServiceRequest() { Foundation::IAsyncAction* action; hrcheck(X::get()->_BeginServiceRequest(&action)); return from_abi(action); }
	ptr<IPlayReadyServiceRequest> NextServiceRequest() { IPlayReadyServiceRequest* serviceRequest; hrcheck(X::get()->_NextServiceRequest(&serviceRequest)); return from_abi(serviceRequest); }
	ptr<PlayReadySoapMessage> GenerateManualEnablingChallenge() { PlayReadySoapMessage* challengeMessage; hrcheck(X::get()->_GenerateManualEnablingChallenge(&challengeMessage)); return from_abi(challengeMessage); }
	Foundation::HResult ProcessManualEnablingResponse(const szarray<unsigned char>& responseBytes) { Foundation::HResult result; hrcheck(X::get()->_ProcessManualEnablingResponse(responseBytes.size, to_abi(responseBytes.p), &result)); return result; }
	IPlayReadyServiceRequest_adaptor() {}
};
template<typename X> struct adapt<IPlayReadyServiceRequest, X> : Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest_adaptor<X> { typedef adapt IPlayReadyServiceRequest; };
template<typename X> struct IPlayReadyServiceRequest_unadaptor : X {
	STDMETHODIMP _get_Uri(Foundation::Uri* *value) { return hrtry([&, this] { get_prop(value, Uri); }); }
	STDMETHODIMP _put_Uri(Foundation::Uri* value) { return hrtry([&, this] { put_prop(value, Uri); }); }
	STDMETHODIMP _get_ResponseCustomData(HSTRING *value) { return hrtry([&, this] { get_prop(value, ResponseCustomData); }); }
	STDMETHODIMP _get_ChallengeCustomData(HSTRING *value) { return hrtry([&, this] { get_prop(value, ChallengeCustomData); }); }
	STDMETHODIMP _put_ChallengeCustomData(HSTRING value) { return hrtry([&, this] { put_prop(value, ChallengeCustomData); }); }
	STDMETHODIMP _BeginServiceRequest(Foundation::IAsyncAction* *action) { return hrtry([&, this] { *action = to_abi(X::get()->BeginServiceRequest()); }); }
	STDMETHODIMP _NextServiceRequest(IPlayReadyServiceRequest* *serviceRequest) { return hrtry([&, this] { *serviceRequest = to_abi(X::get()->NextServiceRequest()); }); }
	STDMETHODIMP _GenerateManualEnablingChallenge(PlayReadySoapMessage* *challengeMessage) { return hrtry([&, this] { *challengeMessage = to_abi(X::get()->GenerateManualEnablingChallenge()); }); }
	STDMETHODIMP _ProcessManualEnablingResponse(unsigned responseBytesSize, unsigned char *responseBytes, Foundation::HResult *result) { return hrtry([&, this] { *result = X::get()->ProcessManualEnablingResponse({(unsigned char*)responseBytes, responseBytesSize}); }); }
};
template<typename X> struct unadapt<IPlayReadyServiceRequest, X> : Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest_unadaptor<X> {};
struct IPlayReadyServiceRequest : IPlayReadyServiceRequest_raw, generate<IPlayReadyServiceRequest> {};

// IPlayReadyIndividualizationServiceRequest
struct IPlayReadyIndividualizationServiceRequest : IInspectable, generate<IPlayReadyIndividualizationServiceRequest> {};

// PlayReadyIndividualizationServiceRequest
template<typename X> struct statics<PlayReadyIndividualizationServiceRequest, X> : X {
	typedef typename X::root_type PlayReadyIndividualizationServiceRequest;
};
struct PlayReadyIndividualizationServiceRequest : generate<PlayReadyIndividualizationServiceRequest> {};

// IPlayReadyDomainJoinServiceRequest
struct IPlayReadyDomainJoinServiceRequest_raw : IInspectable {
	virtual STDMETHODIMP _get_DomainAccountId(Platform::Guid *value);
	virtual STDMETHODIMP _put_DomainAccountId(Platform::Guid value);
	virtual STDMETHODIMP _get_DomainFriendlyName(HSTRING *value);
	virtual STDMETHODIMP _put_DomainFriendlyName(HSTRING value);
	virtual STDMETHODIMP _get_DomainServiceId(Platform::Guid *value);
	virtual STDMETHODIMP _put_DomainServiceId(Platform::Guid value);
};
template<typename X> struct IPlayReadyDomainJoinServiceRequest_adaptor : X {
	union {
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPlayReadyDomainJoinServiceRequest_adaptor::DomainAccountId)->_get_DomainAccountId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
			void put(const Platform::Guid& value) { hrcheck(enc(&IPlayReadyDomainJoinServiceRequest_adaptor::DomainAccountId)->_put_DomainAccountId(value)); }
			void operator=(const Platform::Guid& value) { put(value); }
			void operator()(const Platform::Guid& value) { put(value); }
		} DomainAccountId;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPlayReadyDomainJoinServiceRequest_adaptor::DomainFriendlyName)->_get_DomainFriendlyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPlayReadyDomainJoinServiceRequest_adaptor::DomainFriendlyName)->_put_DomainFriendlyName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DomainFriendlyName;
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPlayReadyDomainJoinServiceRequest_adaptor::DomainServiceId)->_get_DomainServiceId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
			void put(const Platform::Guid& value) { hrcheck(enc(&IPlayReadyDomainJoinServiceRequest_adaptor::DomainServiceId)->_put_DomainServiceId(value)); }
			void operator=(const Platform::Guid& value) { put(value); }
			void operator()(const Platform::Guid& value) { put(value); }
		} DomainServiceId;
	};
	IPlayReadyDomainJoinServiceRequest_adaptor() {}
};
template<typename X> struct adapt<IPlayReadyDomainJoinServiceRequest, X> : Windows::Media::Protection::PlayReady::IPlayReadyDomainJoinServiceRequest_adaptor<X> { typedef adapt IPlayReadyDomainJoinServiceRequest; };
struct IPlayReadyDomainJoinServiceRequest : IPlayReadyDomainJoinServiceRequest_raw, generate<IPlayReadyDomainJoinServiceRequest> {};

// PlayReadyDomainJoinServiceRequest
template<typename X> struct statics<PlayReadyDomainJoinServiceRequest, X> : X {
	typedef typename X::root_type PlayReadyDomainJoinServiceRequest;
};
struct PlayReadyDomainJoinServiceRequest : generate<PlayReadyDomainJoinServiceRequest> {};

// IPlayReadyDomainLeaveServiceRequest
struct IPlayReadyDomainLeaveServiceRequest_raw : IInspectable {
	virtual STDMETHODIMP _get_DomainAccountId(Platform::Guid *value);
	virtual STDMETHODIMP _put_DomainAccountId(Platform::Guid value);
	virtual STDMETHODIMP _get_DomainServiceId(Platform::Guid *value);
	virtual STDMETHODIMP _put_DomainServiceId(Platform::Guid value);
};
template<typename X> struct IPlayReadyDomainLeaveServiceRequest_adaptor : X {
	union {
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPlayReadyDomainLeaveServiceRequest_adaptor::DomainAccountId)->_get_DomainAccountId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
			void put(const Platform::Guid& value) { hrcheck(enc(&IPlayReadyDomainLeaveServiceRequest_adaptor::DomainAccountId)->_put_DomainAccountId(value)); }
			void operator=(const Platform::Guid& value) { put(value); }
			void operator()(const Platform::Guid& value) { put(value); }
		} DomainAccountId;
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPlayReadyDomainLeaveServiceRequest_adaptor::DomainServiceId)->_get_DomainServiceId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
			void put(const Platform::Guid& value) { hrcheck(enc(&IPlayReadyDomainLeaveServiceRequest_adaptor::DomainServiceId)->_put_DomainServiceId(value)); }
			void operator=(const Platform::Guid& value) { put(value); }
			void operator()(const Platform::Guid& value) { put(value); }
		} DomainServiceId;
	};
	IPlayReadyDomainLeaveServiceRequest_adaptor() {}
};
template<typename X> struct adapt<IPlayReadyDomainLeaveServiceRequest, X> : Windows::Media::Protection::PlayReady::IPlayReadyDomainLeaveServiceRequest_adaptor<X> { typedef adapt IPlayReadyDomainLeaveServiceRequest; };
struct IPlayReadyDomainLeaveServiceRequest : IPlayReadyDomainLeaveServiceRequest_raw, generate<IPlayReadyDomainLeaveServiceRequest> {};

// PlayReadyDomainLeaveServiceRequest
template<typename X> struct statics<PlayReadyDomainLeaveServiceRequest, X> : X {
	typedef typename X::root_type PlayReadyDomainLeaveServiceRequest;
};
struct PlayReadyDomainLeaveServiceRequest : generate<PlayReadyDomainLeaveServiceRequest> {};

// IPlayReadyLicenseIterableFactory
struct IPlayReadyLicenseIterableFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(PlayReadyContentHeader* contentHeader, bool fullyEvaluated, PlayReadyLicenseIterable* *instance);
};

// IPlayReadyLicense
struct IPlayReadyLicense_raw : IInspectable {
	virtual STDMETHODIMP _get_FullyEvaluated(bool *value) = 0;
	virtual STDMETHODIMP _get_UsableForPlay(bool *value) = 0;
	virtual STDMETHODIMP _get_ExpirationDate(Foundation::IReference<Foundation::DateTime>* *value) = 0;
	virtual STDMETHODIMP _get_ExpireAfterFirstPlay(unsigned *value) = 0;
	virtual STDMETHODIMP _get_DomainAccountID(Platform::Guid *value) = 0;
	virtual STDMETHODIMP _get_ChainDepth(unsigned *value) = 0;
	virtual STDMETHODIMP _GetKIDAtChainDepth(unsigned chainDepth, Platform::Guid *kid) = 0;
};
template<typename X> struct IPlayReadyLicense_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IPlayReadyLicense_adaptor::ChainDepth)->_get_ChainDepth(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} ChainDepth;
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPlayReadyLicense_adaptor::DomainAccountID)->_get_DomainAccountID(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} DomainAccountID;
		struct : property {
			ptr<Foundation::IReference<Foundation::DateTime>> get() { Foundation::IReference<Foundation::DateTime>* value; hrcheck(enc(&IPlayReadyLicense_adaptor::ExpirationDate)->_get_ExpirationDate(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator->() { return get(); }
		} ExpirationDate;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IPlayReadyLicense_adaptor::ExpireAfterFirstPlay)->_get_ExpireAfterFirstPlay(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} ExpireAfterFirstPlay;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPlayReadyLicense_adaptor::FullyEvaluated)->_get_FullyEvaluated(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} FullyEvaluated;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPlayReadyLicense_adaptor::UsableForPlay)->_get_UsableForPlay(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} UsableForPlay;
	};
	Platform::Guid GetKIDAtChainDepth(unsigned chainDepth) { Platform::Guid kid; hrcheck(X::get()->_GetKIDAtChainDepth(chainDepth, &kid)); return kid; }
	IPlayReadyLicense_adaptor() {}
};
template<typename X> struct adapt<IPlayReadyLicense, X> : Windows::Media::Protection::PlayReady::IPlayReadyLicense_adaptor<X> { typedef adapt IPlayReadyLicense; };
template<typename X> struct IPlayReadyLicense_unadaptor : X {
	STDMETHODIMP _get_FullyEvaluated(bool *value) { return hrtry([&, this] { get_prop(value, FullyEvaluated); }); }
	STDMETHODIMP _get_UsableForPlay(bool *value) { return hrtry([&, this] { get_prop(value, UsableForPlay); }); }
	STDMETHODIMP _get_ExpirationDate(Foundation::IReference<Foundation::DateTime>* *value) { return hrtry([&, this] { get_prop(value, ExpirationDate); }); }
	STDMETHODIMP _get_ExpireAfterFirstPlay(unsigned *value) { return hrtry([&, this] { get_prop(value, ExpireAfterFirstPlay); }); }
	STDMETHODIMP _get_DomainAccountID(Platform::Guid *value) { return hrtry([&, this] { get_prop(value, DomainAccountID); }); }
	STDMETHODIMP _get_ChainDepth(unsigned *value) { return hrtry([&, this] { get_prop(value, ChainDepth); }); }
	STDMETHODIMP _GetKIDAtChainDepth(unsigned chainDepth, Platform::Guid *kid) { return hrtry([&, this] { *kid = X::get()->GetKIDAtChainDepth(chainDepth); }); }
};
template<typename X> struct unadapt<IPlayReadyLicense, X> : Windows::Media::Protection::PlayReady::IPlayReadyLicense_unadaptor<X> {};
struct IPlayReadyLicense : IPlayReadyLicense_raw, generate<IPlayReadyLicense> {};

// PlayReadyLicenseIterable
template<typename> struct PlayReadyLicenseIterable_statics {
	static PlayReadyLicenseIterable *activate(pptr<PlayReadyContentHeader> contentHeader, bool fullyEvaluated) { PlayReadyLicenseIterable *instance; hrcheck(get_activation_factory<PlayReadyLicenseIterable, IPlayReadyLicenseIterableFactory>()->_CreateInstance(contentHeader, fullyEvaluated, &instance)); return instance; }
	static PlayReadyLicenseIterable *activate() { PlayReadyLicenseIterable *t; get_activation_factory<PlayReadyLicenseIterable>()->ActivateInstance((IInspectable**)&t); return t; }
};

template<typename X> struct statics<PlayReadyLicenseIterable, X> : X, Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable_statics<void> {
	using Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable_statics<void>::activate;
	typedef typename X::root_type PlayReadyLicenseIterable;
};
struct PlayReadyLicenseIterable : generate<PlayReadyLicenseIterable> {};

// IPlayReadyLicenseAcquisitionServiceRequest
struct IPlayReadyLicenseAcquisitionServiceRequest_raw : IInspectable {
	virtual STDMETHODIMP _get_ContentHeader(PlayReadyContentHeader* *value) = 0;
	virtual STDMETHODIMP _put_ContentHeader(PlayReadyContentHeader* value) = 0;
	virtual STDMETHODIMP _get_DomainServiceId(Platform::Guid *value) = 0;
	virtual STDMETHODIMP _put_DomainServiceId(Platform::Guid value) = 0;
};
template<typename X> struct IPlayReadyLicenseAcquisitionServiceRequest_adaptor : X {
	union {
		struct : property {
			ptr<PlayReadyContentHeader> get() { PlayReadyContentHeader* value; hrcheck(enc(&IPlayReadyLicenseAcquisitionServiceRequest_adaptor::ContentHeader)->_get_ContentHeader(&value)); return from_abi(value); }
			ptr<PlayReadyContentHeader> operator()() { return get(); }
			operator ptr<PlayReadyContentHeader> () { return get(); }
			ptr<PlayReadyContentHeader> operator->() { return get(); }
			void put(pptr<PlayReadyContentHeader> value) { hrcheck(enc(&IPlayReadyLicenseAcquisitionServiceRequest_adaptor::ContentHeader)->_put_ContentHeader(value)); }
			void operator=(pptr<PlayReadyContentHeader> value) { put(value); }
			void operator()(pptr<PlayReadyContentHeader> value) { put(value); }
		} ContentHeader;
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPlayReadyLicenseAcquisitionServiceRequest_adaptor::DomainServiceId)->_get_DomainServiceId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
			void put(const Platform::Guid& value) { hrcheck(enc(&IPlayReadyLicenseAcquisitionServiceRequest_adaptor::DomainServiceId)->_put_DomainServiceId(value)); }
			void operator=(const Platform::Guid& value) { put(value); }
			void operator()(const Platform::Guid& value) { put(value); }
		} DomainServiceId;
	};
	IPlayReadyLicenseAcquisitionServiceRequest_adaptor() {}
};
template<typename X> struct adapt<IPlayReadyLicenseAcquisitionServiceRequest, X> : Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest_adaptor<X> { typedef adapt IPlayReadyLicenseAcquisitionServiceRequest; };
template<typename X> struct IPlayReadyLicenseAcquisitionServiceRequest_unadaptor : X {
	STDMETHODIMP _get_ContentHeader(PlayReadyContentHeader* *value) { return hrtry([&, this] { get_prop(value, ContentHeader); }); }
	STDMETHODIMP _put_ContentHeader(PlayReadyContentHeader* value) { return hrtry([&, this] { put_prop(value, ContentHeader); }); }
	STDMETHODIMP _get_DomainServiceId(Platform::Guid *value) { return hrtry([&, this] { get_prop(value, DomainServiceId); }); }
	STDMETHODIMP _put_DomainServiceId(Platform::Guid value) { return hrtry([&, this] { put_prop(value, DomainServiceId); }); }
};
template<typename X> struct unadapt<IPlayReadyLicenseAcquisitionServiceRequest, X> : Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest_unadaptor<X> {};
struct IPlayReadyLicenseAcquisitionServiceRequest : IPlayReadyLicenseAcquisitionServiceRequest_raw, generate<IPlayReadyLicenseAcquisitionServiceRequest> {};

// IPlayReadyLicenseAcquisitionServiceRequest2
struct IPlayReadyLicenseAcquisitionServiceRequest2_raw : IInspectable {
	virtual STDMETHODIMP _get_SessionId(Platform::Guid *value);
};
template<typename X> struct IPlayReadyLicenseAcquisitionServiceRequest2_adaptor : X {
	union {
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPlayReadyLicenseAcquisitionServiceRequest2_adaptor::SessionId)->_get_SessionId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} SessionId;
	};
	IPlayReadyLicenseAcquisitionServiceRequest2_adaptor() {}
};
template<typename X> struct adapt<IPlayReadyLicenseAcquisitionServiceRequest2, X> : Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest2_adaptor<X> { typedef adapt IPlayReadyLicenseAcquisitionServiceRequest2; };
struct IPlayReadyLicenseAcquisitionServiceRequest2 : IPlayReadyLicenseAcquisitionServiceRequest2_raw, generate<IPlayReadyLicenseAcquisitionServiceRequest2> {};

// IPlayReadyLicenseAcquisitionServiceRequest3
struct IPlayReadyLicenseAcquisitionServiceRequest3_raw : IInspectable {
	virtual STDMETHODIMP _CreateLicenseIterable(PlayReadyContentHeader* contentHeader, bool fullyEvaluated, PlayReadyLicenseIterable* *result);
};
template<typename X> struct IPlayReadyLicenseAcquisitionServiceRequest3_adaptor : X {
	ptr<PlayReadyLicenseIterable> CreateLicenseIterable(pptr<PlayReadyContentHeader> contentHeader, bool fullyEvaluated) { PlayReadyLicenseIterable* result; hrcheck(X::get()->_CreateLicenseIterable(contentHeader, fullyEvaluated, &result)); return from_abi(result); }
};
template<typename X> struct adapt<IPlayReadyLicenseAcquisitionServiceRequest3, X> : Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest3_adaptor<X> { typedef adapt IPlayReadyLicenseAcquisitionServiceRequest3; };
struct IPlayReadyLicenseAcquisitionServiceRequest3 : IPlayReadyLicenseAcquisitionServiceRequest3_raw, generate<IPlayReadyLicenseAcquisitionServiceRequest3> {};

// PlayReadyLicenseAcquisitionServiceRequest
template<typename X> struct statics<PlayReadyLicenseAcquisitionServiceRequest, X> : X {
	typedef typename X::root_type PlayReadyLicenseAcquisitionServiceRequest;
};
struct PlayReadyLicenseAcquisitionServiceRequest : generate<PlayReadyLicenseAcquisitionServiceRequest> {};

// IPlayReadyMeteringReportServiceRequest
struct IPlayReadyMeteringReportServiceRequest_raw : IInspectable {
	virtual STDMETHODIMP _get_MeteringCertificate(unsigned *meteringCertBytesSize, unsigned char **meteringCertBytes);
	virtual STDMETHODIMP _put_MeteringCertificate(unsigned meteringCertBytesSize, unsigned char *meteringCertBytes);
};
template<typename X> struct IPlayReadyMeteringReportServiceRequest_adaptor : X {
	union {
		struct : property {
			szarray<unsigned char> get() { szarray<unsigned char> meteringCertBytes; hrcheck(enc(&IPlayReadyMeteringReportServiceRequest_adaptor::MeteringCertificate)->_get_MeteringCertificate(&meteringCertBytes.size, &meteringCertBytes.p)); return meteringCertBytes; }
			szarray<unsigned char> operator()() { return get(); }
			operator szarray<unsigned char> () { return get(); }
			void put(const szarray<unsigned char>& meteringCertBytes) { hrcheck(enc(&IPlayReadyMeteringReportServiceRequest_adaptor::MeteringCertificate)->_put_MeteringCertificate(meteringCertBytes.size, to_abi(meteringCertBytes.p))); }
			void operator=(const szarray<unsigned char>& meteringCertBytes) { put(meteringCertBytes); }
			void operator()(const szarray<unsigned char>& meteringCertBytes) { put(meteringCertBytes); }
		} MeteringCertificate;
	};
	IPlayReadyMeteringReportServiceRequest_adaptor() {}
};
template<typename X> struct adapt<IPlayReadyMeteringReportServiceRequest, X> : Windows::Media::Protection::PlayReady::IPlayReadyMeteringReportServiceRequest_adaptor<X> { typedef adapt IPlayReadyMeteringReportServiceRequest; };
struct IPlayReadyMeteringReportServiceRequest : IPlayReadyMeteringReportServiceRequest_raw, generate<IPlayReadyMeteringReportServiceRequest> {};

// PlayReadyMeteringReportServiceRequest
template<typename X> struct statics<PlayReadyMeteringReportServiceRequest, X> : X {
	typedef typename X::root_type PlayReadyMeteringReportServiceRequest;
};
struct PlayReadyMeteringReportServiceRequest : generate<PlayReadyMeteringReportServiceRequest> {};

// IPlayReadyRevocationServiceRequest
struct IPlayReadyRevocationServiceRequest : IInspectable, generate<IPlayReadyRevocationServiceRequest> {};

// PlayReadyRevocationServiceRequest
template<typename X> struct statics<PlayReadyRevocationServiceRequest, X> : X {
	typedef typename X::root_type PlayReadyRevocationServiceRequest;
};
struct PlayReadyRevocationServiceRequest : generate<PlayReadyRevocationServiceRequest> {};

// IPlayReadyLicenseManagement
struct IPlayReadyLicenseManagement : IInspectable {
	virtual STDMETHODIMP _DeleteLicenses(PlayReadyContentHeader* contentHeader, Foundation::IAsyncAction* *operation);
};

// PlayReadyLicenseManagement
template<typename> struct PlayReadyLicenseManagement_statics {
	static ptr<Foundation::IAsyncAction> DeleteLicenses(pptr<PlayReadyContentHeader> contentHeader) { Foundation::IAsyncAction* operation; hrcheck(get_activation_factory<PlayReadyLicenseManagement, IPlayReadyLicenseManagement>()->_DeleteLicenses(contentHeader, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<PlayReadyLicenseManagement, X> : X, Windows::Media::Protection::PlayReady::PlayReadyLicenseManagement_statics<void> {
	typedef typename X::root_type PlayReadyLicenseManagement;
};
struct PlayReadyLicenseManagement : generate<PlayReadyLicenseManagement> {};

// IPlayReadyLicense2
struct IPlayReadyLicense2_raw : IInspectable {
	virtual STDMETHODIMP _get_SecureStopId(Platform::Guid *value);
	virtual STDMETHODIMP _get_SecurityLevel(unsigned *value);
	virtual STDMETHODIMP _get_InMemoryOnly(bool *value);
	virtual STDMETHODIMP _get_ExpiresInRealTime(bool *value);
};
template<typename X> struct IPlayReadyLicense2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPlayReadyLicense2_adaptor::ExpiresInRealTime)->_get_ExpiresInRealTime(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} ExpiresInRealTime;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPlayReadyLicense2_adaptor::InMemoryOnly)->_get_InMemoryOnly(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} InMemoryOnly;
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPlayReadyLicense2_adaptor::SecureStopId)->_get_SecureStopId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} SecureStopId;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IPlayReadyLicense2_adaptor::SecurityLevel)->_get_SecurityLevel(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} SecurityLevel;
	};
	IPlayReadyLicense2_adaptor() {}
};
template<typename X> struct adapt<IPlayReadyLicense2, X> : Windows::Media::Protection::PlayReady::IPlayReadyLicense2_adaptor<X> { typedef adapt IPlayReadyLicense2; };
struct IPlayReadyLicense2 : IPlayReadyLicense2_raw, generate<IPlayReadyLicense2> {};

// PlayReadyLicense
template<typename X> struct statics<PlayReadyLicense, X> : X {
	typedef typename X::root_type PlayReadyLicense;
};
struct PlayReadyLicense : generate<PlayReadyLicense> {};

// PlayReadyLicenseIterator
template<typename X> struct statics<PlayReadyLicenseIterator, X> : X {
	typedef typename X::root_type PlayReadyLicenseIterator;
};
struct PlayReadyLicenseIterator : generate<PlayReadyLicenseIterator> {};

// IPlayReadyDomain
struct IPlayReadyDomain_raw : IInspectable {
	virtual STDMETHODIMP _get_AccountId(Platform::Guid *value) = 0;
	virtual STDMETHODIMP _get_ServiceId(Platform::Guid *value) = 0;
	virtual STDMETHODIMP _get_Revision(unsigned *value) = 0;
	virtual STDMETHODIMP _get_FriendlyName(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_DomainJoinUrl(Foundation::Uri* *value) = 0;
};
template<typename X> struct IPlayReadyDomain_adaptor : X {
	union {
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPlayReadyDomain_adaptor::AccountId)->_get_AccountId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} AccountId;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IPlayReadyDomain_adaptor::DomainJoinUrl)->_get_DomainJoinUrl(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} DomainJoinUrl;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPlayReadyDomain_adaptor::FriendlyName)->_get_FriendlyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} FriendlyName;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IPlayReadyDomain_adaptor::Revision)->_get_Revision(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Revision;
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPlayReadyDomain_adaptor::ServiceId)->_get_ServiceId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} ServiceId;
	};
	IPlayReadyDomain_adaptor() {}
};
template<typename X> struct adapt<IPlayReadyDomain, X> : Windows::Media::Protection::PlayReady::IPlayReadyDomain_adaptor<X> { typedef adapt IPlayReadyDomain; };
template<typename X> struct IPlayReadyDomain_unadaptor : X {
	STDMETHODIMP _get_AccountId(Platform::Guid *value) { return hrtry([&, this] { get_prop(value, AccountId); }); }
	STDMETHODIMP _get_ServiceId(Platform::Guid *value) { return hrtry([&, this] { get_prop(value, ServiceId); }); }
	STDMETHODIMP _get_Revision(unsigned *value) { return hrtry([&, this] { get_prop(value, Revision); }); }
	STDMETHODIMP _get_FriendlyName(HSTRING *value) { return hrtry([&, this] { get_prop(value, FriendlyName); }); }
	STDMETHODIMP _get_DomainJoinUrl(Foundation::Uri* *value) { return hrtry([&, this] { get_prop(value, DomainJoinUrl); }); }
};
template<typename X> struct unadapt<IPlayReadyDomain, X> : Windows::Media::Protection::PlayReady::IPlayReadyDomain_unadaptor<X> {};
struct IPlayReadyDomain : IPlayReadyDomain_raw, generate<IPlayReadyDomain> {};

// PlayReadyDomain
template<typename X> struct statics<PlayReadyDomain, X> : X {
	typedef typename X::root_type PlayReadyDomain;
};
struct PlayReadyDomain : generate<PlayReadyDomain> {};

// IPlayReadyDomainIterableFactory
struct IPlayReadyDomainIterableFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(Platform::Guid domainAccountId, PlayReadyDomainIterable* *domainIterable);
};

// PlayReadyDomainIterable
template<typename> struct PlayReadyDomainIterable_statics {
	static PlayReadyDomainIterable *activate(const Platform::Guid& domainAccountId) { PlayReadyDomainIterable *domainIterable; hrcheck(get_activation_factory<PlayReadyDomainIterable, IPlayReadyDomainIterableFactory>()->_CreateInstance(domainAccountId, &domainIterable)); return domainIterable; }
};

template<typename X> struct statics<PlayReadyDomainIterable, X> : X, Windows::Media::Protection::PlayReady::PlayReadyDomainIterable_statics<void> {
	using Windows::Media::Protection::PlayReady::PlayReadyDomainIterable_statics<void>::activate;
	typedef typename X::root_type PlayReadyDomainIterable;
};
struct PlayReadyDomainIterable : generate<PlayReadyDomainIterable> {};

// PlayReadyDomainIterator
template<typename X> struct statics<PlayReadyDomainIterator, X> : X {
	typedef typename X::root_type PlayReadyDomainIterator;
};
struct PlayReadyDomainIterator : generate<PlayReadyDomainIterator> {};

// IPlayReadyStatics
struct IPlayReadyStatics : IInspectable {
	virtual STDMETHODIMP _get_DomainJoinServiceRequestType(Platform::Guid *value);
	virtual STDMETHODIMP _get_DomainLeaveServiceRequestType(Platform::Guid *value);
	virtual STDMETHODIMP _get_IndividualizationServiceRequestType(Platform::Guid *value);
	virtual STDMETHODIMP _get_LicenseAcquirerServiceRequestType(Platform::Guid *value);
	virtual STDMETHODIMP _get_MeteringReportServiceRequestType(Platform::Guid *value);
	virtual STDMETHODIMP _get_RevocationServiceRequestType(Platform::Guid *value);
	virtual STDMETHODIMP _get_MediaProtectionSystemId(Platform::Guid *value);
	virtual STDMETHODIMP _get_PlayReadySecurityVersion(unsigned *value);
};

// IPlayReadyStatics2
struct IPlayReadyStatics2 : IInspectable {
	virtual STDMETHODIMP _get_PlayReadyCertificateSecurityLevel(unsigned *value);
};

// IPlayReadyStatics3
struct IPlayReadyStatics3 : IInspectable {
	virtual STDMETHODIMP _get_SecureStopServiceRequestType(Platform::Guid *value);
	virtual STDMETHODIMP _CheckSupportedHardware(PlayReadyHardwareDRMFeatures hwdrmFeature, bool *value);
};

// IPlayReadyStatics4
struct IPlayReadyStatics4 : IInspectable {
	virtual STDMETHODIMP _get_InputTrustAuthorityToCreate(HSTRING *value);
	virtual STDMETHODIMP _get_ProtectionSystemId(Platform::Guid *value);
};

// PlayReadyStatics
template<typename> struct PlayReadyStatics_statics {
	static struct _DomainJoinServiceRequestType : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<PlayReadyStatics, IPlayReadyStatics>()->_get_DomainJoinServiceRequestType(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} DomainJoinServiceRequestType;
	static struct _DomainLeaveServiceRequestType : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<PlayReadyStatics, IPlayReadyStatics>()->_get_DomainLeaveServiceRequestType(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} DomainLeaveServiceRequestType;
	static struct _IndividualizationServiceRequestType : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<PlayReadyStatics, IPlayReadyStatics>()->_get_IndividualizationServiceRequestType(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} IndividualizationServiceRequestType;
	static struct _LicenseAcquirerServiceRequestType : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<PlayReadyStatics, IPlayReadyStatics>()->_get_LicenseAcquirerServiceRequestType(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} LicenseAcquirerServiceRequestType;
	static struct _MediaProtectionSystemId : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<PlayReadyStatics, IPlayReadyStatics>()->_get_MediaProtectionSystemId(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} MediaProtectionSystemId;
	static struct _MeteringReportServiceRequestType : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<PlayReadyStatics, IPlayReadyStatics>()->_get_MeteringReportServiceRequestType(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} MeteringReportServiceRequestType;
	static struct _PlayReadySecurityVersion : property {
		unsigned get() { unsigned value; hrcheck(get_activation_factory<PlayReadyStatics, IPlayReadyStatics>()->_get_PlayReadySecurityVersion(&value)); return value; }
		unsigned operator()() { return get(); }
		operator unsigned () { return get(); }
	} PlayReadySecurityVersion;
	static struct _RevocationServiceRequestType : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<PlayReadyStatics, IPlayReadyStatics>()->_get_RevocationServiceRequestType(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} RevocationServiceRequestType;
	static struct _PlayReadyCertificateSecurityLevel : property {
		unsigned get() { unsigned value; hrcheck(get_activation_factory<PlayReadyStatics, IPlayReadyStatics2>()->_get_PlayReadyCertificateSecurityLevel(&value)); return value; }
		unsigned operator()() { return get(); }
		operator unsigned () { return get(); }
	} PlayReadyCertificateSecurityLevel;
	static struct _SecureStopServiceRequestType : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<PlayReadyStatics, IPlayReadyStatics3>()->_get_SecureStopServiceRequestType(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} SecureStopServiceRequestType;
	static struct _InputTrustAuthorityToCreate : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<PlayReadyStatics, IPlayReadyStatics4>()->_get_InputTrustAuthorityToCreate(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} InputTrustAuthorityToCreate;
	static struct _ProtectionSystemId : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<PlayReadyStatics, IPlayReadyStatics4>()->_get_ProtectionSystemId(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} ProtectionSystemId;
	static bool CheckSupportedHardware(PlayReadyHardwareDRMFeatures hwdrmFeature) { bool value; hrcheck(get_activation_factory<PlayReadyStatics, IPlayReadyStatics3>()->_CheckSupportedHardware(hwdrmFeature, &value)); return value; }
};
template<typename X> typename PlayReadyStatics_statics<X>::_DomainJoinServiceRequestType PlayReadyStatics_statics<X>::DomainJoinServiceRequestType;
template<typename X> typename PlayReadyStatics_statics<X>::_DomainLeaveServiceRequestType PlayReadyStatics_statics<X>::DomainLeaveServiceRequestType;
template<typename X> typename PlayReadyStatics_statics<X>::_IndividualizationServiceRequestType PlayReadyStatics_statics<X>::IndividualizationServiceRequestType;
template<typename X> typename PlayReadyStatics_statics<X>::_LicenseAcquirerServiceRequestType PlayReadyStatics_statics<X>::LicenseAcquirerServiceRequestType;
template<typename X> typename PlayReadyStatics_statics<X>::_MediaProtectionSystemId PlayReadyStatics_statics<X>::MediaProtectionSystemId;
template<typename X> typename PlayReadyStatics_statics<X>::_MeteringReportServiceRequestType PlayReadyStatics_statics<X>::MeteringReportServiceRequestType;
template<typename X> typename PlayReadyStatics_statics<X>::_PlayReadySecurityVersion PlayReadyStatics_statics<X>::PlayReadySecurityVersion;
template<typename X> typename PlayReadyStatics_statics<X>::_RevocationServiceRequestType PlayReadyStatics_statics<X>::RevocationServiceRequestType;
template<typename X> typename PlayReadyStatics_statics<X>::_PlayReadyCertificateSecurityLevel PlayReadyStatics_statics<X>::PlayReadyCertificateSecurityLevel;
template<typename X> typename PlayReadyStatics_statics<X>::_SecureStopServiceRequestType PlayReadyStatics_statics<X>::SecureStopServiceRequestType;
template<typename X> typename PlayReadyStatics_statics<X>::_InputTrustAuthorityToCreate PlayReadyStatics_statics<X>::InputTrustAuthorityToCreate;
template<typename X> typename PlayReadyStatics_statics<X>::_ProtectionSystemId PlayReadyStatics_statics<X>::ProtectionSystemId;

template<typename X> struct statics<PlayReadyStatics, X> : X, Windows::Media::Protection::PlayReady::PlayReadyStatics_statics<void> {
	typedef typename X::root_type PlayReadyStatics;
};
struct PlayReadyStatics : generate<PlayReadyStatics> {};

// IPlayReadySecureStopServiceRequestFactory
struct IPlayReadySecureStopServiceRequestFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(unsigned publisherCertBytesSize, unsigned char *publisherCertBytes, PlayReadySecureStopServiceRequest* *instance);
	virtual STDMETHODIMP _CreateInstanceFromSessionID(Platform::Guid sessionID, unsigned publisherCertBytesSize, unsigned char *publisherCertBytes, PlayReadySecureStopServiceRequest* *instance);
};

// IPlayReadySecureStopServiceRequest
struct IPlayReadySecureStopServiceRequest_raw : IInspectable {
	virtual STDMETHODIMP _get_SessionID(Platform::Guid *value) = 0;
	virtual STDMETHODIMP _get_StartTime(Foundation::DateTime *value) = 0;
	virtual STDMETHODIMP _get_UpdateTime(Foundation::DateTime *value) = 0;
	virtual STDMETHODIMP _get_Stopped(bool *value) = 0;
	virtual STDMETHODIMP _get_PublisherCertificate(unsigned *publisherCertBytesSize, unsigned char **publisherCertBytes) = 0;
};
template<typename X> struct IPlayReadySecureStopServiceRequest_adaptor : X {
	union {
		struct : property {
			szarray<unsigned char> get() { szarray<unsigned char> publisherCertBytes; hrcheck(enc(&IPlayReadySecureStopServiceRequest_adaptor::PublisherCertificate)->_get_PublisherCertificate(&publisherCertBytes.size, &publisherCertBytes.p)); return publisherCertBytes; }
			szarray<unsigned char> operator()() { return get(); }
			operator szarray<unsigned char> () { return get(); }
		} PublisherCertificate;
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPlayReadySecureStopServiceRequest_adaptor::SessionID)->_get_SessionID(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} SessionID;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IPlayReadySecureStopServiceRequest_adaptor::StartTime)->_get_StartTime(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} StartTime;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPlayReadySecureStopServiceRequest_adaptor::Stopped)->_get_Stopped(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Stopped;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IPlayReadySecureStopServiceRequest_adaptor::UpdateTime)->_get_UpdateTime(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} UpdateTime;
	};
	IPlayReadySecureStopServiceRequest_adaptor() {}
};
template<typename X> struct adapt<IPlayReadySecureStopServiceRequest, X> : Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest_adaptor<X> { typedef adapt IPlayReadySecureStopServiceRequest; };
template<typename X> struct IPlayReadySecureStopServiceRequest_unadaptor : X {
	STDMETHODIMP _get_SessionID(Platform::Guid *value) { return hrtry([&, this] { get_prop(value, SessionID); }); }
	STDMETHODIMP _get_StartTime(Foundation::DateTime *value) { return hrtry([&, this] { get_prop(value, StartTime); }); }
	STDMETHODIMP _get_UpdateTime(Foundation::DateTime *value) { return hrtry([&, this] { get_prop(value, UpdateTime); }); }
	STDMETHODIMP _get_Stopped(bool *value) { return hrtry([&, this] { get_prop(value, Stopped); }); }
	STDMETHODIMP _get_PublisherCertificate(unsigned *publisherCertBytesSize, unsigned char **publisherCertBytes) { return hrtry([&, this] { get_prop(publisherCertBytes, PublisherCertificate); }); }
};
template<typename X> struct unadapt<IPlayReadySecureStopServiceRequest, X> : Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest_unadaptor<X> {};
struct IPlayReadySecureStopServiceRequest : IPlayReadySecureStopServiceRequest_raw, generate<IPlayReadySecureStopServiceRequest> {};

// PlayReadySecureStopServiceRequest
template<typename> struct PlayReadySecureStopServiceRequest_statics {
	static PlayReadySecureStopServiceRequest *activate(const szarray<unsigned char>& publisherCertBytes) { PlayReadySecureStopServiceRequest *instance; hrcheck(get_activation_factory<PlayReadySecureStopServiceRequest, IPlayReadySecureStopServiceRequestFactory>()->_CreateInstance(publisherCertBytes.size, to_abi(publisherCertBytes.p), &instance)); return instance; }
	static PlayReadySecureStopServiceRequest *activate(const Platform::Guid& sessionID, const szarray<unsigned char>& publisherCertBytes) { PlayReadySecureStopServiceRequest *instance; hrcheck(get_activation_factory<PlayReadySecureStopServiceRequest, IPlayReadySecureStopServiceRequestFactory>()->_CreateInstanceFromSessionID(sessionID, publisherCertBytes.size, to_abi(publisherCertBytes.p), &instance)); return instance; }
};

template<typename X> struct statics<PlayReadySecureStopServiceRequest, X> : X, Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest_statics<void> {
	using Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest_statics<void>::activate;
	typedef typename X::root_type PlayReadySecureStopServiceRequest;
};
struct PlayReadySecureStopServiceRequest : generate<PlayReadySecureStopServiceRequest> {};

// IPlayReadySecureStopIterableFactory
struct IPlayReadySecureStopIterableFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(unsigned publisherCertBytesSize, unsigned char *publisherCertBytes, PlayReadySecureStopIterable* *instance);
};

// PlayReadySecureStopIterable
template<typename> struct PlayReadySecureStopIterable_statics {
	static PlayReadySecureStopIterable *activate(const szarray<unsigned char>& publisherCertBytes) { PlayReadySecureStopIterable *instance; hrcheck(get_activation_factory<PlayReadySecureStopIterable, IPlayReadySecureStopIterableFactory>()->_CreateInstance(publisherCertBytes.size, to_abi(publisherCertBytes.p), &instance)); return instance; }
};

template<typename X> struct statics<PlayReadySecureStopIterable, X> : X, Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable_statics<void> {
	using Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable_statics<void>::activate;
	typedef typename X::root_type PlayReadySecureStopIterable;
};
struct PlayReadySecureStopIterable : generate<PlayReadySecureStopIterable> {};

// PlayReadySecureStopIterator
template<typename X> struct statics<PlayReadySecureStopIterator, X> : X {
	typedef typename X::root_type PlayReadySecureStopIterator;
};
struct PlayReadySecureStopIterator : generate<PlayReadySecureStopIterator> {};

// IPlayReadyITADataGenerator
struct IPlayReadyITADataGenerator_raw : IInspectable {
	virtual STDMETHODIMP _GenerateData(Platform::Guid guidCPSystemId, unsigned countOfStreams, Foundation::Collections::IPropertySet* configuration, PlayReadyITADataFormat format, unsigned *dataBytesSize, unsigned char **dataBytes);
};
template<typename X> struct IPlayReadyITADataGenerator_adaptor : X {
	szarray<unsigned char> GenerateData(const Platform::Guid& guidCPSystemId, unsigned countOfStreams, pptr<Foundation::Collections::IPropertySet> configuration, PlayReadyITADataFormat format) { szarray<unsigned char> dataBytes; hrcheck(X::get()->_GenerateData(guidCPSystemId, countOfStreams, configuration, format, &dataBytes.size, &dataBytes.p)); return dataBytes; }
};
template<typename X> struct adapt<IPlayReadyITADataGenerator, X> : Windows::Media::Protection::PlayReady::IPlayReadyITADataGenerator_adaptor<X> { typedef adapt IPlayReadyITADataGenerator; };
struct IPlayReadyITADataGenerator : IPlayReadyITADataGenerator_raw, generate<IPlayReadyITADataGenerator> {};

// PlayReadyITADataGenerator
template<typename X> struct statics<PlayReadyITADataGenerator, X> : X {
	typedef typename X::root_type PlayReadyITADataGenerator;
};
struct PlayReadyITADataGenerator : generate<PlayReadyITADataGenerator> {};

// IPlayReadyLicenseSession
struct IPlayReadyLicenseSession_raw : IInspectable {
	virtual STDMETHODIMP _CreateLAServiceRequest(IPlayReadyLicenseAcquisitionServiceRequest* *serviceRequest) = 0;
	virtual STDMETHODIMP _ConfigureMediaProtectionManager(MediaProtectionManager* mpm) = 0;
};
template<typename X> struct IPlayReadyLicenseSession_adaptor : X {
	ptr<IPlayReadyLicenseAcquisitionServiceRequest> CreateLAServiceRequest() { IPlayReadyLicenseAcquisitionServiceRequest* serviceRequest; hrcheck(X::get()->_CreateLAServiceRequest(&serviceRequest)); return from_abi(serviceRequest); }
	void ConfigureMediaProtectionManager(pptr<MediaProtectionManager> mpm) { hrcheck(X::get()->_ConfigureMediaProtectionManager(mpm)); }
};
template<typename X> struct adapt<IPlayReadyLicenseSession, X> : Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession_adaptor<X> { typedef adapt IPlayReadyLicenseSession; };
template<typename X> struct IPlayReadyLicenseSession_unadaptor : X {
	STDMETHODIMP _CreateLAServiceRequest(IPlayReadyLicenseAcquisitionServiceRequest* *serviceRequest) { return hrtry([&, this] { *serviceRequest = to_abi(X::get()->CreateLAServiceRequest()); }); }
	STDMETHODIMP _ConfigureMediaProtectionManager(MediaProtectionManager* mpm) { return hrtry([&, this] { X::get()->ConfigureMediaProtectionManager(mpm); }); }
};
template<typename X> struct unadapt<IPlayReadyLicenseSession, X> : Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession_unadaptor<X> {};
struct IPlayReadyLicenseSession : IPlayReadyLicenseSession_raw, generate<IPlayReadyLicenseSession> {};

// IPlayReadyLicenseSession2
struct IPlayReadyLicenseSession2_raw : IInspectable {
	virtual STDMETHODIMP _CreateLicenseIterable(PlayReadyContentHeader* contentHeader, bool fullyEvaluated, PlayReadyLicenseIterable* *licenseIterable) = 0;
};
template<typename X> struct IPlayReadyLicenseSession2_adaptor : X {
	ptr<PlayReadyLicenseIterable> CreateLicenseIterable(pptr<PlayReadyContentHeader> contentHeader, bool fullyEvaluated) { PlayReadyLicenseIterable* licenseIterable; hrcheck(X::get()->_CreateLicenseIterable(contentHeader, fullyEvaluated, &licenseIterable)); return from_abi(licenseIterable); }
};
template<typename X> struct adapt<IPlayReadyLicenseSession2, X> : Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2_adaptor<X> { typedef adapt IPlayReadyLicenseSession2; };
template<typename X> struct IPlayReadyLicenseSession2_unadaptor : X {
	STDMETHODIMP _CreateLicenseIterable(PlayReadyContentHeader* contentHeader, bool fullyEvaluated, PlayReadyLicenseIterable* *licenseIterable) { return hrtry([&, this] { *licenseIterable = to_abi(X::get()->CreateLicenseIterable(contentHeader, fullyEvaluated)); }); }
};
template<typename X> struct unadapt<IPlayReadyLicenseSession2, X> : Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2_unadaptor<X> {};
struct IPlayReadyLicenseSession2 : IPlayReadyLicenseSession2_raw, generate<IPlayReadyLicenseSession2> {};

// IPlayReadyLicenseSessionFactory
struct IPlayReadyLicenseSessionFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(Foundation::Collections::IPropertySet* configuration, PlayReadyLicenseSession* *instance);
};

// PlayReadyLicenseSession
template<typename> struct PlayReadyLicenseSession_statics {
	static PlayReadyLicenseSession *activate(pptr<Foundation::Collections::IPropertySet> configuration) { PlayReadyLicenseSession *instance; hrcheck(get_activation_factory<PlayReadyLicenseSession, IPlayReadyLicenseSessionFactory>()->_CreateInstance(configuration, &instance)); return instance; }
};

template<typename X> struct statics<PlayReadyLicenseSession, X> : X, Windows::Media::Protection::PlayReady::PlayReadyLicenseSession_statics<void> {
	using Windows::Media::Protection::PlayReady::PlayReadyLicenseSession_statics<void>::activate;
	typedef typename X::root_type PlayReadyLicenseSession;
};
struct PlayReadyLicenseSession : generate<PlayReadyLicenseSession> {};

// INDDownloadEngine
struct INDDownloadEngine_raw : IInspectable {
	virtual STDMETHODIMP _Open(Foundation::Uri* uri, unsigned sessionIDBytesSize, unsigned char *sessionIDBytes) = 0;
	virtual STDMETHODIMP _Pause() = 0;
	virtual STDMETHODIMP _Resume() = 0;
	virtual STDMETHODIMP _Close() = 0;
	virtual STDMETHODIMP _Seek(Foundation::TimeSpan startPosition) = 0;
	virtual STDMETHODIMP _get_CanSeek(bool *canSeek) = 0;
	virtual STDMETHODIMP _get_BufferFullMinThresholdInSamples(unsigned *bufferFullMinThreshold) = 0;
	virtual STDMETHODIMP _get_BufferFullMaxThresholdInSamples(unsigned *bufferFullMaxThreshold) = 0;
	virtual STDMETHODIMP _get_Notifier(NDDownloadEngineNotifier* *instance) = 0;
};
template<typename X> struct INDDownloadEngine_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned bufferFullMaxThreshold; hrcheck(enc(&INDDownloadEngine_adaptor::BufferFullMaxThresholdInSamples)->_get_BufferFullMaxThresholdInSamples(&bufferFullMaxThreshold)); return bufferFullMaxThreshold; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} BufferFullMaxThresholdInSamples;
		struct : property {
			unsigned get() { unsigned bufferFullMinThreshold; hrcheck(enc(&INDDownloadEngine_adaptor::BufferFullMinThresholdInSamples)->_get_BufferFullMinThresholdInSamples(&bufferFullMinThreshold)); return bufferFullMinThreshold; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} BufferFullMinThresholdInSamples;
		struct : property {
			bool get() { bool canSeek; hrcheck(enc(&INDDownloadEngine_adaptor::CanSeek)->_get_CanSeek(&canSeek)); return canSeek; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanSeek;
		struct : property {
			ptr<NDDownloadEngineNotifier> get() { NDDownloadEngineNotifier* instance; hrcheck(enc(&INDDownloadEngine_adaptor::Notifier)->_get_Notifier(&instance)); return from_abi(instance); }
			ptr<NDDownloadEngineNotifier> operator()() { return get(); }
			operator ptr<NDDownloadEngineNotifier> () { return get(); }
			ptr<NDDownloadEngineNotifier> operator->() { return get(); }
		} Notifier;
	};
	void Open(pptr<Foundation::Uri> uri, const szarray<unsigned char>& sessionIDBytes) { hrcheck(X::get()->_Open(uri, sessionIDBytes.size, to_abi(sessionIDBytes.p))); }
	void Pause() { hrcheck(X::get()->_Pause()); }
	void Resume() { hrcheck(X::get()->_Resume()); }
	void Close() { hrcheck(X::get()->_Close()); }
	void Seek(const Foundation::TimeSpan& startPosition) { hrcheck(X::get()->_Seek(startPosition)); }
	INDDownloadEngine_adaptor() {}
};
template<typename X> struct adapt<INDDownloadEngine, X> : Windows::Media::Protection::PlayReady::INDDownloadEngine_adaptor<X> { typedef adapt INDDownloadEngine; };
template<typename X> struct INDDownloadEngine_unadaptor : X {
	STDMETHODIMP _Open(Foundation::Uri* uri, unsigned sessionIDBytesSize, unsigned char *sessionIDBytes) { return hrtry([&, this] { X::get()->Open(uri, {(unsigned char*)sessionIDBytes, sessionIDBytesSize}); }); }
	STDMETHODIMP _Pause() { return hrtry([&, this] { X::get()->Pause(); }); }
	STDMETHODIMP _Resume() { return hrtry([&, this] { X::get()->Resume(); }); }
	STDMETHODIMP _Close() { return hrtry([&, this] { X::get()->Close(); }); }
	STDMETHODIMP _Seek(Foundation::TimeSpan startPosition) { return hrtry([&, this] { X::get()->Seek(startPosition); }); }
	STDMETHODIMP _get_CanSeek(bool *canSeek) { return hrtry([&, this] { get_prop(canSeek, CanSeek); }); }
	STDMETHODIMP _get_BufferFullMinThresholdInSamples(unsigned *bufferFullMinThreshold) { return hrtry([&, this] { get_prop(bufferFullMinThreshold, BufferFullMinThresholdInSamples); }); }
	STDMETHODIMP _get_BufferFullMaxThresholdInSamples(unsigned *bufferFullMaxThreshold) { return hrtry([&, this] { get_prop(bufferFullMaxThreshold, BufferFullMaxThresholdInSamples); }); }
	STDMETHODIMP _get_Notifier(NDDownloadEngineNotifier* *instance) { return hrtry([&, this] { get_prop(instance, Notifier); }); }
};
template<typename X> struct unadapt<INDDownloadEngine, X> : Windows::Media::Protection::PlayReady::INDDownloadEngine_unadaptor<X> {};
struct INDDownloadEngine : INDDownloadEngine_raw, generate<INDDownloadEngine> {};

// INDDownloadEngineNotifier
struct INDDownloadEngineNotifier_raw : IInspectable {
	virtual STDMETHODIMP _OnStreamOpened() = 0;
	virtual STDMETHODIMP _OnPlayReadyObjectReceived(unsigned dataBytesSize, unsigned char *dataBytes) = 0;
	virtual STDMETHODIMP _OnContentIDReceived(INDLicenseFetchDescriptor* licenseFetchDescriptor) = 0;
	virtual STDMETHODIMP _OnDataReceived(unsigned dataBytesSize, unsigned char *dataBytes, unsigned bytesReceived) = 0;
	virtual STDMETHODIMP _OnEndOfStream() = 0;
	virtual STDMETHODIMP _OnNetworkError() = 0;
};
template<typename X> struct INDDownloadEngineNotifier_adaptor : X {
	void OnStreamOpened() { hrcheck(X::get()->_OnStreamOpened()); }
	void OnPlayReadyObjectReceived(const szarray<unsigned char>& dataBytes) { hrcheck(X::get()->_OnPlayReadyObjectReceived(dataBytes.size, to_abi(dataBytes.p))); }
	void OnContentIDReceived(pptr<INDLicenseFetchDescriptor> licenseFetchDescriptor) { hrcheck(X::get()->_OnContentIDReceived(licenseFetchDescriptor)); }
	void OnDataReceived(const szarray<unsigned char>& dataBytes, unsigned bytesReceived) { hrcheck(X::get()->_OnDataReceived(dataBytes.size, to_abi(dataBytes.p), bytesReceived)); }
	void OnEndOfStream() { hrcheck(X::get()->_OnEndOfStream()); }
	void OnNetworkError() { hrcheck(X::get()->_OnNetworkError()); }
};
template<typename X> struct adapt<INDDownloadEngineNotifier, X> : Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier_adaptor<X> { typedef adapt INDDownloadEngineNotifier; };
template<typename X> struct INDDownloadEngineNotifier_unadaptor : X {
	STDMETHODIMP _OnStreamOpened() { return hrtry([&, this] { X::get()->OnStreamOpened(); }); }
	STDMETHODIMP _OnPlayReadyObjectReceived(unsigned dataBytesSize, unsigned char *dataBytes) { return hrtry([&, this] { X::get()->OnPlayReadyObjectReceived({(unsigned char*)dataBytes, dataBytesSize}); }); }
	STDMETHODIMP _OnContentIDReceived(INDLicenseFetchDescriptor* licenseFetchDescriptor) { return hrtry([&, this] { X::get()->OnContentIDReceived(licenseFetchDescriptor); }); }
	STDMETHODIMP _OnDataReceived(unsigned dataBytesSize, unsigned char *dataBytes, unsigned bytesReceived) { return hrtry([&, this] { X::get()->OnDataReceived({(unsigned char*)dataBytes, dataBytesSize}, bytesReceived); }); }
	STDMETHODIMP _OnEndOfStream() { return hrtry([&, this] { X::get()->OnEndOfStream(); }); }
	STDMETHODIMP _OnNetworkError() { return hrtry([&, this] { X::get()->OnNetworkError(); }); }
};
template<typename X> struct unadapt<INDDownloadEngineNotifier, X> : Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier_unadaptor<X> {};
struct INDDownloadEngineNotifier : INDDownloadEngineNotifier_raw, generate<INDDownloadEngineNotifier> {};

// NDDownloadEngineNotifier
template<typename X> struct statics<NDDownloadEngineNotifier, X> : X {
	typedef typename X::root_type NDDownloadEngineNotifier;
};
struct NDDownloadEngineNotifier : generate<NDDownloadEngineNotifier> {};

// INDLicenseFetchDescriptor
struct INDLicenseFetchDescriptor_raw : IInspectable {
	virtual STDMETHODIMP _get_ContentIDType(NDContentIDType *contentIDType) = 0;
	virtual STDMETHODIMP _get_ContentID(unsigned *contentIDBytesSize, unsigned char **contentIDBytes) = 0;
	virtual STDMETHODIMP _get_LicenseFetchChallengeCustomData(INDCustomData* *licenseFetchChallengeCustomData) = 0;
	virtual STDMETHODIMP _put_LicenseFetchChallengeCustomData(INDCustomData* licenseFetchChallengeCustomData) = 0;
};
template<typename X> struct INDLicenseFetchDescriptor_adaptor : X {
	union {
		struct : property {
			szarray<unsigned char> get() { szarray<unsigned char> contentIDBytes; hrcheck(enc(&INDLicenseFetchDescriptor_adaptor::ContentID)->_get_ContentID(&contentIDBytes.size, &contentIDBytes.p)); return contentIDBytes; }
			szarray<unsigned char> operator()() { return get(); }
			operator szarray<unsigned char> () { return get(); }
		} ContentID;
		struct : property {
			NDContentIDType get() { NDContentIDType contentIDType; hrcheck(enc(&INDLicenseFetchDescriptor_adaptor::ContentIDType)->_get_ContentIDType(&contentIDType)); return contentIDType; }
			NDContentIDType operator()() { return get(); }
			operator NDContentIDType () { return get(); }
		} ContentIDType;
		struct : property {
			ptr<INDCustomData> get() { INDCustomData* licenseFetchChallengeCustomData; hrcheck(enc(&INDLicenseFetchDescriptor_adaptor::LicenseFetchChallengeCustomData)->_get_LicenseFetchChallengeCustomData(&licenseFetchChallengeCustomData)); return from_abi(licenseFetchChallengeCustomData); }
			ptr<INDCustomData> operator()() { return get(); }
			operator ptr<INDCustomData> () { return get(); }
			ptr<INDCustomData> operator->() { return get(); }
			void put(pptr<INDCustomData> licenseFetchChallengeCustomData) { hrcheck(enc(&INDLicenseFetchDescriptor_adaptor::LicenseFetchChallengeCustomData)->_put_LicenseFetchChallengeCustomData(licenseFetchChallengeCustomData)); }
			void operator=(pptr<INDCustomData> licenseFetchChallengeCustomData) { put(licenseFetchChallengeCustomData); }
			void operator()(pptr<INDCustomData> licenseFetchChallengeCustomData) { put(licenseFetchChallengeCustomData); }
		} LicenseFetchChallengeCustomData;
	};
	INDLicenseFetchDescriptor_adaptor() {}
};
template<typename X> struct adapt<INDLicenseFetchDescriptor, X> : Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor_adaptor<X> { typedef adapt INDLicenseFetchDescriptor; };
template<typename X> struct INDLicenseFetchDescriptor_unadaptor : X {
	STDMETHODIMP _get_ContentIDType(NDContentIDType *contentIDType) { return hrtry([&, this] { get_prop(contentIDType, ContentIDType); }); }
	STDMETHODIMP _get_ContentID(unsigned *contentIDBytesSize, unsigned char **contentIDBytes) { return hrtry([&, this] { get_prop(contentIDBytes, ContentID); }); }
	STDMETHODIMP _get_LicenseFetchChallengeCustomData(INDCustomData* *licenseFetchChallengeCustomData) { return hrtry([&, this] { get_prop(licenseFetchChallengeCustomData, LicenseFetchChallengeCustomData); }); }
	STDMETHODIMP _put_LicenseFetchChallengeCustomData(INDCustomData* licenseFetchChallengeCustomData) { return hrtry([&, this] { put_prop(licenseFetchChallengeCustomData, LicenseFetchChallengeCustomData); }); }
};
template<typename X> struct unadapt<INDLicenseFetchDescriptor, X> : Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor_unadaptor<X> {};
struct INDLicenseFetchDescriptor : INDLicenseFetchDescriptor_raw, generate<INDLicenseFetchDescriptor> {};

// INDCustomData
struct INDCustomData_raw : IInspectable {
	virtual STDMETHODIMP _get_CustomDataTypeID(unsigned *customDataTypeIDBytesSize, unsigned char **customDataTypeIDBytes) = 0;
	virtual STDMETHODIMP _get_CustomData(unsigned *customDataBytesSize, unsigned char **customDataBytes) = 0;
};
template<typename X> struct INDCustomData_adaptor : X {
	union {
		struct : property {
			szarray<unsigned char> get() { szarray<unsigned char> customDataBytes; hrcheck(enc(&INDCustomData_adaptor::CustomData)->_get_CustomData(&customDataBytes.size, &customDataBytes.p)); return customDataBytes; }
			szarray<unsigned char> operator()() { return get(); }
			operator szarray<unsigned char> () { return get(); }
		} CustomData;
		struct : property {
			szarray<unsigned char> get() { szarray<unsigned char> customDataTypeIDBytes; hrcheck(enc(&INDCustomData_adaptor::CustomDataTypeID)->_get_CustomDataTypeID(&customDataTypeIDBytes.size, &customDataTypeIDBytes.p)); return customDataTypeIDBytes; }
			szarray<unsigned char> operator()() { return get(); }
			operator szarray<unsigned char> () { return get(); }
		} CustomDataTypeID;
	};
	INDCustomData_adaptor() {}
};
template<typename X> struct adapt<INDCustomData, X> : Windows::Media::Protection::PlayReady::INDCustomData_adaptor<X> { typedef adapt INDCustomData; };
template<typename X> struct INDCustomData_unadaptor : X {
	STDMETHODIMP _get_CustomDataTypeID(unsigned *customDataTypeIDBytesSize, unsigned char **customDataTypeIDBytes) { return hrtry([&, this] { get_prop(customDataTypeIDBytes, CustomDataTypeID); }); }
	STDMETHODIMP _get_CustomData(unsigned *customDataBytesSize, unsigned char **customDataBytes) { return hrtry([&, this] { get_prop(customDataBytes, CustomData); }); }
};
template<typename X> struct unadapt<INDCustomData, X> : Windows::Media::Protection::PlayReady::INDCustomData_unadaptor<X> {};
struct INDCustomData : INDCustomData_raw, generate<INDCustomData> {};

// INDStreamParser
struct INDStreamParser_raw : IInspectable {
	virtual STDMETHODIMP _ParseData(unsigned dataBytesSize, unsigned char *dataBytes) = 0;
	virtual STDMETHODIMP _GetStreamInformation(Core::IMediaStreamDescriptor* descriptor, NDMediaStreamType *streamType, unsigned *streamID) = 0;
	virtual STDMETHODIMP _BeginOfStream() = 0;
	virtual STDMETHODIMP _EndOfStream() = 0;
	virtual STDMETHODIMP _get_Notifier(NDStreamParserNotifier* *instance) = 0;
};
template<typename X> struct INDStreamParser_adaptor : X {
	union {
		struct : property {
			ptr<NDStreamParserNotifier> get() { NDStreamParserNotifier* instance; hrcheck(enc(&INDStreamParser_adaptor::Notifier)->_get_Notifier(&instance)); return from_abi(instance); }
			ptr<NDStreamParserNotifier> operator()() { return get(); }
			operator ptr<NDStreamParserNotifier> () { return get(); }
			ptr<NDStreamParserNotifier> operator->() { return get(); }
		} Notifier;
	};
	void ParseData(const szarray<unsigned char>& dataBytes) { hrcheck(X::get()->_ParseData(dataBytes.size, to_abi(dataBytes.p))); }
	unsigned GetStreamInformation(pptr<Core::IMediaStreamDescriptor> descriptor, NDMediaStreamType *streamType) { unsigned streamID; hrcheck(X::get()->_GetStreamInformation(descriptor, streamType, &streamID)); return streamID; }
	void BeginOfStream() { hrcheck(X::get()->_BeginOfStream()); }
	void EndOfStream() { hrcheck(X::get()->_EndOfStream()); }
	INDStreamParser_adaptor() {}
};
template<typename X> struct adapt<INDStreamParser, X> : Windows::Media::Protection::PlayReady::INDStreamParser_adaptor<X> { typedef adapt INDStreamParser; };
template<typename X> struct INDStreamParser_unadaptor : X {
	STDMETHODIMP _ParseData(unsigned dataBytesSize, unsigned char *dataBytes) { return hrtry([&, this] { X::get()->ParseData({(unsigned char*)dataBytes, dataBytesSize}); }); }
	STDMETHODIMP _GetStreamInformation(Core::IMediaStreamDescriptor* descriptor, NDMediaStreamType *streamType, unsigned *streamID) { return hrtry([&, this] { *streamID = X::get()->GetStreamInformation(descriptor, streamType); }); }
	STDMETHODIMP _BeginOfStream() { return hrtry([&, this] { X::get()->BeginOfStream(); }); }
	STDMETHODIMP _EndOfStream() { return hrtry([&, this] { X::get()->EndOfStream(); }); }
	STDMETHODIMP _get_Notifier(NDStreamParserNotifier* *instance) { return hrtry([&, this] { get_prop(instance, Notifier); }); }
};
template<typename X> struct unadapt<INDStreamParser, X> : Windows::Media::Protection::PlayReady::INDStreamParser_unadaptor<X> {};
struct INDStreamParser : INDStreamParser_raw, generate<INDStreamParser> {};

// INDStreamParserNotifier
struct INDStreamParserNotifier_raw : IInspectable {
	virtual STDMETHODIMP _OnContentIDReceived(INDLicenseFetchDescriptor* licenseFetchDescriptor) = 0;
	virtual STDMETHODIMP _OnMediaStreamDescriptorCreated(Foundation::Collections::IVector<Core::AudioStreamDescriptor*>* audioStreamDescriptors, Foundation::Collections::IVector<Core::VideoStreamDescriptor*>* videoStreamDescriptors) = 0;
	virtual STDMETHODIMP _OnSampleParsed(unsigned streamID, NDMediaStreamType streamType, Core::MediaStreamSample* streamSample, __int64 pts, NDClosedCaptionFormat ccFormat, unsigned ccDataBytesSize, unsigned char *ccDataBytes) = 0;
	virtual STDMETHODIMP _OnBeginSetupDecryptor(Core::IMediaStreamDescriptor* descriptor, Platform::Guid keyID, unsigned proBytesSize, unsigned char *proBytes) = 0;
};
template<typename X> struct INDStreamParserNotifier_adaptor : X {
	void OnContentIDReceived(pptr<INDLicenseFetchDescriptor> licenseFetchDescriptor) { hrcheck(X::get()->_OnContentIDReceived(licenseFetchDescriptor)); }
	void OnMediaStreamDescriptorCreated(pptr<Foundation::Collections::IVector<ptr<Core::AudioStreamDescriptor>>> audioStreamDescriptors, pptr<Foundation::Collections::IVector<ptr<Core::VideoStreamDescriptor>>> videoStreamDescriptors) { hrcheck(X::get()->_OnMediaStreamDescriptorCreated(to_abi(audioStreamDescriptors), to_abi(videoStreamDescriptors))); }
	void OnSampleParsed(unsigned streamID, NDMediaStreamType streamType, pptr<Core::MediaStreamSample> streamSample, __int64 pts, NDClosedCaptionFormat ccFormat, const szarray<unsigned char>& ccDataBytes) { hrcheck(X::get()->_OnSampleParsed(streamID, streamType, streamSample, pts, ccFormat, ccDataBytes.size, to_abi(ccDataBytes.p))); }
	void OnBeginSetupDecryptor(pptr<Core::IMediaStreamDescriptor> descriptor, const Platform::Guid& keyID, const szarray<unsigned char>& proBytes) { hrcheck(X::get()->_OnBeginSetupDecryptor(descriptor, keyID, proBytes.size, to_abi(proBytes.p))); }
};
template<typename X> struct adapt<INDStreamParserNotifier, X> : Windows::Media::Protection::PlayReady::INDStreamParserNotifier_adaptor<X> { typedef adapt INDStreamParserNotifier; };
template<typename X> struct INDStreamParserNotifier_unadaptor : X {
	STDMETHODIMP _OnContentIDReceived(INDLicenseFetchDescriptor* licenseFetchDescriptor) { return hrtry([&, this] { X::get()->OnContentIDReceived(licenseFetchDescriptor); }); }
	STDMETHODIMP _OnMediaStreamDescriptorCreated(Foundation::Collections::IVector<Core::AudioStreamDescriptor*>* audioStreamDescriptors, Foundation::Collections::IVector<Core::VideoStreamDescriptor*>* videoStreamDescriptors) { return hrtry([&, this] { X::get()->OnMediaStreamDescriptorCreated(audioStreamDescriptors, videoStreamDescriptors); }); }
	STDMETHODIMP _OnSampleParsed(unsigned streamID, NDMediaStreamType streamType, Core::MediaStreamSample* streamSample, __int64 pts, NDClosedCaptionFormat ccFormat, unsigned ccDataBytesSize, unsigned char *ccDataBytes) { return hrtry([&, this] { X::get()->OnSampleParsed(streamID, streamType, streamSample, pts, ccFormat, {(unsigned char*)ccDataBytes, ccDataBytesSize}); }); }
	STDMETHODIMP _OnBeginSetupDecryptor(Core::IMediaStreamDescriptor* descriptor, Platform::Guid keyID, unsigned proBytesSize, unsigned char *proBytes) { return hrtry([&, this] { X::get()->OnBeginSetupDecryptor(descriptor, keyID, {(unsigned char*)proBytes, proBytesSize}); }); }
};
template<typename X> struct unadapt<INDStreamParserNotifier, X> : Windows::Media::Protection::PlayReady::INDStreamParserNotifier_unadaptor<X> {};
struct INDStreamParserNotifier : INDStreamParserNotifier_raw, generate<INDStreamParserNotifier> {};

// NDStreamParserNotifier
template<typename X> struct statics<NDStreamParserNotifier, X> : X {
	typedef typename X::root_type NDStreamParserNotifier;
};
struct NDStreamParserNotifier : generate<NDStreamParserNotifier> {};

// INDSendResult
struct INDSendResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Response(unsigned *responseDataBytesSize, unsigned char **responseDataBytes) = 0;
};
template<typename X> struct INDSendResult_adaptor : X {
	union {
		struct : property {
			szarray<unsigned char> get() { szarray<unsigned char> responseDataBytes; hrcheck(enc(&INDSendResult_adaptor::Response)->_get_Response(&responseDataBytes.size, &responseDataBytes.p)); return responseDataBytes; }
			szarray<unsigned char> operator()() { return get(); }
			operator szarray<unsigned char> () { return get(); }
		} Response;
	};
	INDSendResult_adaptor() {}
};
template<typename X> struct adapt<INDSendResult, X> : Windows::Media::Protection::PlayReady::INDSendResult_adaptor<X> { typedef adapt INDSendResult; };
template<typename X> struct INDSendResult_unadaptor : X {
	STDMETHODIMP _get_Response(unsigned *responseDataBytesSize, unsigned char **responseDataBytes) { return hrtry([&, this] { get_prop(responseDataBytes, Response); }); }
};
template<typename X> struct unadapt<INDSendResult, X> : Windows::Media::Protection::PlayReady::INDSendResult_unadaptor<X> {};
struct INDSendResult : INDSendResult_raw, generate<INDSendResult> {};

// INDMessenger
struct INDMessenger_raw : IInspectable {
	virtual STDMETHODIMP _SendRegistrationRequestAsync(unsigned sessionIDBytesSize, unsigned char *sessionIDBytes, unsigned challengeDataBytesSize, unsigned char *challengeDataBytes, Foundation::IAsyncOperation<INDSendResult*>* *result) = 0;
	virtual STDMETHODIMP _SendProximityDetectionStartAsync(NDProximityDetectionType pdType, unsigned transmitterChannelBytesSize, unsigned char *transmitterChannelBytes, unsigned sessionIDBytesSize, unsigned char *sessionIDBytes, unsigned challengeDataBytesSize, unsigned char *challengeDataBytes, Foundation::IAsyncOperation<INDSendResult*>* *result) = 0;
	virtual STDMETHODIMP _SendProximityDetectionResponseAsync(NDProximityDetectionType pdType, unsigned transmitterChannelBytesSize, unsigned char *transmitterChannelBytes, unsigned sessionIDBytesSize, unsigned char *sessionIDBytes, unsigned responseDataBytesSize, unsigned char *responseDataBytes, Foundation::IAsyncOperation<INDSendResult*>* *result) = 0;
	virtual STDMETHODIMP _SendLicenseFetchRequestAsync(unsigned sessionIDBytesSize, unsigned char *sessionIDBytes, unsigned challengeDataBytesSize, unsigned char *challengeDataBytes, Foundation::IAsyncOperation<INDSendResult*>* *result) = 0;
};
template<typename X> struct INDMessenger_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<INDSendResult>>> SendRegistrationRequestAsync(const szarray<unsigned char>& sessionIDBytes, const szarray<unsigned char>& challengeDataBytes) { Foundation::IAsyncOperation<INDSendResult*>* result; hrcheck(X::get()->_SendRegistrationRequestAsync(sessionIDBytes.size, to_abi(sessionIDBytes.p), challengeDataBytes.size, to_abi(challengeDataBytes.p), &result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<INDSendResult>>> SendProximityDetectionStartAsync(NDProximityDetectionType pdType, const szarray<unsigned char>& transmitterChannelBytes, const szarray<unsigned char>& sessionIDBytes, const szarray<unsigned char>& challengeDataBytes) { Foundation::IAsyncOperation<INDSendResult*>* result; hrcheck(X::get()->_SendProximityDetectionStartAsync(pdType, transmitterChannelBytes.size, to_abi(transmitterChannelBytes.p), sessionIDBytes.size, to_abi(sessionIDBytes.p), challengeDataBytes.size, to_abi(challengeDataBytes.p), &result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<INDSendResult>>> SendProximityDetectionResponseAsync(NDProximityDetectionType pdType, const szarray<unsigned char>& transmitterChannelBytes, const szarray<unsigned char>& sessionIDBytes, const szarray<unsigned char>& responseDataBytes) { Foundation::IAsyncOperation<INDSendResult*>* result; hrcheck(X::get()->_SendProximityDetectionResponseAsync(pdType, transmitterChannelBytes.size, to_abi(transmitterChannelBytes.p), sessionIDBytes.size, to_abi(sessionIDBytes.p), responseDataBytes.size, to_abi(responseDataBytes.p), &result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<INDSendResult>>> SendLicenseFetchRequestAsync(const szarray<unsigned char>& sessionIDBytes, const szarray<unsigned char>& challengeDataBytes) { Foundation::IAsyncOperation<INDSendResult*>* result; hrcheck(X::get()->_SendLicenseFetchRequestAsync(sessionIDBytes.size, to_abi(sessionIDBytes.p), challengeDataBytes.size, to_abi(challengeDataBytes.p), &result)); return from_abi(result); }
};
template<typename X> struct adapt<INDMessenger, X> : Windows::Media::Protection::PlayReady::INDMessenger_adaptor<X> { typedef adapt INDMessenger; };
template<typename X> struct INDMessenger_unadaptor : X {
	STDMETHODIMP _SendRegistrationRequestAsync(unsigned sessionIDBytesSize, unsigned char *sessionIDBytes, unsigned challengeDataBytesSize, unsigned char *challengeDataBytes, Foundation::IAsyncOperation<INDSendResult*>* *result) { return hrtry([&, this] { *result = to_abi(X::get()->SendRegistrationRequestAsync({(unsigned char*)sessionIDBytes, sessionIDBytesSize}, {(unsigned char*)challengeDataBytes, challengeDataBytesSize})); }); }
	STDMETHODIMP _SendProximityDetectionStartAsync(NDProximityDetectionType pdType, unsigned transmitterChannelBytesSize, unsigned char *transmitterChannelBytes, unsigned sessionIDBytesSize, unsigned char *sessionIDBytes, unsigned challengeDataBytesSize, unsigned char *challengeDataBytes, Foundation::IAsyncOperation<INDSendResult*>* *result) { return hrtry([&, this] { *result = to_abi(X::get()->SendProximityDetectionStartAsync(pdType, {(unsigned char*)transmitterChannelBytes, transmitterChannelBytesSize}, {(unsigned char*)sessionIDBytes, sessionIDBytesSize}, {(unsigned char*)challengeDataBytes, challengeDataBytesSize})); }); }
	STDMETHODIMP _SendProximityDetectionResponseAsync(NDProximityDetectionType pdType, unsigned transmitterChannelBytesSize, unsigned char *transmitterChannelBytes, unsigned sessionIDBytesSize, unsigned char *sessionIDBytes, unsigned responseDataBytesSize, unsigned char *responseDataBytes, Foundation::IAsyncOperation<INDSendResult*>* *result) { return hrtry([&, this] { *result = to_abi(X::get()->SendProximityDetectionResponseAsync(pdType, {(unsigned char*)transmitterChannelBytes, transmitterChannelBytesSize}, {(unsigned char*)sessionIDBytes, sessionIDBytesSize}, {(unsigned char*)responseDataBytes, responseDataBytesSize})); }); }
	STDMETHODIMP _SendLicenseFetchRequestAsync(unsigned sessionIDBytesSize, unsigned char *sessionIDBytes, unsigned challengeDataBytesSize, unsigned char *challengeDataBytes, Foundation::IAsyncOperation<INDSendResult*>* *result) { return hrtry([&, this] { *result = to_abi(X::get()->SendLicenseFetchRequestAsync({(unsigned char*)sessionIDBytes, sessionIDBytesSize}, {(unsigned char*)challengeDataBytes, challengeDataBytesSize})); }); }
};
template<typename X> struct unadapt<INDMessenger, X> : Windows::Media::Protection::PlayReady::INDMessenger_unadaptor<X> {};
struct INDMessenger : INDMessenger_raw, generate<INDMessenger> {};

// INDTCPMessengerFactory
struct INDTCPMessengerFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(HSTRING remoteHostName, unsigned remoteHostPort, NDTCPMessenger* *instance);
};

// NDTCPMessenger
template<typename> struct NDTCPMessenger_statics {
	static NDTCPMessenger *activate(hstring_ref remoteHostName, unsigned remoteHostPort) { NDTCPMessenger *instance; hrcheck(get_activation_factory<NDTCPMessenger, INDTCPMessengerFactory>()->_CreateInstance(remoteHostName, remoteHostPort, &instance)); return instance; }
};

template<typename X> struct statics<NDTCPMessenger, X> : X, Windows::Media::Protection::PlayReady::NDTCPMessenger_statics<void> {
	using Windows::Media::Protection::PlayReady::NDTCPMessenger_statics<void>::activate;
	typedef typename X::root_type NDTCPMessenger;
};
struct NDTCPMessenger : generate<NDTCPMessenger> {};

// INDTransmitterProperties
struct INDTransmitterProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_CertificateType(NDCertificateType *type) = 0;
	virtual STDMETHODIMP _get_PlatformIdentifier(NDCertificatePlatformID *identifier) = 0;
	virtual STDMETHODIMP _get_SupportedFeatures(unsigned *featureSetsSize, NDCertificateFeature **featureSets) = 0;
	virtual STDMETHODIMP _get_SecurityLevel(unsigned *level) = 0;
	virtual STDMETHODIMP _get_SecurityVersion(unsigned *securityVersion) = 0;
	virtual STDMETHODIMP _get_ExpirationDate(Foundation::DateTime *expirationDate) = 0;
	virtual STDMETHODIMP _get_ClientID(unsigned *clientIDBytesSize, unsigned char **clientIDBytes) = 0;
	virtual STDMETHODIMP _get_ModelDigest(unsigned *modelDigestBytesSize, unsigned char **modelDigestBytes) = 0;
	virtual STDMETHODIMP _get_ModelManufacturerName(HSTRING *modelManufacturerName) = 0;
	virtual STDMETHODIMP _get_ModelName(HSTRING *modelName) = 0;
	virtual STDMETHODIMP _get_ModelNumber(HSTRING *modelNumber) = 0;
};
template<typename X> struct INDTransmitterProperties_adaptor : X {
	union {
		struct : property {
			NDCertificateType get() { NDCertificateType type; hrcheck(enc(&INDTransmitterProperties_adaptor::CertificateType)->_get_CertificateType(&type)); return type; }
			NDCertificateType operator()() { return get(); }
			operator NDCertificateType () { return get(); }
		} CertificateType;
		struct : property {
			szarray<unsigned char> get() { szarray<unsigned char> clientIDBytes; hrcheck(enc(&INDTransmitterProperties_adaptor::ClientID)->_get_ClientID(&clientIDBytes.size, &clientIDBytes.p)); return clientIDBytes; }
			szarray<unsigned char> operator()() { return get(); }
			operator szarray<unsigned char> () { return get(); }
		} ClientID;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime expirationDate; hrcheck(enc(&INDTransmitterProperties_adaptor::ExpirationDate)->_get_ExpirationDate(&expirationDate)); return expirationDate; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} ExpirationDate;
		struct : property {
			szarray<unsigned char> get() { szarray<unsigned char> modelDigestBytes; hrcheck(enc(&INDTransmitterProperties_adaptor::ModelDigest)->_get_ModelDigest(&modelDigestBytes.size, &modelDigestBytes.p)); return modelDigestBytes; }
			szarray<unsigned char> operator()() { return get(); }
			operator szarray<unsigned char> () { return get(); }
		} ModelDigest;
		struct : property {
			hstring get() { HSTRING modelManufacturerName; hrcheck(enc(&INDTransmitterProperties_adaptor::ModelManufacturerName)->_get_ModelManufacturerName(&modelManufacturerName)); return from_abi(modelManufacturerName); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ModelManufacturerName;
		struct : property {
			hstring get() { HSTRING modelName; hrcheck(enc(&INDTransmitterProperties_adaptor::ModelName)->_get_ModelName(&modelName)); return from_abi(modelName); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ModelName;
		struct : property {
			hstring get() { HSTRING modelNumber; hrcheck(enc(&INDTransmitterProperties_adaptor::ModelNumber)->_get_ModelNumber(&modelNumber)); return from_abi(modelNumber); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ModelNumber;
		struct : property {
			NDCertificatePlatformID get() { NDCertificatePlatformID identifier; hrcheck(enc(&INDTransmitterProperties_adaptor::PlatformIdentifier)->_get_PlatformIdentifier(&identifier)); return identifier; }
			NDCertificatePlatformID operator()() { return get(); }
			operator NDCertificatePlatformID () { return get(); }
		} PlatformIdentifier;
		struct : property {
			unsigned get() { unsigned level; hrcheck(enc(&INDTransmitterProperties_adaptor::SecurityLevel)->_get_SecurityLevel(&level)); return level; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} SecurityLevel;
		struct : property {
			unsigned get() { unsigned securityVersion; hrcheck(enc(&INDTransmitterProperties_adaptor::SecurityVersion)->_get_SecurityVersion(&securityVersion)); return securityVersion; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} SecurityVersion;
		struct : property {
			szarray<NDCertificateFeature> get() { szarray<NDCertificateFeature> featureSets; hrcheck(enc(&INDTransmitterProperties_adaptor::SupportedFeatures)->_get_SupportedFeatures(&featureSets.size, &featureSets.p)); return featureSets; }
			szarray<NDCertificateFeature> operator()() { return get(); }
			operator szarray<NDCertificateFeature> () { return get(); }
		} SupportedFeatures;
	};
	INDTransmitterProperties_adaptor() {}
};
template<typename X> struct adapt<INDTransmitterProperties, X> : Windows::Media::Protection::PlayReady::INDTransmitterProperties_adaptor<X> { typedef adapt INDTransmitterProperties; };
template<typename X> struct INDTransmitterProperties_unadaptor : X {
	STDMETHODIMP _get_CertificateType(NDCertificateType *type) { return hrtry([&, this] { get_prop(type, CertificateType); }); }
	STDMETHODIMP _get_PlatformIdentifier(NDCertificatePlatformID *identifier) { return hrtry([&, this] { get_prop(identifier, PlatformIdentifier); }); }
	STDMETHODIMP _get_SupportedFeatures(unsigned *featureSetsSize, NDCertificateFeature **featureSets) { return hrtry([&, this] { get_prop(featureSets, SupportedFeatures); }); }
	STDMETHODIMP _get_SecurityLevel(unsigned *level) { return hrtry([&, this] { get_prop(level, SecurityLevel); }); }
	STDMETHODIMP _get_SecurityVersion(unsigned *securityVersion) { return hrtry([&, this] { get_prop(securityVersion, SecurityVersion); }); }
	STDMETHODIMP _get_ExpirationDate(Foundation::DateTime *expirationDate) { return hrtry([&, this] { get_prop(expirationDate, ExpirationDate); }); }
	STDMETHODIMP _get_ClientID(unsigned *clientIDBytesSize, unsigned char **clientIDBytes) { return hrtry([&, this] { get_prop(clientIDBytes, ClientID); }); }
	STDMETHODIMP _get_ModelDigest(unsigned *modelDigestBytesSize, unsigned char **modelDigestBytes) { return hrtry([&, this] { get_prop(modelDigestBytes, ModelDigest); }); }
	STDMETHODIMP _get_ModelManufacturerName(HSTRING *modelManufacturerName) { return hrtry([&, this] { get_prop(modelManufacturerName, ModelManufacturerName); }); }
	STDMETHODIMP _get_ModelName(HSTRING *modelName) { return hrtry([&, this] { get_prop(modelName, ModelName); }); }
	STDMETHODIMP _get_ModelNumber(HSTRING *modelNumber) { return hrtry([&, this] { get_prop(modelNumber, ModelNumber); }); }
};
template<typename X> struct unadapt<INDTransmitterProperties, X> : Windows::Media::Protection::PlayReady::INDTransmitterProperties_unadaptor<X> {};
struct INDTransmitterProperties : INDTransmitterProperties_raw, generate<INDTransmitterProperties> {};

// INDStartResult
struct INDStartResult_raw : IInspectable {
	virtual STDMETHODIMP _get_MediaStreamSource(Core::MediaStreamSource* *mediaStreamSource) = 0;
};
template<typename X> struct INDStartResult_adaptor : X {
	union {
		struct : property {
			ptr<Core::MediaStreamSource> get() { Core::MediaStreamSource* mediaStreamSource; hrcheck(enc(&INDStartResult_adaptor::MediaStreamSource)->_get_MediaStreamSource(&mediaStreamSource)); return from_abi(mediaStreamSource); }
			ptr<Core::MediaStreamSource> operator()() { return get(); }
			operator ptr<Core::MediaStreamSource> () { return get(); }
			ptr<Core::MediaStreamSource> operator->() { return get(); }
		} MediaStreamSource;
	};
	INDStartResult_adaptor() {}
};
template<typename X> struct adapt<INDStartResult, X> : Windows::Media::Protection::PlayReady::INDStartResult_adaptor<X> { typedef adapt INDStartResult; };
template<typename X> struct INDStartResult_unadaptor : X {
	STDMETHODIMP _get_MediaStreamSource(Core::MediaStreamSource* *mediaStreamSource) { return hrtry([&, this] { get_prop(mediaStreamSource, MediaStreamSource); }); }
};
template<typename X> struct unadapt<INDStartResult, X> : Windows::Media::Protection::PlayReady::INDStartResult_unadaptor<X> {};
struct INDStartResult : INDStartResult_raw, generate<INDStartResult> {};

// INDLicenseFetchResult
struct INDLicenseFetchResult_raw : IInspectable {
	virtual STDMETHODIMP _get_ResponseCustomData(INDCustomData* *customData) = 0;
};
template<typename X> struct INDLicenseFetchResult_adaptor : X {
	union {
		struct : property {
			ptr<INDCustomData> get() { INDCustomData* customData; hrcheck(enc(&INDLicenseFetchResult_adaptor::ResponseCustomData)->_get_ResponseCustomData(&customData)); return from_abi(customData); }
			ptr<INDCustomData> operator()() { return get(); }
			operator ptr<INDCustomData> () { return get(); }
			ptr<INDCustomData> operator->() { return get(); }
		} ResponseCustomData;
	};
	INDLicenseFetchResult_adaptor() {}
};
template<typename X> struct adapt<INDLicenseFetchResult, X> : Windows::Media::Protection::PlayReady::INDLicenseFetchResult_adaptor<X> { typedef adapt INDLicenseFetchResult; };
template<typename X> struct INDLicenseFetchResult_unadaptor : X {
	STDMETHODIMP _get_ResponseCustomData(INDCustomData* *customData) { return hrtry([&, this] { get_prop(customData, ResponseCustomData); }); }
};
template<typename X> struct unadapt<INDLicenseFetchResult, X> : Windows::Media::Protection::PlayReady::INDLicenseFetchResult_unadaptor<X> {};
struct INDLicenseFetchResult : INDLicenseFetchResult_raw, generate<INDLicenseFetchResult> {};

// INDLicenseFetchDescriptorFactory
struct INDLicenseFetchDescriptorFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(NDContentIDType contentIDType, unsigned contentIDBytesSize, unsigned char *contentIDBytes, INDCustomData* licenseFetchChallengeCustomData, NDLicenseFetchDescriptor* *instance);
};

// NDLicenseFetchDescriptor
template<typename> struct NDLicenseFetchDescriptor_statics {
	static NDLicenseFetchDescriptor *activate(NDContentIDType contentIDType, const szarray<unsigned char>& contentIDBytes, pptr<INDCustomData> licenseFetchChallengeCustomData) { NDLicenseFetchDescriptor *instance; hrcheck(get_activation_factory<NDLicenseFetchDescriptor, INDLicenseFetchDescriptorFactory>()->_CreateInstance(contentIDType, contentIDBytes.size, to_abi(contentIDBytes.p), licenseFetchChallengeCustomData, &instance)); return instance; }
};

template<typename X> struct statics<NDLicenseFetchDescriptor, X> : X, Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor_statics<void> {
	using Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor_statics<void>::activate;
	typedef typename X::root_type NDLicenseFetchDescriptor;
};
struct NDLicenseFetchDescriptor : generate<NDLicenseFetchDescriptor> {};

// INDRegistrationCompletedEventArgs
struct INDRegistrationCompletedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ResponseCustomData(INDCustomData* *customData) = 0;
	virtual STDMETHODIMP _get_TransmitterProperties(INDTransmitterProperties* *transmitterProperties) = 0;
	virtual STDMETHODIMP _get_TransmitterCertificateAccepted(bool *acceptpt) = 0;
	virtual STDMETHODIMP _put_TransmitterCertificateAccepted(bool accept) = 0;
};
template<typename X> struct INDRegistrationCompletedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<INDCustomData> get() { INDCustomData* customData; hrcheck(enc(&INDRegistrationCompletedEventArgs_adaptor::ResponseCustomData)->_get_ResponseCustomData(&customData)); return from_abi(customData); }
			ptr<INDCustomData> operator()() { return get(); }
			operator ptr<INDCustomData> () { return get(); }
			ptr<INDCustomData> operator->() { return get(); }
		} ResponseCustomData;
		struct : property {
			bool get() { bool acceptpt; hrcheck(enc(&INDRegistrationCompletedEventArgs_adaptor::TransmitterCertificateAccepted)->_get_TransmitterCertificateAccepted(&acceptpt)); return acceptpt; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool accept) { hrcheck(enc(&INDRegistrationCompletedEventArgs_adaptor::TransmitterCertificateAccepted)->_put_TransmitterCertificateAccepted(accept)); }
			void operator=(bool accept) { put(accept); }
			void operator()(bool accept) { put(accept); }
		} TransmitterCertificateAccepted;
		struct : property {
			ptr<INDTransmitterProperties> get() { INDTransmitterProperties* transmitterProperties; hrcheck(enc(&INDRegistrationCompletedEventArgs_adaptor::TransmitterProperties)->_get_TransmitterProperties(&transmitterProperties)); return from_abi(transmitterProperties); }
			ptr<INDTransmitterProperties> operator()() { return get(); }
			operator ptr<INDTransmitterProperties> () { return get(); }
			ptr<INDTransmitterProperties> operator->() { return get(); }
		} TransmitterProperties;
	};
	INDRegistrationCompletedEventArgs_adaptor() {}
};
template<typename X> struct adapt<INDRegistrationCompletedEventArgs, X> : Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs_adaptor<X> { typedef adapt INDRegistrationCompletedEventArgs; };
template<typename X> struct INDRegistrationCompletedEventArgs_unadaptor : X {
	STDMETHODIMP _get_ResponseCustomData(INDCustomData* *customData) { return hrtry([&, this] { get_prop(customData, ResponseCustomData); }); }
	STDMETHODIMP _get_TransmitterProperties(INDTransmitterProperties* *transmitterProperties) { return hrtry([&, this] { get_prop(transmitterProperties, TransmitterProperties); }); }
	STDMETHODIMP _get_TransmitterCertificateAccepted(bool *acceptpt) { return hrtry([&, this] { get_prop(acceptpt, TransmitterCertificateAccepted); }); }
	STDMETHODIMP _put_TransmitterCertificateAccepted(bool accept) { return hrtry([&, this] { put_prop(accept, TransmitterCertificateAccepted); }); }
};
template<typename X> struct unadapt<INDRegistrationCompletedEventArgs, X> : Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs_unadaptor<X> {};
struct INDRegistrationCompletedEventArgs : INDRegistrationCompletedEventArgs_raw, generate<INDRegistrationCompletedEventArgs> {};

// INDCustomDataFactory
struct INDCustomDataFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(unsigned customDataTypeIDBytesSize, unsigned char *customDataTypeIDBytes, unsigned customDataBytesSize, unsigned char *customDataBytes, NDCustomData* *instance);
};

// NDCustomData
template<typename> struct NDCustomData_statics {
	static NDCustomData *activate(const szarray<unsigned char>& customDataTypeIDBytes, const szarray<unsigned char>& customDataBytes) { NDCustomData *instance; hrcheck(get_activation_factory<NDCustomData, INDCustomDataFactory>()->_CreateInstance(customDataTypeIDBytes.size, to_abi(customDataTypeIDBytes.p), customDataBytes.size, to_abi(customDataBytes.p), &instance)); return instance; }
};

template<typename X> struct statics<NDCustomData, X> : X, Windows::Media::Protection::PlayReady::NDCustomData_statics<void> {
	using Windows::Media::Protection::PlayReady::NDCustomData_statics<void>::activate;
	typedef typename X::root_type NDCustomData;
};
struct NDCustomData : generate<NDCustomData> {};

// INDProximityDetectionCompletedEventArgs
struct INDProximityDetectionCompletedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ProximityDetectionRetryCount(unsigned *retryCount) = 0;
};
template<typename X> struct INDProximityDetectionCompletedEventArgs_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned retryCount; hrcheck(enc(&INDProximityDetectionCompletedEventArgs_adaptor::ProximityDetectionRetryCount)->_get_ProximityDetectionRetryCount(&retryCount)); return retryCount; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} ProximityDetectionRetryCount;
	};
	INDProximityDetectionCompletedEventArgs_adaptor() {}
};
template<typename X> struct adapt<INDProximityDetectionCompletedEventArgs, X> : Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs_adaptor<X> { typedef adapt INDProximityDetectionCompletedEventArgs; };
template<typename X> struct INDProximityDetectionCompletedEventArgs_unadaptor : X {
	STDMETHODIMP _get_ProximityDetectionRetryCount(unsigned *retryCount) { return hrtry([&, this] { get_prop(retryCount, ProximityDetectionRetryCount); }); }
};
template<typename X> struct unadapt<INDProximityDetectionCompletedEventArgs, X> : Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs_unadaptor<X> {};
struct INDProximityDetectionCompletedEventArgs : INDProximityDetectionCompletedEventArgs_raw, generate<INDProximityDetectionCompletedEventArgs> {};

// INDLicenseFetchCompletedEventArgs
struct INDLicenseFetchCompletedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ResponseCustomData(INDCustomData* *customData) = 0;
};
template<typename X> struct INDLicenseFetchCompletedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<INDCustomData> get() { INDCustomData* customData; hrcheck(enc(&INDLicenseFetchCompletedEventArgs_adaptor::ResponseCustomData)->_get_ResponseCustomData(&customData)); return from_abi(customData); }
			ptr<INDCustomData> operator()() { return get(); }
			operator ptr<INDCustomData> () { return get(); }
			ptr<INDCustomData> operator->() { return get(); }
		} ResponseCustomData;
	};
	INDLicenseFetchCompletedEventArgs_adaptor() {}
};
template<typename X> struct adapt<INDLicenseFetchCompletedEventArgs, X> : Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs_adaptor<X> { typedef adapt INDLicenseFetchCompletedEventArgs; };
template<typename X> struct INDLicenseFetchCompletedEventArgs_unadaptor : X {
	STDMETHODIMP _get_ResponseCustomData(INDCustomData* *customData) { return hrtry([&, this] { get_prop(customData, ResponseCustomData); }); }
};
template<typename X> struct unadapt<INDLicenseFetchCompletedEventArgs, X> : Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs_unadaptor<X> {};
struct INDLicenseFetchCompletedEventArgs : INDLicenseFetchCompletedEventArgs_raw, generate<INDLicenseFetchCompletedEventArgs> {};

// INDClient
struct INDClient_raw : IInspectable {
	virtual STDMETHODIMP _add_RegistrationCompleted(Foundation::TypedEventHandler<NDClient*, INDRegistrationCompletedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_RegistrationCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ProximityDetectionCompleted(Foundation::TypedEventHandler<NDClient*, INDProximityDetectionCompletedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ProximityDetectionCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_LicenseFetchCompleted(Foundation::TypedEventHandler<NDClient*, INDLicenseFetchCompletedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_LicenseFetchCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ReRegistrationNeeded(Foundation::TypedEventHandler<NDClient*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ReRegistrationNeeded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ClosedCaptionDataReceived(Foundation::TypedEventHandler<NDClient*, INDClosedCaptionDataReceivedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ClosedCaptionDataReceived(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _StartAsync(Foundation::Uri* contentUrl, unsigned startAsyncOptions, INDCustomData* registrationCustomData, INDLicenseFetchDescriptor* licenseFetchDescriptor, Foundation::IAsyncOperation<INDStartResult*>* *result);
	virtual STDMETHODIMP _LicenseFetchAsync(INDLicenseFetchDescriptor* licenseFetchDescriptor, Foundation::IAsyncOperation<INDLicenseFetchResult*>* *result);
	virtual STDMETHODIMP _ReRegistrationAsync(INDCustomData* registrationCustomData, Foundation::IAsyncAction* *result);
	virtual STDMETHODIMP _Close();
};
template<typename X> struct INDClient_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<NDClient>, ptr<INDClosedCaptionDataReceivedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&INDClient_adaptor::ClosedCaptionDataReceived)->_add_ClosedCaptionDataReceived(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&INDClient_adaptor::ClosedCaptionDataReceived)->_remove_ClosedCaptionDataReceived(token)); }
		} ClosedCaptionDataReceived;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<NDClient>, ptr<INDLicenseFetchCompletedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&INDClient_adaptor::LicenseFetchCompleted)->_add_LicenseFetchCompleted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&INDClient_adaptor::LicenseFetchCompleted)->_remove_LicenseFetchCompleted(token)); }
		} LicenseFetchCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<NDClient>, ptr<INDProximityDetectionCompletedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&INDClient_adaptor::ProximityDetectionCompleted)->_add_ProximityDetectionCompleted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&INDClient_adaptor::ProximityDetectionCompleted)->_remove_ProximityDetectionCompleted(token)); }
		} ProximityDetectionCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<NDClient>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&INDClient_adaptor::ReRegistrationNeeded)->_add_ReRegistrationNeeded(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&INDClient_adaptor::ReRegistrationNeeded)->_remove_ReRegistrationNeeded(token)); }
		} ReRegistrationNeeded;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<NDClient>, ptr<INDRegistrationCompletedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&INDClient_adaptor::RegistrationCompleted)->_add_RegistrationCompleted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&INDClient_adaptor::RegistrationCompleted)->_remove_RegistrationCompleted(token)); }
		} RegistrationCompleted;
	};
	ptr<Foundation::IAsyncOperation<ptr<INDStartResult>>> StartAsync(pptr<Foundation::Uri> contentUrl, unsigned startAsyncOptions, pptr<INDCustomData> registrationCustomData, pptr<INDLicenseFetchDescriptor> licenseFetchDescriptor) { Foundation::IAsyncOperation<INDStartResult*>* result; hrcheck(X::get()->_StartAsync(contentUrl, startAsyncOptions, registrationCustomData, licenseFetchDescriptor, &result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<INDLicenseFetchResult>>> LicenseFetchAsync(pptr<INDLicenseFetchDescriptor> licenseFetchDescriptor) { Foundation::IAsyncOperation<INDLicenseFetchResult*>* result; hrcheck(X::get()->_LicenseFetchAsync(licenseFetchDescriptor, &result)); return from_abi(result); }
	ptr<Foundation::IAsyncAction> ReRegistrationAsync(pptr<INDCustomData> registrationCustomData) { Foundation::IAsyncAction* result; hrcheck(X::get()->_ReRegistrationAsync(registrationCustomData, &result)); return from_abi(result); }
	void Close() { hrcheck(X::get()->_Close()); }
	INDClient_adaptor() {}
};
template<typename X> struct adapt<INDClient, X> : Windows::Media::Protection::PlayReady::INDClient_adaptor<X> { typedef adapt INDClient; };
struct INDClient : INDClient_raw, generate<INDClient> {};

// INDClientFactory
struct INDClientFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(INDDownloadEngine* downloadEngine, INDStreamParser* streamParser, INDMessenger* pMessenger, NDClient* *instance);
};

// NDClient
template<typename> struct NDClient_statics {
	static NDClient *activate(pptr<INDDownloadEngine> downloadEngine, pptr<INDStreamParser> streamParser, pptr<INDMessenger> pMessenger) { NDClient *instance; hrcheck(get_activation_factory<NDClient, INDClientFactory>()->_CreateInstance(downloadEngine, streamParser, pMessenger, &instance)); return instance; }
};

template<typename X> struct statics<NDClient, X> : X, Windows::Media::Protection::PlayReady::NDClient_statics<void> {
	using Windows::Media::Protection::PlayReady::NDClient_statics<void>::activate;
	typedef typename X::root_type NDClient;
};
struct NDClient : generate<NDClient> {};

// INDClosedCaptionDataReceivedEventArgs
struct INDClosedCaptionDataReceivedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ClosedCaptionDataFormat(NDClosedCaptionFormat *ccForamt) = 0;
	virtual STDMETHODIMP _get_PresentationTimestamp(__int64 *presentationTimestamp) = 0;
	virtual STDMETHODIMP _get_ClosedCaptionData(unsigned *ccDataBytesSize, unsigned char **ccDataBytes) = 0;
};
template<typename X> struct INDClosedCaptionDataReceivedEventArgs_adaptor : X {
	union {
		struct : property {
			szarray<unsigned char> get() { szarray<unsigned char> ccDataBytes; hrcheck(enc(&INDClosedCaptionDataReceivedEventArgs_adaptor::ClosedCaptionData)->_get_ClosedCaptionData(&ccDataBytes.size, &ccDataBytes.p)); return ccDataBytes; }
			szarray<unsigned char> operator()() { return get(); }
			operator szarray<unsigned char> () { return get(); }
		} ClosedCaptionData;
		struct : property {
			NDClosedCaptionFormat get() { NDClosedCaptionFormat ccForamt; hrcheck(enc(&INDClosedCaptionDataReceivedEventArgs_adaptor::ClosedCaptionDataFormat)->_get_ClosedCaptionDataFormat(&ccForamt)); return ccForamt; }
			NDClosedCaptionFormat operator()() { return get(); }
			operator NDClosedCaptionFormat () { return get(); }
		} ClosedCaptionDataFormat;
		struct : property {
			__int64 get() { __int64 presentationTimestamp; hrcheck(enc(&INDClosedCaptionDataReceivedEventArgs_adaptor::PresentationTimestamp)->_get_PresentationTimestamp(&presentationTimestamp)); return presentationTimestamp; }
			__int64 operator()() { return get(); }
			operator __int64 () { return get(); }
		} PresentationTimestamp;
	};
	INDClosedCaptionDataReceivedEventArgs_adaptor() {}
};
template<typename X> struct adapt<INDClosedCaptionDataReceivedEventArgs, X> : Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs_adaptor<X> { typedef adapt INDClosedCaptionDataReceivedEventArgs; };
template<typename X> struct INDClosedCaptionDataReceivedEventArgs_unadaptor : X {
	STDMETHODIMP _get_ClosedCaptionDataFormat(NDClosedCaptionFormat *ccForamt) { return hrtry([&, this] { get_prop(ccForamt, ClosedCaptionDataFormat); }); }
	STDMETHODIMP _get_PresentationTimestamp(__int64 *presentationTimestamp) { return hrtry([&, this] { get_prop(presentationTimestamp, PresentationTimestamp); }); }
	STDMETHODIMP _get_ClosedCaptionData(unsigned *ccDataBytesSize, unsigned char **ccDataBytes) { return hrtry([&, this] { get_prop(ccDataBytes, ClosedCaptionData); }); }
};
template<typename X> struct unadapt<INDClosedCaptionDataReceivedEventArgs, X> : Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs_unadaptor<X> {};
struct INDClosedCaptionDataReceivedEventArgs : INDClosedCaptionDataReceivedEventArgs_raw, generate<INDClosedCaptionDataReceivedEventArgs> {};

// INDStorageFileHelper
struct INDStorageFileHelper_raw : IInspectable {
	virtual STDMETHODIMP _GetFileURLs(Storage::IStorageFile* file, Foundation::Collections::IVector<HSTRING>* *fileURLs) = 0;
};
template<typename X> struct INDStorageFileHelper_adaptor : X {
	ptr<Foundation::Collections::IVector<hstring>> GetFileURLs(pptr<Storage::IStorageFile> file) { Foundation::Collections::IVector<HSTRING>* fileURLs; hrcheck(X::get()->_GetFileURLs(file, &fileURLs)); return from_abi(fileURLs); }
};
template<typename X> struct adapt<INDStorageFileHelper, X> : Windows::Media::Protection::PlayReady::INDStorageFileHelper_adaptor<X> { typedef adapt INDStorageFileHelper; };
template<typename X> struct INDStorageFileHelper_unadaptor : X {
	STDMETHODIMP _GetFileURLs(Storage::IStorageFile* file, Foundation::Collections::IVector<HSTRING>* *fileURLs) { return hrtry([&, this] { *fileURLs = to_abi(X::get()->GetFileURLs(file)); }); }
};
template<typename X> struct unadapt<INDStorageFileHelper, X> : Windows::Media::Protection::PlayReady::INDStorageFileHelper_unadaptor<X> {};
struct INDStorageFileHelper : INDStorageFileHelper_raw, generate<INDStorageFileHelper> {};

// NDStorageFileHelper
template<typename X> struct statics<NDStorageFileHelper, X> : X {
	typedef typename X::root_type NDStorageFileHelper;
};
struct NDStorageFileHelper : generate<NDStorageFileHelper> {};
}}}}
} // namespace iso_winrt
