#pragma once
// generated by isopod tools
// namespaces:
// Windows.Media.Transcoding

#include "Windows.Media.Transcoding.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
struct IPropertySet;
}}
namespace Media { namespace Core {
struct IMediaSource;
}
namespace MediaProperties {
struct MediaEncodingProfile;
}}
namespace Storage { namespace Streams {
struct IRandomAccessStream;
}
struct IStorageFile;
}}

// defs

template<> struct def<Windows::Media::Transcoding::TranscodeFailureReason> : enum_type<int> {};
template<> struct def<Windows::Media::Transcoding::MediaVideoProcessingAlgorithm> : enum_type<int> {};
template<> struct def<Windows::Media::Transcoding::IMediaTranscoder2> : interface_type<> {};
template<> struct def<Windows::Media::Transcoding::IPrepareTranscodeResult> : interface_type<> {};
template<> struct def<Windows::Media::Transcoding::PrepareTranscodeResult> : class_type<Platform::Object, Windows::Media::Transcoding::IPrepareTranscodeResult> {};
template<> struct def<Windows::Media::Transcoding::IMediaTranscoder> : interface_type<> {};
template<> struct def<Windows::Media::Transcoding::MediaTranscoder> : class_type<Platform::Object, Windows::Media::Transcoding::IMediaTranscoder, Windows::Media::Transcoding::IMediaTranscoder2> {};

// uuids

template<> struct uuid<Windows::Media::Transcoding::IMediaTranscoder2> { define_guid(0x40531D74, 0x35E0, 0x4F04, 0x85, 0x74, 0xCA, 0x8B, 0xC4, 0xE5, 0xA0, 0x82);};
template<> struct uuid<Windows::Media::Transcoding::IPrepareTranscodeResult> { define_guid(0x5F25DCE, 0x994F, 0x4A34, 0x9D, 0x68, 0x97, 0xCC, 0xCE, 0x17, 0x30, 0xD6);};
template<> struct uuid<Windows::Media::Transcoding::IMediaTranscoder> { define_guid(0x190C99D2, 0xA0AA, 0x4D34, 0x86, 0xBC, 0xEE, 0xD1, 0xB1, 0x2C, 0x2F, 0x5B);};

// types

namespace Windows { namespace Media { namespace Transcoding {

// IMediaTranscoder2
struct IMediaTranscoder2_raw : IInspectable {
	virtual STDMETHODIMP _PrepareMediaStreamSourceTranscodeAsync(Core::IMediaSource* source, Storage::Streams::IRandomAccessStream* destination, MediaProperties::MediaEncodingProfile* profile, Foundation::IAsyncOperation<PrepareTranscodeResult*>* *operation);
	virtual STDMETHODIMP _put_VideoProcessingAlgorithm(MediaVideoProcessingAlgorithm value);
	virtual STDMETHODIMP _get_VideoProcessingAlgorithm(MediaVideoProcessingAlgorithm *value);
};
template<typename X> struct IMediaTranscoder2_adaptor : X {
	union {
		struct : property {
			MediaVideoProcessingAlgorithm get() { MediaVideoProcessingAlgorithm value; hrcheck(enc(&IMediaTranscoder2_adaptor::VideoProcessingAlgorithm)->_get_VideoProcessingAlgorithm(&value)); return value; }
			MediaVideoProcessingAlgorithm operator()() { return get(); }
			operator MediaVideoProcessingAlgorithm () { return get(); }
			void put(MediaVideoProcessingAlgorithm value) { hrcheck(enc(&IMediaTranscoder2_adaptor::VideoProcessingAlgorithm)->_put_VideoProcessingAlgorithm(value)); }
			void operator=(MediaVideoProcessingAlgorithm value) { put(value); }
			void operator()(MediaVideoProcessingAlgorithm value) { put(value); }
		} VideoProcessingAlgorithm;
	};
	ptr<Foundation::IAsyncOperation<ptr<PrepareTranscodeResult>>> PrepareMediaStreamSourceTranscodeAsync(pptr<Core::IMediaSource> source, pptr<Storage::Streams::IRandomAccessStream> destination, pptr<MediaProperties::MediaEncodingProfile> profile) { Foundation::IAsyncOperation<PrepareTranscodeResult*>* operation; hrcheck(X::get()->_PrepareMediaStreamSourceTranscodeAsync(source, destination, profile, &operation)); return from_abi(operation); }
	IMediaTranscoder2_adaptor() {}
};
template<typename X> struct adapt<IMediaTranscoder2, X> : Windows::Media::Transcoding::IMediaTranscoder2_adaptor<X> { typedef adapt IMediaTranscoder2; };
struct IMediaTranscoder2 : IMediaTranscoder2_raw, generate<IMediaTranscoder2> {};

// IPrepareTranscodeResult
struct IPrepareTranscodeResult_raw : IInspectable {
	virtual STDMETHODIMP _get_CanTranscode(bool *value);
	virtual STDMETHODIMP _get_FailureReason(TranscodeFailureReason *value);
	virtual STDMETHODIMP _TranscodeAsync(Foundation::IAsyncActionWithProgress<double>* *operation);
};
template<typename X> struct IPrepareTranscodeResult_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPrepareTranscodeResult_adaptor::CanTranscode)->_get_CanTranscode(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanTranscode;
		struct : property {
			TranscodeFailureReason get() { TranscodeFailureReason value; hrcheck(enc(&IPrepareTranscodeResult_adaptor::FailureReason)->_get_FailureReason(&value)); return value; }
			TranscodeFailureReason operator()() { return get(); }
			operator TranscodeFailureReason () { return get(); }
		} FailureReason;
	};
	ptr<Foundation::IAsyncActionWithProgress<double>> TranscodeAsync() { Foundation::IAsyncActionWithProgress<double>* operation; hrcheck(X::get()->_TranscodeAsync(&operation)); return from_abi(operation); }
	IPrepareTranscodeResult_adaptor() {}
};
template<typename X> struct adapt<IPrepareTranscodeResult, X> : Windows::Media::Transcoding::IPrepareTranscodeResult_adaptor<X> { typedef adapt IPrepareTranscodeResult; };
struct IPrepareTranscodeResult : IPrepareTranscodeResult_raw, generate<IPrepareTranscodeResult> {};

// PrepareTranscodeResult
template<typename X> struct statics<PrepareTranscodeResult, X> : X {
	typedef typename X::root_type PrepareTranscodeResult;
};
struct PrepareTranscodeResult : generate<PrepareTranscodeResult> {};

// IMediaTranscoder
struct IMediaTranscoder_raw : IInspectable {
	virtual STDMETHODIMP _put_TrimStartTime(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_TrimStartTime(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_TrimStopTime(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_TrimStopTime(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_AlwaysReencode(bool value);
	virtual STDMETHODIMP _get_AlwaysReencode(bool *value);
	virtual STDMETHODIMP _put_HardwareAccelerationEnabled(bool value);
	virtual STDMETHODIMP _get_HardwareAccelerationEnabled(bool *value);
	virtual STDMETHODIMP _AddAudioEffect(HSTRING activatableClassId);
	virtual STDMETHODIMP _AddAudioEffectWithSettings(HSTRING activatableClassId, bool effectRequired, Foundation::Collections::IPropertySet* configuration);
	virtual STDMETHODIMP _AddVideoEffect(HSTRING activatableClassId);
	virtual STDMETHODIMP _AddVideoEffectWithSettings(HSTRING activatableClassId, bool effectRequired, Foundation::Collections::IPropertySet* configuration);
	virtual STDMETHODIMP _ClearEffects();
	virtual STDMETHODIMP _PrepareFileTranscodeAsync(Storage::IStorageFile* source, Storage::IStorageFile* destination, MediaProperties::MediaEncodingProfile* profile, Foundation::IAsyncOperation<PrepareTranscodeResult*>* *operation);
	virtual STDMETHODIMP _PrepareStreamTranscodeAsync(Storage::Streams::IRandomAccessStream* source, Storage::Streams::IRandomAccessStream* destination, MediaProperties::MediaEncodingProfile* profile, Foundation::IAsyncOperation<PrepareTranscodeResult*>* *operation);
};
template<typename X> struct IMediaTranscoder_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTranscoder_adaptor::AlwaysReencode)->_get_AlwaysReencode(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTranscoder_adaptor::AlwaysReencode)->_put_AlwaysReencode(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AlwaysReencode;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTranscoder_adaptor::HardwareAccelerationEnabled)->_get_HardwareAccelerationEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTranscoder_adaptor::HardwareAccelerationEnabled)->_put_HardwareAccelerationEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} HardwareAccelerationEnabled;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaTranscoder_adaptor::TrimStartTime)->_get_TrimStartTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMediaTranscoder_adaptor::TrimStartTime)->_put_TrimStartTime(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} TrimStartTime;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaTranscoder_adaptor::TrimStopTime)->_get_TrimStopTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMediaTranscoder_adaptor::TrimStopTime)->_put_TrimStopTime(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} TrimStopTime;
	};
	void AddAudioEffect(hstring_ref activatableClassId) { hrcheck(X::get()->_AddAudioEffect(activatableClassId)); }
	void AddAudioEffect(hstring_ref activatableClassId, bool effectRequired, pptr<Foundation::Collections::IPropertySet> configuration) { hrcheck(X::get()->_AddAudioEffectWithSettings(activatableClassId, effectRequired, configuration)); }
	void AddVideoEffect(hstring_ref activatableClassId) { hrcheck(X::get()->_AddVideoEffect(activatableClassId)); }
	void AddVideoEffect(hstring_ref activatableClassId, bool effectRequired, pptr<Foundation::Collections::IPropertySet> configuration) { hrcheck(X::get()->_AddVideoEffectWithSettings(activatableClassId, effectRequired, configuration)); }
	void ClearEffects() { hrcheck(X::get()->_ClearEffects()); }
	ptr<Foundation::IAsyncOperation<ptr<PrepareTranscodeResult>>> PrepareFileTranscodeAsync(pptr<Storage::IStorageFile> source, pptr<Storage::IStorageFile> destination, pptr<MediaProperties::MediaEncodingProfile> profile) { Foundation::IAsyncOperation<PrepareTranscodeResult*>* operation; hrcheck(X::get()->_PrepareFileTranscodeAsync(source, destination, profile, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<PrepareTranscodeResult>>> PrepareStreamTranscodeAsync(pptr<Storage::Streams::IRandomAccessStream> source, pptr<Storage::Streams::IRandomAccessStream> destination, pptr<MediaProperties::MediaEncodingProfile> profile) { Foundation::IAsyncOperation<PrepareTranscodeResult*>* operation; hrcheck(X::get()->_PrepareStreamTranscodeAsync(source, destination, profile, &operation)); return from_abi(operation); }
	IMediaTranscoder_adaptor() {}
};
template<typename X> struct adapt<IMediaTranscoder, X> : Windows::Media::Transcoding::IMediaTranscoder_adaptor<X> { typedef adapt IMediaTranscoder; };
struct IMediaTranscoder : IMediaTranscoder_raw, generate<IMediaTranscoder> {};

// MediaTranscoder
template<typename X> struct statics<MediaTranscoder, X> : X {
	typedef typename X::root_type MediaTranscoder;
};
struct MediaTranscoder : generate<MediaTranscoder> {
	using IMediaTranscoder::AddAudioEffect;
	using IMediaTranscoder::AddVideoEffect;
};
}}}
} // namespace iso_winrt
