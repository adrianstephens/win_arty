#pragma once
// generated by isopod tools
// namespaces:
// Windows.UI.Xaml

#include "Windows.UI.Xaml.0.h"
#include "Windows.UI.Xaml.Controls.0.h"
#include "Windows.ApplicationModel.DataTransfer.0.h"
#include "Windows.UI.Xaml.Media.0.h"
#include "Windows.ApplicationModel.DataTransfer.DragDrop.0.h"
#include "Windows.UI.Xaml.Input.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.UI.Xaml.Interop.0.h"
#include "Windows.Foundation.Collections.h"
#include "Windows.ApplicationModel.Core.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace ApplicationModel { namespace Activation {
struct CachedFileUpdaterActivatedEventArgs;
struct IActivatedEventArgs;
struct LaunchActivatedEventArgs;
struct ShareTargetActivatedEventArgs;
struct FileSavePickerActivatedEventArgs;
struct BackgroundActivatedEventArgs;
struct FileOpenPickerActivatedEventArgs;
struct SearchActivatedEventArgs;
struct FileActivatedEventArgs;
}
struct EnteredBackgroundEventArgs;
struct LeavingBackgroundEventArgs;
struct SuspendingEventArgs;
}
namespace Graphics { namespace Imaging {
struct SoftwareBitmap;
}}
namespace UI { namespace Composition {
struct Compositor;
}
namespace Core {
struct WindowSizeChangedEventArgs;
struct CoreWindowEventArgs;
struct WindowActivatedEventArgs;
struct CoreDispatcher;
struct VisibilityChangedEventArgs;
struct CoreWindow;
}
namespace Input {
struct PointerPoint;
}
namespace Xaml { namespace Automation { namespace Peers {
struct AutomationPeer;
}}
namespace Controls { namespace Primitives {
struct FlyoutBase;
}}
namespace Data {
struct BindingBase;
struct BindingExpression;
}
namespace Media { namespace Animation {
struct Storyboard;
struct TransitionCollection;
struct EasingFunctionBase;
}
namespace Imaging {
struct BitmapImage;
}
namespace Media3D {
struct Transform3D;
}}}}}

// defs

template<> struct def<Windows::UI::Xaml::IDataTemplateExtension> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::IDataTemplate> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IDataTemplateFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IDataTemplateStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IDispatcherTimer> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IDispatcherTimerFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::DispatcherTimer> : class_type<Platform::Object, Windows::UI::Xaml::IDispatcherTimer>, composer_type<Windows::UI::Xaml::IDispatcherTimerFactory> {};
template<> struct def<Windows::UI::Xaml::DurationType> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::ElementHighContrastAdjustment> : enum_type<unsigned> {};
template<> struct def<Windows::UI::Xaml::ElementSoundKind> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::ElementSoundMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::ElementTheme> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::FlowDirection> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::FocusState> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::FocusVisualKind> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::HorizontalAlignment> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::VerticalAlignment> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Visibility> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::CornerRadius> : value_type<double, double, double, double> {};
template<> struct def<Windows::UI::Xaml::ICornerRadiusHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::ICornerRadiusHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::CornerRadiusHelper> : class_type<Platform::Object, Windows::UI::Xaml::ICornerRadiusHelper> {};
template<> struct def<Windows::UI::Xaml::Duration> : value_type<Windows::Foundation::TimeSpan, Windows::UI::Xaml::DurationType> {};
template<> struct def<Windows::UI::Xaml::IDurationHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IDurationHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::DurationHelper> : class_type<Platform::Object, Windows::UI::Xaml::IDurationHelper> {};
template<> struct def<Windows::UI::Xaml::Thickness> : value_type<double, double, double, double> {};
template<> struct def<Windows::UI::Xaml::IThicknessHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IThicknessHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::ThicknessHelper> : class_type<Platform::Object, Windows::UI::Xaml::IThicknessHelper> {};
template<> struct def<Windows::UI::Xaml::TemplatePartAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::UI::Xaml::ApplicationInitializationCallback> : delegate_type {};
template<> struct def<Windows::UI::Xaml::IApplicationInitializationCallbackParams> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::ApplicationInitializationCallbackParams> : class_type<Platform::Object, Windows::UI::Xaml::IApplicationInitializationCallbackParams> {};
template<> struct def<Windows::UI::Xaml::CreateDefaultValueCallback> : delegate_type {};
template<> struct def<Windows::UI::Xaml::DependencyPropertyChangedCallback> : delegate_type {};
template<> struct def<Windows::UI::Xaml::IDependencyObjectFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IDependencyObject2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IDependencyObject> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::DependencyObject> : class_type<Platform::Object, Windows::UI::Xaml::IDependencyObject, Windows::UI::Xaml::IDependencyObject2> {};
template<> struct def<Windows::UI::Xaml::IDependencyPropertyStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IDependencyProperty> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::DependencyProperty> : class_type<Platform::Object, Windows::UI::Xaml::IDependencyProperty> {};
template<> struct def<Windows::UI::Xaml::DependencyPropertyChangedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::IDependencyPropertyChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::DependencyPropertyChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::IDependencyPropertyChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::DragEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::EnteredBackgroundEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::ExceptionRoutedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::LeavingBackgroundEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::PropertyChangedCallback> : delegate_type {};
template<> struct def<Windows::UI::Xaml::RoutedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::IRoutedEventArgsFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::RoutedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::IRoutedEventArgs>, composer_type<Windows::UI::Xaml::IRoutedEventArgsFactory> {};
template<> struct def<Windows::UI::Xaml::SizeChangedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::SuspendingEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::UnhandledExceptionEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::IUnhandledExceptionEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::UnhandledExceptionEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::IUnhandledExceptionEventArgs> {};
template<> struct def<Windows::UI::Xaml::VisualStateChangedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::IVisualStateChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::VisualStateChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::IVisualStateChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::WindowActivatedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::WindowClosedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::WindowSizeChangedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::WindowVisibilityChangedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::IBringIntoViewOptions> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IBringIntoViewOptions2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::BringIntoViewOptions> : class_type<Platform::Object, Windows::UI::Xaml::IBringIntoViewOptions, Windows::UI::Xaml::IBringIntoViewOptions2> {};
template<> struct def<Windows::UI::Xaml::IDataContextChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::DataContextChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::IDataContextChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::IDataTemplateKey> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IDataTemplateKeyFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::DataTemplateKey> : class_type<Platform::Object, Windows::UI::Xaml::IDataTemplateKey>, composer_type<Windows::UI::Xaml::IDataTemplateKeyFactory> {};
template<> struct def<Windows::UI::Xaml::IPropertyMetadataFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IPropertyMetadataStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IPropertyMetadata> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::PropertyMetadata> : class_type<Platform::Object, Windows::UI::Xaml::IPropertyMetadata>, composer_type<Windows::UI::Xaml::IPropertyMetadataFactory> {};
template<> struct def<Windows::UI::Xaml::IDragOperationDeferral> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::DragOperationDeferral> : class_type<Platform::Object, Windows::UI::Xaml::IDragOperationDeferral> {};
template<> struct def<Windows::UI::Xaml::IDragUI> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::DragUI> : class_type<Platform::Object, Windows::UI::Xaml::IDragUI> {};
template<> struct def<Windows::UI::Xaml::IDragUIOverride> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::DragUIOverride> : class_type<Platform::Object, Windows::UI::Xaml::IDragUIOverride> {};
template<> struct def<Windows::UI::Xaml::IFrameworkView> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::FrameworkView> : class_type<Platform::Object, Windows::UI::Xaml::IFrameworkView, Windows::ApplicationModel::Core::IFrameworkView> {};
template<> struct def<Windows::UI::Xaml::IRoutedEvent> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::RoutedEvent> : class_type<Platform::Object, Windows::UI::Xaml::IRoutedEvent> {};
template<> struct def<Windows::UI::Xaml::ISetterBaseFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::ISetterBase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::SetterBase> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::ISetterBase> {};
template<> struct def<Windows::UI::Xaml::ISetterBaseCollection> : interface_type<Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::SetterBase>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::SetterBase>>> {};
template<> struct def<Windows::UI::Xaml::SetterBaseCollection> : class_type<Platform::Object, Windows::UI::Xaml::ISetterBaseCollection> {};
template<> struct def<Windows::UI::Xaml::ITargetPropertyPath> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::ITargetPropertyPathFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::TargetPropertyPath> : class_type<Platform::Object, Windows::UI::Xaml::ITargetPropertyPath>, custom_activators {};
template<> struct def<Windows::UI::Xaml::ITriggerActionFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::ITriggerAction> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::TriggerAction> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::ITriggerAction> {};
template<> struct def<Windows::UI::Xaml::TriggerActionCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::TriggerAction>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::TriggerAction>>> {};
template<> struct def<Windows::UI::Xaml::ITriggerBaseFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::ITriggerBase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::TriggerBase> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::ITriggerBase> {};
template<> struct def<Windows::UI::Xaml::TriggerCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::TriggerBase>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::TriggerBase>>> {};
template<> struct def<Windows::UI::Xaml::IBringIntoViewRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::BringIntoViewRequestedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::IBringIntoViewRequestedEventArgs> {};
template<> struct def<Windows::UI::Xaml::IDependencyObjectCollectionFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::DependencyObjectCollection> : class_type<Windows::UI::Xaml::DependencyObject, Windows::Foundation::Collections::IObservableVector<ptr<Windows::UI::Xaml::DependencyObject>>, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::DependencyObject>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::DependencyObject>>>, composer_type<Windows::UI::Xaml::IDependencyObjectCollectionFactory> {};
template<> struct def<Windows::UI::Xaml::IDragEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IDragEventArgs2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IDragEventArgs3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::DragEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::IDragEventArgs, Windows::UI::Xaml::IDragEventArgs2, Windows::UI::Xaml::IDragEventArgs3> {};
template<> struct def<Windows::UI::Xaml::IDragStartingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IDragStartingEventArgs2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::DragStartingEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::IDragStartingEventArgs, Windows::UI::Xaml::IDragStartingEventArgs2> {};
template<> struct def<Windows::UI::Xaml::IDropCompletedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::DropCompletedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::IDropCompletedEventArgs> {};
template<> struct def<Windows::UI::Xaml::IExceptionRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IExceptionRoutedEventArgsFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::ExceptionRoutedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::IExceptionRoutedEventArgs> {};
template<> struct def<Windows::UI::Xaml::IFrameworkTemplate> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IFrameworkTemplateFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::FrameworkTemplate> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::IFrameworkTemplate> {};
template<> struct def<Windows::UI::Xaml::DataTemplate> : class_type<Windows::UI::Xaml::FrameworkTemplate, Windows::UI::Xaml::IDataTemplate>, composer_type<Windows::UI::Xaml::IDataTemplateFactory> {};
template<> struct def<Windows::UI::Xaml::IPropertyPath> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IPropertyPathFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::PropertyPath> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::IPropertyPath>, custom_activators {};
template<> struct def<Windows::UI::Xaml::IResourceDictionary> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IResourceDictionaryFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::ResourceDictionary> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::IResourceDictionary, Windows::Foundation::Collections::IMap<object, object>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<object, object>>>>, composer_type<Windows::UI::Xaml::IResourceDictionaryFactory> {};
template<> struct def<Windows::UI::Xaml::ISizeChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::SizeChangedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::ISizeChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::IStateTriggerBase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IStateTriggerBaseProtected> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IStateTriggerBaseFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::StateTriggerBase> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::IStateTriggerBase, Windows::UI::Xaml::IStateTriggerBaseProtected> {};
template<> struct def<Windows::UI::Xaml::IStyle> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IStyleFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Style> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::IStyle>, custom_activators {};
template<> struct def<Windows::UI::Xaml::IUIElement> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElementOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElementStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElementFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElement2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElementStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElement3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElementStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElement4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElementStatics4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElement5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElementStatics5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElementStatics6> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElement7> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElementOverrides7> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElementStatics7> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElement8> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElementOverrides8> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::IUIElementStatics8> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::UIElement> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::IUIElement, Windows::UI::Xaml::IUIElementOverrides, Windows::UI::Xaml::IUIElement2, Windows::UI::Xaml::IUIElement3, Windows::UI::Xaml::IUIElement4, Windows::UI::Xaml::IUIElement5, Windows::UI::Xaml::IUIElement7, Windows::UI::Xaml::IUIElementOverrides7, Windows::UI::Xaml::IUIElement8, Windows::UI::Xaml::IUIElementOverrides8> {};
template<> struct def<Windows::UI::Xaml::IVisualState> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IVisualState2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::VisualState> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::IVisualState, Windows::UI::Xaml::IVisualState2> {};
template<> struct def<Windows::UI::Xaml::IVisualStateGroup> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::VisualStateGroup> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::IVisualStateGroup> {};
template<> struct def<Windows::UI::Xaml::IVisualTransition> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IVisualTransitionFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::VisualTransition> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::IVisualTransition>, composer_type<Windows::UI::Xaml::IVisualTransitionFactory> {};
template<> struct def<Windows::UI::Xaml::IAdaptiveTrigger> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IAdaptiveTriggerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IAdaptiveTriggerFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::AdaptiveTrigger> : class_type<Windows::UI::Xaml::StateTriggerBase, Windows::UI::Xaml::IAdaptiveTrigger>, composer_type<Windows::UI::Xaml::IAdaptiveTriggerFactory> {};
template<> struct def<Windows::UI::Xaml::IEventTrigger> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::EventTrigger> : class_type<Windows::UI::Xaml::TriggerBase, Windows::UI::Xaml::IEventTrigger> {};
template<> struct def<Windows::UI::Xaml::IFrameworkElement> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IFrameworkElementOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::IFrameworkElementStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IFrameworkElementFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IFrameworkElement2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IFrameworkElementOverrides2> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::IFrameworkElementStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IFrameworkElement3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IFrameworkElement4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IFrameworkElementStatics4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IFrameworkElementStatics5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IFrameworkElement6> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IFrameworkElementStatics6> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::FrameworkElement> : class_type<Windows::UI::Xaml::UIElement, Windows::UI::Xaml::IFrameworkElement, Windows::UI::Xaml::IFrameworkElementOverrides, Windows::UI::Xaml::IFrameworkElement2, Windows::UI::Xaml::IFrameworkElementOverrides2, Windows::UI::Xaml::IFrameworkElement3, Windows::UI::Xaml::IFrameworkElement4, Windows::UI::Xaml::IFrameworkElement6> {};
template<> struct def<Windows::UI::Xaml::IMediaFailedRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::MediaFailedRoutedEventArgs> : class_type<Windows::UI::Xaml::ExceptionRoutedEventArgs, Windows::UI::Xaml::IMediaFailedRoutedEventArgs> {};
template<> struct def<Windows::UI::Xaml::ISetter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::ISetterFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::ISetter2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Setter> : class_type<Windows::UI::Xaml::SetterBase, Windows::UI::Xaml::ISetter, Windows::UI::Xaml::ISetter2>, custom_activators {};
template<> struct def<Windows::UI::Xaml::IStateTrigger> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IStateTriggerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::StateTrigger> : class_type<Windows::UI::Xaml::StateTriggerBase, Windows::UI::Xaml::IStateTrigger> {};
template<> struct def<Windows::UI::Xaml::ApplicationHighContrastAdjustment> : enum_type<unsigned> {};
template<> struct def<Windows::UI::Xaml::ApplicationRequiresPointerMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::ApplicationTheme> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::AutomationTextAttributesEnum> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::ElementSoundPlayerState> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::ElementSpatialAudioMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::FontCapitals> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::FontEastAsianLanguage> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::FontEastAsianWidths> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::FontFraction> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::FontNumeralAlignment> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::FontNumeralStyle> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::FontVariants> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::GridUnitType> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::LineStackingStrategy> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::OpticalMarginAlignment> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::TextAlignment> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::TextLineBounds> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::TextReadingOrder> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::TextTrimming> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::TextWrapping> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::GridLength> : value_type<double, Windows::UI::Xaml::GridUnitType> {};
template<> struct def<Windows::UI::Xaml::IGridLengthHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IGridLengthHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::GridLengthHelper> : class_type<Platform::Object, Windows::UI::Xaml::IGridLengthHelper> {};
template<> struct def<Windows::UI::Xaml::StyleTypedPropertyAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::UI::Xaml::TemplateVisualStateAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::UI::Xaml::BindingFailedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::IBindingFailedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::BindingFailedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::IBindingFailedEventArgs> {};
template<> struct def<Windows::UI::Xaml::IDebugSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IDebugSettings2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IDebugSettings3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::DebugSettings> : class_type<Platform::Object, Windows::UI::Xaml::IDebugSettings, Windows::UI::Xaml::IDebugSettings2, Windows::UI::Xaml::IDebugSettings3> {};
template<> struct def<Windows::UI::Xaml::IElementSoundPlayer> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IElementSoundPlayerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IElementSoundPlayerStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::ElementSoundPlayer> : class_type<Platform::Object, Windows::UI::Xaml::IElementSoundPlayer> {};
template<> struct def<Windows::UI::Xaml::IApplication> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IApplicationOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::IWindowCreatedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::WindowCreatedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::IWindowCreatedEventArgs> {};
template<> struct def<Windows::UI::Xaml::IApplicationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IApplicationFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IApplication3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IApplicationOverrides2> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::IApplication2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Application> : class_type<Platform::Object, Windows::UI::Xaml::IApplication, Windows::UI::Xaml::IApplicationOverrides, Windows::UI::Xaml::IApplication2, Windows::UI::Xaml::IApplicationOverrides2, Windows::UI::Xaml::IApplication3>, composer_type<Windows::UI::Xaml::IApplicationFactory> {};
template<> struct def<Windows::UI::Xaml::IFrameworkViewSource> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::FrameworkViewSource> : class_type<Platform::Object, Windows::UI::Xaml::IFrameworkViewSource, Windows::ApplicationModel::Core::IFrameworkViewSource> {};
template<> struct def<Windows::UI::Xaml::IPointHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IPointHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::PointHelper> : class_type<Platform::Object, Windows::UI::Xaml::IPointHelper> {};
template<> struct def<Windows::UI::Xaml::IRectHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IRectHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::RectHelper> : class_type<Platform::Object, Windows::UI::Xaml::IRectHelper> {};
template<> struct def<Windows::UI::Xaml::ISizeHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::ISizeHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::SizeHelper> : class_type<Platform::Object, Windows::UI::Xaml::ISizeHelper> {};
template<> struct def<Windows::UI::Xaml::IWindow> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IWindowStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IWindow3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IWindow2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Window> : class_type<Platform::Object, Windows::UI::Xaml::IWindow, Windows::UI::Xaml::IWindow2, Windows::UI::Xaml::IWindow3> {};
template<> struct def<Windows::UI::Xaml::IVisualStateManager> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IVisualStateManagerOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::IVisualStateManagerProtected> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IVisualStateManagerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::IVisualStateManagerFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::VisualStateManager> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::IVisualStateManager, Windows::UI::Xaml::IVisualStateManagerOverrides, Windows::UI::Xaml::IVisualStateManagerProtected>, composer_type<Windows::UI::Xaml::IVisualStateManagerFactory> {};

// uuids

template<> struct uuid<Windows::UI::Xaml::IDataTemplateExtension> { define_guid(0x595E9547, 0xCDFF, 0x4B92, 0xB7, 0x73, 0xAB, 0x39, 0x68, 0x78, 0xF3, 0x53);};
template<> struct uuid<Windows::UI::Xaml::IDataTemplate> { define_guid(0x9910AEC7, 0x8AB5, 0x4118, 0x9B, 0xC6, 0x9, 0xF4, 0x5A, 0x35, 0x7, 0x3D);};
template<> struct uuid<Windows::UI::Xaml::IDataTemplateFactory> { define_guid(0x51ED9D7E, 0x2B53, 0x475B, 0x9C, 0x88, 0xC, 0x18, 0x32, 0xC8, 0x35, 0x1A);};
template<> struct uuid<Windows::UI::Xaml::IDataTemplateStatics2> { define_guid(0x8AF77D73, 0xAA01, 0x471E, 0xBE, 0xDD, 0x8B, 0xAD, 0x86, 0x21, 0x9B, 0x77);};
template<> struct uuid<Windows::UI::Xaml::IDispatcherTimer> { define_guid(0xD160CE46, 0xCD22, 0x4F5F, 0x8C, 0x97, 0x40, 0xE6, 0x1D, 0xA3, 0xE2, 0xDC);};
template<> struct uuid<Windows::UI::Xaml::IDispatcherTimerFactory> { define_guid(0xE9961E6E, 0x3626, 0x403A, 0xAF, 0xE0, 0x4, 0xD, 0x58, 0x16, 0x56, 0x32);};
template<> struct uuid<Windows::UI::Xaml::ICornerRadiusHelper> { define_guid(0xFD7BE182, 0x1CDB, 0x4288, 0xB8, 0xC8, 0x85, 0xEE, 0x79, 0x29, 0x7B, 0xFC);};
template<> struct uuid<Windows::UI::Xaml::ICornerRadiusHelperStatics> { define_guid(0xF4A1F659, 0xD4D4, 0x451F, 0xA3, 0x87, 0xD6, 0xBF, 0x4B, 0x24, 0x51, 0xD4);};
template<> struct uuid<Windows::UI::Xaml::IDurationHelper> { define_guid(0x25C1659F, 0x4497, 0x4135, 0x94, 0xF, 0xEE, 0x96, 0xF4, 0xD6, 0xE9, 0x34);};
template<> struct uuid<Windows::UI::Xaml::IDurationHelperStatics> { define_guid(0xBC88093E, 0x3547, 0x4EC0, 0xB5, 0x19, 0xFF, 0xA8, 0xF9, 0xC4, 0x83, 0x8C);};
template<> struct uuid<Windows::UI::Xaml::IThicknessHelper> { define_guid(0xA86BAE4B, 0x1E8F, 0x4EEB, 0x90, 0x13, 0xB, 0x28, 0x38, 0xA9, 0x7B, 0x34);};
template<> struct uuid<Windows::UI::Xaml::IThicknessHelperStatics> { define_guid(0xC0991A7C, 0x70C, 0x4DA6, 0x87, 0x84, 0x1, 0xCA, 0x80, 0xE, 0xB7, 0x3A);};
template<> struct uuid<Windows::UI::Xaml::ApplicationInitializationCallback> { define_guid(0xB6351C55, 0xC284, 0x46E4, 0x83, 0x10, 0xFB, 0x9, 0x67, 0xFA, 0xB7, 0x6F);};
template<> struct uuid<Windows::UI::Xaml::IApplicationInitializationCallbackParams> { define_guid(0x751B792E, 0x5772, 0x4488, 0x8B, 0x87, 0xF5, 0x47, 0xFA, 0xA6, 0x44, 0x74);};
template<> struct uuid<Windows::UI::Xaml::CreateDefaultValueCallback> { define_guid(0xD6ECB12C, 0x15B5, 0x4EC8, 0xB9, 0x5C, 0xCD, 0xD2, 0x8, 0xF0, 0x81, 0x53);};
template<> struct uuid<Windows::UI::Xaml::DependencyPropertyChangedCallback> { define_guid(0x45883D16, 0x27BF, 0x4BC1, 0xAC, 0x26, 0x94, 0xC1, 0x60, 0x1F, 0x3A, 0x49);};
template<> struct uuid<Windows::UI::Xaml::IDependencyObjectFactory> { define_guid(0x9A03AF92, 0x7D8A, 0x4937, 0x88, 0x4F, 0xEC, 0xF3, 0x4F, 0xE0, 0x2A, 0xCB);};
template<> struct uuid<Windows::UI::Xaml::IDependencyObject2> { define_guid(0x29FED85D, 0x3D22, 0x43A1, 0xAD, 0xD0, 0x17, 0x2, 0x7C, 0x8, 0xB2, 0x12);};
template<> struct uuid<Windows::UI::Xaml::IDependencyObject> { define_guid(0x5C526665, 0xF60E, 0x4912, 0xAF, 0x59, 0x5F, 0xE0, 0x68, 0xF, 0x8, 0x9D);};
template<> struct uuid<Windows::UI::Xaml::IDependencyPropertyStatics> { define_guid(0x49E5F28F, 0x8259, 0x4D5C, 0xAA, 0xE0, 0x83, 0xD5, 0x6D, 0xBB, 0x68, 0xD9);};
template<> struct uuid<Windows::UI::Xaml::IDependencyProperty> { define_guid(0x85B13970, 0x9BC4, 0x4E96, 0xAC, 0xF1, 0x30, 0xC8, 0xFD, 0x3D, 0x55, 0xC8);};
template<> struct uuid<Windows::UI::Xaml::DependencyPropertyChangedEventHandler> { define_guid(0x9223E5A, 0x75BE, 0x4499, 0x81, 0x80, 0x1D, 0xDC, 0x0, 0x54, 0x21, 0xC0);};
template<> struct uuid<Windows::UI::Xaml::IDependencyPropertyChangedEventArgs> { define_guid(0x81212C2B, 0x24D0, 0x4957, 0xAB, 0xC3, 0x22, 0x44, 0x70, 0xA9, 0x3A, 0x4E);};
template<> struct uuid<Windows::UI::Xaml::DragEventHandler> { define_guid(0x2AB1A205, 0x1E73, 0x4BCF, 0xAA, 0xBC, 0x57, 0xB9, 0x7E, 0x21, 0x96, 0x1D);};
template<> struct uuid<Windows::UI::Xaml::EnteredBackgroundEventHandler> { define_guid(0x93A956AE, 0x1D7F, 0x438B, 0xB7, 0xB8, 0x22, 0x7D, 0x96, 0xB6, 0x9, 0xC0);};
template<> struct uuid<Windows::UI::Xaml::ExceptionRoutedEventHandler> { define_guid(0x68E0E810, 0xF6EA, 0x42BC, 0x85, 0x5B, 0x5D, 0x9B, 0x67, 0xE6, 0xA2, 0x62);};
template<> struct uuid<Windows::UI::Xaml::LeavingBackgroundEventHandler> { define_guid(0xAAAD5DAD, 0x4FC6, 0x4AA4, 0xB7, 0xCF, 0x87, 0x7E, 0x36, 0xAD, 0xA4, 0xF6);};
template<> struct uuid<Windows::UI::Xaml::PropertyChangedCallback> { define_guid(0x5A9F8A25, 0xD142, 0x44A4, 0x82, 0x31, 0xFD, 0x67, 0x67, 0x24, 0xF2, 0x9B);};
template<> struct uuid<Windows::UI::Xaml::RoutedEventHandler> { define_guid(0xA856E674, 0xB0B6, 0x4BC3, 0xBB, 0xA8, 0x1B, 0xA0, 0x6E, 0x40, 0xD4, 0xB5);};
template<> struct uuid<Windows::UI::Xaml::IRoutedEventArgsFactory> { define_guid(0xB61C4D87, 0x70E5, 0x412E, 0xB5, 0x20, 0x1A, 0x41, 0xEE, 0x76, 0xBB, 0xF4);};
template<> struct uuid<Windows::UI::Xaml::IRoutedEventArgs> { define_guid(0x5C985AC6, 0xD802, 0x4B38, 0xA2, 0x23, 0xBF, 0x7, 0xC, 0x43, 0xFE, 0xDF);};
template<> struct uuid<Windows::UI::Xaml::SizeChangedEventHandler> { define_guid(0x1115B13C, 0x25D2, 0x480B, 0x89, 0xDC, 0xEB, 0x3D, 0xCB, 0xD6, 0xB7, 0xFA);};
template<> struct uuid<Windows::UI::Xaml::SuspendingEventHandler> { define_guid(0x23429465, 0xE36A, 0x40E2, 0xB1, 0x39, 0xA4, 0x70, 0x46, 0x2, 0xA6, 0xE1);};
template<> struct uuid<Windows::UI::Xaml::UnhandledExceptionEventHandler> { define_guid(0x9274E6BD, 0x49A1, 0x4958, 0xBE, 0xEE, 0xD0, 0xE1, 0x95, 0x87, 0xB6, 0xE3);};
template<> struct uuid<Windows::UI::Xaml::IUnhandledExceptionEventArgs> { define_guid(0x7230269C, 0x54E, 0x4CF3, 0x86, 0xC5, 0xBE, 0x90, 0xEB, 0x68, 0x63, 0xD5);};
template<> struct uuid<Windows::UI::Xaml::VisualStateChangedEventHandler> { define_guid(0xE6D5BBD5, 0xE029, 0x43A6, 0xB3, 0x6D, 0x84, 0xA8, 0x10, 0x42, 0xD7, 0x74);};
template<> struct uuid<Windows::UI::Xaml::IVisualStateChangedEventArgs> { define_guid(0xFE216AB1, 0xF31F, 0x4791, 0x89, 0x89, 0xC7, 0xE, 0x1D, 0x9B, 0x59, 0xFF);};
template<> struct uuid<Windows::UI::Xaml::WindowActivatedEventHandler> { define_guid(0x18026348, 0x8619, 0x4C7B, 0xB5, 0x34, 0xCE, 0xD4, 0x5D, 0x9D, 0xE2, 0x19);};
template<> struct uuid<Windows::UI::Xaml::WindowClosedEventHandler> { define_guid(0xDB89161, 0x20D7, 0x45DF, 0x91, 0x22, 0xBA, 0x89, 0x57, 0x67, 0x3, 0xBA);};
template<> struct uuid<Windows::UI::Xaml::WindowSizeChangedEventHandler> { define_guid(0x5C21C742, 0x2CED, 0x4FD9, 0xBA, 0x38, 0x71, 0x18, 0xD4, 0xE, 0x96, 0x6B);};
template<> struct uuid<Windows::UI::Xaml::WindowVisibilityChangedEventHandler> { define_guid(0x10406AD6, 0xB090, 0x4A4A, 0xB2, 0xAD, 0xD6, 0x82, 0xDF, 0x27, 0x13, 0xF);};
template<> struct uuid<Windows::UI::Xaml::IBringIntoViewOptions> { define_guid(0x19BDD1B5, 0xC7CB, 0x46D9, 0xA4, 0xDD, 0xA1, 0xBB, 0xE8, 0x3E, 0xF2, 0xFB);};
template<> struct uuid<Windows::UI::Xaml::IBringIntoViewOptions2> { define_guid(0xE855E08E, 0x64B6, 0x1211, 0xBD, 0xDB, 0x1F, 0xDD, 0xBB, 0x6E, 0x82, 0x31);};
template<> struct uuid<Windows::UI::Xaml::IDataContextChangedEventArgs> { define_guid(0x7DA68E21, 0xB8F, 0x4F9F, 0xA1, 0x43, 0xF8, 0xE7, 0x78, 0x1, 0x36, 0xA2);};
template<> struct uuid<Windows::UI::Xaml::IDataTemplateKey> { define_guid(0x873B6C28, 0xCCEB, 0x4B61, 0x86, 0xFA, 0xB2, 0xCE, 0xC3, 0x9C, 0xC2, 0xFA);};
template<> struct uuid<Windows::UI::Xaml::IDataTemplateKeyFactory> { define_guid(0xE96B2959, 0xD982, 0x4152, 0x91, 0xCB, 0xDE, 0xE, 0x4D, 0xFD, 0x76, 0x93);};
template<> struct uuid<Windows::UI::Xaml::IPropertyMetadataFactory> { define_guid(0xC1B81CC0, 0x57CD, 0x4F2F, 0xB0, 0xA9, 0xE1, 0x80, 0x1B, 0x28, 0xF7, 0x6B);};
template<> struct uuid<Windows::UI::Xaml::IPropertyMetadataStatics> { define_guid(0x3B01077A, 0x6E06, 0x45E9, 0x8B, 0x5C, 0xAF, 0x24, 0x34, 0x58, 0xC0, 0x62);};
template<> struct uuid<Windows::UI::Xaml::IPropertyMetadata> { define_guid(0x814EF30D, 0x8D18, 0x448A, 0x86, 0x44, 0xF2, 0xCB, 0x51, 0xE7, 0x3, 0x80);};
template<> struct uuid<Windows::UI::Xaml::IDragOperationDeferral> { define_guid(0xBA73ECBA, 0x1B73, 0x4086, 0xB3, 0xD3, 0xC2, 0x23, 0xBE, 0xEA, 0x16, 0x33);};
template<> struct uuid<Windows::UI::Xaml::IDragUI> { define_guid(0x2D9BD838, 0x7C60, 0x4842, 0x91, 0x70, 0x34, 0x6F, 0xE1, 0xA, 0x22, 0x6A);};
template<> struct uuid<Windows::UI::Xaml::IDragUIOverride> { define_guid(0xBD6C9DFA, 0xC961, 0x4861, 0xB7, 0xA5, 0xBF, 0x4F, 0xE4, 0xA8, 0xA6, 0xEF);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkView> { define_guid(0xDDBA664B, 0xB603, 0x47AA, 0x94, 0x2D, 0x38, 0x33, 0x17, 0x4F, 0xD, 0x80);};
template<> struct uuid<Windows::UI::Xaml::IRoutedEvent> { define_guid(0xA6B25818, 0x43C1, 0x4C70, 0x86, 0x5C, 0x7B, 0xDD, 0x5A, 0x32, 0xE3, 0x27);};
template<> struct uuid<Windows::UI::Xaml::ISetterBaseFactory> { define_guid(0x81F8AD60, 0x1CE8, 0x469D, 0xA6, 0x67, 0x16, 0xE3, 0x7C, 0xEF, 0x8B, 0xA9);};
template<> struct uuid<Windows::UI::Xaml::ISetterBase> { define_guid(0x418BE27C, 0x2AC4, 0x4F22, 0x80, 0x97, 0xDE, 0xA3, 0xAE, 0xEB, 0x2F, 0xB3);};
template<> struct uuid<Windows::UI::Xaml::ISetterBaseCollection> { define_guid(0x3C40CA8, 0x909E, 0x4117, 0x81, 0x1C, 0xA4, 0x52, 0x94, 0x96, 0xBD, 0xF1);};
template<> struct uuid<Windows::UI::Xaml::ITargetPropertyPath> { define_guid(0x40740F8E, 0x85F, 0x4CED, 0xBE, 0x70, 0x6F, 0x47, 0xAC, 0xF1, 0x5A, 0xD0);};
template<> struct uuid<Windows::UI::Xaml::ITargetPropertyPathFactory> { define_guid(0x88EECCC8, 0x99E2, 0x4A44, 0x99, 0x7, 0xB4, 0x4B, 0xC8, 0x6E, 0x2B, 0xBE);};
template<> struct uuid<Windows::UI::Xaml::ITriggerActionFactory> { define_guid(0x68D2C0B9, 0x3289, 0x414F, 0x8F, 0x6E, 0xC6, 0xB9, 0x7A, 0xED, 0xDA, 0x3);};
template<> struct uuid<Windows::UI::Xaml::ITriggerAction> { define_guid(0xA2C0DF02, 0x63D5, 0x4B46, 0x9B, 0x83, 0x8, 0x68, 0xD3, 0x7, 0x96, 0x21);};
template<> struct uuid<Windows::UI::Xaml::ITriggerBaseFactory> { define_guid(0x6A3B9E57, 0xFC5D, 0x42D0, 0x8C, 0xB9, 0xCA, 0x50, 0x66, 0x7A, 0xF7, 0x46);};
template<> struct uuid<Windows::UI::Xaml::ITriggerBase> { define_guid(0xE7EA222F, 0xDEE6, 0x4393, 0xA8, 0xB2, 0x89, 0x23, 0xD6, 0x41, 0xF3, 0x95);};
template<> struct uuid<Windows::UI::Xaml::IBringIntoViewRequestedEventArgs> { define_guid(0xE629EC4, 0x2206, 0x4C8B, 0x94, 0xAE, 0xBD, 0xB6, 0x6A, 0x4E, 0xBF, 0xD1);};
template<> struct uuid<Windows::UI::Xaml::IDependencyObjectCollectionFactory> { define_guid(0x51E79FF, 0xB3A8, 0x49EE, 0xB5, 0xAF, 0xAC, 0x8F, 0x68, 0xB6, 0x49, 0xE4);};
template<> struct uuid<Windows::UI::Xaml::IDragEventArgs> { define_guid(0xB440C7C3, 0x2B4, 0x4980, 0x93, 0x42, 0x25, 0xDA, 0xE1, 0xC0, 0xF1, 0x88);};
template<> struct uuid<Windows::UI::Xaml::IDragEventArgs2> { define_guid(0x26336658, 0x2917, 0x411D, 0xBF, 0xC3, 0x2F, 0x22, 0x47, 0x1C, 0xBB, 0xE7);};
template<> struct uuid<Windows::UI::Xaml::IDragEventArgs3> { define_guid(0xD04FC3C6, 0x8119, 0x427A, 0x81, 0x52, 0x5F, 0x95, 0x50, 0xCC, 0x4, 0x16);};
template<> struct uuid<Windows::UI::Xaml::IDragStartingEventArgs> { define_guid(0x6800D3FA, 0x90B8, 0x46F9, 0x8E, 0x30, 0x5A, 0xC2, 0x5F, 0x73, 0xF0, 0xF9);};
template<> struct uuid<Windows::UI::Xaml::IDragStartingEventArgs2> { define_guid(0xD855E08E, 0x44B6, 0x4211, 0xBD, 0xB, 0x7F, 0xDD, 0xBB, 0x6E, 0x82, 0x31);};
template<> struct uuid<Windows::UI::Xaml::IDropCompletedEventArgs> { define_guid(0x6C4FC188, 0x95BC, 0x4261, 0x9E, 0xC5, 0x21, 0xCA, 0xB6, 0x77, 0xB7, 0x34);};
template<> struct uuid<Windows::UI::Xaml::IExceptionRoutedEventArgs> { define_guid(0xDD9FF16A, 0x4B62, 0x4A6C, 0xA4, 0x9D, 0x6, 0x71, 0xEF, 0x61, 0x36, 0xBE);};
template<> struct uuid<Windows::UI::Xaml::IExceptionRoutedEventArgsFactory> { define_guid(0xBBA9826D, 0x5D7A, 0x44E7, 0xB8, 0x93, 0xB2, 0xAE, 0xD, 0xD2, 0x42, 0x73);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkTemplate> { define_guid(0xA1E254D8, 0xA446, 0x4A27, 0x9A, 0x9D, 0xA0, 0xF5, 0x9E, 0x12, 0x58, 0xA5);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkTemplateFactory> { define_guid(0x1A78A0A5, 0x937D, 0x46D4, 0x83, 0x2B, 0x94, 0xFF, 0x14, 0xDA, 0xB0, 0x61);};
template<> struct uuid<Windows::UI::Xaml::IPropertyPath> { define_guid(0x300E5D8A, 0x1FF3, 0x4D2C, 0x95, 0xEC, 0x27, 0xF8, 0x1D, 0xEB, 0xAC, 0xB8);};
template<> struct uuid<Windows::UI::Xaml::IPropertyPathFactory> { define_guid(0x4E4CDF99, 0x9826, 0x4E56, 0x84, 0x7C, 0xCA, 0x5, 0x5F, 0x16, 0x29, 0x5);};
template<> struct uuid<Windows::UI::Xaml::IResourceDictionary> { define_guid(0xC1EA4F24, 0xD6DE, 0x4191, 0x8E, 0x3A, 0xF4, 0x86, 0x1, 0xF7, 0x48, 0x9C);};
template<> struct uuid<Windows::UI::Xaml::IResourceDictionaryFactory> { define_guid(0xEA3639B5, 0x31B7, 0x4271, 0x92, 0xC9, 0x7C, 0x95, 0x84, 0xA9, 0x1C, 0x22);};
template<> struct uuid<Windows::UI::Xaml::ISizeChangedEventArgs> { define_guid(0xD5312E60, 0x5CC1, 0x42A1, 0x92, 0xC, 0x1A, 0xF4, 0x6B, 0xE2, 0xF9, 0x86);};
template<> struct uuid<Windows::UI::Xaml::IStateTriggerBase> { define_guid(0x48B20698, 0xAF06, 0x466C, 0x80, 0x52, 0x93, 0x66, 0x6D, 0xDE, 0xE, 0x49);};
template<> struct uuid<Windows::UI::Xaml::IStateTriggerBaseProtected> { define_guid(0x3C41E253, 0x8D14, 0x4216, 0x99, 0x4C, 0xF9, 0x93, 0x4, 0x29, 0xF6, 0xE5);};
template<> struct uuid<Windows::UI::Xaml::IStateTriggerBaseFactory> { define_guid(0x970E2C4B, 0xBFAF, 0x47B0, 0xBE, 0x42, 0xC1, 0xD7, 0x11, 0xBB, 0x2E, 0x9F);};
template<> struct uuid<Windows::UI::Xaml::IStyle> { define_guid(0xC4A9F225, 0x9DB7, 0x4A7D, 0xB6, 0xD1, 0xF7, 0x4E, 0xDB, 0x92, 0x93, 0xC2);};
template<> struct uuid<Windows::UI::Xaml::IStyleFactory> { define_guid(0xA36824E3, 0x3D81, 0x4CE5, 0xAA, 0x51, 0x8B, 0x41, 0xF, 0x60, 0x2F, 0xCD);};
template<> struct uuid<Windows::UI::Xaml::IUIElement> { define_guid(0x676D0BE9, 0xB65C, 0x41C6, 0xBA, 0x40, 0x58, 0xCF, 0x87, 0xF2, 0x1, 0xC1);};
template<> struct uuid<Windows::UI::Xaml::IUIElementOverrides> { define_guid(0x608D2F1D, 0x7858, 0x4AEB, 0x89, 0xE4, 0xB5, 0x4E, 0x2C, 0x7E, 0xD3, 0xD3);};
template<> struct uuid<Windows::UI::Xaml::IUIElementStatics> { define_guid(0x58D3573B, 0xF52C, 0x45BE, 0x98, 0x8B, 0xA5, 0x86, 0x95, 0x64, 0x87, 0x3C);};
template<> struct uuid<Windows::UI::Xaml::IUIElementFactory> { define_guid(0xB9EE93FE, 0xA338, 0x419F, 0xAC, 0x32, 0x91, 0xDC, 0xAA, 0xDF, 0x5D, 0x8);};
template<> struct uuid<Windows::UI::Xaml::IUIElement2> { define_guid(0x676D0BF9, 0xB66C, 0x41D6, 0xBA, 0x50, 0x58, 0xCF, 0x87, 0xF2, 0x1, 0xD1);};
template<> struct uuid<Windows::UI::Xaml::IUIElementStatics2> { define_guid(0x58D3574B, 0xF53C, 0x45BE, 0x98, 0x9B, 0xA5, 0x86, 0x95, 0x64, 0x87, 0x4C);};
template<> struct uuid<Windows::UI::Xaml::IUIElement3> { define_guid(0xBC2B28F1, 0x26F2, 0x4AAB, 0xB2, 0x56, 0x3B, 0x53, 0x50, 0x88, 0x1E, 0x37);};
template<> struct uuid<Windows::UI::Xaml::IUIElementStatics3> { define_guid(0xD1F87ADE, 0xECA1, 0x4561, 0xA3, 0x2B, 0x64, 0x60, 0x1B, 0x4E, 0x5, 0x97);};
template<> struct uuid<Windows::UI::Xaml::IUIElement4> { define_guid(0x69145CD4, 0x199A, 0x4657, 0x9E, 0x57, 0xE9, 0x9E, 0x8F, 0x13, 0x67, 0x12);};
template<> struct uuid<Windows::UI::Xaml::IUIElementStatics4> { define_guid(0x1D157D61, 0x16AF, 0x411F, 0xB7, 0x74, 0x27, 0x23, 0x75, 0xA4, 0xAC, 0x2C);};
template<> struct uuid<Windows::UI::Xaml::IUIElement5> { define_guid(0x8EED9BC2, 0xA58C, 0x4453, 0xAF, 0xF, 0xA9, 0x2E, 0xE0, 0x6D, 0x3, 0x17);};
template<> struct uuid<Windows::UI::Xaml::IUIElementStatics5> { define_guid(0x59BD7D91, 0x8FA3, 0x4C65, 0xBA, 0x1B, 0x40, 0xDF, 0x38, 0x55, 0x6C, 0xBB);};
template<> struct uuid<Windows::UI::Xaml::IUIElementStatics6> { define_guid(0x647E03B7, 0x36A, 0x4DEA, 0x95, 0x40, 0x1D, 0xD7, 0xFD, 0x12, 0x66, 0xF1);};
template<> struct uuid<Windows::UI::Xaml::IUIElement7> { define_guid(0xCAFC4968, 0x6369, 0x4249, 0x80, 0xF9, 0x3D, 0x65, 0x63, 0x19, 0xE8, 0x11);};
template<> struct uuid<Windows::UI::Xaml::IUIElementOverrides7> { define_guid(0xB97F7F68, 0xC29B, 0x4C99, 0xA1, 0xC3, 0x95, 0x26, 0x19, 0xD6, 0xE7, 0x20);};
template<> struct uuid<Windows::UI::Xaml::IUIElementStatics7> { define_guid(0xDA9B4493, 0xA695, 0x4145, 0xAE, 0x93, 0x88, 0x80, 0x24, 0x39, 0x6A, 0xF);};
template<> struct uuid<Windows::UI::Xaml::IUIElement8> { define_guid(0x3AB70E85, 0xD508, 0x4477, 0xB6, 0xF8, 0xE, 0x43, 0x57, 0x1, 0xC8, 0x36);};
template<> struct uuid<Windows::UI::Xaml::IUIElementOverrides8> { define_guid(0x4A5A645C, 0x548D, 0x48CF, 0xB9, 0x98, 0x78, 0x44, 0xD6, 0xE2, 0x35, 0xA1);};
template<> struct uuid<Windows::UI::Xaml::IUIElementStatics8> { define_guid(0x17BE3487, 0x4875, 0x4915, 0xB0, 0xB1, 0xA4, 0xC0, 0xF8, 0x51, 0xDF, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::IVisualState> { define_guid(0x6320AFFC, 0xC31A, 0x4450, 0xAF, 0xDE, 0xF6, 0xEA, 0x7B, 0xD1, 0xF5, 0x86);};
template<> struct uuid<Windows::UI::Xaml::IVisualState2> { define_guid(0xFA0F896, 0x64C0, 0x45FB, 0x8D, 0x24, 0xFB, 0x83, 0x29, 0x8C, 0xD, 0x93);};
template<> struct uuid<Windows::UI::Xaml::IVisualStateGroup> { define_guid(0xE4F9D9A4, 0xE028, 0x44DE, 0x9B, 0x15, 0x49, 0x29, 0xAE, 0xA, 0x26, 0xC2);};
template<> struct uuid<Windows::UI::Xaml::IVisualTransition> { define_guid(0x55C5905E, 0x2BC7, 0x400D, 0xAA, 0xA4, 0x1A, 0x29, 0x81, 0x49, 0x1E, 0xE0);};
template<> struct uuid<Windows::UI::Xaml::IVisualTransitionFactory> { define_guid(0xEA75864F, 0xD1E0, 0x4DAE, 0xB4, 0x29, 0x89, 0xFC, 0x32, 0x27, 0x24, 0xF4);};
template<> struct uuid<Windows::UI::Xaml::IAdaptiveTrigger> { define_guid(0xA5F04119, 0xCD9, 0x49F1, 0xA2, 0x3F, 0x44, 0xE5, 0x47, 0xAB, 0x9F, 0x1A);};
template<> struct uuid<Windows::UI::Xaml::IAdaptiveTriggerStatics> { define_guid(0xB92E29EA, 0x1615, 0x4350, 0x9C, 0x3B, 0x92, 0xB2, 0x98, 0x6B, 0xF4, 0x44);};
template<> struct uuid<Windows::UI::Xaml::IAdaptiveTriggerFactory> { define_guid(0xC966D482, 0x5AEB, 0x4841, 0x92, 0x47, 0xC1, 0xA0, 0xBD, 0xD6, 0xF5, 0x9F);};
template<> struct uuid<Windows::UI::Xaml::IEventTrigger> { define_guid(0xDEF8F855, 0xB49, 0x4087, 0xB1, 0xA9, 0xB8, 0xB3, 0x84, 0x88, 0xF7, 0x86);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkElement> { define_guid(0xA391D09B, 0x4A99, 0x4B7C, 0x9D, 0x8D, 0x6F, 0xA5, 0xD0, 0x1F, 0x6F, 0xBF);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkElementOverrides> { define_guid(0xDA007E54, 0xB3C2, 0x4B9A, 0xAA, 0x8E, 0xD3, 0xF0, 0x71, 0x26, 0x2B, 0x97);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkElementStatics> { define_guid(0x48383032, 0xFBEB, 0x4F8A, 0xAE, 0xD2, 0xEE, 0x21, 0xFB, 0x27, 0xA5, 0x7B);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkElementFactory> { define_guid(0xDEAEE126, 0x3CA, 0x4966, 0xB5, 0x76, 0x60, 0x4C, 0xCE, 0x93, 0xB5, 0xE8);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkElement2> { define_guid(0xF19104BE, 0x422A, 0x4904, 0xA5, 0x2F, 0xEE, 0x72, 0x1, 0x4, 0x29, 0xE5);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkElementOverrides2> { define_guid(0xCB5CD2B9, 0xE3B4, 0x458C, 0xB6, 0x4E, 0x14, 0x34, 0xFD, 0x1B, 0xD8, 0x8A);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkElementStatics2> { define_guid(0x9695DB02, 0xC0D8, 0x4FA2, 0xB1, 0x0, 0x3F, 0xA2, 0xDF, 0x8B, 0x95, 0x38);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkElement3> { define_guid(0xC81C2720, 0x5C52, 0x4BBE, 0xA1, 0x99, 0x2B, 0x1E, 0x34, 0xF0, 0xF, 0x70);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkElement4> { define_guid(0x6B765BB3, 0xFBA3, 0x4404, 0xBD, 0xEE, 0x1A, 0x45, 0xD1, 0xCA, 0x5F, 0x21);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkElementStatics4> { define_guid(0x9C41B155, 0xC5D8, 0x4663, 0xBF, 0xF2, 0xD8, 0xD5, 0x4F, 0xB5, 0xDB, 0xB3);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkElementStatics5> { define_guid(0x525D3941, 0xB3C, 0x4BE6, 0x99, 0x78, 0x19, 0xA8, 0x2, 0x5C, 0x9, 0xD8);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkElement6> { define_guid(0x792A5D91, 0x62A1, 0x40BF, 0xA0, 0xCE, 0xF9, 0xC1, 0x31, 0xFC, 0xB7, 0xA7);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkElementStatics6> { define_guid(0xFCC1529A, 0x69DB, 0x4582, 0xA7, 0xBE, 0xCF, 0x6A, 0x1C, 0xFD, 0xAC, 0xD0);};
template<> struct uuid<Windows::UI::Xaml::IMediaFailedRoutedEventArgs> { define_guid(0x46D1FA8D, 0x5149, 0x4153, 0xBA, 0x3C, 0xB0, 0x3E, 0x64, 0xEE, 0x53, 0x1E);};
template<> struct uuid<Windows::UI::Xaml::ISetter> { define_guid(0xA73DED29, 0xB4AE, 0x4A81, 0xBE, 0x85, 0xE6, 0x90, 0xBA, 0xD, 0x3B, 0x6E);};
template<> struct uuid<Windows::UI::Xaml::ISetterFactory> { define_guid(0xD3CA3D42, 0x9B1, 0x49D5, 0x88, 0x91, 0xE7, 0xB5, 0x64, 0x8E, 0x2, 0xA2);};
template<> struct uuid<Windows::UI::Xaml::ISetter2> { define_guid(0x70169561, 0x5B1, 0x4FA3, 0x9D, 0x53, 0x8E, 0xC, 0x8C, 0x74, 0x7A, 0xFC);};
template<> struct uuid<Windows::UI::Xaml::IStateTrigger> { define_guid(0x67ADEF2E, 0xD8D9, 0x49F7, 0xA1, 0xFD, 0x2E, 0x35, 0xEE, 0xDD, 0x23, 0xCD);};
template<> struct uuid<Windows::UI::Xaml::IStateTriggerStatics> { define_guid(0x71E95C90, 0xB3FE, 0x4DD3, 0xA8, 0xA8, 0x44, 0xA2, 0xCE, 0x25, 0xE0, 0xB8);};
template<> struct uuid<Windows::UI::Xaml::IGridLengthHelper> { define_guid(0x7A826CE1, 0x7A0, 0x4083, 0xB6, 0xD1, 0xB1, 0xD9, 0x17, 0xB9, 0x76, 0xAC);};
template<> struct uuid<Windows::UI::Xaml::IGridLengthHelperStatics> { define_guid(0x9D457B9B, 0x19F, 0x4266, 0x88, 0x72, 0x21, 0x5F, 0x19, 0x8F, 0x6A, 0x9D);};
template<> struct uuid<Windows::UI::Xaml::BindingFailedEventHandler> { define_guid(0x136B1782, 0x54BA, 0x420D, 0xA1, 0xAA, 0x82, 0x82, 0x87, 0x21, 0xCD, 0xE6);};
template<> struct uuid<Windows::UI::Xaml::IBindingFailedEventArgs> { define_guid(0x32C1D013, 0x4DBD, 0x446D, 0xBB, 0xB8, 0xD, 0xE3, 0x50, 0x48, 0xA4, 0x49);};
template<> struct uuid<Windows::UI::Xaml::IDebugSettings> { define_guid(0x3D451F98, 0xC6A7, 0x4D17, 0x83, 0x98, 0xD8, 0x3A, 0x6, 0x71, 0x83, 0xD8);};
template<> struct uuid<Windows::UI::Xaml::IDebugSettings2> { define_guid(0x48D37585, 0xE1A6, 0x469B, 0x83, 0xC8, 0x30, 0x82, 0x50, 0x37, 0x11, 0x9E);};
template<> struct uuid<Windows::UI::Xaml::IDebugSettings3> { define_guid(0xE6BB5022, 0x625, 0x479F, 0x8E, 0x32, 0x4B, 0x58, 0x3D, 0x73, 0xB7, 0xAC);};
template<> struct uuid<Windows::UI::Xaml::IElementSoundPlayer> { define_guid(0x387773A5, 0xF036, 0x460C, 0x9B, 0x81, 0xF3, 0xD6, 0xEA, 0x43, 0xF6, 0xF2);};
template<> struct uuid<Windows::UI::Xaml::IElementSoundPlayerStatics> { define_guid(0x217A9004, 0x981D, 0x41C9, 0xB1, 0x52, 0xAD, 0xA9, 0x11, 0xA4, 0xB1, 0x3A);};
template<> struct uuid<Windows::UI::Xaml::IElementSoundPlayerStatics2> { define_guid(0xF2505956, 0xED41, 0x48D7, 0xAA, 0xE8, 0xF2, 0xAB, 0xCB, 0x44, 0x49, 0x29);};
template<> struct uuid<Windows::UI::Xaml::IApplication> { define_guid(0x74B861A1, 0x7487, 0x46A9, 0x9A, 0x6E, 0xC7, 0x8B, 0x51, 0x27, 0x26, 0xC5);};
template<> struct uuid<Windows::UI::Xaml::IApplicationOverrides> { define_guid(0x25F99FF7, 0x9347, 0x459A, 0x9F, 0xAC, 0xB2, 0xD0, 0xE1, 0x1C, 0x1A, 0xF);};
template<> struct uuid<Windows::UI::Xaml::IWindowCreatedEventArgs> { define_guid(0x31B71470, 0xFEFF, 0x4654, 0xAF, 0x48, 0x9B, 0x39, 0x8A, 0xB5, 0x77, 0x2B);};
template<> struct uuid<Windows::UI::Xaml::IApplicationStatics> { define_guid(0x6499997, 0xF7B4, 0x45FE, 0xB7, 0x63, 0x75, 0x77, 0xD1, 0xD3, 0xCB, 0x4A);};
template<> struct uuid<Windows::UI::Xaml::IApplicationFactory> { define_guid(0x93BBE361, 0xBE5A, 0x4EE3, 0xB4, 0xA3, 0x95, 0x11, 0x8D, 0xC9, 0x7A, 0x89);};
template<> struct uuid<Windows::UI::Xaml::IApplication3> { define_guid(0xB775AD7C, 0x18B8, 0x45CA, 0xA1, 0xB0, 0xDC, 0x48, 0x3E, 0x4B, 0x10, 0x28);};
template<> struct uuid<Windows::UI::Xaml::IApplicationOverrides2> { define_guid(0xDB5CD2B9, 0xD3B4, 0x558C, 0xC6, 0x4E, 0x4, 0x34, 0xFD, 0x1B, 0xD8, 0x89);};
template<> struct uuid<Windows::UI::Xaml::IApplication2> { define_guid(0x19104BE, 0x522A, 0x5904, 0xF5, 0x2F, 0xDE, 0x72, 0x1, 0x4, 0x29, 0xE0);};
template<> struct uuid<Windows::UI::Xaml::IFrameworkViewSource> { define_guid(0xE3B077DA, 0x35AD, 0x4B09, 0xB5, 0xB2, 0x27, 0x42, 0x0, 0x41, 0xBA, 0x9F);};
template<> struct uuid<Windows::UI::Xaml::IPointHelper> { define_guid(0x727BDD92, 0x64B0, 0x49CF, 0xA3, 0x21, 0xA9, 0x79, 0x3E, 0x73, 0xE2, 0xE7);};
template<> struct uuid<Windows::UI::Xaml::IPointHelperStatics> { define_guid(0x15ACA75, 0x76D8, 0x4B7E, 0x8A, 0x33, 0x7D, 0x79, 0x20, 0x46, 0x91, 0xEE);};
template<> struct uuid<Windows::UI::Xaml::IRectHelper> { define_guid(0xA38781E2, 0x4BFB, 0x4EE2, 0xAF, 0xE5, 0x89, 0xF3, 0x1B, 0x37, 0x47, 0x8D);};
template<> struct uuid<Windows::UI::Xaml::IRectHelperStatics> { define_guid(0x5EE163E4, 0xC17E, 0x494F, 0xB5, 0x80, 0x2F, 0x5, 0x74, 0xFC, 0x3A, 0x15);};
template<> struct uuid<Windows::UI::Xaml::ISizeHelper> { define_guid(0xE7225A94, 0x5D03, 0x4A03, 0xBA, 0x94, 0x96, 0x7F, 0xC6, 0x8F, 0xCE, 0xFE);};
template<> struct uuid<Windows::UI::Xaml::ISizeHelperStatics> { define_guid(0x6286C5B2, 0xCF78, 0x4915, 0xAA, 0x40, 0x76, 0x0, 0x4A, 0x16, 0x5F, 0x5E);};
template<> struct uuid<Windows::UI::Xaml::IWindow> { define_guid(0x3276167D, 0xC9F6, 0x462D, 0x9D, 0xE2, 0xAE, 0x4C, 0x1F, 0xD8, 0xC2, 0xE5);};
template<> struct uuid<Windows::UI::Xaml::IWindowStatics> { define_guid(0x93328409, 0x4EA1, 0x4AFA, 0x83, 0xDC, 0xC, 0x4E, 0x73, 0xE8, 0x8B, 0xB1);};
template<> struct uuid<Windows::UI::Xaml::IWindow3> { define_guid(0xB70BDC9D, 0x1C35, 0x462A, 0x9B, 0x97, 0x80, 0x8D, 0x5A, 0xF9, 0xF2, 0x8E);};
template<> struct uuid<Windows::UI::Xaml::IWindow2> { define_guid(0xD384759F, 0x34F6, 0x4482, 0x84, 0x35, 0xF5, 0x52, 0xF9, 0xB2, 0x4C, 0xC8);};
template<> struct uuid<Windows::UI::Xaml::IVisualStateManager> { define_guid(0x6FDA9F9A, 0x6FAB, 0x4112, 0x92, 0x58, 0x10, 0x6, 0xA3, 0xC3, 0x47, 0x6E);};
template<> struct uuid<Windows::UI::Xaml::IVisualStateManagerOverrides> { define_guid(0x4A66910E, 0x7979, 0x43C8, 0x8F, 0xF4, 0xEC, 0x61, 0x22, 0x75, 0x0, 0x6);};
template<> struct uuid<Windows::UI::Xaml::IVisualStateManagerProtected> { define_guid(0x4B3B8640, 0xB0B7, 0x404C, 0x9E, 0xF4, 0xD9, 0x49, 0x64, 0xE, 0x24, 0x5D);};
template<> struct uuid<Windows::UI::Xaml::IVisualStateManagerStatics> { define_guid(0x1D0E9E0, 0xD713, 0x414E, 0xA7, 0x4E, 0xE6, 0x3E, 0xC7, 0xAC, 0x8C, 0x3D);};
template<> struct uuid<Windows::UI::Xaml::IVisualStateManagerFactory> { define_guid(0x85E598FD, 0xA575, 0x47B6, 0x9E, 0x30, 0x38, 0x3C, 0xD0, 0x85, 0x85, 0xF2);};

// types

namespace Windows { namespace UI { namespace Xaml {

// IDataTemplateExtension
struct IDataTemplateExtension_raw : IInspectable {
	virtual STDMETHODIMP _ResetTemplate() = 0;
	virtual STDMETHODIMP _ProcessBinding(unsigned phase, bool *returnValue) = 0;
	virtual STDMETHODIMP _ProcessBindings(Controls::ContainerContentChangingEventArgs* arg, int *returnValue) = 0;
};
template<typename X> struct IDataTemplateExtension_adaptor : X {
	void ResetTemplate() { hrcheck(X::get()->_ResetTemplate()); }
	bool ProcessBinding(unsigned phase) { bool returnValue; hrcheck(X::get()->_ProcessBinding(phase, &returnValue)); return returnValue; }
	int ProcessBindings(pptr<Controls::ContainerContentChangingEventArgs> arg) { int returnValue; hrcheck(X::get()->_ProcessBindings(arg, &returnValue)); return returnValue; }
};
template<typename X> struct adapt<IDataTemplateExtension, X> : Windows::UI::Xaml::IDataTemplateExtension_adaptor<X> { typedef adapt IDataTemplateExtension; };
template<typename X> struct IDataTemplateExtension_unadaptor : X {
	STDMETHODIMP _ResetTemplate() { return hrtry([&, this] { X::get()->ResetTemplate(); }); }
	STDMETHODIMP _ProcessBinding(unsigned phase, bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->ProcessBinding(phase); }); }
	STDMETHODIMP _ProcessBindings(Controls::ContainerContentChangingEventArgs* arg, int *returnValue) { return hrtry([&, this] { *returnValue = X::get()->ProcessBindings(arg); }); }
};
template<typename X> struct unadapt<IDataTemplateExtension, X> : Windows::UI::Xaml::IDataTemplateExtension_unadaptor<X> {};
struct IDataTemplateExtension : IDataTemplateExtension_raw, generate<IDataTemplateExtension> {};

// IDataTemplate
struct IDataTemplate_raw : IInspectable {
	virtual STDMETHODIMP _LoadContent(DependencyObject* *returnValue);
};
template<typename X> struct IDataTemplate_adaptor : X {
	ptr<DependencyObject> LoadContent() { DependencyObject* returnValue; hrcheck(X::get()->_LoadContent(&returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IDataTemplate, X> : Windows::UI::Xaml::IDataTemplate_adaptor<X> { typedef adapt IDataTemplate; };
struct IDataTemplate : IDataTemplate_raw, generate<IDataTemplate> {};

// IDataTemplateFactory
struct IDataTemplateFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, DataTemplate* *instance);
};

// IDataTemplateStatics2
struct IDataTemplateStatics2 : IInspectable {
	virtual STDMETHODIMP _get_ExtensionInstanceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetExtensionInstance(FrameworkElement* element, IDataTemplateExtension* *value);
	virtual STDMETHODIMP _SetExtensionInstance(FrameworkElement* element, IDataTemplateExtension* value);
};

// IDispatcherTimer
struct IDispatcherTimer_raw : IInspectable {
	virtual STDMETHODIMP _get_Interval(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_Interval(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_IsEnabled(bool *value);
	virtual STDMETHODIMP _add_Tick(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Tick(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _Start();
	virtual STDMETHODIMP _Stop();
};
template<typename X> struct IDispatcherTimer_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IDispatcherTimer_adaptor::Interval)->_get_Interval(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IDispatcherTimer_adaptor::Interval)->_put_Interval(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Interval;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDispatcherTimer_adaptor::IsEnabled)->_get_IsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsEnabled;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDispatcherTimer_adaptor::Tick)->_add_Tick(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDispatcherTimer_adaptor::Tick)->_remove_Tick(token)); }
		} Tick;
	};
	void Start() { hrcheck(X::get()->_Start()); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	IDispatcherTimer_adaptor() {}
};
template<typename X> struct adapt<IDispatcherTimer, X> : Windows::UI::Xaml::IDispatcherTimer_adaptor<X> { typedef adapt IDispatcherTimer; };
struct IDispatcherTimer : IDispatcherTimer_raw, generate<IDispatcherTimer> {};

// IDispatcherTimerFactory
struct IDispatcherTimerFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, DispatcherTimer* *instance);
};

// DispatcherTimer
template<typename> struct DispatcherTimer_statics {
	static DispatcherTimer *activate(object_ref outer, IInspectable* *inner) { DispatcherTimer *instance; hrcheck(get_activation_factory<DispatcherTimer, IDispatcherTimerFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<DispatcherTimer, X> : X, Windows::UI::Xaml::DispatcherTimer_statics<void> {
	using Windows::UI::Xaml::DispatcherTimer_statics<void>::activate;
	typedef typename X::root_type DispatcherTimer;
};
struct DispatcherTimer : generate<DispatcherTimer> {};

// ICornerRadiusHelper
struct ICornerRadiusHelper : IInspectable, generate<ICornerRadiusHelper> {};

// ICornerRadiusHelperStatics
struct ICornerRadiusHelperStatics : IInspectable {
	virtual STDMETHODIMP _FromRadii(double topLeft, double topRight, double bottomRight, double bottomLeft, CornerRadius *returnValue);
	virtual STDMETHODIMP _FromUniformRadius(double uniformRadius, CornerRadius *returnValue);
};

// CornerRadiusHelper
template<typename> struct CornerRadiusHelper_statics {
	static CornerRadius FromRadii(double topLeft, double topRight, double bottomRight, double bottomLeft) { CornerRadius returnValue; hrcheck(get_activation_factory<CornerRadiusHelper, ICornerRadiusHelperStatics>()->_FromRadii(topLeft, topRight, bottomRight, bottomLeft, &returnValue)); return returnValue; }
	static CornerRadius FromUniformRadius(double uniformRadius) { CornerRadius returnValue; hrcheck(get_activation_factory<CornerRadiusHelper, ICornerRadiusHelperStatics>()->_FromUniformRadius(uniformRadius, &returnValue)); return returnValue; }
};

template<typename X> struct statics<CornerRadiusHelper, X> : X, Windows::UI::Xaml::CornerRadiusHelper_statics<void> {
	typedef typename X::root_type CornerRadiusHelper;
};
struct CornerRadiusHelper : generate<CornerRadiusHelper> {};

// IDurationHelper
struct IDurationHelper : IInspectable, generate<IDurationHelper> {};

// IDurationHelperStatics
struct IDurationHelperStatics : IInspectable {
	virtual STDMETHODIMP _get_Automatic(Duration *value);
	virtual STDMETHODIMP _get_Forever(Duration *value);
	virtual STDMETHODIMP _Compare(Duration duration1, Duration duration2, int *returnValue);
	virtual STDMETHODIMP _FromTimeSpan(Foundation::TimeSpan timeSpan, Duration *returnValue);
	virtual STDMETHODIMP _GetHasTimeSpan(Duration target, bool *value);
	virtual STDMETHODIMP _Add(Duration target, Duration duration, Duration *returnValue);
	virtual STDMETHODIMP _Equals(Duration target, Duration value, bool *returnValue);
	virtual STDMETHODIMP _Subtract(Duration target, Duration duration, Duration *returnValue);
};

// DurationHelper
template<typename> struct DurationHelper_statics {
	static struct _Automatic : property {
		Duration get() { Duration value; hrcheck(get_activation_factory<DurationHelper, IDurationHelperStatics>()->_get_Automatic(&value)); return value; }
		Duration operator()() { return get(); }
		operator Duration () { return get(); }
	} Automatic;
	static struct _Forever : property {
		Duration get() { Duration value; hrcheck(get_activation_factory<DurationHelper, IDurationHelperStatics>()->_get_Forever(&value)); return value; }
		Duration operator()() { return get(); }
		operator Duration () { return get(); }
	} Forever;
	static int Compare(const Duration& duration1, const Duration& duration2) { int returnValue; hrcheck(get_activation_factory<DurationHelper, IDurationHelperStatics>()->_Compare(duration1, duration2, &returnValue)); return returnValue; }
	static Duration FromTimeSpan(const Foundation::TimeSpan& timeSpan) { Duration returnValue; hrcheck(get_activation_factory<DurationHelper, IDurationHelperStatics>()->_FromTimeSpan(timeSpan, &returnValue)); return returnValue; }
	static bool GetHasTimeSpan(const Duration& target) { bool value; hrcheck(get_activation_factory<DurationHelper, IDurationHelperStatics>()->_GetHasTimeSpan(target, &value)); return value; }
	static Duration Add(const Duration& target, const Duration& duration) { Duration returnValue; hrcheck(get_activation_factory<DurationHelper, IDurationHelperStatics>()->_Add(target, duration, &returnValue)); return returnValue; }
	static bool Equals(const Duration& target, const Duration& value) { bool returnValue; hrcheck(get_activation_factory<DurationHelper, IDurationHelperStatics>()->_Equals(target, value, &returnValue)); return returnValue; }
	static Duration Subtract(const Duration& target, const Duration& duration) { Duration returnValue; hrcheck(get_activation_factory<DurationHelper, IDurationHelperStatics>()->_Subtract(target, duration, &returnValue)); return returnValue; }
};
template<typename X> typename DurationHelper_statics<X>::_Automatic DurationHelper_statics<X>::Automatic;
template<typename X> typename DurationHelper_statics<X>::_Forever DurationHelper_statics<X>::Forever;

template<typename X> struct statics<DurationHelper, X> : X, Windows::UI::Xaml::DurationHelper_statics<void> {
	typedef typename X::root_type DurationHelper;
};
struct DurationHelper : generate<DurationHelper> {};

// IThicknessHelper
struct IThicknessHelper : IInspectable, generate<IThicknessHelper> {};

// IThicknessHelperStatics
struct IThicknessHelperStatics : IInspectable {
	virtual STDMETHODIMP _FromLengths(double left, double top, double right, double bottom, Thickness *returnValue);
	virtual STDMETHODIMP _FromUniformLength(double uniformLength, Thickness *returnValue);
};

// ThicknessHelper
template<typename> struct ThicknessHelper_statics {
	static Thickness FromLengths(double left, double top, double right, double bottom) { Thickness returnValue; hrcheck(get_activation_factory<ThicknessHelper, IThicknessHelperStatics>()->_FromLengths(left, top, right, bottom, &returnValue)); return returnValue; }
	static Thickness FromUniformLength(double uniformLength) { Thickness returnValue; hrcheck(get_activation_factory<ThicknessHelper, IThicknessHelperStatics>()->_FromUniformLength(uniformLength, &returnValue)); return returnValue; }
};

template<typename X> struct statics<ThicknessHelper, X> : X, Windows::UI::Xaml::ThicknessHelper_statics<void> {
	typedef typename X::root_type ThicknessHelper;
};
struct ThicknessHelper : generate<ThicknessHelper> {};

// TemplatePartAttribute
template<typename X> struct statics<TemplatePartAttribute, X> : X {
	typedef typename X::root_type TemplatePartAttribute;
};
struct TemplatePartAttribute : generate<TemplatePartAttribute> {};

// ApplicationInitializationCallback
struct ApplicationInitializationCallback : IUnknown {
	virtual STDMETHODIMP _Invoke(ApplicationInitializationCallbackParams* p) = 0;
};

// IApplicationInitializationCallbackParams
struct IApplicationInitializationCallbackParams : IInspectable, generate<IApplicationInitializationCallbackParams> {};

// ApplicationInitializationCallbackParams
template<typename X> struct statics<ApplicationInitializationCallbackParams, X> : X {
	typedef typename X::root_type ApplicationInitializationCallbackParams;
};
struct ApplicationInitializationCallbackParams : generate<ApplicationInitializationCallbackParams> {};

// CreateDefaultValueCallback
struct CreateDefaultValueCallback : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* *value) = 0;
};

// DependencyPropertyChangedCallback
struct DependencyPropertyChangedCallback : IUnknown {
	virtual STDMETHODIMP _Invoke(DependencyObject* sender, DependencyProperty* dp) = 0;
};

// IDependencyObjectFactory
struct IDependencyObjectFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, DependencyObject* *instance);
};

// IDependencyObject2
struct IDependencyObject2_raw : IInspectable {
	virtual STDMETHODIMP _RegisterPropertyChangedCallback(DependencyProperty* dp, DependencyPropertyChangedCallback* callback, __int64 *returnValue);
	virtual STDMETHODIMP _UnregisterPropertyChangedCallback(DependencyProperty* dp, __int64 token);
};
template<typename X> struct IDependencyObject2_adaptor : X {
	__int64 RegisterPropertyChangedCallback(pptr<DependencyProperty> dp, handler_ref<DependencyPropertyChangedCallback> callback) { __int64 returnValue; hrcheck(X::get()->_RegisterPropertyChangedCallback(dp, callback, &returnValue)); return returnValue; }
	void UnregisterPropertyChangedCallback(pptr<DependencyProperty> dp, __int64 token) { hrcheck(X::get()->_UnregisterPropertyChangedCallback(dp, token)); }
};
template<typename X> struct adapt<IDependencyObject2, X> : Windows::UI::Xaml::IDependencyObject2_adaptor<X> { typedef adapt IDependencyObject2; };
struct IDependencyObject2 : IDependencyObject2_raw, generate<IDependencyObject2> {};

// IDependencyObject
struct IDependencyObject_raw : IInspectable {
	virtual STDMETHODIMP _GetValue(DependencyProperty* dp, IInspectable* *returnValue);
	virtual STDMETHODIMP _SetValue(DependencyProperty* dp, IInspectable* value);
	virtual STDMETHODIMP _ClearValue(DependencyProperty* dp);
	virtual STDMETHODIMP _ReadLocalValue(DependencyProperty* dp, IInspectable* *returnValue);
	virtual STDMETHODIMP _GetAnimationBaseValue(DependencyProperty* dp, IInspectable* *returnValue);
	virtual STDMETHODIMP _get_Dispatcher(Core::CoreDispatcher* *value);
};
template<typename X> struct IDependencyObject_adaptor : X {
	union {
		struct : property {
			ptr<Core::CoreDispatcher> get() { Core::CoreDispatcher* value; hrcheck(enc(&IDependencyObject_adaptor::Dispatcher)->_get_Dispatcher(&value)); return from_abi(value); }
			ptr<Core::CoreDispatcher> operator()() { return get(); }
			operator ptr<Core::CoreDispatcher> () { return get(); }
			ptr<Core::CoreDispatcher> operator->() { return get(); }
		} Dispatcher;
	};
	object GetValue(pptr<DependencyProperty> dp) { IInspectable* returnValue; hrcheck(X::get()->_GetValue(dp, &returnValue)); return from_abi(returnValue); }
	void SetValue(pptr<DependencyProperty> dp, object_ref value) { hrcheck(X::get()->_SetValue(dp, value)); }
	void ClearValue(pptr<DependencyProperty> dp) { hrcheck(X::get()->_ClearValue(dp)); }
	object ReadLocalValue(pptr<DependencyProperty> dp) { IInspectable* returnValue; hrcheck(X::get()->_ReadLocalValue(dp, &returnValue)); return from_abi(returnValue); }
	object GetAnimationBaseValue(pptr<DependencyProperty> dp) { IInspectable* returnValue; hrcheck(X::get()->_GetAnimationBaseValue(dp, &returnValue)); return from_abi(returnValue); }
	IDependencyObject_adaptor() {}
};
template<typename X> struct adapt<IDependencyObject, X> : Windows::UI::Xaml::IDependencyObject_adaptor<X> { typedef adapt IDependencyObject; };
struct IDependencyObject : IDependencyObject_raw, generate<IDependencyObject> {};

// DependencyObject
template<typename X> struct statics<DependencyObject, X> : X {
	typedef typename X::root_type DependencyObject;
};
struct DependencyObject : generate<DependencyObject> {};

// IDependencyPropertyStatics
struct IDependencyPropertyStatics : IInspectable {
	virtual STDMETHODIMP _get_UnsetValue(IInspectable* *value);
	virtual STDMETHODIMP _Register(HSTRING name, Interop::TypeName propertyType, Interop::TypeName ownerType, PropertyMetadata* typeMetadata, DependencyProperty* *returnValue);
	virtual STDMETHODIMP _RegisterAttached(HSTRING name, Interop::TypeName propertyType, Interop::TypeName ownerType, PropertyMetadata* defaultMetadata, DependencyProperty* *returnValue);
};

// IDependencyProperty
struct IDependencyProperty_raw : IInspectable {
	virtual STDMETHODIMP _GetMetadata(Interop::TypeName forType, PropertyMetadata* *returnValue);
};
template<typename X> struct IDependencyProperty_adaptor : X {
	ptr<PropertyMetadata> GetMetadata(const Interop::TypeName& forType) { PropertyMetadata* returnValue; hrcheck(X::get()->_GetMetadata(forType, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IDependencyProperty, X> : Windows::UI::Xaml::IDependencyProperty_adaptor<X> { typedef adapt IDependencyProperty; };
struct IDependencyProperty : IDependencyProperty_raw, generate<IDependencyProperty> {};

// DependencyProperty
template<typename> struct DependencyProperty_statics {
	static struct _UnsetValue : property {
		object get() { IInspectable* value; hrcheck(get_activation_factory<DependencyProperty, IDependencyPropertyStatics>()->_get_UnsetValue(&value)); return from_abi(value); }
		object operator()() { return get(); }
		operator object () { return get(); }
	} UnsetValue;
	static ptr<DependencyProperty> Register(hstring_ref name, const Interop::TypeName& propertyType, const Interop::TypeName& ownerType, pptr<PropertyMetadata> typeMetadata) { DependencyProperty* returnValue; hrcheck(get_activation_factory<DependencyProperty, IDependencyPropertyStatics>()->_Register(name, propertyType, ownerType, typeMetadata, &returnValue)); return from_abi(returnValue); }
	static ptr<DependencyProperty> RegisterAttached(hstring_ref name, const Interop::TypeName& propertyType, const Interop::TypeName& ownerType, pptr<PropertyMetadata> defaultMetadata) { DependencyProperty* returnValue; hrcheck(get_activation_factory<DependencyProperty, IDependencyPropertyStatics>()->_RegisterAttached(name, propertyType, ownerType, defaultMetadata, &returnValue)); return from_abi(returnValue); }
};
template<typename X> typename DependencyProperty_statics<X>::_UnsetValue DependencyProperty_statics<X>::UnsetValue;

template<typename X> struct statics<DependencyProperty, X> : X, Windows::UI::Xaml::DependencyProperty_statics<void> {
	typedef typename X::root_type DependencyProperty;
};
struct DependencyProperty : generate<DependencyProperty> {};

// DependencyPropertyChangedEventHandler
struct DependencyPropertyChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, DependencyPropertyChangedEventArgs* e) = 0;
};

// IDependencyPropertyChangedEventArgs
struct IDependencyPropertyChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Property(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OldValue(IInspectable* *value);
	virtual STDMETHODIMP _get_NewValue(IInspectable* *value);
};
template<typename X> struct IDependencyPropertyChangedEventArgs_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IDependencyPropertyChangedEventArgs_adaptor::NewValue)->_get_NewValue(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} NewValue;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IDependencyPropertyChangedEventArgs_adaptor::OldValue)->_get_OldValue(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} OldValue;
		struct : property {
			ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(enc(&IDependencyPropertyChangedEventArgs_adaptor::Property)->_get_Property(&value)); return from_abi(value); }
			ptr<DependencyProperty> operator()() { return get(); }
			operator ptr<DependencyProperty> () { return get(); }
			ptr<DependencyProperty> operator->() { return get(); }
		} Property;
	};
	IDependencyPropertyChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDependencyPropertyChangedEventArgs, X> : Windows::UI::Xaml::IDependencyPropertyChangedEventArgs_adaptor<X> { typedef adapt IDependencyPropertyChangedEventArgs; };
struct IDependencyPropertyChangedEventArgs : IDependencyPropertyChangedEventArgs_raw, generate<IDependencyPropertyChangedEventArgs> {};

// DependencyPropertyChangedEventArgs
template<typename X> struct statics<DependencyPropertyChangedEventArgs, X> : X {
	typedef typename X::root_type DependencyPropertyChangedEventArgs;
};
struct DependencyPropertyChangedEventArgs : generate<DependencyPropertyChangedEventArgs> {};

// DragEventHandler
struct DragEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, DragEventArgs* e) = 0;
};

// EnteredBackgroundEventHandler
struct EnteredBackgroundEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, ApplicationModel::EnteredBackgroundEventArgs* e) = 0;
};

// ExceptionRoutedEventHandler
struct ExceptionRoutedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, ExceptionRoutedEventArgs* e) = 0;
};

// LeavingBackgroundEventHandler
struct LeavingBackgroundEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, ApplicationModel::LeavingBackgroundEventArgs* e) = 0;
};

// PropertyChangedCallback
struct PropertyChangedCallback : IUnknown {
	virtual STDMETHODIMP _Invoke(DependencyObject* d, DependencyPropertyChangedEventArgs* e) = 0;
};

// RoutedEventHandler
struct RoutedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, RoutedEventArgs* e) = 0;
};

// IRoutedEventArgsFactory
struct IRoutedEventArgsFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, RoutedEventArgs* *instance);
};

// IRoutedEventArgs
struct IRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_OriginalSource(IInspectable* *value);
};
template<typename X> struct IRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IRoutedEventArgs_adaptor::OriginalSource)->_get_OriginalSource(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} OriginalSource;
	};
	IRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IRoutedEventArgs, X> : Windows::UI::Xaml::IRoutedEventArgs_adaptor<X> { typedef adapt IRoutedEventArgs; };
struct IRoutedEventArgs : IRoutedEventArgs_raw, generate<IRoutedEventArgs> {};

// RoutedEventArgs
template<typename> struct RoutedEventArgs_statics {
	static RoutedEventArgs *activate(object_ref outer, IInspectable* *inner) { RoutedEventArgs *instance; hrcheck(get_activation_factory<RoutedEventArgs, IRoutedEventArgsFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<RoutedEventArgs, X> : X, Windows::UI::Xaml::RoutedEventArgs_statics<void> {
	using Windows::UI::Xaml::RoutedEventArgs_statics<void>::activate;
	typedef typename X::root_type RoutedEventArgs;
};
struct RoutedEventArgs : generate<RoutedEventArgs> {};

// SizeChangedEventHandler
struct SizeChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, SizeChangedEventArgs* e) = 0;
};

// SuspendingEventHandler
struct SuspendingEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, ApplicationModel::SuspendingEventArgs* e) = 0;
};

// UnhandledExceptionEventHandler
struct UnhandledExceptionEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, UnhandledExceptionEventArgs* e) = 0;
};

// IUnhandledExceptionEventArgs
struct IUnhandledExceptionEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Exception(Foundation::HResult *value);
	virtual STDMETHODIMP _get_Message(HSTRING *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
};
template<typename X> struct IUnhandledExceptionEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IUnhandledExceptionEventArgs_adaptor::Exception)->_get_Exception(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} Exception;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUnhandledExceptionEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IUnhandledExceptionEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUnhandledExceptionEventArgs_adaptor::Message)->_get_Message(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Message;
	};
	IUnhandledExceptionEventArgs_adaptor() {}
};
template<typename X> struct adapt<IUnhandledExceptionEventArgs, X> : Windows::UI::Xaml::IUnhandledExceptionEventArgs_adaptor<X> { typedef adapt IUnhandledExceptionEventArgs; };
struct IUnhandledExceptionEventArgs : IUnhandledExceptionEventArgs_raw, generate<IUnhandledExceptionEventArgs> {};

// UnhandledExceptionEventArgs
template<typename X> struct statics<UnhandledExceptionEventArgs, X> : X {
	typedef typename X::root_type UnhandledExceptionEventArgs;
};
struct UnhandledExceptionEventArgs : generate<UnhandledExceptionEventArgs> {};

// VisualStateChangedEventHandler
struct VisualStateChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, VisualStateChangedEventArgs* e) = 0;
};

// IVisualStateChangedEventArgs
struct IVisualStateChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_OldState(VisualState* *value);
	virtual STDMETHODIMP _put_OldState(VisualState* value);
	virtual STDMETHODIMP _get_NewState(VisualState* *value);
	virtual STDMETHODIMP _put_NewState(VisualState* value);
	virtual STDMETHODIMP _get_Control(Controls::Control* *value);
	virtual STDMETHODIMP _put_Control(Controls::Control* value);
};
template<typename X> struct IVisualStateChangedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Controls::Control> get() { Controls::Control* value; hrcheck(enc(&IVisualStateChangedEventArgs_adaptor::Control)->_get_Control(&value)); return from_abi(value); }
			ptr<Controls::Control> operator()() { return get(); }
			operator ptr<Controls::Control> () { return get(); }
			ptr<Controls::Control> operator->() { return get(); }
			void put(pptr<Controls::Control> value) { hrcheck(enc(&IVisualStateChangedEventArgs_adaptor::Control)->_put_Control(value)); }
			void operator=(pptr<Controls::Control> value) { put(value); }
			void operator()(pptr<Controls::Control> value) { put(value); }
		} Control;
		struct : property {
			ptr<VisualState> get() { VisualState* value; hrcheck(enc(&IVisualStateChangedEventArgs_adaptor::NewState)->_get_NewState(&value)); return from_abi(value); }
			ptr<VisualState> operator()() { return get(); }
			operator ptr<VisualState> () { return get(); }
			ptr<VisualState> operator->() { return get(); }
			void put(pptr<VisualState> value) { hrcheck(enc(&IVisualStateChangedEventArgs_adaptor::NewState)->_put_NewState(value)); }
			void operator=(pptr<VisualState> value) { put(value); }
			void operator()(pptr<VisualState> value) { put(value); }
		} NewState;
		struct : property {
			ptr<VisualState> get() { VisualState* value; hrcheck(enc(&IVisualStateChangedEventArgs_adaptor::OldState)->_get_OldState(&value)); return from_abi(value); }
			ptr<VisualState> operator()() { return get(); }
			operator ptr<VisualState> () { return get(); }
			ptr<VisualState> operator->() { return get(); }
			void put(pptr<VisualState> value) { hrcheck(enc(&IVisualStateChangedEventArgs_adaptor::OldState)->_put_OldState(value)); }
			void operator=(pptr<VisualState> value) { put(value); }
			void operator()(pptr<VisualState> value) { put(value); }
		} OldState;
	};
	IVisualStateChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IVisualStateChangedEventArgs, X> : Windows::UI::Xaml::IVisualStateChangedEventArgs_adaptor<X> { typedef adapt IVisualStateChangedEventArgs; };
struct IVisualStateChangedEventArgs : IVisualStateChangedEventArgs_raw, generate<IVisualStateChangedEventArgs> {};

// VisualStateChangedEventArgs
template<typename X> struct statics<VisualStateChangedEventArgs, X> : X {
	typedef typename X::root_type VisualStateChangedEventArgs;
};
struct VisualStateChangedEventArgs : generate<VisualStateChangedEventArgs> {};

// WindowActivatedEventHandler
struct WindowActivatedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, Core::WindowActivatedEventArgs* e) = 0;
};

// WindowClosedEventHandler
struct WindowClosedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, Core::CoreWindowEventArgs* e) = 0;
};

// WindowSizeChangedEventHandler
struct WindowSizeChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, Core::WindowSizeChangedEventArgs* e) = 0;
};

// WindowVisibilityChangedEventHandler
struct WindowVisibilityChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, Core::VisibilityChangedEventArgs* e) = 0;
};

// IBringIntoViewOptions
struct IBringIntoViewOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_AnimationDesired(bool *value);
	virtual STDMETHODIMP _put_AnimationDesired(bool value);
	virtual STDMETHODIMP _get_TargetRect(Foundation::IReference<Foundation::Rect>* *value);
	virtual STDMETHODIMP _put_TargetRect(Foundation::IReference<Foundation::Rect>* value);
};
template<typename X> struct IBringIntoViewOptions_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBringIntoViewOptions_adaptor::AnimationDesired)->_get_AnimationDesired(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IBringIntoViewOptions_adaptor::AnimationDesired)->_put_AnimationDesired(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AnimationDesired;
		struct : property {
			ptr<Foundation::IReference<Foundation::Rect>> get() { Foundation::IReference<Foundation::Rect>* value; hrcheck(enc(&IBringIntoViewOptions_adaptor::TargetRect)->_get_TargetRect(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::Rect>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::Rect>> () { return get(); }
			ptr<Foundation::IReference<Foundation::Rect>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::Rect>> value) { hrcheck(enc(&IBringIntoViewOptions_adaptor::TargetRect)->_put_TargetRect(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::Rect>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::Rect>> value) { put(to_abi(value)); }
		} TargetRect;
	};
	IBringIntoViewOptions_adaptor() {}
};
template<typename X> struct adapt<IBringIntoViewOptions, X> : Windows::UI::Xaml::IBringIntoViewOptions_adaptor<X> { typedef adapt IBringIntoViewOptions; };
struct IBringIntoViewOptions : IBringIntoViewOptions_raw, generate<IBringIntoViewOptions> {};

// IBringIntoViewOptions2
struct IBringIntoViewOptions2_raw : IInspectable {
	virtual STDMETHODIMP _get_HorizontalAlignmentRatio(double *value);
	virtual STDMETHODIMP _put_HorizontalAlignmentRatio(double value);
	virtual STDMETHODIMP _get_VerticalAlignmentRatio(double *value);
	virtual STDMETHODIMP _put_VerticalAlignmentRatio(double value);
	virtual STDMETHODIMP _get_HorizontalOffset(double *value);
	virtual STDMETHODIMP _put_HorizontalOffset(double value);
	virtual STDMETHODIMP _get_VerticalOffset(double *value);
	virtual STDMETHODIMP _put_VerticalOffset(double value);
};
template<typename X> struct IBringIntoViewOptions2_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IBringIntoViewOptions2_adaptor::HorizontalAlignmentRatio)->_get_HorizontalAlignmentRatio(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IBringIntoViewOptions2_adaptor::HorizontalAlignmentRatio)->_put_HorizontalAlignmentRatio(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} HorizontalAlignmentRatio;
		struct : property {
			double get() { double value; hrcheck(enc(&IBringIntoViewOptions2_adaptor::HorizontalOffset)->_get_HorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IBringIntoViewOptions2_adaptor::HorizontalOffset)->_put_HorizontalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} HorizontalOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IBringIntoViewOptions2_adaptor::VerticalAlignmentRatio)->_get_VerticalAlignmentRatio(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IBringIntoViewOptions2_adaptor::VerticalAlignmentRatio)->_put_VerticalAlignmentRatio(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} VerticalAlignmentRatio;
		struct : property {
			double get() { double value; hrcheck(enc(&IBringIntoViewOptions2_adaptor::VerticalOffset)->_get_VerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IBringIntoViewOptions2_adaptor::VerticalOffset)->_put_VerticalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} VerticalOffset;
	};
	IBringIntoViewOptions2_adaptor() {}
};
template<typename X> struct adapt<IBringIntoViewOptions2, X> : Windows::UI::Xaml::IBringIntoViewOptions2_adaptor<X> { typedef adapt IBringIntoViewOptions2; };
struct IBringIntoViewOptions2 : IBringIntoViewOptions2_raw, generate<IBringIntoViewOptions2> {};

// BringIntoViewOptions
template<typename X> struct statics<BringIntoViewOptions, X> : X {
	typedef typename X::root_type BringIntoViewOptions;
};
struct BringIntoViewOptions : generate<BringIntoViewOptions> {};

// IDataContextChangedEventArgs
struct IDataContextChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_NewValue(IInspectable* *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
};
template<typename X> struct IDataContextChangedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDataContextChangedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDataContextChangedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IDataContextChangedEventArgs_adaptor::NewValue)->_get_NewValue(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} NewValue;
	};
	IDataContextChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDataContextChangedEventArgs, X> : Windows::UI::Xaml::IDataContextChangedEventArgs_adaptor<X> { typedef adapt IDataContextChangedEventArgs; };
struct IDataContextChangedEventArgs : IDataContextChangedEventArgs_raw, generate<IDataContextChangedEventArgs> {};

// DataContextChangedEventArgs
template<typename X> struct statics<DataContextChangedEventArgs, X> : X {
	typedef typename X::root_type DataContextChangedEventArgs;
};
struct DataContextChangedEventArgs : generate<DataContextChangedEventArgs> {};

// IDataTemplateKey
struct IDataTemplateKey_raw : IInspectable {
	virtual STDMETHODIMP _get_DataType(IInspectable* *value);
	virtual STDMETHODIMP _put_DataType(IInspectable* value);
};
template<typename X> struct IDataTemplateKey_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IDataTemplateKey_adaptor::DataType)->_get_DataType(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IDataTemplateKey_adaptor::DataType)->_put_DataType(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} DataType;
	};
	IDataTemplateKey_adaptor() {}
};
template<typename X> struct adapt<IDataTemplateKey, X> : Windows::UI::Xaml::IDataTemplateKey_adaptor<X> { typedef adapt IDataTemplateKey; };
struct IDataTemplateKey : IDataTemplateKey_raw, generate<IDataTemplateKey> {};

// IDataTemplateKeyFactory
struct IDataTemplateKeyFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, DataTemplateKey* *instance);
	virtual STDMETHODIMP _CreateInstanceWithType(IInspectable* dataType, IInspectable* outer, IInspectable* *inner, DataTemplateKey* *instance);
};

// DataTemplateKey
template<typename> struct DataTemplateKey_statics {
	static DataTemplateKey *activate(object_ref outer, IInspectable* *inner) { DataTemplateKey *instance; hrcheck(get_activation_factory<DataTemplateKey, IDataTemplateKeyFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
	static DataTemplateKey *activate(object_ref dataType, object_ref outer, IInspectable* *inner) { DataTemplateKey *instance; hrcheck(get_activation_factory<DataTemplateKey, IDataTemplateKeyFactory>()->_CreateInstanceWithType(dataType, outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<DataTemplateKey, X> : X, Windows::UI::Xaml::DataTemplateKey_statics<void> {
	using Windows::UI::Xaml::DataTemplateKey_statics<void>::activate;
	typedef typename X::root_type DataTemplateKey;
};
struct DataTemplateKey : generate<DataTemplateKey> {};

// IPropertyMetadataFactory
struct IPropertyMetadataFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithDefaultValue(IInspectable* defaultValue, IInspectable* outer, IInspectable* *inner, PropertyMetadata* *instance);
	virtual STDMETHODIMP _CreateInstanceWithDefaultValueAndCallback(IInspectable* defaultValue, PropertyChangedCallback* propertyChangedCallback, IInspectable* outer, IInspectable* *inner, PropertyMetadata* *instance);
};

// IPropertyMetadataStatics
struct IPropertyMetadataStatics : IInspectable {
	virtual STDMETHODIMP _CreateWithDefaultValue(IInspectable* defaultValue, PropertyMetadata* *returnValue);
	virtual STDMETHODIMP _CreateWithDefaultValueAndCallback(IInspectable* defaultValue, PropertyChangedCallback* propertyChangedCallback, PropertyMetadata* *returnValue);
	virtual STDMETHODIMP _CreateWithFactory(CreateDefaultValueCallback* createDefaultValueCallback, PropertyMetadata* *returnValue);
	virtual STDMETHODIMP _CreateWithFactoryAndCallback(CreateDefaultValueCallback* createDefaultValueCallback, PropertyChangedCallback* propertyChangedCallback, PropertyMetadata* *returnValue);
};

// IPropertyMetadata
struct IPropertyMetadata_raw : IInspectable {
	virtual STDMETHODIMP _get_DefaultValue(IInspectable* *value);
	virtual STDMETHODIMP _get_CreateDefaultValueCallback(Xaml::CreateDefaultValueCallback* *value);
};
template<typename X> struct IPropertyMetadata_adaptor : X {
	union {
		struct : property {
			ptr<Xaml::CreateDefaultValueCallback> get() { Xaml::CreateDefaultValueCallback* value; hrcheck(enc(&IPropertyMetadata_adaptor::CreateDefaultValueCallback)->_get_CreateDefaultValueCallback(&value)); return value; }
			ptr<Xaml::CreateDefaultValueCallback> operator()() { return get(); }
			operator ptr<Xaml::CreateDefaultValueCallback> () { return get(); }
		} CreateDefaultValueCallback;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IPropertyMetadata_adaptor::DefaultValue)->_get_DefaultValue(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} DefaultValue;
	};
	IPropertyMetadata_adaptor() {}
};
template<typename X> struct adapt<IPropertyMetadata, X> : Windows::UI::Xaml::IPropertyMetadata_adaptor<X> { typedef adapt IPropertyMetadata; };
struct IPropertyMetadata : IPropertyMetadata_raw, generate<IPropertyMetadata> {};

// PropertyMetadata
template<typename> struct PropertyMetadata_statics {
	static ptr<PropertyMetadata> Create(object_ref defaultValue) { PropertyMetadata* returnValue; hrcheck(get_activation_factory<PropertyMetadata, IPropertyMetadataStatics>()->_CreateWithDefaultValue(defaultValue, &returnValue)); return from_abi(returnValue); }
	static ptr<PropertyMetadata> Create(object_ref defaultValue, handler_ref<PropertyChangedCallback> propertyChangedCallback) { PropertyMetadata* returnValue; hrcheck(get_activation_factory<PropertyMetadata, IPropertyMetadataStatics>()->_CreateWithDefaultValueAndCallback(defaultValue, propertyChangedCallback, &returnValue)); return from_abi(returnValue); }
	static ptr<PropertyMetadata> Create(handler_ref<Xaml::CreateDefaultValueCallback> createDefaultValueCallback) { PropertyMetadata* returnValue; hrcheck(get_activation_factory<PropertyMetadata, IPropertyMetadataStatics>()->_CreateWithFactory(createDefaultValueCallback, &returnValue)); return from_abi(returnValue); }
	static ptr<PropertyMetadata> Create(handler_ref<Xaml::CreateDefaultValueCallback> createDefaultValueCallback, handler_ref<PropertyChangedCallback> propertyChangedCallback) { PropertyMetadata* returnValue; hrcheck(get_activation_factory<PropertyMetadata, IPropertyMetadataStatics>()->_CreateWithFactoryAndCallback(createDefaultValueCallback, propertyChangedCallback, &returnValue)); return from_abi(returnValue); }
	static PropertyMetadata *activate(object_ref defaultValue, object_ref outer, IInspectable* *inner) { PropertyMetadata *instance; hrcheck(get_activation_factory<PropertyMetadata, IPropertyMetadataFactory>()->_CreateInstanceWithDefaultValue(defaultValue, outer, inner, &instance)); return instance; }
	static PropertyMetadata *activate(object_ref defaultValue, handler_ref<PropertyChangedCallback> propertyChangedCallback, object_ref outer, IInspectable* *inner) { PropertyMetadata *instance; hrcheck(get_activation_factory<PropertyMetadata, IPropertyMetadataFactory>()->_CreateInstanceWithDefaultValueAndCallback(defaultValue, propertyChangedCallback, outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<PropertyMetadata, X> : X, Windows::UI::Xaml::PropertyMetadata_statics<void> {
	using Windows::UI::Xaml::PropertyMetadata_statics<void>::activate;
	typedef typename X::root_type PropertyMetadata;
};
struct PropertyMetadata : generate<PropertyMetadata> {};

// IDragOperationDeferral
struct IDragOperationDeferral_raw : IInspectable {
	virtual STDMETHODIMP _Complete();
};
template<typename X> struct IDragOperationDeferral_adaptor : X {
	void Complete() { hrcheck(X::get()->_Complete()); }
};
template<typename X> struct adapt<IDragOperationDeferral, X> : Windows::UI::Xaml::IDragOperationDeferral_adaptor<X> { typedef adapt IDragOperationDeferral; };
struct IDragOperationDeferral : IDragOperationDeferral_raw, generate<IDragOperationDeferral> {};

// DragOperationDeferral
template<typename X> struct statics<DragOperationDeferral, X> : X {
	typedef typename X::root_type DragOperationDeferral;
};
struct DragOperationDeferral : generate<DragOperationDeferral> {};

// IDragUI
struct IDragUI_raw : IInspectable {
	virtual STDMETHODIMP _SetContentFromBitmapImage(Media::Imaging::BitmapImage* bitmapImage);
	virtual STDMETHODIMP _SetContentFromBitmapImageWithAnchorPoint(Media::Imaging::BitmapImage* bitmapImage, Foundation::Point anchorPoint);
	virtual STDMETHODIMP _SetContentFromSoftwareBitmap(Graphics::Imaging::SoftwareBitmap* softwareBitmap);
	virtual STDMETHODIMP _SetContentFromSoftwareBitmapWithAnchorPoint(Graphics::Imaging::SoftwareBitmap* softwareBitmap, Foundation::Point anchorPoint);
	virtual STDMETHODIMP _SetContentFromDataPackage();
};
template<typename X> struct IDragUI_adaptor : X {
	void SetContentFromBitmapImage(pptr<Media::Imaging::BitmapImage> bitmapImage) { hrcheck(X::get()->_SetContentFromBitmapImage(bitmapImage)); }
	void SetContentFromBitmapImage(pptr<Media::Imaging::BitmapImage> bitmapImage, const Foundation::Point& anchorPoint) { hrcheck(X::get()->_SetContentFromBitmapImageWithAnchorPoint(bitmapImage, anchorPoint)); }
	void SetContentFromSoftwareBitmap(pptr<Graphics::Imaging::SoftwareBitmap> softwareBitmap) { hrcheck(X::get()->_SetContentFromSoftwareBitmap(softwareBitmap)); }
	void SetContentFromSoftwareBitmap(pptr<Graphics::Imaging::SoftwareBitmap> softwareBitmap, const Foundation::Point& anchorPoint) { hrcheck(X::get()->_SetContentFromSoftwareBitmapWithAnchorPoint(softwareBitmap, anchorPoint)); }
	void SetContentFromDataPackage() { hrcheck(X::get()->_SetContentFromDataPackage()); }
};
template<typename X> struct adapt<IDragUI, X> : Windows::UI::Xaml::IDragUI_adaptor<X> { typedef adapt IDragUI; };
struct IDragUI : IDragUI_raw, generate<IDragUI> {};

// DragUI
template<typename X> struct statics<DragUI, X> : X {
	typedef typename X::root_type DragUI;
};
struct DragUI : generate<DragUI> {
	using IDragUI::SetContentFromSoftwareBitmap;
	using IDragUI::SetContentFromBitmapImage;
};

// IDragUIOverride
struct IDragUIOverride_raw : IInspectable {
	virtual STDMETHODIMP _get_Caption(HSTRING *value);
	virtual STDMETHODIMP _put_Caption(HSTRING value);
	virtual STDMETHODIMP _get_IsContentVisible(bool *value);
	virtual STDMETHODIMP _put_IsContentVisible(bool value);
	virtual STDMETHODIMP _get_IsCaptionVisible(bool *value);
	virtual STDMETHODIMP _put_IsCaptionVisible(bool value);
	virtual STDMETHODIMP _get_IsGlyphVisible(bool *value);
	virtual STDMETHODIMP _put_IsGlyphVisible(bool value);
	virtual STDMETHODIMP _Clear();
	virtual STDMETHODIMP _SetContentFromBitmapImage(Media::Imaging::BitmapImage* bitmapImage);
	virtual STDMETHODIMP _SetContentFromBitmapImageWithAnchorPoint(Media::Imaging::BitmapImage* bitmapImage, Foundation::Point anchorPoint);
	virtual STDMETHODIMP _SetContentFromSoftwareBitmap(Graphics::Imaging::SoftwareBitmap* softwareBitmap);
	virtual STDMETHODIMP _SetContentFromSoftwareBitmapWithAnchorPoint(Graphics::Imaging::SoftwareBitmap* softwareBitmap, Foundation::Point anchorPoint);
};
template<typename X> struct IDragUIOverride_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDragUIOverride_adaptor::Caption)->_get_Caption(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDragUIOverride_adaptor::Caption)->_put_Caption(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Caption;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDragUIOverride_adaptor::IsCaptionVisible)->_get_IsCaptionVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDragUIOverride_adaptor::IsCaptionVisible)->_put_IsCaptionVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsCaptionVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDragUIOverride_adaptor::IsContentVisible)->_get_IsContentVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDragUIOverride_adaptor::IsContentVisible)->_put_IsContentVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsContentVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDragUIOverride_adaptor::IsGlyphVisible)->_get_IsGlyphVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDragUIOverride_adaptor::IsGlyphVisible)->_put_IsGlyphVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsGlyphVisible;
	};
	void Clear() { hrcheck(X::get()->_Clear()); }
	void SetContentFromBitmapImage(pptr<Media::Imaging::BitmapImage> bitmapImage) { hrcheck(X::get()->_SetContentFromBitmapImage(bitmapImage)); }
	void SetContentFromBitmapImage(pptr<Media::Imaging::BitmapImage> bitmapImage, const Foundation::Point& anchorPoint) { hrcheck(X::get()->_SetContentFromBitmapImageWithAnchorPoint(bitmapImage, anchorPoint)); }
	void SetContentFromSoftwareBitmap(pptr<Graphics::Imaging::SoftwareBitmap> softwareBitmap) { hrcheck(X::get()->_SetContentFromSoftwareBitmap(softwareBitmap)); }
	void SetContentFromSoftwareBitmap(pptr<Graphics::Imaging::SoftwareBitmap> softwareBitmap, const Foundation::Point& anchorPoint) { hrcheck(X::get()->_SetContentFromSoftwareBitmapWithAnchorPoint(softwareBitmap, anchorPoint)); }
	IDragUIOverride_adaptor() {}
};
template<typename X> struct adapt<IDragUIOverride, X> : Windows::UI::Xaml::IDragUIOverride_adaptor<X> { typedef adapt IDragUIOverride; };
struct IDragUIOverride : IDragUIOverride_raw, generate<IDragUIOverride> {};

// DragUIOverride
template<typename X> struct statics<DragUIOverride, X> : X {
	typedef typename X::root_type DragUIOverride;
};
struct DragUIOverride : generate<DragUIOverride> {
	using IDragUIOverride::SetContentFromSoftwareBitmap;
	using IDragUIOverride::SetContentFromBitmapImage;
};

// IFrameworkView
struct IFrameworkView : IInspectable, generate<IFrameworkView> {};

// FrameworkView
template<typename X> struct statics<FrameworkView, X> : X {
	typedef typename X::root_type FrameworkView;
};
struct FrameworkView : generate<FrameworkView> {};

// IRoutedEvent
struct IRoutedEvent : IInspectable, generate<IRoutedEvent> {};

// RoutedEvent
template<typename X> struct statics<RoutedEvent, X> : X {
	typedef typename X::root_type RoutedEvent;
};
struct RoutedEvent : generate<RoutedEvent> {};

// ISetterBaseFactory
struct ISetterBaseFactory : IInspectable, generate<ISetterBaseFactory> {};

// ISetterBase
struct ISetterBase_raw : IInspectable {
	virtual STDMETHODIMP _get_IsSealed(bool *value);
};
template<typename X> struct ISetterBase_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISetterBase_adaptor::IsSealed)->_get_IsSealed(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsSealed;
	};
	ISetterBase_adaptor() {}
};
template<typename X> struct adapt<ISetterBase, X> : Windows::UI::Xaml::ISetterBase_adaptor<X> { typedef adapt ISetterBase; };
struct ISetterBase : ISetterBase_raw, generate<ISetterBase> {};

// SetterBase
template<typename X> struct statics<SetterBase, X> : X {
	typedef typename X::root_type SetterBase;
};
struct SetterBase : generate<SetterBase> {};

// ISetterBaseCollection
struct ISetterBaseCollection_raw : IInspectable {
	virtual STDMETHODIMP _get_IsSealed(bool *value);
};
template<typename X> struct ISetterBaseCollection_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISetterBaseCollection_adaptor::IsSealed)->_get_IsSealed(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsSealed;
	};
	ISetterBaseCollection_adaptor() {}
};
template<typename X> struct adapt<ISetterBaseCollection, X> : Windows::UI::Xaml::ISetterBaseCollection_adaptor<X> { typedef adapt ISetterBaseCollection; };
struct ISetterBaseCollection : ISetterBaseCollection_raw, generate<ISetterBaseCollection> {};

// SetterBaseCollection
template<typename X> struct statics<SetterBaseCollection, X> : X {
	typedef typename X::root_type SetterBaseCollection;
};
struct SetterBaseCollection : generate<SetterBaseCollection> {};

// ITargetPropertyPath
struct ITargetPropertyPath_raw : IInspectable {
	virtual STDMETHODIMP _get_Path(PropertyPath* *value);
	virtual STDMETHODIMP _put_Path(PropertyPath* value);
	virtual STDMETHODIMP _get_Target(IInspectable* *value);
	virtual STDMETHODIMP _put_Target(IInspectable* value);
};
template<typename X> struct ITargetPropertyPath_adaptor : X {
	union {
		struct : property {
			ptr<PropertyPath> get() { PropertyPath* value; hrcheck(enc(&ITargetPropertyPath_adaptor::Path)->_get_Path(&value)); return from_abi(value); }
			ptr<PropertyPath> operator()() { return get(); }
			operator ptr<PropertyPath> () { return get(); }
			ptr<PropertyPath> operator->() { return get(); }
			void put(pptr<PropertyPath> value) { hrcheck(enc(&ITargetPropertyPath_adaptor::Path)->_put_Path(value)); }
			void operator=(pptr<PropertyPath> value) { put(value); }
			void operator()(pptr<PropertyPath> value) { put(value); }
		} Path;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ITargetPropertyPath_adaptor::Target)->_get_Target(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&ITargetPropertyPath_adaptor::Target)->_put_Target(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Target;
	};
	ITargetPropertyPath_adaptor() {}
};
template<typename X> struct adapt<ITargetPropertyPath, X> : Windows::UI::Xaml::ITargetPropertyPath_adaptor<X> { typedef adapt ITargetPropertyPath; };
struct ITargetPropertyPath : ITargetPropertyPath_raw, generate<ITargetPropertyPath> {};

// ITargetPropertyPathFactory
struct ITargetPropertyPathFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(DependencyProperty* targetProperty, TargetPropertyPath* *instance);
};

// TargetPropertyPath
template<typename> struct TargetPropertyPath_statics {
	static TargetPropertyPath *activate() { TargetPropertyPath *t; get_activation_factory<TargetPropertyPath>()->ActivateInstance((IInspectable**)&t); return t; }
	static TargetPropertyPath *activate(pptr<DependencyProperty> targetProperty) { TargetPropertyPath *instance; hrcheck(get_activation_factory<TargetPropertyPath, ITargetPropertyPathFactory>()->_CreateInstance(targetProperty, &instance)); return instance; }
};

template<typename X> struct statics<TargetPropertyPath, X> : X, Windows::UI::Xaml::TargetPropertyPath_statics<void> {
	using Windows::UI::Xaml::TargetPropertyPath_statics<void>::activate;
	typedef typename X::root_type TargetPropertyPath;
};
struct TargetPropertyPath : generate<TargetPropertyPath> {};

// ITriggerActionFactory
struct ITriggerActionFactory : IInspectable, generate<ITriggerActionFactory> {};

// ITriggerAction
struct ITriggerAction : IInspectable, generate<ITriggerAction> {};

// TriggerAction
template<typename X> struct statics<TriggerAction, X> : X {
	typedef typename X::root_type TriggerAction;
};
struct TriggerAction : generate<TriggerAction> {};

// TriggerActionCollection
template<typename X> struct statics<TriggerActionCollection, X> : X {
	typedef typename X::root_type TriggerActionCollection;
};
struct TriggerActionCollection : generate<TriggerActionCollection> {};

// ITriggerBaseFactory
struct ITriggerBaseFactory : IInspectable, generate<ITriggerBaseFactory> {};

// ITriggerBase
struct ITriggerBase : IInspectable, generate<ITriggerBase> {};

// TriggerBase
template<typename X> struct statics<TriggerBase, X> : X {
	typedef typename X::root_type TriggerBase;
};
struct TriggerBase : generate<TriggerBase> {};

// TriggerCollection
template<typename X> struct statics<TriggerCollection, X> : X {
	typedef typename X::root_type TriggerCollection;
};
struct TriggerCollection : generate<TriggerCollection> {};

// IBringIntoViewRequestedEventArgs
struct IBringIntoViewRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_TargetElement(UIElement* *value);
	virtual STDMETHODIMP _put_TargetElement(UIElement* value);
	virtual STDMETHODIMP _get_AnimationDesired(bool *value);
	virtual STDMETHODIMP _put_AnimationDesired(bool value);
	virtual STDMETHODIMP _get_TargetRect(Foundation::Rect *value);
	virtual STDMETHODIMP _put_TargetRect(Foundation::Rect value);
	virtual STDMETHODIMP _get_HorizontalAlignmentRatio(double *value);
	virtual STDMETHODIMP _get_VerticalAlignmentRatio(double *value);
	virtual STDMETHODIMP _get_HorizontalOffset(double *value);
	virtual STDMETHODIMP _put_HorizontalOffset(double value);
	virtual STDMETHODIMP _get_VerticalOffset(double *value);
	virtual STDMETHODIMP _put_VerticalOffset(double value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
};
template<typename X> struct IBringIntoViewRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBringIntoViewRequestedEventArgs_adaptor::AnimationDesired)->_get_AnimationDesired(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IBringIntoViewRequestedEventArgs_adaptor::AnimationDesired)->_put_AnimationDesired(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AnimationDesired;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBringIntoViewRequestedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IBringIntoViewRequestedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			double get() { double value; hrcheck(enc(&IBringIntoViewRequestedEventArgs_adaptor::HorizontalAlignmentRatio)->_get_HorizontalAlignmentRatio(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} HorizontalAlignmentRatio;
		struct : property {
			double get() { double value; hrcheck(enc(&IBringIntoViewRequestedEventArgs_adaptor::HorizontalOffset)->_get_HorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IBringIntoViewRequestedEventArgs_adaptor::HorizontalOffset)->_put_HorizontalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} HorizontalOffset;
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IBringIntoViewRequestedEventArgs_adaptor::TargetElement)->_get_TargetElement(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IBringIntoViewRequestedEventArgs_adaptor::TargetElement)->_put_TargetElement(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} TargetElement;
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&IBringIntoViewRequestedEventArgs_adaptor::TargetRect)->_get_TargetRect(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
			void put(const Foundation::Rect& value) { hrcheck(enc(&IBringIntoViewRequestedEventArgs_adaptor::TargetRect)->_put_TargetRect(value)); }
			void operator=(const Foundation::Rect& value) { put(value); }
			void operator()(const Foundation::Rect& value) { put(value); }
		} TargetRect;
		struct : property {
			double get() { double value; hrcheck(enc(&IBringIntoViewRequestedEventArgs_adaptor::VerticalAlignmentRatio)->_get_VerticalAlignmentRatio(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} VerticalAlignmentRatio;
		struct : property {
			double get() { double value; hrcheck(enc(&IBringIntoViewRequestedEventArgs_adaptor::VerticalOffset)->_get_VerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IBringIntoViewRequestedEventArgs_adaptor::VerticalOffset)->_put_VerticalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} VerticalOffset;
	};
	IBringIntoViewRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IBringIntoViewRequestedEventArgs, X> : Windows::UI::Xaml::IBringIntoViewRequestedEventArgs_adaptor<X> { typedef adapt IBringIntoViewRequestedEventArgs; };
struct IBringIntoViewRequestedEventArgs : IBringIntoViewRequestedEventArgs_raw, generate<IBringIntoViewRequestedEventArgs> {};

// BringIntoViewRequestedEventArgs
template<typename X> struct statics<BringIntoViewRequestedEventArgs, X> : X {
	typedef typename X::root_type BringIntoViewRequestedEventArgs;
};
struct BringIntoViewRequestedEventArgs : generate<BringIntoViewRequestedEventArgs> {};

// IDependencyObjectCollectionFactory
struct IDependencyObjectCollectionFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, DependencyObjectCollection* *instance);
};

// DependencyObjectCollection
template<typename> struct DependencyObjectCollection_statics {
	static DependencyObjectCollection *activate(object_ref outer, IInspectable* *inner) { DependencyObjectCollection *instance; hrcheck(get_activation_factory<DependencyObjectCollection, IDependencyObjectCollectionFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<DependencyObjectCollection, X> : X, Windows::UI::Xaml::DependencyObjectCollection_statics<void> {
	using Windows::UI::Xaml::DependencyObjectCollection_statics<void>::activate;
	typedef typename X::root_type DependencyObjectCollection;
};
struct DependencyObjectCollection : generate<DependencyObjectCollection> {};

// IDragEventArgs
struct IDragEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _get_Data(ApplicationModel::DataTransfer::DataPackage* *value);
	virtual STDMETHODIMP _put_Data(ApplicationModel::DataTransfer::DataPackage* value);
	virtual STDMETHODIMP _GetPosition(UIElement* relativeTo, Foundation::Point *returnValue);
};
template<typename X> struct IDragEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<ApplicationModel::DataTransfer::DataPackage> get() { ApplicationModel::DataTransfer::DataPackage* value; hrcheck(enc(&IDragEventArgs_adaptor::Data)->_get_Data(&value)); return from_abi(value); }
			ptr<ApplicationModel::DataTransfer::DataPackage> operator()() { return get(); }
			operator ptr<ApplicationModel::DataTransfer::DataPackage> () { return get(); }
			ptr<ApplicationModel::DataTransfer::DataPackage> operator->() { return get(); }
			void put(pptr<ApplicationModel::DataTransfer::DataPackage> value) { hrcheck(enc(&IDragEventArgs_adaptor::Data)->_put_Data(value)); }
			void operator=(pptr<ApplicationModel::DataTransfer::DataPackage> value) { put(value); }
			void operator()(pptr<ApplicationModel::DataTransfer::DataPackage> value) { put(value); }
		} Data;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDragEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDragEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
	};
	Foundation::Point GetPosition(pptr<UIElement> relativeTo) { Foundation::Point returnValue; hrcheck(X::get()->_GetPosition(relativeTo, &returnValue)); return returnValue; }
	IDragEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDragEventArgs, X> : Windows::UI::Xaml::IDragEventArgs_adaptor<X> { typedef adapt IDragEventArgs; };
struct IDragEventArgs : IDragEventArgs_raw, generate<IDragEventArgs> {};

// IDragEventArgs2
struct IDragEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _get_DataView(ApplicationModel::DataTransfer::DataPackageView* *value);
	virtual STDMETHODIMP _get_DragUIOverride(Xaml::DragUIOverride* *value);
	virtual STDMETHODIMP _get_Modifiers(ApplicationModel::DataTransfer::DragDrop::DragDropModifiers *value);
	virtual STDMETHODIMP _get_AcceptedOperation(ApplicationModel::DataTransfer::DataPackageOperation *value);
	virtual STDMETHODIMP _put_AcceptedOperation(ApplicationModel::DataTransfer::DataPackageOperation value);
	virtual STDMETHODIMP _GetDeferral(DragOperationDeferral* *returnValue);
};
template<typename X> struct IDragEventArgs2_adaptor : X {
	union {
		struct : property {
			ApplicationModel::DataTransfer::DataPackageOperation get() { ApplicationModel::DataTransfer::DataPackageOperation value; hrcheck(enc(&IDragEventArgs2_adaptor::AcceptedOperation)->_get_AcceptedOperation(&value)); return value; }
			ApplicationModel::DataTransfer::DataPackageOperation operator()() { return get(); }
			operator ApplicationModel::DataTransfer::DataPackageOperation () { return get(); }
			void put(ApplicationModel::DataTransfer::DataPackageOperation value) { hrcheck(enc(&IDragEventArgs2_adaptor::AcceptedOperation)->_put_AcceptedOperation(value)); }
			void operator=(ApplicationModel::DataTransfer::DataPackageOperation value) { put(value); }
			void operator()(ApplicationModel::DataTransfer::DataPackageOperation value) { put(value); }
		} AcceptedOperation;
		struct : property {
			ptr<ApplicationModel::DataTransfer::DataPackageView> get() { ApplicationModel::DataTransfer::DataPackageView* value; hrcheck(enc(&IDragEventArgs2_adaptor::DataView)->_get_DataView(&value)); return from_abi(value); }
			ptr<ApplicationModel::DataTransfer::DataPackageView> operator()() { return get(); }
			operator ptr<ApplicationModel::DataTransfer::DataPackageView> () { return get(); }
			ptr<ApplicationModel::DataTransfer::DataPackageView> operator->() { return get(); }
		} DataView;
		struct : property {
			ptr<Xaml::DragUIOverride> get() { Xaml::DragUIOverride* value; hrcheck(enc(&IDragEventArgs2_adaptor::DragUIOverride)->_get_DragUIOverride(&value)); return from_abi(value); }
			ptr<Xaml::DragUIOverride> operator()() { return get(); }
			operator ptr<Xaml::DragUIOverride> () { return get(); }
			ptr<Xaml::DragUIOverride> operator->() { return get(); }
		} DragUIOverride;
		struct : property {
			ApplicationModel::DataTransfer::DragDrop::DragDropModifiers get() { ApplicationModel::DataTransfer::DragDrop::DragDropModifiers value; hrcheck(enc(&IDragEventArgs2_adaptor::Modifiers)->_get_Modifiers(&value)); return value; }
			ApplicationModel::DataTransfer::DragDrop::DragDropModifiers operator()() { return get(); }
			operator ApplicationModel::DataTransfer::DragDrop::DragDropModifiers () { return get(); }
		} Modifiers;
	};
	ptr<DragOperationDeferral> GetDeferral() { DragOperationDeferral* returnValue; hrcheck(X::get()->_GetDeferral(&returnValue)); return from_abi(returnValue); }
	IDragEventArgs2_adaptor() {}
};
template<typename X> struct adapt<IDragEventArgs2, X> : Windows::UI::Xaml::IDragEventArgs2_adaptor<X> { typedef adapt IDragEventArgs2; };
struct IDragEventArgs2 : IDragEventArgs2_raw, generate<IDragEventArgs2> {};

// IDragEventArgs3
struct IDragEventArgs3_raw : IInspectable {
	virtual STDMETHODIMP _get_AllowedOperations(ApplicationModel::DataTransfer::DataPackageOperation *value);
};
template<typename X> struct IDragEventArgs3_adaptor : X {
	union {
		struct : property {
			ApplicationModel::DataTransfer::DataPackageOperation get() { ApplicationModel::DataTransfer::DataPackageOperation value; hrcheck(enc(&IDragEventArgs3_adaptor::AllowedOperations)->_get_AllowedOperations(&value)); return value; }
			ApplicationModel::DataTransfer::DataPackageOperation operator()() { return get(); }
			operator ApplicationModel::DataTransfer::DataPackageOperation () { return get(); }
		} AllowedOperations;
	};
	IDragEventArgs3_adaptor() {}
};
template<typename X> struct adapt<IDragEventArgs3, X> : Windows::UI::Xaml::IDragEventArgs3_adaptor<X> { typedef adapt IDragEventArgs3; };
struct IDragEventArgs3 : IDragEventArgs3_raw, generate<IDragEventArgs3> {};

// DragEventArgs
template<typename X> struct statics<DragEventArgs, X> : X {
	typedef typename X::root_type DragEventArgs;
};
struct DragEventArgs : generate<DragEventArgs> {};

// IDragStartingEventArgs
struct IDragStartingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Cancel(bool *value);
	virtual STDMETHODIMP _put_Cancel(bool value);
	virtual STDMETHODIMP _get_Data(ApplicationModel::DataTransfer::DataPackage* *value);
	virtual STDMETHODIMP _get_DragUI(Xaml::DragUI* *value);
	virtual STDMETHODIMP _GetDeferral(DragOperationDeferral* *returnValue);
	virtual STDMETHODIMP _GetPosition(UIElement* relativeTo, Foundation::Point *returnValue);
};
template<typename X> struct IDragStartingEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDragStartingEventArgs_adaptor::Cancel)->_get_Cancel(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDragStartingEventArgs_adaptor::Cancel)->_put_Cancel(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Cancel;
		struct : property {
			ptr<ApplicationModel::DataTransfer::DataPackage> get() { ApplicationModel::DataTransfer::DataPackage* value; hrcheck(enc(&IDragStartingEventArgs_adaptor::Data)->_get_Data(&value)); return from_abi(value); }
			ptr<ApplicationModel::DataTransfer::DataPackage> operator()() { return get(); }
			operator ptr<ApplicationModel::DataTransfer::DataPackage> () { return get(); }
			ptr<ApplicationModel::DataTransfer::DataPackage> operator->() { return get(); }
		} Data;
		struct : property {
			ptr<Xaml::DragUI> get() { Xaml::DragUI* value; hrcheck(enc(&IDragStartingEventArgs_adaptor::DragUI)->_get_DragUI(&value)); return from_abi(value); }
			ptr<Xaml::DragUI> operator()() { return get(); }
			operator ptr<Xaml::DragUI> () { return get(); }
			ptr<Xaml::DragUI> operator->() { return get(); }
		} DragUI;
	};
	ptr<DragOperationDeferral> GetDeferral() { DragOperationDeferral* returnValue; hrcheck(X::get()->_GetDeferral(&returnValue)); return from_abi(returnValue); }
	Foundation::Point GetPosition(pptr<UIElement> relativeTo) { Foundation::Point returnValue; hrcheck(X::get()->_GetPosition(relativeTo, &returnValue)); return returnValue; }
	IDragStartingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDragStartingEventArgs, X> : Windows::UI::Xaml::IDragStartingEventArgs_adaptor<X> { typedef adapt IDragStartingEventArgs; };
struct IDragStartingEventArgs : IDragStartingEventArgs_raw, generate<IDragStartingEventArgs> {};

// IDragStartingEventArgs2
struct IDragStartingEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _get_AllowedOperations(ApplicationModel::DataTransfer::DataPackageOperation *value);
	virtual STDMETHODIMP _put_AllowedOperations(ApplicationModel::DataTransfer::DataPackageOperation value);
};
template<typename X> struct IDragStartingEventArgs2_adaptor : X {
	union {
		struct : property {
			ApplicationModel::DataTransfer::DataPackageOperation get() { ApplicationModel::DataTransfer::DataPackageOperation value; hrcheck(enc(&IDragStartingEventArgs2_adaptor::AllowedOperations)->_get_AllowedOperations(&value)); return value; }
			ApplicationModel::DataTransfer::DataPackageOperation operator()() { return get(); }
			operator ApplicationModel::DataTransfer::DataPackageOperation () { return get(); }
			void put(ApplicationModel::DataTransfer::DataPackageOperation value) { hrcheck(enc(&IDragStartingEventArgs2_adaptor::AllowedOperations)->_put_AllowedOperations(value)); }
			void operator=(ApplicationModel::DataTransfer::DataPackageOperation value) { put(value); }
			void operator()(ApplicationModel::DataTransfer::DataPackageOperation value) { put(value); }
		} AllowedOperations;
	};
	IDragStartingEventArgs2_adaptor() {}
};
template<typename X> struct adapt<IDragStartingEventArgs2, X> : Windows::UI::Xaml::IDragStartingEventArgs2_adaptor<X> { typedef adapt IDragStartingEventArgs2; };
struct IDragStartingEventArgs2 : IDragStartingEventArgs2_raw, generate<IDragStartingEventArgs2> {};

// DragStartingEventArgs
template<typename X> struct statics<DragStartingEventArgs, X> : X {
	typedef typename X::root_type DragStartingEventArgs;
};
struct DragStartingEventArgs : generate<DragStartingEventArgs> {};

// IDropCompletedEventArgs
struct IDropCompletedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_DropResult(ApplicationModel::DataTransfer::DataPackageOperation *value);
};
template<typename X> struct IDropCompletedEventArgs_adaptor : X {
	union {
		struct : property {
			ApplicationModel::DataTransfer::DataPackageOperation get() { ApplicationModel::DataTransfer::DataPackageOperation value; hrcheck(enc(&IDropCompletedEventArgs_adaptor::DropResult)->_get_DropResult(&value)); return value; }
			ApplicationModel::DataTransfer::DataPackageOperation operator()() { return get(); }
			operator ApplicationModel::DataTransfer::DataPackageOperation () { return get(); }
		} DropResult;
	};
	IDropCompletedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDropCompletedEventArgs, X> : Windows::UI::Xaml::IDropCompletedEventArgs_adaptor<X> { typedef adapt IDropCompletedEventArgs; };
struct IDropCompletedEventArgs : IDropCompletedEventArgs_raw, generate<IDropCompletedEventArgs> {};

// DropCompletedEventArgs
template<typename X> struct statics<DropCompletedEventArgs, X> : X {
	typedef typename X::root_type DropCompletedEventArgs;
};
struct DropCompletedEventArgs : generate<DropCompletedEventArgs> {};

// IExceptionRoutedEventArgs
struct IExceptionRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ErrorMessage(HSTRING *value);
};
template<typename X> struct IExceptionRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IExceptionRoutedEventArgs_adaptor::ErrorMessage)->_get_ErrorMessage(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ErrorMessage;
	};
	IExceptionRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IExceptionRoutedEventArgs, X> : Windows::UI::Xaml::IExceptionRoutedEventArgs_adaptor<X> { typedef adapt IExceptionRoutedEventArgs; };
struct IExceptionRoutedEventArgs : IExceptionRoutedEventArgs_raw, generate<IExceptionRoutedEventArgs> {};

// IExceptionRoutedEventArgsFactory
struct IExceptionRoutedEventArgsFactory : IInspectable, generate<IExceptionRoutedEventArgsFactory> {};

// ExceptionRoutedEventArgs
template<typename X> struct statics<ExceptionRoutedEventArgs, X> : X {
	typedef typename X::root_type ExceptionRoutedEventArgs;
};
struct ExceptionRoutedEventArgs : generate<ExceptionRoutedEventArgs> {};

// IFrameworkTemplate
struct IFrameworkTemplate : IInspectable, generate<IFrameworkTemplate> {};

// IFrameworkTemplateFactory
struct IFrameworkTemplateFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, FrameworkTemplate* *instance);
};

// FrameworkTemplate
template<typename X> struct statics<FrameworkTemplate, X> : X {
	typedef typename X::root_type FrameworkTemplate;
};
struct FrameworkTemplate : generate<FrameworkTemplate> {};

// DataTemplate
template<typename> struct DataTemplate_statics {
	static struct _ExtensionInstanceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DataTemplate, IDataTemplateStatics2>()->_get_ExtensionInstanceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ExtensionInstanceProperty;
	static ptr<IDataTemplateExtension> GetExtensionInstance(pptr<FrameworkElement> element) { IDataTemplateExtension* value; hrcheck(get_activation_factory<DataTemplate, IDataTemplateStatics2>()->_GetExtensionInstance(element, &value)); return from_abi(value); }
	static void SetExtensionInstance(pptr<FrameworkElement> element, pptr<IDataTemplateExtension> value) { hrcheck(get_activation_factory<DataTemplate, IDataTemplateStatics2>()->_SetExtensionInstance(element, value)); }
	static DataTemplate *activate(object_ref outer, IInspectable* *inner) { DataTemplate *instance; hrcheck(get_activation_factory<DataTemplate, IDataTemplateFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename DataTemplate_statics<X>::_ExtensionInstanceProperty DataTemplate_statics<X>::ExtensionInstanceProperty;

template<typename X> struct statics<DataTemplate, X> : X, Windows::UI::Xaml::DataTemplate_statics<void> {
	using Windows::UI::Xaml::DataTemplate_statics<void>::activate;
	typedef typename X::root_type DataTemplate;
};
struct DataTemplate : generate<DataTemplate> {};

// IPropertyPath
struct IPropertyPath_raw : IInspectable {
	virtual STDMETHODIMP _get_Path(HSTRING *value);
};
template<typename X> struct IPropertyPath_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPropertyPath_adaptor::Path)->_get_Path(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Path;
	};
	IPropertyPath_adaptor() {}
};
template<typename X> struct adapt<IPropertyPath, X> : Windows::UI::Xaml::IPropertyPath_adaptor<X> { typedef adapt IPropertyPath; };
struct IPropertyPath : IPropertyPath_raw, generate<IPropertyPath> {};

// IPropertyPathFactory
struct IPropertyPathFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(HSTRING path, PropertyPath* *instance);
};

// PropertyPath
template<typename> struct PropertyPath_statics {
	static PropertyPath *activate(hstring_ref path) { PropertyPath *instance; hrcheck(get_activation_factory<PropertyPath, IPropertyPathFactory>()->_CreateInstance(path, &instance)); return instance; }
};

template<typename X> struct statics<PropertyPath, X> : X, Windows::UI::Xaml::PropertyPath_statics<void> {
	using Windows::UI::Xaml::PropertyPath_statics<void>::activate;
	typedef typename X::root_type PropertyPath;
};
struct PropertyPath : generate<PropertyPath> {};

// IResourceDictionary
struct IResourceDictionary_raw : IInspectable {
	virtual STDMETHODIMP _get_Source(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_Source(Foundation::Uri* value);
	virtual STDMETHODIMP _get_MergedDictionaries(Foundation::Collections::IVector<ResourceDictionary*>* *value);
	virtual STDMETHODIMP _get_ThemeDictionaries(Foundation::Collections::IMap<IInspectable*, IInspectable*>* *value);
};
template<typename X> struct IResourceDictionary_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<ResourceDictionary>>> get() { Foundation::Collections::IVector<ResourceDictionary*>* value; hrcheck(enc(&IResourceDictionary_adaptor::MergedDictionaries)->_get_MergedDictionaries(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<ResourceDictionary>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<ResourceDictionary>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<ResourceDictionary>>> operator->() { return get(); }
		} MergedDictionaries;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IResourceDictionary_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IResourceDictionary_adaptor::Source)->_put_Source(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} Source;
		struct : property {
			ptr<Foundation::Collections::IMap<object, object>> get() { Foundation::Collections::IMap<IInspectable*, IInspectable*>* value; hrcheck(enc(&IResourceDictionary_adaptor::ThemeDictionaries)->_get_ThemeDictionaries(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMap<object, object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMap<object, object>> () { return get(); }
			ptr<Foundation::Collections::IMap<object, object>> operator->() { return get(); }
		} ThemeDictionaries;
	};
	IResourceDictionary_adaptor() {}
};
template<typename X> struct adapt<IResourceDictionary, X> : Windows::UI::Xaml::IResourceDictionary_adaptor<X> { typedef adapt IResourceDictionary; };
struct IResourceDictionary : IResourceDictionary_raw, generate<IResourceDictionary> {};

// IResourceDictionaryFactory
struct IResourceDictionaryFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ResourceDictionary* *instance);
};

// ResourceDictionary
template<typename> struct ResourceDictionary_statics {
	static ResourceDictionary *activate(object_ref outer, IInspectable* *inner) { ResourceDictionary *instance; hrcheck(get_activation_factory<ResourceDictionary, IResourceDictionaryFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<ResourceDictionary, X> : X, Windows::UI::Xaml::ResourceDictionary_statics<void> {
	using Windows::UI::Xaml::ResourceDictionary_statics<void>::activate;
	typedef typename X::root_type ResourceDictionary;
};
struct ResourceDictionary : generate<ResourceDictionary> {};

// ISizeChangedEventArgs
struct ISizeChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_PreviousSize(Foundation::Size *value);
	virtual STDMETHODIMP _get_NewSize(Foundation::Size *value);
};
template<typename X> struct ISizeChangedEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::Size get() { Foundation::Size value; hrcheck(enc(&ISizeChangedEventArgs_adaptor::NewSize)->_get_NewSize(&value)); return value; }
			Foundation::Size operator()() { return get(); }
			operator Foundation::Size () { return get(); }
		} NewSize;
		struct : property {
			Foundation::Size get() { Foundation::Size value; hrcheck(enc(&ISizeChangedEventArgs_adaptor::PreviousSize)->_get_PreviousSize(&value)); return value; }
			Foundation::Size operator()() { return get(); }
			operator Foundation::Size () { return get(); }
		} PreviousSize;
	};
	ISizeChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISizeChangedEventArgs, X> : Windows::UI::Xaml::ISizeChangedEventArgs_adaptor<X> { typedef adapt ISizeChangedEventArgs; };
struct ISizeChangedEventArgs : ISizeChangedEventArgs_raw, generate<ISizeChangedEventArgs> {};

// SizeChangedEventArgs
template<typename X> struct statics<SizeChangedEventArgs, X> : X {
	typedef typename X::root_type SizeChangedEventArgs;
};
struct SizeChangedEventArgs : generate<SizeChangedEventArgs> {};

// IStateTriggerBase
struct IStateTriggerBase : IInspectable, generate<IStateTriggerBase> {};

// IStateTriggerBaseProtected
struct IStateTriggerBaseProtected_raw : IInspectable {
	virtual STDMETHODIMP _SetActive(bool IsActive);
};
template<typename X> struct IStateTriggerBaseProtected_adaptor : X {
	void SetActive(bool IsActive) { hrcheck(X::get()->_SetActive(IsActive)); }
};
template<typename X> struct adapt<IStateTriggerBaseProtected, X> : Windows::UI::Xaml::IStateTriggerBaseProtected_adaptor<X> { typedef adapt IStateTriggerBaseProtected; };
struct IStateTriggerBaseProtected : IStateTriggerBaseProtected_raw, generate<IStateTriggerBaseProtected> {};

// IStateTriggerBaseFactory
struct IStateTriggerBaseFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, StateTriggerBase* *instance);
};

// StateTriggerBase
template<typename X> struct statics<StateTriggerBase, X> : X {
	typedef typename X::root_type StateTriggerBase;
};
struct StateTriggerBase : generate<StateTriggerBase> {};

// IStyle
struct IStyle_raw : IInspectable {
	virtual STDMETHODIMP _get_IsSealed(bool *value);
	virtual STDMETHODIMP _get_Setters(SetterBaseCollection* *value);
	virtual STDMETHODIMP _get_TargetType(Interop::TypeName *value);
	virtual STDMETHODIMP _put_TargetType(Interop::TypeName value);
	virtual STDMETHODIMP _get_BasedOn(Style* *value);
	virtual STDMETHODIMP _put_BasedOn(Style* value);
	virtual STDMETHODIMP _Seal();
};
template<typename X> struct IStyle_adaptor : X {
	union {
		struct : property {
			ptr<Style> get() { Style* value; hrcheck(enc(&IStyle_adaptor::BasedOn)->_get_BasedOn(&value)); return from_abi(value); }
			ptr<Style> operator()() { return get(); }
			operator ptr<Style> () { return get(); }
			ptr<Style> operator->() { return get(); }
			void put(pptr<Style> value) { hrcheck(enc(&IStyle_adaptor::BasedOn)->_put_BasedOn(value)); }
			void operator=(pptr<Style> value) { put(value); }
			void operator()(pptr<Style> value) { put(value); }
		} BasedOn;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStyle_adaptor::IsSealed)->_get_IsSealed(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsSealed;
		struct : property {
			ptr<SetterBaseCollection> get() { SetterBaseCollection* value; hrcheck(enc(&IStyle_adaptor::Setters)->_get_Setters(&value)); return from_abi(value); }
			ptr<SetterBaseCollection> operator()() { return get(); }
			operator ptr<SetterBaseCollection> () { return get(); }
			ptr<SetterBaseCollection> operator->() { return get(); }
		} Setters;
		struct : property {
			Interop::TypeName get() { Interop::TypeName value; hrcheck(enc(&IStyle_adaptor::TargetType)->_get_TargetType(&value)); return value; }
			Interop::TypeName operator()() { return get(); }
			operator Interop::TypeName () { return get(); }
			void put(const Interop::TypeName& value) { hrcheck(enc(&IStyle_adaptor::TargetType)->_put_TargetType(value)); }
			void operator=(const Interop::TypeName& value) { put(value); }
			void operator()(const Interop::TypeName& value) { put(value); }
		} TargetType;
	};
	void Seal() { hrcheck(X::get()->_Seal()); }
	IStyle_adaptor() {}
};
template<typename X> struct adapt<IStyle, X> : Windows::UI::Xaml::IStyle_adaptor<X> { typedef adapt IStyle; };
struct IStyle : IStyle_raw, generate<IStyle> {};

// IStyleFactory
struct IStyleFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(Interop::TypeName targetType, Style* *instance);
};

// Style
template<typename> struct Style_statics {
	static Style *activate(const Interop::TypeName& targetType) { Style *instance; hrcheck(get_activation_factory<Style, IStyleFactory>()->_CreateInstance(targetType, &instance)); return instance; }
	static Style *activate() { Style *t; get_activation_factory<Style>()->ActivateInstance((IInspectable**)&t); return t; }
};

template<typename X> struct statics<Style, X> : X, Windows::UI::Xaml::Style_statics<void> {
	using Windows::UI::Xaml::Style_statics<void>::activate;
	typedef typename X::root_type Style;
};
struct Style : generate<Style> {};

// IUIElement
struct IUIElement_raw : IInspectable {
	virtual STDMETHODIMP _get_DesiredSize(Foundation::Size *value);
	virtual STDMETHODIMP _get_AllowDrop(bool *value);
	virtual STDMETHODIMP _put_AllowDrop(bool value);
	virtual STDMETHODIMP _get_Opacity(double *value);
	virtual STDMETHODIMP _put_Opacity(double value);
	virtual STDMETHODIMP _get_Clip(Media::RectangleGeometry* *value);
	virtual STDMETHODIMP _put_Clip(Media::RectangleGeometry* value);
	virtual STDMETHODIMP _get_RenderTransform(Media::Transform* *value);
	virtual STDMETHODIMP _put_RenderTransform(Media::Transform* value);
	virtual STDMETHODIMP _get_Projection(Media::Projection* *value);
	virtual STDMETHODIMP _put_Projection(Media::Projection* value);
	virtual STDMETHODIMP _get_RenderTransformOrigin(Foundation::Point *value);
	virtual STDMETHODIMP _put_RenderTransformOrigin(Foundation::Point value);
	virtual STDMETHODIMP _get_IsHitTestVisible(bool *value);
	virtual STDMETHODIMP _put_IsHitTestVisible(bool value);
	virtual STDMETHODIMP _get_Visibility(Xaml::Visibility *value);
	virtual STDMETHODIMP _put_Visibility(Xaml::Visibility value);
	virtual STDMETHODIMP _get_RenderSize(Foundation::Size *value);
	virtual STDMETHODIMP _get_UseLayoutRounding(bool *value);
	virtual STDMETHODIMP _put_UseLayoutRounding(bool value);
	virtual STDMETHODIMP _get_Transitions(Media::Animation::TransitionCollection* *value);
	virtual STDMETHODIMP _put_Transitions(Media::Animation::TransitionCollection* value);
	virtual STDMETHODIMP _get_CacheMode(Media::CacheMode* *value);
	virtual STDMETHODIMP _put_CacheMode(Media::CacheMode* value);
	virtual STDMETHODIMP _get_IsTapEnabled(bool *value);
	virtual STDMETHODIMP _put_IsTapEnabled(bool value);
	virtual STDMETHODIMP _get_IsDoubleTapEnabled(bool *value);
	virtual STDMETHODIMP _put_IsDoubleTapEnabled(bool value);
	virtual STDMETHODIMP _get_IsRightTapEnabled(bool *value);
	virtual STDMETHODIMP _put_IsRightTapEnabled(bool value);
	virtual STDMETHODIMP _get_IsHoldingEnabled(bool *value);
	virtual STDMETHODIMP _put_IsHoldingEnabled(bool value);
	virtual STDMETHODIMP _get_ManipulationMode(Input::ManipulationModes *value);
	virtual STDMETHODIMP _put_ManipulationMode(Input::ManipulationModes value);
	virtual STDMETHODIMP _get_PointerCaptures(Foundation::Collections::IVectorView<Input::Pointer*>* *value);
	virtual STDMETHODIMP _add_KeyUp(Input::KeyEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_KeyUp(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_KeyDown(Input::KeyEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_KeyDown(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_GotFocus(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_GotFocus(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_LostFocus(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_LostFocus(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DragEnter(DragEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DragEnter(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DragLeave(DragEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DragLeave(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DragOver(DragEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DragOver(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Drop(DragEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Drop(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PointerPressed(Input::PointerEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PointerPressed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PointerMoved(Input::PointerEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PointerMoved(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PointerReleased(Input::PointerEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PointerReleased(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PointerEntered(Input::PointerEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PointerEntered(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PointerExited(Input::PointerEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PointerExited(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PointerCaptureLost(Input::PointerEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PointerCaptureLost(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PointerCanceled(Input::PointerEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PointerCanceled(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PointerWheelChanged(Input::PointerEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PointerWheelChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Tapped(Input::TappedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Tapped(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DoubleTapped(Input::DoubleTappedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DoubleTapped(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Holding(Input::HoldingEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Holding(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_RightTapped(Input::RightTappedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_RightTapped(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ManipulationStarting(Input::ManipulationStartingEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ManipulationStarting(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ManipulationInertiaStarting(Input::ManipulationInertiaStartingEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ManipulationInertiaStarting(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ManipulationStarted(Input::ManipulationStartedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ManipulationStarted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ManipulationDelta(Input::ManipulationDeltaEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ManipulationDelta(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ManipulationCompleted(Input::ManipulationCompletedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ManipulationCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _Measure(Foundation::Size availableSize);
	virtual STDMETHODIMP _Arrange(Foundation::Rect finalRect);
	virtual STDMETHODIMP _CapturePointer(Input::Pointer* value, bool *returnValue);
	virtual STDMETHODIMP _ReleasePointerCapture(Input::Pointer* value);
	virtual STDMETHODIMP _ReleasePointerCaptures();
	virtual STDMETHODIMP _AddHandler(RoutedEvent* routedEvent, IInspectable* handler, bool handledEventsToo);
	virtual STDMETHODIMP _RemoveHandler(RoutedEvent* routedEvent, IInspectable* handler);
	virtual STDMETHODIMP _TransformToVisual(UIElement* visual, Media::GeneralTransform* *returnValue);
	virtual STDMETHODIMP _InvalidateMeasure();
	virtual STDMETHODIMP _InvalidateArrange();
	virtual STDMETHODIMP _UpdateLayout();
};
template<typename X> struct IUIElement_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUIElement_adaptor::AllowDrop)->_get_AllowDrop(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IUIElement_adaptor::AllowDrop)->_put_AllowDrop(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AllowDrop;
		struct : property {
			ptr<Media::CacheMode> get() { Media::CacheMode* value; hrcheck(enc(&IUIElement_adaptor::CacheMode)->_get_CacheMode(&value)); return from_abi(value); }
			ptr<Media::CacheMode> operator()() { return get(); }
			operator ptr<Media::CacheMode> () { return get(); }
			ptr<Media::CacheMode> operator->() { return get(); }
			void put(pptr<Media::CacheMode> value) { hrcheck(enc(&IUIElement_adaptor::CacheMode)->_put_CacheMode(value)); }
			void operator=(pptr<Media::CacheMode> value) { put(value); }
			void operator()(pptr<Media::CacheMode> value) { put(value); }
		} CacheMode;
		struct : property {
			ptr<Media::RectangleGeometry> get() { Media::RectangleGeometry* value; hrcheck(enc(&IUIElement_adaptor::Clip)->_get_Clip(&value)); return from_abi(value); }
			ptr<Media::RectangleGeometry> operator()() { return get(); }
			operator ptr<Media::RectangleGeometry> () { return get(); }
			ptr<Media::RectangleGeometry> operator->() { return get(); }
			void put(pptr<Media::RectangleGeometry> value) { hrcheck(enc(&IUIElement_adaptor::Clip)->_put_Clip(value)); }
			void operator=(pptr<Media::RectangleGeometry> value) { put(value); }
			void operator()(pptr<Media::RectangleGeometry> value) { put(value); }
		} Clip;
		struct : property {
			Foundation::Size get() { Foundation::Size value; hrcheck(enc(&IUIElement_adaptor::DesiredSize)->_get_DesiredSize(&value)); return value; }
			Foundation::Size operator()() { return get(); }
			operator Foundation::Size () { return get(); }
		} DesiredSize;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUIElement_adaptor::IsDoubleTapEnabled)->_get_IsDoubleTapEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IUIElement_adaptor::IsDoubleTapEnabled)->_put_IsDoubleTapEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsDoubleTapEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUIElement_adaptor::IsHitTestVisible)->_get_IsHitTestVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IUIElement_adaptor::IsHitTestVisible)->_put_IsHitTestVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsHitTestVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUIElement_adaptor::IsHoldingEnabled)->_get_IsHoldingEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IUIElement_adaptor::IsHoldingEnabled)->_put_IsHoldingEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsHoldingEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUIElement_adaptor::IsRightTapEnabled)->_get_IsRightTapEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IUIElement_adaptor::IsRightTapEnabled)->_put_IsRightTapEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsRightTapEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUIElement_adaptor::IsTapEnabled)->_get_IsTapEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IUIElement_adaptor::IsTapEnabled)->_put_IsTapEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTapEnabled;
		struct : property {
			Input::ManipulationModes get() { Input::ManipulationModes value; hrcheck(enc(&IUIElement_adaptor::ManipulationMode)->_get_ManipulationMode(&value)); return value; }
			Input::ManipulationModes operator()() { return get(); }
			operator Input::ManipulationModes () { return get(); }
			void put(Input::ManipulationModes value) { hrcheck(enc(&IUIElement_adaptor::ManipulationMode)->_put_ManipulationMode(value)); }
			void operator=(Input::ManipulationModes value) { put(value); }
			void operator()(Input::ManipulationModes value) { put(value); }
		} ManipulationMode;
		struct : property {
			double get() { double value; hrcheck(enc(&IUIElement_adaptor::Opacity)->_get_Opacity(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IUIElement_adaptor::Opacity)->_put_Opacity(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Opacity;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Input::Pointer>>> get() { Foundation::Collections::IVectorView<Input::Pointer*>* value; hrcheck(enc(&IUIElement_adaptor::PointerCaptures)->_get_PointerCaptures(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Input::Pointer>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Input::Pointer>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Input::Pointer>>> operator->() { return get(); }
		} PointerCaptures;
		struct : property {
			ptr<Media::Projection> get() { Media::Projection* value; hrcheck(enc(&IUIElement_adaptor::Projection)->_get_Projection(&value)); return from_abi(value); }
			ptr<Media::Projection> operator()() { return get(); }
			operator ptr<Media::Projection> () { return get(); }
			ptr<Media::Projection> operator->() { return get(); }
			void put(pptr<Media::Projection> value) { hrcheck(enc(&IUIElement_adaptor::Projection)->_put_Projection(value)); }
			void operator=(pptr<Media::Projection> value) { put(value); }
			void operator()(pptr<Media::Projection> value) { put(value); }
		} Projection;
		struct : property {
			Foundation::Size get() { Foundation::Size value; hrcheck(enc(&IUIElement_adaptor::RenderSize)->_get_RenderSize(&value)); return value; }
			Foundation::Size operator()() { return get(); }
			operator Foundation::Size () { return get(); }
		} RenderSize;
		struct : property {
			ptr<Media::Transform> get() { Media::Transform* value; hrcheck(enc(&IUIElement_adaptor::RenderTransform)->_get_RenderTransform(&value)); return from_abi(value); }
			ptr<Media::Transform> operator()() { return get(); }
			operator ptr<Media::Transform> () { return get(); }
			ptr<Media::Transform> operator->() { return get(); }
			void put(pptr<Media::Transform> value) { hrcheck(enc(&IUIElement_adaptor::RenderTransform)->_put_RenderTransform(value)); }
			void operator=(pptr<Media::Transform> value) { put(value); }
			void operator()(pptr<Media::Transform> value) { put(value); }
		} RenderTransform;
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IUIElement_adaptor::RenderTransformOrigin)->_get_RenderTransformOrigin(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&IUIElement_adaptor::RenderTransformOrigin)->_put_RenderTransformOrigin(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} RenderTransformOrigin;
		struct : property {
			ptr<Media::Animation::TransitionCollection> get() { Media::Animation::TransitionCollection* value; hrcheck(enc(&IUIElement_adaptor::Transitions)->_get_Transitions(&value)); return from_abi(value); }
			ptr<Media::Animation::TransitionCollection> operator()() { return get(); }
			operator ptr<Media::Animation::TransitionCollection> () { return get(); }
			ptr<Media::Animation::TransitionCollection> operator->() { return get(); }
			void put(pptr<Media::Animation::TransitionCollection> value) { hrcheck(enc(&IUIElement_adaptor::Transitions)->_put_Transitions(value)); }
			void operator=(pptr<Media::Animation::TransitionCollection> value) { put(value); }
			void operator()(pptr<Media::Animation::TransitionCollection> value) { put(value); }
		} Transitions;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUIElement_adaptor::UseLayoutRounding)->_get_UseLayoutRounding(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IUIElement_adaptor::UseLayoutRounding)->_put_UseLayoutRounding(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} UseLayoutRounding;
		struct : property {
			Xaml::Visibility get() { Xaml::Visibility value; hrcheck(enc(&IUIElement_adaptor::Visibility)->_get_Visibility(&value)); return value; }
			Xaml::Visibility operator()() { return get(); }
			operator Xaml::Visibility () { return get(); }
			void put(Xaml::Visibility value) { hrcheck(enc(&IUIElement_adaptor::Visibility)->_put_Visibility(value)); }
			void operator=(Xaml::Visibility value) { put(value); }
			void operator()(Xaml::Visibility value) { put(value); }
		} Visibility;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::DoubleTappedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::DoubleTapped)->_add_DoubleTapped(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::DoubleTapped)->_remove_DoubleTapped(token)); }
		} DoubleTapped;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<DragEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::DragEnter)->_add_DragEnter(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::DragEnter)->_remove_DragEnter(token)); }
		} DragEnter;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<DragEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::DragLeave)->_add_DragLeave(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::DragLeave)->_remove_DragLeave(token)); }
		} DragLeave;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<DragEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::DragOver)->_add_DragOver(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::DragOver)->_remove_DragOver(token)); }
		} DragOver;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<DragEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::Drop)->_add_Drop(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::Drop)->_remove_Drop(token)); }
		} Drop;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::GotFocus)->_add_GotFocus(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::GotFocus)->_remove_GotFocus(token)); }
		} GotFocus;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::HoldingEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::Holding)->_add_Holding(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::Holding)->_remove_Holding(token)); }
		} Holding;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::KeyEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::KeyDown)->_add_KeyDown(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::KeyDown)->_remove_KeyDown(token)); }
		} KeyDown;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::KeyEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::KeyUp)->_add_KeyUp(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::KeyUp)->_remove_KeyUp(token)); }
		} KeyUp;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::LostFocus)->_add_LostFocus(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::LostFocus)->_remove_LostFocus(token)); }
		} LostFocus;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::ManipulationCompletedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::ManipulationCompleted)->_add_ManipulationCompleted(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::ManipulationCompleted)->_remove_ManipulationCompleted(token)); }
		} ManipulationCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::ManipulationDeltaEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::ManipulationDelta)->_add_ManipulationDelta(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::ManipulationDelta)->_remove_ManipulationDelta(token)); }
		} ManipulationDelta;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::ManipulationInertiaStartingEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::ManipulationInertiaStarting)->_add_ManipulationInertiaStarting(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::ManipulationInertiaStarting)->_remove_ManipulationInertiaStarting(token)); }
		} ManipulationInertiaStarting;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::ManipulationStartedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::ManipulationStarted)->_add_ManipulationStarted(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::ManipulationStarted)->_remove_ManipulationStarted(token)); }
		} ManipulationStarted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::ManipulationStartingEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::ManipulationStarting)->_add_ManipulationStarting(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::ManipulationStarting)->_remove_ManipulationStarting(token)); }
		} ManipulationStarting;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::PointerEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::PointerCanceled)->_add_PointerCanceled(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::PointerCanceled)->_remove_PointerCanceled(token)); }
		} PointerCanceled;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::PointerEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::PointerCaptureLost)->_add_PointerCaptureLost(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::PointerCaptureLost)->_remove_PointerCaptureLost(token)); }
		} PointerCaptureLost;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::PointerEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::PointerEntered)->_add_PointerEntered(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::PointerEntered)->_remove_PointerEntered(token)); }
		} PointerEntered;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::PointerEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::PointerExited)->_add_PointerExited(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::PointerExited)->_remove_PointerExited(token)); }
		} PointerExited;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::PointerEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::PointerMoved)->_add_PointerMoved(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::PointerMoved)->_remove_PointerMoved(token)); }
		} PointerMoved;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::PointerEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::PointerPressed)->_add_PointerPressed(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::PointerPressed)->_remove_PointerPressed(token)); }
		} PointerPressed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::PointerEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::PointerReleased)->_add_PointerReleased(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::PointerReleased)->_remove_PointerReleased(token)); }
		} PointerReleased;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::PointerEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::PointerWheelChanged)->_add_PointerWheelChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::PointerWheelChanged)->_remove_PointerWheelChanged(token)); }
		} PointerWheelChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::RightTappedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::RightTapped)->_add_RightTapped(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::RightTapped)->_remove_RightTapped(token)); }
		} RightTapped;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::TappedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement_adaptor::Tapped)->_add_Tapped(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement_adaptor::Tapped)->_remove_Tapped(token)); }
		} Tapped;
	};
	void Measure(const Foundation::Size& availableSize) { hrcheck(X::get()->_Measure(availableSize)); }
	void Arrange(const Foundation::Rect& finalRect) { hrcheck(X::get()->_Arrange(finalRect)); }
	bool CapturePointer(pptr<Input::Pointer> value) { bool returnValue; hrcheck(X::get()->_CapturePointer(value, &returnValue)); return returnValue; }
	void ReleasePointerCapture(pptr<Input::Pointer> value) { hrcheck(X::get()->_ReleasePointerCapture(value)); }
	void ReleasePointerCaptures() { hrcheck(X::get()->_ReleasePointerCaptures()); }
	void AddHandler(pptr<RoutedEvent> routedEvent, object_ref handler, bool handledEventsToo) { hrcheck(X::get()->_AddHandler(routedEvent, handler, handledEventsToo)); }
	void RemoveHandler(pptr<RoutedEvent> routedEvent, object_ref handler) { hrcheck(X::get()->_RemoveHandler(routedEvent, handler)); }
	ptr<Media::GeneralTransform> TransformToVisual(pptr<UIElement> visual) { Media::GeneralTransform* returnValue; hrcheck(X::get()->_TransformToVisual(visual, &returnValue)); return from_abi(returnValue); }
	void InvalidateMeasure() { hrcheck(X::get()->_InvalidateMeasure()); }
	void InvalidateArrange() { hrcheck(X::get()->_InvalidateArrange()); }
	void UpdateLayout() { hrcheck(X::get()->_UpdateLayout()); }
	IUIElement_adaptor() {}
};
template<typename X> struct adapt<IUIElement, X> : Windows::UI::Xaml::IUIElement_adaptor<X> { typedef adapt IUIElement; };
struct IUIElement : IUIElement_raw, generate<IUIElement> {};

// IUIElementOverrides
struct IUIElementOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnCreateAutomationPeer(Automation::Peers::AutomationPeer* *returnValue) = 0;
	virtual STDMETHODIMP _OnDisconnectVisualChildren() = 0;
	virtual STDMETHODIMP _FindSubElementsForTouchTargeting(Foundation::Point point, Foundation::Rect boundingRect, Foundation::Collections::IIterable<Foundation::Collections::IIterable<Foundation::Point>*>* *returnValue) = 0;
};
template<typename X> struct IUIElementOverrides_adaptor : X {
	ptr<Automation::Peers::AutomationPeer> OnCreateAutomationPeer() { Automation::Peers::AutomationPeer* returnValue; hrcheck(X::get()->_OnCreateAutomationPeer(&returnValue)); return from_abi(returnValue); }
	void OnDisconnectVisualChildren() { hrcheck(X::get()->_OnDisconnectVisualChildren()); }
	ptr<Foundation::Collections::IIterable<ptr<Foundation::Collections::IIterable<Foundation::Point>>>> FindSubElementsForTouchTargeting(const Foundation::Point& point, const Foundation::Rect& boundingRect) { Foundation::Collections::IIterable<Foundation::Collections::IIterable<Foundation::Point>*>* returnValue; hrcheck(X::get()->_FindSubElementsForTouchTargeting(point, boundingRect, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IUIElementOverrides, X> : Windows::UI::Xaml::IUIElementOverrides_adaptor<X> { typedef adapt IUIElementOverrides; };
template<typename X> struct IUIElementOverrides_unadaptor : X {
	STDMETHODIMP _OnCreateAutomationPeer(Automation::Peers::AutomationPeer* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->OnCreateAutomationPeer()); }); }
	STDMETHODIMP _OnDisconnectVisualChildren() { return hrtry([&, this] { X::get()->OnDisconnectVisualChildren(); }); }
	STDMETHODIMP _FindSubElementsForTouchTargeting(Foundation::Point point, Foundation::Rect boundingRect, Foundation::Collections::IIterable<Foundation::Collections::IIterable<Foundation::Point>*>* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->FindSubElementsForTouchTargeting(point, boundingRect)); }); }
};
template<typename X> struct unadapt<IUIElementOverrides, X> : Windows::UI::Xaml::IUIElementOverrides_unadaptor<X> {};
struct IUIElementOverrides : IUIElementOverrides_raw, generate<IUIElementOverrides> {};

// IUIElementStatics
struct IUIElementStatics : IInspectable {
	virtual STDMETHODIMP _get_KeyDownEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_KeyUpEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_PointerEnteredEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_PointerPressedEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_PointerMovedEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_PointerReleasedEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_PointerExitedEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_PointerCaptureLostEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_PointerCanceledEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_PointerWheelChangedEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_TappedEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_DoubleTappedEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_HoldingEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_RightTappedEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_ManipulationStartingEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_ManipulationInertiaStartingEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_ManipulationStartedEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_ManipulationDeltaEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_ManipulationCompletedEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_DragEnterEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_DragLeaveEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_DragOverEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_DropEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_AllowDropProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OpacityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ClipProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RenderTransformProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ProjectionProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RenderTransformOriginProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsHitTestVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VisibilityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_UseLayoutRoundingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TransitionsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CacheModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsTapEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsDoubleTapEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsRightTapEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsHoldingEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ManipulationModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PointerCapturesProperty(DependencyProperty* *value);
};

// IUIElementFactory
struct IUIElementFactory : IInspectable, generate<IUIElementFactory> {};

// IUIElement2
struct IUIElement2_raw : IInspectable {
	virtual STDMETHODIMP _get_CompositeMode(Media::ElementCompositeMode *value);
	virtual STDMETHODIMP _put_CompositeMode(Media::ElementCompositeMode value);
	virtual STDMETHODIMP _CancelDirectManipulations(bool *returnValue);
};
template<typename X> struct IUIElement2_adaptor : X {
	union {
		struct : property {
			Media::ElementCompositeMode get() { Media::ElementCompositeMode value; hrcheck(enc(&IUIElement2_adaptor::CompositeMode)->_get_CompositeMode(&value)); return value; }
			Media::ElementCompositeMode operator()() { return get(); }
			operator Media::ElementCompositeMode () { return get(); }
			void put(Media::ElementCompositeMode value) { hrcheck(enc(&IUIElement2_adaptor::CompositeMode)->_put_CompositeMode(value)); }
			void operator=(Media::ElementCompositeMode value) { put(value); }
			void operator()(Media::ElementCompositeMode value) { put(value); }
		} CompositeMode;
	};
	bool CancelDirectManipulations() { bool returnValue; hrcheck(X::get()->_CancelDirectManipulations(&returnValue)); return returnValue; }
	IUIElement2_adaptor() {}
};
template<typename X> struct adapt<IUIElement2, X> : Windows::UI::Xaml::IUIElement2_adaptor<X> { typedef adapt IUIElement2; };
struct IUIElement2 : IUIElement2_raw, generate<IUIElement2> {};

// IUIElementStatics2
struct IUIElementStatics2 : IInspectable {
	virtual STDMETHODIMP _get_CompositeModeProperty(DependencyProperty* *value);
};

// IUIElement3
struct IUIElement3_raw : IInspectable {
	virtual STDMETHODIMP _get_Transform3D(Media::Media3D::Transform3D* *value);
	virtual STDMETHODIMP _put_Transform3D(Media::Media3D::Transform3D* value);
	virtual STDMETHODIMP _get_CanDrag(bool *value);
	virtual STDMETHODIMP _put_CanDrag(bool value);
	virtual STDMETHODIMP _add_DragStarting(Foundation::TypedEventHandler<UIElement*, DragStartingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DragStarting(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DropCompleted(Foundation::TypedEventHandler<UIElement*, DropCompletedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DropCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _StartDragAsync(UI::Input::PointerPoint* pointerPoint, Foundation::IAsyncOperation<ApplicationModel::DataTransfer::DataPackageOperation>* *returnValue);
};
template<typename X> struct IUIElement3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUIElement3_adaptor::CanDrag)->_get_CanDrag(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IUIElement3_adaptor::CanDrag)->_put_CanDrag(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} CanDrag;
		struct : property {
			ptr<Media::Media3D::Transform3D> get() { Media::Media3D::Transform3D* value; hrcheck(enc(&IUIElement3_adaptor::Transform3D)->_get_Transform3D(&value)); return from_abi(value); }
			ptr<Media::Media3D::Transform3D> operator()() { return get(); }
			operator ptr<Media::Media3D::Transform3D> () { return get(); }
			ptr<Media::Media3D::Transform3D> operator->() { return get(); }
			void put(pptr<Media::Media3D::Transform3D> value) { hrcheck(enc(&IUIElement3_adaptor::Transform3D)->_put_Transform3D(value)); }
			void operator=(pptr<Media::Media3D::Transform3D> value) { put(value); }
			void operator()(pptr<Media::Media3D::Transform3D> value) { put(value); }
		} Transform3D;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UIElement>, ptr<DragStartingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement3_adaptor::DragStarting)->_add_DragStarting(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement3_adaptor::DragStarting)->_remove_DragStarting(token)); }
		} DragStarting;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UIElement>, ptr<DropCompletedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement3_adaptor::DropCompleted)->_add_DropCompleted(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement3_adaptor::DropCompleted)->_remove_DropCompleted(token)); }
		} DropCompleted;
	};
	ptr<Foundation::IAsyncOperation<ApplicationModel::DataTransfer::DataPackageOperation>> StartDragAsync(pptr<UI::Input::PointerPoint> pointerPoint) { Foundation::IAsyncOperation<ApplicationModel::DataTransfer::DataPackageOperation>* returnValue; hrcheck(X::get()->_StartDragAsync(pointerPoint, &returnValue)); return from_abi(returnValue); }
	IUIElement3_adaptor() {}
};
template<typename X> struct adapt<IUIElement3, X> : Windows::UI::Xaml::IUIElement3_adaptor<X> { typedef adapt IUIElement3; };
struct IUIElement3 : IUIElement3_raw, generate<IUIElement3> {};

// IUIElementStatics3
struct IUIElementStatics3 : IInspectable {
	virtual STDMETHODIMP _get_Transform3DProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CanDragProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _TryStartDirectManipulation(Input::Pointer* value, bool *returnValue);
};

// IUIElement4
struct IUIElement4_raw : IInspectable {
	virtual STDMETHODIMP _get_ContextFlyout(Controls::Primitives::FlyoutBase* *value);
	virtual STDMETHODIMP _put_ContextFlyout(Controls::Primitives::FlyoutBase* value);
	virtual STDMETHODIMP _get_ExitDisplayModeOnAccessKeyInvoked(bool *value);
	virtual STDMETHODIMP _put_ExitDisplayModeOnAccessKeyInvoked(bool value);
	virtual STDMETHODIMP _get_IsAccessKeyScope(bool *value);
	virtual STDMETHODIMP _put_IsAccessKeyScope(bool value);
	virtual STDMETHODIMP _get_AccessKeyScopeOwner(DependencyObject* *value);
	virtual STDMETHODIMP _put_AccessKeyScopeOwner(DependencyObject* value);
	virtual STDMETHODIMP _get_AccessKey(HSTRING *value);
	virtual STDMETHODIMP _put_AccessKey(HSTRING value);
	virtual STDMETHODIMP _add_ContextRequested(Foundation::TypedEventHandler<UIElement*, Input::ContextRequestedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ContextRequested(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ContextCanceled(Foundation::TypedEventHandler<UIElement*, RoutedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ContextCanceled(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_AccessKeyDisplayRequested(Foundation::TypedEventHandler<UIElement*, Input::AccessKeyDisplayRequestedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_AccessKeyDisplayRequested(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_AccessKeyDisplayDismissed(Foundation::TypedEventHandler<UIElement*, Input::AccessKeyDisplayDismissedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_AccessKeyDisplayDismissed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_AccessKeyInvoked(Foundation::TypedEventHandler<UIElement*, Input::AccessKeyInvokedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_AccessKeyInvoked(Foundation::EventRegistrationToken token);
};
template<typename X> struct IUIElement4_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUIElement4_adaptor::AccessKey)->_get_AccessKey(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IUIElement4_adaptor::AccessKey)->_put_AccessKey(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} AccessKey;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IUIElement4_adaptor::AccessKeyScopeOwner)->_get_AccessKeyScopeOwner(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IUIElement4_adaptor::AccessKeyScopeOwner)->_put_AccessKeyScopeOwner(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} AccessKeyScopeOwner;
		struct : property {
			ptr<Controls::Primitives::FlyoutBase> get() { Controls::Primitives::FlyoutBase* value; hrcheck(enc(&IUIElement4_adaptor::ContextFlyout)->_get_ContextFlyout(&value)); return from_abi(value); }
			ptr<Controls::Primitives::FlyoutBase> operator()() { return get(); }
			operator ptr<Controls::Primitives::FlyoutBase> () { return get(); }
			ptr<Controls::Primitives::FlyoutBase> operator->() { return get(); }
			void put(pptr<Controls::Primitives::FlyoutBase> value) { hrcheck(enc(&IUIElement4_adaptor::ContextFlyout)->_put_ContextFlyout(value)); }
			void operator=(pptr<Controls::Primitives::FlyoutBase> value) { put(value); }
			void operator()(pptr<Controls::Primitives::FlyoutBase> value) { put(value); }
		} ContextFlyout;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUIElement4_adaptor::ExitDisplayModeOnAccessKeyInvoked)->_get_ExitDisplayModeOnAccessKeyInvoked(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IUIElement4_adaptor::ExitDisplayModeOnAccessKeyInvoked)->_put_ExitDisplayModeOnAccessKeyInvoked(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ExitDisplayModeOnAccessKeyInvoked;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUIElement4_adaptor::IsAccessKeyScope)->_get_IsAccessKeyScope(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IUIElement4_adaptor::IsAccessKeyScope)->_put_IsAccessKeyScope(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsAccessKeyScope;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UIElement>, ptr<Input::AccessKeyDisplayDismissedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement4_adaptor::AccessKeyDisplayDismissed)->_add_AccessKeyDisplayDismissed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement4_adaptor::AccessKeyDisplayDismissed)->_remove_AccessKeyDisplayDismissed(token)); }
		} AccessKeyDisplayDismissed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UIElement>, ptr<Input::AccessKeyDisplayRequestedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement4_adaptor::AccessKeyDisplayRequested)->_add_AccessKeyDisplayRequested(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement4_adaptor::AccessKeyDisplayRequested)->_remove_AccessKeyDisplayRequested(token)); }
		} AccessKeyDisplayRequested;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UIElement>, ptr<Input::AccessKeyInvokedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement4_adaptor::AccessKeyInvoked)->_add_AccessKeyInvoked(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement4_adaptor::AccessKeyInvoked)->_remove_AccessKeyInvoked(token)); }
		} AccessKeyInvoked;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UIElement>, ptr<RoutedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement4_adaptor::ContextCanceled)->_add_ContextCanceled(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement4_adaptor::ContextCanceled)->_remove_ContextCanceled(token)); }
		} ContextCanceled;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UIElement>, ptr<Input::ContextRequestedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement4_adaptor::ContextRequested)->_add_ContextRequested(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement4_adaptor::ContextRequested)->_remove_ContextRequested(token)); }
		} ContextRequested;
	};
	IUIElement4_adaptor() {}
};
template<typename X> struct adapt<IUIElement4, X> : Windows::UI::Xaml::IUIElement4_adaptor<X> { typedef adapt IUIElement4; };
struct IUIElement4 : IUIElement4_raw, generate<IUIElement4> {};

// IUIElementStatics4
struct IUIElementStatics4 : IInspectable {
	virtual STDMETHODIMP _get_ContextFlyoutProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ExitDisplayModeOnAccessKeyInvokedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsAccessKeyScopeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AccessKeyScopeOwnerProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AccessKeyProperty(DependencyProperty* *value);
};

// IUIElement5
struct IUIElement5_raw : IInspectable {
	virtual STDMETHODIMP _get_Lights(Foundation::Collections::IVector<Media::XamlLight*>* *value);
	virtual STDMETHODIMP _get_KeyTipPlacementMode(Input::KeyTipPlacementMode *value);
	virtual STDMETHODIMP _put_KeyTipPlacementMode(Input::KeyTipPlacementMode value);
	virtual STDMETHODIMP _get_KeyTipHorizontalOffset(double *value);
	virtual STDMETHODIMP _put_KeyTipHorizontalOffset(double value);
	virtual STDMETHODIMP _get_KeyTipVerticalOffset(double *value);
	virtual STDMETHODIMP _put_KeyTipVerticalOffset(double value);
	virtual STDMETHODIMP _get_XYFocusKeyboardNavigation(Input::XYFocusKeyboardNavigationMode *value);
	virtual STDMETHODIMP _put_XYFocusKeyboardNavigation(Input::XYFocusKeyboardNavigationMode value);
	virtual STDMETHODIMP _get_XYFocusUpNavigationStrategy(Input::XYFocusNavigationStrategy *value);
	virtual STDMETHODIMP _put_XYFocusUpNavigationStrategy(Input::XYFocusNavigationStrategy value);
	virtual STDMETHODIMP _get_XYFocusDownNavigationStrategy(Input::XYFocusNavigationStrategy *value);
	virtual STDMETHODIMP _put_XYFocusDownNavigationStrategy(Input::XYFocusNavigationStrategy value);
	virtual STDMETHODIMP _get_XYFocusLeftNavigationStrategy(Input::XYFocusNavigationStrategy *value);
	virtual STDMETHODIMP _put_XYFocusLeftNavigationStrategy(Input::XYFocusNavigationStrategy value);
	virtual STDMETHODIMP _get_XYFocusRightNavigationStrategy(Input::XYFocusNavigationStrategy *value);
	virtual STDMETHODIMP _put_XYFocusRightNavigationStrategy(Input::XYFocusNavigationStrategy value);
	virtual STDMETHODIMP _get_HighContrastAdjustment(ElementHighContrastAdjustment *value);
	virtual STDMETHODIMP _put_HighContrastAdjustment(ElementHighContrastAdjustment value);
	virtual STDMETHODIMP _get_TabFocusNavigation(Input::KeyboardNavigationMode *value);
	virtual STDMETHODIMP _put_TabFocusNavigation(Input::KeyboardNavigationMode value);
	virtual STDMETHODIMP _add_GettingFocus(Foundation::TypedEventHandler<UIElement*, Input::GettingFocusEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_GettingFocus(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_LosingFocus(Foundation::TypedEventHandler<UIElement*, Input::LosingFocusEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_LosingFocus(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_NoFocusCandidateFound(Foundation::TypedEventHandler<UIElement*, Input::NoFocusCandidateFoundEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_NoFocusCandidateFound(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _StartBringIntoView();
	virtual STDMETHODIMP _StartBringIntoViewWithOptions(BringIntoViewOptions* options);
};
template<typename X> struct IUIElement5_adaptor : X {
	union {
		struct : property {
			ElementHighContrastAdjustment get() { ElementHighContrastAdjustment value; hrcheck(enc(&IUIElement5_adaptor::HighContrastAdjustment)->_get_HighContrastAdjustment(&value)); return value; }
			ElementHighContrastAdjustment operator()() { return get(); }
			operator ElementHighContrastAdjustment () { return get(); }
			void put(ElementHighContrastAdjustment value) { hrcheck(enc(&IUIElement5_adaptor::HighContrastAdjustment)->_put_HighContrastAdjustment(value)); }
			void operator=(ElementHighContrastAdjustment value) { put(value); }
			void operator()(ElementHighContrastAdjustment value) { put(value); }
		} HighContrastAdjustment;
		struct : property {
			double get() { double value; hrcheck(enc(&IUIElement5_adaptor::KeyTipHorizontalOffset)->_get_KeyTipHorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IUIElement5_adaptor::KeyTipHorizontalOffset)->_put_KeyTipHorizontalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} KeyTipHorizontalOffset;
		struct : property {
			Input::KeyTipPlacementMode get() { Input::KeyTipPlacementMode value; hrcheck(enc(&IUIElement5_adaptor::KeyTipPlacementMode)->_get_KeyTipPlacementMode(&value)); return value; }
			Input::KeyTipPlacementMode operator()() { return get(); }
			operator Input::KeyTipPlacementMode () { return get(); }
			void put(Input::KeyTipPlacementMode value) { hrcheck(enc(&IUIElement5_adaptor::KeyTipPlacementMode)->_put_KeyTipPlacementMode(value)); }
			void operator=(Input::KeyTipPlacementMode value) { put(value); }
			void operator()(Input::KeyTipPlacementMode value) { put(value); }
		} KeyTipPlacementMode;
		struct : property {
			double get() { double value; hrcheck(enc(&IUIElement5_adaptor::KeyTipVerticalOffset)->_get_KeyTipVerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IUIElement5_adaptor::KeyTipVerticalOffset)->_put_KeyTipVerticalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} KeyTipVerticalOffset;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Media::XamlLight>>> get() { Foundation::Collections::IVector<Media::XamlLight*>* value; hrcheck(enc(&IUIElement5_adaptor::Lights)->_get_Lights(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Media::XamlLight>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Media::XamlLight>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Media::XamlLight>>> operator->() { return get(); }
		} Lights;
		struct : property {
			Input::KeyboardNavigationMode get() { Input::KeyboardNavigationMode value; hrcheck(enc(&IUIElement5_adaptor::TabFocusNavigation)->_get_TabFocusNavigation(&value)); return value; }
			Input::KeyboardNavigationMode operator()() { return get(); }
			operator Input::KeyboardNavigationMode () { return get(); }
			void put(Input::KeyboardNavigationMode value) { hrcheck(enc(&IUIElement5_adaptor::TabFocusNavigation)->_put_TabFocusNavigation(value)); }
			void operator=(Input::KeyboardNavigationMode value) { put(value); }
			void operator()(Input::KeyboardNavigationMode value) { put(value); }
		} TabFocusNavigation;
		struct : property {
			Input::XYFocusNavigationStrategy get() { Input::XYFocusNavigationStrategy value; hrcheck(enc(&IUIElement5_adaptor::XYFocusDownNavigationStrategy)->_get_XYFocusDownNavigationStrategy(&value)); return value; }
			Input::XYFocusNavigationStrategy operator()() { return get(); }
			operator Input::XYFocusNavigationStrategy () { return get(); }
			void put(Input::XYFocusNavigationStrategy value) { hrcheck(enc(&IUIElement5_adaptor::XYFocusDownNavigationStrategy)->_put_XYFocusDownNavigationStrategy(value)); }
			void operator=(Input::XYFocusNavigationStrategy value) { put(value); }
			void operator()(Input::XYFocusNavigationStrategy value) { put(value); }
		} XYFocusDownNavigationStrategy;
		struct : property {
			Input::XYFocusKeyboardNavigationMode get() { Input::XYFocusKeyboardNavigationMode value; hrcheck(enc(&IUIElement5_adaptor::XYFocusKeyboardNavigation)->_get_XYFocusKeyboardNavigation(&value)); return value; }
			Input::XYFocusKeyboardNavigationMode operator()() { return get(); }
			operator Input::XYFocusKeyboardNavigationMode () { return get(); }
			void put(Input::XYFocusKeyboardNavigationMode value) { hrcheck(enc(&IUIElement5_adaptor::XYFocusKeyboardNavigation)->_put_XYFocusKeyboardNavigation(value)); }
			void operator=(Input::XYFocusKeyboardNavigationMode value) { put(value); }
			void operator()(Input::XYFocusKeyboardNavigationMode value) { put(value); }
		} XYFocusKeyboardNavigation;
		struct : property {
			Input::XYFocusNavigationStrategy get() { Input::XYFocusNavigationStrategy value; hrcheck(enc(&IUIElement5_adaptor::XYFocusLeftNavigationStrategy)->_get_XYFocusLeftNavigationStrategy(&value)); return value; }
			Input::XYFocusNavigationStrategy operator()() { return get(); }
			operator Input::XYFocusNavigationStrategy () { return get(); }
			void put(Input::XYFocusNavigationStrategy value) { hrcheck(enc(&IUIElement5_adaptor::XYFocusLeftNavigationStrategy)->_put_XYFocusLeftNavigationStrategy(value)); }
			void operator=(Input::XYFocusNavigationStrategy value) { put(value); }
			void operator()(Input::XYFocusNavigationStrategy value) { put(value); }
		} XYFocusLeftNavigationStrategy;
		struct : property {
			Input::XYFocusNavigationStrategy get() { Input::XYFocusNavigationStrategy value; hrcheck(enc(&IUIElement5_adaptor::XYFocusRightNavigationStrategy)->_get_XYFocusRightNavigationStrategy(&value)); return value; }
			Input::XYFocusNavigationStrategy operator()() { return get(); }
			operator Input::XYFocusNavigationStrategy () { return get(); }
			void put(Input::XYFocusNavigationStrategy value) { hrcheck(enc(&IUIElement5_adaptor::XYFocusRightNavigationStrategy)->_put_XYFocusRightNavigationStrategy(value)); }
			void operator=(Input::XYFocusNavigationStrategy value) { put(value); }
			void operator()(Input::XYFocusNavigationStrategy value) { put(value); }
		} XYFocusRightNavigationStrategy;
		struct : property {
			Input::XYFocusNavigationStrategy get() { Input::XYFocusNavigationStrategy value; hrcheck(enc(&IUIElement5_adaptor::XYFocusUpNavigationStrategy)->_get_XYFocusUpNavigationStrategy(&value)); return value; }
			Input::XYFocusNavigationStrategy operator()() { return get(); }
			operator Input::XYFocusNavigationStrategy () { return get(); }
			void put(Input::XYFocusNavigationStrategy value) { hrcheck(enc(&IUIElement5_adaptor::XYFocusUpNavigationStrategy)->_put_XYFocusUpNavigationStrategy(value)); }
			void operator=(Input::XYFocusNavigationStrategy value) { put(value); }
			void operator()(Input::XYFocusNavigationStrategy value) { put(value); }
		} XYFocusUpNavigationStrategy;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UIElement>, ptr<Input::GettingFocusEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement5_adaptor::GettingFocus)->_add_GettingFocus(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement5_adaptor::GettingFocus)->_remove_GettingFocus(token)); }
		} GettingFocus;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UIElement>, ptr<Input::LosingFocusEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement5_adaptor::LosingFocus)->_add_LosingFocus(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement5_adaptor::LosingFocus)->_remove_LosingFocus(token)); }
		} LosingFocus;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UIElement>, ptr<Input::NoFocusCandidateFoundEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement5_adaptor::NoFocusCandidateFound)->_add_NoFocusCandidateFound(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement5_adaptor::NoFocusCandidateFound)->_remove_NoFocusCandidateFound(token)); }
		} NoFocusCandidateFound;
	};
	void StartBringIntoView() { hrcheck(X::get()->_StartBringIntoView()); }
	void StartBringIntoView(pptr<BringIntoViewOptions> options) { hrcheck(X::get()->_StartBringIntoViewWithOptions(options)); }
	IUIElement5_adaptor() {}
};
template<typename X> struct adapt<IUIElement5, X> : Windows::UI::Xaml::IUIElement5_adaptor<X> { typedef adapt IUIElement5; };
struct IUIElement5 : IUIElement5_raw, generate<IUIElement5> {};

// IUIElementStatics5
struct IUIElementStatics5 : IInspectable {
	virtual STDMETHODIMP _get_LightsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_KeyTipPlacementModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_KeyTipHorizontalOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_KeyTipVerticalOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_XYFocusKeyboardNavigationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_XYFocusUpNavigationStrategyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_XYFocusDownNavigationStrategyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_XYFocusLeftNavigationStrategyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_XYFocusRightNavigationStrategyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HighContrastAdjustmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TabFocusNavigationProperty(DependencyProperty* *value);
};

// IUIElementStatics6
struct IUIElementStatics6 : IInspectable {
	virtual STDMETHODIMP _get_GettingFocusEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_LosingFocusEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_NoFocusCandidateFoundEvent(RoutedEvent* *value);
};

// IUIElement7
struct IUIElement7_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyboardAccelerators(Foundation::Collections::IVector<Input::KeyboardAccelerator*>* *value);
	virtual STDMETHODIMP _add_CharacterReceived(Foundation::TypedEventHandler<UIElement*, Input::CharacterReceivedRoutedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CharacterReceived(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ProcessKeyboardAccelerators(Foundation::TypedEventHandler<UIElement*, Input::ProcessKeyboardAcceleratorEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ProcessKeyboardAccelerators(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PreviewKeyDown(Input::KeyEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PreviewKeyDown(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PreviewKeyUp(Input::KeyEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PreviewKeyUp(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _TryInvokeKeyboardAccelerator(Input::ProcessKeyboardAcceleratorEventArgs* args);
};
template<typename X> struct IUIElement7_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Input::KeyboardAccelerator>>> get() { Foundation::Collections::IVector<Input::KeyboardAccelerator*>* value; hrcheck(enc(&IUIElement7_adaptor::KeyboardAccelerators)->_get_KeyboardAccelerators(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Input::KeyboardAccelerator>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Input::KeyboardAccelerator>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Input::KeyboardAccelerator>>> operator->() { return get(); }
		} KeyboardAccelerators;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UIElement>, ptr<Input::CharacterReceivedRoutedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement7_adaptor::CharacterReceived)->_add_CharacterReceived(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement7_adaptor::CharacterReceived)->_remove_CharacterReceived(token)); }
		} CharacterReceived;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::KeyEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement7_adaptor::PreviewKeyDown)->_add_PreviewKeyDown(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement7_adaptor::PreviewKeyDown)->_remove_PreviewKeyDown(token)); }
		} PreviewKeyDown;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Input::KeyEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement7_adaptor::PreviewKeyUp)->_add_PreviewKeyUp(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement7_adaptor::PreviewKeyUp)->_remove_PreviewKeyUp(token)); }
		} PreviewKeyUp;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UIElement>, ptr<Input::ProcessKeyboardAcceleratorEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement7_adaptor::ProcessKeyboardAccelerators)->_add_ProcessKeyboardAccelerators(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement7_adaptor::ProcessKeyboardAccelerators)->_remove_ProcessKeyboardAccelerators(token)); }
		} ProcessKeyboardAccelerators;
	};
	void TryInvokeKeyboardAccelerator(pptr<Input::ProcessKeyboardAcceleratorEventArgs> args) { hrcheck(X::get()->_TryInvokeKeyboardAccelerator(args)); }
	IUIElement7_adaptor() {}
};
template<typename X> struct adapt<IUIElement7, X> : Windows::UI::Xaml::IUIElement7_adaptor<X> { typedef adapt IUIElement7; };
struct IUIElement7 : IUIElement7_raw, generate<IUIElement7> {};

// IUIElementOverrides7
struct IUIElementOverrides7_raw : IInspectable {
	virtual STDMETHODIMP _GetChildrenInTabFocusOrder(Foundation::Collections::IIterable<DependencyObject*>* *returnValue) = 0;
	virtual STDMETHODIMP _OnProcessKeyboardAccelerators(Input::ProcessKeyboardAcceleratorEventArgs* args) = 0;
};
template<typename X> struct IUIElementOverrides7_adaptor : X {
	ptr<Foundation::Collections::IIterable<ptr<DependencyObject>>> GetChildrenInTabFocusOrder() { Foundation::Collections::IIterable<DependencyObject*>* returnValue; hrcheck(X::get()->_GetChildrenInTabFocusOrder(&returnValue)); return from_abi(returnValue); }
	void OnProcessKeyboardAccelerators(pptr<Input::ProcessKeyboardAcceleratorEventArgs> args) { hrcheck(X::get()->_OnProcessKeyboardAccelerators(args)); }
};
template<typename X> struct adapt<IUIElementOverrides7, X> : Windows::UI::Xaml::IUIElementOverrides7_adaptor<X> { typedef adapt IUIElementOverrides7; };
template<typename X> struct IUIElementOverrides7_unadaptor : X {
	STDMETHODIMP _GetChildrenInTabFocusOrder(Foundation::Collections::IIterable<DependencyObject*>* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetChildrenInTabFocusOrder()); }); }
	STDMETHODIMP _OnProcessKeyboardAccelerators(Input::ProcessKeyboardAcceleratorEventArgs* args) { return hrtry([&, this] { X::get()->OnProcessKeyboardAccelerators(args); }); }
};
template<typename X> struct unadapt<IUIElementOverrides7, X> : Windows::UI::Xaml::IUIElementOverrides7_unadaptor<X> {};
struct IUIElementOverrides7 : IUIElementOverrides7_raw, generate<IUIElementOverrides7> {};

// IUIElementStatics7
struct IUIElementStatics7 : IInspectable {
	virtual STDMETHODIMP _get_PreviewKeyDownEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_CharacterReceivedEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_PreviewKeyUpEvent(RoutedEvent* *value);
};

// IUIElement8
struct IUIElement8_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyTipTarget(DependencyObject* *value);
	virtual STDMETHODIMP _put_KeyTipTarget(DependencyObject* value);
	virtual STDMETHODIMP _get_KeyboardAcceleratorPlacementTarget(DependencyObject* *value);
	virtual STDMETHODIMP _put_KeyboardAcceleratorPlacementTarget(DependencyObject* value);
	virtual STDMETHODIMP _get_KeyboardAcceleratorPlacementMode(Input::KeyboardAcceleratorPlacementMode *value);
	virtual STDMETHODIMP _put_KeyboardAcceleratorPlacementMode(Input::KeyboardAcceleratorPlacementMode value);
	virtual STDMETHODIMP _add_BringIntoViewRequested(Foundation::TypedEventHandler<UIElement*, BringIntoViewRequestedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_BringIntoViewRequested(Foundation::EventRegistrationToken token);
};
template<typename X> struct IUIElement8_adaptor : X {
	union {
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IUIElement8_adaptor::KeyTipTarget)->_get_KeyTipTarget(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IUIElement8_adaptor::KeyTipTarget)->_put_KeyTipTarget(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} KeyTipTarget;
		struct : property {
			Input::KeyboardAcceleratorPlacementMode get() { Input::KeyboardAcceleratorPlacementMode value; hrcheck(enc(&IUIElement8_adaptor::KeyboardAcceleratorPlacementMode)->_get_KeyboardAcceleratorPlacementMode(&value)); return value; }
			Input::KeyboardAcceleratorPlacementMode operator()() { return get(); }
			operator Input::KeyboardAcceleratorPlacementMode () { return get(); }
			void put(Input::KeyboardAcceleratorPlacementMode value) { hrcheck(enc(&IUIElement8_adaptor::KeyboardAcceleratorPlacementMode)->_put_KeyboardAcceleratorPlacementMode(value)); }
			void operator=(Input::KeyboardAcceleratorPlacementMode value) { put(value); }
			void operator()(Input::KeyboardAcceleratorPlacementMode value) { put(value); }
		} KeyboardAcceleratorPlacementMode;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IUIElement8_adaptor::KeyboardAcceleratorPlacementTarget)->_get_KeyboardAcceleratorPlacementTarget(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IUIElement8_adaptor::KeyboardAcceleratorPlacementTarget)->_put_KeyboardAcceleratorPlacementTarget(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} KeyboardAcceleratorPlacementTarget;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UIElement>, ptr<BringIntoViewRequestedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUIElement8_adaptor::BringIntoViewRequested)->_add_BringIntoViewRequested(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUIElement8_adaptor::BringIntoViewRequested)->_remove_BringIntoViewRequested(token)); }
		} BringIntoViewRequested;
	};
	IUIElement8_adaptor() {}
};
template<typename X> struct adapt<IUIElement8, X> : Windows::UI::Xaml::IUIElement8_adaptor<X> { typedef adapt IUIElement8; };
struct IUIElement8 : IUIElement8_raw, generate<IUIElement8> {};

// IUIElementOverrides8
struct IUIElementOverrides8_raw : IInspectable {
	virtual STDMETHODIMP _OnKeyboardAcceleratorInvoked(Input::KeyboardAcceleratorInvokedEventArgs* args) = 0;
	virtual STDMETHODIMP _OnBringIntoViewRequested(BringIntoViewRequestedEventArgs* e) = 0;
};
template<typename X> struct IUIElementOverrides8_adaptor : X {
	void OnKeyboardAcceleratorInvoked(pptr<Input::KeyboardAcceleratorInvokedEventArgs> args) { hrcheck(X::get()->_OnKeyboardAcceleratorInvoked(args)); }
	void OnBringIntoViewRequested(pptr<BringIntoViewRequestedEventArgs> e) { hrcheck(X::get()->_OnBringIntoViewRequested(e)); }
};
template<typename X> struct adapt<IUIElementOverrides8, X> : Windows::UI::Xaml::IUIElementOverrides8_adaptor<X> { typedef adapt IUIElementOverrides8; };
template<typename X> struct IUIElementOverrides8_unadaptor : X {
	STDMETHODIMP _OnKeyboardAcceleratorInvoked(Input::KeyboardAcceleratorInvokedEventArgs* args) { return hrtry([&, this] { X::get()->OnKeyboardAcceleratorInvoked(args); }); }
	STDMETHODIMP _OnBringIntoViewRequested(BringIntoViewRequestedEventArgs* e) { return hrtry([&, this] { X::get()->OnBringIntoViewRequested(e); }); }
};
template<typename X> struct unadapt<IUIElementOverrides8, X> : Windows::UI::Xaml::IUIElementOverrides8_unadaptor<X> {};
struct IUIElementOverrides8 : IUIElementOverrides8_raw, generate<IUIElementOverrides8> {};

// IUIElementStatics8
struct IUIElementStatics8 : IInspectable {
	virtual STDMETHODIMP _get_BringIntoViewRequestedEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_ContextRequestedEvent(RoutedEvent* *value);
	virtual STDMETHODIMP _get_KeyTipTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_KeyboardAcceleratorPlacementTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_KeyboardAcceleratorPlacementModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _RegisterAsScrollPort(UIElement* element);
};

// UIElement
template<typename> struct UIElement_statics {
	static struct _AllowDropProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_AllowDropProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AllowDropProperty;
	static struct _CacheModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_CacheModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CacheModeProperty;
	static struct _ClipProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_ClipProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ClipProperty;
	static struct _DoubleTappedEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_DoubleTappedEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} DoubleTappedEvent;
	static struct _DragEnterEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_DragEnterEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} DragEnterEvent;
	static struct _DragLeaveEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_DragLeaveEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} DragLeaveEvent;
	static struct _DragOverEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_DragOverEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} DragOverEvent;
	static struct _DropEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_DropEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} DropEvent;
	static struct _HoldingEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_HoldingEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} HoldingEvent;
	static struct _IsDoubleTapEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_IsDoubleTapEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsDoubleTapEnabledProperty;
	static struct _IsHitTestVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_IsHitTestVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsHitTestVisibleProperty;
	static struct _IsHoldingEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_IsHoldingEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsHoldingEnabledProperty;
	static struct _IsRightTapEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_IsRightTapEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsRightTapEnabledProperty;
	static struct _IsTapEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_IsTapEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTapEnabledProperty;
	static struct _KeyDownEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_KeyDownEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} KeyDownEvent;
	static struct _KeyUpEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_KeyUpEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} KeyUpEvent;
	static struct _ManipulationCompletedEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_ManipulationCompletedEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} ManipulationCompletedEvent;
	static struct _ManipulationDeltaEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_ManipulationDeltaEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} ManipulationDeltaEvent;
	static struct _ManipulationInertiaStartingEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_ManipulationInertiaStartingEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} ManipulationInertiaStartingEvent;
	static struct _ManipulationModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_ManipulationModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ManipulationModeProperty;
	static struct _ManipulationStartedEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_ManipulationStartedEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} ManipulationStartedEvent;
	static struct _ManipulationStartingEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_ManipulationStartingEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} ManipulationStartingEvent;
	static struct _OpacityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_OpacityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OpacityProperty;
	static struct _PointerCanceledEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_PointerCanceledEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} PointerCanceledEvent;
	static struct _PointerCaptureLostEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_PointerCaptureLostEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} PointerCaptureLostEvent;
	static struct _PointerCapturesProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_PointerCapturesProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PointerCapturesProperty;
	static struct _PointerEnteredEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_PointerEnteredEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} PointerEnteredEvent;
	static struct _PointerExitedEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_PointerExitedEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} PointerExitedEvent;
	static struct _PointerMovedEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_PointerMovedEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} PointerMovedEvent;
	static struct _PointerPressedEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_PointerPressedEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} PointerPressedEvent;
	static struct _PointerReleasedEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_PointerReleasedEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} PointerReleasedEvent;
	static struct _PointerWheelChangedEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_PointerWheelChangedEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} PointerWheelChangedEvent;
	static struct _ProjectionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_ProjectionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ProjectionProperty;
	static struct _RenderTransformOriginProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_RenderTransformOriginProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RenderTransformOriginProperty;
	static struct _RenderTransformProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_RenderTransformProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RenderTransformProperty;
	static struct _RightTappedEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_RightTappedEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} RightTappedEvent;
	static struct _TappedEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_TappedEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} TappedEvent;
	static struct _TransitionsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_TransitionsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TransitionsProperty;
	static struct _UseLayoutRoundingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_UseLayoutRoundingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} UseLayoutRoundingProperty;
	static struct _VisibilityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics>()->_get_VisibilityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VisibilityProperty;
	static struct _CompositeModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics2>()->_get_CompositeModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CompositeModeProperty;
	static struct _CanDragProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics3>()->_get_CanDragProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CanDragProperty;
	static struct _Transform3DProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics3>()->_get_Transform3DProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} Transform3DProperty;
	static struct _AccessKeyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics4>()->_get_AccessKeyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AccessKeyProperty;
	static struct _AccessKeyScopeOwnerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics4>()->_get_AccessKeyScopeOwnerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AccessKeyScopeOwnerProperty;
	static struct _ContextFlyoutProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics4>()->_get_ContextFlyoutProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContextFlyoutProperty;
	static struct _ExitDisplayModeOnAccessKeyInvokedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics4>()->_get_ExitDisplayModeOnAccessKeyInvokedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ExitDisplayModeOnAccessKeyInvokedProperty;
	static struct _IsAccessKeyScopeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics4>()->_get_IsAccessKeyScopeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsAccessKeyScopeProperty;
	static struct _HighContrastAdjustmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics5>()->_get_HighContrastAdjustmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HighContrastAdjustmentProperty;
	static struct _KeyTipHorizontalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics5>()->_get_KeyTipHorizontalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeyTipHorizontalOffsetProperty;
	static struct _KeyTipPlacementModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics5>()->_get_KeyTipPlacementModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeyTipPlacementModeProperty;
	static struct _KeyTipVerticalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics5>()->_get_KeyTipVerticalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeyTipVerticalOffsetProperty;
	static struct _LightsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics5>()->_get_LightsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LightsProperty;
	static struct _TabFocusNavigationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics5>()->_get_TabFocusNavigationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TabFocusNavigationProperty;
	static struct _XYFocusDownNavigationStrategyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics5>()->_get_XYFocusDownNavigationStrategyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} XYFocusDownNavigationStrategyProperty;
	static struct _XYFocusKeyboardNavigationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics5>()->_get_XYFocusKeyboardNavigationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} XYFocusKeyboardNavigationProperty;
	static struct _XYFocusLeftNavigationStrategyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics5>()->_get_XYFocusLeftNavigationStrategyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} XYFocusLeftNavigationStrategyProperty;
	static struct _XYFocusRightNavigationStrategyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics5>()->_get_XYFocusRightNavigationStrategyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} XYFocusRightNavigationStrategyProperty;
	static struct _XYFocusUpNavigationStrategyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics5>()->_get_XYFocusUpNavigationStrategyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} XYFocusUpNavigationStrategyProperty;
	static struct _GettingFocusEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics6>()->_get_GettingFocusEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} GettingFocusEvent;
	static struct _LosingFocusEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics6>()->_get_LosingFocusEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} LosingFocusEvent;
	static struct _NoFocusCandidateFoundEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics6>()->_get_NoFocusCandidateFoundEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} NoFocusCandidateFoundEvent;
	static struct _CharacterReceivedEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics7>()->_get_CharacterReceivedEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} CharacterReceivedEvent;
	static struct _PreviewKeyDownEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics7>()->_get_PreviewKeyDownEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} PreviewKeyDownEvent;
	static struct _PreviewKeyUpEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics7>()->_get_PreviewKeyUpEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} PreviewKeyUpEvent;
	static struct _BringIntoViewRequestedEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics8>()->_get_BringIntoViewRequestedEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} BringIntoViewRequestedEvent;
	static struct _ContextRequestedEvent : property {
		ptr<RoutedEvent> get() { RoutedEvent* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics8>()->_get_ContextRequestedEvent(&value)); return from_abi(value); }
		ptr<RoutedEvent> operator()() { return get(); }
		operator ptr<RoutedEvent> () { return get(); }
		ptr<RoutedEvent> operator->() { return get(); }
	} ContextRequestedEvent;
	static struct _KeyTipTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics8>()->_get_KeyTipTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeyTipTargetProperty;
	static struct _KeyboardAcceleratorPlacementModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics8>()->_get_KeyboardAcceleratorPlacementModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeyboardAcceleratorPlacementModeProperty;
	static struct _KeyboardAcceleratorPlacementTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UIElement, IUIElementStatics8>()->_get_KeyboardAcceleratorPlacementTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeyboardAcceleratorPlacementTargetProperty;
	static void RegisterAsScrollPort(pptr<UIElement> element) { hrcheck(get_activation_factory<UIElement, IUIElementStatics8>()->_RegisterAsScrollPort(element)); }
	static bool TryStartDirectManipulation(pptr<Input::Pointer> value) { bool returnValue; hrcheck(get_activation_factory<UIElement, IUIElementStatics3>()->_TryStartDirectManipulation(value, &returnValue)); return returnValue; }
};
template<typename X> typename UIElement_statics<X>::_AllowDropProperty UIElement_statics<X>::AllowDropProperty;
template<typename X> typename UIElement_statics<X>::_CacheModeProperty UIElement_statics<X>::CacheModeProperty;
template<typename X> typename UIElement_statics<X>::_ClipProperty UIElement_statics<X>::ClipProperty;
template<typename X> typename UIElement_statics<X>::_DoubleTappedEvent UIElement_statics<X>::DoubleTappedEvent;
template<typename X> typename UIElement_statics<X>::_DragEnterEvent UIElement_statics<X>::DragEnterEvent;
template<typename X> typename UIElement_statics<X>::_DragLeaveEvent UIElement_statics<X>::DragLeaveEvent;
template<typename X> typename UIElement_statics<X>::_DragOverEvent UIElement_statics<X>::DragOverEvent;
template<typename X> typename UIElement_statics<X>::_DropEvent UIElement_statics<X>::DropEvent;
template<typename X> typename UIElement_statics<X>::_HoldingEvent UIElement_statics<X>::HoldingEvent;
template<typename X> typename UIElement_statics<X>::_IsDoubleTapEnabledProperty UIElement_statics<X>::IsDoubleTapEnabledProperty;
template<typename X> typename UIElement_statics<X>::_IsHitTestVisibleProperty UIElement_statics<X>::IsHitTestVisibleProperty;
template<typename X> typename UIElement_statics<X>::_IsHoldingEnabledProperty UIElement_statics<X>::IsHoldingEnabledProperty;
template<typename X> typename UIElement_statics<X>::_IsRightTapEnabledProperty UIElement_statics<X>::IsRightTapEnabledProperty;
template<typename X> typename UIElement_statics<X>::_IsTapEnabledProperty UIElement_statics<X>::IsTapEnabledProperty;
template<typename X> typename UIElement_statics<X>::_KeyDownEvent UIElement_statics<X>::KeyDownEvent;
template<typename X> typename UIElement_statics<X>::_KeyUpEvent UIElement_statics<X>::KeyUpEvent;
template<typename X> typename UIElement_statics<X>::_ManipulationCompletedEvent UIElement_statics<X>::ManipulationCompletedEvent;
template<typename X> typename UIElement_statics<X>::_ManipulationDeltaEvent UIElement_statics<X>::ManipulationDeltaEvent;
template<typename X> typename UIElement_statics<X>::_ManipulationInertiaStartingEvent UIElement_statics<X>::ManipulationInertiaStartingEvent;
template<typename X> typename UIElement_statics<X>::_ManipulationModeProperty UIElement_statics<X>::ManipulationModeProperty;
template<typename X> typename UIElement_statics<X>::_ManipulationStartedEvent UIElement_statics<X>::ManipulationStartedEvent;
template<typename X> typename UIElement_statics<X>::_ManipulationStartingEvent UIElement_statics<X>::ManipulationStartingEvent;
template<typename X> typename UIElement_statics<X>::_OpacityProperty UIElement_statics<X>::OpacityProperty;
template<typename X> typename UIElement_statics<X>::_PointerCanceledEvent UIElement_statics<X>::PointerCanceledEvent;
template<typename X> typename UIElement_statics<X>::_PointerCaptureLostEvent UIElement_statics<X>::PointerCaptureLostEvent;
template<typename X> typename UIElement_statics<X>::_PointerCapturesProperty UIElement_statics<X>::PointerCapturesProperty;
template<typename X> typename UIElement_statics<X>::_PointerEnteredEvent UIElement_statics<X>::PointerEnteredEvent;
template<typename X> typename UIElement_statics<X>::_PointerExitedEvent UIElement_statics<X>::PointerExitedEvent;
template<typename X> typename UIElement_statics<X>::_PointerMovedEvent UIElement_statics<X>::PointerMovedEvent;
template<typename X> typename UIElement_statics<X>::_PointerPressedEvent UIElement_statics<X>::PointerPressedEvent;
template<typename X> typename UIElement_statics<X>::_PointerReleasedEvent UIElement_statics<X>::PointerReleasedEvent;
template<typename X> typename UIElement_statics<X>::_PointerWheelChangedEvent UIElement_statics<X>::PointerWheelChangedEvent;
template<typename X> typename UIElement_statics<X>::_ProjectionProperty UIElement_statics<X>::ProjectionProperty;
template<typename X> typename UIElement_statics<X>::_RenderTransformOriginProperty UIElement_statics<X>::RenderTransformOriginProperty;
template<typename X> typename UIElement_statics<X>::_RenderTransformProperty UIElement_statics<X>::RenderTransformProperty;
template<typename X> typename UIElement_statics<X>::_RightTappedEvent UIElement_statics<X>::RightTappedEvent;
template<typename X> typename UIElement_statics<X>::_TappedEvent UIElement_statics<X>::TappedEvent;
template<typename X> typename UIElement_statics<X>::_TransitionsProperty UIElement_statics<X>::TransitionsProperty;
template<typename X> typename UIElement_statics<X>::_UseLayoutRoundingProperty UIElement_statics<X>::UseLayoutRoundingProperty;
template<typename X> typename UIElement_statics<X>::_VisibilityProperty UIElement_statics<X>::VisibilityProperty;
template<typename X> typename UIElement_statics<X>::_CompositeModeProperty UIElement_statics<X>::CompositeModeProperty;
template<typename X> typename UIElement_statics<X>::_CanDragProperty UIElement_statics<X>::CanDragProperty;
template<typename X> typename UIElement_statics<X>::_Transform3DProperty UIElement_statics<X>::Transform3DProperty;
template<typename X> typename UIElement_statics<X>::_AccessKeyProperty UIElement_statics<X>::AccessKeyProperty;
template<typename X> typename UIElement_statics<X>::_AccessKeyScopeOwnerProperty UIElement_statics<X>::AccessKeyScopeOwnerProperty;
template<typename X> typename UIElement_statics<X>::_ContextFlyoutProperty UIElement_statics<X>::ContextFlyoutProperty;
template<typename X> typename UIElement_statics<X>::_ExitDisplayModeOnAccessKeyInvokedProperty UIElement_statics<X>::ExitDisplayModeOnAccessKeyInvokedProperty;
template<typename X> typename UIElement_statics<X>::_IsAccessKeyScopeProperty UIElement_statics<X>::IsAccessKeyScopeProperty;
template<typename X> typename UIElement_statics<X>::_HighContrastAdjustmentProperty UIElement_statics<X>::HighContrastAdjustmentProperty;
template<typename X> typename UIElement_statics<X>::_KeyTipHorizontalOffsetProperty UIElement_statics<X>::KeyTipHorizontalOffsetProperty;
template<typename X> typename UIElement_statics<X>::_KeyTipPlacementModeProperty UIElement_statics<X>::KeyTipPlacementModeProperty;
template<typename X> typename UIElement_statics<X>::_KeyTipVerticalOffsetProperty UIElement_statics<X>::KeyTipVerticalOffsetProperty;
template<typename X> typename UIElement_statics<X>::_LightsProperty UIElement_statics<X>::LightsProperty;
template<typename X> typename UIElement_statics<X>::_TabFocusNavigationProperty UIElement_statics<X>::TabFocusNavigationProperty;
template<typename X> typename UIElement_statics<X>::_XYFocusDownNavigationStrategyProperty UIElement_statics<X>::XYFocusDownNavigationStrategyProperty;
template<typename X> typename UIElement_statics<X>::_XYFocusKeyboardNavigationProperty UIElement_statics<X>::XYFocusKeyboardNavigationProperty;
template<typename X> typename UIElement_statics<X>::_XYFocusLeftNavigationStrategyProperty UIElement_statics<X>::XYFocusLeftNavigationStrategyProperty;
template<typename X> typename UIElement_statics<X>::_XYFocusRightNavigationStrategyProperty UIElement_statics<X>::XYFocusRightNavigationStrategyProperty;
template<typename X> typename UIElement_statics<X>::_XYFocusUpNavigationStrategyProperty UIElement_statics<X>::XYFocusUpNavigationStrategyProperty;
template<typename X> typename UIElement_statics<X>::_GettingFocusEvent UIElement_statics<X>::GettingFocusEvent;
template<typename X> typename UIElement_statics<X>::_LosingFocusEvent UIElement_statics<X>::LosingFocusEvent;
template<typename X> typename UIElement_statics<X>::_NoFocusCandidateFoundEvent UIElement_statics<X>::NoFocusCandidateFoundEvent;
template<typename X> typename UIElement_statics<X>::_CharacterReceivedEvent UIElement_statics<X>::CharacterReceivedEvent;
template<typename X> typename UIElement_statics<X>::_PreviewKeyDownEvent UIElement_statics<X>::PreviewKeyDownEvent;
template<typename X> typename UIElement_statics<X>::_PreviewKeyUpEvent UIElement_statics<X>::PreviewKeyUpEvent;
template<typename X> typename UIElement_statics<X>::_BringIntoViewRequestedEvent UIElement_statics<X>::BringIntoViewRequestedEvent;
template<typename X> typename UIElement_statics<X>::_ContextRequestedEvent UIElement_statics<X>::ContextRequestedEvent;
template<typename X> typename UIElement_statics<X>::_KeyTipTargetProperty UIElement_statics<X>::KeyTipTargetProperty;
template<typename X> typename UIElement_statics<X>::_KeyboardAcceleratorPlacementModeProperty UIElement_statics<X>::KeyboardAcceleratorPlacementModeProperty;
template<typename X> typename UIElement_statics<X>::_KeyboardAcceleratorPlacementTargetProperty UIElement_statics<X>::KeyboardAcceleratorPlacementTargetProperty;

template<typename X> struct statics<UIElement, X> : X, Windows::UI::Xaml::UIElement_statics<void> {
	typedef typename X::root_type UIElement;
};
struct UIElement : generate<UIElement> {
	using IUIElement5::StartBringIntoView;
};

// IVisualState
struct IVisualState_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_Storyboard(Media::Animation::Storyboard* *value);
	virtual STDMETHODIMP _put_Storyboard(Media::Animation::Storyboard* value);
};
template<typename X> struct IVisualState_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVisualState_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			ptr<Media::Animation::Storyboard> get() { Media::Animation::Storyboard* value; hrcheck(enc(&IVisualState_adaptor::Storyboard)->_get_Storyboard(&value)); return from_abi(value); }
			ptr<Media::Animation::Storyboard> operator()() { return get(); }
			operator ptr<Media::Animation::Storyboard> () { return get(); }
			ptr<Media::Animation::Storyboard> operator->() { return get(); }
			void put(pptr<Media::Animation::Storyboard> value) { hrcheck(enc(&IVisualState_adaptor::Storyboard)->_put_Storyboard(value)); }
			void operator=(pptr<Media::Animation::Storyboard> value) { put(value); }
			void operator()(pptr<Media::Animation::Storyboard> value) { put(value); }
		} Storyboard;
	};
	IVisualState_adaptor() {}
};
template<typename X> struct adapt<IVisualState, X> : Windows::UI::Xaml::IVisualState_adaptor<X> { typedef adapt IVisualState; };
struct IVisualState : IVisualState_raw, generate<IVisualState> {};

// IVisualState2
struct IVisualState2_raw : IInspectable {
	virtual STDMETHODIMP _get_Setters(SetterBaseCollection* *value);
	virtual STDMETHODIMP _get_StateTriggers(Foundation::Collections::IVector<StateTriggerBase*>* *value);
};
template<typename X> struct IVisualState2_adaptor : X {
	union {
		struct : property {
			ptr<SetterBaseCollection> get() { SetterBaseCollection* value; hrcheck(enc(&IVisualState2_adaptor::Setters)->_get_Setters(&value)); return from_abi(value); }
			ptr<SetterBaseCollection> operator()() { return get(); }
			operator ptr<SetterBaseCollection> () { return get(); }
			ptr<SetterBaseCollection> operator->() { return get(); }
		} Setters;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<StateTriggerBase>>> get() { Foundation::Collections::IVector<StateTriggerBase*>* value; hrcheck(enc(&IVisualState2_adaptor::StateTriggers)->_get_StateTriggers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<StateTriggerBase>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<StateTriggerBase>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<StateTriggerBase>>> operator->() { return get(); }
		} StateTriggers;
	};
	IVisualState2_adaptor() {}
};
template<typename X> struct adapt<IVisualState2, X> : Windows::UI::Xaml::IVisualState2_adaptor<X> { typedef adapt IVisualState2; };
struct IVisualState2 : IVisualState2_raw, generate<IVisualState2> {};

// VisualState
template<typename X> struct statics<VisualState, X> : X {
	typedef typename X::root_type VisualState;
};
struct VisualState : generate<VisualState> {};

// IVisualStateGroup
struct IVisualStateGroup_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_Transitions(Foundation::Collections::IVector<VisualTransition*>* *value);
	virtual STDMETHODIMP _get_States(Foundation::Collections::IVector<VisualState*>* *value);
	virtual STDMETHODIMP _get_CurrentState(VisualState* *value);
	virtual STDMETHODIMP _add_CurrentStateChanged(VisualStateChangedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CurrentStateChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_CurrentStateChanging(VisualStateChangedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CurrentStateChanging(Foundation::EventRegistrationToken token);
};
template<typename X> struct IVisualStateGroup_adaptor : X {
	union {
		struct : property {
			ptr<VisualState> get() { VisualState* value; hrcheck(enc(&IVisualStateGroup_adaptor::CurrentState)->_get_CurrentState(&value)); return from_abi(value); }
			ptr<VisualState> operator()() { return get(); }
			operator ptr<VisualState> () { return get(); }
			ptr<VisualState> operator->() { return get(); }
		} CurrentState;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVisualStateGroup_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<VisualState>>> get() { Foundation::Collections::IVector<VisualState*>* value; hrcheck(enc(&IVisualStateGroup_adaptor::States)->_get_States(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<VisualState>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<VisualState>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<VisualState>>> operator->() { return get(); }
		} States;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<VisualTransition>>> get() { Foundation::Collections::IVector<VisualTransition*>* value; hrcheck(enc(&IVisualStateGroup_adaptor::Transitions)->_get_Transitions(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<VisualTransition>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<VisualTransition>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<VisualTransition>>> operator->() { return get(); }
		} Transitions;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<VisualStateChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IVisualStateGroup_adaptor::CurrentStateChanged)->_add_CurrentStateChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IVisualStateGroup_adaptor::CurrentStateChanged)->_remove_CurrentStateChanged(token)); }
		} CurrentStateChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<VisualStateChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IVisualStateGroup_adaptor::CurrentStateChanging)->_add_CurrentStateChanging(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IVisualStateGroup_adaptor::CurrentStateChanging)->_remove_CurrentStateChanging(token)); }
		} CurrentStateChanging;
	};
	IVisualStateGroup_adaptor() {}
};
template<typename X> struct adapt<IVisualStateGroup, X> : Windows::UI::Xaml::IVisualStateGroup_adaptor<X> { typedef adapt IVisualStateGroup; };
struct IVisualStateGroup : IVisualStateGroup_raw, generate<IVisualStateGroup> {};

// VisualStateGroup
template<typename X> struct statics<VisualStateGroup, X> : X {
	typedef typename X::root_type VisualStateGroup;
};
struct VisualStateGroup : generate<VisualStateGroup> {};

// IVisualTransition
struct IVisualTransition_raw : IInspectable {
	virtual STDMETHODIMP _get_GeneratedDuration(Duration *value);
	virtual STDMETHODIMP _put_GeneratedDuration(Duration value);
	virtual STDMETHODIMP _get_GeneratedEasingFunction(Media::Animation::EasingFunctionBase* *value);
	virtual STDMETHODIMP _put_GeneratedEasingFunction(Media::Animation::EasingFunctionBase* value);
	virtual STDMETHODIMP _get_To(HSTRING *value);
	virtual STDMETHODIMP _put_To(HSTRING value);
	virtual STDMETHODIMP _get_From(HSTRING *value);
	virtual STDMETHODIMP _put_From(HSTRING value);
	virtual STDMETHODIMP _get_Storyboard(Media::Animation::Storyboard* *value);
	virtual STDMETHODIMP _put_Storyboard(Media::Animation::Storyboard* value);
};
template<typename X> struct IVisualTransition_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVisualTransition_adaptor::From)->_get_From(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVisualTransition_adaptor::From)->_put_From(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} From;
		struct : property {
			Duration get() { Duration value; hrcheck(enc(&IVisualTransition_adaptor::GeneratedDuration)->_get_GeneratedDuration(&value)); return value; }
			Duration operator()() { return get(); }
			operator Duration () { return get(); }
			void put(const Duration& value) { hrcheck(enc(&IVisualTransition_adaptor::GeneratedDuration)->_put_GeneratedDuration(value)); }
			void operator=(const Duration& value) { put(value); }
			void operator()(const Duration& value) { put(value); }
		} GeneratedDuration;
		struct : property {
			ptr<Media::Animation::EasingFunctionBase> get() { Media::Animation::EasingFunctionBase* value; hrcheck(enc(&IVisualTransition_adaptor::GeneratedEasingFunction)->_get_GeneratedEasingFunction(&value)); return from_abi(value); }
			ptr<Media::Animation::EasingFunctionBase> operator()() { return get(); }
			operator ptr<Media::Animation::EasingFunctionBase> () { return get(); }
			ptr<Media::Animation::EasingFunctionBase> operator->() { return get(); }
			void put(pptr<Media::Animation::EasingFunctionBase> value) { hrcheck(enc(&IVisualTransition_adaptor::GeneratedEasingFunction)->_put_GeneratedEasingFunction(value)); }
			void operator=(pptr<Media::Animation::EasingFunctionBase> value) { put(value); }
			void operator()(pptr<Media::Animation::EasingFunctionBase> value) { put(value); }
		} GeneratedEasingFunction;
		struct : property {
			ptr<Media::Animation::Storyboard> get() { Media::Animation::Storyboard* value; hrcheck(enc(&IVisualTransition_adaptor::Storyboard)->_get_Storyboard(&value)); return from_abi(value); }
			ptr<Media::Animation::Storyboard> operator()() { return get(); }
			operator ptr<Media::Animation::Storyboard> () { return get(); }
			ptr<Media::Animation::Storyboard> operator->() { return get(); }
			void put(pptr<Media::Animation::Storyboard> value) { hrcheck(enc(&IVisualTransition_adaptor::Storyboard)->_put_Storyboard(value)); }
			void operator=(pptr<Media::Animation::Storyboard> value) { put(value); }
			void operator()(pptr<Media::Animation::Storyboard> value) { put(value); }
		} Storyboard;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVisualTransition_adaptor::To)->_get_To(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVisualTransition_adaptor::To)->_put_To(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} To;
	};
	IVisualTransition_adaptor() {}
};
template<typename X> struct adapt<IVisualTransition, X> : Windows::UI::Xaml::IVisualTransition_adaptor<X> { typedef adapt IVisualTransition; };
struct IVisualTransition : IVisualTransition_raw, generate<IVisualTransition> {};

// IVisualTransitionFactory
struct IVisualTransitionFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, VisualTransition* *instance);
};

// VisualTransition
template<typename> struct VisualTransition_statics {
	static VisualTransition *activate(object_ref outer, IInspectable* *inner) { VisualTransition *instance; hrcheck(get_activation_factory<VisualTransition, IVisualTransitionFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<VisualTransition, X> : X, Windows::UI::Xaml::VisualTransition_statics<void> {
	using Windows::UI::Xaml::VisualTransition_statics<void>::activate;
	typedef typename X::root_type VisualTransition;
};
struct VisualTransition : generate<VisualTransition> {};

// IAdaptiveTrigger
struct IAdaptiveTrigger_raw : IInspectable {
	virtual STDMETHODIMP _get_MinWindowWidth(double *value);
	virtual STDMETHODIMP _put_MinWindowWidth(double value);
	virtual STDMETHODIMP _get_MinWindowHeight(double *value);
	virtual STDMETHODIMP _put_MinWindowHeight(double value);
};
template<typename X> struct IAdaptiveTrigger_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IAdaptiveTrigger_adaptor::MinWindowHeight)->_get_MinWindowHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IAdaptiveTrigger_adaptor::MinWindowHeight)->_put_MinWindowHeight(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MinWindowHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IAdaptiveTrigger_adaptor::MinWindowWidth)->_get_MinWindowWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IAdaptiveTrigger_adaptor::MinWindowWidth)->_put_MinWindowWidth(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MinWindowWidth;
	};
	IAdaptiveTrigger_adaptor() {}
};
template<typename X> struct adapt<IAdaptiveTrigger, X> : Windows::UI::Xaml::IAdaptiveTrigger_adaptor<X> { typedef adapt IAdaptiveTrigger; };
struct IAdaptiveTrigger : IAdaptiveTrigger_raw, generate<IAdaptiveTrigger> {};

// IAdaptiveTriggerStatics
struct IAdaptiveTriggerStatics : IInspectable {
	virtual STDMETHODIMP _get_MinWindowWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinWindowHeightProperty(DependencyProperty* *value);
};

// IAdaptiveTriggerFactory
struct IAdaptiveTriggerFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, AdaptiveTrigger* *instance);
};

// AdaptiveTrigger
template<typename> struct AdaptiveTrigger_statics {
	static struct _MinWindowHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AdaptiveTrigger, IAdaptiveTriggerStatics>()->_get_MinWindowHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinWindowHeightProperty;
	static struct _MinWindowWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AdaptiveTrigger, IAdaptiveTriggerStatics>()->_get_MinWindowWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinWindowWidthProperty;
	static AdaptiveTrigger *activate(object_ref outer, IInspectable* *inner) { AdaptiveTrigger *instance; hrcheck(get_activation_factory<AdaptiveTrigger, IAdaptiveTriggerFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename AdaptiveTrigger_statics<X>::_MinWindowHeightProperty AdaptiveTrigger_statics<X>::MinWindowHeightProperty;
template<typename X> typename AdaptiveTrigger_statics<X>::_MinWindowWidthProperty AdaptiveTrigger_statics<X>::MinWindowWidthProperty;

template<typename X> struct statics<AdaptiveTrigger, X> : X, Windows::UI::Xaml::AdaptiveTrigger_statics<void> {
	using Windows::UI::Xaml::AdaptiveTrigger_statics<void>::activate;
	typedef typename X::root_type AdaptiveTrigger;
};
struct AdaptiveTrigger : generate<AdaptiveTrigger> {};

// IEventTrigger
struct IEventTrigger_raw : IInspectable {
	virtual STDMETHODIMP _get_RoutedEvent(Xaml::RoutedEvent* *value);
	virtual STDMETHODIMP _put_RoutedEvent(Xaml::RoutedEvent* value);
	virtual STDMETHODIMP _get_Actions(TriggerActionCollection* *value);
};
template<typename X> struct IEventTrigger_adaptor : X {
	union {
		struct : property {
			ptr<TriggerActionCollection> get() { TriggerActionCollection* value; hrcheck(enc(&IEventTrigger_adaptor::Actions)->_get_Actions(&value)); return from_abi(value); }
			ptr<TriggerActionCollection> operator()() { return get(); }
			operator ptr<TriggerActionCollection> () { return get(); }
			ptr<TriggerActionCollection> operator->() { return get(); }
		} Actions;
		struct : property {
			ptr<Xaml::RoutedEvent> get() { Xaml::RoutedEvent* value; hrcheck(enc(&IEventTrigger_adaptor::RoutedEvent)->_get_RoutedEvent(&value)); return from_abi(value); }
			ptr<Xaml::RoutedEvent> operator()() { return get(); }
			operator ptr<Xaml::RoutedEvent> () { return get(); }
			ptr<Xaml::RoutedEvent> operator->() { return get(); }
			void put(pptr<Xaml::RoutedEvent> value) { hrcheck(enc(&IEventTrigger_adaptor::RoutedEvent)->_put_RoutedEvent(value)); }
			void operator=(pptr<Xaml::RoutedEvent> value) { put(value); }
			void operator()(pptr<Xaml::RoutedEvent> value) { put(value); }
		} RoutedEvent;
	};
	IEventTrigger_adaptor() {}
};
template<typename X> struct adapt<IEventTrigger, X> : Windows::UI::Xaml::IEventTrigger_adaptor<X> { typedef adapt IEventTrigger; };
struct IEventTrigger : IEventTrigger_raw, generate<IEventTrigger> {};

// EventTrigger
template<typename X> struct statics<EventTrigger, X> : X {
	typedef typename X::root_type EventTrigger;
};
struct EventTrigger : generate<EventTrigger> {};

// IFrameworkElement
struct IFrameworkElement_raw : IInspectable {
	virtual STDMETHODIMP _get_Triggers(TriggerCollection* *value);
	virtual STDMETHODIMP _get_Resources(ResourceDictionary* *value);
	virtual STDMETHODIMP _put_Resources(ResourceDictionary* value);
	virtual STDMETHODIMP _get_Tag(IInspectable* *value);
	virtual STDMETHODIMP _put_Tag(IInspectable* value);
	virtual STDMETHODIMP _get_Language(HSTRING *value);
	virtual STDMETHODIMP _put_Language(HSTRING value);
	virtual STDMETHODIMP _get_ActualWidth(double *value);
	virtual STDMETHODIMP _get_ActualHeight(double *value);
	virtual STDMETHODIMP _get_Width(double *value);
	virtual STDMETHODIMP _put_Width(double value);
	virtual STDMETHODIMP _get_Height(double *value);
	virtual STDMETHODIMP _put_Height(double value);
	virtual STDMETHODIMP _get_MinWidth(double *value);
	virtual STDMETHODIMP _put_MinWidth(double value);
	virtual STDMETHODIMP _get_MaxWidth(double *value);
	virtual STDMETHODIMP _put_MaxWidth(double value);
	virtual STDMETHODIMP _get_MinHeight(double *value);
	virtual STDMETHODIMP _put_MinHeight(double value);
	virtual STDMETHODIMP _get_MaxHeight(double *value);
	virtual STDMETHODIMP _put_MaxHeight(double value);
	virtual STDMETHODIMP _get_HorizontalAlignment(Xaml::HorizontalAlignment *value);
	virtual STDMETHODIMP _put_HorizontalAlignment(Xaml::HorizontalAlignment value);
	virtual STDMETHODIMP _get_VerticalAlignment(Xaml::VerticalAlignment *value);
	virtual STDMETHODIMP _put_VerticalAlignment(Xaml::VerticalAlignment value);
	virtual STDMETHODIMP _get_Margin(Thickness *value);
	virtual STDMETHODIMP _put_Margin(Thickness value);
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _put_Name(HSTRING value);
	virtual STDMETHODIMP _get_BaseUri(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_DataContext(IInspectable* *value);
	virtual STDMETHODIMP _put_DataContext(IInspectable* value);
	virtual STDMETHODIMP _get_Style(Xaml::Style* *value);
	virtual STDMETHODIMP _put_Style(Xaml::Style* value);
	virtual STDMETHODIMP _get_Parent(DependencyObject* *value);
	virtual STDMETHODIMP _get_FlowDirection(Xaml::FlowDirection *value);
	virtual STDMETHODIMP _put_FlowDirection(Xaml::FlowDirection value);
	virtual STDMETHODIMP _add_Loaded(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Loaded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Unloaded(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Unloaded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_SizeChanged(SizeChangedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SizeChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_LayoutUpdated(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_LayoutUpdated(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _FindName(HSTRING name, IInspectable* *returnValue);
	virtual STDMETHODIMP _SetBinding(DependencyProperty* dp, Data::BindingBase* binding);
};
template<typename X> struct IFrameworkElement_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IFrameworkElement_adaptor::ActualHeight)->_get_ActualHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ActualHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IFrameworkElement_adaptor::ActualWidth)->_get_ActualWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ActualWidth;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IFrameworkElement_adaptor::BaseUri)->_get_BaseUri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} BaseUri;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IFrameworkElement_adaptor::DataContext)->_get_DataContext(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IFrameworkElement_adaptor::DataContext)->_put_DataContext(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} DataContext;
		struct : property {
			Xaml::FlowDirection get() { Xaml::FlowDirection value; hrcheck(enc(&IFrameworkElement_adaptor::FlowDirection)->_get_FlowDirection(&value)); return value; }
			Xaml::FlowDirection operator()() { return get(); }
			operator Xaml::FlowDirection () { return get(); }
			void put(Xaml::FlowDirection value) { hrcheck(enc(&IFrameworkElement_adaptor::FlowDirection)->_put_FlowDirection(value)); }
			void operator=(Xaml::FlowDirection value) { put(value); }
			void operator()(Xaml::FlowDirection value) { put(value); }
		} FlowDirection;
		struct : property {
			double get() { double value; hrcheck(enc(&IFrameworkElement_adaptor::Height)->_get_Height(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IFrameworkElement_adaptor::Height)->_put_Height(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Height;
		struct : property {
			Xaml::HorizontalAlignment get() { Xaml::HorizontalAlignment value; hrcheck(enc(&IFrameworkElement_adaptor::HorizontalAlignment)->_get_HorizontalAlignment(&value)); return value; }
			Xaml::HorizontalAlignment operator()() { return get(); }
			operator Xaml::HorizontalAlignment () { return get(); }
			void put(Xaml::HorizontalAlignment value) { hrcheck(enc(&IFrameworkElement_adaptor::HorizontalAlignment)->_put_HorizontalAlignment(value)); }
			void operator=(Xaml::HorizontalAlignment value) { put(value); }
			void operator()(Xaml::HorizontalAlignment value) { put(value); }
		} HorizontalAlignment;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IFrameworkElement_adaptor::Language)->_get_Language(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IFrameworkElement_adaptor::Language)->_put_Language(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Language;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IFrameworkElement_adaptor::Margin)->_get_Margin(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IFrameworkElement_adaptor::Margin)->_put_Margin(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} Margin;
		struct : property {
			double get() { double value; hrcheck(enc(&IFrameworkElement_adaptor::MaxHeight)->_get_MaxHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IFrameworkElement_adaptor::MaxHeight)->_put_MaxHeight(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MaxHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IFrameworkElement_adaptor::MaxWidth)->_get_MaxWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IFrameworkElement_adaptor::MaxWidth)->_put_MaxWidth(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MaxWidth;
		struct : property {
			double get() { double value; hrcheck(enc(&IFrameworkElement_adaptor::MinHeight)->_get_MinHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IFrameworkElement_adaptor::MinHeight)->_put_MinHeight(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MinHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IFrameworkElement_adaptor::MinWidth)->_get_MinWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IFrameworkElement_adaptor::MinWidth)->_put_MinWidth(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MinWidth;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IFrameworkElement_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IFrameworkElement_adaptor::Name)->_put_Name(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Name;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IFrameworkElement_adaptor::Parent)->_get_Parent(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
		} Parent;
		struct : property {
			ptr<ResourceDictionary> get() { ResourceDictionary* value; hrcheck(enc(&IFrameworkElement_adaptor::Resources)->_get_Resources(&value)); return from_abi(value); }
			ptr<ResourceDictionary> operator()() { return get(); }
			operator ptr<ResourceDictionary> () { return get(); }
			ptr<ResourceDictionary> operator->() { return get(); }
			void put(pptr<ResourceDictionary> value) { hrcheck(enc(&IFrameworkElement_adaptor::Resources)->_put_Resources(value)); }
			void operator=(pptr<ResourceDictionary> value) { put(value); }
			void operator()(pptr<ResourceDictionary> value) { put(value); }
		} Resources;
		struct : property {
			ptr<Xaml::Style> get() { Xaml::Style* value; hrcheck(enc(&IFrameworkElement_adaptor::Style)->_get_Style(&value)); return from_abi(value); }
			ptr<Xaml::Style> operator()() { return get(); }
			operator ptr<Xaml::Style> () { return get(); }
			ptr<Xaml::Style> operator->() { return get(); }
			void put(pptr<Xaml::Style> value) { hrcheck(enc(&IFrameworkElement_adaptor::Style)->_put_Style(value)); }
			void operator=(pptr<Xaml::Style> value) { put(value); }
			void operator()(pptr<Xaml::Style> value) { put(value); }
		} Style;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IFrameworkElement_adaptor::Tag)->_get_Tag(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IFrameworkElement_adaptor::Tag)->_put_Tag(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Tag;
		struct : property {
			ptr<TriggerCollection> get() { TriggerCollection* value; hrcheck(enc(&IFrameworkElement_adaptor::Triggers)->_get_Triggers(&value)); return from_abi(value); }
			ptr<TriggerCollection> operator()() { return get(); }
			operator ptr<TriggerCollection> () { return get(); }
			ptr<TriggerCollection> operator->() { return get(); }
		} Triggers;
		struct : property {
			Xaml::VerticalAlignment get() { Xaml::VerticalAlignment value; hrcheck(enc(&IFrameworkElement_adaptor::VerticalAlignment)->_get_VerticalAlignment(&value)); return value; }
			Xaml::VerticalAlignment operator()() { return get(); }
			operator Xaml::VerticalAlignment () { return get(); }
			void put(Xaml::VerticalAlignment value) { hrcheck(enc(&IFrameworkElement_adaptor::VerticalAlignment)->_put_VerticalAlignment(value)); }
			void operator=(Xaml::VerticalAlignment value) { put(value); }
			void operator()(Xaml::VerticalAlignment value) { put(value); }
		} VerticalAlignment;
		struct : property {
			double get() { double value; hrcheck(enc(&IFrameworkElement_adaptor::Width)->_get_Width(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IFrameworkElement_adaptor::Width)->_put_Width(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Width;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IFrameworkElement_adaptor::LayoutUpdated)->_add_LayoutUpdated(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IFrameworkElement_adaptor::LayoutUpdated)->_remove_LayoutUpdated(token)); }
		} LayoutUpdated;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IFrameworkElement_adaptor::Loaded)->_add_Loaded(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IFrameworkElement_adaptor::Loaded)->_remove_Loaded(token)); }
		} Loaded;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<SizeChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IFrameworkElement_adaptor::SizeChanged)->_add_SizeChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IFrameworkElement_adaptor::SizeChanged)->_remove_SizeChanged(token)); }
		} SizeChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IFrameworkElement_adaptor::Unloaded)->_add_Unloaded(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IFrameworkElement_adaptor::Unloaded)->_remove_Unloaded(token)); }
		} Unloaded;
	};
	object FindName(hstring_ref name) { IInspectable* returnValue; hrcheck(X::get()->_FindName(name, &returnValue)); return from_abi(returnValue); }
	void SetBinding(pptr<DependencyProperty> dp, pptr<Data::BindingBase> binding) { hrcheck(X::get()->_SetBinding(dp, binding)); }
	IFrameworkElement_adaptor() {}
};
template<typename X> struct adapt<IFrameworkElement, X> : Windows::UI::Xaml::IFrameworkElement_adaptor<X> { typedef adapt IFrameworkElement; };
struct IFrameworkElement : IFrameworkElement_raw, generate<IFrameworkElement> {};

// IFrameworkElementOverrides
struct IFrameworkElementOverrides_raw : IInspectable {
	virtual STDMETHODIMP _MeasureOverride(Foundation::Size availableSize, Foundation::Size *returnValue) = 0;
	virtual STDMETHODIMP _ArrangeOverride(Foundation::Size finalSize, Foundation::Size *returnValue) = 0;
	virtual STDMETHODIMP _OnApplyTemplate() = 0;
};
template<typename X> struct IFrameworkElementOverrides_adaptor : X {
	Foundation::Size MeasureOverride(const Foundation::Size& availableSize) { Foundation::Size returnValue; hrcheck(X::get()->_MeasureOverride(availableSize, &returnValue)); return returnValue; }
	Foundation::Size ArrangeOverride(const Foundation::Size& finalSize) { Foundation::Size returnValue; hrcheck(X::get()->_ArrangeOverride(finalSize, &returnValue)); return returnValue; }
	void OnApplyTemplate() { hrcheck(X::get()->_OnApplyTemplate()); }
};
template<typename X> struct adapt<IFrameworkElementOverrides, X> : Windows::UI::Xaml::IFrameworkElementOverrides_adaptor<X> { typedef adapt IFrameworkElementOverrides; };
template<typename X> struct IFrameworkElementOverrides_unadaptor : X {
	STDMETHODIMP _MeasureOverride(Foundation::Size availableSize, Foundation::Size *returnValue) { return hrtry([&, this] { *returnValue = X::get()->MeasureOverride(availableSize); }); }
	STDMETHODIMP _ArrangeOverride(Foundation::Size finalSize, Foundation::Size *returnValue) { return hrtry([&, this] { *returnValue = X::get()->ArrangeOverride(finalSize); }); }
	STDMETHODIMP _OnApplyTemplate() { return hrtry([&, this] { X::get()->OnApplyTemplate(); }); }
};
template<typename X> struct unadapt<IFrameworkElementOverrides, X> : Windows::UI::Xaml::IFrameworkElementOverrides_unadaptor<X> {};
struct IFrameworkElementOverrides : IFrameworkElementOverrides_raw, generate<IFrameworkElementOverrides> {};

// IFrameworkElementStatics
struct IFrameworkElementStatics : IInspectable {
	virtual STDMETHODIMP _get_TagProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_LanguageProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ActualWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ActualHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_WidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MarginProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_NameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DataContextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_StyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FlowDirectionProperty(DependencyProperty* *value);
};

// IFrameworkElementFactory
struct IFrameworkElementFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, FrameworkElement* *instance);
};

// IFrameworkElement2
struct IFrameworkElement2_raw : IInspectable {
	virtual STDMETHODIMP _get_RequestedTheme(ElementTheme *value);
	virtual STDMETHODIMP _put_RequestedTheme(ElementTheme value);
	virtual STDMETHODIMP _add_DataContextChanged(Foundation::TypedEventHandler<FrameworkElement*, DataContextChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DataContextChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _GetBindingExpression(DependencyProperty* dp, Data::BindingExpression* *returnValue);
};
template<typename X> struct IFrameworkElement2_adaptor : X {
	union {
		struct : property {
			ElementTheme get() { ElementTheme value; hrcheck(enc(&IFrameworkElement2_adaptor::RequestedTheme)->_get_RequestedTheme(&value)); return value; }
			ElementTheme operator()() { return get(); }
			operator ElementTheme () { return get(); }
			void put(ElementTheme value) { hrcheck(enc(&IFrameworkElement2_adaptor::RequestedTheme)->_put_RequestedTheme(value)); }
			void operator=(ElementTheme value) { put(value); }
			void operator()(ElementTheme value) { put(value); }
		} RequestedTheme;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<FrameworkElement>, ptr<DataContextChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IFrameworkElement2_adaptor::DataContextChanged)->_add_DataContextChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IFrameworkElement2_adaptor::DataContextChanged)->_remove_DataContextChanged(token)); }
		} DataContextChanged;
	};
	ptr<Data::BindingExpression> GetBindingExpression(pptr<DependencyProperty> dp) { Data::BindingExpression* returnValue; hrcheck(X::get()->_GetBindingExpression(dp, &returnValue)); return from_abi(returnValue); }
	IFrameworkElement2_adaptor() {}
};
template<typename X> struct adapt<IFrameworkElement2, X> : Windows::UI::Xaml::IFrameworkElement2_adaptor<X> { typedef adapt IFrameworkElement2; };
struct IFrameworkElement2 : IFrameworkElement2_raw, generate<IFrameworkElement2> {};

// IFrameworkElementOverrides2
struct IFrameworkElementOverrides2_raw : IInspectable {
	virtual STDMETHODIMP _GoToElementStateCore(HSTRING stateName, bool useTransitions, bool *returnValue) = 0;
};
template<typename X> struct IFrameworkElementOverrides2_adaptor : X {
	bool GoToElementStateCore(hstring_ref stateName, bool useTransitions) { bool returnValue; hrcheck(X::get()->_GoToElementStateCore(stateName, useTransitions, &returnValue)); return returnValue; }
};
template<typename X> struct adapt<IFrameworkElementOverrides2, X> : Windows::UI::Xaml::IFrameworkElementOverrides2_adaptor<X> { typedef adapt IFrameworkElementOverrides2; };
template<typename X> struct IFrameworkElementOverrides2_unadaptor : X {
	STDMETHODIMP _GoToElementStateCore(HSTRING stateName, bool useTransitions, bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->GoToElementStateCore(stateName, useTransitions); }); }
};
template<typename X> struct unadapt<IFrameworkElementOverrides2, X> : Windows::UI::Xaml::IFrameworkElementOverrides2_unadaptor<X> {};
struct IFrameworkElementOverrides2 : IFrameworkElementOverrides2_raw, generate<IFrameworkElementOverrides2> {};

// IFrameworkElementStatics2
struct IFrameworkElementStatics2 : IInspectable {
	virtual STDMETHODIMP _get_RequestedThemeProperty(DependencyProperty* *value);
};

// IFrameworkElement3
struct IFrameworkElement3_raw : IInspectable {
	virtual STDMETHODIMP _add_Loading(Foundation::TypedEventHandler<FrameworkElement*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Loading(Foundation::EventRegistrationToken token);
};
template<typename X> struct IFrameworkElement3_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<FrameworkElement>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IFrameworkElement3_adaptor::Loading)->_add_Loading(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IFrameworkElement3_adaptor::Loading)->_remove_Loading(token)); }
		} Loading;
	};
	IFrameworkElement3_adaptor() {}
};
template<typename X> struct adapt<IFrameworkElement3, X> : Windows::UI::Xaml::IFrameworkElement3_adaptor<X> { typedef adapt IFrameworkElement3; };
struct IFrameworkElement3 : IFrameworkElement3_raw, generate<IFrameworkElement3> {};

// IFrameworkElement4
struct IFrameworkElement4_raw : IInspectable {
	virtual STDMETHODIMP _get_AllowFocusOnInteraction(bool *value);
	virtual STDMETHODIMP _put_AllowFocusOnInteraction(bool value);
	virtual STDMETHODIMP _get_FocusVisualMargin(Thickness *value);
	virtual STDMETHODIMP _put_FocusVisualMargin(Thickness value);
	virtual STDMETHODIMP _get_FocusVisualSecondaryThickness(Thickness *value);
	virtual STDMETHODIMP _put_FocusVisualSecondaryThickness(Thickness value);
	virtual STDMETHODIMP _get_FocusVisualPrimaryThickness(Thickness *value);
	virtual STDMETHODIMP _put_FocusVisualPrimaryThickness(Thickness value);
	virtual STDMETHODIMP _get_FocusVisualSecondaryBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_FocusVisualSecondaryBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_FocusVisualPrimaryBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_FocusVisualPrimaryBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_AllowFocusWhenDisabled(bool *value);
	virtual STDMETHODIMP _put_AllowFocusWhenDisabled(bool value);
};
template<typename X> struct IFrameworkElement4_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFrameworkElement4_adaptor::AllowFocusOnInteraction)->_get_AllowFocusOnInteraction(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IFrameworkElement4_adaptor::AllowFocusOnInteraction)->_put_AllowFocusOnInteraction(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AllowFocusOnInteraction;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFrameworkElement4_adaptor::AllowFocusWhenDisabled)->_get_AllowFocusWhenDisabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IFrameworkElement4_adaptor::AllowFocusWhenDisabled)->_put_AllowFocusWhenDisabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AllowFocusWhenDisabled;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IFrameworkElement4_adaptor::FocusVisualMargin)->_get_FocusVisualMargin(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IFrameworkElement4_adaptor::FocusVisualMargin)->_put_FocusVisualMargin(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} FocusVisualMargin;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IFrameworkElement4_adaptor::FocusVisualPrimaryBrush)->_get_FocusVisualPrimaryBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IFrameworkElement4_adaptor::FocusVisualPrimaryBrush)->_put_FocusVisualPrimaryBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} FocusVisualPrimaryBrush;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IFrameworkElement4_adaptor::FocusVisualPrimaryThickness)->_get_FocusVisualPrimaryThickness(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IFrameworkElement4_adaptor::FocusVisualPrimaryThickness)->_put_FocusVisualPrimaryThickness(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} FocusVisualPrimaryThickness;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IFrameworkElement4_adaptor::FocusVisualSecondaryBrush)->_get_FocusVisualSecondaryBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IFrameworkElement4_adaptor::FocusVisualSecondaryBrush)->_put_FocusVisualSecondaryBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} FocusVisualSecondaryBrush;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IFrameworkElement4_adaptor::FocusVisualSecondaryThickness)->_get_FocusVisualSecondaryThickness(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IFrameworkElement4_adaptor::FocusVisualSecondaryThickness)->_put_FocusVisualSecondaryThickness(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} FocusVisualSecondaryThickness;
	};
	IFrameworkElement4_adaptor() {}
};
template<typename X> struct adapt<IFrameworkElement4, X> : Windows::UI::Xaml::IFrameworkElement4_adaptor<X> { typedef adapt IFrameworkElement4; };
struct IFrameworkElement4 : IFrameworkElement4_raw, generate<IFrameworkElement4> {};

// IFrameworkElementStatics4
struct IFrameworkElementStatics4 : IInspectable {
	virtual STDMETHODIMP _get_AllowFocusOnInteractionProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FocusVisualMarginProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FocusVisualSecondaryThicknessProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FocusVisualPrimaryThicknessProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FocusVisualSecondaryBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FocusVisualPrimaryBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AllowFocusWhenDisabledProperty(DependencyProperty* *value);
};

// IFrameworkElementStatics5
struct IFrameworkElementStatics5 : IInspectable {
	virtual STDMETHODIMP _DeferTree(DependencyObject* element);
};

// IFrameworkElement6
struct IFrameworkElement6_raw : IInspectable {
	virtual STDMETHODIMP _get_ActualTheme(ElementTheme *value);
	virtual STDMETHODIMP _add_ActualThemeChanged(Foundation::TypedEventHandler<FrameworkElement*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ActualThemeChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IFrameworkElement6_adaptor : X {
	union {
		struct : property {
			ElementTheme get() { ElementTheme value; hrcheck(enc(&IFrameworkElement6_adaptor::ActualTheme)->_get_ActualTheme(&value)); return value; }
			ElementTheme operator()() { return get(); }
			operator ElementTheme () { return get(); }
		} ActualTheme;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<FrameworkElement>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IFrameworkElement6_adaptor::ActualThemeChanged)->_add_ActualThemeChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IFrameworkElement6_adaptor::ActualThemeChanged)->_remove_ActualThemeChanged(token)); }
		} ActualThemeChanged;
	};
	IFrameworkElement6_adaptor() {}
};
template<typename X> struct adapt<IFrameworkElement6, X> : Windows::UI::Xaml::IFrameworkElement6_adaptor<X> { typedef adapt IFrameworkElement6; };
struct IFrameworkElement6 : IFrameworkElement6_raw, generate<IFrameworkElement6> {};

// IFrameworkElementStatics6
struct IFrameworkElementStatics6 : IInspectable {
	virtual STDMETHODIMP _get_ActualThemeProperty(DependencyProperty* *value);
};

// FrameworkElement
template<typename> struct FrameworkElement_statics {
	static struct _ActualHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_ActualHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ActualHeightProperty;
	static struct _ActualWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_ActualWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ActualWidthProperty;
	static struct _DataContextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_DataContextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DataContextProperty;
	static struct _FlowDirectionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_FlowDirectionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FlowDirectionProperty;
	static struct _HeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_HeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeightProperty;
	static struct _HorizontalAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_HorizontalAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalAlignmentProperty;
	static struct _LanguageProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_LanguageProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LanguageProperty;
	static struct _MarginProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_MarginProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MarginProperty;
	static struct _MaxHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_MaxHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxHeightProperty;
	static struct _MaxWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_MaxWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxWidthProperty;
	static struct _MinHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_MinHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinHeightProperty;
	static struct _MinWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_MinWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinWidthProperty;
	static struct _NameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_NameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} NameProperty;
	static struct _StyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_StyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StyleProperty;
	static struct _TagProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_TagProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TagProperty;
	static struct _VerticalAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_VerticalAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalAlignmentProperty;
	static struct _WidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics>()->_get_WidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} WidthProperty;
	static struct _RequestedThemeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics2>()->_get_RequestedThemeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RequestedThemeProperty;
	static struct _AllowFocusOnInteractionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics4>()->_get_AllowFocusOnInteractionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AllowFocusOnInteractionProperty;
	static struct _AllowFocusWhenDisabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics4>()->_get_AllowFocusWhenDisabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AllowFocusWhenDisabledProperty;
	static struct _FocusVisualMarginProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics4>()->_get_FocusVisualMarginProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FocusVisualMarginProperty;
	static struct _FocusVisualPrimaryBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics4>()->_get_FocusVisualPrimaryBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FocusVisualPrimaryBrushProperty;
	static struct _FocusVisualPrimaryThicknessProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics4>()->_get_FocusVisualPrimaryThicknessProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FocusVisualPrimaryThicknessProperty;
	static struct _FocusVisualSecondaryBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics4>()->_get_FocusVisualSecondaryBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FocusVisualSecondaryBrushProperty;
	static struct _FocusVisualSecondaryThicknessProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics4>()->_get_FocusVisualSecondaryThicknessProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FocusVisualSecondaryThicknessProperty;
	static struct _ActualThemeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics6>()->_get_ActualThemeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ActualThemeProperty;
	static void DeferTree(pptr<DependencyObject> element) { hrcheck(get_activation_factory<FrameworkElement, IFrameworkElementStatics5>()->_DeferTree(element)); }
};
template<typename X> typename FrameworkElement_statics<X>::_ActualHeightProperty FrameworkElement_statics<X>::ActualHeightProperty;
template<typename X> typename FrameworkElement_statics<X>::_ActualWidthProperty FrameworkElement_statics<X>::ActualWidthProperty;
template<typename X> typename FrameworkElement_statics<X>::_DataContextProperty FrameworkElement_statics<X>::DataContextProperty;
template<typename X> typename FrameworkElement_statics<X>::_FlowDirectionProperty FrameworkElement_statics<X>::FlowDirectionProperty;
template<typename X> typename FrameworkElement_statics<X>::_HeightProperty FrameworkElement_statics<X>::HeightProperty;
template<typename X> typename FrameworkElement_statics<X>::_HorizontalAlignmentProperty FrameworkElement_statics<X>::HorizontalAlignmentProperty;
template<typename X> typename FrameworkElement_statics<X>::_LanguageProperty FrameworkElement_statics<X>::LanguageProperty;
template<typename X> typename FrameworkElement_statics<X>::_MarginProperty FrameworkElement_statics<X>::MarginProperty;
template<typename X> typename FrameworkElement_statics<X>::_MaxHeightProperty FrameworkElement_statics<X>::MaxHeightProperty;
template<typename X> typename FrameworkElement_statics<X>::_MaxWidthProperty FrameworkElement_statics<X>::MaxWidthProperty;
template<typename X> typename FrameworkElement_statics<X>::_MinHeightProperty FrameworkElement_statics<X>::MinHeightProperty;
template<typename X> typename FrameworkElement_statics<X>::_MinWidthProperty FrameworkElement_statics<X>::MinWidthProperty;
template<typename X> typename FrameworkElement_statics<X>::_NameProperty FrameworkElement_statics<X>::NameProperty;
template<typename X> typename FrameworkElement_statics<X>::_StyleProperty FrameworkElement_statics<X>::StyleProperty;
template<typename X> typename FrameworkElement_statics<X>::_TagProperty FrameworkElement_statics<X>::TagProperty;
template<typename X> typename FrameworkElement_statics<X>::_VerticalAlignmentProperty FrameworkElement_statics<X>::VerticalAlignmentProperty;
template<typename X> typename FrameworkElement_statics<X>::_WidthProperty FrameworkElement_statics<X>::WidthProperty;
template<typename X> typename FrameworkElement_statics<X>::_RequestedThemeProperty FrameworkElement_statics<X>::RequestedThemeProperty;
template<typename X> typename FrameworkElement_statics<X>::_AllowFocusOnInteractionProperty FrameworkElement_statics<X>::AllowFocusOnInteractionProperty;
template<typename X> typename FrameworkElement_statics<X>::_AllowFocusWhenDisabledProperty FrameworkElement_statics<X>::AllowFocusWhenDisabledProperty;
template<typename X> typename FrameworkElement_statics<X>::_FocusVisualMarginProperty FrameworkElement_statics<X>::FocusVisualMarginProperty;
template<typename X> typename FrameworkElement_statics<X>::_FocusVisualPrimaryBrushProperty FrameworkElement_statics<X>::FocusVisualPrimaryBrushProperty;
template<typename X> typename FrameworkElement_statics<X>::_FocusVisualPrimaryThicknessProperty FrameworkElement_statics<X>::FocusVisualPrimaryThicknessProperty;
template<typename X> typename FrameworkElement_statics<X>::_FocusVisualSecondaryBrushProperty FrameworkElement_statics<X>::FocusVisualSecondaryBrushProperty;
template<typename X> typename FrameworkElement_statics<X>::_FocusVisualSecondaryThicknessProperty FrameworkElement_statics<X>::FocusVisualSecondaryThicknessProperty;
template<typename X> typename FrameworkElement_statics<X>::_ActualThemeProperty FrameworkElement_statics<X>::ActualThemeProperty;

template<typename X> struct statics<FrameworkElement, X> : X, Windows::UI::Xaml::FrameworkElement_statics<void> {
	typedef typename X::root_type FrameworkElement;
};
struct FrameworkElement : generate<FrameworkElement> {
	using IUIElement5::StartBringIntoView;
};

// IMediaFailedRoutedEventArgs
struct IMediaFailedRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ErrorTrace(HSTRING *value);
};
template<typename X> struct IMediaFailedRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMediaFailedRoutedEventArgs_adaptor::ErrorTrace)->_get_ErrorTrace(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ErrorTrace;
	};
	IMediaFailedRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IMediaFailedRoutedEventArgs, X> : Windows::UI::Xaml::IMediaFailedRoutedEventArgs_adaptor<X> { typedef adapt IMediaFailedRoutedEventArgs; };
struct IMediaFailedRoutedEventArgs : IMediaFailedRoutedEventArgs_raw, generate<IMediaFailedRoutedEventArgs> {};

// MediaFailedRoutedEventArgs
template<typename X> struct statics<MediaFailedRoutedEventArgs, X> : X {
	typedef typename X::root_type MediaFailedRoutedEventArgs;
};
struct MediaFailedRoutedEventArgs : generate<MediaFailedRoutedEventArgs> {};

// ISetter
struct ISetter_raw : IInspectable {
	virtual STDMETHODIMP _get_Property(DependencyProperty* *value);
	virtual STDMETHODIMP _put_Property(DependencyProperty* value);
	virtual STDMETHODIMP _get_Value(IInspectable* *value);
	virtual STDMETHODIMP _put_Value(IInspectable* value);
};
template<typename X> struct ISetter_adaptor : X {
	union {
		struct : property {
			ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(enc(&ISetter_adaptor::Property)->_get_Property(&value)); return from_abi(value); }
			ptr<DependencyProperty> operator()() { return get(); }
			operator ptr<DependencyProperty> () { return get(); }
			ptr<DependencyProperty> operator->() { return get(); }
			void put(pptr<DependencyProperty> value) { hrcheck(enc(&ISetter_adaptor::Property)->_put_Property(value)); }
			void operator=(pptr<DependencyProperty> value) { put(value); }
			void operator()(pptr<DependencyProperty> value) { put(value); }
		} Property;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ISetter_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&ISetter_adaptor::Value)->_put_Value(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Value;
	};
	ISetter_adaptor() {}
};
template<typename X> struct adapt<ISetter, X> : Windows::UI::Xaml::ISetter_adaptor<X> { typedef adapt ISetter; };
struct ISetter : ISetter_raw, generate<ISetter> {};

// ISetterFactory
struct ISetterFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(DependencyProperty* targetProperty, IInspectable* value, Setter* *instance);
};

// ISetter2
struct ISetter2_raw : IInspectable {
	virtual STDMETHODIMP _get_Target(TargetPropertyPath* *value);
	virtual STDMETHODIMP _put_Target(TargetPropertyPath* value);
};
template<typename X> struct ISetter2_adaptor : X {
	union {
		struct : property {
			ptr<TargetPropertyPath> get() { TargetPropertyPath* value; hrcheck(enc(&ISetter2_adaptor::Target)->_get_Target(&value)); return from_abi(value); }
			ptr<TargetPropertyPath> operator()() { return get(); }
			operator ptr<TargetPropertyPath> () { return get(); }
			ptr<TargetPropertyPath> operator->() { return get(); }
			void put(pptr<TargetPropertyPath> value) { hrcheck(enc(&ISetter2_adaptor::Target)->_put_Target(value)); }
			void operator=(pptr<TargetPropertyPath> value) { put(value); }
			void operator()(pptr<TargetPropertyPath> value) { put(value); }
		} Target;
	};
	ISetter2_adaptor() {}
};
template<typename X> struct adapt<ISetter2, X> : Windows::UI::Xaml::ISetter2_adaptor<X> { typedef adapt ISetter2; };
struct ISetter2 : ISetter2_raw, generate<ISetter2> {};

// Setter
template<typename> struct Setter_statics {
	static Setter *activate(pptr<DependencyProperty> targetProperty, object_ref value) { Setter *instance; hrcheck(get_activation_factory<Setter, ISetterFactory>()->_CreateInstance(targetProperty, value, &instance)); return instance; }
	static Setter *activate() { Setter *t; get_activation_factory<Setter>()->ActivateInstance((IInspectable**)&t); return t; }
};

template<typename X> struct statics<Setter, X> : X, Windows::UI::Xaml::Setter_statics<void> {
	using Windows::UI::Xaml::Setter_statics<void>::activate;
	typedef typename X::root_type Setter;
};
struct Setter : generate<Setter> {};

// IStateTrigger
struct IStateTrigger_raw : IInspectable {
	virtual STDMETHODIMP _get_IsActive(bool *value);
	virtual STDMETHODIMP _put_IsActive(bool value);
};
template<typename X> struct IStateTrigger_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStateTrigger_adaptor::IsActive)->_get_IsActive(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IStateTrigger_adaptor::IsActive)->_put_IsActive(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsActive;
	};
	IStateTrigger_adaptor() {}
};
template<typename X> struct adapt<IStateTrigger, X> : Windows::UI::Xaml::IStateTrigger_adaptor<X> { typedef adapt IStateTrigger; };
struct IStateTrigger : IStateTrigger_raw, generate<IStateTrigger> {};

// IStateTriggerStatics
struct IStateTriggerStatics : IInspectable {
	virtual STDMETHODIMP _get_IsActiveProperty(DependencyProperty* *value);
};

// StateTrigger
template<typename> struct StateTrigger_statics {
	static struct _IsActiveProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<StateTrigger, IStateTriggerStatics>()->_get_IsActiveProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsActiveProperty;
};
template<typename X> typename StateTrigger_statics<X>::_IsActiveProperty StateTrigger_statics<X>::IsActiveProperty;

template<typename X> struct statics<StateTrigger, X> : X, Windows::UI::Xaml::StateTrigger_statics<void> {
	typedef typename X::root_type StateTrigger;
};
struct StateTrigger : generate<StateTrigger> {};

// IGridLengthHelper
struct IGridLengthHelper : IInspectable, generate<IGridLengthHelper> {};

// IGridLengthHelperStatics
struct IGridLengthHelperStatics : IInspectable {
	virtual STDMETHODIMP _get_Auto(GridLength *value);
	virtual STDMETHODIMP _FromPixels(double pixels, GridLength *returnValue);
	virtual STDMETHODIMP _FromValueAndType(double value, GridUnitType type, GridLength *returnValue);
	virtual STDMETHODIMP _GetIsAbsolute(GridLength target, bool *value);
	virtual STDMETHODIMP _GetIsAuto(GridLength target, bool *value);
	virtual STDMETHODIMP _GetIsStar(GridLength target, bool *value);
	virtual STDMETHODIMP _Equals(GridLength target, GridLength value, bool *returnValue);
};

// GridLengthHelper
template<typename> struct GridLengthHelper_statics {
	static struct _Auto : property {
		GridLength get() { GridLength value; hrcheck(get_activation_factory<GridLengthHelper, IGridLengthHelperStatics>()->_get_Auto(&value)); return value; }
		GridLength operator()() { return get(); }
		operator GridLength () { return get(); }
	} Auto;
	static GridLength FromPixels(double pixels) { GridLength returnValue; hrcheck(get_activation_factory<GridLengthHelper, IGridLengthHelperStatics>()->_FromPixels(pixels, &returnValue)); return returnValue; }
	static GridLength FromValueAndType(double value, GridUnitType type) { GridLength returnValue; hrcheck(get_activation_factory<GridLengthHelper, IGridLengthHelperStatics>()->_FromValueAndType(value, type, &returnValue)); return returnValue; }
	static bool GetIsAbsolute(const GridLength& target) { bool value; hrcheck(get_activation_factory<GridLengthHelper, IGridLengthHelperStatics>()->_GetIsAbsolute(target, &value)); return value; }
	static bool GetIsAuto(const GridLength& target) { bool value; hrcheck(get_activation_factory<GridLengthHelper, IGridLengthHelperStatics>()->_GetIsAuto(target, &value)); return value; }
	static bool GetIsStar(const GridLength& target) { bool value; hrcheck(get_activation_factory<GridLengthHelper, IGridLengthHelperStatics>()->_GetIsStar(target, &value)); return value; }
	static bool Equals(const GridLength& target, const GridLength& value) { bool returnValue; hrcheck(get_activation_factory<GridLengthHelper, IGridLengthHelperStatics>()->_Equals(target, value, &returnValue)); return returnValue; }
};
template<typename X> typename GridLengthHelper_statics<X>::_Auto GridLengthHelper_statics<X>::Auto;

template<typename X> struct statics<GridLengthHelper, X> : X, Windows::UI::Xaml::GridLengthHelper_statics<void> {
	typedef typename X::root_type GridLengthHelper;
};
struct GridLengthHelper : generate<GridLengthHelper> {};

// StyleTypedPropertyAttribute
template<typename X> struct statics<StyleTypedPropertyAttribute, X> : X {
	typedef typename X::root_type StyleTypedPropertyAttribute;
};
struct StyleTypedPropertyAttribute : generate<StyleTypedPropertyAttribute> {};

// TemplateVisualStateAttribute
template<typename X> struct statics<TemplateVisualStateAttribute, X> : X {
	typedef typename X::root_type TemplateVisualStateAttribute;
};
struct TemplateVisualStateAttribute : generate<TemplateVisualStateAttribute> {};

// BindingFailedEventHandler
struct BindingFailedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, BindingFailedEventArgs* e) = 0;
};

// IBindingFailedEventArgs
struct IBindingFailedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Message(HSTRING *value);
};
template<typename X> struct IBindingFailedEventArgs_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IBindingFailedEventArgs_adaptor::Message)->_get_Message(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Message;
	};
	IBindingFailedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IBindingFailedEventArgs, X> : Windows::UI::Xaml::IBindingFailedEventArgs_adaptor<X> { typedef adapt IBindingFailedEventArgs; };
struct IBindingFailedEventArgs : IBindingFailedEventArgs_raw, generate<IBindingFailedEventArgs> {};

// BindingFailedEventArgs
template<typename X> struct statics<BindingFailedEventArgs, X> : X {
	typedef typename X::root_type BindingFailedEventArgs;
};
struct BindingFailedEventArgs : generate<BindingFailedEventArgs> {};

// IDebugSettings
struct IDebugSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_EnableFrameRateCounter(bool *value);
	virtual STDMETHODIMP _put_EnableFrameRateCounter(bool value);
	virtual STDMETHODIMP _get_IsBindingTracingEnabled(bool *value);
	virtual STDMETHODIMP _put_IsBindingTracingEnabled(bool value);
	virtual STDMETHODIMP _get_IsOverdrawHeatMapEnabled(bool *value);
	virtual STDMETHODIMP _put_IsOverdrawHeatMapEnabled(bool value);
	virtual STDMETHODIMP _add_BindingFailed(BindingFailedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_BindingFailed(Foundation::EventRegistrationToken token);
};
template<typename X> struct IDebugSettings_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDebugSettings_adaptor::EnableFrameRateCounter)->_get_EnableFrameRateCounter(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDebugSettings_adaptor::EnableFrameRateCounter)->_put_EnableFrameRateCounter(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} EnableFrameRateCounter;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDebugSettings_adaptor::IsBindingTracingEnabled)->_get_IsBindingTracingEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDebugSettings_adaptor::IsBindingTracingEnabled)->_put_IsBindingTracingEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsBindingTracingEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDebugSettings_adaptor::IsOverdrawHeatMapEnabled)->_get_IsOverdrawHeatMapEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDebugSettings_adaptor::IsOverdrawHeatMapEnabled)->_put_IsOverdrawHeatMapEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsOverdrawHeatMapEnabled;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<BindingFailedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDebugSettings_adaptor::BindingFailed)->_add_BindingFailed(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDebugSettings_adaptor::BindingFailed)->_remove_BindingFailed(token)); }
		} BindingFailed;
	};
	IDebugSettings_adaptor() {}
};
template<typename X> struct adapt<IDebugSettings, X> : Windows::UI::Xaml::IDebugSettings_adaptor<X> { typedef adapt IDebugSettings; };
struct IDebugSettings : IDebugSettings_raw, generate<IDebugSettings> {};

// IDebugSettings2
struct IDebugSettings2_raw : IInspectable {
	virtual STDMETHODIMP _get_EnableRedrawRegions(bool *value);
	virtual STDMETHODIMP _put_EnableRedrawRegions(bool value);
};
template<typename X> struct IDebugSettings2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDebugSettings2_adaptor::EnableRedrawRegions)->_get_EnableRedrawRegions(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDebugSettings2_adaptor::EnableRedrawRegions)->_put_EnableRedrawRegions(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} EnableRedrawRegions;
	};
	IDebugSettings2_adaptor() {}
};
template<typename X> struct adapt<IDebugSettings2, X> : Windows::UI::Xaml::IDebugSettings2_adaptor<X> { typedef adapt IDebugSettings2; };
struct IDebugSettings2 : IDebugSettings2_raw, generate<IDebugSettings2> {};

// IDebugSettings3
struct IDebugSettings3_raw : IInspectable {
	virtual STDMETHODIMP _get_IsTextPerformanceVisualizationEnabled(bool *value);
	virtual STDMETHODIMP _put_IsTextPerformanceVisualizationEnabled(bool value);
};
template<typename X> struct IDebugSettings3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDebugSettings3_adaptor::IsTextPerformanceVisualizationEnabled)->_get_IsTextPerformanceVisualizationEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDebugSettings3_adaptor::IsTextPerformanceVisualizationEnabled)->_put_IsTextPerformanceVisualizationEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTextPerformanceVisualizationEnabled;
	};
	IDebugSettings3_adaptor() {}
};
template<typename X> struct adapt<IDebugSettings3, X> : Windows::UI::Xaml::IDebugSettings3_adaptor<X> { typedef adapt IDebugSettings3; };
struct IDebugSettings3 : IDebugSettings3_raw, generate<IDebugSettings3> {};

// DebugSettings
template<typename X> struct statics<DebugSettings, X> : X {
	typedef typename X::root_type DebugSettings;
};
struct DebugSettings : generate<DebugSettings> {};

// IElementSoundPlayer
struct IElementSoundPlayer : IInspectable, generate<IElementSoundPlayer> {};

// IElementSoundPlayerStatics
struct IElementSoundPlayerStatics : IInspectable {
	virtual STDMETHODIMP _get_Volume(double *value);
	virtual STDMETHODIMP _put_Volume(double value);
	virtual STDMETHODIMP _get_State(ElementSoundPlayerState *value);
	virtual STDMETHODIMP _put_State(ElementSoundPlayerState value);
	virtual STDMETHODIMP _Play(ElementSoundKind sound);
};

// IElementSoundPlayerStatics2
struct IElementSoundPlayerStatics2 : IInspectable {
	virtual STDMETHODIMP _get_SpatialAudioMode(ElementSpatialAudioMode *value);
	virtual STDMETHODIMP _put_SpatialAudioMode(ElementSpatialAudioMode value);
};

// ElementSoundPlayer
template<typename> struct ElementSoundPlayer_statics {
	static struct _State : property {
		ElementSoundPlayerState get() { ElementSoundPlayerState value; hrcheck(get_activation_factory<ElementSoundPlayer, IElementSoundPlayerStatics>()->_get_State(&value)); return value; }
		ElementSoundPlayerState operator()() { return get(); }
		operator ElementSoundPlayerState () { return get(); }
		void put(ElementSoundPlayerState value) { hrcheck(get_activation_factory<ElementSoundPlayer, IElementSoundPlayerStatics>()->_put_State(value)); }
		void operator=(ElementSoundPlayerState value) { put(value); }
		void operator()(ElementSoundPlayerState value) { put(value); }
	} State;
	static struct _Volume : property {
		double get() { double value; hrcheck(get_activation_factory<ElementSoundPlayer, IElementSoundPlayerStatics>()->_get_Volume(&value)); return value; }
		double operator()() { return get(); }
		operator double () { return get(); }
		void put(double value) { hrcheck(get_activation_factory<ElementSoundPlayer, IElementSoundPlayerStatics>()->_put_Volume(value)); }
		void operator=(double value) { put(value); }
		void operator()(double value) { put(value); }
	} Volume;
	static struct _SpatialAudioMode : property {
		ElementSpatialAudioMode get() { ElementSpatialAudioMode value; hrcheck(get_activation_factory<ElementSoundPlayer, IElementSoundPlayerStatics2>()->_get_SpatialAudioMode(&value)); return value; }
		ElementSpatialAudioMode operator()() { return get(); }
		operator ElementSpatialAudioMode () { return get(); }
		void put(ElementSpatialAudioMode value) { hrcheck(get_activation_factory<ElementSoundPlayer, IElementSoundPlayerStatics2>()->_put_SpatialAudioMode(value)); }
		void operator=(ElementSpatialAudioMode value) { put(value); }
		void operator()(ElementSpatialAudioMode value) { put(value); }
	} SpatialAudioMode;
	static void Play(ElementSoundKind sound) { hrcheck(get_activation_factory<ElementSoundPlayer, IElementSoundPlayerStatics>()->_Play(sound)); }
};
template<typename X> typename ElementSoundPlayer_statics<X>::_State ElementSoundPlayer_statics<X>::State;
template<typename X> typename ElementSoundPlayer_statics<X>::_Volume ElementSoundPlayer_statics<X>::Volume;
template<typename X> typename ElementSoundPlayer_statics<X>::_SpatialAudioMode ElementSoundPlayer_statics<X>::SpatialAudioMode;

template<typename X> struct statics<ElementSoundPlayer, X> : X, Windows::UI::Xaml::ElementSoundPlayer_statics<void> {
	typedef typename X::root_type ElementSoundPlayer;
};
struct ElementSoundPlayer : generate<ElementSoundPlayer> {};

// IApplication
struct IApplication_raw : IInspectable {
	virtual STDMETHODIMP _get_Resources(ResourceDictionary* *value);
	virtual STDMETHODIMP _put_Resources(ResourceDictionary* value);
	virtual STDMETHODIMP _get_DebugSettings(Xaml::DebugSettings* *value);
	virtual STDMETHODIMP _get_RequestedTheme(ApplicationTheme *value);
	virtual STDMETHODIMP _put_RequestedTheme(ApplicationTheme value);
	virtual STDMETHODIMP _add_UnhandledException(UnhandledExceptionEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_UnhandledException(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Suspending(SuspendingEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Suspending(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Resuming(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Resuming(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _Exit();
};
template<typename X> struct IApplication_adaptor : X {
	union {
		struct : property {
			ptr<Xaml::DebugSettings> get() { Xaml::DebugSettings* value; hrcheck(enc(&IApplication_adaptor::DebugSettings)->_get_DebugSettings(&value)); return from_abi(value); }
			ptr<Xaml::DebugSettings> operator()() { return get(); }
			operator ptr<Xaml::DebugSettings> () { return get(); }
			ptr<Xaml::DebugSettings> operator->() { return get(); }
		} DebugSettings;
		struct : property {
			ApplicationTheme get() { ApplicationTheme value; hrcheck(enc(&IApplication_adaptor::RequestedTheme)->_get_RequestedTheme(&value)); return value; }
			ApplicationTheme operator()() { return get(); }
			operator ApplicationTheme () { return get(); }
			void put(ApplicationTheme value) { hrcheck(enc(&IApplication_adaptor::RequestedTheme)->_put_RequestedTheme(value)); }
			void operator=(ApplicationTheme value) { put(value); }
			void operator()(ApplicationTheme value) { put(value); }
		} RequestedTheme;
		struct : property {
			ptr<ResourceDictionary> get() { ResourceDictionary* value; hrcheck(enc(&IApplication_adaptor::Resources)->_get_Resources(&value)); return from_abi(value); }
			ptr<ResourceDictionary> operator()() { return get(); }
			operator ptr<ResourceDictionary> () { return get(); }
			ptr<ResourceDictionary> operator->() { return get(); }
			void put(pptr<ResourceDictionary> value) { hrcheck(enc(&IApplication_adaptor::Resources)->_put_Resources(value)); }
			void operator=(pptr<ResourceDictionary> value) { put(value); }
			void operator()(pptr<ResourceDictionary> value) { put(value); }
		} Resources;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IApplication_adaptor::Resuming)->_add_Resuming(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IApplication_adaptor::Resuming)->_remove_Resuming(token)); }
		} Resuming;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<SuspendingEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IApplication_adaptor::Suspending)->_add_Suspending(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IApplication_adaptor::Suspending)->_remove_Suspending(token)); }
		} Suspending;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<UnhandledExceptionEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IApplication_adaptor::UnhandledException)->_add_UnhandledException(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IApplication_adaptor::UnhandledException)->_remove_UnhandledException(token)); }
		} UnhandledException;
	};
	void Exit() { hrcheck(X::get()->_Exit()); }
	IApplication_adaptor() {}
};
template<typename X> struct adapt<IApplication, X> : Windows::UI::Xaml::IApplication_adaptor<X> { typedef adapt IApplication; };
struct IApplication : IApplication_raw, generate<IApplication> {};

// IApplicationOverrides
struct IApplicationOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnActivated(ApplicationModel::Activation::IActivatedEventArgs* args) = 0;
	virtual STDMETHODIMP _OnLaunched(ApplicationModel::Activation::LaunchActivatedEventArgs* args) = 0;
	virtual STDMETHODIMP _OnFileActivated(ApplicationModel::Activation::FileActivatedEventArgs* args) = 0;
	virtual STDMETHODIMP _OnSearchActivated(ApplicationModel::Activation::SearchActivatedEventArgs* args) = 0;
	virtual STDMETHODIMP _OnShareTargetActivated(ApplicationModel::Activation::ShareTargetActivatedEventArgs* args) = 0;
	virtual STDMETHODIMP _OnFileOpenPickerActivated(ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* args) = 0;
	virtual STDMETHODIMP _OnFileSavePickerActivated(ApplicationModel::Activation::FileSavePickerActivatedEventArgs* args) = 0;
	virtual STDMETHODIMP _OnCachedFileUpdaterActivated(ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* args) = 0;
	virtual STDMETHODIMP _OnWindowCreated(WindowCreatedEventArgs* args) = 0;
};
template<typename X> struct IApplicationOverrides_adaptor : X {
	void OnActivated(pptr<ApplicationModel::Activation::IActivatedEventArgs> args) { hrcheck(X::get()->_OnActivated(args)); }
	void OnLaunched(pptr<ApplicationModel::Activation::LaunchActivatedEventArgs> args) { hrcheck(X::get()->_OnLaunched(args)); }
	void OnFileActivated(pptr<ApplicationModel::Activation::FileActivatedEventArgs> args) { hrcheck(X::get()->_OnFileActivated(args)); }
	void OnSearchActivated(pptr<ApplicationModel::Activation::SearchActivatedEventArgs> args) { hrcheck(X::get()->_OnSearchActivated(args)); }
	void OnShareTargetActivated(pptr<ApplicationModel::Activation::ShareTargetActivatedEventArgs> args) { hrcheck(X::get()->_OnShareTargetActivated(args)); }
	void OnFileOpenPickerActivated(pptr<ApplicationModel::Activation::FileOpenPickerActivatedEventArgs> args) { hrcheck(X::get()->_OnFileOpenPickerActivated(args)); }
	void OnFileSavePickerActivated(pptr<ApplicationModel::Activation::FileSavePickerActivatedEventArgs> args) { hrcheck(X::get()->_OnFileSavePickerActivated(args)); }
	void OnCachedFileUpdaterActivated(pptr<ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs> args) { hrcheck(X::get()->_OnCachedFileUpdaterActivated(args)); }
	void OnWindowCreated(pptr<WindowCreatedEventArgs> args) { hrcheck(X::get()->_OnWindowCreated(args)); }
};
template<typename X> struct adapt<IApplicationOverrides, X> : Windows::UI::Xaml::IApplicationOverrides_adaptor<X> { typedef adapt IApplicationOverrides; };
template<typename X> struct IApplicationOverrides_unadaptor : X {
	STDMETHODIMP _OnActivated(ApplicationModel::Activation::IActivatedEventArgs* args) { return hrtry([&, this] { X::get()->OnActivated(args); }); }
	STDMETHODIMP _OnLaunched(ApplicationModel::Activation::LaunchActivatedEventArgs* args) { return hrtry([&, this] { X::get()->OnLaunched(args); }); }
	STDMETHODIMP _OnFileActivated(ApplicationModel::Activation::FileActivatedEventArgs* args) { return hrtry([&, this] { X::get()->OnFileActivated(args); }); }
	STDMETHODIMP _OnSearchActivated(ApplicationModel::Activation::SearchActivatedEventArgs* args) { return hrtry([&, this] { X::get()->OnSearchActivated(args); }); }
	STDMETHODIMP _OnShareTargetActivated(ApplicationModel::Activation::ShareTargetActivatedEventArgs* args) { return hrtry([&, this] { X::get()->OnShareTargetActivated(args); }); }
	STDMETHODIMP _OnFileOpenPickerActivated(ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* args) { return hrtry([&, this] { X::get()->OnFileOpenPickerActivated(args); }); }
	STDMETHODIMP _OnFileSavePickerActivated(ApplicationModel::Activation::FileSavePickerActivatedEventArgs* args) { return hrtry([&, this] { X::get()->OnFileSavePickerActivated(args); }); }
	STDMETHODIMP _OnCachedFileUpdaterActivated(ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* args) { return hrtry([&, this] { X::get()->OnCachedFileUpdaterActivated(args); }); }
	STDMETHODIMP _OnWindowCreated(WindowCreatedEventArgs* args) { return hrtry([&, this] { X::get()->OnWindowCreated(args); }); }
};
template<typename X> struct unadapt<IApplicationOverrides, X> : Windows::UI::Xaml::IApplicationOverrides_unadaptor<X> {};
struct IApplicationOverrides : IApplicationOverrides_raw, generate<IApplicationOverrides> {};

// IWindowCreatedEventArgs
struct IWindowCreatedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Window(Xaml::Window* *value);
};
template<typename X> struct IWindowCreatedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Xaml::Window> get() { Xaml::Window* value; hrcheck(enc(&IWindowCreatedEventArgs_adaptor::Window)->_get_Window(&value)); return from_abi(value); }
			ptr<Xaml::Window> operator()() { return get(); }
			operator ptr<Xaml::Window> () { return get(); }
			ptr<Xaml::Window> operator->() { return get(); }
		} Window;
	};
	IWindowCreatedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IWindowCreatedEventArgs, X> : Windows::UI::Xaml::IWindowCreatedEventArgs_adaptor<X> { typedef adapt IWindowCreatedEventArgs; };
struct IWindowCreatedEventArgs : IWindowCreatedEventArgs_raw, generate<IWindowCreatedEventArgs> {};

// WindowCreatedEventArgs
template<typename X> struct statics<WindowCreatedEventArgs, X> : X {
	typedef typename X::root_type WindowCreatedEventArgs;
};
struct WindowCreatedEventArgs : generate<WindowCreatedEventArgs> {};

// IApplicationStatics
struct IApplicationStatics : IInspectable {
	virtual STDMETHODIMP _get_Current(Application* *value);
	virtual STDMETHODIMP _Start(ApplicationInitializationCallback* callback);
	virtual STDMETHODIMP _LoadComponent(IInspectable* component, Foundation::Uri* resourceLocator);
	virtual STDMETHODIMP _LoadComponentWithResourceLocation(IInspectable* component, Foundation::Uri* resourceLocator, Controls::Primitives::ComponentResourceLocation componentResourceLocation);
};

// IApplicationFactory
struct IApplicationFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Application* *instance);
};

// IApplication3
struct IApplication3_raw : IInspectable {
	virtual STDMETHODIMP _get_HighContrastAdjustment(ApplicationHighContrastAdjustment *value);
	virtual STDMETHODIMP _put_HighContrastAdjustment(ApplicationHighContrastAdjustment value);
};
template<typename X> struct IApplication3_adaptor : X {
	union {
		struct : property {
			ApplicationHighContrastAdjustment get() { ApplicationHighContrastAdjustment value; hrcheck(enc(&IApplication3_adaptor::HighContrastAdjustment)->_get_HighContrastAdjustment(&value)); return value; }
			ApplicationHighContrastAdjustment operator()() { return get(); }
			operator ApplicationHighContrastAdjustment () { return get(); }
			void put(ApplicationHighContrastAdjustment value) { hrcheck(enc(&IApplication3_adaptor::HighContrastAdjustment)->_put_HighContrastAdjustment(value)); }
			void operator=(ApplicationHighContrastAdjustment value) { put(value); }
			void operator()(ApplicationHighContrastAdjustment value) { put(value); }
		} HighContrastAdjustment;
	};
	IApplication3_adaptor() {}
};
template<typename X> struct adapt<IApplication3, X> : Windows::UI::Xaml::IApplication3_adaptor<X> { typedef adapt IApplication3; };
struct IApplication3 : IApplication3_raw, generate<IApplication3> {};

// IApplicationOverrides2
struct IApplicationOverrides2_raw : IInspectable {
	virtual STDMETHODIMP _OnBackgroundActivated(ApplicationModel::Activation::BackgroundActivatedEventArgs* args) = 0;
};
template<typename X> struct IApplicationOverrides2_adaptor : X {
	void OnBackgroundActivated(pptr<ApplicationModel::Activation::BackgroundActivatedEventArgs> args) { hrcheck(X::get()->_OnBackgroundActivated(args)); }
};
template<typename X> struct adapt<IApplicationOverrides2, X> : Windows::UI::Xaml::IApplicationOverrides2_adaptor<X> { typedef adapt IApplicationOverrides2; };
template<typename X> struct IApplicationOverrides2_unadaptor : X {
	STDMETHODIMP _OnBackgroundActivated(ApplicationModel::Activation::BackgroundActivatedEventArgs* args) { return hrtry([&, this] { X::get()->OnBackgroundActivated(args); }); }
};
template<typename X> struct unadapt<IApplicationOverrides2, X> : Windows::UI::Xaml::IApplicationOverrides2_unadaptor<X> {};
struct IApplicationOverrides2 : IApplicationOverrides2_raw, generate<IApplicationOverrides2> {};

// IApplication2
struct IApplication2_raw : IInspectable {
	virtual STDMETHODIMP _get_FocusVisualKind(Xaml::FocusVisualKind *value);
	virtual STDMETHODIMP _put_FocusVisualKind(Xaml::FocusVisualKind value);
	virtual STDMETHODIMP _get_RequiresPointerMode(ApplicationRequiresPointerMode *value);
	virtual STDMETHODIMP _put_RequiresPointerMode(ApplicationRequiresPointerMode value);
	virtual STDMETHODIMP _add_LeavingBackground(LeavingBackgroundEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_LeavingBackground(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_EnteredBackground(EnteredBackgroundEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_EnteredBackground(Foundation::EventRegistrationToken token);
};
template<typename X> struct IApplication2_adaptor : X {
	union {
		struct : property {
			Xaml::FocusVisualKind get() { Xaml::FocusVisualKind value; hrcheck(enc(&IApplication2_adaptor::FocusVisualKind)->_get_FocusVisualKind(&value)); return value; }
			Xaml::FocusVisualKind operator()() { return get(); }
			operator Xaml::FocusVisualKind () { return get(); }
			void put(Xaml::FocusVisualKind value) { hrcheck(enc(&IApplication2_adaptor::FocusVisualKind)->_put_FocusVisualKind(value)); }
			void operator=(Xaml::FocusVisualKind value) { put(value); }
			void operator()(Xaml::FocusVisualKind value) { put(value); }
		} FocusVisualKind;
		struct : property {
			ApplicationRequiresPointerMode get() { ApplicationRequiresPointerMode value; hrcheck(enc(&IApplication2_adaptor::RequiresPointerMode)->_get_RequiresPointerMode(&value)); return value; }
			ApplicationRequiresPointerMode operator()() { return get(); }
			operator ApplicationRequiresPointerMode () { return get(); }
			void put(ApplicationRequiresPointerMode value) { hrcheck(enc(&IApplication2_adaptor::RequiresPointerMode)->_put_RequiresPointerMode(value)); }
			void operator=(ApplicationRequiresPointerMode value) { put(value); }
			void operator()(ApplicationRequiresPointerMode value) { put(value); }
		} RequiresPointerMode;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<EnteredBackgroundEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IApplication2_adaptor::EnteredBackground)->_add_EnteredBackground(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IApplication2_adaptor::EnteredBackground)->_remove_EnteredBackground(token)); }
		} EnteredBackground;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<LeavingBackgroundEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IApplication2_adaptor::LeavingBackground)->_add_LeavingBackground(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IApplication2_adaptor::LeavingBackground)->_remove_LeavingBackground(token)); }
		} LeavingBackground;
	};
	IApplication2_adaptor() {}
};
template<typename X> struct adapt<IApplication2, X> : Windows::UI::Xaml::IApplication2_adaptor<X> { typedef adapt IApplication2; };
struct IApplication2 : IApplication2_raw, generate<IApplication2> {};

// Application
template<typename> struct Application_statics {
	static struct _Current : property {
		ptr<Application> get() { Application* value; hrcheck(get_activation_factory<Application, IApplicationStatics>()->_get_Current(&value)); return from_abi(value); }
		ptr<Application> operator()() { return get(); }
		operator ptr<Application> () { return get(); }
		ptr<Application> operator->() { return get(); }
	} Current;
	static void Start(handler_ref<ApplicationInitializationCallback> callback) { hrcheck(get_activation_factory<Application, IApplicationStatics>()->_Start(callback)); }
	static void LoadComponent(object_ref component, pptr<Foundation::Uri> resourceLocator) { hrcheck(get_activation_factory<Application, IApplicationStatics>()->_LoadComponent(component, resourceLocator)); }
	static void LoadComponent(object_ref component, pptr<Foundation::Uri> resourceLocator, Controls::Primitives::ComponentResourceLocation componentResourceLocation) { hrcheck(get_activation_factory<Application, IApplicationStatics>()->_LoadComponentWithResourceLocation(component, resourceLocator, componentResourceLocation)); }
	static Application *activate(object_ref outer, IInspectable* *inner) { Application *instance; hrcheck(get_activation_factory<Application, IApplicationFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename Application_statics<X>::_Current Application_statics<X>::Current;

template<typename X> struct statics<Application, X> : X, Windows::UI::Xaml::Application_statics<void> {
	using Windows::UI::Xaml::Application_statics<void>::activate;
	typedef typename X::root_type Application;
};
struct Application : generate<Application> {};

// IFrameworkViewSource
struct IFrameworkViewSource : IInspectable, generate<IFrameworkViewSource> {};

// FrameworkViewSource
template<typename X> struct statics<FrameworkViewSource, X> : X {
	typedef typename X::root_type FrameworkViewSource;
};
struct FrameworkViewSource : generate<FrameworkViewSource> {};

// IPointHelper
struct IPointHelper : IInspectable, generate<IPointHelper> {};

// IPointHelperStatics
struct IPointHelperStatics : IInspectable {
	virtual STDMETHODIMP _FromCoordinates(float x, float y, Foundation::Point *returnValue);
};

// PointHelper
template<typename> struct PointHelper_statics {
	static Foundation::Point FromCoordinates(float x, float y) { Foundation::Point returnValue; hrcheck(get_activation_factory<PointHelper, IPointHelperStatics>()->_FromCoordinates(x, y, &returnValue)); return returnValue; }
};

template<typename X> struct statics<PointHelper, X> : X, Windows::UI::Xaml::PointHelper_statics<void> {
	typedef typename X::root_type PointHelper;
};
struct PointHelper : generate<PointHelper> {};

// IRectHelper
struct IRectHelper : IInspectable, generate<IRectHelper> {};

// IRectHelperStatics
struct IRectHelperStatics : IInspectable {
	virtual STDMETHODIMP _get_Empty(Foundation::Rect *value);
	virtual STDMETHODIMP _FromCoordinatesAndDimensions(float x, float y, float width, float height, Foundation::Rect *returnValue);
	virtual STDMETHODIMP _FromPoints(Foundation::Point point1, Foundation::Point point2, Foundation::Rect *returnValue);
	virtual STDMETHODIMP _FromLocationAndSize(Foundation::Point location, Foundation::Size size, Foundation::Rect *returnValue);
	virtual STDMETHODIMP _GetIsEmpty(Foundation::Rect target, bool *value);
	virtual STDMETHODIMP _GetBottom(Foundation::Rect target, float *value);
	virtual STDMETHODIMP _GetLeft(Foundation::Rect target, float *value);
	virtual STDMETHODIMP _GetRight(Foundation::Rect target, float *value);
	virtual STDMETHODIMP _GetTop(Foundation::Rect target, float *value);
	virtual STDMETHODIMP _Contains(Foundation::Rect target, Foundation::Point point, bool *returnValue);
	virtual STDMETHODIMP _Equals(Foundation::Rect target, Foundation::Rect value, bool *returnValue);
	virtual STDMETHODIMP _Intersect(Foundation::Rect target, Foundation::Rect rect, Foundation::Rect *returnValue);
	virtual STDMETHODIMP _UnionWithPoint(Foundation::Rect target, Foundation::Point point, Foundation::Rect *returnValue);
	virtual STDMETHODIMP _UnionWithRect(Foundation::Rect target, Foundation::Rect rect, Foundation::Rect *returnValue);
};

// RectHelper
template<typename> struct RectHelper_statics {
	static struct _Empty : property {
		Foundation::Rect get() { Foundation::Rect value; hrcheck(get_activation_factory<RectHelper, IRectHelperStatics>()->_get_Empty(&value)); return value; }
		Foundation::Rect operator()() { return get(); }
		operator Foundation::Rect () { return get(); }
	} Empty;
	static Foundation::Rect FromCoordinatesAndDimensions(float x, float y, float width, float height) { Foundation::Rect returnValue; hrcheck(get_activation_factory<RectHelper, IRectHelperStatics>()->_FromCoordinatesAndDimensions(x, y, width, height, &returnValue)); return returnValue; }
	static Foundation::Rect FromPoints(const Foundation::Point& point1, const Foundation::Point& point2) { Foundation::Rect returnValue; hrcheck(get_activation_factory<RectHelper, IRectHelperStatics>()->_FromPoints(point1, point2, &returnValue)); return returnValue; }
	static Foundation::Rect FromLocationAndSize(const Foundation::Point& location, const Foundation::Size& size) { Foundation::Rect returnValue; hrcheck(get_activation_factory<RectHelper, IRectHelperStatics>()->_FromLocationAndSize(location, size, &returnValue)); return returnValue; }
	static bool GetIsEmpty(const Foundation::Rect& target) { bool value; hrcheck(get_activation_factory<RectHelper, IRectHelperStatics>()->_GetIsEmpty(target, &value)); return value; }
	static float GetBottom(const Foundation::Rect& target) { float value; hrcheck(get_activation_factory<RectHelper, IRectHelperStatics>()->_GetBottom(target, &value)); return value; }
	static float GetLeft(const Foundation::Rect& target) { float value; hrcheck(get_activation_factory<RectHelper, IRectHelperStatics>()->_GetLeft(target, &value)); return value; }
	static float GetRight(const Foundation::Rect& target) { float value; hrcheck(get_activation_factory<RectHelper, IRectHelperStatics>()->_GetRight(target, &value)); return value; }
	static float GetTop(const Foundation::Rect& target) { float value; hrcheck(get_activation_factory<RectHelper, IRectHelperStatics>()->_GetTop(target, &value)); return value; }
	static bool Contains(const Foundation::Rect& target, const Foundation::Point& point) { bool returnValue; hrcheck(get_activation_factory<RectHelper, IRectHelperStatics>()->_Contains(target, point, &returnValue)); return returnValue; }
	static bool Equals(const Foundation::Rect& target, const Foundation::Rect& value) { bool returnValue; hrcheck(get_activation_factory<RectHelper, IRectHelperStatics>()->_Equals(target, value, &returnValue)); return returnValue; }
	static Foundation::Rect Intersect(const Foundation::Rect& target, const Foundation::Rect& rect) { Foundation::Rect returnValue; hrcheck(get_activation_factory<RectHelper, IRectHelperStatics>()->_Intersect(target, rect, &returnValue)); return returnValue; }
	static Foundation::Rect Union(const Foundation::Rect& target, const Foundation::Point& point) { Foundation::Rect returnValue; hrcheck(get_activation_factory<RectHelper, IRectHelperStatics>()->_UnionWithPoint(target, point, &returnValue)); return returnValue; }
	static Foundation::Rect Union(const Foundation::Rect& target, const Foundation::Rect& rect) { Foundation::Rect returnValue; hrcheck(get_activation_factory<RectHelper, IRectHelperStatics>()->_UnionWithRect(target, rect, &returnValue)); return returnValue; }
};
template<typename X> typename RectHelper_statics<X>::_Empty RectHelper_statics<X>::Empty;

template<typename X> struct statics<RectHelper, X> : X, Windows::UI::Xaml::RectHelper_statics<void> {
	typedef typename X::root_type RectHelper;
};
struct RectHelper : generate<RectHelper> {};

// ISizeHelper
struct ISizeHelper : IInspectable, generate<ISizeHelper> {};

// ISizeHelperStatics
struct ISizeHelperStatics : IInspectable {
	virtual STDMETHODIMP _get_Empty(Foundation::Size *value);
	virtual STDMETHODIMP _FromDimensions(float width, float height, Foundation::Size *returnValue);
	virtual STDMETHODIMP _GetIsEmpty(Foundation::Size target, bool *value);
	virtual STDMETHODIMP _Equals(Foundation::Size target, Foundation::Size value, bool *returnValue);
};

// SizeHelper
template<typename> struct SizeHelper_statics {
	static struct _Empty : property {
		Foundation::Size get() { Foundation::Size value; hrcheck(get_activation_factory<SizeHelper, ISizeHelperStatics>()->_get_Empty(&value)); return value; }
		Foundation::Size operator()() { return get(); }
		operator Foundation::Size () { return get(); }
	} Empty;
	static Foundation::Size FromDimensions(float width, float height) { Foundation::Size returnValue; hrcheck(get_activation_factory<SizeHelper, ISizeHelperStatics>()->_FromDimensions(width, height, &returnValue)); return returnValue; }
	static bool GetIsEmpty(const Foundation::Size& target) { bool value; hrcheck(get_activation_factory<SizeHelper, ISizeHelperStatics>()->_GetIsEmpty(target, &value)); return value; }
	static bool Equals(const Foundation::Size& target, const Foundation::Size& value) { bool returnValue; hrcheck(get_activation_factory<SizeHelper, ISizeHelperStatics>()->_Equals(target, value, &returnValue)); return returnValue; }
};
template<typename X> typename SizeHelper_statics<X>::_Empty SizeHelper_statics<X>::Empty;

template<typename X> struct statics<SizeHelper, X> : X, Windows::UI::Xaml::SizeHelper_statics<void> {
	typedef typename X::root_type SizeHelper;
};
struct SizeHelper : generate<SizeHelper> {};

// IWindow
struct IWindow_raw : IInspectable {
	virtual STDMETHODIMP _get_Bounds(Foundation::Rect *value);
	virtual STDMETHODIMP _get_Visible(bool *value);
	virtual STDMETHODIMP _get_Content(UIElement* *value);
	virtual STDMETHODIMP _put_Content(UIElement* value);
	virtual STDMETHODIMP _get_CoreWindow(Core::CoreWindow* *value);
	virtual STDMETHODIMP _get_Dispatcher(Core::CoreDispatcher* *value);
	virtual STDMETHODIMP _add_Activated(WindowActivatedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Activated(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Closed(WindowClosedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Closed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_SizeChanged(WindowSizeChangedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SizeChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_VisibilityChanged(WindowVisibilityChangedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_VisibilityChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _Activate();
	virtual STDMETHODIMP _Close();
};
template<typename X> struct IWindow_adaptor : X {
	union {
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&IWindow_adaptor::Bounds)->_get_Bounds(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
		} Bounds;
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IWindow_adaptor::Content)->_get_Content(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IWindow_adaptor::Content)->_put_Content(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} Content;
		struct : property {
			ptr<Core::CoreWindow> get() { Core::CoreWindow* value; hrcheck(enc(&IWindow_adaptor::CoreWindow)->_get_CoreWindow(&value)); return from_abi(value); }
			ptr<Core::CoreWindow> operator()() { return get(); }
			operator ptr<Core::CoreWindow> () { return get(); }
			ptr<Core::CoreWindow> operator->() { return get(); }
		} CoreWindow;
		struct : property {
			ptr<Core::CoreDispatcher> get() { Core::CoreDispatcher* value; hrcheck(enc(&IWindow_adaptor::Dispatcher)->_get_Dispatcher(&value)); return from_abi(value); }
			ptr<Core::CoreDispatcher> operator()() { return get(); }
			operator ptr<Core::CoreDispatcher> () { return get(); }
			ptr<Core::CoreDispatcher> operator->() { return get(); }
		} Dispatcher;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IWindow_adaptor::Visible)->_get_Visible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Visible;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<WindowActivatedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWindow_adaptor::Activated)->_add_Activated(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWindow_adaptor::Activated)->_remove_Activated(token)); }
		} Activated;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<WindowClosedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWindow_adaptor::Closed)->_add_Closed(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWindow_adaptor::Closed)->_remove_Closed(token)); }
		} Closed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<WindowSizeChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWindow_adaptor::SizeChanged)->_add_SizeChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWindow_adaptor::SizeChanged)->_remove_SizeChanged(token)); }
		} SizeChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<WindowVisibilityChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWindow_adaptor::VisibilityChanged)->_add_VisibilityChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWindow_adaptor::VisibilityChanged)->_remove_VisibilityChanged(token)); }
		} VisibilityChanged;
	};
	void Activate() { hrcheck(X::get()->_Activate()); }
	void Close() { hrcheck(X::get()->_Close()); }
	IWindow_adaptor() {}
};
template<typename X> struct adapt<IWindow, X> : Windows::UI::Xaml::IWindow_adaptor<X> { typedef adapt IWindow; };
struct IWindow : IWindow_raw, generate<IWindow> {};

// IWindowStatics
struct IWindowStatics : IInspectable {
	virtual STDMETHODIMP _get_Current(Window* *value);
};

// IWindow3
struct IWindow3_raw : IInspectable {
	virtual STDMETHODIMP _get_Compositor(Composition::Compositor* *value);
};
template<typename X> struct IWindow3_adaptor : X {
	union {
		struct : property {
			ptr<Composition::Compositor> get() { Composition::Compositor* value; hrcheck(enc(&IWindow3_adaptor::Compositor)->_get_Compositor(&value)); return from_abi(value); }
			ptr<Composition::Compositor> operator()() { return get(); }
			operator ptr<Composition::Compositor> () { return get(); }
			ptr<Composition::Compositor> operator->() { return get(); }
		} Compositor;
	};
	IWindow3_adaptor() {}
};
template<typename X> struct adapt<IWindow3, X> : Windows::UI::Xaml::IWindow3_adaptor<X> { typedef adapt IWindow3; };
struct IWindow3 : IWindow3_raw, generate<IWindow3> {};

// IWindow2
struct IWindow2_raw : IInspectable {
	virtual STDMETHODIMP _SetTitleBar(UIElement* value);
};
template<typename X> struct IWindow2_adaptor : X {
	void SetTitleBar(pptr<UIElement> value) { hrcheck(X::get()->_SetTitleBar(value)); }
};
template<typename X> struct adapt<IWindow2, X> : Windows::UI::Xaml::IWindow2_adaptor<X> { typedef adapt IWindow2; };
struct IWindow2 : IWindow2_raw, generate<IWindow2> {};

// Window
template<typename> struct Window_statics {
	static struct _Current : property {
		ptr<Window> get() { Window* value; hrcheck(get_activation_factory<Window, IWindowStatics>()->_get_Current(&value)); return from_abi(value); }
		ptr<Window> operator()() { return get(); }
		operator ptr<Window> () { return get(); }
		ptr<Window> operator->() { return get(); }
	} Current;
};
template<typename X> typename Window_statics<X>::_Current Window_statics<X>::Current;

template<typename X> struct statics<Window, X> : X, Windows::UI::Xaml::Window_statics<void> {
	typedef typename X::root_type Window;
};
struct Window : generate<Window> {};

// IVisualStateManager
struct IVisualStateManager : IInspectable, generate<IVisualStateManager> {};

// IVisualStateManagerOverrides
struct IVisualStateManagerOverrides_raw : IInspectable {
	virtual STDMETHODIMP _GoToStateCore(Controls::Control* control, FrameworkElement* templateRoot, HSTRING stateName, VisualStateGroup* group, VisualState* state, bool useTransitions, bool *returnValue) = 0;
};
template<typename X> struct IVisualStateManagerOverrides_adaptor : X {
	bool GoToStateCore(pptr<Controls::Control> control, pptr<FrameworkElement> templateRoot, hstring_ref stateName, pptr<VisualStateGroup> group, pptr<VisualState> state, bool useTransitions) { bool returnValue; hrcheck(X::get()->_GoToStateCore(control, templateRoot, stateName, group, state, useTransitions, &returnValue)); return returnValue; }
};
template<typename X> struct adapt<IVisualStateManagerOverrides, X> : Windows::UI::Xaml::IVisualStateManagerOverrides_adaptor<X> { typedef adapt IVisualStateManagerOverrides; };
template<typename X> struct IVisualStateManagerOverrides_unadaptor : X {
	STDMETHODIMP _GoToStateCore(Controls::Control* control, FrameworkElement* templateRoot, HSTRING stateName, VisualStateGroup* group, VisualState* state, bool useTransitions, bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->GoToStateCore(control, templateRoot, stateName, group, state, useTransitions); }); }
};
template<typename X> struct unadapt<IVisualStateManagerOverrides, X> : Windows::UI::Xaml::IVisualStateManagerOverrides_unadaptor<X> {};
struct IVisualStateManagerOverrides : IVisualStateManagerOverrides_raw, generate<IVisualStateManagerOverrides> {};

// IVisualStateManagerProtected
struct IVisualStateManagerProtected_raw : IInspectable {
	virtual STDMETHODIMP _RaiseCurrentStateChanging(VisualStateGroup* stateGroup, VisualState* oldState, VisualState* newState, Controls::Control* control);
	virtual STDMETHODIMP _RaiseCurrentStateChanged(VisualStateGroup* stateGroup, VisualState* oldState, VisualState* newState, Controls::Control* control);
};
template<typename X> struct IVisualStateManagerProtected_adaptor : X {
	void RaiseCurrentStateChanging(pptr<VisualStateGroup> stateGroup, pptr<VisualState> oldState, pptr<VisualState> newState, pptr<Controls::Control> control) { hrcheck(X::get()->_RaiseCurrentStateChanging(stateGroup, oldState, newState, control)); }
	void RaiseCurrentStateChanged(pptr<VisualStateGroup> stateGroup, pptr<VisualState> oldState, pptr<VisualState> newState, pptr<Controls::Control> control) { hrcheck(X::get()->_RaiseCurrentStateChanged(stateGroup, oldState, newState, control)); }
};
template<typename X> struct adapt<IVisualStateManagerProtected, X> : Windows::UI::Xaml::IVisualStateManagerProtected_adaptor<X> { typedef adapt IVisualStateManagerProtected; };
struct IVisualStateManagerProtected : IVisualStateManagerProtected_raw, generate<IVisualStateManagerProtected> {};

// IVisualStateManagerStatics
struct IVisualStateManagerStatics : IInspectable {
	virtual STDMETHODIMP _GetVisualStateGroups(FrameworkElement* obj, Foundation::Collections::IVector<VisualStateGroup*>* *value);
	virtual STDMETHODIMP _get_CustomVisualStateManagerProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetCustomVisualStateManager(FrameworkElement* obj, VisualStateManager* *value);
	virtual STDMETHODIMP _SetCustomVisualStateManager(FrameworkElement* obj, VisualStateManager* value);
	virtual STDMETHODIMP _GoToState(Controls::Control* control, HSTRING stateName, bool useTransitions, bool *returnValue);
};

// IVisualStateManagerFactory
struct IVisualStateManagerFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, VisualStateManager* *instance);
};

// VisualStateManager
template<typename> struct VisualStateManager_statics {
	static struct _CustomVisualStateManagerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<VisualStateManager, IVisualStateManagerStatics>()->_get_CustomVisualStateManagerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CustomVisualStateManagerProperty;
	static ptr<Foundation::Collections::IVector<ptr<VisualStateGroup>>> GetVisualStateGroups(pptr<FrameworkElement> obj) { Foundation::Collections::IVector<VisualStateGroup*>* value; hrcheck(get_activation_factory<VisualStateManager, IVisualStateManagerStatics>()->_GetVisualStateGroups(obj, &value)); return from_abi(value); }
	static ptr<VisualStateManager> GetCustomVisualStateManager(pptr<FrameworkElement> obj) { VisualStateManager* value; hrcheck(get_activation_factory<VisualStateManager, IVisualStateManagerStatics>()->_GetCustomVisualStateManager(obj, &value)); return from_abi(value); }
	static void SetCustomVisualStateManager(pptr<FrameworkElement> obj, pptr<VisualStateManager> value) { hrcheck(get_activation_factory<VisualStateManager, IVisualStateManagerStatics>()->_SetCustomVisualStateManager(obj, value)); }
	static bool GoToState(pptr<Controls::Control> control, hstring_ref stateName, bool useTransitions) { bool returnValue; hrcheck(get_activation_factory<VisualStateManager, IVisualStateManagerStatics>()->_GoToState(control, stateName, useTransitions, &returnValue)); return returnValue; }
	static VisualStateManager *activate(object_ref outer, IInspectable* *inner) { VisualStateManager *instance; hrcheck(get_activation_factory<VisualStateManager, IVisualStateManagerFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename VisualStateManager_statics<X>::_CustomVisualStateManagerProperty VisualStateManager_statics<X>::CustomVisualStateManagerProperty;

template<typename X> struct statics<VisualStateManager, X> : X, Windows::UI::Xaml::VisualStateManager_statics<void> {
	using Windows::UI::Xaml::VisualStateManager_statics<void>::activate;
	typedef typename X::root_type VisualStateManager;
};
struct VisualStateManager : generate<VisualStateManager> {};
}}}
} // namespace iso_winrt
