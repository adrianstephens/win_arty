#pragma once
// generated by isopod tools
// namespaces:
// Windows.UI.Xaml.Media.Animation

#include "Windows.UI.Xaml.Media.Animation.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.UI.0.h"
#include "Windows.UI.Xaml.Controls.0.h"
#include "Windows.Foundation.Collections.h"
#include "Windows.UI.Xaml.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace UI { namespace Composition {
struct CompositionEasingFunction;
struct ICompositionAnimationBase;
}}}

// defs

template<> struct def<Windows::UI::Xaml::Media::Animation::ClockState> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::EasingMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::FillBehavior> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::RepeatBehaviorType> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::KeyTime> : value_type<Windows::Foundation::TimeSpan> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IKeyTimeHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IKeyTimeHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::KeyTimeHelper> : class_type<Platform::Object, Windows::UI::Xaml::Media::Animation::IKeyTimeHelper> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::RepeatBehavior> : value_type<double, Windows::Foundation::TimeSpan, Windows::UI::Xaml::Media::Animation::RepeatBehaviorType> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IRepeatBehaviorHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IRepeatBehaviorHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::RepeatBehaviorHelper> : class_type<Platform::Object, Windows::UI::Xaml::Media::Animation::IRepeatBehaviorHelper> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ConditionallyIndependentlyAnimatableAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IndependentlyAnimatableAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ITransitionFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ITransition> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::Transition> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::Animation::ITransition> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::TransitionCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Media::Animation::Transition>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Media::Animation::Transition>>> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDoubleKeyFrameFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDoubleKeyFrameStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDoubleKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::DoubleKeyFrame> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::Animation::IDoubleKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::DoubleKeyFrameCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Media::Animation::DoubleKeyFrame>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Media::Animation::DoubleKeyFrame>>> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IObjectKeyFrameFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IObjectKeyFrameStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IObjectKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ObjectKeyFrame> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::Animation::IObjectKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ObjectKeyFrameCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Media::Animation::ObjectKeyFrame>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Media::Animation::ObjectKeyFrame>>> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ITimelineFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ITimelineStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ITimeline> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::Timeline> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::Animation::ITimeline> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::TimelineCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Media::Animation::Timeline>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Media::Animation::Timeline>>> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IEasingFunctionBase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IEasingFunctionBaseFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IEasingFunctionBaseStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::EasingFunctionBase> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::Animation::IEasingFunctionBase> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IKeySpline> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::KeySpline> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::Animation::IKeySpline> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::INavigationTransitionInfo> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::INavigationTransitionInfoOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::INavigationTransitionInfoFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::Animation::INavigationTransitionInfo, Windows::UI::Xaml::Media::Animation::INavigationTransitionInfoOverrides> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IAddDeleteThemeTransition> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::AddDeleteThemeTransition> : class_type<Windows::UI::Xaml::Media::Animation::Transition, Windows::UI::Xaml::Media::Animation::IAddDeleteThemeTransition> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IBackEase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IBackEaseStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::BackEase> : class_type<Windows::UI::Xaml::Media::Animation::EasingFunctionBase, Windows::UI::Xaml::Media::Animation::IBackEase> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IBeginStoryboard> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IBeginStoryboardStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::BeginStoryboard> : class_type<Windows::UI::Xaml::TriggerAction, Windows::UI::Xaml::Media::Animation::IBeginStoryboard> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IBounceEase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IBounceEaseStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::BounceEase> : class_type<Windows::UI::Xaml::Media::Animation::EasingFunctionBase, Windows::UI::Xaml::Media::Animation::IBounceEase> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ICircleEase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::CircleEase> : class_type<Windows::UI::Xaml::Media::Animation::EasingFunctionBase, Windows::UI::Xaml::Media::Animation::ICircleEase> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IColorAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IColorAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ColorAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IColorAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IContentThemeTransition> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IContentThemeTransitionStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ContentThemeTransition> : class_type<Windows::UI::Xaml::Media::Animation::Transition, Windows::UI::Xaml::Media::Animation::IContentThemeTransition> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ICubicEase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::CubicEase> : class_type<Windows::UI::Xaml::Media::Animation::EasingFunctionBase, Windows::UI::Xaml::Media::Animation::ICubicEase> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDiscreteDoubleKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::DiscreteDoubleKeyFrame> : class_type<Windows::UI::Xaml::Media::Animation::DoubleKeyFrame, Windows::UI::Xaml::Media::Animation::IDiscreteDoubleKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDiscreteObjectKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::DiscreteObjectKeyFrame> : class_type<Windows::UI::Xaml::Media::Animation::ObjectKeyFrame, Windows::UI::Xaml::Media::Animation::IDiscreteObjectKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDoubleAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDoubleAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::DoubleAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IDoubleAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDoubleAnimationUsingKeyFrames> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDoubleAnimationUsingKeyFramesStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::DoubleAnimationUsingKeyFrames> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IDoubleAnimationUsingKeyFrames> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IEasingDoubleKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IEasingDoubleKeyFrameStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::EasingDoubleKeyFrame> : class_type<Windows::UI::Xaml::Media::Animation::DoubleKeyFrame, Windows::UI::Xaml::Media::Animation::IEasingDoubleKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IEdgeUIThemeTransition> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IEdgeUIThemeTransitionStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::EdgeUIThemeTransition> : class_type<Windows::UI::Xaml::Media::Animation::Transition, Windows::UI::Xaml::Media::Animation::IEdgeUIThemeTransition> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IElasticEase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IElasticEaseStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ElasticEase> : class_type<Windows::UI::Xaml::Media::Animation::EasingFunctionBase, Windows::UI::Xaml::Media::Animation::IElasticEase> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IEntranceThemeTransition> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IEntranceThemeTransitionStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::EntranceThemeTransition> : class_type<Windows::UI::Xaml::Media::Animation::Transition, Windows::UI::Xaml::Media::Animation::IEntranceThemeTransition> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IExponentialEase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IExponentialEaseStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ExponentialEase> : class_type<Windows::UI::Xaml::Media::Animation::EasingFunctionBase, Windows::UI::Xaml::Media::Animation::IExponentialEase> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ILinearDoubleKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::LinearDoubleKeyFrame> : class_type<Windows::UI::Xaml::Media::Animation::DoubleKeyFrame, Windows::UI::Xaml::Media::Animation::ILinearDoubleKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IObjectAnimationUsingKeyFrames> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IObjectAnimationUsingKeyFramesStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ObjectAnimationUsingKeyFrames> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IObjectAnimationUsingKeyFrames> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPaneThemeTransition> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPaneThemeTransitionStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::PaneThemeTransition> : class_type<Windows::UI::Xaml::Media::Animation::Transition, Windows::UI::Xaml::Media::Animation::IPaneThemeTransition> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPointAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPointAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::PointAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IPointAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPopupThemeTransition> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPopupThemeTransitionStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::PopupThemeTransition> : class_type<Windows::UI::Xaml::Media::Animation::Transition, Windows::UI::Xaml::Media::Animation::IPopupThemeTransition> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPowerEase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPowerEaseStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::PowerEase> : class_type<Windows::UI::Xaml::Media::Animation::EasingFunctionBase, Windows::UI::Xaml::Media::Animation::IPowerEase> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IQuadraticEase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::QuadraticEase> : class_type<Windows::UI::Xaml::Media::Animation::EasingFunctionBase, Windows::UI::Xaml::Media::Animation::IQuadraticEase> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IQuarticEase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::QuarticEase> : class_type<Windows::UI::Xaml::Media::Animation::EasingFunctionBase, Windows::UI::Xaml::Media::Animation::IQuarticEase> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IQuinticEase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::QuinticEase> : class_type<Windows::UI::Xaml::Media::Animation::EasingFunctionBase, Windows::UI::Xaml::Media::Animation::IQuinticEase> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IReorderThemeTransition> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ReorderThemeTransition> : class_type<Windows::UI::Xaml::Media::Animation::Transition, Windows::UI::Xaml::Media::Animation::IReorderThemeTransition> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IRepositionThemeTransition> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IRepositionThemeTransition2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IRepositionThemeTransitionStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::RepositionThemeTransition> : class_type<Windows::UI::Xaml::Media::Animation::Transition, Windows::UI::Xaml::Media::Animation::IRepositionThemeTransition, Windows::UI::Xaml::Media::Animation::IRepositionThemeTransition2> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISineEase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::SineEase> : class_type<Windows::UI::Xaml::Media::Animation::EasingFunctionBase, Windows::UI::Xaml::Media::Animation::ISineEase> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISplineDoubleKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISplineDoubleKeyFrameStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::SplineDoubleKeyFrame> : class_type<Windows::UI::Xaml::Media::Animation::DoubleKeyFrame, Windows::UI::Xaml::Media::Animation::ISplineDoubleKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IStoryboard> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IStoryboardStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::Storyboard> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IStoryboard> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ConnectedAnimationComponent> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IColorKeyFrameFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IColorKeyFrameStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IColorKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ColorKeyFrame> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::Animation::IColorKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ColorKeyFrameCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Media::Animation::ColorKeyFrame>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Media::Animation::ColorKeyFrame>>> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IConnectedAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IConnectedAnimation2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ConnectedAnimation> : class_type<Platform::Object, Windows::UI::Xaml::Media::Animation::IConnectedAnimation, Windows::UI::Xaml::Media::Animation::IConnectedAnimation2> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IConnectedAnimationService> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IConnectedAnimationServiceStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ConnectedAnimationService> : class_type<Platform::Object, Windows::UI::Xaml::Media::Animation::IConnectedAnimationService> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPointKeyFrameFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPointKeyFrameStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPointKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::PointKeyFrame> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::Animation::IPointKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::PointKeyFrameCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Media::Animation::PointKeyFrame>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Media::Animation::PointKeyFrame>>> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IColorAnimationUsingKeyFrames> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IColorAnimationUsingKeyFramesStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ColorAnimationUsingKeyFrames> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IColorAnimationUsingKeyFrames> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDiscreteColorKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::DiscreteColorKeyFrame> : class_type<Windows::UI::Xaml::Media::Animation::ColorKeyFrame, Windows::UI::Xaml::Media::Animation::IDiscreteColorKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDiscretePointKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::DiscretePointKeyFrame> : class_type<Windows::UI::Xaml::Media::Animation::PointKeyFrame, Windows::UI::Xaml::Media::Animation::IDiscretePointKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDragItemThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDragItemThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::DragItemThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IDragItemThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDragOverThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDragOverThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IDragOverThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDrillInThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDrillInThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IDrillInThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDrillOutThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDrillOutThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IDrillOutThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDropTargetItemThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDropTargetItemThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::DropTargetItemThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IDropTargetItemThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IEasingColorKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IEasingColorKeyFrameStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::EasingColorKeyFrame> : class_type<Windows::UI::Xaml::Media::Animation::ColorKeyFrame, Windows::UI::Xaml::Media::Animation::IEasingColorKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IEasingPointKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IEasingPointKeyFrameStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::EasingPointKeyFrame> : class_type<Windows::UI::Xaml::Media::Animation::PointKeyFrame, Windows::UI::Xaml::Media::Animation::IEasingPointKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IFadeInThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IFadeInThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::FadeInThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IFadeInThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IFadeOutThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IFadeOutThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::FadeOutThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IFadeOutThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ILinearColorKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::LinearColorKeyFrame> : class_type<Windows::UI::Xaml::Media::Animation::ColorKeyFrame, Windows::UI::Xaml::Media::Animation::ILinearColorKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ILinearPointKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::LinearPointKeyFrame> : class_type<Windows::UI::Xaml::Media::Animation::PointKeyFrame, Windows::UI::Xaml::Media::Animation::ILinearPointKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPointAnimationUsingKeyFrames> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPointAnimationUsingKeyFramesStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::PointAnimationUsingKeyFrames> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IPointAnimationUsingKeyFrames> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPointerDownThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPointerDownThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::PointerDownThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IPointerDownThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPointerUpThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPointerUpThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::PointerUpThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IPointerUpThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPopInThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPopInThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::PopInThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IPopInThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPopOutThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IPopOutThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::PopOutThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IPopOutThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IRepositionThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IRepositionThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::IRepositionThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISplineColorKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISplineColorKeyFrameStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::SplineColorKeyFrame> : class_type<Windows::UI::Xaml::Media::Animation::ColorKeyFrame, Windows::UI::Xaml::Media::Animation::ISplineColorKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISplinePointKeyFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISplinePointKeyFrameStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::SplinePointKeyFrame> : class_type<Windows::UI::Xaml::Media::Animation::PointKeyFrame, Windows::UI::Xaml::Media::Animation::ISplinePointKeyFrame> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISplitCloseThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISplitCloseThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::ISplitCloseThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISplitOpenThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISplitOpenThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::ISplitOpenThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISwipeBackThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISwipeBackThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::ISwipeBackThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISwipeHintThemeAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISwipeHintThemeAnimationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation> : class_type<Windows::UI::Xaml::Media::Animation::Timeline, Windows::UI::Xaml::Media::Animation::ISwipeHintThemeAnimation> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ICommonNavigationTransitionInfo> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ICommonNavigationTransitionInfoStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::CommonNavigationTransitionInfo> : class_type<Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo, Windows::UI::Xaml::Media::Animation::ICommonNavigationTransitionInfo> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IContinuumNavigationTransitionInfo> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IContinuumNavigationTransitionInfoStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo> : class_type<Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo, Windows::UI::Xaml::Media::Animation::IContinuumNavigationTransitionInfo> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IDrillInNavigationTransitionInfo> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::DrillInNavigationTransitionInfo> : class_type<Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo, Windows::UI::Xaml::Media::Animation::IDrillInNavigationTransitionInfo> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IEntranceNavigationTransitionInfo> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::IEntranceNavigationTransitionInfoStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::EntranceNavigationTransitionInfo> : class_type<Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo, Windows::UI::Xaml::Media::Animation::IEntranceNavigationTransitionInfo> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::INavigationThemeTransition> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::INavigationThemeTransitionStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::NavigationThemeTransition> : class_type<Windows::UI::Xaml::Media::Animation::Transition, Windows::UI::Xaml::Media::Animation::INavigationThemeTransition> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISlideNavigationTransitionInfo> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::SlideNavigationTransitionInfo> : class_type<Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo, Windows::UI::Xaml::Media::Animation::ISlideNavigationTransitionInfo> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::ISuppressNavigationTransitionInfo> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Animation::SuppressNavigationTransitionInfo> : class_type<Windows::UI::Xaml::Media::Animation::NavigationTransitionInfo, Windows::UI::Xaml::Media::Animation::ISuppressNavigationTransitionInfo> {};

// uuids

template<> struct uuid<Windows::UI::Xaml::Media::Animation::IKeyTimeHelper> { define_guid(0x3643E480, 0x4823, 0x466A, 0xAB, 0xE5, 0x5E, 0x79, 0xC8, 0xED, 0x77, 0xED);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IKeyTimeHelperStatics> { define_guid(0x7FA2612C, 0x22A9, 0x45E9, 0x9A, 0xF7, 0xC7, 0x41, 0x6E, 0xFF, 0xF7, 0xA5);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IRepeatBehaviorHelper> { define_guid(0x6863AB72, 0x4997, 0x47F9, 0x87, 0xAD, 0x37, 0xEF, 0xB7, 0x59, 0x93, 0xEA);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IRepeatBehaviorHelperStatics> { define_guid(0x7A795033, 0x79F3, 0x4DD9, 0xB2, 0x67, 0x9C, 0xF5, 0xF, 0xB5, 0x1F, 0x84);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ITransitionFactory> { define_guid(0xDC9AB2CF, 0x3BC9, 0x44AA, 0xB3, 0xFC, 0x88, 0x3A, 0x83, 0x23, 0x3A, 0x2C);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ITransition> { define_guid(0x3C677C7C, 0x1D0, 0x4DCE, 0xB3, 0x33, 0x97, 0x6F, 0x93, 0x31, 0x2B, 0x8);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDoubleKeyFrameFactory> { define_guid(0xAC97DEC3, 0x7538, 0x40B9, 0xB1, 0x52, 0x69, 0x6F, 0x7F, 0xBF, 0x47, 0x22);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDoubleKeyFrameStatics> { define_guid(0x324641B0, 0x7D37, 0x427A, 0xAD, 0xEB, 0x43, 0xF3, 0x8B, 0xB6, 0x1A, 0x4D);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDoubleKeyFrame> { define_guid(0x674456FD, 0xE81E, 0x4F4E, 0xB4, 0xAD, 0xA, 0xCF, 0xED, 0x9E, 0xCD, 0x68);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IObjectKeyFrameFactory> { define_guid(0x1626143E, 0x3E6D, 0x44D8, 0x9B, 0x9A, 0x4, 0xAE, 0xA7, 0xF, 0x84, 0x92);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IObjectKeyFrameStatics> { define_guid(0x2CD6AB00, 0x5319, 0x4286, 0x8E, 0xED, 0x4E, 0x75, 0x5E, 0xA0, 0xCF, 0x9C);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IObjectKeyFrame> { define_guid(0x9852A851, 0x8593, 0x48EE, 0xA6, 0xA4, 0xD5, 0xD4, 0x72, 0xF, 0x2, 0x9A);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ITimelineFactory> { define_guid(0x1D56BB07, 0xBDA4, 0x478B, 0x8A, 0xDA, 0xEB, 0x4, 0xD5, 0x80, 0xCD, 0x5E);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ITimelineStatics> { define_guid(0xA902ED4E, 0xEF10, 0x4D6F, 0x9A, 0x40, 0x93, 0xCB, 0x88, 0x95, 0xF4, 0xE5);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ITimeline> { define_guid(0xBC465DC, 0xBE4D, 0x4D0D, 0x95, 0x49, 0x22, 0x8, 0xB7, 0x15, 0xF4, 0xD);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IEasingFunctionBase> { define_guid(0xC108383F, 0x2C02, 0x4151, 0x8E, 0xCD, 0x68, 0xDD, 0xAA, 0x3F, 0xD, 0x9B);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IEasingFunctionBaseFactory> { define_guid(0x1830FE6A, 0xF01B, 0x43E0, 0xB6, 0x1F, 0xB4, 0x52, 0xA1, 0xC6, 0x6F, 0xD2);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IEasingFunctionBaseStatics> { define_guid(0x2A5031AA, 0x2C50, 0x4A1D, 0xBB, 0x4, 0xD7, 0x5E, 0x7, 0xB7, 0x15, 0x48);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IKeySpline> { define_guid(0x77A163BB, 0xD5CA, 0x4A32, 0xBA, 0xB, 0x7D, 0xFF, 0x98, 0x8E, 0x58, 0xA0);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::INavigationTransitionInfo> { define_guid(0xA9B05091, 0xAE4A, 0x4372, 0x86, 0x25, 0x21, 0xB7, 0xA8, 0xB9, 0x8C, 0xA4);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::INavigationTransitionInfoOverrides> { define_guid(0xD9517E6A, 0xA9D0, 0x4BF7, 0x9D, 0xB0, 0x46, 0x33, 0xA6, 0x9D, 0xAF, 0xF2);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::INavigationTransitionInfoFactory> { define_guid(0xEDF4F8D5, 0xAF63, 0x4FAB, 0x9D, 0x4A, 0x87, 0x92, 0x7F, 0x82, 0xDD, 0x6B);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IAddDeleteThemeTransition> { define_guid(0xADEC852E, 0x4424, 0x4DAB, 0x99, 0xC1, 0x3A, 0x4, 0xE3, 0x6A, 0x3C, 0x48);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IBackEase> { define_guid(0xE47796E7, 0xF805, 0x4A8F, 0x81, 0xC9, 0x38, 0xE6, 0x47, 0x2C, 0xAA, 0x94);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IBackEaseStatics> { define_guid(0x3C70A2FF, 0xA0A0, 0x4786, 0x92, 0x6C, 0x22, 0x32, 0x1F, 0x8F, 0x25, 0xB7);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IBeginStoryboard> { define_guid(0x64189FCD, 0x49EC, 0x4E52, 0xA6, 0xF6, 0x55, 0x32, 0x4C, 0x92, 0x10, 0x53);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IBeginStoryboardStatics> { define_guid(0x12CFF18C, 0xAA91, 0x4C4A, 0xB8, 0x2F, 0xDF, 0x34, 0xFC, 0x57, 0xF9, 0x4B);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IBounceEase> { define_guid(0x2BF1464E, 0xFC71, 0x47ED, 0x85, 0xA1, 0x3B, 0xA9, 0x57, 0x77, 0x18, 0xB4);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IBounceEaseStatics> { define_guid(0xC0701DA2, 0x4F73, 0x41C9, 0xB2, 0xCB, 0x2E, 0xA3, 0x10, 0x51, 0x7, 0xFF);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ICircleEase> { define_guid(0x53A3BDB2, 0x9177, 0x4E6E, 0xA0, 0x43, 0x50, 0x82, 0xD8, 0x89, 0xAB, 0x1F);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IColorAnimation> { define_guid(0xB8AE8A15, 0xF63, 0x4694, 0x94, 0x67, 0xBD, 0xAF, 0xAC, 0x12, 0x53, 0xEA);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IColorAnimationStatics> { define_guid(0x55EAF6E2, 0x87E3, 0x4F48, 0x95, 0x8F, 0x85, 0x5B, 0x2F, 0x9E, 0xA9, 0xEC);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IContentThemeTransition> { define_guid(0xF66FC5C3, 0x5915, 0x437D, 0x8E, 0x3B, 0xAD, 0xF8, 0xE7, 0xF0, 0xAB, 0x57);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IContentThemeTransitionStatics> { define_guid(0xE8EE385, 0x9A42, 0x4459, 0xAF, 0xA9, 0x33, 0x7D, 0xC4, 0x1E, 0x15, 0x87);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ICubicEase> { define_guid(0x1B94FC76, 0xDAD7, 0x4354, 0xB1, 0xA2, 0x79, 0x69, 0xFB, 0xF6, 0xA7, 0xD);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDiscreteDoubleKeyFrame> { define_guid(0xF5F51F3A, 0xAD11, 0x49CE, 0x8E, 0x1C, 0x8, 0xFD, 0xF1, 0x44, 0x74, 0x46);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDiscreteObjectKeyFrame> { define_guid(0xC7DCDE89, 0xF12D, 0x4A9C, 0x81, 0x99, 0xE7, 0xA9, 0xEC, 0xE3, 0xA4, 0x73);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDoubleAnimation> { define_guid(0x7E9F3D59, 0xF07, 0x4BC9, 0x97, 0x7D, 0x3, 0x76, 0x3F, 0xF8, 0x15, 0x4F);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDoubleAnimationStatics> { define_guid(0xE27A935D, 0xF111, 0x43B7, 0xB8, 0x24, 0x83, 0x2B, 0x58, 0xD7, 0x78, 0x6B);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDoubleAnimationUsingKeyFrames> { define_guid(0x4FEE628F, 0xBFEE, 0x4F75, 0x83, 0xC2, 0xA9, 0x3B, 0x39, 0x48, 0x84, 0x73);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDoubleAnimationUsingKeyFramesStatics> { define_guid(0x109BF2F6, 0xC60F, 0x49AA, 0xAB, 0xF6, 0xF6, 0x96, 0xD4, 0x92, 0x11, 0x6B);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IEasingDoubleKeyFrame> { define_guid(0x965ADB8D, 0x9A54, 0x4108, 0xB4, 0xFF, 0xB5, 0xA5, 0x21, 0x2C, 0xB3, 0x38);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IEasingDoubleKeyFrameStatics> { define_guid(0xC8D3D845, 0xDBAE, 0x4E5B, 0x8B, 0x84, 0xD9, 0x53, 0x73, 0x98, 0xE5, 0xB1);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IEdgeUIThemeTransition> { define_guid(0x5C86C19B, 0x49D7, 0x19EC, 0xCF, 0x19, 0x83, 0xA7, 0x3C, 0x6D, 0xE7, 0x5E);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IEdgeUIThemeTransitionStatics> { define_guid(0x16A2B13B, 0x4705, 0x302B, 0x27, 0xC6, 0x2A, 0xAC, 0x92, 0xF6, 0x45, 0xAC);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IElasticEase> { define_guid(0xEF5BA58C, 0xB0B6, 0x4A6C, 0x9C, 0xA8, 0xFB, 0x42, 0x33, 0xF1, 0x24, 0x59);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IElasticEaseStatics> { define_guid(0xA9F566EC, 0xFE9C, 0x4B2B, 0x8E, 0x52, 0xBB, 0x78, 0x5D, 0x56, 0x21, 0x85);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IEntranceThemeTransition> { define_guid(0x7698C09, 0xA8E3, 0x419A, 0xA0, 0x1D, 0x74, 0x10, 0xA0, 0xAE, 0x8E, 0xC8);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IEntranceThemeTransitionStatics> { define_guid(0x37CC0577, 0xFF98, 0x4AED, 0xB8, 0x6E, 0x5E, 0xC2, 0x37, 0x2, 0xF8, 0x77);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IExponentialEase> { define_guid(0x7CB9E41D, 0xF0BB, 0x4BCA, 0x9D, 0xA5, 0x9B, 0xA3, 0xA1, 0x17, 0x34, 0xC4);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IExponentialEaseStatics> { define_guid(0xF37EE7E3, 0xA761, 0x4352, 0x9A, 0xD6, 0x70, 0x79, 0x45, 0x67, 0x58, 0x1A);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ILinearDoubleKeyFrame> { define_guid(0x8EFDF265, 0x9A7B, 0x431D, 0x8F, 0xC, 0x14, 0xC5, 0x6B, 0x5E, 0xA4, 0xD9);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IObjectAnimationUsingKeyFrames> { define_guid(0x334A2D92, 0xB74A, 0x4C64, 0xB9, 0xA6, 0x58, 0xBC, 0xFA, 0x31, 0x4F, 0x22);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IObjectAnimationUsingKeyFramesStatics> { define_guid(0xEB736182, 0x6AF1, 0x49A3, 0x97, 0xB6, 0x78, 0x3E, 0xD9, 0x74, 0x0, 0xFE);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPaneThemeTransition> { define_guid(0x4708EB8E, 0x4BFC, 0xEE46, 0xD4, 0xF9, 0x70, 0x8D, 0xEF, 0x3F, 0xBB, 0x2B);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPaneThemeTransitionStatics> { define_guid(0x316B382F, 0x4BE4, 0x1797, 0xB4, 0x5C, 0xCD, 0x90, 0xB, 0xBE, 0xC, 0xAA);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPointAnimation> { define_guid(0x30F04312, 0x7726, 0x4F88, 0xB8, 0xE2, 0x2F, 0xA5, 0x45, 0x18, 0x96, 0x3B);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPointAnimationStatics> { define_guid(0x2F99B356, 0xE737, 0x408B, 0xA0, 0xFD, 0x32, 0x78, 0x26, 0xD3, 0x22, 0x55);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPopupThemeTransition> { define_guid(0x47843552, 0x4283, 0x545E, 0xC7, 0x91, 0x26, 0x8D, 0xCA, 0x22, 0xCE, 0x4B);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPopupThemeTransitionStatics> { define_guid(0xE5A1640E, 0x490D, 0x1505, 0x9F, 0x6B, 0x8F, 0xAF, 0xC0, 0x44, 0xDE, 0xC5);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPowerEase> { define_guid(0x69C80579, 0xEEDF, 0x405B, 0x86, 0x80, 0xD9, 0x60, 0x68, 0x80, 0xC9, 0x37);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPowerEaseStatics> { define_guid(0xA5955103, 0x91A2, 0x460C, 0x9C, 0x41, 0xD2, 0x8F, 0x6A, 0x93, 0x9B, 0xDA);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IQuadraticEase> { define_guid(0xE1510E91, 0xEF6D, 0x44F0, 0x80, 0x3D, 0x68, 0xD1, 0x6D, 0xE0, 0xDD, 0xFC);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IQuarticEase> { define_guid(0xE8698814, 0xFE42, 0x4A05, 0xB5, 0xB8, 0x8, 0x1F, 0x41, 0x15, 0x78, 0x15);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IQuinticEase> { define_guid(0x92EE793B, 0x3C49, 0x4108, 0xAA, 0x11, 0xAB, 0x78, 0x66, 0x3, 0xDA, 0x21);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IReorderThemeTransition> { define_guid(0xF2065C6C, 0xD052, 0x4AD1, 0x83, 0x62, 0xB7, 0x1B, 0x36, 0xDF, 0x74, 0x97);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IRepositionThemeTransition> { define_guid(0x88329B82, 0x98F3, 0x455A, 0xAC, 0x53, 0x2E, 0x70, 0x83, 0xB6, 0xE2, 0x2C);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IRepositionThemeTransition2> { define_guid(0xCEBFE864, 0xDBEA, 0x4404, 0x8E, 0x6E, 0xDE, 0x55, 0xAD, 0xA7, 0x52, 0x39);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IRepositionThemeTransitionStatics2> { define_guid(0x9240E930, 0xA19, 0x468B, 0x8C, 0x2A, 0x68, 0xFA, 0xB4, 0x50, 0x0, 0x27);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISineEase> { define_guid(0xA9382962, 0x230B, 0x49DA, 0x9E, 0xD, 0x66, 0x49, 0x87, 0x89, 0x23, 0x43);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISplineDoubleKeyFrame> { define_guid(0xD72D38, 0x6B2B, 0x4843, 0x83, 0x8E, 0xC8, 0xB1, 0x15, 0xEE, 0xC8, 0x1);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISplineDoubleKeyFrameStatics> { define_guid(0x60A8FFC, 0x975F, 0x4E4E, 0x9E, 0xC7, 0x13, 0xC5, 0xAE, 0xE0, 0x20, 0x62);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IStoryboard> { define_guid(0xD45C1E6E, 0x3594, 0x460E, 0x98, 0x1A, 0x32, 0x27, 0x1B, 0xD3, 0xAA, 0x6);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IStoryboardStatics> { define_guid(0xD82F07D8, 0x73D5, 0x4379, 0xBD, 0x48, 0x7E, 0x5, 0x18, 0x4A, 0x8B, 0xAD);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IColorKeyFrameFactory> { define_guid(0x769BD88A, 0x9CFB, 0x4A7D, 0x96, 0xC4, 0xA1, 0xE7, 0xDE, 0x6F, 0xDB, 0x4B);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IColorKeyFrameStatics> { define_guid(0xC043AE99, 0x210C, 0x430F, 0x9D, 0xA5, 0xDF, 0x10, 0x82, 0x69, 0x20, 0x55);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IColorKeyFrame> { define_guid(0xB51D82D9, 0x910, 0x4589, 0xA2, 0x84, 0xB0, 0xC9, 0x20, 0x58, 0x58, 0xE9);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IConnectedAnimation> { define_guid(0x3518628C, 0xF387, 0x4C25, 0xAC, 0x98, 0x44, 0xE8, 0x6C, 0x3C, 0xAD, 0xF0);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IConnectedAnimation2> { define_guid(0x5D2F8E5C, 0x584B, 0x4DDD, 0xB6, 0x68, 0x97, 0x38, 0x91, 0x43, 0x14, 0x59);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IConnectedAnimationService> { define_guid(0x1C6875C9, 0x19BB, 0x4D47, 0xB9, 0xAA, 0x66, 0xC8, 0x2, 0xDC, 0xB9, 0xFF);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IConnectedAnimationServiceStatics> { define_guid(0xC7078EA5, 0xD688, 0x40E8, 0x8F, 0x90, 0x96, 0xA6, 0x27, 0x92, 0x73, 0xD2);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPointKeyFrameFactory> { define_guid(0xCB214BDF, 0x426A, 0x4392, 0x83, 0x55, 0xC2, 0xAE, 0x52, 0x85, 0x26, 0x23);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPointKeyFrameStatics> { define_guid(0x95CF1B27, 0x7965, 0x4BEC, 0xB9, 0xFB, 0xFB, 0xE9, 0x4B, 0x65, 0x51, 0x8E);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPointKeyFrame> { define_guid(0xFCC88D01, 0x7F82, 0x4DAE, 0x80, 0x26, 0x7B, 0x7E, 0x8, 0x68, 0x78, 0xB3);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IColorAnimationUsingKeyFrames> { define_guid(0xF5C82640, 0x13C3, 0x42AA, 0x9A, 0xE2, 0x7E, 0x6B, 0x51, 0xC9, 0x2F, 0x95);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IColorAnimationUsingKeyFramesStatics> { define_guid(0xB4723CDC, 0x96E9, 0x48F9, 0x8D, 0x92, 0x9B, 0x64, 0x8B, 0x2F, 0x1C, 0xC6);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDiscreteColorKeyFrame> { define_guid(0x230C08F4, 0xE062, 0x4CB1, 0x8E, 0x2A, 0x14, 0x9, 0x3D, 0x73, 0xED, 0x8C);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDiscretePointKeyFrame> { define_guid(0xE0A9070D, 0x4C42, 0x4A90, 0x98, 0x3A, 0x75, 0xF5, 0xA8, 0x3A, 0x2F, 0xBE);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDragItemThemeAnimation> { define_guid(0xC7D5DB5, 0x7ED6, 0x4949, 0xB4, 0xE6, 0xA7, 0x8C, 0x9F, 0x4F, 0x97, 0x8D);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDragItemThemeAnimationStatics> { define_guid(0x6218B9F5, 0x13A, 0x4FB1, 0x86, 0xFC, 0x92, 0xBC, 0x4E, 0x8D, 0x2, 0x41);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDragOverThemeAnimation> { define_guid(0x72F762F7, 0x7E51, 0x4A6B, 0xB9, 0x37, 0xDC, 0x4B, 0x4C, 0x1C, 0x54, 0x58);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDragOverThemeAnimationStatics> { define_guid(0x146FFE57, 0x3C9D, 0x41D9, 0xA5, 0xFF, 0x8D, 0x72, 0x39, 0x51, 0x68, 0x10);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDrillInThemeAnimation> { define_guid(0xB090B824, 0xF1D2, 0x41B8, 0x87, 0xBA, 0x78, 0x3, 0x41, 0x26, 0x59, 0x4C);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDrillInThemeAnimationStatics> { define_guid(0xC61FE488, 0xA17A, 0x4B11, 0xB5, 0x3B, 0xA4, 0xF1, 0xA0, 0x7D, 0x4B, 0xA9);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDrillOutThemeAnimation> { define_guid(0xD890CCDF, 0x6D3, 0x4F7E, 0x8E, 0x4A, 0x4F, 0xB7, 0x6E, 0x25, 0x61, 0x39);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDrillOutThemeAnimationStatics> { define_guid(0xBEB5DB9B, 0x2617, 0x4888, 0x80, 0xDD, 0x72, 0xFA, 0x7B, 0xB6, 0xFA, 0xC3);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDropTargetItemThemeAnimation> { define_guid(0x1881C968, 0x1824, 0x462B, 0x87, 0xE8, 0xC3, 0x57, 0x21, 0x2B, 0x97, 0x7B);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDropTargetItemThemeAnimationStatics> { define_guid(0xAE80F486, 0x2E56, 0x4513, 0xBF, 0x18, 0xD7, 0x74, 0x70, 0x16, 0x4A, 0xE5);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IEasingColorKeyFrame> { define_guid(0xC733D630, 0xF4B9, 0x4934, 0x9B, 0xDD, 0x27, 0xAC, 0x5E, 0xD1, 0xCF, 0xD8);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IEasingColorKeyFrameStatics> { define_guid(0x6F3837FC, 0x8E3D, 0x4522, 0x9B, 0xF, 0x0, 0x3D, 0xB8, 0x60, 0x98, 0x51);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IEasingPointKeyFrame> { define_guid(0xB3C91380, 0x6868, 0x4225, 0xA7, 0xB, 0x39, 0x81, 0xCC, 0xB, 0x29, 0x47);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IEasingPointKeyFrameStatics> { define_guid(0xE22DBFC4, 0x80C, 0x402C, 0xA6, 0xB5, 0xF4, 0x8D, 0xA, 0x98, 0x11, 0x6B);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IFadeInThemeAnimation> { define_guid(0x6D4BC8F5, 0xA918, 0x4477, 0x80, 0x78, 0x55, 0x4C, 0x68, 0x81, 0x2A, 0xB8);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IFadeInThemeAnimationStatics> { define_guid(0x7F0117E1, 0xBEA9, 0x4923, 0xB2, 0x3A, 0xD, 0xDF, 0x4D, 0x7B, 0x87, 0x37);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IFadeOutThemeAnimation> { define_guid(0x89276BA9, 0xFFD4, 0x45B6, 0x9B, 0x9A, 0xCE, 0xD4, 0x89, 0x51, 0xE7, 0x12);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IFadeOutThemeAnimationStatics> { define_guid(0xFE17A81A, 0x4168, 0x4F68, 0xA2, 0x8C, 0xE5, 0xDD, 0x98, 0xCF, 0x68, 0xF);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ILinearColorKeyFrame> { define_guid(0x66FDB6EF, 0xAC81, 0x4611, 0xB1, 0xD2, 0x61, 0xF5, 0x45, 0x98, 0x3F, 0x3);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ILinearPointKeyFrame> { define_guid(0xE7C9B8EF, 0xAF24, 0x49EE, 0x84, 0xF1, 0xA8, 0x66, 0x0, 0xA4, 0xE3, 0x19);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPointAnimationUsingKeyFrames> { define_guid(0x9B944F72, 0x446A, 0x41D0, 0xA1, 0x29, 0x41, 0xA6, 0x20, 0xF4, 0x59, 0x5D);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPointAnimationUsingKeyFramesStatics> { define_guid(0x5F454C87, 0x2390, 0x46EA, 0xBA, 0xA7, 0x76, 0x2F, 0x4B, 0xC3, 0xD, 0x4);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPointerDownThemeAnimation> { define_guid(0xB58E714E, 0xC49D, 0x4788, 0xA2, 0x33, 0xA, 0xE8, 0x5D, 0x99, 0xDD, 0x5A);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPointerDownThemeAnimationStatics> { define_guid(0x63A7CB7B, 0x6D46, 0x4494, 0xB9, 0x4A, 0xE7, 0x2F, 0x3B, 0x49, 0x2A, 0x61);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPointerUpThemeAnimation> { define_guid(0xE9E9D07D, 0x6340, 0x4828, 0xAD, 0x12, 0x69, 0x6, 0x94, 0xB9, 0x91, 0xB);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPointerUpThemeAnimationStatics> { define_guid(0x7C618F9C, 0x7992, 0x4139, 0x8B, 0xFC, 0x8, 0x83, 0xB9, 0x72, 0x7A, 0x7E);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPopInThemeAnimation> { define_guid(0x196938C1, 0x1C07, 0x4C28, 0x88, 0x47, 0xF9, 0xF0, 0x55, 0xB3, 0x28, 0x55);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPopInThemeAnimationStatics> { define_guid(0xEFAA99D3, 0x218A, 0x4701, 0x97, 0x7F, 0xF1, 0xBF, 0xAE, 0x8B, 0xA6, 0x49);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPopOutThemeAnimation> { define_guid(0x4786AB49, 0xE48, 0x4E81, 0xA2, 0xE5, 0xCC, 0x5A, 0xA1, 0x9E, 0x48, 0xD3);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IPopOutThemeAnimationStatics> { define_guid(0x1D492C09, 0x3C1, 0x4490, 0x99, 0xDC, 0x90, 0x9F, 0xEA, 0xB3, 0x57, 0xFB);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IRepositionThemeAnimation> { define_guid(0xECDA24E8, 0x8945, 0x4949, 0xA1, 0xBF, 0x62, 0x10, 0x99, 0x65, 0xA7, 0xE9);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IRepositionThemeAnimationStatics> { define_guid(0x4D92B1B1, 0x860B, 0x4BF9, 0xA5, 0x9D, 0x1E, 0xB1, 0xCC, 0xBE, 0x8F, 0xE0);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISplineColorKeyFrame> { define_guid(0x1A4A5941, 0x1FE0, 0x473A, 0x8E, 0xFE, 0x43, 0x16, 0xD8, 0xC8, 0x62, 0x29);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISplineColorKeyFrameStatics> { define_guid(0x61D1D997, 0x8589, 0x4F2F, 0x8F, 0xBB, 0x7D, 0x3, 0xED, 0xC9, 0x8D, 0xD3);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISplinePointKeyFrame> { define_guid(0xF19F306, 0x7036, 0x494F, 0xBC, 0x3C, 0x78, 0xD, 0xF0, 0xCC, 0x52, 0x4A);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISplinePointKeyFrameStatics> { define_guid(0xE97A32C2, 0xA7A, 0x4766, 0x95, 0xCB, 0xD, 0x69, 0x26, 0x11, 0xCB, 0x4C);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISplitCloseThemeAnimation> { define_guid(0x4F799518, 0xFF39, 0x4E90, 0xBB, 0x74, 0x2A, 0xBD, 0x56, 0x2, 0x74, 0x2);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISplitCloseThemeAnimationStatics> { define_guid(0x7AA94DE9, 0xCC9B, 0x4E90, 0xA1, 0x1A, 0x0, 0x50, 0xA2, 0x21, 0x6A, 0x9E);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISplitOpenThemeAnimation> { define_guid(0x785FD7AA, 0x5456, 0x4639, 0x8F, 0xD2, 0x26, 0xBA, 0xE6, 0xA5, 0xFF, 0xE4);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISplitOpenThemeAnimationStatics> { define_guid(0x8D4CFA89, 0x3A91, 0x458D, 0xB0, 0xFB, 0x4C, 0xAD, 0x62, 0x5C, 0xBF, 0x8D);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISwipeBackThemeAnimation> { define_guid(0xA38A4214, 0xBCA, 0x4D2D, 0x95, 0xF7, 0xCE, 0xBA, 0x57, 0xFB, 0xAF, 0x60);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISwipeBackThemeAnimationStatics> { define_guid(0x693F31BF, 0x4DA6, 0x468A, 0x8C, 0xE0, 0x99, 0x6C, 0x9A, 0xAD, 0x42, 0xE0);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISwipeHintThemeAnimation> { define_guid(0xCDD067C0, 0x580E, 0x4E40, 0xBE, 0x98, 0xF2, 0x2, 0xD3, 0xD8, 0x43, 0x65);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISwipeHintThemeAnimationStatics> { define_guid(0x23D61A57, 0x9115, 0x4D63, 0xB0, 0x4A, 0xB8, 0x9F, 0x1C, 0x74, 0x4D, 0xC0);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ICommonNavigationTransitionInfo> { define_guid(0x50345692, 0xA555, 0x4624, 0xA3, 0x61, 0xA, 0x91, 0xC1, 0x70, 0x64, 0x73);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ICommonNavigationTransitionInfoStatics> { define_guid(0x1E3EFE33, 0x50BE, 0x4443, 0x88, 0x3C, 0xE5, 0x62, 0x72, 0x1, 0xC2, 0xE5);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IContinuumNavigationTransitionInfo> { define_guid(0x4BE1DBAD, 0x8BA6, 0x4004, 0x84, 0x38, 0x8A, 0x90, 0x17, 0x97, 0x85, 0x43);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IContinuumNavigationTransitionInfoStatics> { define_guid(0x3E25DD53, 0xB18F, 0x4BF1, 0xB3, 0xBC, 0x92, 0xF5, 0x16, 0xF2, 0x99, 0x3);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IDrillInNavigationTransitionInfo> { define_guid(0x3B86201A, 0x45D3, 0x463B, 0x93, 0x9E, 0xC8, 0x59, 0x5F, 0x43, 0x9B, 0xCC);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IEntranceNavigationTransitionInfo> { define_guid(0x720A256B, 0x1C8A, 0x41EE, 0x82, 0xEC, 0x8A, 0x87, 0xC0, 0xCF, 0x47, 0xDA);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::IEntranceNavigationTransitionInfoStatics> { define_guid(0xF948C27A, 0x40C9, 0x469F, 0x8F, 0x33, 0xBF, 0x45, 0xC8, 0x81, 0x1F, 0x21);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::INavigationThemeTransition> { define_guid(0x8833848C, 0x4EB7, 0x41F2, 0x87, 0x99, 0x9E, 0xEF, 0xA, 0x21, 0x3B, 0x73);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::INavigationThemeTransitionStatics> { define_guid(0xEA2F06E0, 0x5E60, 0x4F8E, 0xBC, 0xAF, 0x43, 0x14, 0x87, 0xA2, 0x94, 0xAB);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISlideNavigationTransitionInfo> { define_guid(0xD6AC9D77, 0x2E03, 0x405F, 0x80, 0xED, 0xE6, 0x2B, 0xEE, 0xF3, 0x66, 0x8F);};
template<> struct uuid<Windows::UI::Xaml::Media::Animation::ISuppressNavigationTransitionInfo> { define_guid(0x244D7B0C, 0xB1B7, 0x4871, 0x9D, 0x3E, 0xD5, 0x62, 0x3, 0xA3, 0xA5, 0xB4);};

// types

namespace Windows { namespace UI { namespace Xaml { namespace Media { namespace Animation {

// IKeyTimeHelper
struct IKeyTimeHelper : IInspectable, generate<IKeyTimeHelper> {};

// IKeyTimeHelperStatics
struct IKeyTimeHelperStatics : IInspectable {
	virtual STDMETHODIMP _FromTimeSpan(Foundation::TimeSpan timeSpan, KeyTime *returnValue);
};

// KeyTimeHelper
template<typename> struct KeyTimeHelper_statics {
	static KeyTime FromTimeSpan(const Foundation::TimeSpan& timeSpan) { KeyTime returnValue; hrcheck(get_activation_factory<KeyTimeHelper, IKeyTimeHelperStatics>()->_FromTimeSpan(timeSpan, &returnValue)); return returnValue; }
};

template<typename X> struct statics<KeyTimeHelper, X> : X, Windows::UI::Xaml::Media::Animation::KeyTimeHelper_statics<void> {
	typedef typename X::root_type KeyTimeHelper;
};
struct KeyTimeHelper : generate<KeyTimeHelper> {};

// IRepeatBehaviorHelper
struct IRepeatBehaviorHelper : IInspectable, generate<IRepeatBehaviorHelper> {};

// IRepeatBehaviorHelperStatics
struct IRepeatBehaviorHelperStatics : IInspectable {
	virtual STDMETHODIMP _get_Forever(RepeatBehavior *value);
	virtual STDMETHODIMP _FromCount(double count, RepeatBehavior *returnValue);
	virtual STDMETHODIMP _FromDuration(Foundation::TimeSpan duration, RepeatBehavior *returnValue);
	virtual STDMETHODIMP _GetHasCount(RepeatBehavior target, bool *value);
	virtual STDMETHODIMP _GetHasDuration(RepeatBehavior target, bool *value);
	virtual STDMETHODIMP _Equals(RepeatBehavior target, RepeatBehavior value, bool *returnValue);
};

// RepeatBehaviorHelper
template<typename> struct RepeatBehaviorHelper_statics {
	static struct _Forever : property {
		RepeatBehavior get() { RepeatBehavior value; hrcheck(get_activation_factory<RepeatBehaviorHelper, IRepeatBehaviorHelperStatics>()->_get_Forever(&value)); return value; }
		RepeatBehavior operator()() { return get(); }
		operator RepeatBehavior () { return get(); }
	} Forever;
	static RepeatBehavior FromCount(double count) { RepeatBehavior returnValue; hrcheck(get_activation_factory<RepeatBehaviorHelper, IRepeatBehaviorHelperStatics>()->_FromCount(count, &returnValue)); return returnValue; }
	static RepeatBehavior FromDuration(const Foundation::TimeSpan& duration) { RepeatBehavior returnValue; hrcheck(get_activation_factory<RepeatBehaviorHelper, IRepeatBehaviorHelperStatics>()->_FromDuration(duration, &returnValue)); return returnValue; }
	static bool GetHasCount(const RepeatBehavior& target) { bool value; hrcheck(get_activation_factory<RepeatBehaviorHelper, IRepeatBehaviorHelperStatics>()->_GetHasCount(target, &value)); return value; }
	static bool GetHasDuration(const RepeatBehavior& target) { bool value; hrcheck(get_activation_factory<RepeatBehaviorHelper, IRepeatBehaviorHelperStatics>()->_GetHasDuration(target, &value)); return value; }
	static bool Equals(const RepeatBehavior& target, const RepeatBehavior& value) { bool returnValue; hrcheck(get_activation_factory<RepeatBehaviorHelper, IRepeatBehaviorHelperStatics>()->_Equals(target, value, &returnValue)); return returnValue; }
};
template<typename X> typename RepeatBehaviorHelper_statics<X>::_Forever RepeatBehaviorHelper_statics<X>::Forever;

template<typename X> struct statics<RepeatBehaviorHelper, X> : X, Windows::UI::Xaml::Media::Animation::RepeatBehaviorHelper_statics<void> {
	typedef typename X::root_type RepeatBehaviorHelper;
};
struct RepeatBehaviorHelper : generate<RepeatBehaviorHelper> {};

// ConditionallyIndependentlyAnimatableAttribute
template<typename X> struct statics<ConditionallyIndependentlyAnimatableAttribute, X> : X {
	typedef typename X::root_type ConditionallyIndependentlyAnimatableAttribute;
};
struct ConditionallyIndependentlyAnimatableAttribute : generate<ConditionallyIndependentlyAnimatableAttribute> {};

// IndependentlyAnimatableAttribute
template<typename X> struct statics<IndependentlyAnimatableAttribute, X> : X {
	typedef typename X::root_type IndependentlyAnimatableAttribute;
};
struct IndependentlyAnimatableAttribute : generate<IndependentlyAnimatableAttribute> {};

// ITransitionFactory
struct ITransitionFactory : IInspectable, generate<ITransitionFactory> {};

// ITransition
struct ITransition : IInspectable, generate<ITransition> {};

// Transition
template<typename X> struct statics<Transition, X> : X {
	typedef typename X::root_type Transition;
};
struct Transition : generate<Transition> {};

// TransitionCollection
template<typename X> struct statics<TransitionCollection, X> : X {
	typedef typename X::root_type TransitionCollection;
};
struct TransitionCollection : generate<TransitionCollection> {};

// IDoubleKeyFrameFactory
struct IDoubleKeyFrameFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, DoubleKeyFrame* *instance);
};

// IDoubleKeyFrameStatics
struct IDoubleKeyFrameStatics : IInspectable {
	virtual STDMETHODIMP _get_ValueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_KeyTimeProperty(DependencyProperty* *value);
};

// IDoubleKeyFrame
struct IDoubleKeyFrame_raw : IInspectable {
	virtual STDMETHODIMP _get_Value(double *value);
	virtual STDMETHODIMP _put_Value(double value);
	virtual STDMETHODIMP _get_KeyTime(Animation::KeyTime *value);
	virtual STDMETHODIMP _put_KeyTime(Animation::KeyTime value);
};
template<typename X> struct IDoubleKeyFrame_adaptor : X {
	union {
		struct : property {
			Animation::KeyTime get() { Animation::KeyTime value; hrcheck(enc(&IDoubleKeyFrame_adaptor::KeyTime)->_get_KeyTime(&value)); return value; }
			Animation::KeyTime operator()() { return get(); }
			operator Animation::KeyTime () { return get(); }
			void put(const Animation::KeyTime& value) { hrcheck(enc(&IDoubleKeyFrame_adaptor::KeyTime)->_put_KeyTime(value)); }
			void operator=(const Animation::KeyTime& value) { put(value); }
			void operator()(const Animation::KeyTime& value) { put(value); }
		} KeyTime;
		struct : property {
			double get() { double value; hrcheck(enc(&IDoubleKeyFrame_adaptor::Value)->_get_Value(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IDoubleKeyFrame_adaptor::Value)->_put_Value(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Value;
	};
	IDoubleKeyFrame_adaptor() {}
};
template<typename X> struct adapt<IDoubleKeyFrame, X> : Windows::UI::Xaml::Media::Animation::IDoubleKeyFrame_adaptor<X> { typedef adapt IDoubleKeyFrame; };
struct IDoubleKeyFrame : IDoubleKeyFrame_raw, generate<IDoubleKeyFrame> {};

// DoubleKeyFrame
template<typename> struct DoubleKeyFrame_statics {
	static struct _KeyTimeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DoubleKeyFrame, IDoubleKeyFrameStatics>()->_get_KeyTimeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeyTimeProperty;
	static struct _ValueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DoubleKeyFrame, IDoubleKeyFrameStatics>()->_get_ValueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ValueProperty;
};
template<typename X> typename DoubleKeyFrame_statics<X>::_KeyTimeProperty DoubleKeyFrame_statics<X>::KeyTimeProperty;
template<typename X> typename DoubleKeyFrame_statics<X>::_ValueProperty DoubleKeyFrame_statics<X>::ValueProperty;

template<typename X> struct statics<DoubleKeyFrame, X> : X, Windows::UI::Xaml::Media::Animation::DoubleKeyFrame_statics<void> {
	typedef typename X::root_type DoubleKeyFrame;
};
struct DoubleKeyFrame : generate<DoubleKeyFrame> {};

// DoubleKeyFrameCollection
template<typename X> struct statics<DoubleKeyFrameCollection, X> : X {
	typedef typename X::root_type DoubleKeyFrameCollection;
};
struct DoubleKeyFrameCollection : generate<DoubleKeyFrameCollection> {};

// IObjectKeyFrameFactory
struct IObjectKeyFrameFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ObjectKeyFrame* *instance);
};

// IObjectKeyFrameStatics
struct IObjectKeyFrameStatics : IInspectable {
	virtual STDMETHODIMP _get_ValueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_KeyTimeProperty(DependencyProperty* *value);
};

// IObjectKeyFrame
struct IObjectKeyFrame_raw : IInspectable {
	virtual STDMETHODIMP _get_Value(IInspectable* *value);
	virtual STDMETHODIMP _put_Value(IInspectable* value);
	virtual STDMETHODIMP _get_KeyTime(Animation::KeyTime *value);
	virtual STDMETHODIMP _put_KeyTime(Animation::KeyTime value);
};
template<typename X> struct IObjectKeyFrame_adaptor : X {
	union {
		struct : property {
			Animation::KeyTime get() { Animation::KeyTime value; hrcheck(enc(&IObjectKeyFrame_adaptor::KeyTime)->_get_KeyTime(&value)); return value; }
			Animation::KeyTime operator()() { return get(); }
			operator Animation::KeyTime () { return get(); }
			void put(const Animation::KeyTime& value) { hrcheck(enc(&IObjectKeyFrame_adaptor::KeyTime)->_put_KeyTime(value)); }
			void operator=(const Animation::KeyTime& value) { put(value); }
			void operator()(const Animation::KeyTime& value) { put(value); }
		} KeyTime;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IObjectKeyFrame_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IObjectKeyFrame_adaptor::Value)->_put_Value(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Value;
	};
	IObjectKeyFrame_adaptor() {}
};
template<typename X> struct adapt<IObjectKeyFrame, X> : Windows::UI::Xaml::Media::Animation::IObjectKeyFrame_adaptor<X> { typedef adapt IObjectKeyFrame; };
struct IObjectKeyFrame : IObjectKeyFrame_raw, generate<IObjectKeyFrame> {};

// ObjectKeyFrame
template<typename> struct ObjectKeyFrame_statics {
	static struct _KeyTimeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ObjectKeyFrame, IObjectKeyFrameStatics>()->_get_KeyTimeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeyTimeProperty;
	static struct _ValueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ObjectKeyFrame, IObjectKeyFrameStatics>()->_get_ValueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ValueProperty;
};
template<typename X> typename ObjectKeyFrame_statics<X>::_KeyTimeProperty ObjectKeyFrame_statics<X>::KeyTimeProperty;
template<typename X> typename ObjectKeyFrame_statics<X>::_ValueProperty ObjectKeyFrame_statics<X>::ValueProperty;

template<typename X> struct statics<ObjectKeyFrame, X> : X, Windows::UI::Xaml::Media::Animation::ObjectKeyFrame_statics<void> {
	typedef typename X::root_type ObjectKeyFrame;
};
struct ObjectKeyFrame : generate<ObjectKeyFrame> {};

// ObjectKeyFrameCollection
template<typename X> struct statics<ObjectKeyFrameCollection, X> : X {
	typedef typename X::root_type ObjectKeyFrameCollection;
};
struct ObjectKeyFrameCollection : generate<ObjectKeyFrameCollection> {};

// ITimelineFactory
struct ITimelineFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Timeline* *instance);
};

// ITimelineStatics
struct ITimelineStatics : IInspectable {
	virtual STDMETHODIMP _get_AllowDependentAnimations(bool *value);
	virtual STDMETHODIMP _put_AllowDependentAnimations(bool value);
	virtual STDMETHODIMP _get_AutoReverseProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BeginTimeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DurationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SpeedRatioProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FillBehaviorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RepeatBehaviorProperty(DependencyProperty* *value);
};

// ITimeline
struct ITimeline_raw : IInspectable {
	virtual STDMETHODIMP _get_AutoReverse(bool *value);
	virtual STDMETHODIMP _put_AutoReverse(bool value);
	virtual STDMETHODIMP _get_BeginTime(Foundation::IReference<Foundation::TimeSpan>* *value);
	virtual STDMETHODIMP _put_BeginTime(Foundation::IReference<Foundation::TimeSpan>* value);
	virtual STDMETHODIMP _get_Duration(Xaml::Duration *value);
	virtual STDMETHODIMP _put_Duration(Xaml::Duration value);
	virtual STDMETHODIMP _get_SpeedRatio(double *value);
	virtual STDMETHODIMP _put_SpeedRatio(double value);
	virtual STDMETHODIMP _get_FillBehavior(Animation::FillBehavior *value);
	virtual STDMETHODIMP _put_FillBehavior(Animation::FillBehavior value);
	virtual STDMETHODIMP _get_RepeatBehavior(Animation::RepeatBehavior *value);
	virtual STDMETHODIMP _put_RepeatBehavior(Animation::RepeatBehavior value);
	virtual STDMETHODIMP _add_Completed(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Completed(Foundation::EventRegistrationToken token);
};
template<typename X> struct ITimeline_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITimeline_adaptor::AutoReverse)->_get_AutoReverse(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITimeline_adaptor::AutoReverse)->_put_AutoReverse(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AutoReverse;
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&ITimeline_adaptor::BeginTime)->_get_BeginTime(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&ITimeline_adaptor::BeginTime)->_put_BeginTime(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} BeginTime;
		struct : property {
			Xaml::Duration get() { Xaml::Duration value; hrcheck(enc(&ITimeline_adaptor::Duration)->_get_Duration(&value)); return value; }
			Xaml::Duration operator()() { return get(); }
			operator Xaml::Duration () { return get(); }
			void put(const Xaml::Duration& value) { hrcheck(enc(&ITimeline_adaptor::Duration)->_put_Duration(value)); }
			void operator=(const Xaml::Duration& value) { put(value); }
			void operator()(const Xaml::Duration& value) { put(value); }
		} Duration;
		struct : property {
			Animation::FillBehavior get() { Animation::FillBehavior value; hrcheck(enc(&ITimeline_adaptor::FillBehavior)->_get_FillBehavior(&value)); return value; }
			Animation::FillBehavior operator()() { return get(); }
			operator Animation::FillBehavior () { return get(); }
			void put(Animation::FillBehavior value) { hrcheck(enc(&ITimeline_adaptor::FillBehavior)->_put_FillBehavior(value)); }
			void operator=(Animation::FillBehavior value) { put(value); }
			void operator()(Animation::FillBehavior value) { put(value); }
		} FillBehavior;
		struct : property {
			Animation::RepeatBehavior get() { Animation::RepeatBehavior value; hrcheck(enc(&ITimeline_adaptor::RepeatBehavior)->_get_RepeatBehavior(&value)); return value; }
			Animation::RepeatBehavior operator()() { return get(); }
			operator Animation::RepeatBehavior () { return get(); }
			void put(const Animation::RepeatBehavior& value) { hrcheck(enc(&ITimeline_adaptor::RepeatBehavior)->_put_RepeatBehavior(value)); }
			void operator=(const Animation::RepeatBehavior& value) { put(value); }
			void operator()(const Animation::RepeatBehavior& value) { put(value); }
		} RepeatBehavior;
		struct : property {
			double get() { double value; hrcheck(enc(&ITimeline_adaptor::SpeedRatio)->_get_SpeedRatio(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ITimeline_adaptor::SpeedRatio)->_put_SpeedRatio(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} SpeedRatio;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITimeline_adaptor::Completed)->_add_Completed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITimeline_adaptor::Completed)->_remove_Completed(token)); }
		} Completed;
	};
	ITimeline_adaptor() {}
};
template<typename X> struct adapt<ITimeline, X> : Windows::UI::Xaml::Media::Animation::ITimeline_adaptor<X> { typedef adapt ITimeline; };
struct ITimeline : ITimeline_raw, generate<ITimeline> {};

// Timeline
template<typename> struct Timeline_statics {
	static struct _AllowDependentAnimations : property {
		bool get() { bool value; hrcheck(get_activation_factory<Timeline, ITimelineStatics>()->_get_AllowDependentAnimations(&value)); return value; }
		bool operator()() { return get(); }
		operator bool () { return get(); }
		void put(bool value) { hrcheck(get_activation_factory<Timeline, ITimelineStatics>()->_put_AllowDependentAnimations(value)); }
		void operator=(bool value) { put(value); }
		void operator()(bool value) { put(value); }
	} AllowDependentAnimations;
	static struct _AutoReverseProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Timeline, ITimelineStatics>()->_get_AutoReverseProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AutoReverseProperty;
	static struct _BeginTimeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Timeline, ITimelineStatics>()->_get_BeginTimeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BeginTimeProperty;
	static struct _DurationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Timeline, ITimelineStatics>()->_get_DurationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DurationProperty;
	static struct _FillBehaviorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Timeline, ITimelineStatics>()->_get_FillBehaviorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FillBehaviorProperty;
	static struct _RepeatBehaviorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Timeline, ITimelineStatics>()->_get_RepeatBehaviorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RepeatBehaviorProperty;
	static struct _SpeedRatioProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Timeline, ITimelineStatics>()->_get_SpeedRatioProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SpeedRatioProperty;
};
template<typename X> typename Timeline_statics<X>::_AllowDependentAnimations Timeline_statics<X>::AllowDependentAnimations;
template<typename X> typename Timeline_statics<X>::_AutoReverseProperty Timeline_statics<X>::AutoReverseProperty;
template<typename X> typename Timeline_statics<X>::_BeginTimeProperty Timeline_statics<X>::BeginTimeProperty;
template<typename X> typename Timeline_statics<X>::_DurationProperty Timeline_statics<X>::DurationProperty;
template<typename X> typename Timeline_statics<X>::_FillBehaviorProperty Timeline_statics<X>::FillBehaviorProperty;
template<typename X> typename Timeline_statics<X>::_RepeatBehaviorProperty Timeline_statics<X>::RepeatBehaviorProperty;
template<typename X> typename Timeline_statics<X>::_SpeedRatioProperty Timeline_statics<X>::SpeedRatioProperty;

template<typename X> struct statics<Timeline, X> : X, Windows::UI::Xaml::Media::Animation::Timeline_statics<void> {
	typedef typename X::root_type Timeline;
};
struct Timeline : generate<Timeline> {};

// TimelineCollection
template<typename X> struct statics<TimelineCollection, X> : X {
	typedef typename X::root_type TimelineCollection;
};
struct TimelineCollection : generate<TimelineCollection> {};

// IEasingFunctionBase
struct IEasingFunctionBase_raw : IInspectable {
	virtual STDMETHODIMP _get_EasingMode(Animation::EasingMode *value);
	virtual STDMETHODIMP _put_EasingMode(Animation::EasingMode value);
	virtual STDMETHODIMP _Ease(double normalizedTime, double *returnValue);
};
template<typename X> struct IEasingFunctionBase_adaptor : X {
	union {
		struct : property {
			Animation::EasingMode get() { Animation::EasingMode value; hrcheck(enc(&IEasingFunctionBase_adaptor::EasingMode)->_get_EasingMode(&value)); return value; }
			Animation::EasingMode operator()() { return get(); }
			operator Animation::EasingMode () { return get(); }
			void put(Animation::EasingMode value) { hrcheck(enc(&IEasingFunctionBase_adaptor::EasingMode)->_put_EasingMode(value)); }
			void operator=(Animation::EasingMode value) { put(value); }
			void operator()(Animation::EasingMode value) { put(value); }
		} EasingMode;
	};
	double Ease(double normalizedTime) { double returnValue; hrcheck(X::get()->_Ease(normalizedTime, &returnValue)); return returnValue; }
	IEasingFunctionBase_adaptor() {}
};
template<typename X> struct adapt<IEasingFunctionBase, X> : Windows::UI::Xaml::Media::Animation::IEasingFunctionBase_adaptor<X> { typedef adapt IEasingFunctionBase; };
struct IEasingFunctionBase : IEasingFunctionBase_raw, generate<IEasingFunctionBase> {};

// IEasingFunctionBaseFactory
struct IEasingFunctionBaseFactory : IInspectable, generate<IEasingFunctionBaseFactory> {};

// IEasingFunctionBaseStatics
struct IEasingFunctionBaseStatics : IInspectable {
	virtual STDMETHODIMP _get_EasingModeProperty(DependencyProperty* *value);
};

// EasingFunctionBase
template<typename> struct EasingFunctionBase_statics {
	static struct _EasingModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<EasingFunctionBase, IEasingFunctionBaseStatics>()->_get_EasingModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EasingModeProperty;
};
template<typename X> typename EasingFunctionBase_statics<X>::_EasingModeProperty EasingFunctionBase_statics<X>::EasingModeProperty;

template<typename X> struct statics<EasingFunctionBase, X> : X, Windows::UI::Xaml::Media::Animation::EasingFunctionBase_statics<void> {
	typedef typename X::root_type EasingFunctionBase;
};
struct EasingFunctionBase : generate<EasingFunctionBase> {};

// IKeySpline
struct IKeySpline_raw : IInspectable {
	virtual STDMETHODIMP _get_ControlPoint1(Foundation::Point *value);
	virtual STDMETHODIMP _put_ControlPoint1(Foundation::Point value);
	virtual STDMETHODIMP _get_ControlPoint2(Foundation::Point *value);
	virtual STDMETHODIMP _put_ControlPoint2(Foundation::Point value);
};
template<typename X> struct IKeySpline_adaptor : X {
	union {
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IKeySpline_adaptor::ControlPoint1)->_get_ControlPoint1(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&IKeySpline_adaptor::ControlPoint1)->_put_ControlPoint1(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} ControlPoint1;
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IKeySpline_adaptor::ControlPoint2)->_get_ControlPoint2(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&IKeySpline_adaptor::ControlPoint2)->_put_ControlPoint2(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} ControlPoint2;
	};
	IKeySpline_adaptor() {}
};
template<typename X> struct adapt<IKeySpline, X> : Windows::UI::Xaml::Media::Animation::IKeySpline_adaptor<X> { typedef adapt IKeySpline; };
struct IKeySpline : IKeySpline_raw, generate<IKeySpline> {};

// KeySpline
template<typename X> struct statics<KeySpline, X> : X {
	typedef typename X::root_type KeySpline;
};
struct KeySpline : generate<KeySpline> {};

// INavigationTransitionInfo
struct INavigationTransitionInfo : IInspectable, generate<INavigationTransitionInfo> {};

// INavigationTransitionInfoOverrides
struct INavigationTransitionInfoOverrides_raw : IInspectable {
	virtual STDMETHODIMP _GetNavigationStateCore(HSTRING *returnValue) = 0;
	virtual STDMETHODIMP _SetNavigationStateCore(HSTRING navigationState) = 0;
};
template<typename X> struct INavigationTransitionInfoOverrides_adaptor : X {
	hstring GetNavigationStateCore() { HSTRING returnValue; hrcheck(X::get()->_GetNavigationStateCore(&returnValue)); return from_abi(returnValue); }
	void SetNavigationStateCore(hstring_ref navigationState) { hrcheck(X::get()->_SetNavigationStateCore(navigationState)); }
};
template<typename X> struct adapt<INavigationTransitionInfoOverrides, X> : Windows::UI::Xaml::Media::Animation::INavigationTransitionInfoOverrides_adaptor<X> { typedef adapt INavigationTransitionInfoOverrides; };
template<typename X> struct INavigationTransitionInfoOverrides_unadaptor : X {
	STDMETHODIMP _GetNavigationStateCore(HSTRING *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetNavigationStateCore()); }); }
	STDMETHODIMP _SetNavigationStateCore(HSTRING navigationState) { return hrtry([&, this] { X::get()->SetNavigationStateCore(navigationState); }); }
};
template<typename X> struct unadapt<INavigationTransitionInfoOverrides, X> : Windows::UI::Xaml::Media::Animation::INavigationTransitionInfoOverrides_unadaptor<X> {};
struct INavigationTransitionInfoOverrides : INavigationTransitionInfoOverrides_raw, generate<INavigationTransitionInfoOverrides> {};

// INavigationTransitionInfoFactory
struct INavigationTransitionInfoFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, NavigationTransitionInfo* *instance);
};

// NavigationTransitionInfo
template<typename X> struct statics<NavigationTransitionInfo, X> : X {
	typedef typename X::root_type NavigationTransitionInfo;
};
struct NavigationTransitionInfo : generate<NavigationTransitionInfo> {};

// IAddDeleteThemeTransition
struct IAddDeleteThemeTransition : IInspectable, generate<IAddDeleteThemeTransition> {};

// AddDeleteThemeTransition
template<typename X> struct statics<AddDeleteThemeTransition, X> : X {
	typedef typename X::root_type AddDeleteThemeTransition;
};
struct AddDeleteThemeTransition : generate<AddDeleteThemeTransition> {};

// IBackEase
struct IBackEase_raw : IInspectable {
	virtual STDMETHODIMP _get_Amplitude(double *value);
	virtual STDMETHODIMP _put_Amplitude(double value);
};
template<typename X> struct IBackEase_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IBackEase_adaptor::Amplitude)->_get_Amplitude(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IBackEase_adaptor::Amplitude)->_put_Amplitude(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Amplitude;
	};
	IBackEase_adaptor() {}
};
template<typename X> struct adapt<IBackEase, X> : Windows::UI::Xaml::Media::Animation::IBackEase_adaptor<X> { typedef adapt IBackEase; };
struct IBackEase : IBackEase_raw, generate<IBackEase> {};

// IBackEaseStatics
struct IBackEaseStatics : IInspectable {
	virtual STDMETHODIMP _get_AmplitudeProperty(DependencyProperty* *value);
};

// BackEase
template<typename> struct BackEase_statics {
	static struct _AmplitudeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BackEase, IBackEaseStatics>()->_get_AmplitudeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AmplitudeProperty;
};
template<typename X> typename BackEase_statics<X>::_AmplitudeProperty BackEase_statics<X>::AmplitudeProperty;

template<typename X> struct statics<BackEase, X> : X, Windows::UI::Xaml::Media::Animation::BackEase_statics<void> {
	typedef typename X::root_type BackEase;
};
struct BackEase : generate<BackEase> {};

// IBeginStoryboard
struct IBeginStoryboard_raw : IInspectable {
	virtual STDMETHODIMP _get_Storyboard(Animation::Storyboard* *value);
	virtual STDMETHODIMP _put_Storyboard(Animation::Storyboard* value);
};
template<typename X> struct IBeginStoryboard_adaptor : X {
	union {
		struct : property {
			ptr<Animation::Storyboard> get() { Animation::Storyboard* value; hrcheck(enc(&IBeginStoryboard_adaptor::Storyboard)->_get_Storyboard(&value)); return from_abi(value); }
			ptr<Animation::Storyboard> operator()() { return get(); }
			operator ptr<Animation::Storyboard> () { return get(); }
			ptr<Animation::Storyboard> operator->() { return get(); }
			void put(pptr<Animation::Storyboard> value) { hrcheck(enc(&IBeginStoryboard_adaptor::Storyboard)->_put_Storyboard(value)); }
			void operator=(pptr<Animation::Storyboard> value) { put(value); }
			void operator()(pptr<Animation::Storyboard> value) { put(value); }
		} Storyboard;
	};
	IBeginStoryboard_adaptor() {}
};
template<typename X> struct adapt<IBeginStoryboard, X> : Windows::UI::Xaml::Media::Animation::IBeginStoryboard_adaptor<X> { typedef adapt IBeginStoryboard; };
struct IBeginStoryboard : IBeginStoryboard_raw, generate<IBeginStoryboard> {};

// IBeginStoryboardStatics
struct IBeginStoryboardStatics : IInspectable {
	virtual STDMETHODIMP _get_StoryboardProperty(DependencyProperty* *value);
};

// BeginStoryboard
template<typename> struct BeginStoryboard_statics {
	static struct _StoryboardProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BeginStoryboard, IBeginStoryboardStatics>()->_get_StoryboardProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StoryboardProperty;
};
template<typename X> typename BeginStoryboard_statics<X>::_StoryboardProperty BeginStoryboard_statics<X>::StoryboardProperty;

template<typename X> struct statics<BeginStoryboard, X> : X, Windows::UI::Xaml::Media::Animation::BeginStoryboard_statics<void> {
	typedef typename X::root_type BeginStoryboard;
};
struct BeginStoryboard : generate<BeginStoryboard> {};

// IBounceEase
struct IBounceEase_raw : IInspectable {
	virtual STDMETHODIMP _get_Bounces(int *value);
	virtual STDMETHODIMP _put_Bounces(int value);
	virtual STDMETHODIMP _get_Bounciness(double *value);
	virtual STDMETHODIMP _put_Bounciness(double value);
};
template<typename X> struct IBounceEase_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IBounceEase_adaptor::Bounces)->_get_Bounces(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IBounceEase_adaptor::Bounces)->_put_Bounces(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} Bounces;
		struct : property {
			double get() { double value; hrcheck(enc(&IBounceEase_adaptor::Bounciness)->_get_Bounciness(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IBounceEase_adaptor::Bounciness)->_put_Bounciness(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Bounciness;
	};
	IBounceEase_adaptor() {}
};
template<typename X> struct adapt<IBounceEase, X> : Windows::UI::Xaml::Media::Animation::IBounceEase_adaptor<X> { typedef adapt IBounceEase; };
struct IBounceEase : IBounceEase_raw, generate<IBounceEase> {};

// IBounceEaseStatics
struct IBounceEaseStatics : IInspectable {
	virtual STDMETHODIMP _get_BouncesProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BouncinessProperty(DependencyProperty* *value);
};

// BounceEase
template<typename> struct BounceEase_statics {
	static struct _BouncesProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BounceEase, IBounceEaseStatics>()->_get_BouncesProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BouncesProperty;
	static struct _BouncinessProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BounceEase, IBounceEaseStatics>()->_get_BouncinessProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BouncinessProperty;
};
template<typename X> typename BounceEase_statics<X>::_BouncesProperty BounceEase_statics<X>::BouncesProperty;
template<typename X> typename BounceEase_statics<X>::_BouncinessProperty BounceEase_statics<X>::BouncinessProperty;

template<typename X> struct statics<BounceEase, X> : X, Windows::UI::Xaml::Media::Animation::BounceEase_statics<void> {
	typedef typename X::root_type BounceEase;
};
struct BounceEase : generate<BounceEase> {};

// ICircleEase
struct ICircleEase : IInspectable, generate<ICircleEase> {};

// CircleEase
template<typename X> struct statics<CircleEase, X> : X {
	typedef typename X::root_type CircleEase;
};
struct CircleEase : generate<CircleEase> {};

// IColorAnimation
struct IColorAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_From(Foundation::IReference<Color>* *value);
	virtual STDMETHODIMP _put_From(Foundation::IReference<Color>* value);
	virtual STDMETHODIMP _get_To(Foundation::IReference<Color>* *value);
	virtual STDMETHODIMP _put_To(Foundation::IReference<Color>* value);
	virtual STDMETHODIMP _get_By(Foundation::IReference<Color>* *value);
	virtual STDMETHODIMP _put_By(Foundation::IReference<Color>* value);
	virtual STDMETHODIMP _get_EasingFunction(EasingFunctionBase* *value);
	virtual STDMETHODIMP _put_EasingFunction(EasingFunctionBase* value);
	virtual STDMETHODIMP _get_EnableDependentAnimation(bool *value);
	virtual STDMETHODIMP _put_EnableDependentAnimation(bool value);
};
template<typename X> struct IColorAnimation_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Color>> get() { Foundation::IReference<Color>* value; hrcheck(enc(&IColorAnimation_adaptor::By)->_get_By(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Color>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Color>> () { return get(); }
			ptr<Foundation::IReference<Color>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Color>> value) { hrcheck(enc(&IColorAnimation_adaptor::By)->_put_By(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Color>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Color>> value) { put(to_abi(value)); }
		} By;
		struct : property {
			ptr<EasingFunctionBase> get() { EasingFunctionBase* value; hrcheck(enc(&IColorAnimation_adaptor::EasingFunction)->_get_EasingFunction(&value)); return from_abi(value); }
			ptr<EasingFunctionBase> operator()() { return get(); }
			operator ptr<EasingFunctionBase> () { return get(); }
			ptr<EasingFunctionBase> operator->() { return get(); }
			void put(pptr<EasingFunctionBase> value) { hrcheck(enc(&IColorAnimation_adaptor::EasingFunction)->_put_EasingFunction(value)); }
			void operator=(pptr<EasingFunctionBase> value) { put(value); }
			void operator()(pptr<EasingFunctionBase> value) { put(value); }
		} EasingFunction;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IColorAnimation_adaptor::EnableDependentAnimation)->_get_EnableDependentAnimation(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IColorAnimation_adaptor::EnableDependentAnimation)->_put_EnableDependentAnimation(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} EnableDependentAnimation;
		struct : property {
			ptr<Foundation::IReference<Color>> get() { Foundation::IReference<Color>* value; hrcheck(enc(&IColorAnimation_adaptor::From)->_get_From(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Color>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Color>> () { return get(); }
			ptr<Foundation::IReference<Color>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Color>> value) { hrcheck(enc(&IColorAnimation_adaptor::From)->_put_From(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Color>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Color>> value) { put(to_abi(value)); }
		} From;
		struct : property {
			ptr<Foundation::IReference<Color>> get() { Foundation::IReference<Color>* value; hrcheck(enc(&IColorAnimation_adaptor::To)->_get_To(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Color>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Color>> () { return get(); }
			ptr<Foundation::IReference<Color>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Color>> value) { hrcheck(enc(&IColorAnimation_adaptor::To)->_put_To(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Color>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Color>> value) { put(to_abi(value)); }
		} To;
	};
	IColorAnimation_adaptor() {}
};
template<typename X> struct adapt<IColorAnimation, X> : Windows::UI::Xaml::Media::Animation::IColorAnimation_adaptor<X> { typedef adapt IColorAnimation; };
struct IColorAnimation : IColorAnimation_raw, generate<IColorAnimation> {};

// IColorAnimationStatics
struct IColorAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_FromProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ToProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ByProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_EasingFunctionProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_EnableDependentAnimationProperty(DependencyProperty* *value);
};

// ColorAnimation
template<typename> struct ColorAnimation_statics {
	static struct _ByProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorAnimation, IColorAnimationStatics>()->_get_ByProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ByProperty;
	static struct _EasingFunctionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorAnimation, IColorAnimationStatics>()->_get_EasingFunctionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EasingFunctionProperty;
	static struct _EnableDependentAnimationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorAnimation, IColorAnimationStatics>()->_get_EnableDependentAnimationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EnableDependentAnimationProperty;
	static struct _FromProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorAnimation, IColorAnimationStatics>()->_get_FromProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FromProperty;
	static struct _ToProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorAnimation, IColorAnimationStatics>()->_get_ToProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ToProperty;
};
template<typename X> typename ColorAnimation_statics<X>::_ByProperty ColorAnimation_statics<X>::ByProperty;
template<typename X> typename ColorAnimation_statics<X>::_EasingFunctionProperty ColorAnimation_statics<X>::EasingFunctionProperty;
template<typename X> typename ColorAnimation_statics<X>::_EnableDependentAnimationProperty ColorAnimation_statics<X>::EnableDependentAnimationProperty;
template<typename X> typename ColorAnimation_statics<X>::_FromProperty ColorAnimation_statics<X>::FromProperty;
template<typename X> typename ColorAnimation_statics<X>::_ToProperty ColorAnimation_statics<X>::ToProperty;

template<typename X> struct statics<ColorAnimation, X> : X, Windows::UI::Xaml::Media::Animation::ColorAnimation_statics<void> {
	typedef typename X::root_type ColorAnimation;
};
struct ColorAnimation : generate<ColorAnimation> {};

// IContentThemeTransition
struct IContentThemeTransition_raw : IInspectable {
	virtual STDMETHODIMP _get_HorizontalOffset(double *value);
	virtual STDMETHODIMP _put_HorizontalOffset(double value);
	virtual STDMETHODIMP _get_VerticalOffset(double *value);
	virtual STDMETHODIMP _put_VerticalOffset(double value);
};
template<typename X> struct IContentThemeTransition_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IContentThemeTransition_adaptor::HorizontalOffset)->_get_HorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IContentThemeTransition_adaptor::HorizontalOffset)->_put_HorizontalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} HorizontalOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IContentThemeTransition_adaptor::VerticalOffset)->_get_VerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IContentThemeTransition_adaptor::VerticalOffset)->_put_VerticalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} VerticalOffset;
	};
	IContentThemeTransition_adaptor() {}
};
template<typename X> struct adapt<IContentThemeTransition, X> : Windows::UI::Xaml::Media::Animation::IContentThemeTransition_adaptor<X> { typedef adapt IContentThemeTransition; };
struct IContentThemeTransition : IContentThemeTransition_raw, generate<IContentThemeTransition> {};

// IContentThemeTransitionStatics
struct IContentThemeTransitionStatics : IInspectable {
	virtual STDMETHODIMP _get_HorizontalOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalOffsetProperty(DependencyProperty* *value);
};

// ContentThemeTransition
template<typename> struct ContentThemeTransition_statics {
	static struct _HorizontalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentThemeTransition, IContentThemeTransitionStatics>()->_get_HorizontalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalOffsetProperty;
	static struct _VerticalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentThemeTransition, IContentThemeTransitionStatics>()->_get_VerticalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalOffsetProperty;
};
template<typename X> typename ContentThemeTransition_statics<X>::_HorizontalOffsetProperty ContentThemeTransition_statics<X>::HorizontalOffsetProperty;
template<typename X> typename ContentThemeTransition_statics<X>::_VerticalOffsetProperty ContentThemeTransition_statics<X>::VerticalOffsetProperty;

template<typename X> struct statics<ContentThemeTransition, X> : X, Windows::UI::Xaml::Media::Animation::ContentThemeTransition_statics<void> {
	typedef typename X::root_type ContentThemeTransition;
};
struct ContentThemeTransition : generate<ContentThemeTransition> {};

// ICubicEase
struct ICubicEase : IInspectable, generate<ICubicEase> {};

// CubicEase
template<typename X> struct statics<CubicEase, X> : X {
	typedef typename X::root_type CubicEase;
};
struct CubicEase : generate<CubicEase> {};

// IDiscreteDoubleKeyFrame
struct IDiscreteDoubleKeyFrame : IInspectable, generate<IDiscreteDoubleKeyFrame> {};

// DiscreteDoubleKeyFrame
template<typename X> struct statics<DiscreteDoubleKeyFrame, X> : X {
	typedef typename X::root_type DiscreteDoubleKeyFrame;
};
struct DiscreteDoubleKeyFrame : generate<DiscreteDoubleKeyFrame> {};

// IDiscreteObjectKeyFrame
struct IDiscreteObjectKeyFrame : IInspectable, generate<IDiscreteObjectKeyFrame> {};

// DiscreteObjectKeyFrame
template<typename X> struct statics<DiscreteObjectKeyFrame, X> : X {
	typedef typename X::root_type DiscreteObjectKeyFrame;
};
struct DiscreteObjectKeyFrame : generate<DiscreteObjectKeyFrame> {};

// IDoubleAnimation
struct IDoubleAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_From(Foundation::IReference<double>* *value);
	virtual STDMETHODIMP _put_From(Foundation::IReference<double>* value);
	virtual STDMETHODIMP _get_To(Foundation::IReference<double>* *value);
	virtual STDMETHODIMP _put_To(Foundation::IReference<double>* value);
	virtual STDMETHODIMP _get_By(Foundation::IReference<double>* *value);
	virtual STDMETHODIMP _put_By(Foundation::IReference<double>* value);
	virtual STDMETHODIMP _get_EasingFunction(EasingFunctionBase* *value);
	virtual STDMETHODIMP _put_EasingFunction(EasingFunctionBase* value);
	virtual STDMETHODIMP _get_EnableDependentAnimation(bool *value);
	virtual STDMETHODIMP _put_EnableDependentAnimation(bool value);
};
template<typename X> struct IDoubleAnimation_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<double>> get() { Foundation::IReference<double>* value; hrcheck(enc(&IDoubleAnimation_adaptor::By)->_get_By(&value)); return from_abi(value); }
			ptr<Foundation::IReference<double>> operator()() { return get(); }
			operator ptr<Foundation::IReference<double>> () { return get(); }
			ptr<Foundation::IReference<double>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<double>> value) { hrcheck(enc(&IDoubleAnimation_adaptor::By)->_put_By(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<double>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<double>> value) { put(to_abi(value)); }
		} By;
		struct : property {
			ptr<EasingFunctionBase> get() { EasingFunctionBase* value; hrcheck(enc(&IDoubleAnimation_adaptor::EasingFunction)->_get_EasingFunction(&value)); return from_abi(value); }
			ptr<EasingFunctionBase> operator()() { return get(); }
			operator ptr<EasingFunctionBase> () { return get(); }
			ptr<EasingFunctionBase> operator->() { return get(); }
			void put(pptr<EasingFunctionBase> value) { hrcheck(enc(&IDoubleAnimation_adaptor::EasingFunction)->_put_EasingFunction(value)); }
			void operator=(pptr<EasingFunctionBase> value) { put(value); }
			void operator()(pptr<EasingFunctionBase> value) { put(value); }
		} EasingFunction;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDoubleAnimation_adaptor::EnableDependentAnimation)->_get_EnableDependentAnimation(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDoubleAnimation_adaptor::EnableDependentAnimation)->_put_EnableDependentAnimation(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} EnableDependentAnimation;
		struct : property {
			ptr<Foundation::IReference<double>> get() { Foundation::IReference<double>* value; hrcheck(enc(&IDoubleAnimation_adaptor::From)->_get_From(&value)); return from_abi(value); }
			ptr<Foundation::IReference<double>> operator()() { return get(); }
			operator ptr<Foundation::IReference<double>> () { return get(); }
			ptr<Foundation::IReference<double>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<double>> value) { hrcheck(enc(&IDoubleAnimation_adaptor::From)->_put_From(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<double>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<double>> value) { put(to_abi(value)); }
		} From;
		struct : property {
			ptr<Foundation::IReference<double>> get() { Foundation::IReference<double>* value; hrcheck(enc(&IDoubleAnimation_adaptor::To)->_get_To(&value)); return from_abi(value); }
			ptr<Foundation::IReference<double>> operator()() { return get(); }
			operator ptr<Foundation::IReference<double>> () { return get(); }
			ptr<Foundation::IReference<double>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<double>> value) { hrcheck(enc(&IDoubleAnimation_adaptor::To)->_put_To(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<double>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<double>> value) { put(to_abi(value)); }
		} To;
	};
	IDoubleAnimation_adaptor() {}
};
template<typename X> struct adapt<IDoubleAnimation, X> : Windows::UI::Xaml::Media::Animation::IDoubleAnimation_adaptor<X> { typedef adapt IDoubleAnimation; };
struct IDoubleAnimation : IDoubleAnimation_raw, generate<IDoubleAnimation> {};

// IDoubleAnimationStatics
struct IDoubleAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_FromProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ToProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ByProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_EasingFunctionProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_EnableDependentAnimationProperty(DependencyProperty* *value);
};

// DoubleAnimation
template<typename> struct DoubleAnimation_statics {
	static struct _ByProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DoubleAnimation, IDoubleAnimationStatics>()->_get_ByProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ByProperty;
	static struct _EasingFunctionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DoubleAnimation, IDoubleAnimationStatics>()->_get_EasingFunctionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EasingFunctionProperty;
	static struct _EnableDependentAnimationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DoubleAnimation, IDoubleAnimationStatics>()->_get_EnableDependentAnimationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EnableDependentAnimationProperty;
	static struct _FromProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DoubleAnimation, IDoubleAnimationStatics>()->_get_FromProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FromProperty;
	static struct _ToProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DoubleAnimation, IDoubleAnimationStatics>()->_get_ToProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ToProperty;
};
template<typename X> typename DoubleAnimation_statics<X>::_ByProperty DoubleAnimation_statics<X>::ByProperty;
template<typename X> typename DoubleAnimation_statics<X>::_EasingFunctionProperty DoubleAnimation_statics<X>::EasingFunctionProperty;
template<typename X> typename DoubleAnimation_statics<X>::_EnableDependentAnimationProperty DoubleAnimation_statics<X>::EnableDependentAnimationProperty;
template<typename X> typename DoubleAnimation_statics<X>::_FromProperty DoubleAnimation_statics<X>::FromProperty;
template<typename X> typename DoubleAnimation_statics<X>::_ToProperty DoubleAnimation_statics<X>::ToProperty;

template<typename X> struct statics<DoubleAnimation, X> : X, Windows::UI::Xaml::Media::Animation::DoubleAnimation_statics<void> {
	typedef typename X::root_type DoubleAnimation;
};
struct DoubleAnimation : generate<DoubleAnimation> {};

// IDoubleAnimationUsingKeyFrames
struct IDoubleAnimationUsingKeyFrames_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyFrames(DoubleKeyFrameCollection* *value);
	virtual STDMETHODIMP _get_EnableDependentAnimation(bool *value);
	virtual STDMETHODIMP _put_EnableDependentAnimation(bool value);
};
template<typename X> struct IDoubleAnimationUsingKeyFrames_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDoubleAnimationUsingKeyFrames_adaptor::EnableDependentAnimation)->_get_EnableDependentAnimation(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDoubleAnimationUsingKeyFrames_adaptor::EnableDependentAnimation)->_put_EnableDependentAnimation(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} EnableDependentAnimation;
		struct : property {
			ptr<DoubleKeyFrameCollection> get() { DoubleKeyFrameCollection* value; hrcheck(enc(&IDoubleAnimationUsingKeyFrames_adaptor::KeyFrames)->_get_KeyFrames(&value)); return from_abi(value); }
			ptr<DoubleKeyFrameCollection> operator()() { return get(); }
			operator ptr<DoubleKeyFrameCollection> () { return get(); }
			ptr<DoubleKeyFrameCollection> operator->() { return get(); }
		} KeyFrames;
	};
	IDoubleAnimationUsingKeyFrames_adaptor() {}
};
template<typename X> struct adapt<IDoubleAnimationUsingKeyFrames, X> : Windows::UI::Xaml::Media::Animation::IDoubleAnimationUsingKeyFrames_adaptor<X> { typedef adapt IDoubleAnimationUsingKeyFrames; };
struct IDoubleAnimationUsingKeyFrames : IDoubleAnimationUsingKeyFrames_raw, generate<IDoubleAnimationUsingKeyFrames> {};

// IDoubleAnimationUsingKeyFramesStatics
struct IDoubleAnimationUsingKeyFramesStatics : IInspectable {
	virtual STDMETHODIMP _get_EnableDependentAnimationProperty(DependencyProperty* *value);
};

// DoubleAnimationUsingKeyFrames
template<typename> struct DoubleAnimationUsingKeyFrames_statics {
	static struct _EnableDependentAnimationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DoubleAnimationUsingKeyFrames, IDoubleAnimationUsingKeyFramesStatics>()->_get_EnableDependentAnimationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EnableDependentAnimationProperty;
};
template<typename X> typename DoubleAnimationUsingKeyFrames_statics<X>::_EnableDependentAnimationProperty DoubleAnimationUsingKeyFrames_statics<X>::EnableDependentAnimationProperty;

template<typename X> struct statics<DoubleAnimationUsingKeyFrames, X> : X, Windows::UI::Xaml::Media::Animation::DoubleAnimationUsingKeyFrames_statics<void> {
	typedef typename X::root_type DoubleAnimationUsingKeyFrames;
};
struct DoubleAnimationUsingKeyFrames : generate<DoubleAnimationUsingKeyFrames> {};

// IEasingDoubleKeyFrame
struct IEasingDoubleKeyFrame_raw : IInspectable {
	virtual STDMETHODIMP _get_EasingFunction(EasingFunctionBase* *value);
	virtual STDMETHODIMP _put_EasingFunction(EasingFunctionBase* value);
};
template<typename X> struct IEasingDoubleKeyFrame_adaptor : X {
	union {
		struct : property {
			ptr<EasingFunctionBase> get() { EasingFunctionBase* value; hrcheck(enc(&IEasingDoubleKeyFrame_adaptor::EasingFunction)->_get_EasingFunction(&value)); return from_abi(value); }
			ptr<EasingFunctionBase> operator()() { return get(); }
			operator ptr<EasingFunctionBase> () { return get(); }
			ptr<EasingFunctionBase> operator->() { return get(); }
			void put(pptr<EasingFunctionBase> value) { hrcheck(enc(&IEasingDoubleKeyFrame_adaptor::EasingFunction)->_put_EasingFunction(value)); }
			void operator=(pptr<EasingFunctionBase> value) { put(value); }
			void operator()(pptr<EasingFunctionBase> value) { put(value); }
		} EasingFunction;
	};
	IEasingDoubleKeyFrame_adaptor() {}
};
template<typename X> struct adapt<IEasingDoubleKeyFrame, X> : Windows::UI::Xaml::Media::Animation::IEasingDoubleKeyFrame_adaptor<X> { typedef adapt IEasingDoubleKeyFrame; };
struct IEasingDoubleKeyFrame : IEasingDoubleKeyFrame_raw, generate<IEasingDoubleKeyFrame> {};

// IEasingDoubleKeyFrameStatics
struct IEasingDoubleKeyFrameStatics : IInspectable {
	virtual STDMETHODIMP _get_EasingFunctionProperty(DependencyProperty* *value);
};

// EasingDoubleKeyFrame
template<typename> struct EasingDoubleKeyFrame_statics {
	static struct _EasingFunctionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<EasingDoubleKeyFrame, IEasingDoubleKeyFrameStatics>()->_get_EasingFunctionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EasingFunctionProperty;
};
template<typename X> typename EasingDoubleKeyFrame_statics<X>::_EasingFunctionProperty EasingDoubleKeyFrame_statics<X>::EasingFunctionProperty;

template<typename X> struct statics<EasingDoubleKeyFrame, X> : X, Windows::UI::Xaml::Media::Animation::EasingDoubleKeyFrame_statics<void> {
	typedef typename X::root_type EasingDoubleKeyFrame;
};
struct EasingDoubleKeyFrame : generate<EasingDoubleKeyFrame> {};

// IEdgeUIThemeTransition
struct IEdgeUIThemeTransition_raw : IInspectable {
	virtual STDMETHODIMP _get_Edge(Controls::Primitives::EdgeTransitionLocation *value);
	virtual STDMETHODIMP _put_Edge(Controls::Primitives::EdgeTransitionLocation value);
};
template<typename X> struct IEdgeUIThemeTransition_adaptor : X {
	union {
		struct : property {
			Controls::Primitives::EdgeTransitionLocation get() { Controls::Primitives::EdgeTransitionLocation value; hrcheck(enc(&IEdgeUIThemeTransition_adaptor::Edge)->_get_Edge(&value)); return value; }
			Controls::Primitives::EdgeTransitionLocation operator()() { return get(); }
			operator Controls::Primitives::EdgeTransitionLocation () { return get(); }
			void put(Controls::Primitives::EdgeTransitionLocation value) { hrcheck(enc(&IEdgeUIThemeTransition_adaptor::Edge)->_put_Edge(value)); }
			void operator=(Controls::Primitives::EdgeTransitionLocation value) { put(value); }
			void operator()(Controls::Primitives::EdgeTransitionLocation value) { put(value); }
		} Edge;
	};
	IEdgeUIThemeTransition_adaptor() {}
};
template<typename X> struct adapt<IEdgeUIThemeTransition, X> : Windows::UI::Xaml::Media::Animation::IEdgeUIThemeTransition_adaptor<X> { typedef adapt IEdgeUIThemeTransition; };
struct IEdgeUIThemeTransition : IEdgeUIThemeTransition_raw, generate<IEdgeUIThemeTransition> {};

// IEdgeUIThemeTransitionStatics
struct IEdgeUIThemeTransitionStatics : IInspectable {
	virtual STDMETHODIMP _get_EdgeProperty(DependencyProperty* *value);
};

// EdgeUIThemeTransition
template<typename> struct EdgeUIThemeTransition_statics {
	static struct _EdgeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<EdgeUIThemeTransition, IEdgeUIThemeTransitionStatics>()->_get_EdgeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EdgeProperty;
};
template<typename X> typename EdgeUIThemeTransition_statics<X>::_EdgeProperty EdgeUIThemeTransition_statics<X>::EdgeProperty;

template<typename X> struct statics<EdgeUIThemeTransition, X> : X, Windows::UI::Xaml::Media::Animation::EdgeUIThemeTransition_statics<void> {
	typedef typename X::root_type EdgeUIThemeTransition;
};
struct EdgeUIThemeTransition : generate<EdgeUIThemeTransition> {};

// IElasticEase
struct IElasticEase_raw : IInspectable {
	virtual STDMETHODIMP _get_Oscillations(int *value);
	virtual STDMETHODIMP _put_Oscillations(int value);
	virtual STDMETHODIMP _get_Springiness(double *value);
	virtual STDMETHODIMP _put_Springiness(double value);
};
template<typename X> struct IElasticEase_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IElasticEase_adaptor::Oscillations)->_get_Oscillations(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IElasticEase_adaptor::Oscillations)->_put_Oscillations(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} Oscillations;
		struct : property {
			double get() { double value; hrcheck(enc(&IElasticEase_adaptor::Springiness)->_get_Springiness(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IElasticEase_adaptor::Springiness)->_put_Springiness(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Springiness;
	};
	IElasticEase_adaptor() {}
};
template<typename X> struct adapt<IElasticEase, X> : Windows::UI::Xaml::Media::Animation::IElasticEase_adaptor<X> { typedef adapt IElasticEase; };
struct IElasticEase : IElasticEase_raw, generate<IElasticEase> {};

// IElasticEaseStatics
struct IElasticEaseStatics : IInspectable {
	virtual STDMETHODIMP _get_OscillationsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SpringinessProperty(DependencyProperty* *value);
};

// ElasticEase
template<typename> struct ElasticEase_statics {
	static struct _OscillationsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ElasticEase, IElasticEaseStatics>()->_get_OscillationsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OscillationsProperty;
	static struct _SpringinessProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ElasticEase, IElasticEaseStatics>()->_get_SpringinessProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SpringinessProperty;
};
template<typename X> typename ElasticEase_statics<X>::_OscillationsProperty ElasticEase_statics<X>::OscillationsProperty;
template<typename X> typename ElasticEase_statics<X>::_SpringinessProperty ElasticEase_statics<X>::SpringinessProperty;

template<typename X> struct statics<ElasticEase, X> : X, Windows::UI::Xaml::Media::Animation::ElasticEase_statics<void> {
	typedef typename X::root_type ElasticEase;
};
struct ElasticEase : generate<ElasticEase> {};

// IEntranceThemeTransition
struct IEntranceThemeTransition_raw : IInspectable {
	virtual STDMETHODIMP _get_FromHorizontalOffset(double *value);
	virtual STDMETHODIMP _put_FromHorizontalOffset(double value);
	virtual STDMETHODIMP _get_FromVerticalOffset(double *value);
	virtual STDMETHODIMP _put_FromVerticalOffset(double value);
	virtual STDMETHODIMP _get_IsStaggeringEnabled(bool *value);
	virtual STDMETHODIMP _put_IsStaggeringEnabled(bool value);
};
template<typename X> struct IEntranceThemeTransition_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IEntranceThemeTransition_adaptor::FromHorizontalOffset)->_get_FromHorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IEntranceThemeTransition_adaptor::FromHorizontalOffset)->_put_FromHorizontalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FromHorizontalOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IEntranceThemeTransition_adaptor::FromVerticalOffset)->_get_FromVerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IEntranceThemeTransition_adaptor::FromVerticalOffset)->_put_FromVerticalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FromVerticalOffset;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IEntranceThemeTransition_adaptor::IsStaggeringEnabled)->_get_IsStaggeringEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IEntranceThemeTransition_adaptor::IsStaggeringEnabled)->_put_IsStaggeringEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsStaggeringEnabled;
	};
	IEntranceThemeTransition_adaptor() {}
};
template<typename X> struct adapt<IEntranceThemeTransition, X> : Windows::UI::Xaml::Media::Animation::IEntranceThemeTransition_adaptor<X> { typedef adapt IEntranceThemeTransition; };
struct IEntranceThemeTransition : IEntranceThemeTransition_raw, generate<IEntranceThemeTransition> {};

// IEntranceThemeTransitionStatics
struct IEntranceThemeTransitionStatics : IInspectable {
	virtual STDMETHODIMP _get_FromHorizontalOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FromVerticalOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsStaggeringEnabledProperty(DependencyProperty* *value);
};

// EntranceThemeTransition
template<typename> struct EntranceThemeTransition_statics {
	static struct _FromHorizontalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<EntranceThemeTransition, IEntranceThemeTransitionStatics>()->_get_FromHorizontalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FromHorizontalOffsetProperty;
	static struct _FromVerticalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<EntranceThemeTransition, IEntranceThemeTransitionStatics>()->_get_FromVerticalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FromVerticalOffsetProperty;
	static struct _IsStaggeringEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<EntranceThemeTransition, IEntranceThemeTransitionStatics>()->_get_IsStaggeringEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsStaggeringEnabledProperty;
};
template<typename X> typename EntranceThemeTransition_statics<X>::_FromHorizontalOffsetProperty EntranceThemeTransition_statics<X>::FromHorizontalOffsetProperty;
template<typename X> typename EntranceThemeTransition_statics<X>::_FromVerticalOffsetProperty EntranceThemeTransition_statics<X>::FromVerticalOffsetProperty;
template<typename X> typename EntranceThemeTransition_statics<X>::_IsStaggeringEnabledProperty EntranceThemeTransition_statics<X>::IsStaggeringEnabledProperty;

template<typename X> struct statics<EntranceThemeTransition, X> : X, Windows::UI::Xaml::Media::Animation::EntranceThemeTransition_statics<void> {
	typedef typename X::root_type EntranceThemeTransition;
};
struct EntranceThemeTransition : generate<EntranceThemeTransition> {};

// IExponentialEase
struct IExponentialEase_raw : IInspectable {
	virtual STDMETHODIMP _get_Exponent(double *value);
	virtual STDMETHODIMP _put_Exponent(double value);
};
template<typename X> struct IExponentialEase_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IExponentialEase_adaptor::Exponent)->_get_Exponent(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IExponentialEase_adaptor::Exponent)->_put_Exponent(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Exponent;
	};
	IExponentialEase_adaptor() {}
};
template<typename X> struct adapt<IExponentialEase, X> : Windows::UI::Xaml::Media::Animation::IExponentialEase_adaptor<X> { typedef adapt IExponentialEase; };
struct IExponentialEase : IExponentialEase_raw, generate<IExponentialEase> {};

// IExponentialEaseStatics
struct IExponentialEaseStatics : IInspectable {
	virtual STDMETHODIMP _get_ExponentProperty(DependencyProperty* *value);
};

// ExponentialEase
template<typename> struct ExponentialEase_statics {
	static struct _ExponentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ExponentialEase, IExponentialEaseStatics>()->_get_ExponentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ExponentProperty;
};
template<typename X> typename ExponentialEase_statics<X>::_ExponentProperty ExponentialEase_statics<X>::ExponentProperty;

template<typename X> struct statics<ExponentialEase, X> : X, Windows::UI::Xaml::Media::Animation::ExponentialEase_statics<void> {
	typedef typename X::root_type ExponentialEase;
};
struct ExponentialEase : generate<ExponentialEase> {};

// ILinearDoubleKeyFrame
struct ILinearDoubleKeyFrame : IInspectable, generate<ILinearDoubleKeyFrame> {};

// LinearDoubleKeyFrame
template<typename X> struct statics<LinearDoubleKeyFrame, X> : X {
	typedef typename X::root_type LinearDoubleKeyFrame;
};
struct LinearDoubleKeyFrame : generate<LinearDoubleKeyFrame> {};

// IObjectAnimationUsingKeyFrames
struct IObjectAnimationUsingKeyFrames_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyFrames(ObjectKeyFrameCollection* *value);
	virtual STDMETHODIMP _get_EnableDependentAnimation(bool *value);
	virtual STDMETHODIMP _put_EnableDependentAnimation(bool value);
};
template<typename X> struct IObjectAnimationUsingKeyFrames_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IObjectAnimationUsingKeyFrames_adaptor::EnableDependentAnimation)->_get_EnableDependentAnimation(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IObjectAnimationUsingKeyFrames_adaptor::EnableDependentAnimation)->_put_EnableDependentAnimation(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} EnableDependentAnimation;
		struct : property {
			ptr<ObjectKeyFrameCollection> get() { ObjectKeyFrameCollection* value; hrcheck(enc(&IObjectAnimationUsingKeyFrames_adaptor::KeyFrames)->_get_KeyFrames(&value)); return from_abi(value); }
			ptr<ObjectKeyFrameCollection> operator()() { return get(); }
			operator ptr<ObjectKeyFrameCollection> () { return get(); }
			ptr<ObjectKeyFrameCollection> operator->() { return get(); }
		} KeyFrames;
	};
	IObjectAnimationUsingKeyFrames_adaptor() {}
};
template<typename X> struct adapt<IObjectAnimationUsingKeyFrames, X> : Windows::UI::Xaml::Media::Animation::IObjectAnimationUsingKeyFrames_adaptor<X> { typedef adapt IObjectAnimationUsingKeyFrames; };
struct IObjectAnimationUsingKeyFrames : IObjectAnimationUsingKeyFrames_raw, generate<IObjectAnimationUsingKeyFrames> {};

// IObjectAnimationUsingKeyFramesStatics
struct IObjectAnimationUsingKeyFramesStatics : IInspectable {
	virtual STDMETHODIMP _get_EnableDependentAnimationProperty(DependencyProperty* *value);
};

// ObjectAnimationUsingKeyFrames
template<typename> struct ObjectAnimationUsingKeyFrames_statics {
	static struct _EnableDependentAnimationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ObjectAnimationUsingKeyFrames, IObjectAnimationUsingKeyFramesStatics>()->_get_EnableDependentAnimationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EnableDependentAnimationProperty;
};
template<typename X> typename ObjectAnimationUsingKeyFrames_statics<X>::_EnableDependentAnimationProperty ObjectAnimationUsingKeyFrames_statics<X>::EnableDependentAnimationProperty;

template<typename X> struct statics<ObjectAnimationUsingKeyFrames, X> : X, Windows::UI::Xaml::Media::Animation::ObjectAnimationUsingKeyFrames_statics<void> {
	typedef typename X::root_type ObjectAnimationUsingKeyFrames;
};
struct ObjectAnimationUsingKeyFrames : generate<ObjectAnimationUsingKeyFrames> {};

// IPaneThemeTransition
struct IPaneThemeTransition_raw : IInspectable {
	virtual STDMETHODIMP _get_Edge(Controls::Primitives::EdgeTransitionLocation *value);
	virtual STDMETHODIMP _put_Edge(Controls::Primitives::EdgeTransitionLocation value);
};
template<typename X> struct IPaneThemeTransition_adaptor : X {
	union {
		struct : property {
			Controls::Primitives::EdgeTransitionLocation get() { Controls::Primitives::EdgeTransitionLocation value; hrcheck(enc(&IPaneThemeTransition_adaptor::Edge)->_get_Edge(&value)); return value; }
			Controls::Primitives::EdgeTransitionLocation operator()() { return get(); }
			operator Controls::Primitives::EdgeTransitionLocation () { return get(); }
			void put(Controls::Primitives::EdgeTransitionLocation value) { hrcheck(enc(&IPaneThemeTransition_adaptor::Edge)->_put_Edge(value)); }
			void operator=(Controls::Primitives::EdgeTransitionLocation value) { put(value); }
			void operator()(Controls::Primitives::EdgeTransitionLocation value) { put(value); }
		} Edge;
	};
	IPaneThemeTransition_adaptor() {}
};
template<typename X> struct adapt<IPaneThemeTransition, X> : Windows::UI::Xaml::Media::Animation::IPaneThemeTransition_adaptor<X> { typedef adapt IPaneThemeTransition; };
struct IPaneThemeTransition : IPaneThemeTransition_raw, generate<IPaneThemeTransition> {};

// IPaneThemeTransitionStatics
struct IPaneThemeTransitionStatics : IInspectable {
	virtual STDMETHODIMP _get_EdgeProperty(DependencyProperty* *value);
};

// PaneThemeTransition
template<typename> struct PaneThemeTransition_statics {
	static struct _EdgeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PaneThemeTransition, IPaneThemeTransitionStatics>()->_get_EdgeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EdgeProperty;
};
template<typename X> typename PaneThemeTransition_statics<X>::_EdgeProperty PaneThemeTransition_statics<X>::EdgeProperty;

template<typename X> struct statics<PaneThemeTransition, X> : X, Windows::UI::Xaml::Media::Animation::PaneThemeTransition_statics<void> {
	typedef typename X::root_type PaneThemeTransition;
};
struct PaneThemeTransition : generate<PaneThemeTransition> {};

// IPointAnimation
struct IPointAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_From(Foundation::IReference<Foundation::Point>* *value);
	virtual STDMETHODIMP _put_From(Foundation::IReference<Foundation::Point>* value);
	virtual STDMETHODIMP _get_To(Foundation::IReference<Foundation::Point>* *value);
	virtual STDMETHODIMP _put_To(Foundation::IReference<Foundation::Point>* value);
	virtual STDMETHODIMP _get_By(Foundation::IReference<Foundation::Point>* *value);
	virtual STDMETHODIMP _put_By(Foundation::IReference<Foundation::Point>* value);
	virtual STDMETHODIMP _get_EasingFunction(EasingFunctionBase* *value);
	virtual STDMETHODIMP _put_EasingFunction(EasingFunctionBase* value);
	virtual STDMETHODIMP _get_EnableDependentAnimation(bool *value);
	virtual STDMETHODIMP _put_EnableDependentAnimation(bool value);
};
template<typename X> struct IPointAnimation_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Foundation::Point>> get() { Foundation::IReference<Foundation::Point>* value; hrcheck(enc(&IPointAnimation_adaptor::By)->_get_By(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::Point>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::Point>> () { return get(); }
			ptr<Foundation::IReference<Foundation::Point>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::Point>> value) { hrcheck(enc(&IPointAnimation_adaptor::By)->_put_By(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::Point>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::Point>> value) { put(to_abi(value)); }
		} By;
		struct : property {
			ptr<EasingFunctionBase> get() { EasingFunctionBase* value; hrcheck(enc(&IPointAnimation_adaptor::EasingFunction)->_get_EasingFunction(&value)); return from_abi(value); }
			ptr<EasingFunctionBase> operator()() { return get(); }
			operator ptr<EasingFunctionBase> () { return get(); }
			ptr<EasingFunctionBase> operator->() { return get(); }
			void put(pptr<EasingFunctionBase> value) { hrcheck(enc(&IPointAnimation_adaptor::EasingFunction)->_put_EasingFunction(value)); }
			void operator=(pptr<EasingFunctionBase> value) { put(value); }
			void operator()(pptr<EasingFunctionBase> value) { put(value); }
		} EasingFunction;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPointAnimation_adaptor::EnableDependentAnimation)->_get_EnableDependentAnimation(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IPointAnimation_adaptor::EnableDependentAnimation)->_put_EnableDependentAnimation(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} EnableDependentAnimation;
		struct : property {
			ptr<Foundation::IReference<Foundation::Point>> get() { Foundation::IReference<Foundation::Point>* value; hrcheck(enc(&IPointAnimation_adaptor::From)->_get_From(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::Point>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::Point>> () { return get(); }
			ptr<Foundation::IReference<Foundation::Point>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::Point>> value) { hrcheck(enc(&IPointAnimation_adaptor::From)->_put_From(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::Point>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::Point>> value) { put(to_abi(value)); }
		} From;
		struct : property {
			ptr<Foundation::IReference<Foundation::Point>> get() { Foundation::IReference<Foundation::Point>* value; hrcheck(enc(&IPointAnimation_adaptor::To)->_get_To(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::Point>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::Point>> () { return get(); }
			ptr<Foundation::IReference<Foundation::Point>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::Point>> value) { hrcheck(enc(&IPointAnimation_adaptor::To)->_put_To(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::Point>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::Point>> value) { put(to_abi(value)); }
		} To;
	};
	IPointAnimation_adaptor() {}
};
template<typename X> struct adapt<IPointAnimation, X> : Windows::UI::Xaml::Media::Animation::IPointAnimation_adaptor<X> { typedef adapt IPointAnimation; };
struct IPointAnimation : IPointAnimation_raw, generate<IPointAnimation> {};

// IPointAnimationStatics
struct IPointAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_FromProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ToProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ByProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_EasingFunctionProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_EnableDependentAnimationProperty(DependencyProperty* *value);
};

// PointAnimation
template<typename> struct PointAnimation_statics {
	static struct _ByProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PointAnimation, IPointAnimationStatics>()->_get_ByProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ByProperty;
	static struct _EasingFunctionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PointAnimation, IPointAnimationStatics>()->_get_EasingFunctionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EasingFunctionProperty;
	static struct _EnableDependentAnimationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PointAnimation, IPointAnimationStatics>()->_get_EnableDependentAnimationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EnableDependentAnimationProperty;
	static struct _FromProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PointAnimation, IPointAnimationStatics>()->_get_FromProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FromProperty;
	static struct _ToProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PointAnimation, IPointAnimationStatics>()->_get_ToProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ToProperty;
};
template<typename X> typename PointAnimation_statics<X>::_ByProperty PointAnimation_statics<X>::ByProperty;
template<typename X> typename PointAnimation_statics<X>::_EasingFunctionProperty PointAnimation_statics<X>::EasingFunctionProperty;
template<typename X> typename PointAnimation_statics<X>::_EnableDependentAnimationProperty PointAnimation_statics<X>::EnableDependentAnimationProperty;
template<typename X> typename PointAnimation_statics<X>::_FromProperty PointAnimation_statics<X>::FromProperty;
template<typename X> typename PointAnimation_statics<X>::_ToProperty PointAnimation_statics<X>::ToProperty;

template<typename X> struct statics<PointAnimation, X> : X, Windows::UI::Xaml::Media::Animation::PointAnimation_statics<void> {
	typedef typename X::root_type PointAnimation;
};
struct PointAnimation : generate<PointAnimation> {};

// IPopupThemeTransition
struct IPopupThemeTransition_raw : IInspectable {
	virtual STDMETHODIMP _get_FromHorizontalOffset(double *value);
	virtual STDMETHODIMP _put_FromHorizontalOffset(double value);
	virtual STDMETHODIMP _get_FromVerticalOffset(double *value);
	virtual STDMETHODIMP _put_FromVerticalOffset(double value);
};
template<typename X> struct IPopupThemeTransition_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IPopupThemeTransition_adaptor::FromHorizontalOffset)->_get_FromHorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPopupThemeTransition_adaptor::FromHorizontalOffset)->_put_FromHorizontalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FromHorizontalOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IPopupThemeTransition_adaptor::FromVerticalOffset)->_get_FromVerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPopupThemeTransition_adaptor::FromVerticalOffset)->_put_FromVerticalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FromVerticalOffset;
	};
	IPopupThemeTransition_adaptor() {}
};
template<typename X> struct adapt<IPopupThemeTransition, X> : Windows::UI::Xaml::Media::Animation::IPopupThemeTransition_adaptor<X> { typedef adapt IPopupThemeTransition; };
struct IPopupThemeTransition : IPopupThemeTransition_raw, generate<IPopupThemeTransition> {};

// IPopupThemeTransitionStatics
struct IPopupThemeTransitionStatics : IInspectable {
	virtual STDMETHODIMP _get_FromHorizontalOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FromVerticalOffsetProperty(DependencyProperty* *value);
};

// PopupThemeTransition
template<typename> struct PopupThemeTransition_statics {
	static struct _FromHorizontalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PopupThemeTransition, IPopupThemeTransitionStatics>()->_get_FromHorizontalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FromHorizontalOffsetProperty;
	static struct _FromVerticalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PopupThemeTransition, IPopupThemeTransitionStatics>()->_get_FromVerticalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FromVerticalOffsetProperty;
};
template<typename X> typename PopupThemeTransition_statics<X>::_FromHorizontalOffsetProperty PopupThemeTransition_statics<X>::FromHorizontalOffsetProperty;
template<typename X> typename PopupThemeTransition_statics<X>::_FromVerticalOffsetProperty PopupThemeTransition_statics<X>::FromVerticalOffsetProperty;

template<typename X> struct statics<PopupThemeTransition, X> : X, Windows::UI::Xaml::Media::Animation::PopupThemeTransition_statics<void> {
	typedef typename X::root_type PopupThemeTransition;
};
struct PopupThemeTransition : generate<PopupThemeTransition> {};

// IPowerEase
struct IPowerEase_raw : IInspectable {
	virtual STDMETHODIMP _get_Power(double *value);
	virtual STDMETHODIMP _put_Power(double value);
};
template<typename X> struct IPowerEase_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IPowerEase_adaptor::Power)->_get_Power(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPowerEase_adaptor::Power)->_put_Power(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Power;
	};
	IPowerEase_adaptor() {}
};
template<typename X> struct adapt<IPowerEase, X> : Windows::UI::Xaml::Media::Animation::IPowerEase_adaptor<X> { typedef adapt IPowerEase; };
struct IPowerEase : IPowerEase_raw, generate<IPowerEase> {};

// IPowerEaseStatics
struct IPowerEaseStatics : IInspectable {
	virtual STDMETHODIMP _get_PowerProperty(DependencyProperty* *value);
};

// PowerEase
template<typename> struct PowerEase_statics {
	static struct _PowerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PowerEase, IPowerEaseStatics>()->_get_PowerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PowerProperty;
};
template<typename X> typename PowerEase_statics<X>::_PowerProperty PowerEase_statics<X>::PowerProperty;

template<typename X> struct statics<PowerEase, X> : X, Windows::UI::Xaml::Media::Animation::PowerEase_statics<void> {
	typedef typename X::root_type PowerEase;
};
struct PowerEase : generate<PowerEase> {};

// IQuadraticEase
struct IQuadraticEase : IInspectable, generate<IQuadraticEase> {};

// QuadraticEase
template<typename X> struct statics<QuadraticEase, X> : X {
	typedef typename X::root_type QuadraticEase;
};
struct QuadraticEase : generate<QuadraticEase> {};

// IQuarticEase
struct IQuarticEase : IInspectable, generate<IQuarticEase> {};

// QuarticEase
template<typename X> struct statics<QuarticEase, X> : X {
	typedef typename X::root_type QuarticEase;
};
struct QuarticEase : generate<QuarticEase> {};

// IQuinticEase
struct IQuinticEase : IInspectable, generate<IQuinticEase> {};

// QuinticEase
template<typename X> struct statics<QuinticEase, X> : X {
	typedef typename X::root_type QuinticEase;
};
struct QuinticEase : generate<QuinticEase> {};

// IReorderThemeTransition
struct IReorderThemeTransition : IInspectable, generate<IReorderThemeTransition> {};

// ReorderThemeTransition
template<typename X> struct statics<ReorderThemeTransition, X> : X {
	typedef typename X::root_type ReorderThemeTransition;
};
struct ReorderThemeTransition : generate<ReorderThemeTransition> {};

// IRepositionThemeTransition
struct IRepositionThemeTransition : IInspectable, generate<IRepositionThemeTransition> {};

// IRepositionThemeTransition2
struct IRepositionThemeTransition2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsStaggeringEnabled(bool *value);
	virtual STDMETHODIMP _put_IsStaggeringEnabled(bool value);
};
template<typename X> struct IRepositionThemeTransition2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRepositionThemeTransition2_adaptor::IsStaggeringEnabled)->_get_IsStaggeringEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IRepositionThemeTransition2_adaptor::IsStaggeringEnabled)->_put_IsStaggeringEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsStaggeringEnabled;
	};
	IRepositionThemeTransition2_adaptor() {}
};
template<typename X> struct adapt<IRepositionThemeTransition2, X> : Windows::UI::Xaml::Media::Animation::IRepositionThemeTransition2_adaptor<X> { typedef adapt IRepositionThemeTransition2; };
struct IRepositionThemeTransition2 : IRepositionThemeTransition2_raw, generate<IRepositionThemeTransition2> {};

// IRepositionThemeTransitionStatics2
struct IRepositionThemeTransitionStatics2 : IInspectable {
	virtual STDMETHODIMP _get_IsStaggeringEnabledProperty(DependencyProperty* *value);
};

// RepositionThemeTransition
template<typename> struct RepositionThemeTransition_statics {
	static struct _IsStaggeringEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RepositionThemeTransition, IRepositionThemeTransitionStatics2>()->_get_IsStaggeringEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsStaggeringEnabledProperty;
};
template<typename X> typename RepositionThemeTransition_statics<X>::_IsStaggeringEnabledProperty RepositionThemeTransition_statics<X>::IsStaggeringEnabledProperty;

template<typename X> struct statics<RepositionThemeTransition, X> : X, Windows::UI::Xaml::Media::Animation::RepositionThemeTransition_statics<void> {
	typedef typename X::root_type RepositionThemeTransition;
};
struct RepositionThemeTransition : generate<RepositionThemeTransition> {};

// ISineEase
struct ISineEase : IInspectable, generate<ISineEase> {};

// SineEase
template<typename X> struct statics<SineEase, X> : X {
	typedef typename X::root_type SineEase;
};
struct SineEase : generate<SineEase> {};

// ISplineDoubleKeyFrame
struct ISplineDoubleKeyFrame_raw : IInspectable {
	virtual STDMETHODIMP _get_KeySpline(Animation::KeySpline* *value);
	virtual STDMETHODIMP _put_KeySpline(Animation::KeySpline* value);
};
template<typename X> struct ISplineDoubleKeyFrame_adaptor : X {
	union {
		struct : property {
			ptr<Animation::KeySpline> get() { Animation::KeySpline* value; hrcheck(enc(&ISplineDoubleKeyFrame_adaptor::KeySpline)->_get_KeySpline(&value)); return from_abi(value); }
			ptr<Animation::KeySpline> operator()() { return get(); }
			operator ptr<Animation::KeySpline> () { return get(); }
			ptr<Animation::KeySpline> operator->() { return get(); }
			void put(pptr<Animation::KeySpline> value) { hrcheck(enc(&ISplineDoubleKeyFrame_adaptor::KeySpline)->_put_KeySpline(value)); }
			void operator=(pptr<Animation::KeySpline> value) { put(value); }
			void operator()(pptr<Animation::KeySpline> value) { put(value); }
		} KeySpline;
	};
	ISplineDoubleKeyFrame_adaptor() {}
};
template<typename X> struct adapt<ISplineDoubleKeyFrame, X> : Windows::UI::Xaml::Media::Animation::ISplineDoubleKeyFrame_adaptor<X> { typedef adapt ISplineDoubleKeyFrame; };
struct ISplineDoubleKeyFrame : ISplineDoubleKeyFrame_raw, generate<ISplineDoubleKeyFrame> {};

// ISplineDoubleKeyFrameStatics
struct ISplineDoubleKeyFrameStatics : IInspectable {
	virtual STDMETHODIMP _get_KeySplineProperty(DependencyProperty* *value);
};

// SplineDoubleKeyFrame
template<typename> struct SplineDoubleKeyFrame_statics {
	static struct _KeySplineProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplineDoubleKeyFrame, ISplineDoubleKeyFrameStatics>()->_get_KeySplineProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeySplineProperty;
};
template<typename X> typename SplineDoubleKeyFrame_statics<X>::_KeySplineProperty SplineDoubleKeyFrame_statics<X>::KeySplineProperty;

template<typename X> struct statics<SplineDoubleKeyFrame, X> : X, Windows::UI::Xaml::Media::Animation::SplineDoubleKeyFrame_statics<void> {
	typedef typename X::root_type SplineDoubleKeyFrame;
};
struct SplineDoubleKeyFrame : generate<SplineDoubleKeyFrame> {};

// IStoryboard
struct IStoryboard_raw : IInspectable {
	virtual STDMETHODIMP _get_Children(TimelineCollection* *value);
	virtual STDMETHODIMP _Seek(Foundation::TimeSpan offset);
	virtual STDMETHODIMP _Stop();
	virtual STDMETHODIMP _Begin();
	virtual STDMETHODIMP _Pause();
	virtual STDMETHODIMP _Resume();
	virtual STDMETHODIMP _GetCurrentState(ClockState *returnValue);
	virtual STDMETHODIMP _GetCurrentTime(Foundation::TimeSpan *returnValue);
	virtual STDMETHODIMP _SeekAlignedToLastTick(Foundation::TimeSpan offset);
	virtual STDMETHODIMP _SkipToFill();
};
template<typename X> struct IStoryboard_adaptor : X {
	union {
		struct : property {
			ptr<TimelineCollection> get() { TimelineCollection* value; hrcheck(enc(&IStoryboard_adaptor::Children)->_get_Children(&value)); return from_abi(value); }
			ptr<TimelineCollection> operator()() { return get(); }
			operator ptr<TimelineCollection> () { return get(); }
			ptr<TimelineCollection> operator->() { return get(); }
		} Children;
	};
	void Seek(const Foundation::TimeSpan& offset) { hrcheck(X::get()->_Seek(offset)); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	void Begin() { hrcheck(X::get()->_Begin()); }
	void Pause() { hrcheck(X::get()->_Pause()); }
	void Resume() { hrcheck(X::get()->_Resume()); }
	ClockState GetCurrentState() { ClockState returnValue; hrcheck(X::get()->_GetCurrentState(&returnValue)); return returnValue; }
	Foundation::TimeSpan GetCurrentTime() { Foundation::TimeSpan returnValue; hrcheck(X::get()->_GetCurrentTime(&returnValue)); return returnValue; }
	void SeekAlignedToLastTick(const Foundation::TimeSpan& offset) { hrcheck(X::get()->_SeekAlignedToLastTick(offset)); }
	void SkipToFill() { hrcheck(X::get()->_SkipToFill()); }
	IStoryboard_adaptor() {}
};
template<typename X> struct adapt<IStoryboard, X> : Windows::UI::Xaml::Media::Animation::IStoryboard_adaptor<X> { typedef adapt IStoryboard; };
struct IStoryboard : IStoryboard_raw, generate<IStoryboard> {};

// IStoryboardStatics
struct IStoryboardStatics : IInspectable {
	virtual STDMETHODIMP _get_TargetPropertyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetTargetProperty(Timeline* element, HSTRING *path);
	virtual STDMETHODIMP _SetTargetProperty(Timeline* element, HSTRING path);
	virtual STDMETHODIMP _get_TargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetTargetName(Timeline* element, HSTRING *name);
	virtual STDMETHODIMP _SetTargetName(Timeline* element, HSTRING name);
	virtual STDMETHODIMP _SetTarget(Timeline* timeline, DependencyObject* target);
};

// Storyboard
template<typename> struct Storyboard_statics {
	static struct _TargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Storyboard, IStoryboardStatics>()->_get_TargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetNameProperty;
	static struct _TargetPropertyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Storyboard, IStoryboardStatics>()->_get_TargetPropertyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetPropertyProperty;
	static hstring GetTargetProperty(pptr<Timeline> element) { HSTRING path; hrcheck(get_activation_factory<Storyboard, IStoryboardStatics>()->_GetTargetProperty(element, &path)); return from_abi(path); }
	static void SetTargetProperty(pptr<Timeline> element, hstring_ref path) { hrcheck(get_activation_factory<Storyboard, IStoryboardStatics>()->_SetTargetProperty(element, path)); }
	static hstring GetTargetName(pptr<Timeline> element) { HSTRING name; hrcheck(get_activation_factory<Storyboard, IStoryboardStatics>()->_GetTargetName(element, &name)); return from_abi(name); }
	static void SetTargetName(pptr<Timeline> element, hstring_ref name) { hrcheck(get_activation_factory<Storyboard, IStoryboardStatics>()->_SetTargetName(element, name)); }
	static void SetTarget(pptr<Timeline> timeline, pptr<DependencyObject> target) { hrcheck(get_activation_factory<Storyboard, IStoryboardStatics>()->_SetTarget(timeline, target)); }
};
template<typename X> typename Storyboard_statics<X>::_TargetNameProperty Storyboard_statics<X>::TargetNameProperty;
template<typename X> typename Storyboard_statics<X>::_TargetPropertyProperty Storyboard_statics<X>::TargetPropertyProperty;

template<typename X> struct statics<Storyboard, X> : X, Windows::UI::Xaml::Media::Animation::Storyboard_statics<void> {
	typedef typename X::root_type Storyboard;
};
struct Storyboard : generate<Storyboard> {};

// IColorKeyFrameFactory
struct IColorKeyFrameFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ColorKeyFrame* *instance);
};

// IColorKeyFrameStatics
struct IColorKeyFrameStatics : IInspectable {
	virtual STDMETHODIMP _get_ValueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_KeyTimeProperty(DependencyProperty* *value);
};

// IColorKeyFrame
struct IColorKeyFrame_raw : IInspectable {
	virtual STDMETHODIMP _get_Value(Color *value);
	virtual STDMETHODIMP _put_Value(Color value);
	virtual STDMETHODIMP _get_KeyTime(Animation::KeyTime *value);
	virtual STDMETHODIMP _put_KeyTime(Animation::KeyTime value);
};
template<typename X> struct IColorKeyFrame_adaptor : X {
	union {
		struct : property {
			Animation::KeyTime get() { Animation::KeyTime value; hrcheck(enc(&IColorKeyFrame_adaptor::KeyTime)->_get_KeyTime(&value)); return value; }
			Animation::KeyTime operator()() { return get(); }
			operator Animation::KeyTime () { return get(); }
			void put(const Animation::KeyTime& value) { hrcheck(enc(&IColorKeyFrame_adaptor::KeyTime)->_put_KeyTime(value)); }
			void operator=(const Animation::KeyTime& value) { put(value); }
			void operator()(const Animation::KeyTime& value) { put(value); }
		} KeyTime;
		struct : property {
			Color get() { Color value; hrcheck(enc(&IColorKeyFrame_adaptor::Value)->_get_Value(&value)); return value; }
			Color operator()() { return get(); }
			operator Color () { return get(); }
			void put(const Color& value) { hrcheck(enc(&IColorKeyFrame_adaptor::Value)->_put_Value(value)); }
			void operator=(const Color& value) { put(value); }
			void operator()(const Color& value) { put(value); }
		} Value;
	};
	IColorKeyFrame_adaptor() {}
};
template<typename X> struct adapt<IColorKeyFrame, X> : Windows::UI::Xaml::Media::Animation::IColorKeyFrame_adaptor<X> { typedef adapt IColorKeyFrame; };
struct IColorKeyFrame : IColorKeyFrame_raw, generate<IColorKeyFrame> {};

// ColorKeyFrame
template<typename> struct ColorKeyFrame_statics {
	static struct _KeyTimeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorKeyFrame, IColorKeyFrameStatics>()->_get_KeyTimeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeyTimeProperty;
	static struct _ValueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorKeyFrame, IColorKeyFrameStatics>()->_get_ValueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ValueProperty;
};
template<typename X> typename ColorKeyFrame_statics<X>::_KeyTimeProperty ColorKeyFrame_statics<X>::KeyTimeProperty;
template<typename X> typename ColorKeyFrame_statics<X>::_ValueProperty ColorKeyFrame_statics<X>::ValueProperty;

template<typename X> struct statics<ColorKeyFrame, X> : X, Windows::UI::Xaml::Media::Animation::ColorKeyFrame_statics<void> {
	typedef typename X::root_type ColorKeyFrame;
};
struct ColorKeyFrame : generate<ColorKeyFrame> {};

// ColorKeyFrameCollection
template<typename X> struct statics<ColorKeyFrameCollection, X> : X {
	typedef typename X::root_type ColorKeyFrameCollection;
};
struct ColorKeyFrameCollection : generate<ColorKeyFrameCollection> {};

// IConnectedAnimation
struct IConnectedAnimation_raw : IInspectable {
	virtual STDMETHODIMP _add_Completed(Foundation::TypedEventHandler<ConnectedAnimation*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Completed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _TryStart(UIElement* destination, bool *returnValue);
	virtual STDMETHODIMP _Cancel();
};
template<typename X> struct IConnectedAnimation_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ConnectedAnimation>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IConnectedAnimation_adaptor::Completed)->_add_Completed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IConnectedAnimation_adaptor::Completed)->_remove_Completed(token)); }
		} Completed;
	};
	bool TryStart(pptr<UIElement> destination) { bool returnValue; hrcheck(X::get()->_TryStart(destination, &returnValue)); return returnValue; }
	void Cancel() { hrcheck(X::get()->_Cancel()); }
	IConnectedAnimation_adaptor() {}
};
template<typename X> struct adapt<IConnectedAnimation, X> : Windows::UI::Xaml::Media::Animation::IConnectedAnimation_adaptor<X> { typedef adapt IConnectedAnimation; };
struct IConnectedAnimation : IConnectedAnimation_raw, generate<IConnectedAnimation> {};

// IConnectedAnimation2
struct IConnectedAnimation2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsScaleAnimationEnabled(bool *value);
	virtual STDMETHODIMP _put_IsScaleAnimationEnabled(bool value);
	virtual STDMETHODIMP _TryStartWithCoordinatedElements(UIElement* destination, Foundation::Collections::IIterable<UIElement*>* coordinatedElements, bool *returnValue);
	virtual STDMETHODIMP _SetAnimationComponent(ConnectedAnimationComponent component, Composition::ICompositionAnimationBase* animation);
};
template<typename X> struct IConnectedAnimation2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IConnectedAnimation2_adaptor::IsScaleAnimationEnabled)->_get_IsScaleAnimationEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IConnectedAnimation2_adaptor::IsScaleAnimationEnabled)->_put_IsScaleAnimationEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsScaleAnimationEnabled;
	};
	bool TryStart(pptr<UIElement> destination, pptr<Foundation::Collections::IIterable<ptr<UIElement>>> coordinatedElements) { bool returnValue; hrcheck(X::get()->_TryStartWithCoordinatedElements(destination, to_abi(coordinatedElements), &returnValue)); return returnValue; }
	void SetAnimationComponent(ConnectedAnimationComponent component, pptr<Composition::ICompositionAnimationBase> animation) { hrcheck(X::get()->_SetAnimationComponent(component, animation)); }
	IConnectedAnimation2_adaptor() {}
};
template<typename X> struct adapt<IConnectedAnimation2, X> : Windows::UI::Xaml::Media::Animation::IConnectedAnimation2_adaptor<X> { typedef adapt IConnectedAnimation2; };
struct IConnectedAnimation2 : IConnectedAnimation2_raw, generate<IConnectedAnimation2> {};

// ConnectedAnimation
template<typename X> struct statics<ConnectedAnimation, X> : X {
	typedef typename X::root_type ConnectedAnimation;
};
struct ConnectedAnimation : generate<ConnectedAnimation> {
	using IConnectedAnimation::TryStart;
	using IConnectedAnimation2::TryStart;
};

// IConnectedAnimationService
struct IConnectedAnimationService_raw : IInspectable {
	virtual STDMETHODIMP _get_DefaultDuration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_DefaultDuration(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_DefaultEasingFunction(Composition::CompositionEasingFunction* *value);
	virtual STDMETHODIMP _put_DefaultEasingFunction(Composition::CompositionEasingFunction* value);
	virtual STDMETHODIMP _PrepareToAnimate(HSTRING key, UIElement* source, ConnectedAnimation* *returnValue);
	virtual STDMETHODIMP _GetAnimation(HSTRING key, ConnectedAnimation* *returnValue);
};
template<typename X> struct IConnectedAnimationService_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IConnectedAnimationService_adaptor::DefaultDuration)->_get_DefaultDuration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IConnectedAnimationService_adaptor::DefaultDuration)->_put_DefaultDuration(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} DefaultDuration;
		struct : property {
			ptr<Composition::CompositionEasingFunction> get() { Composition::CompositionEasingFunction* value; hrcheck(enc(&IConnectedAnimationService_adaptor::DefaultEasingFunction)->_get_DefaultEasingFunction(&value)); return from_abi(value); }
			ptr<Composition::CompositionEasingFunction> operator()() { return get(); }
			operator ptr<Composition::CompositionEasingFunction> () { return get(); }
			ptr<Composition::CompositionEasingFunction> operator->() { return get(); }
			void put(pptr<Composition::CompositionEasingFunction> value) { hrcheck(enc(&IConnectedAnimationService_adaptor::DefaultEasingFunction)->_put_DefaultEasingFunction(value)); }
			void operator=(pptr<Composition::CompositionEasingFunction> value) { put(value); }
			void operator()(pptr<Composition::CompositionEasingFunction> value) { put(value); }
		} DefaultEasingFunction;
	};
	ptr<ConnectedAnimation> PrepareToAnimate(hstring_ref key, pptr<UIElement> source) { ConnectedAnimation* returnValue; hrcheck(X::get()->_PrepareToAnimate(key, source, &returnValue)); return from_abi(returnValue); }
	ptr<ConnectedAnimation> GetAnimation(hstring_ref key) { ConnectedAnimation* returnValue; hrcheck(X::get()->_GetAnimation(key, &returnValue)); return from_abi(returnValue); }
	IConnectedAnimationService_adaptor() {}
};
template<typename X> struct adapt<IConnectedAnimationService, X> : Windows::UI::Xaml::Media::Animation::IConnectedAnimationService_adaptor<X> { typedef adapt IConnectedAnimationService; };
struct IConnectedAnimationService : IConnectedAnimationService_raw, generate<IConnectedAnimationService> {};

// IConnectedAnimationServiceStatics
struct IConnectedAnimationServiceStatics : IInspectable {
	virtual STDMETHODIMP _GetForCurrentView(ConnectedAnimationService* *returnValue);
};

// ConnectedAnimationService
template<typename> struct ConnectedAnimationService_statics {
	static ptr<ConnectedAnimationService> GetForCurrentView() { ConnectedAnimationService* returnValue; hrcheck(get_activation_factory<ConnectedAnimationService, IConnectedAnimationServiceStatics>()->_GetForCurrentView(&returnValue)); return from_abi(returnValue); }
};

template<typename X> struct statics<ConnectedAnimationService, X> : X, Windows::UI::Xaml::Media::Animation::ConnectedAnimationService_statics<void> {
	typedef typename X::root_type ConnectedAnimationService;
};
struct ConnectedAnimationService : generate<ConnectedAnimationService> {};

// IPointKeyFrameFactory
struct IPointKeyFrameFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, PointKeyFrame* *instance);
};

// IPointKeyFrameStatics
struct IPointKeyFrameStatics : IInspectable {
	virtual STDMETHODIMP _get_ValueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_KeyTimeProperty(DependencyProperty* *value);
};

// IPointKeyFrame
struct IPointKeyFrame_raw : IInspectable {
	virtual STDMETHODIMP _get_Value(Foundation::Point *value);
	virtual STDMETHODIMP _put_Value(Foundation::Point value);
	virtual STDMETHODIMP _get_KeyTime(Animation::KeyTime *value);
	virtual STDMETHODIMP _put_KeyTime(Animation::KeyTime value);
};
template<typename X> struct IPointKeyFrame_adaptor : X {
	union {
		struct : property {
			Animation::KeyTime get() { Animation::KeyTime value; hrcheck(enc(&IPointKeyFrame_adaptor::KeyTime)->_get_KeyTime(&value)); return value; }
			Animation::KeyTime operator()() { return get(); }
			operator Animation::KeyTime () { return get(); }
			void put(const Animation::KeyTime& value) { hrcheck(enc(&IPointKeyFrame_adaptor::KeyTime)->_put_KeyTime(value)); }
			void operator=(const Animation::KeyTime& value) { put(value); }
			void operator()(const Animation::KeyTime& value) { put(value); }
		} KeyTime;
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IPointKeyFrame_adaptor::Value)->_get_Value(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&IPointKeyFrame_adaptor::Value)->_put_Value(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} Value;
	};
	IPointKeyFrame_adaptor() {}
};
template<typename X> struct adapt<IPointKeyFrame, X> : Windows::UI::Xaml::Media::Animation::IPointKeyFrame_adaptor<X> { typedef adapt IPointKeyFrame; };
struct IPointKeyFrame : IPointKeyFrame_raw, generate<IPointKeyFrame> {};

// PointKeyFrame
template<typename> struct PointKeyFrame_statics {
	static struct _KeyTimeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PointKeyFrame, IPointKeyFrameStatics>()->_get_KeyTimeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeyTimeProperty;
	static struct _ValueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PointKeyFrame, IPointKeyFrameStatics>()->_get_ValueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ValueProperty;
};
template<typename X> typename PointKeyFrame_statics<X>::_KeyTimeProperty PointKeyFrame_statics<X>::KeyTimeProperty;
template<typename X> typename PointKeyFrame_statics<X>::_ValueProperty PointKeyFrame_statics<X>::ValueProperty;

template<typename X> struct statics<PointKeyFrame, X> : X, Windows::UI::Xaml::Media::Animation::PointKeyFrame_statics<void> {
	typedef typename X::root_type PointKeyFrame;
};
struct PointKeyFrame : generate<PointKeyFrame> {};

// PointKeyFrameCollection
template<typename X> struct statics<PointKeyFrameCollection, X> : X {
	typedef typename X::root_type PointKeyFrameCollection;
};
struct PointKeyFrameCollection : generate<PointKeyFrameCollection> {};

// IColorAnimationUsingKeyFrames
struct IColorAnimationUsingKeyFrames_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyFrames(ColorKeyFrameCollection* *value);
	virtual STDMETHODIMP _get_EnableDependentAnimation(bool *value);
	virtual STDMETHODIMP _put_EnableDependentAnimation(bool value);
};
template<typename X> struct IColorAnimationUsingKeyFrames_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IColorAnimationUsingKeyFrames_adaptor::EnableDependentAnimation)->_get_EnableDependentAnimation(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IColorAnimationUsingKeyFrames_adaptor::EnableDependentAnimation)->_put_EnableDependentAnimation(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} EnableDependentAnimation;
		struct : property {
			ptr<ColorKeyFrameCollection> get() { ColorKeyFrameCollection* value; hrcheck(enc(&IColorAnimationUsingKeyFrames_adaptor::KeyFrames)->_get_KeyFrames(&value)); return from_abi(value); }
			ptr<ColorKeyFrameCollection> operator()() { return get(); }
			operator ptr<ColorKeyFrameCollection> () { return get(); }
			ptr<ColorKeyFrameCollection> operator->() { return get(); }
		} KeyFrames;
	};
	IColorAnimationUsingKeyFrames_adaptor() {}
};
template<typename X> struct adapt<IColorAnimationUsingKeyFrames, X> : Windows::UI::Xaml::Media::Animation::IColorAnimationUsingKeyFrames_adaptor<X> { typedef adapt IColorAnimationUsingKeyFrames; };
struct IColorAnimationUsingKeyFrames : IColorAnimationUsingKeyFrames_raw, generate<IColorAnimationUsingKeyFrames> {};

// IColorAnimationUsingKeyFramesStatics
struct IColorAnimationUsingKeyFramesStatics : IInspectable {
	virtual STDMETHODIMP _get_EnableDependentAnimationProperty(DependencyProperty* *value);
};

// ColorAnimationUsingKeyFrames
template<typename> struct ColorAnimationUsingKeyFrames_statics {
	static struct _EnableDependentAnimationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorAnimationUsingKeyFrames, IColorAnimationUsingKeyFramesStatics>()->_get_EnableDependentAnimationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EnableDependentAnimationProperty;
};
template<typename X> typename ColorAnimationUsingKeyFrames_statics<X>::_EnableDependentAnimationProperty ColorAnimationUsingKeyFrames_statics<X>::EnableDependentAnimationProperty;

template<typename X> struct statics<ColorAnimationUsingKeyFrames, X> : X, Windows::UI::Xaml::Media::Animation::ColorAnimationUsingKeyFrames_statics<void> {
	typedef typename X::root_type ColorAnimationUsingKeyFrames;
};
struct ColorAnimationUsingKeyFrames : generate<ColorAnimationUsingKeyFrames> {};

// IDiscreteColorKeyFrame
struct IDiscreteColorKeyFrame : IInspectable, generate<IDiscreteColorKeyFrame> {};

// DiscreteColorKeyFrame
template<typename X> struct statics<DiscreteColorKeyFrame, X> : X {
	typedef typename X::root_type DiscreteColorKeyFrame;
};
struct DiscreteColorKeyFrame : generate<DiscreteColorKeyFrame> {};

// IDiscretePointKeyFrame
struct IDiscretePointKeyFrame : IInspectable, generate<IDiscretePointKeyFrame> {};

// DiscretePointKeyFrame
template<typename X> struct statics<DiscretePointKeyFrame, X> : X {
	typedef typename X::root_type DiscretePointKeyFrame;
};
struct DiscretePointKeyFrame : generate<DiscretePointKeyFrame> {};

// IDragItemThemeAnimation
struct IDragItemThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_TargetName(HSTRING *value);
	virtual STDMETHODIMP _put_TargetName(HSTRING value);
};
template<typename X> struct IDragItemThemeAnimation_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDragItemThemeAnimation_adaptor::TargetName)->_get_TargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDragItemThemeAnimation_adaptor::TargetName)->_put_TargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} TargetName;
	};
	IDragItemThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<IDragItemThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::IDragItemThemeAnimation_adaptor<X> { typedef adapt IDragItemThemeAnimation; };
struct IDragItemThemeAnimation : IDragItemThemeAnimation_raw, generate<IDragItemThemeAnimation> {};

// IDragItemThemeAnimationStatics
struct IDragItemThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_TargetNameProperty(DependencyProperty* *value);
};

// DragItemThemeAnimation
template<typename> struct DragItemThemeAnimation_statics {
	static struct _TargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DragItemThemeAnimation, IDragItemThemeAnimationStatics>()->_get_TargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetNameProperty;
};
template<typename X> typename DragItemThemeAnimation_statics<X>::_TargetNameProperty DragItemThemeAnimation_statics<X>::TargetNameProperty;

template<typename X> struct statics<DragItemThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::DragItemThemeAnimation_statics<void> {
	typedef typename X::root_type DragItemThemeAnimation;
};
struct DragItemThemeAnimation : generate<DragItemThemeAnimation> {};

// IDragOverThemeAnimation
struct IDragOverThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_TargetName(HSTRING *value);
	virtual STDMETHODIMP _put_TargetName(HSTRING value);
	virtual STDMETHODIMP _get_ToOffset(double *value);
	virtual STDMETHODIMP _put_ToOffset(double value);
	virtual STDMETHODIMP _get_Direction(Controls::Primitives::AnimationDirection *value);
	virtual STDMETHODIMP _put_Direction(Controls::Primitives::AnimationDirection value);
};
template<typename X> struct IDragOverThemeAnimation_adaptor : X {
	union {
		struct : property {
			Controls::Primitives::AnimationDirection get() { Controls::Primitives::AnimationDirection value; hrcheck(enc(&IDragOverThemeAnimation_adaptor::Direction)->_get_Direction(&value)); return value; }
			Controls::Primitives::AnimationDirection operator()() { return get(); }
			operator Controls::Primitives::AnimationDirection () { return get(); }
			void put(Controls::Primitives::AnimationDirection value) { hrcheck(enc(&IDragOverThemeAnimation_adaptor::Direction)->_put_Direction(value)); }
			void operator=(Controls::Primitives::AnimationDirection value) { put(value); }
			void operator()(Controls::Primitives::AnimationDirection value) { put(value); }
		} Direction;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDragOverThemeAnimation_adaptor::TargetName)->_get_TargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDragOverThemeAnimation_adaptor::TargetName)->_put_TargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} TargetName;
		struct : property {
			double get() { double value; hrcheck(enc(&IDragOverThemeAnimation_adaptor::ToOffset)->_get_ToOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IDragOverThemeAnimation_adaptor::ToOffset)->_put_ToOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ToOffset;
	};
	IDragOverThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<IDragOverThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::IDragOverThemeAnimation_adaptor<X> { typedef adapt IDragOverThemeAnimation; };
struct IDragOverThemeAnimation : IDragOverThemeAnimation_raw, generate<IDragOverThemeAnimation> {};

// IDragOverThemeAnimationStatics
struct IDragOverThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_TargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ToOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DirectionProperty(DependencyProperty* *value);
};

// DragOverThemeAnimation
template<typename> struct DragOverThemeAnimation_statics {
	static struct _DirectionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DragOverThemeAnimation, IDragOverThemeAnimationStatics>()->_get_DirectionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DirectionProperty;
	static struct _TargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DragOverThemeAnimation, IDragOverThemeAnimationStatics>()->_get_TargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetNameProperty;
	static struct _ToOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DragOverThemeAnimation, IDragOverThemeAnimationStatics>()->_get_ToOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ToOffsetProperty;
};
template<typename X> typename DragOverThemeAnimation_statics<X>::_DirectionProperty DragOverThemeAnimation_statics<X>::DirectionProperty;
template<typename X> typename DragOverThemeAnimation_statics<X>::_TargetNameProperty DragOverThemeAnimation_statics<X>::TargetNameProperty;
template<typename X> typename DragOverThemeAnimation_statics<X>::_ToOffsetProperty DragOverThemeAnimation_statics<X>::ToOffsetProperty;

template<typename X> struct statics<DragOverThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::DragOverThemeAnimation_statics<void> {
	typedef typename X::root_type DragOverThemeAnimation;
};
struct DragOverThemeAnimation : generate<DragOverThemeAnimation> {};

// IDrillInThemeAnimation
struct IDrillInThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_EntranceTargetName(HSTRING *value);
	virtual STDMETHODIMP _put_EntranceTargetName(HSTRING value);
	virtual STDMETHODIMP _get_EntranceTarget(DependencyObject* *value);
	virtual STDMETHODIMP _put_EntranceTarget(DependencyObject* value);
	virtual STDMETHODIMP _get_ExitTargetName(HSTRING *value);
	virtual STDMETHODIMP _put_ExitTargetName(HSTRING value);
	virtual STDMETHODIMP _get_ExitTarget(DependencyObject* *value);
	virtual STDMETHODIMP _put_ExitTarget(DependencyObject* value);
};
template<typename X> struct IDrillInThemeAnimation_adaptor : X {
	union {
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IDrillInThemeAnimation_adaptor::EntranceTarget)->_get_EntranceTarget(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IDrillInThemeAnimation_adaptor::EntranceTarget)->_put_EntranceTarget(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} EntranceTarget;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDrillInThemeAnimation_adaptor::EntranceTargetName)->_get_EntranceTargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDrillInThemeAnimation_adaptor::EntranceTargetName)->_put_EntranceTargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} EntranceTargetName;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IDrillInThemeAnimation_adaptor::ExitTarget)->_get_ExitTarget(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IDrillInThemeAnimation_adaptor::ExitTarget)->_put_ExitTarget(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} ExitTarget;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDrillInThemeAnimation_adaptor::ExitTargetName)->_get_ExitTargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDrillInThemeAnimation_adaptor::ExitTargetName)->_put_ExitTargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ExitTargetName;
	};
	IDrillInThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<IDrillInThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::IDrillInThemeAnimation_adaptor<X> { typedef adapt IDrillInThemeAnimation; };
struct IDrillInThemeAnimation : IDrillInThemeAnimation_raw, generate<IDrillInThemeAnimation> {};

// IDrillInThemeAnimationStatics
struct IDrillInThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_EntranceTargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_EntranceTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ExitTargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ExitTargetProperty(DependencyProperty* *value);
};

// DrillInThemeAnimation
template<typename> struct DrillInThemeAnimation_statics {
	static struct _EntranceTargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DrillInThemeAnimation, IDrillInThemeAnimationStatics>()->_get_EntranceTargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EntranceTargetNameProperty;
	static struct _EntranceTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DrillInThemeAnimation, IDrillInThemeAnimationStatics>()->_get_EntranceTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EntranceTargetProperty;
	static struct _ExitTargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DrillInThemeAnimation, IDrillInThemeAnimationStatics>()->_get_ExitTargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ExitTargetNameProperty;
	static struct _ExitTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DrillInThemeAnimation, IDrillInThemeAnimationStatics>()->_get_ExitTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ExitTargetProperty;
};
template<typename X> typename DrillInThemeAnimation_statics<X>::_EntranceTargetNameProperty DrillInThemeAnimation_statics<X>::EntranceTargetNameProperty;
template<typename X> typename DrillInThemeAnimation_statics<X>::_EntranceTargetProperty DrillInThemeAnimation_statics<X>::EntranceTargetProperty;
template<typename X> typename DrillInThemeAnimation_statics<X>::_ExitTargetNameProperty DrillInThemeAnimation_statics<X>::ExitTargetNameProperty;
template<typename X> typename DrillInThemeAnimation_statics<X>::_ExitTargetProperty DrillInThemeAnimation_statics<X>::ExitTargetProperty;

template<typename X> struct statics<DrillInThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::DrillInThemeAnimation_statics<void> {
	typedef typename X::root_type DrillInThemeAnimation;
};
struct DrillInThemeAnimation : generate<DrillInThemeAnimation> {};

// IDrillOutThemeAnimation
struct IDrillOutThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_EntranceTargetName(HSTRING *value);
	virtual STDMETHODIMP _put_EntranceTargetName(HSTRING value);
	virtual STDMETHODIMP _get_EntranceTarget(DependencyObject* *value);
	virtual STDMETHODIMP _put_EntranceTarget(DependencyObject* value);
	virtual STDMETHODIMP _get_ExitTargetName(HSTRING *value);
	virtual STDMETHODIMP _put_ExitTargetName(HSTRING value);
	virtual STDMETHODIMP _get_ExitTarget(DependencyObject* *value);
	virtual STDMETHODIMP _put_ExitTarget(DependencyObject* value);
};
template<typename X> struct IDrillOutThemeAnimation_adaptor : X {
	union {
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IDrillOutThemeAnimation_adaptor::EntranceTarget)->_get_EntranceTarget(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IDrillOutThemeAnimation_adaptor::EntranceTarget)->_put_EntranceTarget(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} EntranceTarget;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDrillOutThemeAnimation_adaptor::EntranceTargetName)->_get_EntranceTargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDrillOutThemeAnimation_adaptor::EntranceTargetName)->_put_EntranceTargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} EntranceTargetName;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IDrillOutThemeAnimation_adaptor::ExitTarget)->_get_ExitTarget(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IDrillOutThemeAnimation_adaptor::ExitTarget)->_put_ExitTarget(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} ExitTarget;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDrillOutThemeAnimation_adaptor::ExitTargetName)->_get_ExitTargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDrillOutThemeAnimation_adaptor::ExitTargetName)->_put_ExitTargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ExitTargetName;
	};
	IDrillOutThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<IDrillOutThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::IDrillOutThemeAnimation_adaptor<X> { typedef adapt IDrillOutThemeAnimation; };
struct IDrillOutThemeAnimation : IDrillOutThemeAnimation_raw, generate<IDrillOutThemeAnimation> {};

// IDrillOutThemeAnimationStatics
struct IDrillOutThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_EntranceTargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_EntranceTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ExitTargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ExitTargetProperty(DependencyProperty* *value);
};

// DrillOutThemeAnimation
template<typename> struct DrillOutThemeAnimation_statics {
	static struct _EntranceTargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DrillOutThemeAnimation, IDrillOutThemeAnimationStatics>()->_get_EntranceTargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EntranceTargetNameProperty;
	static struct _EntranceTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DrillOutThemeAnimation, IDrillOutThemeAnimationStatics>()->_get_EntranceTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EntranceTargetProperty;
	static struct _ExitTargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DrillOutThemeAnimation, IDrillOutThemeAnimationStatics>()->_get_ExitTargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ExitTargetNameProperty;
	static struct _ExitTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DrillOutThemeAnimation, IDrillOutThemeAnimationStatics>()->_get_ExitTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ExitTargetProperty;
};
template<typename X> typename DrillOutThemeAnimation_statics<X>::_EntranceTargetNameProperty DrillOutThemeAnimation_statics<X>::EntranceTargetNameProperty;
template<typename X> typename DrillOutThemeAnimation_statics<X>::_EntranceTargetProperty DrillOutThemeAnimation_statics<X>::EntranceTargetProperty;
template<typename X> typename DrillOutThemeAnimation_statics<X>::_ExitTargetNameProperty DrillOutThemeAnimation_statics<X>::ExitTargetNameProperty;
template<typename X> typename DrillOutThemeAnimation_statics<X>::_ExitTargetProperty DrillOutThemeAnimation_statics<X>::ExitTargetProperty;

template<typename X> struct statics<DrillOutThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::DrillOutThemeAnimation_statics<void> {
	typedef typename X::root_type DrillOutThemeAnimation;
};
struct DrillOutThemeAnimation : generate<DrillOutThemeAnimation> {};

// IDropTargetItemThemeAnimation
struct IDropTargetItemThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_TargetName(HSTRING *value);
	virtual STDMETHODIMP _put_TargetName(HSTRING value);
};
template<typename X> struct IDropTargetItemThemeAnimation_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDropTargetItemThemeAnimation_adaptor::TargetName)->_get_TargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDropTargetItemThemeAnimation_adaptor::TargetName)->_put_TargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} TargetName;
	};
	IDropTargetItemThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<IDropTargetItemThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::IDropTargetItemThemeAnimation_adaptor<X> { typedef adapt IDropTargetItemThemeAnimation; };
struct IDropTargetItemThemeAnimation : IDropTargetItemThemeAnimation_raw, generate<IDropTargetItemThemeAnimation> {};

// IDropTargetItemThemeAnimationStatics
struct IDropTargetItemThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_TargetNameProperty(DependencyProperty* *value);
};

// DropTargetItemThemeAnimation
template<typename> struct DropTargetItemThemeAnimation_statics {
	static struct _TargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DropTargetItemThemeAnimation, IDropTargetItemThemeAnimationStatics>()->_get_TargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetNameProperty;
};
template<typename X> typename DropTargetItemThemeAnimation_statics<X>::_TargetNameProperty DropTargetItemThemeAnimation_statics<X>::TargetNameProperty;

template<typename X> struct statics<DropTargetItemThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::DropTargetItemThemeAnimation_statics<void> {
	typedef typename X::root_type DropTargetItemThemeAnimation;
};
struct DropTargetItemThemeAnimation : generate<DropTargetItemThemeAnimation> {};

// IEasingColorKeyFrame
struct IEasingColorKeyFrame_raw : IInspectable {
	virtual STDMETHODIMP _get_EasingFunction(EasingFunctionBase* *value);
	virtual STDMETHODIMP _put_EasingFunction(EasingFunctionBase* value);
};
template<typename X> struct IEasingColorKeyFrame_adaptor : X {
	union {
		struct : property {
			ptr<EasingFunctionBase> get() { EasingFunctionBase* value; hrcheck(enc(&IEasingColorKeyFrame_adaptor::EasingFunction)->_get_EasingFunction(&value)); return from_abi(value); }
			ptr<EasingFunctionBase> operator()() { return get(); }
			operator ptr<EasingFunctionBase> () { return get(); }
			ptr<EasingFunctionBase> operator->() { return get(); }
			void put(pptr<EasingFunctionBase> value) { hrcheck(enc(&IEasingColorKeyFrame_adaptor::EasingFunction)->_put_EasingFunction(value)); }
			void operator=(pptr<EasingFunctionBase> value) { put(value); }
			void operator()(pptr<EasingFunctionBase> value) { put(value); }
		} EasingFunction;
	};
	IEasingColorKeyFrame_adaptor() {}
};
template<typename X> struct adapt<IEasingColorKeyFrame, X> : Windows::UI::Xaml::Media::Animation::IEasingColorKeyFrame_adaptor<X> { typedef adapt IEasingColorKeyFrame; };
struct IEasingColorKeyFrame : IEasingColorKeyFrame_raw, generate<IEasingColorKeyFrame> {};

// IEasingColorKeyFrameStatics
struct IEasingColorKeyFrameStatics : IInspectable {
	virtual STDMETHODIMP _get_EasingFunctionProperty(DependencyProperty* *value);
};

// EasingColorKeyFrame
template<typename> struct EasingColorKeyFrame_statics {
	static struct _EasingFunctionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<EasingColorKeyFrame, IEasingColorKeyFrameStatics>()->_get_EasingFunctionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EasingFunctionProperty;
};
template<typename X> typename EasingColorKeyFrame_statics<X>::_EasingFunctionProperty EasingColorKeyFrame_statics<X>::EasingFunctionProperty;

template<typename X> struct statics<EasingColorKeyFrame, X> : X, Windows::UI::Xaml::Media::Animation::EasingColorKeyFrame_statics<void> {
	typedef typename X::root_type EasingColorKeyFrame;
};
struct EasingColorKeyFrame : generate<EasingColorKeyFrame> {};

// IEasingPointKeyFrame
struct IEasingPointKeyFrame_raw : IInspectable {
	virtual STDMETHODIMP _get_EasingFunction(EasingFunctionBase* *value);
	virtual STDMETHODIMP _put_EasingFunction(EasingFunctionBase* value);
};
template<typename X> struct IEasingPointKeyFrame_adaptor : X {
	union {
		struct : property {
			ptr<EasingFunctionBase> get() { EasingFunctionBase* value; hrcheck(enc(&IEasingPointKeyFrame_adaptor::EasingFunction)->_get_EasingFunction(&value)); return from_abi(value); }
			ptr<EasingFunctionBase> operator()() { return get(); }
			operator ptr<EasingFunctionBase> () { return get(); }
			ptr<EasingFunctionBase> operator->() { return get(); }
			void put(pptr<EasingFunctionBase> value) { hrcheck(enc(&IEasingPointKeyFrame_adaptor::EasingFunction)->_put_EasingFunction(value)); }
			void operator=(pptr<EasingFunctionBase> value) { put(value); }
			void operator()(pptr<EasingFunctionBase> value) { put(value); }
		} EasingFunction;
	};
	IEasingPointKeyFrame_adaptor() {}
};
template<typename X> struct adapt<IEasingPointKeyFrame, X> : Windows::UI::Xaml::Media::Animation::IEasingPointKeyFrame_adaptor<X> { typedef adapt IEasingPointKeyFrame; };
struct IEasingPointKeyFrame : IEasingPointKeyFrame_raw, generate<IEasingPointKeyFrame> {};

// IEasingPointKeyFrameStatics
struct IEasingPointKeyFrameStatics : IInspectable {
	virtual STDMETHODIMP _get_EasingFunctionProperty(DependencyProperty* *value);
};

// EasingPointKeyFrame
template<typename> struct EasingPointKeyFrame_statics {
	static struct _EasingFunctionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<EasingPointKeyFrame, IEasingPointKeyFrameStatics>()->_get_EasingFunctionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EasingFunctionProperty;
};
template<typename X> typename EasingPointKeyFrame_statics<X>::_EasingFunctionProperty EasingPointKeyFrame_statics<X>::EasingFunctionProperty;

template<typename X> struct statics<EasingPointKeyFrame, X> : X, Windows::UI::Xaml::Media::Animation::EasingPointKeyFrame_statics<void> {
	typedef typename X::root_type EasingPointKeyFrame;
};
struct EasingPointKeyFrame : generate<EasingPointKeyFrame> {};

// IFadeInThemeAnimation
struct IFadeInThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_TargetName(HSTRING *value);
	virtual STDMETHODIMP _put_TargetName(HSTRING value);
};
template<typename X> struct IFadeInThemeAnimation_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IFadeInThemeAnimation_adaptor::TargetName)->_get_TargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IFadeInThemeAnimation_adaptor::TargetName)->_put_TargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} TargetName;
	};
	IFadeInThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<IFadeInThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::IFadeInThemeAnimation_adaptor<X> { typedef adapt IFadeInThemeAnimation; };
struct IFadeInThemeAnimation : IFadeInThemeAnimation_raw, generate<IFadeInThemeAnimation> {};

// IFadeInThemeAnimationStatics
struct IFadeInThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_TargetNameProperty(DependencyProperty* *value);
};

// FadeInThemeAnimation
template<typename> struct FadeInThemeAnimation_statics {
	static struct _TargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FadeInThemeAnimation, IFadeInThemeAnimationStatics>()->_get_TargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetNameProperty;
};
template<typename X> typename FadeInThemeAnimation_statics<X>::_TargetNameProperty FadeInThemeAnimation_statics<X>::TargetNameProperty;

template<typename X> struct statics<FadeInThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::FadeInThemeAnimation_statics<void> {
	typedef typename X::root_type FadeInThemeAnimation;
};
struct FadeInThemeAnimation : generate<FadeInThemeAnimation> {};

// IFadeOutThemeAnimation
struct IFadeOutThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_TargetName(HSTRING *value);
	virtual STDMETHODIMP _put_TargetName(HSTRING value);
};
template<typename X> struct IFadeOutThemeAnimation_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IFadeOutThemeAnimation_adaptor::TargetName)->_get_TargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IFadeOutThemeAnimation_adaptor::TargetName)->_put_TargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} TargetName;
	};
	IFadeOutThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<IFadeOutThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::IFadeOutThemeAnimation_adaptor<X> { typedef adapt IFadeOutThemeAnimation; };
struct IFadeOutThemeAnimation : IFadeOutThemeAnimation_raw, generate<IFadeOutThemeAnimation> {};

// IFadeOutThemeAnimationStatics
struct IFadeOutThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_TargetNameProperty(DependencyProperty* *value);
};

// FadeOutThemeAnimation
template<typename> struct FadeOutThemeAnimation_statics {
	static struct _TargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FadeOutThemeAnimation, IFadeOutThemeAnimationStatics>()->_get_TargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetNameProperty;
};
template<typename X> typename FadeOutThemeAnimation_statics<X>::_TargetNameProperty FadeOutThemeAnimation_statics<X>::TargetNameProperty;

template<typename X> struct statics<FadeOutThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::FadeOutThemeAnimation_statics<void> {
	typedef typename X::root_type FadeOutThemeAnimation;
};
struct FadeOutThemeAnimation : generate<FadeOutThemeAnimation> {};

// ILinearColorKeyFrame
struct ILinearColorKeyFrame : IInspectable, generate<ILinearColorKeyFrame> {};

// LinearColorKeyFrame
template<typename X> struct statics<LinearColorKeyFrame, X> : X {
	typedef typename X::root_type LinearColorKeyFrame;
};
struct LinearColorKeyFrame : generate<LinearColorKeyFrame> {};

// ILinearPointKeyFrame
struct ILinearPointKeyFrame : IInspectable, generate<ILinearPointKeyFrame> {};

// LinearPointKeyFrame
template<typename X> struct statics<LinearPointKeyFrame, X> : X {
	typedef typename X::root_type LinearPointKeyFrame;
};
struct LinearPointKeyFrame : generate<LinearPointKeyFrame> {};

// IPointAnimationUsingKeyFrames
struct IPointAnimationUsingKeyFrames_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyFrames(PointKeyFrameCollection* *value);
	virtual STDMETHODIMP _get_EnableDependentAnimation(bool *value);
	virtual STDMETHODIMP _put_EnableDependentAnimation(bool value);
};
template<typename X> struct IPointAnimationUsingKeyFrames_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPointAnimationUsingKeyFrames_adaptor::EnableDependentAnimation)->_get_EnableDependentAnimation(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IPointAnimationUsingKeyFrames_adaptor::EnableDependentAnimation)->_put_EnableDependentAnimation(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} EnableDependentAnimation;
		struct : property {
			ptr<PointKeyFrameCollection> get() { PointKeyFrameCollection* value; hrcheck(enc(&IPointAnimationUsingKeyFrames_adaptor::KeyFrames)->_get_KeyFrames(&value)); return from_abi(value); }
			ptr<PointKeyFrameCollection> operator()() { return get(); }
			operator ptr<PointKeyFrameCollection> () { return get(); }
			ptr<PointKeyFrameCollection> operator->() { return get(); }
		} KeyFrames;
	};
	IPointAnimationUsingKeyFrames_adaptor() {}
};
template<typename X> struct adapt<IPointAnimationUsingKeyFrames, X> : Windows::UI::Xaml::Media::Animation::IPointAnimationUsingKeyFrames_adaptor<X> { typedef adapt IPointAnimationUsingKeyFrames; };
struct IPointAnimationUsingKeyFrames : IPointAnimationUsingKeyFrames_raw, generate<IPointAnimationUsingKeyFrames> {};

// IPointAnimationUsingKeyFramesStatics
struct IPointAnimationUsingKeyFramesStatics : IInspectable {
	virtual STDMETHODIMP _get_EnableDependentAnimationProperty(DependencyProperty* *value);
};

// PointAnimationUsingKeyFrames
template<typename> struct PointAnimationUsingKeyFrames_statics {
	static struct _EnableDependentAnimationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PointAnimationUsingKeyFrames, IPointAnimationUsingKeyFramesStatics>()->_get_EnableDependentAnimationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EnableDependentAnimationProperty;
};
template<typename X> typename PointAnimationUsingKeyFrames_statics<X>::_EnableDependentAnimationProperty PointAnimationUsingKeyFrames_statics<X>::EnableDependentAnimationProperty;

template<typename X> struct statics<PointAnimationUsingKeyFrames, X> : X, Windows::UI::Xaml::Media::Animation::PointAnimationUsingKeyFrames_statics<void> {
	typedef typename X::root_type PointAnimationUsingKeyFrames;
};
struct PointAnimationUsingKeyFrames : generate<PointAnimationUsingKeyFrames> {};

// IPointerDownThemeAnimation
struct IPointerDownThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_TargetName(HSTRING *value);
	virtual STDMETHODIMP _put_TargetName(HSTRING value);
};
template<typename X> struct IPointerDownThemeAnimation_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPointerDownThemeAnimation_adaptor::TargetName)->_get_TargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPointerDownThemeAnimation_adaptor::TargetName)->_put_TargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} TargetName;
	};
	IPointerDownThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<IPointerDownThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::IPointerDownThemeAnimation_adaptor<X> { typedef adapt IPointerDownThemeAnimation; };
struct IPointerDownThemeAnimation : IPointerDownThemeAnimation_raw, generate<IPointerDownThemeAnimation> {};

// IPointerDownThemeAnimationStatics
struct IPointerDownThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_TargetNameProperty(DependencyProperty* *value);
};

// PointerDownThemeAnimation
template<typename> struct PointerDownThemeAnimation_statics {
	static struct _TargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PointerDownThemeAnimation, IPointerDownThemeAnimationStatics>()->_get_TargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetNameProperty;
};
template<typename X> typename PointerDownThemeAnimation_statics<X>::_TargetNameProperty PointerDownThemeAnimation_statics<X>::TargetNameProperty;

template<typename X> struct statics<PointerDownThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::PointerDownThemeAnimation_statics<void> {
	typedef typename X::root_type PointerDownThemeAnimation;
};
struct PointerDownThemeAnimation : generate<PointerDownThemeAnimation> {};

// IPointerUpThemeAnimation
struct IPointerUpThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_TargetName(HSTRING *value);
	virtual STDMETHODIMP _put_TargetName(HSTRING value);
};
template<typename X> struct IPointerUpThemeAnimation_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPointerUpThemeAnimation_adaptor::TargetName)->_get_TargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPointerUpThemeAnimation_adaptor::TargetName)->_put_TargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} TargetName;
	};
	IPointerUpThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<IPointerUpThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::IPointerUpThemeAnimation_adaptor<X> { typedef adapt IPointerUpThemeAnimation; };
struct IPointerUpThemeAnimation : IPointerUpThemeAnimation_raw, generate<IPointerUpThemeAnimation> {};

// IPointerUpThemeAnimationStatics
struct IPointerUpThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_TargetNameProperty(DependencyProperty* *value);
};

// PointerUpThemeAnimation
template<typename> struct PointerUpThemeAnimation_statics {
	static struct _TargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PointerUpThemeAnimation, IPointerUpThemeAnimationStatics>()->_get_TargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetNameProperty;
};
template<typename X> typename PointerUpThemeAnimation_statics<X>::_TargetNameProperty PointerUpThemeAnimation_statics<X>::TargetNameProperty;

template<typename X> struct statics<PointerUpThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::PointerUpThemeAnimation_statics<void> {
	typedef typename X::root_type PointerUpThemeAnimation;
};
struct PointerUpThemeAnimation : generate<PointerUpThemeAnimation> {};

// IPopInThemeAnimation
struct IPopInThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_TargetName(HSTRING *value);
	virtual STDMETHODIMP _put_TargetName(HSTRING value);
	virtual STDMETHODIMP _get_FromHorizontalOffset(double *value);
	virtual STDMETHODIMP _put_FromHorizontalOffset(double value);
	virtual STDMETHODIMP _get_FromVerticalOffset(double *value);
	virtual STDMETHODIMP _put_FromVerticalOffset(double value);
};
template<typename X> struct IPopInThemeAnimation_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IPopInThemeAnimation_adaptor::FromHorizontalOffset)->_get_FromHorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPopInThemeAnimation_adaptor::FromHorizontalOffset)->_put_FromHorizontalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FromHorizontalOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IPopInThemeAnimation_adaptor::FromVerticalOffset)->_get_FromVerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPopInThemeAnimation_adaptor::FromVerticalOffset)->_put_FromVerticalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FromVerticalOffset;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPopInThemeAnimation_adaptor::TargetName)->_get_TargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPopInThemeAnimation_adaptor::TargetName)->_put_TargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} TargetName;
	};
	IPopInThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<IPopInThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::IPopInThemeAnimation_adaptor<X> { typedef adapt IPopInThemeAnimation; };
struct IPopInThemeAnimation : IPopInThemeAnimation_raw, generate<IPopInThemeAnimation> {};

// IPopInThemeAnimationStatics
struct IPopInThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_TargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FromHorizontalOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FromVerticalOffsetProperty(DependencyProperty* *value);
};

// PopInThemeAnimation
template<typename> struct PopInThemeAnimation_statics {
	static struct _FromHorizontalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PopInThemeAnimation, IPopInThemeAnimationStatics>()->_get_FromHorizontalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FromHorizontalOffsetProperty;
	static struct _FromVerticalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PopInThemeAnimation, IPopInThemeAnimationStatics>()->_get_FromVerticalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FromVerticalOffsetProperty;
	static struct _TargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PopInThemeAnimation, IPopInThemeAnimationStatics>()->_get_TargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetNameProperty;
};
template<typename X> typename PopInThemeAnimation_statics<X>::_FromHorizontalOffsetProperty PopInThemeAnimation_statics<X>::FromHorizontalOffsetProperty;
template<typename X> typename PopInThemeAnimation_statics<X>::_FromVerticalOffsetProperty PopInThemeAnimation_statics<X>::FromVerticalOffsetProperty;
template<typename X> typename PopInThemeAnimation_statics<X>::_TargetNameProperty PopInThemeAnimation_statics<X>::TargetNameProperty;

template<typename X> struct statics<PopInThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::PopInThemeAnimation_statics<void> {
	typedef typename X::root_type PopInThemeAnimation;
};
struct PopInThemeAnimation : generate<PopInThemeAnimation> {};

// IPopOutThemeAnimation
struct IPopOutThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_TargetName(HSTRING *value);
	virtual STDMETHODIMP _put_TargetName(HSTRING value);
};
template<typename X> struct IPopOutThemeAnimation_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPopOutThemeAnimation_adaptor::TargetName)->_get_TargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPopOutThemeAnimation_adaptor::TargetName)->_put_TargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} TargetName;
	};
	IPopOutThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<IPopOutThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::IPopOutThemeAnimation_adaptor<X> { typedef adapt IPopOutThemeAnimation; };
struct IPopOutThemeAnimation : IPopOutThemeAnimation_raw, generate<IPopOutThemeAnimation> {};

// IPopOutThemeAnimationStatics
struct IPopOutThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_TargetNameProperty(DependencyProperty* *value);
};

// PopOutThemeAnimation
template<typename> struct PopOutThemeAnimation_statics {
	static struct _TargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PopOutThemeAnimation, IPopOutThemeAnimationStatics>()->_get_TargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetNameProperty;
};
template<typename X> typename PopOutThemeAnimation_statics<X>::_TargetNameProperty PopOutThemeAnimation_statics<X>::TargetNameProperty;

template<typename X> struct statics<PopOutThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::PopOutThemeAnimation_statics<void> {
	typedef typename X::root_type PopOutThemeAnimation;
};
struct PopOutThemeAnimation : generate<PopOutThemeAnimation> {};

// IRepositionThemeAnimation
struct IRepositionThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_TargetName(HSTRING *value);
	virtual STDMETHODIMP _put_TargetName(HSTRING value);
	virtual STDMETHODIMP _get_FromHorizontalOffset(double *value);
	virtual STDMETHODIMP _put_FromHorizontalOffset(double value);
	virtual STDMETHODIMP _get_FromVerticalOffset(double *value);
	virtual STDMETHODIMP _put_FromVerticalOffset(double value);
};
template<typename X> struct IRepositionThemeAnimation_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IRepositionThemeAnimation_adaptor::FromHorizontalOffset)->_get_FromHorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRepositionThemeAnimation_adaptor::FromHorizontalOffset)->_put_FromHorizontalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FromHorizontalOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IRepositionThemeAnimation_adaptor::FromVerticalOffset)->_get_FromVerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRepositionThemeAnimation_adaptor::FromVerticalOffset)->_put_FromVerticalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FromVerticalOffset;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRepositionThemeAnimation_adaptor::TargetName)->_get_TargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IRepositionThemeAnimation_adaptor::TargetName)->_put_TargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} TargetName;
	};
	IRepositionThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<IRepositionThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::IRepositionThemeAnimation_adaptor<X> { typedef adapt IRepositionThemeAnimation; };
struct IRepositionThemeAnimation : IRepositionThemeAnimation_raw, generate<IRepositionThemeAnimation> {};

// IRepositionThemeAnimationStatics
struct IRepositionThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_TargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FromHorizontalOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FromVerticalOffsetProperty(DependencyProperty* *value);
};

// RepositionThemeAnimation
template<typename> struct RepositionThemeAnimation_statics {
	static struct _FromHorizontalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RepositionThemeAnimation, IRepositionThemeAnimationStatics>()->_get_FromHorizontalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FromHorizontalOffsetProperty;
	static struct _FromVerticalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RepositionThemeAnimation, IRepositionThemeAnimationStatics>()->_get_FromVerticalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FromVerticalOffsetProperty;
	static struct _TargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RepositionThemeAnimation, IRepositionThemeAnimationStatics>()->_get_TargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetNameProperty;
};
template<typename X> typename RepositionThemeAnimation_statics<X>::_FromHorizontalOffsetProperty RepositionThemeAnimation_statics<X>::FromHorizontalOffsetProperty;
template<typename X> typename RepositionThemeAnimation_statics<X>::_FromVerticalOffsetProperty RepositionThemeAnimation_statics<X>::FromVerticalOffsetProperty;
template<typename X> typename RepositionThemeAnimation_statics<X>::_TargetNameProperty RepositionThemeAnimation_statics<X>::TargetNameProperty;

template<typename X> struct statics<RepositionThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::RepositionThemeAnimation_statics<void> {
	typedef typename X::root_type RepositionThemeAnimation;
};
struct RepositionThemeAnimation : generate<RepositionThemeAnimation> {};

// ISplineColorKeyFrame
struct ISplineColorKeyFrame_raw : IInspectable {
	virtual STDMETHODIMP _get_KeySpline(Animation::KeySpline* *value);
	virtual STDMETHODIMP _put_KeySpline(Animation::KeySpline* value);
};
template<typename X> struct ISplineColorKeyFrame_adaptor : X {
	union {
		struct : property {
			ptr<Animation::KeySpline> get() { Animation::KeySpline* value; hrcheck(enc(&ISplineColorKeyFrame_adaptor::KeySpline)->_get_KeySpline(&value)); return from_abi(value); }
			ptr<Animation::KeySpline> operator()() { return get(); }
			operator ptr<Animation::KeySpline> () { return get(); }
			ptr<Animation::KeySpline> operator->() { return get(); }
			void put(pptr<Animation::KeySpline> value) { hrcheck(enc(&ISplineColorKeyFrame_adaptor::KeySpline)->_put_KeySpline(value)); }
			void operator=(pptr<Animation::KeySpline> value) { put(value); }
			void operator()(pptr<Animation::KeySpline> value) { put(value); }
		} KeySpline;
	};
	ISplineColorKeyFrame_adaptor() {}
};
template<typename X> struct adapt<ISplineColorKeyFrame, X> : Windows::UI::Xaml::Media::Animation::ISplineColorKeyFrame_adaptor<X> { typedef adapt ISplineColorKeyFrame; };
struct ISplineColorKeyFrame : ISplineColorKeyFrame_raw, generate<ISplineColorKeyFrame> {};

// ISplineColorKeyFrameStatics
struct ISplineColorKeyFrameStatics : IInspectable {
	virtual STDMETHODIMP _get_KeySplineProperty(DependencyProperty* *value);
};

// SplineColorKeyFrame
template<typename> struct SplineColorKeyFrame_statics {
	static struct _KeySplineProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplineColorKeyFrame, ISplineColorKeyFrameStatics>()->_get_KeySplineProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeySplineProperty;
};
template<typename X> typename SplineColorKeyFrame_statics<X>::_KeySplineProperty SplineColorKeyFrame_statics<X>::KeySplineProperty;

template<typename X> struct statics<SplineColorKeyFrame, X> : X, Windows::UI::Xaml::Media::Animation::SplineColorKeyFrame_statics<void> {
	typedef typename X::root_type SplineColorKeyFrame;
};
struct SplineColorKeyFrame : generate<SplineColorKeyFrame> {};

// ISplinePointKeyFrame
struct ISplinePointKeyFrame_raw : IInspectable {
	virtual STDMETHODIMP _get_KeySpline(Animation::KeySpline* *value);
	virtual STDMETHODIMP _put_KeySpline(Animation::KeySpline* value);
};
template<typename X> struct ISplinePointKeyFrame_adaptor : X {
	union {
		struct : property {
			ptr<Animation::KeySpline> get() { Animation::KeySpline* value; hrcheck(enc(&ISplinePointKeyFrame_adaptor::KeySpline)->_get_KeySpline(&value)); return from_abi(value); }
			ptr<Animation::KeySpline> operator()() { return get(); }
			operator ptr<Animation::KeySpline> () { return get(); }
			ptr<Animation::KeySpline> operator->() { return get(); }
			void put(pptr<Animation::KeySpline> value) { hrcheck(enc(&ISplinePointKeyFrame_adaptor::KeySpline)->_put_KeySpline(value)); }
			void operator=(pptr<Animation::KeySpline> value) { put(value); }
			void operator()(pptr<Animation::KeySpline> value) { put(value); }
		} KeySpline;
	};
	ISplinePointKeyFrame_adaptor() {}
};
template<typename X> struct adapt<ISplinePointKeyFrame, X> : Windows::UI::Xaml::Media::Animation::ISplinePointKeyFrame_adaptor<X> { typedef adapt ISplinePointKeyFrame; };
struct ISplinePointKeyFrame : ISplinePointKeyFrame_raw, generate<ISplinePointKeyFrame> {};

// ISplinePointKeyFrameStatics
struct ISplinePointKeyFrameStatics : IInspectable {
	virtual STDMETHODIMP _get_KeySplineProperty(DependencyProperty* *value);
};

// SplinePointKeyFrame
template<typename> struct SplinePointKeyFrame_statics {
	static struct _KeySplineProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplinePointKeyFrame, ISplinePointKeyFrameStatics>()->_get_KeySplineProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeySplineProperty;
};
template<typename X> typename SplinePointKeyFrame_statics<X>::_KeySplineProperty SplinePointKeyFrame_statics<X>::KeySplineProperty;

template<typename X> struct statics<SplinePointKeyFrame, X> : X, Windows::UI::Xaml::Media::Animation::SplinePointKeyFrame_statics<void> {
	typedef typename X::root_type SplinePointKeyFrame;
};
struct SplinePointKeyFrame : generate<SplinePointKeyFrame> {};

// ISplitCloseThemeAnimation
struct ISplitCloseThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_OpenedTargetName(HSTRING *value);
	virtual STDMETHODIMP _put_OpenedTargetName(HSTRING value);
	virtual STDMETHODIMP _get_OpenedTarget(DependencyObject* *value);
	virtual STDMETHODIMP _put_OpenedTarget(DependencyObject* value);
	virtual STDMETHODIMP _get_ClosedTargetName(HSTRING *value);
	virtual STDMETHODIMP _put_ClosedTargetName(HSTRING value);
	virtual STDMETHODIMP _get_ClosedTarget(DependencyObject* *value);
	virtual STDMETHODIMP _put_ClosedTarget(DependencyObject* value);
	virtual STDMETHODIMP _get_ContentTargetName(HSTRING *value);
	virtual STDMETHODIMP _put_ContentTargetName(HSTRING value);
	virtual STDMETHODIMP _get_ContentTarget(DependencyObject* *value);
	virtual STDMETHODIMP _put_ContentTarget(DependencyObject* value);
	virtual STDMETHODIMP _get_OpenedLength(double *value);
	virtual STDMETHODIMP _put_OpenedLength(double value);
	virtual STDMETHODIMP _get_ClosedLength(double *value);
	virtual STDMETHODIMP _put_ClosedLength(double value);
	virtual STDMETHODIMP _get_OffsetFromCenter(double *value);
	virtual STDMETHODIMP _put_OffsetFromCenter(double value);
	virtual STDMETHODIMP _get_ContentTranslationDirection(Controls::Primitives::AnimationDirection *value);
	virtual STDMETHODIMP _put_ContentTranslationDirection(Controls::Primitives::AnimationDirection value);
	virtual STDMETHODIMP _get_ContentTranslationOffset(double *value);
	virtual STDMETHODIMP _put_ContentTranslationOffset(double value);
};
template<typename X> struct ISplitCloseThemeAnimation_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::ClosedLength)->_get_ClosedLength(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::ClosedLength)->_put_ClosedLength(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ClosedLength;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::ClosedTarget)->_get_ClosedTarget(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::ClosedTarget)->_put_ClosedTarget(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} ClosedTarget;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::ClosedTargetName)->_get_ClosedTargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::ClosedTargetName)->_put_ClosedTargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ClosedTargetName;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::ContentTarget)->_get_ContentTarget(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::ContentTarget)->_put_ContentTarget(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} ContentTarget;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::ContentTargetName)->_get_ContentTargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::ContentTargetName)->_put_ContentTargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ContentTargetName;
		struct : property {
			Controls::Primitives::AnimationDirection get() { Controls::Primitives::AnimationDirection value; hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::ContentTranslationDirection)->_get_ContentTranslationDirection(&value)); return value; }
			Controls::Primitives::AnimationDirection operator()() { return get(); }
			operator Controls::Primitives::AnimationDirection () { return get(); }
			void put(Controls::Primitives::AnimationDirection value) { hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::ContentTranslationDirection)->_put_ContentTranslationDirection(value)); }
			void operator=(Controls::Primitives::AnimationDirection value) { put(value); }
			void operator()(Controls::Primitives::AnimationDirection value) { put(value); }
		} ContentTranslationDirection;
		struct : property {
			double get() { double value; hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::ContentTranslationOffset)->_get_ContentTranslationOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::ContentTranslationOffset)->_put_ContentTranslationOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ContentTranslationOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::OffsetFromCenter)->_get_OffsetFromCenter(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::OffsetFromCenter)->_put_OffsetFromCenter(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} OffsetFromCenter;
		struct : property {
			double get() { double value; hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::OpenedLength)->_get_OpenedLength(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::OpenedLength)->_put_OpenedLength(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} OpenedLength;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::OpenedTarget)->_get_OpenedTarget(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::OpenedTarget)->_put_OpenedTarget(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} OpenedTarget;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::OpenedTargetName)->_get_OpenedTargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISplitCloseThemeAnimation_adaptor::OpenedTargetName)->_put_OpenedTargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} OpenedTargetName;
	};
	ISplitCloseThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<ISplitCloseThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::ISplitCloseThemeAnimation_adaptor<X> { typedef adapt ISplitCloseThemeAnimation; };
struct ISplitCloseThemeAnimation : ISplitCloseThemeAnimation_raw, generate<ISplitCloseThemeAnimation> {};

// ISplitCloseThemeAnimationStatics
struct ISplitCloseThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_OpenedTargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OpenedTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ClosedTargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ClosedTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentTargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OpenedLengthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ClosedLengthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OffsetFromCenterProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentTranslationDirectionProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentTranslationOffsetProperty(DependencyProperty* *value);
};

// SplitCloseThemeAnimation
template<typename> struct SplitCloseThemeAnimation_statics {
	static struct _ClosedLengthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitCloseThemeAnimation, ISplitCloseThemeAnimationStatics>()->_get_ClosedLengthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ClosedLengthProperty;
	static struct _ClosedTargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitCloseThemeAnimation, ISplitCloseThemeAnimationStatics>()->_get_ClosedTargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ClosedTargetNameProperty;
	static struct _ClosedTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitCloseThemeAnimation, ISplitCloseThemeAnimationStatics>()->_get_ClosedTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ClosedTargetProperty;
	static struct _ContentTargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitCloseThemeAnimation, ISplitCloseThemeAnimationStatics>()->_get_ContentTargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentTargetNameProperty;
	static struct _ContentTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitCloseThemeAnimation, ISplitCloseThemeAnimationStatics>()->_get_ContentTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentTargetProperty;
	static struct _ContentTranslationDirectionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitCloseThemeAnimation, ISplitCloseThemeAnimationStatics>()->_get_ContentTranslationDirectionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentTranslationDirectionProperty;
	static struct _ContentTranslationOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitCloseThemeAnimation, ISplitCloseThemeAnimationStatics>()->_get_ContentTranslationOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentTranslationOffsetProperty;
	static struct _OffsetFromCenterProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitCloseThemeAnimation, ISplitCloseThemeAnimationStatics>()->_get_OffsetFromCenterProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OffsetFromCenterProperty;
	static struct _OpenedLengthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitCloseThemeAnimation, ISplitCloseThemeAnimationStatics>()->_get_OpenedLengthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OpenedLengthProperty;
	static struct _OpenedTargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitCloseThemeAnimation, ISplitCloseThemeAnimationStatics>()->_get_OpenedTargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OpenedTargetNameProperty;
	static struct _OpenedTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitCloseThemeAnimation, ISplitCloseThemeAnimationStatics>()->_get_OpenedTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OpenedTargetProperty;
};
template<typename X> typename SplitCloseThemeAnimation_statics<X>::_ClosedLengthProperty SplitCloseThemeAnimation_statics<X>::ClosedLengthProperty;
template<typename X> typename SplitCloseThemeAnimation_statics<X>::_ClosedTargetNameProperty SplitCloseThemeAnimation_statics<X>::ClosedTargetNameProperty;
template<typename X> typename SplitCloseThemeAnimation_statics<X>::_ClosedTargetProperty SplitCloseThemeAnimation_statics<X>::ClosedTargetProperty;
template<typename X> typename SplitCloseThemeAnimation_statics<X>::_ContentTargetNameProperty SplitCloseThemeAnimation_statics<X>::ContentTargetNameProperty;
template<typename X> typename SplitCloseThemeAnimation_statics<X>::_ContentTargetProperty SplitCloseThemeAnimation_statics<X>::ContentTargetProperty;
template<typename X> typename SplitCloseThemeAnimation_statics<X>::_ContentTranslationDirectionProperty SplitCloseThemeAnimation_statics<X>::ContentTranslationDirectionProperty;
template<typename X> typename SplitCloseThemeAnimation_statics<X>::_ContentTranslationOffsetProperty SplitCloseThemeAnimation_statics<X>::ContentTranslationOffsetProperty;
template<typename X> typename SplitCloseThemeAnimation_statics<X>::_OffsetFromCenterProperty SplitCloseThemeAnimation_statics<X>::OffsetFromCenterProperty;
template<typename X> typename SplitCloseThemeAnimation_statics<X>::_OpenedLengthProperty SplitCloseThemeAnimation_statics<X>::OpenedLengthProperty;
template<typename X> typename SplitCloseThemeAnimation_statics<X>::_OpenedTargetNameProperty SplitCloseThemeAnimation_statics<X>::OpenedTargetNameProperty;
template<typename X> typename SplitCloseThemeAnimation_statics<X>::_OpenedTargetProperty SplitCloseThemeAnimation_statics<X>::OpenedTargetProperty;

template<typename X> struct statics<SplitCloseThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::SplitCloseThemeAnimation_statics<void> {
	typedef typename X::root_type SplitCloseThemeAnimation;
};
struct SplitCloseThemeAnimation : generate<SplitCloseThemeAnimation> {};

// ISplitOpenThemeAnimation
struct ISplitOpenThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_OpenedTargetName(HSTRING *value);
	virtual STDMETHODIMP _put_OpenedTargetName(HSTRING value);
	virtual STDMETHODIMP _get_OpenedTarget(DependencyObject* *value);
	virtual STDMETHODIMP _put_OpenedTarget(DependencyObject* value);
	virtual STDMETHODIMP _get_ClosedTargetName(HSTRING *value);
	virtual STDMETHODIMP _put_ClosedTargetName(HSTRING value);
	virtual STDMETHODIMP _get_ClosedTarget(DependencyObject* *value);
	virtual STDMETHODIMP _put_ClosedTarget(DependencyObject* value);
	virtual STDMETHODIMP _get_ContentTargetName(HSTRING *value);
	virtual STDMETHODIMP _put_ContentTargetName(HSTRING value);
	virtual STDMETHODIMP _get_ContentTarget(DependencyObject* *value);
	virtual STDMETHODIMP _put_ContentTarget(DependencyObject* value);
	virtual STDMETHODIMP _get_OpenedLength(double *value);
	virtual STDMETHODIMP _put_OpenedLength(double value);
	virtual STDMETHODIMP _get_ClosedLength(double *value);
	virtual STDMETHODIMP _put_ClosedLength(double value);
	virtual STDMETHODIMP _get_OffsetFromCenter(double *value);
	virtual STDMETHODIMP _put_OffsetFromCenter(double value);
	virtual STDMETHODIMP _get_ContentTranslationDirection(Controls::Primitives::AnimationDirection *value);
	virtual STDMETHODIMP _put_ContentTranslationDirection(Controls::Primitives::AnimationDirection value);
	virtual STDMETHODIMP _get_ContentTranslationOffset(double *value);
	virtual STDMETHODIMP _put_ContentTranslationOffset(double value);
};
template<typename X> struct ISplitOpenThemeAnimation_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::ClosedLength)->_get_ClosedLength(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::ClosedLength)->_put_ClosedLength(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ClosedLength;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::ClosedTarget)->_get_ClosedTarget(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::ClosedTarget)->_put_ClosedTarget(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} ClosedTarget;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::ClosedTargetName)->_get_ClosedTargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::ClosedTargetName)->_put_ClosedTargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ClosedTargetName;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::ContentTarget)->_get_ContentTarget(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::ContentTarget)->_put_ContentTarget(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} ContentTarget;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::ContentTargetName)->_get_ContentTargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::ContentTargetName)->_put_ContentTargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ContentTargetName;
		struct : property {
			Controls::Primitives::AnimationDirection get() { Controls::Primitives::AnimationDirection value; hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::ContentTranslationDirection)->_get_ContentTranslationDirection(&value)); return value; }
			Controls::Primitives::AnimationDirection operator()() { return get(); }
			operator Controls::Primitives::AnimationDirection () { return get(); }
			void put(Controls::Primitives::AnimationDirection value) { hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::ContentTranslationDirection)->_put_ContentTranslationDirection(value)); }
			void operator=(Controls::Primitives::AnimationDirection value) { put(value); }
			void operator()(Controls::Primitives::AnimationDirection value) { put(value); }
		} ContentTranslationDirection;
		struct : property {
			double get() { double value; hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::ContentTranslationOffset)->_get_ContentTranslationOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::ContentTranslationOffset)->_put_ContentTranslationOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ContentTranslationOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::OffsetFromCenter)->_get_OffsetFromCenter(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::OffsetFromCenter)->_put_OffsetFromCenter(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} OffsetFromCenter;
		struct : property {
			double get() { double value; hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::OpenedLength)->_get_OpenedLength(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::OpenedLength)->_put_OpenedLength(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} OpenedLength;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::OpenedTarget)->_get_OpenedTarget(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::OpenedTarget)->_put_OpenedTarget(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} OpenedTarget;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::OpenedTargetName)->_get_OpenedTargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISplitOpenThemeAnimation_adaptor::OpenedTargetName)->_put_OpenedTargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} OpenedTargetName;
	};
	ISplitOpenThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<ISplitOpenThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::ISplitOpenThemeAnimation_adaptor<X> { typedef adapt ISplitOpenThemeAnimation; };
struct ISplitOpenThemeAnimation : ISplitOpenThemeAnimation_raw, generate<ISplitOpenThemeAnimation> {};

// ISplitOpenThemeAnimationStatics
struct ISplitOpenThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_OpenedTargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OpenedTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ClosedTargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ClosedTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentTargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OpenedLengthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ClosedLengthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OffsetFromCenterProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentTranslationDirectionProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentTranslationOffsetProperty(DependencyProperty* *value);
};

// SplitOpenThemeAnimation
template<typename> struct SplitOpenThemeAnimation_statics {
	static struct _ClosedLengthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitOpenThemeAnimation, ISplitOpenThemeAnimationStatics>()->_get_ClosedLengthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ClosedLengthProperty;
	static struct _ClosedTargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitOpenThemeAnimation, ISplitOpenThemeAnimationStatics>()->_get_ClosedTargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ClosedTargetNameProperty;
	static struct _ClosedTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitOpenThemeAnimation, ISplitOpenThemeAnimationStatics>()->_get_ClosedTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ClosedTargetProperty;
	static struct _ContentTargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitOpenThemeAnimation, ISplitOpenThemeAnimationStatics>()->_get_ContentTargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentTargetNameProperty;
	static struct _ContentTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitOpenThemeAnimation, ISplitOpenThemeAnimationStatics>()->_get_ContentTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentTargetProperty;
	static struct _ContentTranslationDirectionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitOpenThemeAnimation, ISplitOpenThemeAnimationStatics>()->_get_ContentTranslationDirectionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentTranslationDirectionProperty;
	static struct _ContentTranslationOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitOpenThemeAnimation, ISplitOpenThemeAnimationStatics>()->_get_ContentTranslationOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentTranslationOffsetProperty;
	static struct _OffsetFromCenterProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitOpenThemeAnimation, ISplitOpenThemeAnimationStatics>()->_get_OffsetFromCenterProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OffsetFromCenterProperty;
	static struct _OpenedLengthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitOpenThemeAnimation, ISplitOpenThemeAnimationStatics>()->_get_OpenedLengthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OpenedLengthProperty;
	static struct _OpenedTargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitOpenThemeAnimation, ISplitOpenThemeAnimationStatics>()->_get_OpenedTargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OpenedTargetNameProperty;
	static struct _OpenedTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitOpenThemeAnimation, ISplitOpenThemeAnimationStatics>()->_get_OpenedTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OpenedTargetProperty;
};
template<typename X> typename SplitOpenThemeAnimation_statics<X>::_ClosedLengthProperty SplitOpenThemeAnimation_statics<X>::ClosedLengthProperty;
template<typename X> typename SplitOpenThemeAnimation_statics<X>::_ClosedTargetNameProperty SplitOpenThemeAnimation_statics<X>::ClosedTargetNameProperty;
template<typename X> typename SplitOpenThemeAnimation_statics<X>::_ClosedTargetProperty SplitOpenThemeAnimation_statics<X>::ClosedTargetProperty;
template<typename X> typename SplitOpenThemeAnimation_statics<X>::_ContentTargetNameProperty SplitOpenThemeAnimation_statics<X>::ContentTargetNameProperty;
template<typename X> typename SplitOpenThemeAnimation_statics<X>::_ContentTargetProperty SplitOpenThemeAnimation_statics<X>::ContentTargetProperty;
template<typename X> typename SplitOpenThemeAnimation_statics<X>::_ContentTranslationDirectionProperty SplitOpenThemeAnimation_statics<X>::ContentTranslationDirectionProperty;
template<typename X> typename SplitOpenThemeAnimation_statics<X>::_ContentTranslationOffsetProperty SplitOpenThemeAnimation_statics<X>::ContentTranslationOffsetProperty;
template<typename X> typename SplitOpenThemeAnimation_statics<X>::_OffsetFromCenterProperty SplitOpenThemeAnimation_statics<X>::OffsetFromCenterProperty;
template<typename X> typename SplitOpenThemeAnimation_statics<X>::_OpenedLengthProperty SplitOpenThemeAnimation_statics<X>::OpenedLengthProperty;
template<typename X> typename SplitOpenThemeAnimation_statics<X>::_OpenedTargetNameProperty SplitOpenThemeAnimation_statics<X>::OpenedTargetNameProperty;
template<typename X> typename SplitOpenThemeAnimation_statics<X>::_OpenedTargetProperty SplitOpenThemeAnimation_statics<X>::OpenedTargetProperty;

template<typename X> struct statics<SplitOpenThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::SplitOpenThemeAnimation_statics<void> {
	typedef typename X::root_type SplitOpenThemeAnimation;
};
struct SplitOpenThemeAnimation : generate<SplitOpenThemeAnimation> {};

// ISwipeBackThemeAnimation
struct ISwipeBackThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_TargetName(HSTRING *value);
	virtual STDMETHODIMP _put_TargetName(HSTRING value);
	virtual STDMETHODIMP _get_FromHorizontalOffset(double *value);
	virtual STDMETHODIMP _put_FromHorizontalOffset(double value);
	virtual STDMETHODIMP _get_FromVerticalOffset(double *value);
	virtual STDMETHODIMP _put_FromVerticalOffset(double value);
};
template<typename X> struct ISwipeBackThemeAnimation_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&ISwipeBackThemeAnimation_adaptor::FromHorizontalOffset)->_get_FromHorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISwipeBackThemeAnimation_adaptor::FromHorizontalOffset)->_put_FromHorizontalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FromHorizontalOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&ISwipeBackThemeAnimation_adaptor::FromVerticalOffset)->_get_FromVerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISwipeBackThemeAnimation_adaptor::FromVerticalOffset)->_put_FromVerticalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FromVerticalOffset;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISwipeBackThemeAnimation_adaptor::TargetName)->_get_TargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISwipeBackThemeAnimation_adaptor::TargetName)->_put_TargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} TargetName;
	};
	ISwipeBackThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<ISwipeBackThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::ISwipeBackThemeAnimation_adaptor<X> { typedef adapt ISwipeBackThemeAnimation; };
struct ISwipeBackThemeAnimation : ISwipeBackThemeAnimation_raw, generate<ISwipeBackThemeAnimation> {};

// ISwipeBackThemeAnimationStatics
struct ISwipeBackThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_TargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FromHorizontalOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FromVerticalOffsetProperty(DependencyProperty* *value);
};

// SwipeBackThemeAnimation
template<typename> struct SwipeBackThemeAnimation_statics {
	static struct _FromHorizontalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeBackThemeAnimation, ISwipeBackThemeAnimationStatics>()->_get_FromHorizontalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FromHorizontalOffsetProperty;
	static struct _FromVerticalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeBackThemeAnimation, ISwipeBackThemeAnimationStatics>()->_get_FromVerticalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FromVerticalOffsetProperty;
	static struct _TargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeBackThemeAnimation, ISwipeBackThemeAnimationStatics>()->_get_TargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetNameProperty;
};
template<typename X> typename SwipeBackThemeAnimation_statics<X>::_FromHorizontalOffsetProperty SwipeBackThemeAnimation_statics<X>::FromHorizontalOffsetProperty;
template<typename X> typename SwipeBackThemeAnimation_statics<X>::_FromVerticalOffsetProperty SwipeBackThemeAnimation_statics<X>::FromVerticalOffsetProperty;
template<typename X> typename SwipeBackThemeAnimation_statics<X>::_TargetNameProperty SwipeBackThemeAnimation_statics<X>::TargetNameProperty;

template<typename X> struct statics<SwipeBackThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::SwipeBackThemeAnimation_statics<void> {
	typedef typename X::root_type SwipeBackThemeAnimation;
};
struct SwipeBackThemeAnimation : generate<SwipeBackThemeAnimation> {};

// ISwipeHintThemeAnimation
struct ISwipeHintThemeAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_TargetName(HSTRING *value);
	virtual STDMETHODIMP _put_TargetName(HSTRING value);
	virtual STDMETHODIMP _get_ToHorizontalOffset(double *value);
	virtual STDMETHODIMP _put_ToHorizontalOffset(double value);
	virtual STDMETHODIMP _get_ToVerticalOffset(double *value);
	virtual STDMETHODIMP _put_ToVerticalOffset(double value);
};
template<typename X> struct ISwipeHintThemeAnimation_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISwipeHintThemeAnimation_adaptor::TargetName)->_get_TargetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISwipeHintThemeAnimation_adaptor::TargetName)->_put_TargetName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} TargetName;
		struct : property {
			double get() { double value; hrcheck(enc(&ISwipeHintThemeAnimation_adaptor::ToHorizontalOffset)->_get_ToHorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISwipeHintThemeAnimation_adaptor::ToHorizontalOffset)->_put_ToHorizontalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ToHorizontalOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&ISwipeHintThemeAnimation_adaptor::ToVerticalOffset)->_get_ToVerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISwipeHintThemeAnimation_adaptor::ToVerticalOffset)->_put_ToVerticalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ToVerticalOffset;
	};
	ISwipeHintThemeAnimation_adaptor() {}
};
template<typename X> struct adapt<ISwipeHintThemeAnimation, X> : Windows::UI::Xaml::Media::Animation::ISwipeHintThemeAnimation_adaptor<X> { typedef adapt ISwipeHintThemeAnimation; };
struct ISwipeHintThemeAnimation : ISwipeHintThemeAnimation_raw, generate<ISwipeHintThemeAnimation> {};

// ISwipeHintThemeAnimationStatics
struct ISwipeHintThemeAnimationStatics : IInspectable {
	virtual STDMETHODIMP _get_TargetNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ToHorizontalOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ToVerticalOffsetProperty(DependencyProperty* *value);
};

// SwipeHintThemeAnimation
template<typename> struct SwipeHintThemeAnimation_statics {
	static struct _TargetNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeHintThemeAnimation, ISwipeHintThemeAnimationStatics>()->_get_TargetNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetNameProperty;
	static struct _ToHorizontalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeHintThemeAnimation, ISwipeHintThemeAnimationStatics>()->_get_ToHorizontalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ToHorizontalOffsetProperty;
	static struct _ToVerticalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeHintThemeAnimation, ISwipeHintThemeAnimationStatics>()->_get_ToVerticalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ToVerticalOffsetProperty;
};
template<typename X> typename SwipeHintThemeAnimation_statics<X>::_TargetNameProperty SwipeHintThemeAnimation_statics<X>::TargetNameProperty;
template<typename X> typename SwipeHintThemeAnimation_statics<X>::_ToHorizontalOffsetProperty SwipeHintThemeAnimation_statics<X>::ToHorizontalOffsetProperty;
template<typename X> typename SwipeHintThemeAnimation_statics<X>::_ToVerticalOffsetProperty SwipeHintThemeAnimation_statics<X>::ToVerticalOffsetProperty;

template<typename X> struct statics<SwipeHintThemeAnimation, X> : X, Windows::UI::Xaml::Media::Animation::SwipeHintThemeAnimation_statics<void> {
	typedef typename X::root_type SwipeHintThemeAnimation;
};
struct SwipeHintThemeAnimation : generate<SwipeHintThemeAnimation> {};

// ICommonNavigationTransitionInfo
struct ICommonNavigationTransitionInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_IsStaggeringEnabled(bool *value);
	virtual STDMETHODIMP _put_IsStaggeringEnabled(bool value);
};
template<typename X> struct ICommonNavigationTransitionInfo_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICommonNavigationTransitionInfo_adaptor::IsStaggeringEnabled)->_get_IsStaggeringEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICommonNavigationTransitionInfo_adaptor::IsStaggeringEnabled)->_put_IsStaggeringEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsStaggeringEnabled;
	};
	ICommonNavigationTransitionInfo_adaptor() {}
};
template<typename X> struct adapt<ICommonNavigationTransitionInfo, X> : Windows::UI::Xaml::Media::Animation::ICommonNavigationTransitionInfo_adaptor<X> { typedef adapt ICommonNavigationTransitionInfo; };
struct ICommonNavigationTransitionInfo : ICommonNavigationTransitionInfo_raw, generate<ICommonNavigationTransitionInfo> {};

// ICommonNavigationTransitionInfoStatics
struct ICommonNavigationTransitionInfoStatics : IInspectable {
	virtual STDMETHODIMP _get_IsStaggeringEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsStaggerElementProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsStaggerElement(UIElement* element, bool *value);
	virtual STDMETHODIMP _SetIsStaggerElement(UIElement* element, bool value);
};

// CommonNavigationTransitionInfo
template<typename> struct CommonNavigationTransitionInfo_statics {
	static struct _IsStaggerElementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CommonNavigationTransitionInfo, ICommonNavigationTransitionInfoStatics>()->_get_IsStaggerElementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsStaggerElementProperty;
	static struct _IsStaggeringEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CommonNavigationTransitionInfo, ICommonNavigationTransitionInfoStatics>()->_get_IsStaggeringEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsStaggeringEnabledProperty;
	static bool GetIsStaggerElement(pptr<UIElement> element) { bool value; hrcheck(get_activation_factory<CommonNavigationTransitionInfo, ICommonNavigationTransitionInfoStatics>()->_GetIsStaggerElement(element, &value)); return value; }
	static void SetIsStaggerElement(pptr<UIElement> element, bool value) { hrcheck(get_activation_factory<CommonNavigationTransitionInfo, ICommonNavigationTransitionInfoStatics>()->_SetIsStaggerElement(element, value)); }
};
template<typename X> typename CommonNavigationTransitionInfo_statics<X>::_IsStaggerElementProperty CommonNavigationTransitionInfo_statics<X>::IsStaggerElementProperty;
template<typename X> typename CommonNavigationTransitionInfo_statics<X>::_IsStaggeringEnabledProperty CommonNavigationTransitionInfo_statics<X>::IsStaggeringEnabledProperty;

template<typename X> struct statics<CommonNavigationTransitionInfo, X> : X, Windows::UI::Xaml::Media::Animation::CommonNavigationTransitionInfo_statics<void> {
	typedef typename X::root_type CommonNavigationTransitionInfo;
};
struct CommonNavigationTransitionInfo : generate<CommonNavigationTransitionInfo> {};

// IContinuumNavigationTransitionInfo
struct IContinuumNavigationTransitionInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_ExitElement(UIElement* *value);
	virtual STDMETHODIMP _put_ExitElement(UIElement* value);
};
template<typename X> struct IContinuumNavigationTransitionInfo_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IContinuumNavigationTransitionInfo_adaptor::ExitElement)->_get_ExitElement(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IContinuumNavigationTransitionInfo_adaptor::ExitElement)->_put_ExitElement(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} ExitElement;
	};
	IContinuumNavigationTransitionInfo_adaptor() {}
};
template<typename X> struct adapt<IContinuumNavigationTransitionInfo, X> : Windows::UI::Xaml::Media::Animation::IContinuumNavigationTransitionInfo_adaptor<X> { typedef adapt IContinuumNavigationTransitionInfo; };
struct IContinuumNavigationTransitionInfo : IContinuumNavigationTransitionInfo_raw, generate<IContinuumNavigationTransitionInfo> {};

// IContinuumNavigationTransitionInfoStatics
struct IContinuumNavigationTransitionInfoStatics : IInspectable {
	virtual STDMETHODIMP _get_ExitElementProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsEntranceElementProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsEntranceElement(UIElement* element, bool *value);
	virtual STDMETHODIMP _SetIsEntranceElement(UIElement* element, bool value);
	virtual STDMETHODIMP _get_IsExitElementProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsExitElement(UIElement* element, bool *value);
	virtual STDMETHODIMP _SetIsExitElement(UIElement* element, bool value);
	virtual STDMETHODIMP _get_ExitElementContainerProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetExitElementContainer(Controls::ListViewBase* element, bool *value);
	virtual STDMETHODIMP _SetExitElementContainer(Controls::ListViewBase* element, bool value);
};

// ContinuumNavigationTransitionInfo
template<typename> struct ContinuumNavigationTransitionInfo_statics {
	static struct _ExitElementContainerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContinuumNavigationTransitionInfo, IContinuumNavigationTransitionInfoStatics>()->_get_ExitElementContainerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ExitElementContainerProperty;
	static struct _ExitElementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContinuumNavigationTransitionInfo, IContinuumNavigationTransitionInfoStatics>()->_get_ExitElementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ExitElementProperty;
	static struct _IsEntranceElementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContinuumNavigationTransitionInfo, IContinuumNavigationTransitionInfoStatics>()->_get_IsEntranceElementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsEntranceElementProperty;
	static struct _IsExitElementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContinuumNavigationTransitionInfo, IContinuumNavigationTransitionInfoStatics>()->_get_IsExitElementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsExitElementProperty;
	static bool GetIsEntranceElement(pptr<UIElement> element) { bool value; hrcheck(get_activation_factory<ContinuumNavigationTransitionInfo, IContinuumNavigationTransitionInfoStatics>()->_GetIsEntranceElement(element, &value)); return value; }
	static void SetIsEntranceElement(pptr<UIElement> element, bool value) { hrcheck(get_activation_factory<ContinuumNavigationTransitionInfo, IContinuumNavigationTransitionInfoStatics>()->_SetIsEntranceElement(element, value)); }
	static bool GetIsExitElement(pptr<UIElement> element) { bool value; hrcheck(get_activation_factory<ContinuumNavigationTransitionInfo, IContinuumNavigationTransitionInfoStatics>()->_GetIsExitElement(element, &value)); return value; }
	static void SetIsExitElement(pptr<UIElement> element, bool value) { hrcheck(get_activation_factory<ContinuumNavigationTransitionInfo, IContinuumNavigationTransitionInfoStatics>()->_SetIsExitElement(element, value)); }
	static bool GetExitElementContainer(pptr<Controls::ListViewBase> element) { bool value; hrcheck(get_activation_factory<ContinuumNavigationTransitionInfo, IContinuumNavigationTransitionInfoStatics>()->_GetExitElementContainer(element, &value)); return value; }
	static void SetExitElementContainer(pptr<Controls::ListViewBase> element, bool value) { hrcheck(get_activation_factory<ContinuumNavigationTransitionInfo, IContinuumNavigationTransitionInfoStatics>()->_SetExitElementContainer(element, value)); }
};
template<typename X> typename ContinuumNavigationTransitionInfo_statics<X>::_ExitElementContainerProperty ContinuumNavigationTransitionInfo_statics<X>::ExitElementContainerProperty;
template<typename X> typename ContinuumNavigationTransitionInfo_statics<X>::_ExitElementProperty ContinuumNavigationTransitionInfo_statics<X>::ExitElementProperty;
template<typename X> typename ContinuumNavigationTransitionInfo_statics<X>::_IsEntranceElementProperty ContinuumNavigationTransitionInfo_statics<X>::IsEntranceElementProperty;
template<typename X> typename ContinuumNavigationTransitionInfo_statics<X>::_IsExitElementProperty ContinuumNavigationTransitionInfo_statics<X>::IsExitElementProperty;

template<typename X> struct statics<ContinuumNavigationTransitionInfo, X> : X, Windows::UI::Xaml::Media::Animation::ContinuumNavigationTransitionInfo_statics<void> {
	typedef typename X::root_type ContinuumNavigationTransitionInfo;
};
struct ContinuumNavigationTransitionInfo : generate<ContinuumNavigationTransitionInfo> {};

// IDrillInNavigationTransitionInfo
struct IDrillInNavigationTransitionInfo : IInspectable, generate<IDrillInNavigationTransitionInfo> {};

// DrillInNavigationTransitionInfo
template<typename X> struct statics<DrillInNavigationTransitionInfo, X> : X {
	typedef typename X::root_type DrillInNavigationTransitionInfo;
};
struct DrillInNavigationTransitionInfo : generate<DrillInNavigationTransitionInfo> {};

// IEntranceNavigationTransitionInfo
struct IEntranceNavigationTransitionInfo : IInspectable, generate<IEntranceNavigationTransitionInfo> {};

// IEntranceNavigationTransitionInfoStatics
struct IEntranceNavigationTransitionInfoStatics : IInspectable {
	virtual STDMETHODIMP _get_IsTargetElementProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsTargetElement(UIElement* element, bool *value);
	virtual STDMETHODIMP _SetIsTargetElement(UIElement* element, bool value);
};

// EntranceNavigationTransitionInfo
template<typename> struct EntranceNavigationTransitionInfo_statics {
	static struct _IsTargetElementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<EntranceNavigationTransitionInfo, IEntranceNavigationTransitionInfoStatics>()->_get_IsTargetElementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTargetElementProperty;
	static bool GetIsTargetElement(pptr<UIElement> element) { bool value; hrcheck(get_activation_factory<EntranceNavigationTransitionInfo, IEntranceNavigationTransitionInfoStatics>()->_GetIsTargetElement(element, &value)); return value; }
	static void SetIsTargetElement(pptr<UIElement> element, bool value) { hrcheck(get_activation_factory<EntranceNavigationTransitionInfo, IEntranceNavigationTransitionInfoStatics>()->_SetIsTargetElement(element, value)); }
};
template<typename X> typename EntranceNavigationTransitionInfo_statics<X>::_IsTargetElementProperty EntranceNavigationTransitionInfo_statics<X>::IsTargetElementProperty;

template<typename X> struct statics<EntranceNavigationTransitionInfo, X> : X, Windows::UI::Xaml::Media::Animation::EntranceNavigationTransitionInfo_statics<void> {
	typedef typename X::root_type EntranceNavigationTransitionInfo;
};
struct EntranceNavigationTransitionInfo : generate<EntranceNavigationTransitionInfo> {};

// INavigationThemeTransition
struct INavigationThemeTransition_raw : IInspectable {
	virtual STDMETHODIMP _get_DefaultNavigationTransitionInfo(NavigationTransitionInfo* *value);
	virtual STDMETHODIMP _put_DefaultNavigationTransitionInfo(NavigationTransitionInfo* value);
};
template<typename X> struct INavigationThemeTransition_adaptor : X {
	union {
		struct : property {
			ptr<NavigationTransitionInfo> get() { NavigationTransitionInfo* value; hrcheck(enc(&INavigationThemeTransition_adaptor::DefaultNavigationTransitionInfo)->_get_DefaultNavigationTransitionInfo(&value)); return from_abi(value); }
			ptr<NavigationTransitionInfo> operator()() { return get(); }
			operator ptr<NavigationTransitionInfo> () { return get(); }
			ptr<NavigationTransitionInfo> operator->() { return get(); }
			void put(pptr<NavigationTransitionInfo> value) { hrcheck(enc(&INavigationThemeTransition_adaptor::DefaultNavigationTransitionInfo)->_put_DefaultNavigationTransitionInfo(value)); }
			void operator=(pptr<NavigationTransitionInfo> value) { put(value); }
			void operator()(pptr<NavigationTransitionInfo> value) { put(value); }
		} DefaultNavigationTransitionInfo;
	};
	INavigationThemeTransition_adaptor() {}
};
template<typename X> struct adapt<INavigationThemeTransition, X> : Windows::UI::Xaml::Media::Animation::INavigationThemeTransition_adaptor<X> { typedef adapt INavigationThemeTransition; };
struct INavigationThemeTransition : INavigationThemeTransition_raw, generate<INavigationThemeTransition> {};

// INavigationThemeTransitionStatics
struct INavigationThemeTransitionStatics : IInspectable {
	virtual STDMETHODIMP _get_DefaultNavigationTransitionInfoProperty(DependencyProperty* *value);
};

// NavigationThemeTransition
template<typename> struct NavigationThemeTransition_statics {
	static struct _DefaultNavigationTransitionInfoProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationThemeTransition, INavigationThemeTransitionStatics>()->_get_DefaultNavigationTransitionInfoProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DefaultNavigationTransitionInfoProperty;
};
template<typename X> typename NavigationThemeTransition_statics<X>::_DefaultNavigationTransitionInfoProperty NavigationThemeTransition_statics<X>::DefaultNavigationTransitionInfoProperty;

template<typename X> struct statics<NavigationThemeTransition, X> : X, Windows::UI::Xaml::Media::Animation::NavigationThemeTransition_statics<void> {
	typedef typename X::root_type NavigationThemeTransition;
};
struct NavigationThemeTransition : generate<NavigationThemeTransition> {};

// ISlideNavigationTransitionInfo
struct ISlideNavigationTransitionInfo : IInspectable, generate<ISlideNavigationTransitionInfo> {};

// SlideNavigationTransitionInfo
template<typename X> struct statics<SlideNavigationTransitionInfo, X> : X {
	typedef typename X::root_type SlideNavigationTransitionInfo;
};
struct SlideNavigationTransitionInfo : generate<SlideNavigationTransitionInfo> {};

// ISuppressNavigationTransitionInfo
struct ISuppressNavigationTransitionInfo : IInspectable, generate<ISuppressNavigationTransitionInfo> {};

// SuppressNavigationTransitionInfo
template<typename X> struct statics<SuppressNavigationTransitionInfo, X> : X {
	typedef typename X::root_type SuppressNavigationTransitionInfo;
};
struct SuppressNavigationTransitionInfo : generate<SuppressNavigationTransitionInfo> {};
}}}}}
} // namespace iso_winrt
