#pragma once
// generated by isopod tools
// namespaces:
// Windows.Gaming.Input.Custom

#include "Windows.Gaming.Input.Custom.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation {
template<typename TResult, typename TProgress> struct IAsyncOperationWithProgress;
}
namespace Gaming { namespace Input {
struct IGameController;
}}
namespace Storage { namespace Streams {
struct IInputStream;
}}}

// defs

template<> struct def<Windows::Gaming::Input::Custom::GipFirmwareUpdateStatus> : enum_type<int> {};
template<> struct def<Windows::Gaming::Input::Custom::GipMessageClass> : enum_type<int> {};
template<> struct def<Windows::Gaming::Input::Custom::XusbDeviceType> : enum_type<int> {};
template<> struct def<Windows::Gaming::Input::Custom::XusbDeviceSubtype> : enum_type<int> {};
template<> struct def<Windows::Gaming::Input::Custom::GameControllerVersionInfo> : value_type<unsigned short, unsigned short, unsigned short, unsigned short> {};
template<> struct def<Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress> : value_type<double, unsigned> {};
template<> struct def<Windows::Gaming::Input::Custom::IGameControllerInputSink> : overridable_type<> {};
template<> struct def<Windows::Gaming::Input::Custom::IGipGameControllerInputSink> : overridable_type<Windows::Gaming::Input::Custom::IGameControllerInputSink> {};
template<> struct def<Windows::Gaming::Input::Custom::IHidGameControllerInputSink> : overridable_type<Windows::Gaming::Input::Custom::IGameControllerInputSink> {};
template<> struct def<Windows::Gaming::Input::Custom::IXusbGameControllerInputSink> : overridable_type<Windows::Gaming::Input::Custom::IGameControllerInputSink> {};
template<> struct def<Windows::Gaming::Input::Custom::IGipFirmwareUpdateResult> : interface_type<> {};
template<> struct def<Windows::Gaming::Input::Custom::IGameControllerProvider> : overridable_type<> {};
template<> struct def<Windows::Gaming::Input::Custom::IGipGameControllerProvider> : interface_type<Windows::Gaming::Input::Custom::IGameControllerProvider> {};
template<> struct def<Windows::Gaming::Input::Custom::GipFirmwareUpdateResult> : class_type<Platform::Object, Windows::Gaming::Input::Custom::IGipFirmwareUpdateResult> {};
template<> struct def<Windows::Gaming::Input::Custom::IHidGameControllerProvider> : interface_type<Windows::Gaming::Input::Custom::IGameControllerProvider> {};
template<> struct def<Windows::Gaming::Input::Custom::IXusbGameControllerProvider> : interface_type<Windows::Gaming::Input::Custom::IGameControllerProvider> {};
template<> struct def<Windows::Gaming::Input::Custom::ICustomGameControllerFactory> : overridable_type<> {};
template<> struct def<Windows::Gaming::Input::Custom::IGameControllerFactoryManagerStatics> : interface_type<> {};
template<> struct def<Windows::Gaming::Input::Custom::IGameControllerFactoryManagerStatics2> : interface_type<Windows::Gaming::Input::Custom::IGameControllerFactoryManagerStatics> {};
template<> struct def<Windows::Gaming::Input::Custom::GipGameControllerProvider> : class_type<Platform::Object, Windows::Gaming::Input::Custom::IGipGameControllerProvider> {};
template<> struct def<Windows::Gaming::Input::Custom::HidGameControllerProvider> : class_type<Platform::Object, Windows::Gaming::Input::Custom::IHidGameControllerProvider> {};
template<> struct def<Windows::Gaming::Input::Custom::XusbGameControllerProvider> : class_type<Platform::Object, Windows::Gaming::Input::Custom::IXusbGameControllerProvider> {};
template<> struct def<Windows::Gaming::Input::Custom::GameControllerFactoryManager> : class_type<Platform::Object, Platform::Object> {};

// uuids

template<> struct uuid<Windows::Gaming::Input::Custom::IGameControllerInputSink> { define_guid(0x1FF6F922, 0xC640, 0x4C78, 0xA8, 0x20, 0x9A, 0x71, 0x5C, 0x55, 0x8B, 0xCB);};
template<> struct uuid<Windows::Gaming::Input::Custom::IGipGameControllerInputSink> { define_guid(0xA2108ABF, 0x9F1, 0x43BC, 0xA1, 0x40, 0x80, 0xF8, 0x99, 0xEC, 0x36, 0xFB);};
template<> struct uuid<Windows::Gaming::Input::Custom::IHidGameControllerInputSink> { define_guid(0xF754C322, 0x182D, 0x40E4, 0xA1, 0x26, 0xFC, 0xEE, 0x4F, 0xFA, 0x1E, 0x31);};
template<> struct uuid<Windows::Gaming::Input::Custom::IXusbGameControllerInputSink> { define_guid(0xB2AC1D95, 0x6ECB, 0x42B3, 0x8A, 0xAB, 0x2, 0x54, 0x1, 0xCA, 0x47, 0x12);};
template<> struct uuid<Windows::Gaming::Input::Custom::IGipFirmwareUpdateResult> { define_guid(0x6B794D32, 0x8553, 0x4292, 0x8E, 0x3, 0xE1, 0x66, 0x51, 0xA2, 0xF8, 0xBC);};
template<> struct uuid<Windows::Gaming::Input::Custom::IGameControllerProvider> { define_guid(0xE6D73982, 0x2996, 0x4559, 0xB1, 0x6C, 0x3E, 0x57, 0xD4, 0x6E, 0x58, 0xD6);};
template<> struct uuid<Windows::Gaming::Input::Custom::IGipGameControllerProvider> { define_guid(0xDBCF1E19, 0x1AF5, 0x45A8, 0xBF, 0x2, 0xA0, 0xEE, 0x50, 0xC8, 0x23, 0xFC);};
template<> struct uuid<Windows::Gaming::Input::Custom::IHidGameControllerProvider> { define_guid(0x95CE3AF4, 0xABF0, 0x4B68, 0xA0, 0x81, 0x3B, 0x7D, 0xE7, 0x3F, 0xF0, 0xE7);};
template<> struct uuid<Windows::Gaming::Input::Custom::IXusbGameControllerProvider> { define_guid(0x6E2971EB, 0xEFB, 0x48B4, 0x80, 0x8B, 0x83, 0x76, 0x43, 0xB2, 0xF2, 0x16);};
template<> struct uuid<Windows::Gaming::Input::Custom::ICustomGameControllerFactory> { define_guid(0x69A0AE5E, 0x758E, 0x4CBE, 0xAC, 0xE6, 0x62, 0x15, 0x5F, 0xE9, 0x12, 0x6F);};
template<> struct uuid<Windows::Gaming::Input::Custom::IGameControllerFactoryManagerStatics> { define_guid(0x36CB66E3, 0xD0A1, 0x4986, 0xA2, 0x4C, 0x40, 0xB1, 0x37, 0xDE, 0xBA, 0x9E);};
template<> struct uuid<Windows::Gaming::Input::Custom::IGameControllerFactoryManagerStatics2> { define_guid(0xEACE5644, 0x19DF, 0x4115, 0xB3, 0x2A, 0x27, 0x93, 0xE2, 0xAE, 0xA3, 0xBB);};

// types

namespace Windows { namespace Gaming { namespace Input { namespace Custom {

// IGameControllerInputSink
struct IGameControllerInputSink_raw : IInspectable {
	virtual STDMETHODIMP _OnInputResumed(unsigned __int64 timestamp) = 0;
	virtual STDMETHODIMP _OnInputSuspended(unsigned __int64 timestamp) = 0;
};
template<typename X> struct IGameControllerInputSink_adaptor : X {
	void OnInputResumed(unsigned __int64 timestamp) { hrcheck(X::get()->_OnInputResumed(timestamp)); }
	void OnInputSuspended(unsigned __int64 timestamp) { hrcheck(X::get()->_OnInputSuspended(timestamp)); }
};
template<typename X> struct adapt<IGameControllerInputSink, X> : Windows::Gaming::Input::Custom::IGameControllerInputSink_adaptor<X> { typedef adapt IGameControllerInputSink; };
template<typename X> struct IGameControllerInputSink_unadaptor : X {
	STDMETHODIMP _OnInputResumed(unsigned __int64 timestamp) { return hrtry([&, this] { X::get()->OnInputResumed(timestamp); }); }
	STDMETHODIMP _OnInputSuspended(unsigned __int64 timestamp) { return hrtry([&, this] { X::get()->OnInputSuspended(timestamp); }); }
};
template<typename X> struct unadapt<IGameControllerInputSink, X> : Windows::Gaming::Input::Custom::IGameControllerInputSink_unadaptor<X> {};
struct IGameControllerInputSink : IGameControllerInputSink_raw, generate<IGameControllerInputSink> {};

// IGipGameControllerInputSink
struct IGipGameControllerInputSink_raw : IInspectable {
	virtual STDMETHODIMP _OnKeyReceived(unsigned __int64 timestamp, unsigned char keyCode, bool isPressed) = 0;
	virtual STDMETHODIMP _OnMessageReceived(unsigned __int64 timestamp, GipMessageClass messageClass, unsigned char messageId, unsigned char sequenceId, unsigned messageBufferSize, unsigned char *messageBuffer) = 0;
};
template<typename X> struct IGipGameControllerInputSink_adaptor : X {
	void OnKeyReceived(unsigned __int64 timestamp, unsigned char keyCode, bool isPressed) { hrcheck(X::get()->_OnKeyReceived(timestamp, keyCode, isPressed)); }
	void OnMessageReceived(unsigned __int64 timestamp, GipMessageClass messageClass, unsigned char messageId, unsigned char sequenceId, const szarray<unsigned char>& messageBuffer) { hrcheck(X::get()->_OnMessageReceived(timestamp, messageClass, messageId, sequenceId, messageBuffer.size, to_abi(messageBuffer.p))); }
};
template<typename X> struct adapt<IGipGameControllerInputSink, X> : Windows::Gaming::Input::Custom::IGipGameControllerInputSink_adaptor<X> { typedef adapt IGipGameControllerInputSink; };
template<typename X> struct IGipGameControllerInputSink_unadaptor : X {
	STDMETHODIMP _OnKeyReceived(unsigned __int64 timestamp, unsigned char keyCode, bool isPressed) { return hrtry([&, this] { X::get()->OnKeyReceived(timestamp, keyCode, isPressed); }); }
	STDMETHODIMP _OnMessageReceived(unsigned __int64 timestamp, GipMessageClass messageClass, unsigned char messageId, unsigned char sequenceId, unsigned messageBufferSize, unsigned char *messageBuffer) { return hrtry([&, this] { X::get()->OnMessageReceived(timestamp, messageClass, messageId, sequenceId, {(unsigned char*)messageBuffer, messageBufferSize}); }); }
};
template<typename X> struct unadapt<IGipGameControllerInputSink, X> : Windows::Gaming::Input::Custom::IGipGameControllerInputSink_unadaptor<X> {};
struct IGipGameControllerInputSink : IGipGameControllerInputSink_raw, generate<IGipGameControllerInputSink> {};

// IHidGameControllerInputSink
struct IHidGameControllerInputSink_raw : IInspectable {
	virtual STDMETHODIMP _OnInputReportReceived(unsigned __int64 timestamp, unsigned char reportId, unsigned reportBufferSize, unsigned char *reportBuffer) = 0;
};
template<typename X> struct IHidGameControllerInputSink_adaptor : X {
	void OnInputReportReceived(unsigned __int64 timestamp, unsigned char reportId, const szarray<unsigned char>& reportBuffer) { hrcheck(X::get()->_OnInputReportReceived(timestamp, reportId, reportBuffer.size, to_abi(reportBuffer.p))); }
};
template<typename X> struct adapt<IHidGameControllerInputSink, X> : Windows::Gaming::Input::Custom::IHidGameControllerInputSink_adaptor<X> { typedef adapt IHidGameControllerInputSink; };
template<typename X> struct IHidGameControllerInputSink_unadaptor : X {
	STDMETHODIMP _OnInputReportReceived(unsigned __int64 timestamp, unsigned char reportId, unsigned reportBufferSize, unsigned char *reportBuffer) { return hrtry([&, this] { X::get()->OnInputReportReceived(timestamp, reportId, {(unsigned char*)reportBuffer, reportBufferSize}); }); }
};
template<typename X> struct unadapt<IHidGameControllerInputSink, X> : Windows::Gaming::Input::Custom::IHidGameControllerInputSink_unadaptor<X> {};
struct IHidGameControllerInputSink : IHidGameControllerInputSink_raw, generate<IHidGameControllerInputSink> {};

// IXusbGameControllerInputSink
struct IXusbGameControllerInputSink_raw : IInspectable {
	virtual STDMETHODIMP _OnInputReceived(unsigned __int64 timestamp, unsigned char reportId, unsigned inputBufferSize, unsigned char *inputBuffer) = 0;
};
template<typename X> struct IXusbGameControllerInputSink_adaptor : X {
	void OnInputReceived(unsigned __int64 timestamp, unsigned char reportId, const szarray<unsigned char>& inputBuffer) { hrcheck(X::get()->_OnInputReceived(timestamp, reportId, inputBuffer.size, to_abi(inputBuffer.p))); }
};
template<typename X> struct adapt<IXusbGameControllerInputSink, X> : Windows::Gaming::Input::Custom::IXusbGameControllerInputSink_adaptor<X> { typedef adapt IXusbGameControllerInputSink; };
template<typename X> struct IXusbGameControllerInputSink_unadaptor : X {
	STDMETHODIMP _OnInputReceived(unsigned __int64 timestamp, unsigned char reportId, unsigned inputBufferSize, unsigned char *inputBuffer) { return hrtry([&, this] { X::get()->OnInputReceived(timestamp, reportId, {(unsigned char*)inputBuffer, inputBufferSize}); }); }
};
template<typename X> struct unadapt<IXusbGameControllerInputSink, X> : Windows::Gaming::Input::Custom::IXusbGameControllerInputSink_unadaptor<X> {};
struct IXusbGameControllerInputSink : IXusbGameControllerInputSink_raw, generate<IXusbGameControllerInputSink> {};

// IGipFirmwareUpdateResult
struct IGipFirmwareUpdateResult_raw : IInspectable {
	virtual STDMETHODIMP _get_ExtendedErrorCode(unsigned *value);
	virtual STDMETHODIMP _get_FinalComponentId(unsigned *value);
	virtual STDMETHODIMP _get_Status(GipFirmwareUpdateStatus *value);
};
template<typename X> struct IGipFirmwareUpdateResult_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IGipFirmwareUpdateResult_adaptor::ExtendedErrorCode)->_get_ExtendedErrorCode(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} ExtendedErrorCode;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IGipFirmwareUpdateResult_adaptor::FinalComponentId)->_get_FinalComponentId(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} FinalComponentId;
		struct : property {
			GipFirmwareUpdateStatus get() { GipFirmwareUpdateStatus value; hrcheck(enc(&IGipFirmwareUpdateResult_adaptor::Status)->_get_Status(&value)); return value; }
			GipFirmwareUpdateStatus operator()() { return get(); }
			operator GipFirmwareUpdateStatus () { return get(); }
		} Status;
	};
	IGipFirmwareUpdateResult_adaptor() {}
};
template<typename X> struct adapt<IGipFirmwareUpdateResult, X> : Windows::Gaming::Input::Custom::IGipFirmwareUpdateResult_adaptor<X> { typedef adapt IGipFirmwareUpdateResult; };
struct IGipFirmwareUpdateResult : IGipFirmwareUpdateResult_raw, generate<IGipFirmwareUpdateResult> {};

// IGameControllerProvider
struct IGameControllerProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_FirmwareVersionInfo(GameControllerVersionInfo *value) = 0;
	virtual STDMETHODIMP _get_HardwareProductId(unsigned short *value) = 0;
	virtual STDMETHODIMP _get_HardwareVendorId(unsigned short *value) = 0;
	virtual STDMETHODIMP _get_HardwareVersionInfo(GameControllerVersionInfo *value) = 0;
	virtual STDMETHODIMP _get_IsConnected(bool *value) = 0;
};
template<typename X> struct IGameControllerProvider_adaptor : X {
	union {
		struct : property {
			GameControllerVersionInfo get() { GameControllerVersionInfo value; hrcheck(enc(&IGameControllerProvider_adaptor::FirmwareVersionInfo)->_get_FirmwareVersionInfo(&value)); return value; }
			GameControllerVersionInfo operator()() { return get(); }
			operator GameControllerVersionInfo () { return get(); }
		} FirmwareVersionInfo;
		struct : property {
			unsigned short get() { unsigned short value; hrcheck(enc(&IGameControllerProvider_adaptor::HardwareProductId)->_get_HardwareProductId(&value)); return value; }
			unsigned short operator()() { return get(); }
			operator unsigned short () { return get(); }
		} HardwareProductId;
		struct : property {
			unsigned short get() { unsigned short value; hrcheck(enc(&IGameControllerProvider_adaptor::HardwareVendorId)->_get_HardwareVendorId(&value)); return value; }
			unsigned short operator()() { return get(); }
			operator unsigned short () { return get(); }
		} HardwareVendorId;
		struct : property {
			GameControllerVersionInfo get() { GameControllerVersionInfo value; hrcheck(enc(&IGameControllerProvider_adaptor::HardwareVersionInfo)->_get_HardwareVersionInfo(&value)); return value; }
			GameControllerVersionInfo operator()() { return get(); }
			operator GameControllerVersionInfo () { return get(); }
		} HardwareVersionInfo;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGameControllerProvider_adaptor::IsConnected)->_get_IsConnected(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsConnected;
	};
	IGameControllerProvider_adaptor() {}
};
template<typename X> struct adapt<IGameControllerProvider, X> : Windows::Gaming::Input::Custom::IGameControllerProvider_adaptor<X> { typedef adapt IGameControllerProvider; };
template<typename X> struct IGameControllerProvider_unadaptor : X {
	STDMETHODIMP _get_FirmwareVersionInfo(GameControllerVersionInfo *value) { return hrtry([&, this] { get_prop(value, FirmwareVersionInfo); }); }
	STDMETHODIMP _get_HardwareProductId(unsigned short *value) { return hrtry([&, this] { get_prop(value, HardwareProductId); }); }
	STDMETHODIMP _get_HardwareVendorId(unsigned short *value) { return hrtry([&, this] { get_prop(value, HardwareVendorId); }); }
	STDMETHODIMP _get_HardwareVersionInfo(GameControllerVersionInfo *value) { return hrtry([&, this] { get_prop(value, HardwareVersionInfo); }); }
	STDMETHODIMP _get_IsConnected(bool *value) { return hrtry([&, this] { get_prop(value, IsConnected); }); }
};
template<typename X> struct unadapt<IGameControllerProvider, X> : Windows::Gaming::Input::Custom::IGameControllerProvider_unadaptor<X> {};
struct IGameControllerProvider : IGameControllerProvider_raw, generate<IGameControllerProvider> {};

// IGipGameControllerProvider
struct IGipGameControllerProvider_raw : IInspectable {
	virtual STDMETHODIMP _SendMessage(GipMessageClass messageClass, unsigned char messageId, unsigned messageBufferSize, unsigned char *messageBuffer);
	virtual STDMETHODIMP _SendReceiveMessage(GipMessageClass messageClass, unsigned char messageId, unsigned requestMessageBufferSize, unsigned char *requestMessageBuffer, unsigned responseMessageBufferSize, unsigned char *responseMessageBuffer);
	virtual STDMETHODIMP _UpdateFirmwareAsync(Storage::Streams::IInputStream* firmwareImage, Foundation::IAsyncOperationWithProgress<GipFirmwareUpdateResult*, GipFirmwareUpdateProgress>* *result);
};
template<typename X> struct IGipGameControllerProvider_adaptor : X {
	void SendMessage(GipMessageClass messageClass, unsigned char messageId, const szarray<unsigned char>& messageBuffer) { hrcheck(X::get()->_SendMessage(messageClass, messageId, messageBuffer.size, to_abi(messageBuffer.p))); }
	void SendReceiveMessage(GipMessageClass messageClass, unsigned char messageId, const szarray<unsigned char>& requestMessageBuffer, const szarray<unsigned char>& responseMessageBuffer) { hrcheck(X::get()->_SendReceiveMessage(messageClass, messageId, requestMessageBuffer.size, to_abi(requestMessageBuffer.p), responseMessageBuffer.size, to_abi(responseMessageBuffer.p))); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<GipFirmwareUpdateResult>, GipFirmwareUpdateProgress>> UpdateFirmwareAsync(pptr<Storage::Streams::IInputStream> firmwareImage) { Foundation::IAsyncOperationWithProgress<GipFirmwareUpdateResult*, GipFirmwareUpdateProgress>* result; hrcheck(X::get()->_UpdateFirmwareAsync(firmwareImage, &result)); return from_abi(result); }
};
template<typename X> struct adapt<IGipGameControllerProvider, X> : Windows::Gaming::Input::Custom::IGipGameControllerProvider_adaptor<X> { typedef adapt IGipGameControllerProvider; };
struct IGipGameControllerProvider : IGipGameControllerProvider_raw, generate<IGipGameControllerProvider> {};

// GipFirmwareUpdateResult
template<typename X> struct statics<GipFirmwareUpdateResult, X> : X {
	typedef typename X::root_type GipFirmwareUpdateResult;
};
struct GipFirmwareUpdateResult : generate<GipFirmwareUpdateResult> {};

// IHidGameControllerProvider
struct IHidGameControllerProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_UsageId(unsigned short *value);
	virtual STDMETHODIMP _get_UsagePage(unsigned short *value);
	virtual STDMETHODIMP _GetFeatureReport(unsigned char reportId, unsigned reportBufferSize, unsigned char *reportBuffer);
	virtual STDMETHODIMP _SendFeatureReport(unsigned char reportId, unsigned reportBufferSize, unsigned char *reportBuffer);
	virtual STDMETHODIMP _SendOutputReport(unsigned char reportId, unsigned reportBufferSize, unsigned char *reportBuffer);
};
template<typename X> struct IHidGameControllerProvider_adaptor : X {
	union {
		struct : property {
			unsigned short get() { unsigned short value; hrcheck(enc(&IHidGameControllerProvider_adaptor::UsageId)->_get_UsageId(&value)); return value; }
			unsigned short operator()() { return get(); }
			operator unsigned short () { return get(); }
		} UsageId;
		struct : property {
			unsigned short get() { unsigned short value; hrcheck(enc(&IHidGameControllerProvider_adaptor::UsagePage)->_get_UsagePage(&value)); return value; }
			unsigned short operator()() { return get(); }
			operator unsigned short () { return get(); }
		} UsagePage;
	};
	void GetFeatureReport(unsigned char reportId, const szarray<unsigned char>& reportBuffer) { hrcheck(X::get()->_GetFeatureReport(reportId, reportBuffer.size, to_abi(reportBuffer.p))); }
	void SendFeatureReport(unsigned char reportId, const szarray<unsigned char>& reportBuffer) { hrcheck(X::get()->_SendFeatureReport(reportId, reportBuffer.size, to_abi(reportBuffer.p))); }
	void SendOutputReport(unsigned char reportId, const szarray<unsigned char>& reportBuffer) { hrcheck(X::get()->_SendOutputReport(reportId, reportBuffer.size, to_abi(reportBuffer.p))); }
	IHidGameControllerProvider_adaptor() {}
};
template<typename X> struct adapt<IHidGameControllerProvider, X> : Windows::Gaming::Input::Custom::IHidGameControllerProvider_adaptor<X> { typedef adapt IHidGameControllerProvider; };
struct IHidGameControllerProvider : IHidGameControllerProvider_raw, generate<IHidGameControllerProvider> {};

// IXusbGameControllerProvider
struct IXusbGameControllerProvider_raw : IInspectable {
	virtual STDMETHODIMP _SetVibration(double lowFrequencyMotorSpeed, double highFrequencyMotorSpeed);
};
template<typename X> struct IXusbGameControllerProvider_adaptor : X {
	void SetVibration(double lowFrequencyMotorSpeed, double highFrequencyMotorSpeed) { hrcheck(X::get()->_SetVibration(lowFrequencyMotorSpeed, highFrequencyMotorSpeed)); }
};
template<typename X> struct adapt<IXusbGameControllerProvider, X> : Windows::Gaming::Input::Custom::IXusbGameControllerProvider_adaptor<X> { typedef adapt IXusbGameControllerProvider; };
struct IXusbGameControllerProvider : IXusbGameControllerProvider_raw, generate<IXusbGameControllerProvider> {};

// ICustomGameControllerFactory
struct ICustomGameControllerFactory_raw : IInspectable {
	virtual STDMETHODIMP _CreateGameController(IGameControllerProvider* provider, IInspectable* *value) = 0;
	virtual STDMETHODIMP _OnGameControllerAdded(IGameController* value) = 0;
	virtual STDMETHODIMP _OnGameControllerRemoved(IGameController* value) = 0;
};
template<typename X> struct ICustomGameControllerFactory_adaptor : X {
	object CreateGameController(pptr<IGameControllerProvider> provider) { IInspectable* value; hrcheck(X::get()->_CreateGameController(provider, &value)); return from_abi(value); }
	void OnGameControllerAdded(pptr<IGameController> value) { hrcheck(X::get()->_OnGameControllerAdded(value)); }
	void OnGameControllerRemoved(pptr<IGameController> value) { hrcheck(X::get()->_OnGameControllerRemoved(value)); }
};
template<typename X> struct adapt<ICustomGameControllerFactory, X> : Windows::Gaming::Input::Custom::ICustomGameControllerFactory_adaptor<X> { typedef adapt ICustomGameControllerFactory; };
template<typename X> struct ICustomGameControllerFactory_unadaptor : X {
	STDMETHODIMP _CreateGameController(IGameControllerProvider* provider, IInspectable* *value) { return hrtry([&, this] { *value = to_abi(X::get()->CreateGameController(provider)); }); }
	STDMETHODIMP _OnGameControllerAdded(IGameController* value) { return hrtry([&, this] { X::get()->OnGameControllerAdded(value); }); }
	STDMETHODIMP _OnGameControllerRemoved(IGameController* value) { return hrtry([&, this] { X::get()->OnGameControllerRemoved(value); }); }
};
template<typename X> struct unadapt<ICustomGameControllerFactory, X> : Windows::Gaming::Input::Custom::ICustomGameControllerFactory_unadaptor<X> {};
struct ICustomGameControllerFactory : ICustomGameControllerFactory_raw, generate<ICustomGameControllerFactory> {};

// IGameControllerFactoryManagerStatics
struct IGameControllerFactoryManagerStatics : IInspectable {
	virtual STDMETHODIMP _RegisterCustomFactoryForGipInterface(ICustomGameControllerFactory* factory, Platform::Guid interfaceId);
	virtual STDMETHODIMP _RegisterCustomFactoryForHardwareId(ICustomGameControllerFactory* factory, unsigned short hardwareVendorId, unsigned short hardwareProductId);
	virtual STDMETHODIMP _RegisterCustomFactoryForXusbType(ICustomGameControllerFactory* factory, XusbDeviceType xusbType, XusbDeviceSubtype xusbSubtype);
};

// IGameControllerFactoryManagerStatics2
struct IGameControllerFactoryManagerStatics2 : IInspectable {
	virtual STDMETHODIMP _TryGetFactoryControllerFromGameController(ICustomGameControllerFactory* factory, IGameController* gameController, IGameController* *factoryController);
};

// GipGameControllerProvider
template<typename X> struct statics<GipGameControllerProvider, X> : X {
	typedef typename X::root_type GipGameControllerProvider;
};
struct GipGameControllerProvider : generate<GipGameControllerProvider> {};

// HidGameControllerProvider
template<typename X> struct statics<HidGameControllerProvider, X> : X {
	typedef typename X::root_type HidGameControllerProvider;
};
struct HidGameControllerProvider : generate<HidGameControllerProvider> {};

// XusbGameControllerProvider
template<typename X> struct statics<XusbGameControllerProvider, X> : X {
	typedef typename X::root_type XusbGameControllerProvider;
};
struct XusbGameControllerProvider : generate<XusbGameControllerProvider> {};

// GameControllerFactoryManager
template<typename> struct GameControllerFactoryManager_statics {
	static ptr<IGameController> TryGetFactoryControllerFromGameController(pptr<ICustomGameControllerFactory> factory, pptr<IGameController> gameController) { IGameController* factoryController; hrcheck(get_activation_factory<GameControllerFactoryManager, IGameControllerFactoryManagerStatics2>()->_TryGetFactoryControllerFromGameController(factory, gameController, &factoryController)); return from_abi(factoryController); }
	static void RegisterCustomFactoryForGipInterface(pptr<ICustomGameControllerFactory> factory, const Platform::Guid& interfaceId) { hrcheck(get_activation_factory<GameControllerFactoryManager, IGameControllerFactoryManagerStatics>()->_RegisterCustomFactoryForGipInterface(factory, interfaceId)); }
	static void RegisterCustomFactoryForHardwareId(pptr<ICustomGameControllerFactory> factory, unsigned short hardwareVendorId, unsigned short hardwareProductId) { hrcheck(get_activation_factory<GameControllerFactoryManager, IGameControllerFactoryManagerStatics>()->_RegisterCustomFactoryForHardwareId(factory, hardwareVendorId, hardwareProductId)); }
	static void RegisterCustomFactoryForXusbType(pptr<ICustomGameControllerFactory> factory, XusbDeviceType xusbType, XusbDeviceSubtype xusbSubtype) { hrcheck(get_activation_factory<GameControllerFactoryManager, IGameControllerFactoryManagerStatics>()->_RegisterCustomFactoryForXusbType(factory, xusbType, xusbSubtype)); }
};

template<typename X> struct statics<GameControllerFactoryManager, X> : X, Windows::Gaming::Input::Custom::GameControllerFactoryManager_statics<void> {
	typedef typename X::root_type GameControllerFactoryManager;
};
struct GameControllerFactoryManager : generate<GameControllerFactoryManager> {};
}}}}
} // namespace iso_winrt
