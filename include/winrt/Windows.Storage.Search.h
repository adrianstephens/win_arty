#pragma once
// generated by isopod tools
// namespaces:
// Windows.Storage.Search

#include "Windows.Storage.Search.0.h"
#include "Windows.Data.Text.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.Storage.FileProperties.0.h"
#include "Windows.Foundation.Collections.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Storage { namespace Streams {
struct IRandomAccessStream;
}
struct StorageFile;
struct StorageLibraryChangeTracker;
struct StorageFolder;
struct IStorageItem;
}}

// defs

template<> struct def<Windows::Storage::Search::IContentIndexerStatics> : interface_type<> {};
template<> struct def<Windows::Storage::Search::SortEntry> : value_type<HSTRING, bool> {};
template<> struct def<Windows::Storage::Search::IContentIndexerQueryOperations> : interface_type<> {};
template<> struct def<Windows::Storage::Search::IContentIndexer> : interface_type<> {};
template<> struct def<Windows::Storage::Search::ContentIndexer> : class_type<Platform::Object, Windows::Storage::Search::IContentIndexer, Windows::Storage::Search::IContentIndexerQueryOperations> {};
template<> struct def<Windows::Storage::Search::IIndexableContent> : overridable_type<> {};
template<> struct def<Windows::Storage::Search::IValueAndLanguage> : interface_type<> {};
template<> struct def<Windows::Storage::Search::ValueAndLanguage> : class_type<Platform::Object, Windows::Storage::Search::IValueAndLanguage> {};
template<> struct def<Windows::Storage::Search::IContentIndexerQuery> : interface_type<> {};
template<> struct def<Windows::Storage::Search::ContentIndexerQuery> : class_type<Platform::Object, Windows::Storage::Search::IContentIndexerQuery> {};
template<> struct def<Windows::Storage::Search::IndexableContent> : class_type<Platform::Object, Windows::Storage::Search::IIndexableContent> {};
template<> struct def<Windows::Storage::Search::DateStackOption> : enum_type<int> {};
template<> struct def<Windows::Storage::Search::IndexerOption> : enum_type<int> {};
template<> struct def<Windows::Storage::Search::FolderDepth> : enum_type<int> {};
template<> struct def<Windows::Storage::Search::CommonFileQuery> : enum_type<int> {};
template<> struct def<Windows::Storage::Search::CommonFolderQuery> : enum_type<int> {};
template<> struct def<Windows::Storage::Search::IndexedState> : enum_type<int> {};
template<> struct def<Windows::Storage::Search::IQueryOptions> : interface_type<> {};
template<> struct def<Windows::Storage::Search::IQueryOptionsWithProviderFilter> : interface_type<> {};
template<> struct def<Windows::Storage::Search::IQueryOptionsFactory> : interface_type<> {};
template<> struct def<Windows::Storage::Search::QueryOptions> : class_type<Platform::Object, Windows::Storage::Search::IQueryOptions, Windows::Storage::Search::IQueryOptionsWithProviderFilter>, custom_activators {};
template<> struct def<Windows::Storage::Search::IStorageQueryResultBase> : overridable_type<> {};
template<> struct def<Windows::Storage::Search::IStorageFileQueryResult> : interface_type<Windows::Storage::Search::IStorageQueryResultBase> {};
template<> struct def<Windows::Storage::Search::IStorageFileQueryResult2> : interface_type<Windows::Storage::Search::IStorageQueryResultBase> {};
template<> struct def<Windows::Storage::Search::IStorageFolderQueryResult> : interface_type<Windows::Storage::Search::IStorageQueryResultBase> {};
template<> struct def<Windows::Storage::Search::IStorageItemQueryResult> : interface_type<Windows::Storage::Search::IStorageQueryResultBase> {};
template<> struct def<Windows::Storage::Search::IStorageFolderQueryOperations> : overridable_type<> {};
template<> struct def<Windows::Storage::Search::StorageFileQueryResult> : class_type<Platform::Object, Windows::Storage::Search::IStorageFileQueryResult, Windows::Storage::Search::IStorageFileQueryResult2> {};
template<> struct def<Windows::Storage::Search::StorageFolderQueryResult> : class_type<Platform::Object, Windows::Storage::Search::IStorageFolderQueryResult> {};
template<> struct def<Windows::Storage::Search::StorageItemQueryResult> : class_type<Platform::Object, Windows::Storage::Search::IStorageItemQueryResult> {};
template<> struct def<Windows::Storage::Search::SortEntryVector> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<Windows::Storage::Search::SortEntry>, Windows::Foundation::Collections::IIterable<Windows::Storage::Search::SortEntry>> {};
template<> struct def<Windows::Storage::Search::IStorageLibraryContentChangedTriggerDetails> : interface_type<> {};
template<> struct def<Windows::Storage::Search::StorageLibraryContentChangedTriggerDetails> : class_type<Platform::Object, Windows::Storage::Search::IStorageLibraryContentChangedTriggerDetails> {};
template<> struct def<Windows::Storage::Search::IStorageLibraryChangeTrackerTriggerDetails> : interface_type<> {};
template<> struct def<Windows::Storage::Search::StorageLibraryChangeTrackerTriggerDetails> : class_type<Platform::Object, Windows::Storage::Search::IStorageLibraryChangeTrackerTriggerDetails> {};

// uuids

template<> struct uuid<Windows::Storage::Search::IContentIndexerStatics> { define_guid(0x8C488375, 0xB37E, 0x4C60, 0x9B, 0xA8, 0xB7, 0x60, 0xFD, 0xA3, 0xE5, 0x9D);};
template<> struct uuid<Windows::Storage::Search::IContentIndexerQueryOperations> { define_guid(0x28823E10, 0x4786, 0x42F1, 0x97, 0x30, 0x79, 0x2B, 0x35, 0x66, 0xB1, 0x50);};
template<> struct uuid<Windows::Storage::Search::IContentIndexer> { define_guid(0xB1767F8D, 0xF698, 0x4982, 0xB0, 0x5F, 0x3A, 0x6E, 0x8C, 0xAB, 0x1, 0xA2);};
template<> struct uuid<Windows::Storage::Search::IIndexableContent> { define_guid(0xCCF1A05F, 0xD4B5, 0x483A, 0xB0, 0x6E, 0xE0, 0xDB, 0x1E, 0xC4, 0x20, 0xE4);};
template<> struct uuid<Windows::Storage::Search::IValueAndLanguage> { define_guid(0xB9914881, 0xA1EE, 0x4BC4, 0x92, 0xA5, 0x46, 0x69, 0x68, 0xE3, 0x4, 0x36);};
template<> struct uuid<Windows::Storage::Search::IContentIndexerQuery> { define_guid(0x70E3B0F8, 0x4BFC, 0x428A, 0x88, 0x89, 0xCC, 0x51, 0xDA, 0x9A, 0x7B, 0x9D);};
template<> struct uuid<Windows::Storage::Search::IQueryOptions> { define_guid(0x1E5E46EE, 0xF45, 0x4838, 0xA8, 0xE9, 0xD0, 0x47, 0x9D, 0x44, 0x6C, 0x30);};
template<> struct uuid<Windows::Storage::Search::IQueryOptionsWithProviderFilter> { define_guid(0x5B9D1026, 0x15C4, 0x44DD, 0xB8, 0x9A, 0x47, 0xA5, 0x9B, 0x7D, 0x7C, 0x4F);};
template<> struct uuid<Windows::Storage::Search::IQueryOptionsFactory> { define_guid(0x32E1F8C, 0xA9C1, 0x4E71, 0x80, 0x11, 0xD, 0xEE, 0x9D, 0x48, 0x11, 0xA3);};
template<> struct uuid<Windows::Storage::Search::IStorageQueryResultBase> { define_guid(0xC297D70D, 0x7353, 0x47AB, 0xBA, 0x58, 0x8C, 0x61, 0x42, 0x5D, 0xC5, 0x4B);};
template<> struct uuid<Windows::Storage::Search::IStorageFileQueryResult> { define_guid(0x52FDA447, 0x2BAA, 0x412C, 0xB2, 0x9F, 0xD4, 0xB1, 0x77, 0x8E, 0xFA, 0x1E);};
template<> struct uuid<Windows::Storage::Search::IStorageFileQueryResult2> { define_guid(0x4E5DB9DD, 0x7141, 0x46C4, 0x8B, 0xE3, 0xE9, 0xDC, 0x9E, 0x27, 0x27, 0x5C);};
template<> struct uuid<Windows::Storage::Search::IStorageFolderQueryResult> { define_guid(0x6654C911, 0x7D66, 0x46FA, 0xAE, 0xCF, 0xE4, 0xA4, 0xBA, 0xA9, 0x3A, 0xB8);};
template<> struct uuid<Windows::Storage::Search::IStorageItemQueryResult> { define_guid(0xE8948079, 0x9D58, 0x47B8, 0xB2, 0xB2, 0x41, 0xB0, 0x7F, 0x47, 0x95, 0xF9);};
template<> struct uuid<Windows::Storage::Search::IStorageFolderQueryOperations> { define_guid(0xCB43CCC9, 0x446B, 0x4A4F, 0xBE, 0x97, 0x75, 0x77, 0x71, 0xBE, 0x52, 0x3);};
template<> struct uuid<Windows::Storage::Search::IStorageLibraryContentChangedTriggerDetails> { define_guid(0x2A371977, 0xABBF, 0x4E1D, 0x8A, 0xA5, 0x63, 0x85, 0xD8, 0x88, 0x47, 0x99);};
template<> struct uuid<Windows::Storage::Search::IStorageLibraryChangeTrackerTriggerDetails> { define_guid(0x1DC7A369, 0xB7A3, 0x4DF2, 0x9D, 0x61, 0xEB, 0xA8, 0x5A, 0x3, 0x43, 0xD2);};

// types

namespace Windows { namespace Storage { namespace Search {

// IContentIndexerStatics
struct IContentIndexerStatics : IInspectable {
	virtual STDMETHODIMP _GetIndexerWithName(HSTRING indexName, ContentIndexer* *index);
	virtual STDMETHODIMP _GetIndexer(ContentIndexer* *index);
};

// IContentIndexerQueryOperations
struct IContentIndexerQueryOperations_raw : IInspectable {
	virtual STDMETHODIMP _CreateQueryWithSortOrderAndLanguage(HSTRING searchFilter, Foundation::Collections::IIterable<HSTRING>* propertiesToRetrieve, Foundation::Collections::IIterable<SortEntry>* sortOrder, HSTRING searchFilterLanguage, ContentIndexerQuery* *query);
	virtual STDMETHODIMP _CreateQueryWithSortOrder(HSTRING searchFilter, Foundation::Collections::IIterable<HSTRING>* propertiesToRetrieve, Foundation::Collections::IIterable<SortEntry>* sortOrder, ContentIndexerQuery* *query);
	virtual STDMETHODIMP _CreateQuery(HSTRING searchFilter, Foundation::Collections::IIterable<HSTRING>* propertiesToRetrieve, ContentIndexerQuery* *query);
};
template<typename X> struct IContentIndexerQueryOperations_adaptor : X {
	ptr<ContentIndexerQuery> CreateQuery(hstring_ref searchFilter, pptr<Foundation::Collections::IIterable<hstring>> propertiesToRetrieve, pptr<Foundation::Collections::IIterable<SortEntry>> sortOrder, hstring_ref searchFilterLanguage) { ContentIndexerQuery* query; hrcheck(X::get()->_CreateQueryWithSortOrderAndLanguage(searchFilter, to_abi(propertiesToRetrieve), to_abi(sortOrder), searchFilterLanguage, &query)); return from_abi(query); }
	ptr<ContentIndexerQuery> CreateQuery(hstring_ref searchFilter, pptr<Foundation::Collections::IIterable<hstring>> propertiesToRetrieve, pptr<Foundation::Collections::IIterable<SortEntry>> sortOrder) { ContentIndexerQuery* query; hrcheck(X::get()->_CreateQueryWithSortOrder(searchFilter, to_abi(propertiesToRetrieve), to_abi(sortOrder), &query)); return from_abi(query); }
	ptr<ContentIndexerQuery> CreateQuery(hstring_ref searchFilter, pptr<Foundation::Collections::IIterable<hstring>> propertiesToRetrieve) { ContentIndexerQuery* query; hrcheck(X::get()->_CreateQuery(searchFilter, to_abi(propertiesToRetrieve), &query)); return from_abi(query); }
};
template<typename X> struct adapt<IContentIndexerQueryOperations, X> : Windows::Storage::Search::IContentIndexerQueryOperations_adaptor<X> { typedef adapt IContentIndexerQueryOperations; };
struct IContentIndexerQueryOperations : IContentIndexerQueryOperations_raw, generate<IContentIndexerQueryOperations> {};

// IContentIndexer
struct IContentIndexer_raw : IInspectable {
	virtual STDMETHODIMP _AddAsync(IIndexableContent* indexableContent, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _UpdateAsync(IIndexableContent* indexableContent, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _DeleteAsync(HSTRING contentId, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _DeleteMultipleAsync(Foundation::Collections::IIterable<HSTRING>* contentIds, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _DeleteAllAsync(Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _RetrievePropertiesAsync(HSTRING contentId, Foundation::Collections::IIterable<HSTRING>* propertiesToRetrieve, Foundation::IAsyncOperation<Foundation::Collections::IMapView<HSTRING, IInspectable*>*>* *operation);
	virtual STDMETHODIMP _get_Revision(unsigned __int64 *value);
};
template<typename X> struct IContentIndexer_adaptor : X {
	union {
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IContentIndexer_adaptor::Revision)->_get_Revision(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} Revision;
	};
	ptr<Foundation::IAsyncAction> AddAsync(pptr<IIndexableContent> indexableContent) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_AddAsync(indexableContent, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> UpdateAsync(pptr<IIndexableContent> indexableContent) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_UpdateAsync(indexableContent, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> DeleteAsync(hstring_ref contentId) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_DeleteAsync(contentId, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> DeleteMultipleAsync(pptr<Foundation::Collections::IIterable<hstring>> contentIds) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_DeleteMultipleAsync(to_abi(contentIds), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> DeleteAllAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_DeleteAllAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IMapView<hstring, object>>>> RetrievePropertiesAsync(hstring_ref contentId, pptr<Foundation::Collections::IIterable<hstring>> propertiesToRetrieve) { Foundation::IAsyncOperation<Foundation::Collections::IMapView<HSTRING, IInspectable*>*>* operation; hrcheck(X::get()->_RetrievePropertiesAsync(contentId, to_abi(propertiesToRetrieve), &operation)); return from_abi(operation); }
	IContentIndexer_adaptor() {}
};
template<typename X> struct adapt<IContentIndexer, X> : Windows::Storage::Search::IContentIndexer_adaptor<X> { typedef adapt IContentIndexer; };
struct IContentIndexer : IContentIndexer_raw, generate<IContentIndexer> {};

// ContentIndexer
template<typename> struct ContentIndexer_statics {
	static ptr<ContentIndexer> GetIndexer(hstring_ref indexName) { ContentIndexer* index; hrcheck(get_activation_factory<ContentIndexer, IContentIndexerStatics>()->_GetIndexerWithName(indexName, &index)); return from_abi(index); }
	static ptr<ContentIndexer> GetIndexer() { ContentIndexer* index; hrcheck(get_activation_factory<ContentIndexer, IContentIndexerStatics>()->_GetIndexer(&index)); return from_abi(index); }
};

template<typename X> struct statics<ContentIndexer, X> : X, Windows::Storage::Search::ContentIndexer_statics<void> {
	typedef typename X::root_type ContentIndexer;
};
struct ContentIndexer : generate<ContentIndexer> {
	using IContentIndexerQueryOperations::CreateQuery;
};

// IIndexableContent
struct IIndexableContent_raw : IInspectable {
	virtual STDMETHODIMP _get_Id(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_Id(HSTRING value) = 0;
	virtual STDMETHODIMP _get_Properties(Foundation::Collections::IMap<HSTRING, IInspectable*>* *value) = 0;
	virtual STDMETHODIMP _get_Stream(Streams::IRandomAccessStream* *value) = 0;
	virtual STDMETHODIMP _put_Stream(Streams::IRandomAccessStream* value) = 0;
	virtual STDMETHODIMP _get_StreamContentType(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_StreamContentType(HSTRING value) = 0;
};
template<typename X> struct IIndexableContent_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IIndexableContent_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IIndexableContent_adaptor::Id)->_put_Id(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Id;
		struct : property {
			ptr<Foundation::Collections::IMap<hstring, object>> get() { Foundation::Collections::IMap<HSTRING, IInspectable*>* value; hrcheck(enc(&IIndexableContent_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMap<hstring, object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMap<hstring, object>> () { return get(); }
			ptr<Foundation::Collections::IMap<hstring, object>> operator->() { return get(); }
		} Properties;
		struct : property {
			ptr<Streams::IRandomAccessStream> get() { Streams::IRandomAccessStream* value; hrcheck(enc(&IIndexableContent_adaptor::Stream)->_get_Stream(&value)); return from_abi(value); }
			ptr<Streams::IRandomAccessStream> operator()() { return get(); }
			operator ptr<Streams::IRandomAccessStream> () { return get(); }
			ptr<Streams::IRandomAccessStream> operator->() { return get(); }
			void put(pptr<Streams::IRandomAccessStream> value) { hrcheck(enc(&IIndexableContent_adaptor::Stream)->_put_Stream(value)); }
			void operator=(pptr<Streams::IRandomAccessStream> value) { put(value); }
			void operator()(pptr<Streams::IRandomAccessStream> value) { put(value); }
		} Stream;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IIndexableContent_adaptor::StreamContentType)->_get_StreamContentType(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IIndexableContent_adaptor::StreamContentType)->_put_StreamContentType(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} StreamContentType;
	};
	IIndexableContent_adaptor() {}
};
template<typename X> struct adapt<IIndexableContent, X> : Windows::Storage::Search::IIndexableContent_adaptor<X> { typedef adapt IIndexableContent; };
template<typename X> struct IIndexableContent_unadaptor : X {
	STDMETHODIMP _get_Id(HSTRING *value) { return hrtry([&, this] { get_prop(value, Id); }); }
	STDMETHODIMP _put_Id(HSTRING value) { return hrtry([&, this] { put_prop(value, Id); }); }
	STDMETHODIMP _get_Properties(Foundation::Collections::IMap<HSTRING, IInspectable*>* *value) { return hrtry([&, this] { get_prop(value, Properties); }); }
	STDMETHODIMP _get_Stream(Streams::IRandomAccessStream* *value) { return hrtry([&, this] { get_prop(value, Stream); }); }
	STDMETHODIMP _put_Stream(Streams::IRandomAccessStream* value) { return hrtry([&, this] { put_prop(value, Stream); }); }
	STDMETHODIMP _get_StreamContentType(HSTRING *value) { return hrtry([&, this] { get_prop(value, StreamContentType); }); }
	STDMETHODIMP _put_StreamContentType(HSTRING value) { return hrtry([&, this] { put_prop(value, StreamContentType); }); }
};
template<typename X> struct unadapt<IIndexableContent, X> : Windows::Storage::Search::IIndexableContent_unadaptor<X> {};
struct IIndexableContent : IIndexableContent_raw, generate<IIndexableContent> {};

// IValueAndLanguage
struct IValueAndLanguage_raw : IInspectable {
	virtual STDMETHODIMP _get_Language(HSTRING *value);
	virtual STDMETHODIMP _put_Language(HSTRING value);
	virtual STDMETHODIMP _get_Value(IInspectable* *value);
	virtual STDMETHODIMP _put_Value(IInspectable* value);
};
template<typename X> struct IValueAndLanguage_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IValueAndLanguage_adaptor::Language)->_get_Language(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IValueAndLanguage_adaptor::Language)->_put_Language(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Language;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IValueAndLanguage_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IValueAndLanguage_adaptor::Value)->_put_Value(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Value;
	};
	IValueAndLanguage_adaptor() {}
};
template<typename X> struct adapt<IValueAndLanguage, X> : Windows::Storage::Search::IValueAndLanguage_adaptor<X> { typedef adapt IValueAndLanguage; };
struct IValueAndLanguage : IValueAndLanguage_raw, generate<IValueAndLanguage> {};

// ValueAndLanguage
template<typename X> struct statics<ValueAndLanguage, X> : X {
	typedef typename X::root_type ValueAndLanguage;
};
struct ValueAndLanguage : generate<ValueAndLanguage> {};

// IContentIndexerQuery
struct IContentIndexerQuery_raw : IInspectable {
	virtual STDMETHODIMP _GetCountAsync(Foundation::IAsyncOperation<unsigned>* *operation);
	virtual STDMETHODIMP _GetPropertiesAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Foundation::Collections::IMapView<HSTRING, IInspectable*>*>*>* *operation);
	virtual STDMETHODIMP _GetPropertiesRangeAsync(unsigned startIndex, unsigned maxItems, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Foundation::Collections::IMapView<HSTRING, IInspectable*>*>*>* *operation);
	virtual STDMETHODIMP _GetAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IIndexableContent*>*>* *operation);
	virtual STDMETHODIMP _GetRangeAsync(unsigned startIndex, unsigned maxItems, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IIndexableContent*>*>* *operation);
	virtual STDMETHODIMP _get_QueryFolder(StorageFolder* *value);
};
template<typename X> struct IContentIndexerQuery_adaptor : X {
	union {
		struct : property {
			ptr<StorageFolder> get() { StorageFolder* value; hrcheck(enc(&IContentIndexerQuery_adaptor::QueryFolder)->_get_QueryFolder(&value)); return from_abi(value); }
			ptr<StorageFolder> operator()() { return get(); }
			operator ptr<StorageFolder> () { return get(); }
			ptr<StorageFolder> operator->() { return get(); }
		} QueryFolder;
	};
	ptr<Foundation::IAsyncOperation<unsigned>> GetCountAsync() { Foundation::IAsyncOperation<unsigned>* operation; hrcheck(X::get()->_GetCountAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<Foundation::Collections::IMapView<hstring, object>>>>>> GetPropertiesAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Foundation::Collections::IMapView<HSTRING, IInspectable*>*>*>* operation; hrcheck(X::get()->_GetPropertiesAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<Foundation::Collections::IMapView<hstring, object>>>>>> GetPropertiesAsync(unsigned startIndex, unsigned maxItems) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Foundation::Collections::IMapView<HSTRING, IInspectable*>*>*>* operation; hrcheck(X::get()->_GetPropertiesRangeAsync(startIndex, maxItems, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<IIndexableContent>>>>> GetAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IIndexableContent*>*>* operation; hrcheck(X::get()->_GetAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<IIndexableContent>>>>> GetAsync(unsigned startIndex, unsigned maxItems) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IIndexableContent*>*>* operation; hrcheck(X::get()->_GetRangeAsync(startIndex, maxItems, &operation)); return from_abi(operation); }
	IContentIndexerQuery_adaptor() {}
};
template<typename X> struct adapt<IContentIndexerQuery, X> : Windows::Storage::Search::IContentIndexerQuery_adaptor<X> { typedef adapt IContentIndexerQuery; };
struct IContentIndexerQuery : IContentIndexerQuery_raw, generate<IContentIndexerQuery> {};

// ContentIndexerQuery
template<typename X> struct statics<ContentIndexerQuery, X> : X {
	typedef typename X::root_type ContentIndexerQuery;
};
struct ContentIndexerQuery : generate<ContentIndexerQuery> {
	using IContentIndexerQuery::GetAsync;
	using IContentIndexerQuery::GetPropertiesAsync;
};

// IndexableContent
template<typename X> struct statics<IndexableContent, X> : X {
	typedef typename X::root_type IndexableContent;
};
struct IndexableContent : generate<IndexableContent> {};

// IQueryOptions
struct IQueryOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_FileTypeFilter(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_FolderDepth(Search::FolderDepth *value);
	virtual STDMETHODIMP _put_FolderDepth(Search::FolderDepth value);
	virtual STDMETHODIMP _get_ApplicationSearchFilter(HSTRING *value);
	virtual STDMETHODIMP _put_ApplicationSearchFilter(HSTRING value);
	virtual STDMETHODIMP _get_UserSearchFilter(HSTRING *value);
	virtual STDMETHODIMP _put_UserSearchFilter(HSTRING value);
	virtual STDMETHODIMP _get_Language(HSTRING *value);
	virtual STDMETHODIMP _put_Language(HSTRING value);
	virtual STDMETHODIMP _get_IndexerOption(Search::IndexerOption *value);
	virtual STDMETHODIMP _put_IndexerOption(Search::IndexerOption value);
	virtual STDMETHODIMP _get_SortOrder(Foundation::Collections::IVector<SortEntry>* *value);
	virtual STDMETHODIMP _get_GroupPropertyName(HSTRING *value);
	virtual STDMETHODIMP _get_DateStackOption(Search::DateStackOption *value);
	virtual STDMETHODIMP _SaveToString(HSTRING *value);
	virtual STDMETHODIMP _LoadFromString(HSTRING value);
	virtual STDMETHODIMP _SetThumbnailPrefetch(FileProperties::ThumbnailMode mode, unsigned requestedSize, FileProperties::ThumbnailOptions options);
	virtual STDMETHODIMP _SetPropertyPrefetch(FileProperties::PropertyPrefetchOptions options, Foundation::Collections::IIterable<HSTRING>* propertiesToRetrieve);
};
template<typename X> struct IQueryOptions_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IQueryOptions_adaptor::ApplicationSearchFilter)->_get_ApplicationSearchFilter(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IQueryOptions_adaptor::ApplicationSearchFilter)->_put_ApplicationSearchFilter(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ApplicationSearchFilter;
		struct : property {
			Search::DateStackOption get() { Search::DateStackOption value; hrcheck(enc(&IQueryOptions_adaptor::DateStackOption)->_get_DateStackOption(&value)); return value; }
			Search::DateStackOption operator()() { return get(); }
			operator Search::DateStackOption () { return get(); }
		} DateStackOption;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IQueryOptions_adaptor::FileTypeFilter)->_get_FileTypeFilter(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} FileTypeFilter;
		struct : property {
			Search::FolderDepth get() { Search::FolderDepth value; hrcheck(enc(&IQueryOptions_adaptor::FolderDepth)->_get_FolderDepth(&value)); return value; }
			Search::FolderDepth operator()() { return get(); }
			operator Search::FolderDepth () { return get(); }
			void put(Search::FolderDepth value) { hrcheck(enc(&IQueryOptions_adaptor::FolderDepth)->_put_FolderDepth(value)); }
			void operator=(Search::FolderDepth value) { put(value); }
			void operator()(Search::FolderDepth value) { put(value); }
		} FolderDepth;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IQueryOptions_adaptor::GroupPropertyName)->_get_GroupPropertyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} GroupPropertyName;
		struct : property {
			Search::IndexerOption get() { Search::IndexerOption value; hrcheck(enc(&IQueryOptions_adaptor::IndexerOption)->_get_IndexerOption(&value)); return value; }
			Search::IndexerOption operator()() { return get(); }
			operator Search::IndexerOption () { return get(); }
			void put(Search::IndexerOption value) { hrcheck(enc(&IQueryOptions_adaptor::IndexerOption)->_put_IndexerOption(value)); }
			void operator=(Search::IndexerOption value) { put(value); }
			void operator()(Search::IndexerOption value) { put(value); }
		} IndexerOption;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IQueryOptions_adaptor::Language)->_get_Language(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IQueryOptions_adaptor::Language)->_put_Language(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Language;
		struct : property {
			ptr<Foundation::Collections::IVector<SortEntry>> get() { Foundation::Collections::IVector<SortEntry>* value; hrcheck(enc(&IQueryOptions_adaptor::SortOrder)->_get_SortOrder(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<SortEntry>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<SortEntry>> () { return get(); }
			ptr<Foundation::Collections::IVector<SortEntry>> operator->() { return get(); }
		} SortOrder;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IQueryOptions_adaptor::UserSearchFilter)->_get_UserSearchFilter(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IQueryOptions_adaptor::UserSearchFilter)->_put_UserSearchFilter(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} UserSearchFilter;
	};
	hstring SaveToString() { HSTRING value; hrcheck(X::get()->_SaveToString(&value)); return from_abi(value); }
	void LoadFromString(hstring_ref value) { hrcheck(X::get()->_LoadFromString(value)); }
	void SetThumbnailPrefetch(FileProperties::ThumbnailMode mode, unsigned requestedSize, FileProperties::ThumbnailOptions options) { hrcheck(X::get()->_SetThumbnailPrefetch(mode, requestedSize, options)); }
	void SetPropertyPrefetch(FileProperties::PropertyPrefetchOptions options, pptr<Foundation::Collections::IIterable<hstring>> propertiesToRetrieve) { hrcheck(X::get()->_SetPropertyPrefetch(options, to_abi(propertiesToRetrieve))); }
	IQueryOptions_adaptor() {}
};
template<typename X> struct adapt<IQueryOptions, X> : Windows::Storage::Search::IQueryOptions_adaptor<X> { typedef adapt IQueryOptions; };
struct IQueryOptions : IQueryOptions_raw, generate<IQueryOptions> {};

// IQueryOptionsWithProviderFilter
struct IQueryOptionsWithProviderFilter_raw : IInspectable {
	virtual STDMETHODIMP _get_StorageProviderIdFilter(Foundation::Collections::IVector<HSTRING>* *value);
};
template<typename X> struct IQueryOptionsWithProviderFilter_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IQueryOptionsWithProviderFilter_adaptor::StorageProviderIdFilter)->_get_StorageProviderIdFilter(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} StorageProviderIdFilter;
	};
	IQueryOptionsWithProviderFilter_adaptor() {}
};
template<typename X> struct adapt<IQueryOptionsWithProviderFilter, X> : Windows::Storage::Search::IQueryOptionsWithProviderFilter_adaptor<X> { typedef adapt IQueryOptionsWithProviderFilter; };
struct IQueryOptionsWithProviderFilter : IQueryOptionsWithProviderFilter_raw, generate<IQueryOptionsWithProviderFilter> {};

// IQueryOptionsFactory
struct IQueryOptionsFactory : IInspectable {
	virtual STDMETHODIMP _CreateCommonFileQuery(CommonFileQuery query, Foundation::Collections::IIterable<HSTRING>* fileTypeFilter, QueryOptions* *queryOptions);
	virtual STDMETHODIMP _CreateCommonFolderQuery(CommonFolderQuery query, QueryOptions* *queryOptions);
};

// QueryOptions
template<typename> struct QueryOptions_statics {
	static QueryOptions *activate(CommonFileQuery query, pptr<Foundation::Collections::IIterable<hstring>> fileTypeFilter) { QueryOptions *queryOptions; hrcheck(get_activation_factory<QueryOptions, IQueryOptionsFactory>()->_CreateCommonFileQuery(query, to_abi(fileTypeFilter), &queryOptions)); return queryOptions; }
	static QueryOptions *activate(CommonFolderQuery query) { QueryOptions *queryOptions; hrcheck(get_activation_factory<QueryOptions, IQueryOptionsFactory>()->_CreateCommonFolderQuery(query, &queryOptions)); return queryOptions; }
	static QueryOptions *activate() { QueryOptions *t; get_activation_factory<QueryOptions>()->ActivateInstance((IInspectable**)&t); return t; }
};

template<typename X> struct statics<QueryOptions, X> : X, Windows::Storage::Search::QueryOptions_statics<void> {
	using Windows::Storage::Search::QueryOptions_statics<void>::activate;
	typedef typename X::root_type QueryOptions;
};
struct QueryOptions : generate<QueryOptions> {};

// IStorageQueryResultBase
struct IStorageQueryResultBase_raw : IInspectable {
	virtual STDMETHODIMP _GetItemCountAsync(Foundation::IAsyncOperation<unsigned>* *operation) = 0;
	virtual STDMETHODIMP _get_Folder(StorageFolder* *container) = 0;
	virtual STDMETHODIMP _add_ContentsChanged(Foundation::TypedEventHandler<IStorageQueryResultBase*, IInspectable*>* handler, Foundation::EventRegistrationToken *eventCookie) = 0;
	virtual STDMETHODIMP _remove_ContentsChanged(Foundation::EventRegistrationToken eventCookie) = 0;
	virtual STDMETHODIMP _add_OptionsChanged(Foundation::TypedEventHandler<IStorageQueryResultBase*, IInspectable*>* changedHandler, Foundation::EventRegistrationToken *eventCookie) = 0;
	virtual STDMETHODIMP _remove_OptionsChanged(Foundation::EventRegistrationToken eventCookie) = 0;
	virtual STDMETHODIMP _FindStartIndexAsync(IInspectable* value, Foundation::IAsyncOperation<unsigned>* *operation) = 0;
	virtual STDMETHODIMP _GetCurrentQueryOptions(QueryOptions* *value) = 0;
	virtual STDMETHODIMP _ApplyNewQueryOptions(QueryOptions* newQueryOptions) = 0;
};
template<typename X> struct IStorageQueryResultBase_adaptor : X {
	union {
		struct : property {
			ptr<StorageFolder> get() { StorageFolder* container; hrcheck(enc(&IStorageQueryResultBase_adaptor::Folder)->_get_Folder(&container)); return from_abi(container); }
			ptr<StorageFolder> operator()() { return get(); }
			operator ptr<StorageFolder> () { return get(); }
			ptr<StorageFolder> operator->() { return get(); }
		} Folder;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<IStorageQueryResultBase>, object>> handler) { Foundation::EventRegistrationToken eventCookie; hrcheck(enc(&IStorageQueryResultBase_adaptor::ContentsChanged)->_add_ContentsChanged(to_abi(handler), &eventCookie)); return eventCookie; }
			void operator-=(const Foundation::EventRegistrationToken& eventCookie) { hrcheck(enc(&IStorageQueryResultBase_adaptor::ContentsChanged)->_remove_ContentsChanged(eventCookie)); }
		} ContentsChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<IStorageQueryResultBase>, object>> changedHandler) { Foundation::EventRegistrationToken eventCookie; hrcheck(enc(&IStorageQueryResultBase_adaptor::OptionsChanged)->_add_OptionsChanged(to_abi(changedHandler), &eventCookie)); return eventCookie; }
			void operator-=(const Foundation::EventRegistrationToken& eventCookie) { hrcheck(enc(&IStorageQueryResultBase_adaptor::OptionsChanged)->_remove_OptionsChanged(eventCookie)); }
		} OptionsChanged;
	};
	ptr<Foundation::IAsyncOperation<unsigned>> GetItemCountAsync() { Foundation::IAsyncOperation<unsigned>* operation; hrcheck(X::get()->_GetItemCountAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<unsigned>> FindStartIndexAsync(object_ref value) { Foundation::IAsyncOperation<unsigned>* operation; hrcheck(X::get()->_FindStartIndexAsync(value, &operation)); return from_abi(operation); }
	ptr<QueryOptions> GetCurrentQueryOptions() { QueryOptions* value; hrcheck(X::get()->_GetCurrentQueryOptions(&value)); return from_abi(value); }
	void ApplyNewQueryOptions(pptr<QueryOptions> newQueryOptions) { hrcheck(X::get()->_ApplyNewQueryOptions(newQueryOptions)); }
	IStorageQueryResultBase_adaptor() {}
};
template<typename X> struct adapt<IStorageQueryResultBase, X> : Windows::Storage::Search::IStorageQueryResultBase_adaptor<X> { typedef adapt IStorageQueryResultBase; };
template<typename X> struct IStorageQueryResultBase_unadaptor : X {
	STDMETHODIMP _GetItemCountAsync(Foundation::IAsyncOperation<unsigned>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetItemCountAsync()); }); }
	STDMETHODIMP _get_Folder(StorageFolder* *container) { return hrtry([&, this] { get_prop(container, Folder); }); }
	STDMETHODIMP _add_ContentsChanged(Foundation::TypedEventHandler<IStorageQueryResultBase*, IInspectable*>* handler, Foundation::EventRegistrationToken *eventCookie) { return hrtry([&, this] { *eventCookie = X::get()->ContentsChanged+=handler; }); }
	STDMETHODIMP _remove_ContentsChanged(Foundation::EventRegistrationToken eventCookie) { return hrtry([&, this] { X::get()->ContentsChanged-=eventCookie; }); }
	STDMETHODIMP _add_OptionsChanged(Foundation::TypedEventHandler<IStorageQueryResultBase*, IInspectable*>* changedHandler, Foundation::EventRegistrationToken *eventCookie) { return hrtry([&, this] { *eventCookie = X::get()->OptionsChanged+=changedHandler; }); }
	STDMETHODIMP _remove_OptionsChanged(Foundation::EventRegistrationToken eventCookie) { return hrtry([&, this] { X::get()->OptionsChanged-=eventCookie; }); }
	STDMETHODIMP _FindStartIndexAsync(IInspectable* value, Foundation::IAsyncOperation<unsigned>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->FindStartIndexAsync(value)); }); }
	STDMETHODIMP _GetCurrentQueryOptions(QueryOptions* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetCurrentQueryOptions()); }); }
	STDMETHODIMP _ApplyNewQueryOptions(QueryOptions* newQueryOptions) { return hrtry([&, this] { X::get()->ApplyNewQueryOptions(newQueryOptions); }); }
};
template<typename X> struct unadapt<IStorageQueryResultBase, X> : Windows::Storage::Search::IStorageQueryResultBase_unadaptor<X> {};
struct IStorageQueryResultBase : IStorageQueryResultBase_raw, generate<IStorageQueryResultBase> {};

// IStorageFileQueryResult
struct IStorageFileQueryResult_raw : IInspectable {
	virtual STDMETHODIMP _GetFilesAsync(unsigned startIndex, unsigned maxNumberOfItems, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFile*>*>* *operation);
	virtual STDMETHODIMP _GetFilesAsyncDefaultStartAndCount(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFile*>*>* *operation);
};
template<typename X> struct IStorageFileQueryResult_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<StorageFile>>>>> GetFilesAsync(unsigned startIndex, unsigned maxNumberOfItems) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFile*>*>* operation; hrcheck(X::get()->_GetFilesAsync(startIndex, maxNumberOfItems, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<StorageFile>>>>> GetFilesAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFile*>*>* operation; hrcheck(X::get()->_GetFilesAsyncDefaultStartAndCount(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IStorageFileQueryResult, X> : Windows::Storage::Search::IStorageFileQueryResult_adaptor<X> { typedef adapt IStorageFileQueryResult; };
struct IStorageFileQueryResult : IStorageFileQueryResult_raw, generate<IStorageFileQueryResult> {};

// IStorageFileQueryResult2
struct IStorageFileQueryResult2_raw : IInspectable {
	virtual STDMETHODIMP _GetMatchingPropertiesWithRanges(StorageFile* file, Foundation::Collections::IMap<HSTRING, Foundation::Collections::IVectorView<Data::Text::TextSegment>*>* *result);
};
template<typename X> struct IStorageFileQueryResult2_adaptor : X {
	ptr<Foundation::Collections::IMap<hstring, ptr<Foundation::Collections::IVectorView<Data::Text::TextSegment>>>> GetMatchingPropertiesWithRanges(pptr<StorageFile> file) { Foundation::Collections::IMap<HSTRING, Foundation::Collections::IVectorView<Data::Text::TextSegment>*>* result; hrcheck(X::get()->_GetMatchingPropertiesWithRanges(file, &result)); return from_abi(result); }
};
template<typename X> struct adapt<IStorageFileQueryResult2, X> : Windows::Storage::Search::IStorageFileQueryResult2_adaptor<X> { typedef adapt IStorageFileQueryResult2; };
struct IStorageFileQueryResult2 : IStorageFileQueryResult2_raw, generate<IStorageFileQueryResult2> {};

// IStorageFolderQueryResult
struct IStorageFolderQueryResult_raw : IInspectable {
	virtual STDMETHODIMP _GetFoldersAsync(unsigned startIndex, unsigned maxNumberOfItems, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFolder*>*>* *operation);
	virtual STDMETHODIMP _GetFoldersAsyncDefaultStartAndCount(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFolder*>*>* *operation);
};
template<typename X> struct IStorageFolderQueryResult_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<StorageFolder>>>>> GetFoldersAsync(unsigned startIndex, unsigned maxNumberOfItems) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFolder*>*>* operation; hrcheck(X::get()->_GetFoldersAsync(startIndex, maxNumberOfItems, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<StorageFolder>>>>> GetFoldersAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFolder*>*>* operation; hrcheck(X::get()->_GetFoldersAsyncDefaultStartAndCount(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IStorageFolderQueryResult, X> : Windows::Storage::Search::IStorageFolderQueryResult_adaptor<X> { typedef adapt IStorageFolderQueryResult; };
struct IStorageFolderQueryResult : IStorageFolderQueryResult_raw, generate<IStorageFolderQueryResult> {};

// IStorageItemQueryResult
struct IStorageItemQueryResult_raw : IInspectable {
	virtual STDMETHODIMP _GetItemsAsync(unsigned startIndex, unsigned maxNumberOfItems, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IStorageItem*>*>* *operation);
	virtual STDMETHODIMP _GetItemsAsyncDefaultStartAndCount(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IStorageItem*>*>* *operation);
};
template<typename X> struct IStorageItemQueryResult_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<IStorageItem>>>>> GetItemsAsync(unsigned startIndex, unsigned maxNumberOfItems) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IStorageItem*>*>* operation; hrcheck(X::get()->_GetItemsAsync(startIndex, maxNumberOfItems, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<IStorageItem>>>>> GetItemsAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IStorageItem*>*>* operation; hrcheck(X::get()->_GetItemsAsyncDefaultStartAndCount(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IStorageItemQueryResult, X> : Windows::Storage::Search::IStorageItemQueryResult_adaptor<X> { typedef adapt IStorageItemQueryResult; };
struct IStorageItemQueryResult : IStorageItemQueryResult_raw, generate<IStorageItemQueryResult> {};

// IStorageFolderQueryOperations
struct IStorageFolderQueryOperations_raw : IInspectable {
	virtual STDMETHODIMP _GetIndexedStateAsync(Foundation::IAsyncOperation<IndexedState>* *operation) = 0;
	virtual STDMETHODIMP _CreateFileQueryOverloadDefault(StorageFileQueryResult* *value) = 0;
	virtual STDMETHODIMP _CreateFileQuery(CommonFileQuery query, StorageFileQueryResult* *value) = 0;
	virtual STDMETHODIMP _CreateFileQueryWithOptions(QueryOptions* queryOptions, StorageFileQueryResult* *value) = 0;
	virtual STDMETHODIMP _CreateFolderQueryOverloadDefault(StorageFolderQueryResult* *value) = 0;
	virtual STDMETHODIMP _CreateFolderQuery(CommonFolderQuery query, StorageFolderQueryResult* *value) = 0;
	virtual STDMETHODIMP _CreateFolderQueryWithOptions(QueryOptions* queryOptions, StorageFolderQueryResult* *value) = 0;
	virtual STDMETHODIMP _CreateItemQuery(StorageItemQueryResult* *value) = 0;
	virtual STDMETHODIMP _CreateItemQueryWithOptions(QueryOptions* queryOptions, StorageItemQueryResult* *value) = 0;
	virtual STDMETHODIMP _GetFilesAsync(CommonFileQuery query, unsigned startIndex, unsigned maxItemsToRetrieve, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFile*>*>* *operation) = 0;
	virtual STDMETHODIMP _GetFilesAsyncOverloadDefaultStartAndCount(CommonFileQuery query, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFile*>*>* *operation) = 0;
	virtual STDMETHODIMP _GetFoldersAsync(CommonFolderQuery query, unsigned startIndex, unsigned maxItemsToRetrieve, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFolder*>*>* *operation) = 0;
	virtual STDMETHODIMP _GetFoldersAsyncOverloadDefaultStartAndCount(CommonFolderQuery query, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFolder*>*>* *operation) = 0;
	virtual STDMETHODIMP _GetItemsAsync(unsigned startIndex, unsigned maxItemsToRetrieve, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IStorageItem*>*>* *operation) = 0;
	virtual STDMETHODIMP _AreQueryOptionsSupported(QueryOptions* queryOptions, bool *value) = 0;
	virtual STDMETHODIMP _IsCommonFolderQuerySupported(CommonFolderQuery query, bool *value) = 0;
	virtual STDMETHODIMP _IsCommonFileQuerySupported(CommonFileQuery query, bool *value) = 0;
};
template<typename X> struct IStorageFolderQueryOperations_adaptor : X {
	ptr<Foundation::IAsyncOperation<IndexedState>> GetIndexedStateAsync() { Foundation::IAsyncOperation<IndexedState>* operation; hrcheck(X::get()->_GetIndexedStateAsync(&operation)); return from_abi(operation); }
	ptr<StorageFileQueryResult> CreateFileQuery() { StorageFileQueryResult* value; hrcheck(X::get()->_CreateFileQueryOverloadDefault(&value)); return from_abi(value); }
	ptr<StorageFileQueryResult> CreateFileQuery(CommonFileQuery query) { StorageFileQueryResult* value; hrcheck(X::get()->_CreateFileQuery(query, &value)); return from_abi(value); }
	ptr<StorageFileQueryResult> CreateFileQueryWithOptions(pptr<QueryOptions> queryOptions) { StorageFileQueryResult* value; hrcheck(X::get()->_CreateFileQueryWithOptions(queryOptions, &value)); return from_abi(value); }
	ptr<StorageFolderQueryResult> CreateFolderQuery() { StorageFolderQueryResult* value; hrcheck(X::get()->_CreateFolderQueryOverloadDefault(&value)); return from_abi(value); }
	ptr<StorageFolderQueryResult> CreateFolderQuery(CommonFolderQuery query) { StorageFolderQueryResult* value; hrcheck(X::get()->_CreateFolderQuery(query, &value)); return from_abi(value); }
	ptr<StorageFolderQueryResult> CreateFolderQueryWithOptions(pptr<QueryOptions> queryOptions) { StorageFolderQueryResult* value; hrcheck(X::get()->_CreateFolderQueryWithOptions(queryOptions, &value)); return from_abi(value); }
	ptr<StorageItemQueryResult> CreateItemQuery() { StorageItemQueryResult* value; hrcheck(X::get()->_CreateItemQuery(&value)); return from_abi(value); }
	ptr<StorageItemQueryResult> CreateItemQueryWithOptions(pptr<QueryOptions> queryOptions) { StorageItemQueryResult* value; hrcheck(X::get()->_CreateItemQueryWithOptions(queryOptions, &value)); return from_abi(value); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<StorageFile>>>>> GetFilesAsync(CommonFileQuery query, unsigned startIndex, unsigned maxItemsToRetrieve) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFile*>*>* operation; hrcheck(X::get()->_GetFilesAsync(query, startIndex, maxItemsToRetrieve, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<StorageFile>>>>> GetFilesAsync(CommonFileQuery query) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFile*>*>* operation; hrcheck(X::get()->_GetFilesAsyncOverloadDefaultStartAndCount(query, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<StorageFolder>>>>> GetFoldersAsync(CommonFolderQuery query, unsigned startIndex, unsigned maxItemsToRetrieve) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFolder*>*>* operation; hrcheck(X::get()->_GetFoldersAsync(query, startIndex, maxItemsToRetrieve, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<StorageFolder>>>>> GetFoldersAsync(CommonFolderQuery query) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFolder*>*>* operation; hrcheck(X::get()->_GetFoldersAsyncOverloadDefaultStartAndCount(query, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<IStorageItem>>>>> GetItemsAsync(unsigned startIndex, unsigned maxItemsToRetrieve) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IStorageItem*>*>* operation; hrcheck(X::get()->_GetItemsAsync(startIndex, maxItemsToRetrieve, &operation)); return from_abi(operation); }
	bool AreQueryOptionsSupported(pptr<QueryOptions> queryOptions) { bool value; hrcheck(X::get()->_AreQueryOptionsSupported(queryOptions, &value)); return value; }
	bool IsCommonFolderQuerySupported(CommonFolderQuery query) { bool value; hrcheck(X::get()->_IsCommonFolderQuerySupported(query, &value)); return value; }
	bool IsCommonFileQuerySupported(CommonFileQuery query) { bool value; hrcheck(X::get()->_IsCommonFileQuerySupported(query, &value)); return value; }
};
template<typename X> struct adapt<IStorageFolderQueryOperations, X> : Windows::Storage::Search::IStorageFolderQueryOperations_adaptor<X> { typedef adapt IStorageFolderQueryOperations; };
template<typename X> struct IStorageFolderQueryOperations_unadaptor : X {
	STDMETHODIMP _GetIndexedStateAsync(Foundation::IAsyncOperation<IndexedState>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetIndexedStateAsync()); }); }
	STDMETHODIMP _CreateFileQueryOverloadDefault(StorageFileQueryResult* *value) { return hrtry([&, this] { *value = to_abi(X::get()->CreateFileQuery()); }); }
	STDMETHODIMP _CreateFileQuery(CommonFileQuery query, StorageFileQueryResult* *value) { return hrtry([&, this] { *value = to_abi(X::get()->CreateFileQuery(query)); }); }
	STDMETHODIMP _CreateFileQueryWithOptions(QueryOptions* queryOptions, StorageFileQueryResult* *value) { return hrtry([&, this] { *value = to_abi(X::get()->CreateFileQueryWithOptions(queryOptions)); }); }
	STDMETHODIMP _CreateFolderQueryOverloadDefault(StorageFolderQueryResult* *value) { return hrtry([&, this] { *value = to_abi(X::get()->CreateFolderQuery()); }); }
	STDMETHODIMP _CreateFolderQuery(CommonFolderQuery query, StorageFolderQueryResult* *value) { return hrtry([&, this] { *value = to_abi(X::get()->CreateFolderQuery(query)); }); }
	STDMETHODIMP _CreateFolderQueryWithOptions(QueryOptions* queryOptions, StorageFolderQueryResult* *value) { return hrtry([&, this] { *value = to_abi(X::get()->CreateFolderQueryWithOptions(queryOptions)); }); }
	STDMETHODIMP _CreateItemQuery(StorageItemQueryResult* *value) { return hrtry([&, this] { *value = to_abi(X::get()->CreateItemQuery()); }); }
	STDMETHODIMP _CreateItemQueryWithOptions(QueryOptions* queryOptions, StorageItemQueryResult* *value) { return hrtry([&, this] { *value = to_abi(X::get()->CreateItemQueryWithOptions(queryOptions)); }); }
	STDMETHODIMP _GetFilesAsync(CommonFileQuery query, unsigned startIndex, unsigned maxItemsToRetrieve, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFile*>*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetFilesAsync(query, startIndex, maxItemsToRetrieve)); }); }
	STDMETHODIMP _GetFilesAsyncOverloadDefaultStartAndCount(CommonFileQuery query, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFile*>*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetFilesAsync(query)); }); }
	STDMETHODIMP _GetFoldersAsync(CommonFolderQuery query, unsigned startIndex, unsigned maxItemsToRetrieve, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFolder*>*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetFoldersAsync(query, startIndex, maxItemsToRetrieve)); }); }
	STDMETHODIMP _GetFoldersAsyncOverloadDefaultStartAndCount(CommonFolderQuery query, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFolder*>*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetFoldersAsync(query)); }); }
	STDMETHODIMP _GetItemsAsync(unsigned startIndex, unsigned maxItemsToRetrieve, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IStorageItem*>*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetItemsAsync(startIndex, maxItemsToRetrieve)); }); }
	STDMETHODIMP _AreQueryOptionsSupported(QueryOptions* queryOptions, bool *value) { return hrtry([&, this] { *value = X::get()->AreQueryOptionsSupported(queryOptions); }); }
	STDMETHODIMP _IsCommonFolderQuerySupported(CommonFolderQuery query, bool *value) { return hrtry([&, this] { *value = X::get()->IsCommonFolderQuerySupported(query); }); }
	STDMETHODIMP _IsCommonFileQuerySupported(CommonFileQuery query, bool *value) { return hrtry([&, this] { *value = X::get()->IsCommonFileQuerySupported(query); }); }
};
template<typename X> struct unadapt<IStorageFolderQueryOperations, X> : Windows::Storage::Search::IStorageFolderQueryOperations_unadaptor<X> {};
struct IStorageFolderQueryOperations : IStorageFolderQueryOperations_raw, generate<IStorageFolderQueryOperations> {};

// StorageFileQueryResult
template<typename X> struct statics<StorageFileQueryResult, X> : X {
	typedef typename X::root_type StorageFileQueryResult;
};
struct StorageFileQueryResult : generate<StorageFileQueryResult> {
	using IStorageFileQueryResult::GetFilesAsync;
};

// StorageFolderQueryResult
template<typename X> struct statics<StorageFolderQueryResult, X> : X {
	typedef typename X::root_type StorageFolderQueryResult;
};
struct StorageFolderQueryResult : generate<StorageFolderQueryResult> {
	using IStorageFolderQueryResult::GetFoldersAsync;
};

// StorageItemQueryResult
template<typename X> struct statics<StorageItemQueryResult, X> : X {
	typedef typename X::root_type StorageItemQueryResult;
};
struct StorageItemQueryResult : generate<StorageItemQueryResult> {
	using IStorageItemQueryResult::GetItemsAsync;
};

// SortEntryVector
template<typename X> struct statics<SortEntryVector, X> : X {
	typedef typename X::root_type SortEntryVector;
};
struct SortEntryVector : generate<SortEntryVector> {};

// IStorageLibraryContentChangedTriggerDetails
struct IStorageLibraryContentChangedTriggerDetails_raw : IInspectable {
	virtual STDMETHODIMP _get_Folder(StorageFolder* *value);
	virtual STDMETHODIMP _CreateModifiedSinceQuery(Foundation::DateTime lastQueryTime, StorageItemQueryResult* *result);
};
template<typename X> struct IStorageLibraryContentChangedTriggerDetails_adaptor : X {
	union {
		struct : property {
			ptr<StorageFolder> get() { StorageFolder* value; hrcheck(enc(&IStorageLibraryContentChangedTriggerDetails_adaptor::Folder)->_get_Folder(&value)); return from_abi(value); }
			ptr<StorageFolder> operator()() { return get(); }
			operator ptr<StorageFolder> () { return get(); }
			ptr<StorageFolder> operator->() { return get(); }
		} Folder;
	};
	ptr<StorageItemQueryResult> CreateModifiedSinceQuery(const Foundation::DateTime& lastQueryTime) { StorageItemQueryResult* result; hrcheck(X::get()->_CreateModifiedSinceQuery(lastQueryTime, &result)); return from_abi(result); }
	IStorageLibraryContentChangedTriggerDetails_adaptor() {}
};
template<typename X> struct adapt<IStorageLibraryContentChangedTriggerDetails, X> : Windows::Storage::Search::IStorageLibraryContentChangedTriggerDetails_adaptor<X> { typedef adapt IStorageLibraryContentChangedTriggerDetails; };
struct IStorageLibraryContentChangedTriggerDetails : IStorageLibraryContentChangedTriggerDetails_raw, generate<IStorageLibraryContentChangedTriggerDetails> {};

// StorageLibraryContentChangedTriggerDetails
template<typename X> struct statics<StorageLibraryContentChangedTriggerDetails, X> : X {
	typedef typename X::root_type StorageLibraryContentChangedTriggerDetails;
};
struct StorageLibraryContentChangedTriggerDetails : generate<StorageLibraryContentChangedTriggerDetails> {};

// IStorageLibraryChangeTrackerTriggerDetails
struct IStorageLibraryChangeTrackerTriggerDetails_raw : IInspectable {
	virtual STDMETHODIMP _get_Folder(StorageFolder* *value);
	virtual STDMETHODIMP _get_ChangeTracker(StorageLibraryChangeTracker* *value);
};
template<typename X> struct IStorageLibraryChangeTrackerTriggerDetails_adaptor : X {
	union {
		struct : property {
			ptr<StorageLibraryChangeTracker> get() { StorageLibraryChangeTracker* value; hrcheck(enc(&IStorageLibraryChangeTrackerTriggerDetails_adaptor::ChangeTracker)->_get_ChangeTracker(&value)); return from_abi(value); }
			ptr<StorageLibraryChangeTracker> operator()() { return get(); }
			operator ptr<StorageLibraryChangeTracker> () { return get(); }
			ptr<StorageLibraryChangeTracker> operator->() { return get(); }
		} ChangeTracker;
		struct : property {
			ptr<StorageFolder> get() { StorageFolder* value; hrcheck(enc(&IStorageLibraryChangeTrackerTriggerDetails_adaptor::Folder)->_get_Folder(&value)); return from_abi(value); }
			ptr<StorageFolder> operator()() { return get(); }
			operator ptr<StorageFolder> () { return get(); }
			ptr<StorageFolder> operator->() { return get(); }
		} Folder;
	};
	IStorageLibraryChangeTrackerTriggerDetails_adaptor() {}
};
template<typename X> struct adapt<IStorageLibraryChangeTrackerTriggerDetails, X> : Windows::Storage::Search::IStorageLibraryChangeTrackerTriggerDetails_adaptor<X> { typedef adapt IStorageLibraryChangeTrackerTriggerDetails; };
struct IStorageLibraryChangeTrackerTriggerDetails : IStorageLibraryChangeTrackerTriggerDetails_raw, generate<IStorageLibraryChangeTrackerTriggerDetails> {};

// StorageLibraryChangeTrackerTriggerDetails
template<typename X> struct statics<StorageLibraryChangeTrackerTriggerDetails, X> : X {
	typedef typename X::root_type StorageLibraryChangeTrackerTriggerDetails;
};
struct StorageLibraryChangeTrackerTriggerDetails : generate<StorageLibraryChangeTrackerTriggerDetails> {};
}}}
} // namespace iso_winrt
