#pragma once
// generated by isopod tools
// namespaces:
// Windows.Web.AtomPub

#include "Windows.Web.AtomPub.0.h"
#include "Windows.Web.Syndication.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Data { namespace Xml { namespace Dom {
struct XmlDocument;
}}}
namespace Foundation { namespace Collections {
template<typename T> struct IVector;
template<typename T> struct IVectorView;
}
template<typename TProgress> struct IAsyncActionWithProgress;
template<typename TResult, typename TProgress> struct IAsyncOperationWithProgress;
struct Uri;
}
namespace Security { namespace Credentials {
struct PasswordCredential;
}}
namespace Storage { namespace Streams {
struct IInputStream;
}}}

// defs

template<> struct def<Windows::Web::AtomPub::IResourceCollection> : interface_type<Windows::Web::Syndication::ISyndicationNode> {};
template<> struct def<Windows::Web::AtomPub::ResourceCollection> : class_type<Platform::Object, Windows::Web::AtomPub::IResourceCollection> {};
template<> struct def<Windows::Web::AtomPub::IWorkspace> : interface_type<Windows::Web::Syndication::ISyndicationNode> {};
template<> struct def<Windows::Web::AtomPub::Workspace> : class_type<Platform::Object, Windows::Web::AtomPub::IWorkspace> {};
template<> struct def<Windows::Web::AtomPub::IServiceDocument> : interface_type<Windows::Web::Syndication::ISyndicationNode> {};
template<> struct def<Windows::Web::AtomPub::ServiceDocument> : class_type<Platform::Object, Windows::Web::AtomPub::IServiceDocument> {};
template<> struct def<Windows::Web::AtomPub::IAtomPubClient> : interface_type<Windows::Web::Syndication::ISyndicationClient> {};
template<> struct def<Windows::Web::AtomPub::IAtomPubClientFactory> : interface_type<> {};
template<> struct def<Windows::Web::AtomPub::AtomPubClient> : class_type<Platform::Object, Windows::Web::AtomPub::IAtomPubClient>, custom_activators {};

// uuids

template<> struct uuid<Windows::Web::AtomPub::IResourceCollection> { define_guid(0x7F5FD609, 0xBC88, 0x41D4, 0x88, 0xFA, 0x3D, 0xE6, 0x70, 0x4D, 0x42, 0x8E);};
template<> struct uuid<Windows::Web::AtomPub::IWorkspace> { define_guid(0xB41DA63B, 0xA4B8, 0x4036, 0x89, 0xC5, 0x83, 0xC3, 0x12, 0x66, 0xBA, 0x49);};
template<> struct uuid<Windows::Web::AtomPub::IServiceDocument> { define_guid(0x8B7EC771, 0x2AB3, 0x4DBE, 0x8B, 0xCC, 0x77, 0x8F, 0x92, 0xB7, 0x5E, 0x51);};
template<> struct uuid<Windows::Web::AtomPub::IAtomPubClient> { define_guid(0x35392C38, 0xCDED, 0x4D4C, 0x96, 0x37, 0x5, 0xF1, 0x5C, 0x1C, 0x94, 0x6);};
template<> struct uuid<Windows::Web::AtomPub::IAtomPubClientFactory> { define_guid(0x49D55012, 0x57CB, 0x4BDE, 0xAB, 0x9F, 0x26, 0x10, 0xB1, 0x72, 0x77, 0x7B);};

// types

namespace Windows { namespace Web { namespace AtomPub {

// IResourceCollection
struct IResourceCollection_raw : IInspectable {
	virtual STDMETHODIMP _get_Title(Syndication::ISyndicationText* *value);
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_Categories(Foundation::Collections::IVectorView<Syndication::SyndicationCategory*>* *value);
	virtual STDMETHODIMP _get_Accepts(Foundation::Collections::IVectorView<HSTRING>* *value);
};
template<typename X> struct IResourceCollection_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&IResourceCollection_adaptor::Accepts)->_get_Accepts(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} Accepts;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Syndication::SyndicationCategory>>> get() { Foundation::Collections::IVectorView<Syndication::SyndicationCategory*>* value; hrcheck(enc(&IResourceCollection_adaptor::Categories)->_get_Categories(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Syndication::SyndicationCategory>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Syndication::SyndicationCategory>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Syndication::SyndicationCategory>>> operator->() { return get(); }
		} Categories;
		struct : property {
			ptr<Syndication::ISyndicationText> get() { Syndication::ISyndicationText* value; hrcheck(enc(&IResourceCollection_adaptor::Title)->_get_Title(&value)); return from_abi(value); }
			ptr<Syndication::ISyndicationText> operator()() { return get(); }
			operator ptr<Syndication::ISyndicationText> () { return get(); }
			ptr<Syndication::ISyndicationText> operator->() { return get(); }
		} Title;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IResourceCollection_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
	};
	IResourceCollection_adaptor() {}
};
template<typename X> struct adapt<IResourceCollection, X> : Windows::Web::AtomPub::IResourceCollection_adaptor<X> { typedef adapt IResourceCollection; };
struct IResourceCollection : IResourceCollection_raw, generate<IResourceCollection> {};

// ResourceCollection
template<typename X> struct statics<ResourceCollection, X> : X {
	typedef typename X::root_type ResourceCollection;
};
struct ResourceCollection : generate<ResourceCollection> {};

// IWorkspace
struct IWorkspace_raw : IInspectable {
	virtual STDMETHODIMP _get_Title(Syndication::ISyndicationText* *value);
	virtual STDMETHODIMP _get_Collections(Foundation::Collections::IVectorView<ResourceCollection*>* *value);
};
template<typename X> struct IWorkspace_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<ResourceCollection>>> get() { Foundation::Collections::IVectorView<ResourceCollection*>* value; hrcheck(enc(&IWorkspace_adaptor::Collections)->_get_Collections(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<ResourceCollection>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<ResourceCollection>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<ResourceCollection>>> operator->() { return get(); }
		} Collections;
		struct : property {
			ptr<Syndication::ISyndicationText> get() { Syndication::ISyndicationText* value; hrcheck(enc(&IWorkspace_adaptor::Title)->_get_Title(&value)); return from_abi(value); }
			ptr<Syndication::ISyndicationText> operator()() { return get(); }
			operator ptr<Syndication::ISyndicationText> () { return get(); }
			ptr<Syndication::ISyndicationText> operator->() { return get(); }
		} Title;
	};
	IWorkspace_adaptor() {}
};
template<typename X> struct adapt<IWorkspace, X> : Windows::Web::AtomPub::IWorkspace_adaptor<X> { typedef adapt IWorkspace; };
struct IWorkspace : IWorkspace_raw, generate<IWorkspace> {};

// Workspace
template<typename X> struct statics<Workspace, X> : X {
	typedef typename X::root_type Workspace;
};
struct Workspace : generate<Workspace> {};

// IServiceDocument
struct IServiceDocument_raw : IInspectable {
	virtual STDMETHODIMP _get_Workspaces(Foundation::Collections::IVectorView<Workspace*>* *value);
};
template<typename X> struct IServiceDocument_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Workspace>>> get() { Foundation::Collections::IVectorView<Workspace*>* value; hrcheck(enc(&IServiceDocument_adaptor::Workspaces)->_get_Workspaces(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Workspace>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Workspace>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Workspace>>> operator->() { return get(); }
		} Workspaces;
	};
	IServiceDocument_adaptor() {}
};
template<typename X> struct adapt<IServiceDocument, X> : Windows::Web::AtomPub::IServiceDocument_adaptor<X> { typedef adapt IServiceDocument; };
struct IServiceDocument : IServiceDocument_raw, generate<IServiceDocument> {};

// ServiceDocument
template<typename X> struct statics<ServiceDocument, X> : X {
	typedef typename X::root_type ServiceDocument;
};
struct ServiceDocument : generate<ServiceDocument> {};

// IAtomPubClient
struct IAtomPubClient_raw : IInspectable {
	virtual STDMETHODIMP _RetrieveServiceDocumentAsync(Foundation::Uri* uri, Foundation::IAsyncOperationWithProgress<ServiceDocument*, Syndication::RetrievalProgress>* *operation);
	virtual STDMETHODIMP _RetrieveMediaResourceAsync(Foundation::Uri* uri, Foundation::IAsyncOperationWithProgress<Storage::Streams::IInputStream*, Syndication::RetrievalProgress>* *operation);
	virtual STDMETHODIMP _RetrieveResourceAsync(Foundation::Uri* uri, Foundation::IAsyncOperationWithProgress<Syndication::SyndicationItem*, Syndication::RetrievalProgress>* *operation);
	virtual STDMETHODIMP _CreateResourceAsync(Foundation::Uri* uri, HSTRING description, Syndication::SyndicationItem* item, Foundation::IAsyncOperationWithProgress<Syndication::SyndicationItem*, Syndication::TransferProgress>* *operation);
	virtual STDMETHODIMP _CreateMediaResourceAsync(Foundation::Uri* uri, HSTRING mediaType, HSTRING description, Storage::Streams::IInputStream* mediaStream, Foundation::IAsyncOperationWithProgress<Syndication::SyndicationItem*, Syndication::TransferProgress>* *operation);
	virtual STDMETHODIMP _UpdateMediaResourceAsync(Foundation::Uri* uri, HSTRING mediaType, Storage::Streams::IInputStream* mediaStream, Foundation::IAsyncActionWithProgress<Syndication::TransferProgress>* *operation);
	virtual STDMETHODIMP _UpdateResourceAsync(Foundation::Uri* uri, Syndication::SyndicationItem* item, Foundation::IAsyncActionWithProgress<Syndication::TransferProgress>* *operation);
	virtual STDMETHODIMP _UpdateResourceItemAsync(Syndication::SyndicationItem* item, Foundation::IAsyncActionWithProgress<Syndication::TransferProgress>* *operation);
	virtual STDMETHODIMP _DeleteResourceAsync(Foundation::Uri* uri, Foundation::IAsyncActionWithProgress<Syndication::TransferProgress>* *operation);
	virtual STDMETHODIMP _DeleteResourceItemAsync(Syndication::SyndicationItem* item, Foundation::IAsyncActionWithProgress<Syndication::TransferProgress>* *operation);
	virtual STDMETHODIMP _CancelAsyncOperations();
};
template<typename X> struct IAtomPubClient_adaptor : X {
	ptr<Foundation::IAsyncOperationWithProgress<ptr<ServiceDocument>, Syndication::RetrievalProgress>> RetrieveServiceDocumentAsync(pptr<Foundation::Uri> uri) { Foundation::IAsyncOperationWithProgress<ServiceDocument*, Syndication::RetrievalProgress>* operation; hrcheck(X::get()->_RetrieveServiceDocumentAsync(uri, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<Storage::Streams::IInputStream>, Syndication::RetrievalProgress>> RetrieveMediaResourceAsync(pptr<Foundation::Uri> uri) { Foundation::IAsyncOperationWithProgress<Storage::Streams::IInputStream*, Syndication::RetrievalProgress>* operation; hrcheck(X::get()->_RetrieveMediaResourceAsync(uri, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<Syndication::SyndicationItem>, Syndication::RetrievalProgress>> RetrieveResourceAsync(pptr<Foundation::Uri> uri) { Foundation::IAsyncOperationWithProgress<Syndication::SyndicationItem*, Syndication::RetrievalProgress>* operation; hrcheck(X::get()->_RetrieveResourceAsync(uri, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<Syndication::SyndicationItem>, Syndication::TransferProgress>> CreateResourceAsync(pptr<Foundation::Uri> uri, hstring_ref description, pptr<Syndication::SyndicationItem> item) { Foundation::IAsyncOperationWithProgress<Syndication::SyndicationItem*, Syndication::TransferProgress>* operation; hrcheck(X::get()->_CreateResourceAsync(uri, description, item, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<Syndication::SyndicationItem>, Syndication::TransferProgress>> CreateMediaResourceAsync(pptr<Foundation::Uri> uri, hstring_ref mediaType, hstring_ref description, pptr<Storage::Streams::IInputStream> mediaStream) { Foundation::IAsyncOperationWithProgress<Syndication::SyndicationItem*, Syndication::TransferProgress>* operation; hrcheck(X::get()->_CreateMediaResourceAsync(uri, mediaType, description, mediaStream, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncActionWithProgress<Syndication::TransferProgress>> UpdateMediaResourceAsync(pptr<Foundation::Uri> uri, hstring_ref mediaType, pptr<Storage::Streams::IInputStream> mediaStream) { Foundation::IAsyncActionWithProgress<Syndication::TransferProgress>* operation; hrcheck(X::get()->_UpdateMediaResourceAsync(uri, mediaType, mediaStream, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncActionWithProgress<Syndication::TransferProgress>> UpdateResourceAsync(pptr<Foundation::Uri> uri, pptr<Syndication::SyndicationItem> item) { Foundation::IAsyncActionWithProgress<Syndication::TransferProgress>* operation; hrcheck(X::get()->_UpdateResourceAsync(uri, item, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncActionWithProgress<Syndication::TransferProgress>> UpdateResourceItemAsync(pptr<Syndication::SyndicationItem> item) { Foundation::IAsyncActionWithProgress<Syndication::TransferProgress>* operation; hrcheck(X::get()->_UpdateResourceItemAsync(item, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncActionWithProgress<Syndication::TransferProgress>> DeleteResourceAsync(pptr<Foundation::Uri> uri) { Foundation::IAsyncActionWithProgress<Syndication::TransferProgress>* operation; hrcheck(X::get()->_DeleteResourceAsync(uri, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncActionWithProgress<Syndication::TransferProgress>> DeleteResourceItemAsync(pptr<Syndication::SyndicationItem> item) { Foundation::IAsyncActionWithProgress<Syndication::TransferProgress>* operation; hrcheck(X::get()->_DeleteResourceItemAsync(item, &operation)); return from_abi(operation); }
	void CancelAsyncOperations() { hrcheck(X::get()->_CancelAsyncOperations()); }
};
template<typename X> struct adapt<IAtomPubClient, X> : Windows::Web::AtomPub::IAtomPubClient_adaptor<X> { typedef adapt IAtomPubClient; };
struct IAtomPubClient : IAtomPubClient_raw, generate<IAtomPubClient> {};

// IAtomPubClientFactory
struct IAtomPubClientFactory : IInspectable {
	virtual STDMETHODIMP _CreateAtomPubClientWithCredentials(Security::Credentials::PasswordCredential* serverCredential, AtomPubClient* *atomPubClient);
};

// AtomPubClient
template<typename> struct AtomPubClient_statics {
	static AtomPubClient *activate(pptr<Security::Credentials::PasswordCredential> serverCredential) { AtomPubClient *atomPubClient; hrcheck(get_activation_factory<AtomPubClient, IAtomPubClientFactory>()->_CreateAtomPubClientWithCredentials(serverCredential, &atomPubClient)); return atomPubClient; }
	static AtomPubClient *activate() { AtomPubClient *t; get_activation_factory<AtomPubClient>()->ActivateInstance((IInspectable**)&t); return t; }
};

template<typename X> struct statics<AtomPubClient, X> : X, Windows::Web::AtomPub::AtomPubClient_statics<void> {
	using Windows::Web::AtomPub::AtomPubClient_statics<void>::activate;
	typedef typename X::root_type AtomPubClient;
};
struct AtomPubClient : generate<AtomPubClient> {};
}}}
} // namespace iso_winrt
