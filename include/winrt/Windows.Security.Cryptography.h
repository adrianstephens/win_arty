#pragma once
// generated by isopod tools
// namespaces:
// Windows.Security.Cryptography

#include "Windows.Security.Cryptography.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Storage { namespace Streams {
struct IBuffer;
}}}

// defs

template<> struct def<Windows::Security::Cryptography::BinaryStringEncoding> : enum_type<int> {};
template<> struct def<Windows::Security::Cryptography::ICryptographicBufferStatics> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::CryptographicBuffer> : class_type<Platform::Object, Platform::Object> {};

// uuids

template<> struct uuid<Windows::Security::Cryptography::ICryptographicBufferStatics> { define_guid(0x320B7E22, 0x3CB0, 0x4CDF, 0x86, 0x63, 0x1D, 0x28, 0x91, 0x0, 0x65, 0xEB);};

// types

namespace Windows { namespace Security { namespace Cryptography {

// ICryptographicBufferStatics
struct ICryptographicBufferStatics : IInspectable {
	virtual STDMETHODIMP _Compare(Storage::Streams::IBuffer* object1, Storage::Streams::IBuffer* object2, bool *isEqual);
	virtual STDMETHODIMP _GenerateRandom(unsigned length, Storage::Streams::IBuffer* *buffer);
	virtual STDMETHODIMP _GenerateRandomNumber(unsigned *value);
	virtual STDMETHODIMP _CreateFromByteArray(unsigned valueSize, unsigned char *value, Storage::Streams::IBuffer* *buffer);
	virtual STDMETHODIMP _CopyToByteArray(Storage::Streams::IBuffer* buffer, unsigned *valueSize, unsigned char **value);
	virtual STDMETHODIMP _DecodeFromHexString(HSTRING value, Storage::Streams::IBuffer* *buffer);
	virtual STDMETHODIMP _EncodeToHexString(Storage::Streams::IBuffer* buffer, HSTRING *value);
	virtual STDMETHODIMP _DecodeFromBase64String(HSTRING value, Storage::Streams::IBuffer* *buffer);
	virtual STDMETHODIMP _EncodeToBase64String(Storage::Streams::IBuffer* buffer, HSTRING *value);
	virtual STDMETHODIMP _ConvertStringToBinary(HSTRING value, BinaryStringEncoding encoding, Storage::Streams::IBuffer* *buffer);
	virtual STDMETHODIMP _ConvertBinaryToString(BinaryStringEncoding encoding, Storage::Streams::IBuffer* buffer, HSTRING *value);
};

// CryptographicBuffer
template<typename> struct CryptographicBuffer_statics {
	static bool Compare(pptr<Storage::Streams::IBuffer> object1, pptr<Storage::Streams::IBuffer> object2) { bool isEqual; hrcheck(get_activation_factory<CryptographicBuffer, ICryptographicBufferStatics>()->_Compare(object1, object2, &isEqual)); return isEqual; }
	static ptr<Storage::Streams::IBuffer> GenerateRandom(unsigned length) { Storage::Streams::IBuffer* buffer; hrcheck(get_activation_factory<CryptographicBuffer, ICryptographicBufferStatics>()->_GenerateRandom(length, &buffer)); return from_abi(buffer); }
	static unsigned GenerateRandomNumber() { unsigned value; hrcheck(get_activation_factory<CryptographicBuffer, ICryptographicBufferStatics>()->_GenerateRandomNumber(&value)); return value; }
	static ptr<Storage::Streams::IBuffer> CreateFromByteArray(const szarray<unsigned char>& value) { Storage::Streams::IBuffer* buffer; hrcheck(get_activation_factory<CryptographicBuffer, ICryptographicBufferStatics>()->_CreateFromByteArray(value.size, to_abi(value.p), &buffer)); return from_abi(buffer); }
	static szarray<unsigned char> CopyToByteArray(pptr<Storage::Streams::IBuffer> buffer) { szarray<unsigned char> value; hrcheck(get_activation_factory<CryptographicBuffer, ICryptographicBufferStatics>()->_CopyToByteArray(buffer, &value.size, &value.p)); return value; }
	static ptr<Storage::Streams::IBuffer> DecodeFromHexString(hstring_ref value) { Storage::Streams::IBuffer* buffer; hrcheck(get_activation_factory<CryptographicBuffer, ICryptographicBufferStatics>()->_DecodeFromHexString(value, &buffer)); return from_abi(buffer); }
	static hstring EncodeToHexString(pptr<Storage::Streams::IBuffer> buffer) { HSTRING value; hrcheck(get_activation_factory<CryptographicBuffer, ICryptographicBufferStatics>()->_EncodeToHexString(buffer, &value)); return from_abi(value); }
	static ptr<Storage::Streams::IBuffer> DecodeFromBase64String(hstring_ref value) { Storage::Streams::IBuffer* buffer; hrcheck(get_activation_factory<CryptographicBuffer, ICryptographicBufferStatics>()->_DecodeFromBase64String(value, &buffer)); return from_abi(buffer); }
	static hstring EncodeToBase64String(pptr<Storage::Streams::IBuffer> buffer) { HSTRING value; hrcheck(get_activation_factory<CryptographicBuffer, ICryptographicBufferStatics>()->_EncodeToBase64String(buffer, &value)); return from_abi(value); }
	static ptr<Storage::Streams::IBuffer> ConvertStringToBinary(hstring_ref value, BinaryStringEncoding encoding) { Storage::Streams::IBuffer* buffer; hrcheck(get_activation_factory<CryptographicBuffer, ICryptographicBufferStatics>()->_ConvertStringToBinary(value, encoding, &buffer)); return from_abi(buffer); }
	static hstring ConvertBinaryToString(BinaryStringEncoding encoding, pptr<Storage::Streams::IBuffer> buffer) { HSTRING value; hrcheck(get_activation_factory<CryptographicBuffer, ICryptographicBufferStatics>()->_ConvertBinaryToString(encoding, buffer, &value)); return from_abi(value); }
};

template<typename X> struct statics<CryptographicBuffer, X> : X, Windows::Security::Cryptography::CryptographicBuffer_statics<void> {
	typedef typename X::root_type CryptographicBuffer;
};
struct CryptographicBuffer : generate<CryptographicBuffer> {};
}}}
} // namespace iso_winrt
