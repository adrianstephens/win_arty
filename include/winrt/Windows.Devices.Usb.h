#pragma once
// generated by isopod tools
// namespaces:
// Windows.Devices.Usb

#include "Windows.Devices.Usb.0.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IVectorView;
}}
namespace Storage { namespace Streams {
struct IInputStream;
struct IOutputStream;
struct IBuffer;
}}}

// defs

template<> struct def<Windows::Devices::Usb::UsbTransferDirection> : enum_type<int> {};
template<> struct def<Windows::Devices::Usb::UsbEndpointType> : enum_type<int> {};
template<> struct def<Windows::Devices::Usb::UsbControlRecipient> : enum_type<int> {};
template<> struct def<Windows::Devices::Usb::UsbControlTransferType> : enum_type<int> {};
template<> struct def<Windows::Devices::Usb::IUsbControlRequestType> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbControlRequestType> : class_type<Platform::Object, Windows::Devices::Usb::IUsbControlRequestType> {};
template<> struct def<Windows::Devices::Usb::IUsbSetupPacketFactory> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::IUsbSetupPacket> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbSetupPacket> : class_type<Platform::Object, Windows::Devices::Usb::IUsbSetupPacket>, custom_activators {};
template<> struct def<Windows::Devices::Usb::IUsbDeviceClass> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbDeviceClass> : class_type<Platform::Object, Windows::Devices::Usb::IUsbDeviceClass> {};
template<> struct def<Windows::Devices::Usb::IUsbDeviceClassesStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::IUsbDeviceClasses> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbDeviceClasses> : class_type<Platform::Object, Windows::Devices::Usb::IUsbDeviceClasses> {};
template<> struct def<Windows::Devices::Usb::IUsbDeviceStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::IUsbDevice> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Devices::Usb::UsbDevice> : class_type<Platform::Object, Windows::Devices::Usb::IUsbDevice> {};
template<> struct def<Windows::Devices::Usb::IUsbInterface> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbInterface> : class_type<Platform::Object, Windows::Devices::Usb::IUsbInterface> {};
template<> struct def<Windows::Devices::Usb::IUsbDeviceDescriptor> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbDeviceDescriptor> : class_type<Platform::Object, Windows::Devices::Usb::IUsbDeviceDescriptor> {};
template<> struct def<Windows::Devices::Usb::IUsbConfiguration> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbConfiguration> : class_type<Platform::Object, Windows::Devices::Usb::IUsbConfiguration> {};
template<> struct def<Windows::Devices::Usb::IUsbConfigurationDescriptor> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::IUsbConfigurationDescriptorStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::IUsbDescriptor> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbDescriptor> : class_type<Platform::Object, Windows::Devices::Usb::IUsbDescriptor> {};
template<> struct def<Windows::Devices::Usb::UsbConfigurationDescriptor> : class_type<Platform::Object, Windows::Devices::Usb::IUsbConfigurationDescriptor> {};
template<> struct def<Windows::Devices::Usb::IUsbInterfaceDescriptor> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::IUsbInterfaceDescriptorStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbInterfaceDescriptor> : class_type<Platform::Object, Windows::Devices::Usb::IUsbInterfaceDescriptor> {};
template<> struct def<Windows::Devices::Usb::IUsbEndpointDescriptor> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::IUsbBulkInEndpointDescriptor> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbBulkInEndpointDescriptor> : class_type<Platform::Object, Windows::Devices::Usb::IUsbBulkInEndpointDescriptor> {};
template<> struct def<Windows::Devices::Usb::IUsbInterruptInEndpointDescriptor> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbInterruptInEndpointDescriptor> : class_type<Platform::Object, Windows::Devices::Usb::IUsbInterruptInEndpointDescriptor> {};
template<> struct def<Windows::Devices::Usb::IUsbBulkOutEndpointDescriptor> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbBulkOutEndpointDescriptor> : class_type<Platform::Object, Windows::Devices::Usb::IUsbBulkOutEndpointDescriptor> {};
template<> struct def<Windows::Devices::Usb::IUsbInterruptOutEndpointDescriptor> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor> : class_type<Platform::Object, Windows::Devices::Usb::IUsbInterruptOutEndpointDescriptor> {};
template<> struct def<Windows::Devices::Usb::IUsbEndpointDescriptorStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbEndpointDescriptor> : class_type<Platform::Object, Windows::Devices::Usb::IUsbEndpointDescriptor> {};
template<> struct def<Windows::Devices::Usb::IUsbInterruptInEventArgs> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbInterruptInEventArgs> : class_type<Platform::Object, Windows::Devices::Usb::IUsbInterruptInEventArgs> {};
template<> struct def<Windows::Devices::Usb::UsbReadOptions> : enum_type<unsigned> {};
template<> struct def<Windows::Devices::Usb::UsbWriteOptions> : enum_type<unsigned> {};
template<> struct def<Windows::Devices::Usb::IUsbBulkInPipe> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::IUsbInterruptInPipe> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbInterruptInPipe> : class_type<Platform::Object, Windows::Devices::Usb::IUsbInterruptInPipe> {};
template<> struct def<Windows::Devices::Usb::IUsbBulkOutPipe> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::IUsbInterruptOutPipe> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbBulkInPipe> : class_type<Platform::Object, Windows::Devices::Usb::IUsbBulkInPipe> {};
template<> struct def<Windows::Devices::Usb::UsbBulkOutPipe> : class_type<Platform::Object, Windows::Devices::Usb::IUsbBulkOutPipe> {};
template<> struct def<Windows::Devices::Usb::UsbInterruptOutPipe> : class_type<Platform::Object, Windows::Devices::Usb::IUsbInterruptOutPipe> {};
template<> struct def<Windows::Devices::Usb::IUsbInterfaceSetting> : interface_type<> {};
template<> struct def<Windows::Devices::Usb::UsbInterfaceSetting> : class_type<Platform::Object, Windows::Devices::Usb::IUsbInterfaceSetting> {};

// uuids

template<> struct uuid<Windows::Devices::Usb::IUsbControlRequestType> { define_guid(0x8E9465A6, 0xD73D, 0x46DE, 0x94, 0xBE, 0xAA, 0xE7, 0xF0, 0x7C, 0xF, 0x5C);};
template<> struct uuid<Windows::Devices::Usb::IUsbSetupPacketFactory> { define_guid(0xC9257D50, 0x1B2E, 0x4A41, 0xA2, 0xA7, 0x33, 0x8F, 0xC, 0xEF, 0x3C, 0x14);};
template<> struct uuid<Windows::Devices::Usb::IUsbSetupPacket> { define_guid(0x104BA132, 0xC78F, 0x4C51, 0xB6, 0x54, 0xE4, 0x9D, 0x2, 0xF2, 0xCB, 0x3);};
template<> struct uuid<Windows::Devices::Usb::IUsbDeviceClass> { define_guid(0x51942F9, 0x845E, 0x47EB, 0xB1, 0x2A, 0x38, 0xF2, 0xF6, 0x17, 0xAF, 0xE7);};
template<> struct uuid<Windows::Devices::Usb::IUsbDeviceClassesStatics> { define_guid(0xB20B0527, 0xC580, 0x4599, 0xA1, 0x65, 0x98, 0x1B, 0x4F, 0xD0, 0x32, 0x30);};
template<> struct uuid<Windows::Devices::Usb::IUsbDeviceClasses> { define_guid(0x686F955D, 0x9B92, 0x4B30, 0x97, 0x81, 0xC2, 0x2C, 0x55, 0xAC, 0x35, 0xCB);};
template<> struct uuid<Windows::Devices::Usb::IUsbDeviceStatics> { define_guid(0x66B85A2, 0x9B7, 0x4446, 0x85, 0x2, 0x6F, 0xE6, 0xDC, 0xAA, 0x73, 0x9);};
template<> struct uuid<Windows::Devices::Usb::IUsbDevice> { define_guid(0x5249B992, 0xC456, 0x44D5, 0xAD, 0x5E, 0x24, 0xF5, 0xA0, 0x89, 0xF6, 0x3B);};
template<> struct uuid<Windows::Devices::Usb::IUsbInterface> { define_guid(0xA0322B95, 0x7F47, 0x48AB, 0xA7, 0x27, 0x67, 0x8C, 0x25, 0xBE, 0x21, 0x12);};
template<> struct uuid<Windows::Devices::Usb::IUsbDeviceDescriptor> { define_guid(0x1F48D1F6, 0xBA97, 0x4322, 0xB9, 0x2C, 0xB5, 0xB1, 0x89, 0x21, 0x65, 0x88);};
template<> struct uuid<Windows::Devices::Usb::IUsbConfiguration> { define_guid(0x68177429, 0x36A9, 0x46D7, 0xB8, 0x73, 0xFC, 0x68, 0x92, 0x51, 0xEC, 0x30);};
template<> struct uuid<Windows::Devices::Usb::IUsbConfigurationDescriptor> { define_guid(0xF2176D92, 0xB442, 0x407A, 0x82, 0x7, 0x7D, 0x64, 0x6C, 0x3, 0x85, 0xF3);};
template<> struct uuid<Windows::Devices::Usb::IUsbConfigurationDescriptorStatics> { define_guid(0x424CED93, 0xE740, 0x40A1, 0x92, 0xBD, 0xDA, 0x12, 0xE, 0xA0, 0x49, 0x14);};
template<> struct uuid<Windows::Devices::Usb::IUsbDescriptor> { define_guid(0xA89F216, 0x5F9D, 0x4874, 0x89, 0x4, 0xDA, 0x9A, 0xD3, 0xF5, 0x52, 0x8F);};
template<> struct uuid<Windows::Devices::Usb::IUsbInterfaceDescriptor> { define_guid(0x199670C7, 0xB7EE, 0x4F90, 0x8C, 0xD5, 0x94, 0xA2, 0xE2, 0x57, 0x59, 0x8A);};
template<> struct uuid<Windows::Devices::Usb::IUsbInterfaceDescriptorStatics> { define_guid(0xE34A9FF5, 0x77D6, 0x48B6, 0xB0, 0xBE, 0x16, 0xC6, 0x42, 0x23, 0x16, 0xFE);};
template<> struct uuid<Windows::Devices::Usb::IUsbEndpointDescriptor> { define_guid(0x6B4862D9, 0x8DF7, 0x4B40, 0xAC, 0x83, 0x57, 0x8F, 0x13, 0x9F, 0x5, 0x75);};
template<> struct uuid<Windows::Devices::Usb::IUsbBulkInEndpointDescriptor> { define_guid(0x3C6E4846, 0x6CF, 0x42A9, 0x9D, 0xC2, 0x97, 0x1C, 0x1B, 0x14, 0xB6, 0xE3);};
template<> struct uuid<Windows::Devices::Usb::IUsbInterruptInEndpointDescriptor> { define_guid(0xC0528967, 0xC911, 0x4C3A, 0x86, 0xB2, 0x41, 0x9C, 0x2D, 0xA8, 0x90, 0x39);};
template<> struct uuid<Windows::Devices::Usb::IUsbBulkOutEndpointDescriptor> { define_guid(0x2820847A, 0xFFEE, 0x4F60, 0x9B, 0xE1, 0x95, 0x6C, 0xAC, 0x3E, 0xCB, 0x65);};
template<> struct uuid<Windows::Devices::Usb::IUsbInterruptOutEndpointDescriptor> { define_guid(0xCC9FED81, 0x10CA, 0x4533, 0x95, 0x2D, 0x9E, 0x27, 0x83, 0x41, 0xE8, 0xF);};
template<> struct uuid<Windows::Devices::Usb::IUsbEndpointDescriptorStatics> { define_guid(0xC890B201, 0x9A6A, 0x495E, 0xA8, 0x2C, 0x29, 0x5B, 0x9E, 0x70, 0x81, 0x6);};
template<> struct uuid<Windows::Devices::Usb::IUsbInterruptInEventArgs> { define_guid(0xB7B04092, 0x1418, 0x4936, 0x82, 0x9, 0x29, 0x9C, 0xF5, 0x60, 0x55, 0x83);};
template<> struct uuid<Windows::Devices::Usb::IUsbBulkInPipe> { define_guid(0xF01D2D3B, 0x4548, 0x4D50, 0xB3, 0x26, 0xD8, 0x2C, 0xDA, 0xBE, 0x12, 0x20);};
template<> struct uuid<Windows::Devices::Usb::IUsbInterruptInPipe> { define_guid(0xFA007116, 0x84D7, 0x48C7, 0x8A, 0x3F, 0x4C, 0xB, 0x23, 0x5F, 0x2E, 0xA6);};
template<> struct uuid<Windows::Devices::Usb::IUsbBulkOutPipe> { define_guid(0xA8E9EE6E, 0x115, 0x45AA, 0x8B, 0x21, 0x37, 0xB2, 0x25, 0xBC, 0xCE, 0xE7);};
template<> struct uuid<Windows::Devices::Usb::IUsbInterruptOutPipe> { define_guid(0xE984C8A9, 0xAAF9, 0x49D0, 0xB9, 0x6C, 0xF6, 0x61, 0xAB, 0x4A, 0x7F, 0x95);};
template<> struct uuid<Windows::Devices::Usb::IUsbInterfaceSetting> { define_guid(0x1827BBA7, 0x8DA7, 0x4AF7, 0x8F, 0x4C, 0x7F, 0x30, 0x32, 0xE7, 0x81, 0xF5);};

// types

namespace Windows { namespace Devices { namespace Usb {

// IUsbControlRequestType
struct IUsbControlRequestType_raw : IInspectable {
	virtual STDMETHODIMP _get_Direction(UsbTransferDirection *value);
	virtual STDMETHODIMP _put_Direction(UsbTransferDirection value);
	virtual STDMETHODIMP _get_ControlTransferType(UsbControlTransferType *value);
	virtual STDMETHODIMP _put_ControlTransferType(UsbControlTransferType value);
	virtual STDMETHODIMP _get_Recipient(UsbControlRecipient *value);
	virtual STDMETHODIMP _put_Recipient(UsbControlRecipient value);
	virtual STDMETHODIMP _get_AsByte(unsigned char *value);
	virtual STDMETHODIMP _put_AsByte(unsigned char value);
};
template<typename X> struct IUsbControlRequestType_adaptor : X {
	union {
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbControlRequestType_adaptor::AsByte)->_get_AsByte(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IUsbControlRequestType_adaptor::AsByte)->_put_AsByte(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} AsByte;
		struct : property {
			UsbControlTransferType get() { UsbControlTransferType value; hrcheck(enc(&IUsbControlRequestType_adaptor::ControlTransferType)->_get_ControlTransferType(&value)); return value; }
			UsbControlTransferType operator()() { return get(); }
			operator UsbControlTransferType () { return get(); }
			void put(UsbControlTransferType value) { hrcheck(enc(&IUsbControlRequestType_adaptor::ControlTransferType)->_put_ControlTransferType(value)); }
			void operator=(UsbControlTransferType value) { put(value); }
			void operator()(UsbControlTransferType value) { put(value); }
		} ControlTransferType;
		struct : property {
			UsbTransferDirection get() { UsbTransferDirection value; hrcheck(enc(&IUsbControlRequestType_adaptor::Direction)->_get_Direction(&value)); return value; }
			UsbTransferDirection operator()() { return get(); }
			operator UsbTransferDirection () { return get(); }
			void put(UsbTransferDirection value) { hrcheck(enc(&IUsbControlRequestType_adaptor::Direction)->_put_Direction(value)); }
			void operator=(UsbTransferDirection value) { put(value); }
			void operator()(UsbTransferDirection value) { put(value); }
		} Direction;
		struct : property {
			UsbControlRecipient get() { UsbControlRecipient value; hrcheck(enc(&IUsbControlRequestType_adaptor::Recipient)->_get_Recipient(&value)); return value; }
			UsbControlRecipient operator()() { return get(); }
			operator UsbControlRecipient () { return get(); }
			void put(UsbControlRecipient value) { hrcheck(enc(&IUsbControlRequestType_adaptor::Recipient)->_put_Recipient(value)); }
			void operator=(UsbControlRecipient value) { put(value); }
			void operator()(UsbControlRecipient value) { put(value); }
		} Recipient;
	};
	IUsbControlRequestType_adaptor() {}
};
template<typename X> struct adapt<IUsbControlRequestType, X> : Windows::Devices::Usb::IUsbControlRequestType_adaptor<X> { typedef adapt IUsbControlRequestType; };
struct IUsbControlRequestType : IUsbControlRequestType_raw, generate<IUsbControlRequestType> {};

// UsbControlRequestType
template<typename X> struct statics<UsbControlRequestType, X> : X {
	typedef typename X::root_type UsbControlRequestType;
};
struct UsbControlRequestType : generate<UsbControlRequestType> {};

// IUsbSetupPacketFactory
struct IUsbSetupPacketFactory : IInspectable {
	virtual STDMETHODIMP _CreateWithEightByteBuffer(Storage::Streams::IBuffer* eightByteBuffer, UsbSetupPacket* *value);
};

// IUsbSetupPacket
struct IUsbSetupPacket_raw : IInspectable {
	virtual STDMETHODIMP _get_RequestType(UsbControlRequestType* *value);
	virtual STDMETHODIMP _put_RequestType(UsbControlRequestType* value);
	virtual STDMETHODIMP _get_Request(unsigned char *value);
	virtual STDMETHODIMP _put_Request(unsigned char value);
	virtual STDMETHODIMP _get_Value(unsigned *value);
	virtual STDMETHODIMP _put_Value(unsigned value);
	virtual STDMETHODIMP _get_Index(unsigned *value);
	virtual STDMETHODIMP _put_Index(unsigned value);
	virtual STDMETHODIMP _get_Length(unsigned *value);
	virtual STDMETHODIMP _put_Length(unsigned value);
};
template<typename X> struct IUsbSetupPacket_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IUsbSetupPacket_adaptor::Index)->_get_Index(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IUsbSetupPacket_adaptor::Index)->_put_Index(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} Index;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IUsbSetupPacket_adaptor::Length)->_get_Length(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IUsbSetupPacket_adaptor::Length)->_put_Length(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} Length;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbSetupPacket_adaptor::Request)->_get_Request(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IUsbSetupPacket_adaptor::Request)->_put_Request(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} Request;
		struct : property {
			ptr<UsbControlRequestType> get() { UsbControlRequestType* value; hrcheck(enc(&IUsbSetupPacket_adaptor::RequestType)->_get_RequestType(&value)); return from_abi(value); }
			ptr<UsbControlRequestType> operator()() { return get(); }
			operator ptr<UsbControlRequestType> () { return get(); }
			ptr<UsbControlRequestType> operator->() { return get(); }
			void put(pptr<UsbControlRequestType> value) { hrcheck(enc(&IUsbSetupPacket_adaptor::RequestType)->_put_RequestType(value)); }
			void operator=(pptr<UsbControlRequestType> value) { put(value); }
			void operator()(pptr<UsbControlRequestType> value) { put(value); }
		} RequestType;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IUsbSetupPacket_adaptor::Value)->_get_Value(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IUsbSetupPacket_adaptor::Value)->_put_Value(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} Value;
	};
	IUsbSetupPacket_adaptor() {}
};
template<typename X> struct adapt<IUsbSetupPacket, X> : Windows::Devices::Usb::IUsbSetupPacket_adaptor<X> { typedef adapt IUsbSetupPacket; };
struct IUsbSetupPacket : IUsbSetupPacket_raw, generate<IUsbSetupPacket> {};

// UsbSetupPacket
template<typename> struct UsbSetupPacket_statics {
	static UsbSetupPacket *activate() { UsbSetupPacket *t; get_activation_factory<UsbSetupPacket>()->ActivateInstance((IInspectable**)&t); return t; }
	static UsbSetupPacket *activate(pptr<Storage::Streams::IBuffer> eightByteBuffer) { UsbSetupPacket *value; hrcheck(get_activation_factory<UsbSetupPacket, IUsbSetupPacketFactory>()->_CreateWithEightByteBuffer(eightByteBuffer, &value)); return value; }
};

template<typename X> struct statics<UsbSetupPacket, X> : X, Windows::Devices::Usb::UsbSetupPacket_statics<void> {
	using Windows::Devices::Usb::UsbSetupPacket_statics<void>::activate;
	typedef typename X::root_type UsbSetupPacket;
};
struct UsbSetupPacket : generate<UsbSetupPacket> {};

// IUsbDeviceClass
struct IUsbDeviceClass_raw : IInspectable {
	virtual STDMETHODIMP _get_ClassCode(unsigned char *value);
	virtual STDMETHODIMP _put_ClassCode(unsigned char value);
	virtual STDMETHODIMP _get_SubclassCode(Foundation::IReference<unsigned char>* *value);
	virtual STDMETHODIMP _put_SubclassCode(Foundation::IReference<unsigned char>* value);
	virtual STDMETHODIMP _get_ProtocolCode(Foundation::IReference<unsigned char>* *value);
	virtual STDMETHODIMP _put_ProtocolCode(Foundation::IReference<unsigned char>* value);
};
template<typename X> struct IUsbDeviceClass_adaptor : X {
	union {
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbDeviceClass_adaptor::ClassCode)->_get_ClassCode(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IUsbDeviceClass_adaptor::ClassCode)->_put_ClassCode(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} ClassCode;
		struct : property {
			ptr<Foundation::IReference<unsigned char>> get() { Foundation::IReference<unsigned char>* value; hrcheck(enc(&IUsbDeviceClass_adaptor::ProtocolCode)->_get_ProtocolCode(&value)); return from_abi(value); }
			ptr<Foundation::IReference<unsigned char>> operator()() { return get(); }
			operator ptr<Foundation::IReference<unsigned char>> () { return get(); }
			ptr<Foundation::IReference<unsigned char>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<unsigned char>> value) { hrcheck(enc(&IUsbDeviceClass_adaptor::ProtocolCode)->_put_ProtocolCode(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<unsigned char>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<unsigned char>> value) { put(to_abi(value)); }
		} ProtocolCode;
		struct : property {
			ptr<Foundation::IReference<unsigned char>> get() { Foundation::IReference<unsigned char>* value; hrcheck(enc(&IUsbDeviceClass_adaptor::SubclassCode)->_get_SubclassCode(&value)); return from_abi(value); }
			ptr<Foundation::IReference<unsigned char>> operator()() { return get(); }
			operator ptr<Foundation::IReference<unsigned char>> () { return get(); }
			ptr<Foundation::IReference<unsigned char>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<unsigned char>> value) { hrcheck(enc(&IUsbDeviceClass_adaptor::SubclassCode)->_put_SubclassCode(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<unsigned char>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<unsigned char>> value) { put(to_abi(value)); }
		} SubclassCode;
	};
	IUsbDeviceClass_adaptor() {}
};
template<typename X> struct adapt<IUsbDeviceClass, X> : Windows::Devices::Usb::IUsbDeviceClass_adaptor<X> { typedef adapt IUsbDeviceClass; };
struct IUsbDeviceClass : IUsbDeviceClass_raw, generate<IUsbDeviceClass> {};

// UsbDeviceClass
template<typename X> struct statics<UsbDeviceClass, X> : X {
	typedef typename X::root_type UsbDeviceClass;
};
struct UsbDeviceClass : generate<UsbDeviceClass> {};

// IUsbDeviceClassesStatics
struct IUsbDeviceClassesStatics : IInspectable {
	virtual STDMETHODIMP _get_CdcControl(UsbDeviceClass* *value);
	virtual STDMETHODIMP _get_Physical(UsbDeviceClass* *value);
	virtual STDMETHODIMP _get_PersonalHealthcare(UsbDeviceClass* *value);
	virtual STDMETHODIMP _get_ActiveSync(UsbDeviceClass* *value);
	virtual STDMETHODIMP _get_PalmSync(UsbDeviceClass* *value);
	virtual STDMETHODIMP _get_DeviceFirmwareUpdate(UsbDeviceClass* *value);
	virtual STDMETHODIMP _get_Irda(UsbDeviceClass* *value);
	virtual STDMETHODIMP _get_Measurement(UsbDeviceClass* *value);
	virtual STDMETHODIMP _get_VendorSpecific(UsbDeviceClass* *value);
};

// IUsbDeviceClasses
struct IUsbDeviceClasses : IInspectable, generate<IUsbDeviceClasses> {};

// UsbDeviceClasses
template<typename> struct UsbDeviceClasses_statics {
	static struct _ActiveSync : property {
		ptr<UsbDeviceClass> get() { UsbDeviceClass* value; hrcheck(get_activation_factory<UsbDeviceClasses, IUsbDeviceClassesStatics>()->_get_ActiveSync(&value)); return from_abi(value); }
		ptr<UsbDeviceClass> operator()() { return get(); }
		operator ptr<UsbDeviceClass> () { return get(); }
		ptr<UsbDeviceClass> operator->() { return get(); }
	} ActiveSync;
	static struct _CdcControl : property {
		ptr<UsbDeviceClass> get() { UsbDeviceClass* value; hrcheck(get_activation_factory<UsbDeviceClasses, IUsbDeviceClassesStatics>()->_get_CdcControl(&value)); return from_abi(value); }
		ptr<UsbDeviceClass> operator()() { return get(); }
		operator ptr<UsbDeviceClass> () { return get(); }
		ptr<UsbDeviceClass> operator->() { return get(); }
	} CdcControl;
	static struct _DeviceFirmwareUpdate : property {
		ptr<UsbDeviceClass> get() { UsbDeviceClass* value; hrcheck(get_activation_factory<UsbDeviceClasses, IUsbDeviceClassesStatics>()->_get_DeviceFirmwareUpdate(&value)); return from_abi(value); }
		ptr<UsbDeviceClass> operator()() { return get(); }
		operator ptr<UsbDeviceClass> () { return get(); }
		ptr<UsbDeviceClass> operator->() { return get(); }
	} DeviceFirmwareUpdate;
	static struct _Irda : property {
		ptr<UsbDeviceClass> get() { UsbDeviceClass* value; hrcheck(get_activation_factory<UsbDeviceClasses, IUsbDeviceClassesStatics>()->_get_Irda(&value)); return from_abi(value); }
		ptr<UsbDeviceClass> operator()() { return get(); }
		operator ptr<UsbDeviceClass> () { return get(); }
		ptr<UsbDeviceClass> operator->() { return get(); }
	} Irda;
	static struct _Measurement : property {
		ptr<UsbDeviceClass> get() { UsbDeviceClass* value; hrcheck(get_activation_factory<UsbDeviceClasses, IUsbDeviceClassesStatics>()->_get_Measurement(&value)); return from_abi(value); }
		ptr<UsbDeviceClass> operator()() { return get(); }
		operator ptr<UsbDeviceClass> () { return get(); }
		ptr<UsbDeviceClass> operator->() { return get(); }
	} Measurement;
	static struct _PalmSync : property {
		ptr<UsbDeviceClass> get() { UsbDeviceClass* value; hrcheck(get_activation_factory<UsbDeviceClasses, IUsbDeviceClassesStatics>()->_get_PalmSync(&value)); return from_abi(value); }
		ptr<UsbDeviceClass> operator()() { return get(); }
		operator ptr<UsbDeviceClass> () { return get(); }
		ptr<UsbDeviceClass> operator->() { return get(); }
	} PalmSync;
	static struct _PersonalHealthcare : property {
		ptr<UsbDeviceClass> get() { UsbDeviceClass* value; hrcheck(get_activation_factory<UsbDeviceClasses, IUsbDeviceClassesStatics>()->_get_PersonalHealthcare(&value)); return from_abi(value); }
		ptr<UsbDeviceClass> operator()() { return get(); }
		operator ptr<UsbDeviceClass> () { return get(); }
		ptr<UsbDeviceClass> operator->() { return get(); }
	} PersonalHealthcare;
	static struct _Physical : property {
		ptr<UsbDeviceClass> get() { UsbDeviceClass* value; hrcheck(get_activation_factory<UsbDeviceClasses, IUsbDeviceClassesStatics>()->_get_Physical(&value)); return from_abi(value); }
		ptr<UsbDeviceClass> operator()() { return get(); }
		operator ptr<UsbDeviceClass> () { return get(); }
		ptr<UsbDeviceClass> operator->() { return get(); }
	} Physical;
	static struct _VendorSpecific : property {
		ptr<UsbDeviceClass> get() { UsbDeviceClass* value; hrcheck(get_activation_factory<UsbDeviceClasses, IUsbDeviceClassesStatics>()->_get_VendorSpecific(&value)); return from_abi(value); }
		ptr<UsbDeviceClass> operator()() { return get(); }
		operator ptr<UsbDeviceClass> () { return get(); }
		ptr<UsbDeviceClass> operator->() { return get(); }
	} VendorSpecific;
};
template<typename X> typename UsbDeviceClasses_statics<X>::_ActiveSync UsbDeviceClasses_statics<X>::ActiveSync;
template<typename X> typename UsbDeviceClasses_statics<X>::_CdcControl UsbDeviceClasses_statics<X>::CdcControl;
template<typename X> typename UsbDeviceClasses_statics<X>::_DeviceFirmwareUpdate UsbDeviceClasses_statics<X>::DeviceFirmwareUpdate;
template<typename X> typename UsbDeviceClasses_statics<X>::_Irda UsbDeviceClasses_statics<X>::Irda;
template<typename X> typename UsbDeviceClasses_statics<X>::_Measurement UsbDeviceClasses_statics<X>::Measurement;
template<typename X> typename UsbDeviceClasses_statics<X>::_PalmSync UsbDeviceClasses_statics<X>::PalmSync;
template<typename X> typename UsbDeviceClasses_statics<X>::_PersonalHealthcare UsbDeviceClasses_statics<X>::PersonalHealthcare;
template<typename X> typename UsbDeviceClasses_statics<X>::_Physical UsbDeviceClasses_statics<X>::Physical;
template<typename X> typename UsbDeviceClasses_statics<X>::_VendorSpecific UsbDeviceClasses_statics<X>::VendorSpecific;

template<typename X> struct statics<UsbDeviceClasses, X> : X, Windows::Devices::Usb::UsbDeviceClasses_statics<void> {
	typedef typename X::root_type UsbDeviceClasses;
};
struct UsbDeviceClasses : generate<UsbDeviceClasses> {};

// IUsbDeviceStatics
struct IUsbDeviceStatics : IInspectable {
	virtual STDMETHODIMP _GetDeviceSelector(unsigned vendorId, unsigned productId, Platform::Guid winUsbInterfaceClass, HSTRING *value);
	virtual STDMETHODIMP _GetDeviceSelectorGuidOnly(Platform::Guid winUsbInterfaceClass, HSTRING *value);
	virtual STDMETHODIMP _GetDeviceSelectorVidPidOnly(unsigned vendorId, unsigned productId, HSTRING *value);
	virtual STDMETHODIMP _GetDeviceClassSelector(UsbDeviceClass* usbClass, HSTRING *value);
	virtual STDMETHODIMP _FromIdAsync(HSTRING deviceId, Foundation::IAsyncOperation<UsbDevice*>* *operation);
};

// IUsbDevice
struct IUsbDevice_raw : IInspectable {
	virtual STDMETHODIMP _SendControlOutTransferAsync(UsbSetupPacket* setupPacket, Storage::Streams::IBuffer* buffer, Foundation::IAsyncOperation<unsigned>* *operation);
	virtual STDMETHODIMP _SendControlOutTransferAsyncNoBuffer(UsbSetupPacket* setupPacket, Foundation::IAsyncOperation<unsigned>* *operation);
	virtual STDMETHODIMP _SendControlInTransferAsync(UsbSetupPacket* setupPacket, Storage::Streams::IBuffer* buffer, Foundation::IAsyncOperation<Storage::Streams::IBuffer*>* *operation);
	virtual STDMETHODIMP _SendControlInTransferAsyncNoBuffer(UsbSetupPacket* setupPacket, Foundation::IAsyncOperation<Storage::Streams::IBuffer*>* *operation);
	virtual STDMETHODIMP _get_DefaultInterface(UsbInterface* *value);
	virtual STDMETHODIMP _get_DeviceDescriptor(UsbDeviceDescriptor* *value);
	virtual STDMETHODIMP _get_Configuration(UsbConfiguration* *value);
};
template<typename X> struct IUsbDevice_adaptor : X {
	union {
		struct : property {
			ptr<UsbConfiguration> get() { UsbConfiguration* value; hrcheck(enc(&IUsbDevice_adaptor::Configuration)->_get_Configuration(&value)); return from_abi(value); }
			ptr<UsbConfiguration> operator()() { return get(); }
			operator ptr<UsbConfiguration> () { return get(); }
			ptr<UsbConfiguration> operator->() { return get(); }
		} Configuration;
		struct : property {
			ptr<UsbInterface> get() { UsbInterface* value; hrcheck(enc(&IUsbDevice_adaptor::DefaultInterface)->_get_DefaultInterface(&value)); return from_abi(value); }
			ptr<UsbInterface> operator()() { return get(); }
			operator ptr<UsbInterface> () { return get(); }
			ptr<UsbInterface> operator->() { return get(); }
		} DefaultInterface;
		struct : property {
			ptr<UsbDeviceDescriptor> get() { UsbDeviceDescriptor* value; hrcheck(enc(&IUsbDevice_adaptor::DeviceDescriptor)->_get_DeviceDescriptor(&value)); return from_abi(value); }
			ptr<UsbDeviceDescriptor> operator()() { return get(); }
			operator ptr<UsbDeviceDescriptor> () { return get(); }
			ptr<UsbDeviceDescriptor> operator->() { return get(); }
		} DeviceDescriptor;
	};
	ptr<Foundation::IAsyncOperation<unsigned>> SendControlOutTransferAsync(pptr<UsbSetupPacket> setupPacket, pptr<Storage::Streams::IBuffer> buffer) { Foundation::IAsyncOperation<unsigned>* operation; hrcheck(X::get()->_SendControlOutTransferAsync(setupPacket, buffer, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<unsigned>> SendControlOutTransferAsync(pptr<UsbSetupPacket> setupPacket) { Foundation::IAsyncOperation<unsigned>* operation; hrcheck(X::get()->_SendControlOutTransferAsyncNoBuffer(setupPacket, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Storage::Streams::IBuffer>>> SendControlInTransferAsync(pptr<UsbSetupPacket> setupPacket, pptr<Storage::Streams::IBuffer> buffer) { Foundation::IAsyncOperation<Storage::Streams::IBuffer*>* operation; hrcheck(X::get()->_SendControlInTransferAsync(setupPacket, buffer, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Storage::Streams::IBuffer>>> SendControlInTransferAsync(pptr<UsbSetupPacket> setupPacket) { Foundation::IAsyncOperation<Storage::Streams::IBuffer*>* operation; hrcheck(X::get()->_SendControlInTransferAsyncNoBuffer(setupPacket, &operation)); return from_abi(operation); }
	IUsbDevice_adaptor() {}
};
template<typename X> struct adapt<IUsbDevice, X> : Windows::Devices::Usb::IUsbDevice_adaptor<X> { typedef adapt IUsbDevice; };
struct IUsbDevice : IUsbDevice_raw, generate<IUsbDevice> {};

// UsbDevice
template<typename> struct UsbDevice_statics {
	static hstring GetDeviceSelector(unsigned vendorId, unsigned productId, const Platform::Guid& winUsbInterfaceClass) { HSTRING value; hrcheck(get_activation_factory<UsbDevice, IUsbDeviceStatics>()->_GetDeviceSelector(vendorId, productId, winUsbInterfaceClass, &value)); return from_abi(value); }
	static hstring GetDeviceSelector(const Platform::Guid& winUsbInterfaceClass) { HSTRING value; hrcheck(get_activation_factory<UsbDevice, IUsbDeviceStatics>()->_GetDeviceSelectorGuidOnly(winUsbInterfaceClass, &value)); return from_abi(value); }
	static hstring GetDeviceSelector(unsigned vendorId, unsigned productId) { HSTRING value; hrcheck(get_activation_factory<UsbDevice, IUsbDeviceStatics>()->_GetDeviceSelectorVidPidOnly(vendorId, productId, &value)); return from_abi(value); }
	static hstring GetDeviceClassSelector(pptr<UsbDeviceClass> usbClass) { HSTRING value; hrcheck(get_activation_factory<UsbDevice, IUsbDeviceStatics>()->_GetDeviceClassSelector(usbClass, &value)); return from_abi(value); }
	static ptr<Foundation::IAsyncOperation<ptr<UsbDevice>>> FromIdAsync(hstring_ref deviceId) { Foundation::IAsyncOperation<UsbDevice*>* operation; hrcheck(get_activation_factory<UsbDevice, IUsbDeviceStatics>()->_FromIdAsync(deviceId, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<UsbDevice, X> : X, Windows::Devices::Usb::UsbDevice_statics<void> {
	typedef typename X::root_type UsbDevice;
};
struct UsbDevice : generate<UsbDevice> {
	using IUsbDevice::SendControlInTransferAsync;
	using IUsbDevice::SendControlOutTransferAsync;
};

// IUsbInterface
struct IUsbInterface_raw : IInspectable {
	virtual STDMETHODIMP _get_BulkInPipes(Foundation::Collections::IVectorView<UsbBulkInPipe*>* *value);
	virtual STDMETHODIMP _get_InterruptInPipes(Foundation::Collections::IVectorView<UsbInterruptInPipe*>* *value);
	virtual STDMETHODIMP _get_BulkOutPipes(Foundation::Collections::IVectorView<UsbBulkOutPipe*>* *value);
	virtual STDMETHODIMP _get_InterruptOutPipes(Foundation::Collections::IVectorView<UsbInterruptOutPipe*>* *value);
	virtual STDMETHODIMP _get_InterfaceSettings(Foundation::Collections::IVectorView<UsbInterfaceSetting*>* *value);
	virtual STDMETHODIMP _get_InterfaceNumber(unsigned char *value);
	virtual STDMETHODIMP _get_Descriptors(Foundation::Collections::IVectorView<UsbDescriptor*>* *value);
};
template<typename X> struct IUsbInterface_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<UsbBulkInPipe>>> get() { Foundation::Collections::IVectorView<UsbBulkInPipe*>* value; hrcheck(enc(&IUsbInterface_adaptor::BulkInPipes)->_get_BulkInPipes(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbBulkInPipe>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<UsbBulkInPipe>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbBulkInPipe>>> operator->() { return get(); }
		} BulkInPipes;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<UsbBulkOutPipe>>> get() { Foundation::Collections::IVectorView<UsbBulkOutPipe*>* value; hrcheck(enc(&IUsbInterface_adaptor::BulkOutPipes)->_get_BulkOutPipes(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbBulkOutPipe>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<UsbBulkOutPipe>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbBulkOutPipe>>> operator->() { return get(); }
		} BulkOutPipes;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<UsbDescriptor>>> get() { Foundation::Collections::IVectorView<UsbDescriptor*>* value; hrcheck(enc(&IUsbInterface_adaptor::Descriptors)->_get_Descriptors(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbDescriptor>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<UsbDescriptor>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbDescriptor>>> operator->() { return get(); }
		} Descriptors;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbInterface_adaptor::InterfaceNumber)->_get_InterfaceNumber(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} InterfaceNumber;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterfaceSetting>>> get() { Foundation::Collections::IVectorView<UsbInterfaceSetting*>* value; hrcheck(enc(&IUsbInterface_adaptor::InterfaceSettings)->_get_InterfaceSettings(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterfaceSetting>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<UsbInterfaceSetting>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterfaceSetting>>> operator->() { return get(); }
		} InterfaceSettings;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptInPipe>>> get() { Foundation::Collections::IVectorView<UsbInterruptInPipe*>* value; hrcheck(enc(&IUsbInterface_adaptor::InterruptInPipes)->_get_InterruptInPipes(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptInPipe>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptInPipe>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptInPipe>>> operator->() { return get(); }
		} InterruptInPipes;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptOutPipe>>> get() { Foundation::Collections::IVectorView<UsbInterruptOutPipe*>* value; hrcheck(enc(&IUsbInterface_adaptor::InterruptOutPipes)->_get_InterruptOutPipes(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptOutPipe>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptOutPipe>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptOutPipe>>> operator->() { return get(); }
		} InterruptOutPipes;
	};
	IUsbInterface_adaptor() {}
};
template<typename X> struct adapt<IUsbInterface, X> : Windows::Devices::Usb::IUsbInterface_adaptor<X> { typedef adapt IUsbInterface; };
struct IUsbInterface : IUsbInterface_raw, generate<IUsbInterface> {};

// UsbInterface
template<typename X> struct statics<UsbInterface, X> : X {
	typedef typename X::root_type UsbInterface;
};
struct UsbInterface : generate<UsbInterface> {};

// IUsbDeviceDescriptor
struct IUsbDeviceDescriptor_raw : IInspectable {
	virtual STDMETHODIMP _get_BcdUsb(unsigned *value);
	virtual STDMETHODIMP _get_MaxPacketSize0(unsigned char *value);
	virtual STDMETHODIMP _get_VendorId(unsigned *value);
	virtual STDMETHODIMP _get_ProductId(unsigned *value);
	virtual STDMETHODIMP _get_BcdDeviceRevision(unsigned *value);
	virtual STDMETHODIMP _get_NumberOfConfigurations(unsigned char *value);
};
template<typename X> struct IUsbDeviceDescriptor_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IUsbDeviceDescriptor_adaptor::BcdDeviceRevision)->_get_BcdDeviceRevision(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} BcdDeviceRevision;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IUsbDeviceDescriptor_adaptor::BcdUsb)->_get_BcdUsb(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} BcdUsb;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbDeviceDescriptor_adaptor::MaxPacketSize0)->_get_MaxPacketSize0(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} MaxPacketSize0;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbDeviceDescriptor_adaptor::NumberOfConfigurations)->_get_NumberOfConfigurations(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} NumberOfConfigurations;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IUsbDeviceDescriptor_adaptor::ProductId)->_get_ProductId(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} ProductId;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IUsbDeviceDescriptor_adaptor::VendorId)->_get_VendorId(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} VendorId;
	};
	IUsbDeviceDescriptor_adaptor() {}
};
template<typename X> struct adapt<IUsbDeviceDescriptor, X> : Windows::Devices::Usb::IUsbDeviceDescriptor_adaptor<X> { typedef adapt IUsbDeviceDescriptor; };
struct IUsbDeviceDescriptor : IUsbDeviceDescriptor_raw, generate<IUsbDeviceDescriptor> {};

// UsbDeviceDescriptor
template<typename X> struct statics<UsbDeviceDescriptor, X> : X {
	typedef typename X::root_type UsbDeviceDescriptor;
};
struct UsbDeviceDescriptor : generate<UsbDeviceDescriptor> {};

// IUsbConfiguration
struct IUsbConfiguration_raw : IInspectable {
	virtual STDMETHODIMP _get_UsbInterfaces(Foundation::Collections::IVectorView<UsbInterface*>* *value);
	virtual STDMETHODIMP _get_ConfigurationDescriptor(UsbConfigurationDescriptor* *value);
	virtual STDMETHODIMP _get_Descriptors(Foundation::Collections::IVectorView<UsbDescriptor*>* *value);
};
template<typename X> struct IUsbConfiguration_adaptor : X {
	union {
		struct : property {
			ptr<UsbConfigurationDescriptor> get() { UsbConfigurationDescriptor* value; hrcheck(enc(&IUsbConfiguration_adaptor::ConfigurationDescriptor)->_get_ConfigurationDescriptor(&value)); return from_abi(value); }
			ptr<UsbConfigurationDescriptor> operator()() { return get(); }
			operator ptr<UsbConfigurationDescriptor> () { return get(); }
			ptr<UsbConfigurationDescriptor> operator->() { return get(); }
		} ConfigurationDescriptor;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<UsbDescriptor>>> get() { Foundation::Collections::IVectorView<UsbDescriptor*>* value; hrcheck(enc(&IUsbConfiguration_adaptor::Descriptors)->_get_Descriptors(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbDescriptor>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<UsbDescriptor>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbDescriptor>>> operator->() { return get(); }
		} Descriptors;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterface>>> get() { Foundation::Collections::IVectorView<UsbInterface*>* value; hrcheck(enc(&IUsbConfiguration_adaptor::UsbInterfaces)->_get_UsbInterfaces(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterface>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<UsbInterface>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterface>>> operator->() { return get(); }
		} UsbInterfaces;
	};
	IUsbConfiguration_adaptor() {}
};
template<typename X> struct adapt<IUsbConfiguration, X> : Windows::Devices::Usb::IUsbConfiguration_adaptor<X> { typedef adapt IUsbConfiguration; };
struct IUsbConfiguration : IUsbConfiguration_raw, generate<IUsbConfiguration> {};

// UsbConfiguration
template<typename X> struct statics<UsbConfiguration, X> : X {
	typedef typename X::root_type UsbConfiguration;
};
struct UsbConfiguration : generate<UsbConfiguration> {};

// IUsbConfigurationDescriptor
struct IUsbConfigurationDescriptor_raw : IInspectable {
	virtual STDMETHODIMP _get_ConfigurationValue(unsigned char *value);
	virtual STDMETHODIMP _get_MaxPowerMilliamps(unsigned *value);
	virtual STDMETHODIMP _get_SelfPowered(bool *value);
	virtual STDMETHODIMP _get_RemoteWakeup(bool *value);
};
template<typename X> struct IUsbConfigurationDescriptor_adaptor : X {
	union {
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbConfigurationDescriptor_adaptor::ConfigurationValue)->_get_ConfigurationValue(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} ConfigurationValue;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IUsbConfigurationDescriptor_adaptor::MaxPowerMilliamps)->_get_MaxPowerMilliamps(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} MaxPowerMilliamps;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUsbConfigurationDescriptor_adaptor::RemoteWakeup)->_get_RemoteWakeup(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} RemoteWakeup;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUsbConfigurationDescriptor_adaptor::SelfPowered)->_get_SelfPowered(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} SelfPowered;
	};
	IUsbConfigurationDescriptor_adaptor() {}
};
template<typename X> struct adapt<IUsbConfigurationDescriptor, X> : Windows::Devices::Usb::IUsbConfigurationDescriptor_adaptor<X> { typedef adapt IUsbConfigurationDescriptor; };
struct IUsbConfigurationDescriptor : IUsbConfigurationDescriptor_raw, generate<IUsbConfigurationDescriptor> {};

// IUsbConfigurationDescriptorStatics
struct IUsbConfigurationDescriptorStatics : IInspectable {
	virtual STDMETHODIMP _TryParse(UsbDescriptor* descriptor, UsbConfigurationDescriptor* *parsed, bool *success);
	virtual STDMETHODIMP _Parse(UsbDescriptor* descriptor, UsbConfigurationDescriptor* *parsed);
};

// IUsbDescriptor
struct IUsbDescriptor_raw : IInspectable {
	virtual STDMETHODIMP _get_Length(unsigned char *value);
	virtual STDMETHODIMP _get_DescriptorType(unsigned char *value);
	virtual STDMETHODIMP _ReadDescriptorBuffer(Storage::Streams::IBuffer* buffer);
};
template<typename X> struct IUsbDescriptor_adaptor : X {
	union {
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbDescriptor_adaptor::DescriptorType)->_get_DescriptorType(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} DescriptorType;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbDescriptor_adaptor::Length)->_get_Length(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} Length;
	};
	void ReadDescriptorBuffer(pptr<Storage::Streams::IBuffer> buffer) { hrcheck(X::get()->_ReadDescriptorBuffer(buffer)); }
	IUsbDescriptor_adaptor() {}
};
template<typename X> struct adapt<IUsbDescriptor, X> : Windows::Devices::Usb::IUsbDescriptor_adaptor<X> { typedef adapt IUsbDescriptor; };
struct IUsbDescriptor : IUsbDescriptor_raw, generate<IUsbDescriptor> {};

// UsbDescriptor
template<typename X> struct statics<UsbDescriptor, X> : X {
	typedef typename X::root_type UsbDescriptor;
};
struct UsbDescriptor : generate<UsbDescriptor> {};

// UsbConfigurationDescriptor
template<typename> struct UsbConfigurationDescriptor_statics {
	static bool TryParse(pptr<UsbDescriptor> descriptor, pptr<UsbConfigurationDescriptor> *parsed) { bool success; hrcheck(get_activation_factory<UsbConfigurationDescriptor, IUsbConfigurationDescriptorStatics>()->_TryParse(descriptor, parsed, &success)); return success; }
	static ptr<UsbConfigurationDescriptor> Parse(pptr<UsbDescriptor> descriptor) { UsbConfigurationDescriptor* parsed; hrcheck(get_activation_factory<UsbConfigurationDescriptor, IUsbConfigurationDescriptorStatics>()->_Parse(descriptor, &parsed)); return from_abi(parsed); }
};

template<typename X> struct statics<UsbConfigurationDescriptor, X> : X, Windows::Devices::Usb::UsbConfigurationDescriptor_statics<void> {
	typedef typename X::root_type UsbConfigurationDescriptor;
};
struct UsbConfigurationDescriptor : generate<UsbConfigurationDescriptor> {};

// IUsbInterfaceDescriptor
struct IUsbInterfaceDescriptor_raw : IInspectable {
	virtual STDMETHODIMP _get_ClassCode(unsigned char *value);
	virtual STDMETHODIMP _get_SubclassCode(unsigned char *value);
	virtual STDMETHODIMP _get_ProtocolCode(unsigned char *value);
	virtual STDMETHODIMP _get_AlternateSettingNumber(unsigned char *value);
	virtual STDMETHODIMP _get_InterfaceNumber(unsigned char *value);
};
template<typename X> struct IUsbInterfaceDescriptor_adaptor : X {
	union {
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbInterfaceDescriptor_adaptor::AlternateSettingNumber)->_get_AlternateSettingNumber(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} AlternateSettingNumber;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbInterfaceDescriptor_adaptor::ClassCode)->_get_ClassCode(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} ClassCode;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbInterfaceDescriptor_adaptor::InterfaceNumber)->_get_InterfaceNumber(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} InterfaceNumber;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbInterfaceDescriptor_adaptor::ProtocolCode)->_get_ProtocolCode(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} ProtocolCode;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbInterfaceDescriptor_adaptor::SubclassCode)->_get_SubclassCode(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} SubclassCode;
	};
	IUsbInterfaceDescriptor_adaptor() {}
};
template<typename X> struct adapt<IUsbInterfaceDescriptor, X> : Windows::Devices::Usb::IUsbInterfaceDescriptor_adaptor<X> { typedef adapt IUsbInterfaceDescriptor; };
struct IUsbInterfaceDescriptor : IUsbInterfaceDescriptor_raw, generate<IUsbInterfaceDescriptor> {};

// IUsbInterfaceDescriptorStatics
struct IUsbInterfaceDescriptorStatics : IInspectable {
	virtual STDMETHODIMP _TryParse(UsbDescriptor* descriptor, UsbInterfaceDescriptor* *parsed, bool *success);
	virtual STDMETHODIMP _Parse(UsbDescriptor* descriptor, UsbInterfaceDescriptor* *parsed);
};

// UsbInterfaceDescriptor
template<typename> struct UsbInterfaceDescriptor_statics {
	static bool TryParse(pptr<UsbDescriptor> descriptor, pptr<UsbInterfaceDescriptor> *parsed) { bool success; hrcheck(get_activation_factory<UsbInterfaceDescriptor, IUsbInterfaceDescriptorStatics>()->_TryParse(descriptor, parsed, &success)); return success; }
	static ptr<UsbInterfaceDescriptor> Parse(pptr<UsbDescriptor> descriptor) { UsbInterfaceDescriptor* parsed; hrcheck(get_activation_factory<UsbInterfaceDescriptor, IUsbInterfaceDescriptorStatics>()->_Parse(descriptor, &parsed)); return from_abi(parsed); }
};

template<typename X> struct statics<UsbInterfaceDescriptor, X> : X, Windows::Devices::Usb::UsbInterfaceDescriptor_statics<void> {
	typedef typename X::root_type UsbInterfaceDescriptor;
};
struct UsbInterfaceDescriptor : generate<UsbInterfaceDescriptor> {};

// IUsbEndpointDescriptor
struct IUsbEndpointDescriptor_raw : IInspectable {
	virtual STDMETHODIMP _get_EndpointNumber(unsigned char *value);
	virtual STDMETHODIMP _get_Direction(UsbTransferDirection *value);
	virtual STDMETHODIMP _get_EndpointType(UsbEndpointType *value);
	virtual STDMETHODIMP _get_AsBulkInEndpointDescriptor(UsbBulkInEndpointDescriptor* *value);
	virtual STDMETHODIMP _get_AsInterruptInEndpointDescriptor(UsbInterruptInEndpointDescriptor* *value);
	virtual STDMETHODIMP _get_AsBulkOutEndpointDescriptor(UsbBulkOutEndpointDescriptor* *value);
	virtual STDMETHODIMP _get_AsInterruptOutEndpointDescriptor(UsbInterruptOutEndpointDescriptor* *value);
};
template<typename X> struct IUsbEndpointDescriptor_adaptor : X {
	union {
		struct : property {
			ptr<UsbBulkInEndpointDescriptor> get() { UsbBulkInEndpointDescriptor* value; hrcheck(enc(&IUsbEndpointDescriptor_adaptor::AsBulkInEndpointDescriptor)->_get_AsBulkInEndpointDescriptor(&value)); return from_abi(value); }
			ptr<UsbBulkInEndpointDescriptor> operator()() { return get(); }
			operator ptr<UsbBulkInEndpointDescriptor> () { return get(); }
			ptr<UsbBulkInEndpointDescriptor> operator->() { return get(); }
		} AsBulkInEndpointDescriptor;
		struct : property {
			ptr<UsbBulkOutEndpointDescriptor> get() { UsbBulkOutEndpointDescriptor* value; hrcheck(enc(&IUsbEndpointDescriptor_adaptor::AsBulkOutEndpointDescriptor)->_get_AsBulkOutEndpointDescriptor(&value)); return from_abi(value); }
			ptr<UsbBulkOutEndpointDescriptor> operator()() { return get(); }
			operator ptr<UsbBulkOutEndpointDescriptor> () { return get(); }
			ptr<UsbBulkOutEndpointDescriptor> operator->() { return get(); }
		} AsBulkOutEndpointDescriptor;
		struct : property {
			ptr<UsbInterruptInEndpointDescriptor> get() { UsbInterruptInEndpointDescriptor* value; hrcheck(enc(&IUsbEndpointDescriptor_adaptor::AsInterruptInEndpointDescriptor)->_get_AsInterruptInEndpointDescriptor(&value)); return from_abi(value); }
			ptr<UsbInterruptInEndpointDescriptor> operator()() { return get(); }
			operator ptr<UsbInterruptInEndpointDescriptor> () { return get(); }
			ptr<UsbInterruptInEndpointDescriptor> operator->() { return get(); }
		} AsInterruptInEndpointDescriptor;
		struct : property {
			ptr<UsbInterruptOutEndpointDescriptor> get() { UsbInterruptOutEndpointDescriptor* value; hrcheck(enc(&IUsbEndpointDescriptor_adaptor::AsInterruptOutEndpointDescriptor)->_get_AsInterruptOutEndpointDescriptor(&value)); return from_abi(value); }
			ptr<UsbInterruptOutEndpointDescriptor> operator()() { return get(); }
			operator ptr<UsbInterruptOutEndpointDescriptor> () { return get(); }
			ptr<UsbInterruptOutEndpointDescriptor> operator->() { return get(); }
		} AsInterruptOutEndpointDescriptor;
		struct : property {
			UsbTransferDirection get() { UsbTransferDirection value; hrcheck(enc(&IUsbEndpointDescriptor_adaptor::Direction)->_get_Direction(&value)); return value; }
			UsbTransferDirection operator()() { return get(); }
			operator UsbTransferDirection () { return get(); }
		} Direction;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbEndpointDescriptor_adaptor::EndpointNumber)->_get_EndpointNumber(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} EndpointNumber;
		struct : property {
			UsbEndpointType get() { UsbEndpointType value; hrcheck(enc(&IUsbEndpointDescriptor_adaptor::EndpointType)->_get_EndpointType(&value)); return value; }
			UsbEndpointType operator()() { return get(); }
			operator UsbEndpointType () { return get(); }
		} EndpointType;
	};
	IUsbEndpointDescriptor_adaptor() {}
};
template<typename X> struct adapt<IUsbEndpointDescriptor, X> : Windows::Devices::Usb::IUsbEndpointDescriptor_adaptor<X> { typedef adapt IUsbEndpointDescriptor; };
struct IUsbEndpointDescriptor : IUsbEndpointDescriptor_raw, generate<IUsbEndpointDescriptor> {};

// IUsbBulkInEndpointDescriptor
struct IUsbBulkInEndpointDescriptor_raw : IInspectable {
	virtual STDMETHODIMP _get_MaxPacketSize(unsigned *value);
	virtual STDMETHODIMP _get_EndpointNumber(unsigned char *value);
	virtual STDMETHODIMP _get_Pipe(UsbBulkInPipe* *value);
};
template<typename X> struct IUsbBulkInEndpointDescriptor_adaptor : X {
	union {
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbBulkInEndpointDescriptor_adaptor::EndpointNumber)->_get_EndpointNumber(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} EndpointNumber;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IUsbBulkInEndpointDescriptor_adaptor::MaxPacketSize)->_get_MaxPacketSize(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} MaxPacketSize;
		struct : property {
			ptr<UsbBulkInPipe> get() { UsbBulkInPipe* value; hrcheck(enc(&IUsbBulkInEndpointDescriptor_adaptor::Pipe)->_get_Pipe(&value)); return from_abi(value); }
			ptr<UsbBulkInPipe> operator()() { return get(); }
			operator ptr<UsbBulkInPipe> () { return get(); }
			ptr<UsbBulkInPipe> operator->() { return get(); }
		} Pipe;
	};
	IUsbBulkInEndpointDescriptor_adaptor() {}
};
template<typename X> struct adapt<IUsbBulkInEndpointDescriptor, X> : Windows::Devices::Usb::IUsbBulkInEndpointDescriptor_adaptor<X> { typedef adapt IUsbBulkInEndpointDescriptor; };
struct IUsbBulkInEndpointDescriptor : IUsbBulkInEndpointDescriptor_raw, generate<IUsbBulkInEndpointDescriptor> {};

// UsbBulkInEndpointDescriptor
template<typename X> struct statics<UsbBulkInEndpointDescriptor, X> : X {
	typedef typename X::root_type UsbBulkInEndpointDescriptor;
};
struct UsbBulkInEndpointDescriptor : generate<UsbBulkInEndpointDescriptor> {};

// IUsbInterruptInEndpointDescriptor
struct IUsbInterruptInEndpointDescriptor_raw : IInspectable {
	virtual STDMETHODIMP _get_MaxPacketSize(unsigned *value);
	virtual STDMETHODIMP _get_EndpointNumber(unsigned char *value);
	virtual STDMETHODIMP _get_Interval(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_Pipe(UsbInterruptInPipe* *value);
};
template<typename X> struct IUsbInterruptInEndpointDescriptor_adaptor : X {
	union {
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbInterruptInEndpointDescriptor_adaptor::EndpointNumber)->_get_EndpointNumber(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} EndpointNumber;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IUsbInterruptInEndpointDescriptor_adaptor::Interval)->_get_Interval(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} Interval;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IUsbInterruptInEndpointDescriptor_adaptor::MaxPacketSize)->_get_MaxPacketSize(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} MaxPacketSize;
		struct : property {
			ptr<UsbInterruptInPipe> get() { UsbInterruptInPipe* value; hrcheck(enc(&IUsbInterruptInEndpointDescriptor_adaptor::Pipe)->_get_Pipe(&value)); return from_abi(value); }
			ptr<UsbInterruptInPipe> operator()() { return get(); }
			operator ptr<UsbInterruptInPipe> () { return get(); }
			ptr<UsbInterruptInPipe> operator->() { return get(); }
		} Pipe;
	};
	IUsbInterruptInEndpointDescriptor_adaptor() {}
};
template<typename X> struct adapt<IUsbInterruptInEndpointDescriptor, X> : Windows::Devices::Usb::IUsbInterruptInEndpointDescriptor_adaptor<X> { typedef adapt IUsbInterruptInEndpointDescriptor; };
struct IUsbInterruptInEndpointDescriptor : IUsbInterruptInEndpointDescriptor_raw, generate<IUsbInterruptInEndpointDescriptor> {};

// UsbInterruptInEndpointDescriptor
template<typename X> struct statics<UsbInterruptInEndpointDescriptor, X> : X {
	typedef typename X::root_type UsbInterruptInEndpointDescriptor;
};
struct UsbInterruptInEndpointDescriptor : generate<UsbInterruptInEndpointDescriptor> {};

// IUsbBulkOutEndpointDescriptor
struct IUsbBulkOutEndpointDescriptor_raw : IInspectable {
	virtual STDMETHODIMP _get_MaxPacketSize(unsigned *value);
	virtual STDMETHODIMP _get_EndpointNumber(unsigned char *value);
	virtual STDMETHODIMP _get_Pipe(UsbBulkOutPipe* *value);
};
template<typename X> struct IUsbBulkOutEndpointDescriptor_adaptor : X {
	union {
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbBulkOutEndpointDescriptor_adaptor::EndpointNumber)->_get_EndpointNumber(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} EndpointNumber;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IUsbBulkOutEndpointDescriptor_adaptor::MaxPacketSize)->_get_MaxPacketSize(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} MaxPacketSize;
		struct : property {
			ptr<UsbBulkOutPipe> get() { UsbBulkOutPipe* value; hrcheck(enc(&IUsbBulkOutEndpointDescriptor_adaptor::Pipe)->_get_Pipe(&value)); return from_abi(value); }
			ptr<UsbBulkOutPipe> operator()() { return get(); }
			operator ptr<UsbBulkOutPipe> () { return get(); }
			ptr<UsbBulkOutPipe> operator->() { return get(); }
		} Pipe;
	};
	IUsbBulkOutEndpointDescriptor_adaptor() {}
};
template<typename X> struct adapt<IUsbBulkOutEndpointDescriptor, X> : Windows::Devices::Usb::IUsbBulkOutEndpointDescriptor_adaptor<X> { typedef adapt IUsbBulkOutEndpointDescriptor; };
struct IUsbBulkOutEndpointDescriptor : IUsbBulkOutEndpointDescriptor_raw, generate<IUsbBulkOutEndpointDescriptor> {};

// UsbBulkOutEndpointDescriptor
template<typename X> struct statics<UsbBulkOutEndpointDescriptor, X> : X {
	typedef typename X::root_type UsbBulkOutEndpointDescriptor;
};
struct UsbBulkOutEndpointDescriptor : generate<UsbBulkOutEndpointDescriptor> {};

// IUsbInterruptOutEndpointDescriptor
struct IUsbInterruptOutEndpointDescriptor_raw : IInspectable {
	virtual STDMETHODIMP _get_MaxPacketSize(unsigned *value);
	virtual STDMETHODIMP _get_EndpointNumber(unsigned char *value);
	virtual STDMETHODIMP _get_Interval(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_Pipe(UsbInterruptOutPipe* *value);
};
template<typename X> struct IUsbInterruptOutEndpointDescriptor_adaptor : X {
	union {
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IUsbInterruptOutEndpointDescriptor_adaptor::EndpointNumber)->_get_EndpointNumber(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
		} EndpointNumber;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IUsbInterruptOutEndpointDescriptor_adaptor::Interval)->_get_Interval(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} Interval;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IUsbInterruptOutEndpointDescriptor_adaptor::MaxPacketSize)->_get_MaxPacketSize(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} MaxPacketSize;
		struct : property {
			ptr<UsbInterruptOutPipe> get() { UsbInterruptOutPipe* value; hrcheck(enc(&IUsbInterruptOutEndpointDescriptor_adaptor::Pipe)->_get_Pipe(&value)); return from_abi(value); }
			ptr<UsbInterruptOutPipe> operator()() { return get(); }
			operator ptr<UsbInterruptOutPipe> () { return get(); }
			ptr<UsbInterruptOutPipe> operator->() { return get(); }
		} Pipe;
	};
	IUsbInterruptOutEndpointDescriptor_adaptor() {}
};
template<typename X> struct adapt<IUsbInterruptOutEndpointDescriptor, X> : Windows::Devices::Usb::IUsbInterruptOutEndpointDescriptor_adaptor<X> { typedef adapt IUsbInterruptOutEndpointDescriptor; };
struct IUsbInterruptOutEndpointDescriptor : IUsbInterruptOutEndpointDescriptor_raw, generate<IUsbInterruptOutEndpointDescriptor> {};

// UsbInterruptOutEndpointDescriptor
template<typename X> struct statics<UsbInterruptOutEndpointDescriptor, X> : X {
	typedef typename X::root_type UsbInterruptOutEndpointDescriptor;
};
struct UsbInterruptOutEndpointDescriptor : generate<UsbInterruptOutEndpointDescriptor> {};

// IUsbEndpointDescriptorStatics
struct IUsbEndpointDescriptorStatics : IInspectable {
	virtual STDMETHODIMP _TryParse(UsbDescriptor* descriptor, UsbEndpointDescriptor* *parsed, bool *success);
	virtual STDMETHODIMP _Parse(UsbDescriptor* descriptor, UsbEndpointDescriptor* *parsed);
};

// UsbEndpointDescriptor
template<typename> struct UsbEndpointDescriptor_statics {
	static bool TryParse(pptr<UsbDescriptor> descriptor, pptr<UsbEndpointDescriptor> *parsed) { bool success; hrcheck(get_activation_factory<UsbEndpointDescriptor, IUsbEndpointDescriptorStatics>()->_TryParse(descriptor, parsed, &success)); return success; }
	static ptr<UsbEndpointDescriptor> Parse(pptr<UsbDescriptor> descriptor) { UsbEndpointDescriptor* parsed; hrcheck(get_activation_factory<UsbEndpointDescriptor, IUsbEndpointDescriptorStatics>()->_Parse(descriptor, &parsed)); return from_abi(parsed); }
};

template<typename X> struct statics<UsbEndpointDescriptor, X> : X, Windows::Devices::Usb::UsbEndpointDescriptor_statics<void> {
	typedef typename X::root_type UsbEndpointDescriptor;
};
struct UsbEndpointDescriptor : generate<UsbEndpointDescriptor> {};

// IUsbInterruptInEventArgs
struct IUsbInterruptInEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_InterruptData(Storage::Streams::IBuffer* *value);
};
template<typename X> struct IUsbInterruptInEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Storage::Streams::IBuffer> get() { Storage::Streams::IBuffer* value; hrcheck(enc(&IUsbInterruptInEventArgs_adaptor::InterruptData)->_get_InterruptData(&value)); return from_abi(value); }
			ptr<Storage::Streams::IBuffer> operator()() { return get(); }
			operator ptr<Storage::Streams::IBuffer> () { return get(); }
			ptr<Storage::Streams::IBuffer> operator->() { return get(); }
		} InterruptData;
	};
	IUsbInterruptInEventArgs_adaptor() {}
};
template<typename X> struct adapt<IUsbInterruptInEventArgs, X> : Windows::Devices::Usb::IUsbInterruptInEventArgs_adaptor<X> { typedef adapt IUsbInterruptInEventArgs; };
struct IUsbInterruptInEventArgs : IUsbInterruptInEventArgs_raw, generate<IUsbInterruptInEventArgs> {};

// UsbInterruptInEventArgs
template<typename X> struct statics<UsbInterruptInEventArgs, X> : X {
	typedef typename X::root_type UsbInterruptInEventArgs;
};
struct UsbInterruptInEventArgs : generate<UsbInterruptInEventArgs> {};

// IUsbBulkInPipe
struct IUsbBulkInPipe_raw : IInspectable {
	virtual STDMETHODIMP _get_MaxTransferSizeBytes(unsigned *value);
	virtual STDMETHODIMP _get_EndpointDescriptor(UsbBulkInEndpointDescriptor* *value);
	virtual STDMETHODIMP _ClearStallAsync(Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _put_ReadOptions(UsbReadOptions value);
	virtual STDMETHODIMP _get_ReadOptions(UsbReadOptions *value);
	virtual STDMETHODIMP _FlushBuffer();
	virtual STDMETHODIMP _get_InputStream(Storage::Streams::IInputStream* *value);
};
template<typename X> struct IUsbBulkInPipe_adaptor : X {
	union {
		struct : property {
			ptr<UsbBulkInEndpointDescriptor> get() { UsbBulkInEndpointDescriptor* value; hrcheck(enc(&IUsbBulkInPipe_adaptor::EndpointDescriptor)->_get_EndpointDescriptor(&value)); return from_abi(value); }
			ptr<UsbBulkInEndpointDescriptor> operator()() { return get(); }
			operator ptr<UsbBulkInEndpointDescriptor> () { return get(); }
			ptr<UsbBulkInEndpointDescriptor> operator->() { return get(); }
		} EndpointDescriptor;
		struct : property {
			ptr<Storage::Streams::IInputStream> get() { Storage::Streams::IInputStream* value; hrcheck(enc(&IUsbBulkInPipe_adaptor::InputStream)->_get_InputStream(&value)); return from_abi(value); }
			ptr<Storage::Streams::IInputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IInputStream> () { return get(); }
			ptr<Storage::Streams::IInputStream> operator->() { return get(); }
		} InputStream;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IUsbBulkInPipe_adaptor::MaxTransferSizeBytes)->_get_MaxTransferSizeBytes(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} MaxTransferSizeBytes;
		struct : property {
			UsbReadOptions get() { UsbReadOptions value; hrcheck(enc(&IUsbBulkInPipe_adaptor::ReadOptions)->_get_ReadOptions(&value)); return value; }
			UsbReadOptions operator()() { return get(); }
			operator UsbReadOptions () { return get(); }
			void put(UsbReadOptions value) { hrcheck(enc(&IUsbBulkInPipe_adaptor::ReadOptions)->_put_ReadOptions(value)); }
			void operator=(UsbReadOptions value) { put(value); }
			void operator()(UsbReadOptions value) { put(value); }
		} ReadOptions;
	};
	ptr<Foundation::IAsyncAction> ClearStallAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_ClearStallAsync(&operation)); return from_abi(operation); }
	void FlushBuffer() { hrcheck(X::get()->_FlushBuffer()); }
	IUsbBulkInPipe_adaptor() {}
};
template<typename X> struct adapt<IUsbBulkInPipe, X> : Windows::Devices::Usb::IUsbBulkInPipe_adaptor<X> { typedef adapt IUsbBulkInPipe; };
struct IUsbBulkInPipe : IUsbBulkInPipe_raw, generate<IUsbBulkInPipe> {};

// IUsbInterruptInPipe
struct IUsbInterruptInPipe_raw : IInspectable {
	virtual STDMETHODIMP _get_EndpointDescriptor(UsbInterruptInEndpointDescriptor* *value);
	virtual STDMETHODIMP _ClearStallAsync(Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _add_DataReceived(Foundation::TypedEventHandler<UsbInterruptInPipe*, UsbInterruptInEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DataReceived(Foundation::EventRegistrationToken token);
};
template<typename X> struct IUsbInterruptInPipe_adaptor : X {
	union {
		struct : property {
			ptr<UsbInterruptInEndpointDescriptor> get() { UsbInterruptInEndpointDescriptor* value; hrcheck(enc(&IUsbInterruptInPipe_adaptor::EndpointDescriptor)->_get_EndpointDescriptor(&value)); return from_abi(value); }
			ptr<UsbInterruptInEndpointDescriptor> operator()() { return get(); }
			operator ptr<UsbInterruptInEndpointDescriptor> () { return get(); }
			ptr<UsbInterruptInEndpointDescriptor> operator->() { return get(); }
		} EndpointDescriptor;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UsbInterruptInPipe>, ptr<UsbInterruptInEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUsbInterruptInPipe_adaptor::DataReceived)->_add_DataReceived(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUsbInterruptInPipe_adaptor::DataReceived)->_remove_DataReceived(token)); }
		} DataReceived;
	};
	ptr<Foundation::IAsyncAction> ClearStallAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_ClearStallAsync(&operation)); return from_abi(operation); }
	IUsbInterruptInPipe_adaptor() {}
};
template<typename X> struct adapt<IUsbInterruptInPipe, X> : Windows::Devices::Usb::IUsbInterruptInPipe_adaptor<X> { typedef adapt IUsbInterruptInPipe; };
struct IUsbInterruptInPipe : IUsbInterruptInPipe_raw, generate<IUsbInterruptInPipe> {};

// UsbInterruptInPipe
template<typename X> struct statics<UsbInterruptInPipe, X> : X {
	typedef typename X::root_type UsbInterruptInPipe;
};
struct UsbInterruptInPipe : generate<UsbInterruptInPipe> {};

// IUsbBulkOutPipe
struct IUsbBulkOutPipe_raw : IInspectable {
	virtual STDMETHODIMP _get_EndpointDescriptor(UsbBulkOutEndpointDescriptor* *value);
	virtual STDMETHODIMP _ClearStallAsync(Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _put_WriteOptions(UsbWriteOptions value);
	virtual STDMETHODIMP _get_WriteOptions(UsbWriteOptions *value);
	virtual STDMETHODIMP _get_OutputStream(Storage::Streams::IOutputStream* *value);
};
template<typename X> struct IUsbBulkOutPipe_adaptor : X {
	union {
		struct : property {
			ptr<UsbBulkOutEndpointDescriptor> get() { UsbBulkOutEndpointDescriptor* value; hrcheck(enc(&IUsbBulkOutPipe_adaptor::EndpointDescriptor)->_get_EndpointDescriptor(&value)); return from_abi(value); }
			ptr<UsbBulkOutEndpointDescriptor> operator()() { return get(); }
			operator ptr<UsbBulkOutEndpointDescriptor> () { return get(); }
			ptr<UsbBulkOutEndpointDescriptor> operator->() { return get(); }
		} EndpointDescriptor;
		struct : property {
			ptr<Storage::Streams::IOutputStream> get() { Storage::Streams::IOutputStream* value; hrcheck(enc(&IUsbBulkOutPipe_adaptor::OutputStream)->_get_OutputStream(&value)); return from_abi(value); }
			ptr<Storage::Streams::IOutputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IOutputStream> () { return get(); }
			ptr<Storage::Streams::IOutputStream> operator->() { return get(); }
		} OutputStream;
		struct : property {
			UsbWriteOptions get() { UsbWriteOptions value; hrcheck(enc(&IUsbBulkOutPipe_adaptor::WriteOptions)->_get_WriteOptions(&value)); return value; }
			UsbWriteOptions operator()() { return get(); }
			operator UsbWriteOptions () { return get(); }
			void put(UsbWriteOptions value) { hrcheck(enc(&IUsbBulkOutPipe_adaptor::WriteOptions)->_put_WriteOptions(value)); }
			void operator=(UsbWriteOptions value) { put(value); }
			void operator()(UsbWriteOptions value) { put(value); }
		} WriteOptions;
	};
	ptr<Foundation::IAsyncAction> ClearStallAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_ClearStallAsync(&operation)); return from_abi(operation); }
	IUsbBulkOutPipe_adaptor() {}
};
template<typename X> struct adapt<IUsbBulkOutPipe, X> : Windows::Devices::Usb::IUsbBulkOutPipe_adaptor<X> { typedef adapt IUsbBulkOutPipe; };
struct IUsbBulkOutPipe : IUsbBulkOutPipe_raw, generate<IUsbBulkOutPipe> {};

// IUsbInterruptOutPipe
struct IUsbInterruptOutPipe_raw : IInspectable {
	virtual STDMETHODIMP _get_EndpointDescriptor(UsbInterruptOutEndpointDescriptor* *value);
	virtual STDMETHODIMP _ClearStallAsync(Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _put_WriteOptions(UsbWriteOptions value);
	virtual STDMETHODIMP _get_WriteOptions(UsbWriteOptions *value);
	virtual STDMETHODIMP _get_OutputStream(Storage::Streams::IOutputStream* *value);
};
template<typename X> struct IUsbInterruptOutPipe_adaptor : X {
	union {
		struct : property {
			ptr<UsbInterruptOutEndpointDescriptor> get() { UsbInterruptOutEndpointDescriptor* value; hrcheck(enc(&IUsbInterruptOutPipe_adaptor::EndpointDescriptor)->_get_EndpointDescriptor(&value)); return from_abi(value); }
			ptr<UsbInterruptOutEndpointDescriptor> operator()() { return get(); }
			operator ptr<UsbInterruptOutEndpointDescriptor> () { return get(); }
			ptr<UsbInterruptOutEndpointDescriptor> operator->() { return get(); }
		} EndpointDescriptor;
		struct : property {
			ptr<Storage::Streams::IOutputStream> get() { Storage::Streams::IOutputStream* value; hrcheck(enc(&IUsbInterruptOutPipe_adaptor::OutputStream)->_get_OutputStream(&value)); return from_abi(value); }
			ptr<Storage::Streams::IOutputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IOutputStream> () { return get(); }
			ptr<Storage::Streams::IOutputStream> operator->() { return get(); }
		} OutputStream;
		struct : property {
			UsbWriteOptions get() { UsbWriteOptions value; hrcheck(enc(&IUsbInterruptOutPipe_adaptor::WriteOptions)->_get_WriteOptions(&value)); return value; }
			UsbWriteOptions operator()() { return get(); }
			operator UsbWriteOptions () { return get(); }
			void put(UsbWriteOptions value) { hrcheck(enc(&IUsbInterruptOutPipe_adaptor::WriteOptions)->_put_WriteOptions(value)); }
			void operator=(UsbWriteOptions value) { put(value); }
			void operator()(UsbWriteOptions value) { put(value); }
		} WriteOptions;
	};
	ptr<Foundation::IAsyncAction> ClearStallAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_ClearStallAsync(&operation)); return from_abi(operation); }
	IUsbInterruptOutPipe_adaptor() {}
};
template<typename X> struct adapt<IUsbInterruptOutPipe, X> : Windows::Devices::Usb::IUsbInterruptOutPipe_adaptor<X> { typedef adapt IUsbInterruptOutPipe; };
struct IUsbInterruptOutPipe : IUsbInterruptOutPipe_raw, generate<IUsbInterruptOutPipe> {};

// UsbBulkInPipe
template<typename X> struct statics<UsbBulkInPipe, X> : X {
	typedef typename X::root_type UsbBulkInPipe;
};
struct UsbBulkInPipe : generate<UsbBulkInPipe> {};

// UsbBulkOutPipe
template<typename X> struct statics<UsbBulkOutPipe, X> : X {
	typedef typename X::root_type UsbBulkOutPipe;
};
struct UsbBulkOutPipe : generate<UsbBulkOutPipe> {};

// UsbInterruptOutPipe
template<typename X> struct statics<UsbInterruptOutPipe, X> : X {
	typedef typename X::root_type UsbInterruptOutPipe;
};
struct UsbInterruptOutPipe : generate<UsbInterruptOutPipe> {};

// IUsbInterfaceSetting
struct IUsbInterfaceSetting_raw : IInspectable {
	virtual STDMETHODIMP _get_BulkInEndpoints(Foundation::Collections::IVectorView<UsbBulkInEndpointDescriptor*>* *value);
	virtual STDMETHODIMP _get_InterruptInEndpoints(Foundation::Collections::IVectorView<UsbInterruptInEndpointDescriptor*>* *value);
	virtual STDMETHODIMP _get_BulkOutEndpoints(Foundation::Collections::IVectorView<UsbBulkOutEndpointDescriptor*>* *value);
	virtual STDMETHODIMP _get_InterruptOutEndpoints(Foundation::Collections::IVectorView<UsbInterruptOutEndpointDescriptor*>* *value);
	virtual STDMETHODIMP _get_Selected(bool *value);
	virtual STDMETHODIMP _SelectSettingAsync(Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _get_InterfaceDescriptor(UsbInterfaceDescriptor* *value);
	virtual STDMETHODIMP _get_Descriptors(Foundation::Collections::IVectorView<UsbDescriptor*>* *value);
};
template<typename X> struct IUsbInterfaceSetting_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<UsbBulkInEndpointDescriptor>>> get() { Foundation::Collections::IVectorView<UsbBulkInEndpointDescriptor*>* value; hrcheck(enc(&IUsbInterfaceSetting_adaptor::BulkInEndpoints)->_get_BulkInEndpoints(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbBulkInEndpointDescriptor>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<UsbBulkInEndpointDescriptor>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbBulkInEndpointDescriptor>>> operator->() { return get(); }
		} BulkInEndpoints;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<UsbBulkOutEndpointDescriptor>>> get() { Foundation::Collections::IVectorView<UsbBulkOutEndpointDescriptor*>* value; hrcheck(enc(&IUsbInterfaceSetting_adaptor::BulkOutEndpoints)->_get_BulkOutEndpoints(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbBulkOutEndpointDescriptor>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<UsbBulkOutEndpointDescriptor>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbBulkOutEndpointDescriptor>>> operator->() { return get(); }
		} BulkOutEndpoints;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<UsbDescriptor>>> get() { Foundation::Collections::IVectorView<UsbDescriptor*>* value; hrcheck(enc(&IUsbInterfaceSetting_adaptor::Descriptors)->_get_Descriptors(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbDescriptor>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<UsbDescriptor>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbDescriptor>>> operator->() { return get(); }
		} Descriptors;
		struct : property {
			ptr<UsbInterfaceDescriptor> get() { UsbInterfaceDescriptor* value; hrcheck(enc(&IUsbInterfaceSetting_adaptor::InterfaceDescriptor)->_get_InterfaceDescriptor(&value)); return from_abi(value); }
			ptr<UsbInterfaceDescriptor> operator()() { return get(); }
			operator ptr<UsbInterfaceDescriptor> () { return get(); }
			ptr<UsbInterfaceDescriptor> operator->() { return get(); }
		} InterfaceDescriptor;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptInEndpointDescriptor>>> get() { Foundation::Collections::IVectorView<UsbInterruptInEndpointDescriptor*>* value; hrcheck(enc(&IUsbInterfaceSetting_adaptor::InterruptInEndpoints)->_get_InterruptInEndpoints(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptInEndpointDescriptor>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptInEndpointDescriptor>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptInEndpointDescriptor>>> operator->() { return get(); }
		} InterruptInEndpoints;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptOutEndpointDescriptor>>> get() { Foundation::Collections::IVectorView<UsbInterruptOutEndpointDescriptor*>* value; hrcheck(enc(&IUsbInterfaceSetting_adaptor::InterruptOutEndpoints)->_get_InterruptOutEndpoints(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptOutEndpointDescriptor>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptOutEndpointDescriptor>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<UsbInterruptOutEndpointDescriptor>>> operator->() { return get(); }
		} InterruptOutEndpoints;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUsbInterfaceSetting_adaptor::Selected)->_get_Selected(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Selected;
	};
	ptr<Foundation::IAsyncAction> SelectSettingAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_SelectSettingAsync(&operation)); return from_abi(operation); }
	IUsbInterfaceSetting_adaptor() {}
};
template<typename X> struct adapt<IUsbInterfaceSetting, X> : Windows::Devices::Usb::IUsbInterfaceSetting_adaptor<X> { typedef adapt IUsbInterfaceSetting; };
struct IUsbInterfaceSetting : IUsbInterfaceSetting_raw, generate<IUsbInterfaceSetting> {};

// UsbInterfaceSetting
template<typename X> struct statics<UsbInterfaceSetting, X> : X {
	typedef typename X::root_type UsbInterfaceSetting;
};
struct UsbInterfaceSetting : generate<UsbInterfaceSetting> {};
}}}
} // namespace iso_winrt
