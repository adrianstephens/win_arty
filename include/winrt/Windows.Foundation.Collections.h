#pragma once
// generated by isopod tools
// namespaces:
// Windows.Foundation.Collections

#include "Windows.Foundation.Collections.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types


// defs

template<> struct def<Windows::Foundation::Collections::CollectionChange> : enum_type<int> {};
template<> struct def<Windows::Foundation::Collections::IVectorChangedEventArgs> : overridable_type<> {};
template<typename K, typename V> struct def<Windows::Foundation::Collections::IKeyValuePair<K, V> > : overridable_type<> {};
template<typename T> struct def<Windows::Foundation::Collections::IIterable<T> > : overridable_type<> {};
template<typename K, typename V> struct def<Windows::Foundation::Collections::IMap<K, V> > : overridable_type<Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<K, V>>>> {};
template<typename K, typename V> struct def<Windows::Foundation::Collections::IObservableMap<K, V> > : overridable_type<Windows::Foundation::Collections::IMap<K, V>> {};
template<> struct def<Windows::Foundation::Collections::IPropertySet> : overridable_type<Windows::Foundation::Collections::IObservableMap<HSTRING, object>> {};
template<> struct def<Windows::Foundation::Collections::PropertySet> : class_type<Platform::Object, Windows::Foundation::Collections::IPropertySet> {};
template<> struct def<Windows::Foundation::Collections::ValueSet> : class_type<Platform::Object, Windows::Foundation::Collections::IPropertySet> {};
template<> struct def<Windows::Foundation::Collections::StringMap> : class_type<Platform::Object, Windows::Foundation::Collections::IMap<HSTRING, HSTRING>, Windows::Foundation::Collections::IObservableMap<HSTRING, HSTRING>> {};
template<typename T> struct def<Windows::Foundation::Collections::IIterator<T> > : overridable_type<> {};
template<typename T> struct def<Windows::Foundation::Collections::IVectorView<T> > : overridable_type<Windows::Foundation::Collections::IIterable<T>> {};
template<typename T> struct def<Windows::Foundation::Collections::IVector<T> > : overridable_type<Windows::Foundation::Collections::IIterable<T>> {};
template<typename K, typename V> struct def<Windows::Foundation::Collections::IMapView<K, V> > : overridable_type<Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<K, V>>>> {};
template<typename T> struct def<Windows::Foundation::Collections::VectorChangedEventHandler<T> > : delegate_type {};
template<typename T> struct def<Windows::Foundation::Collections::IObservableVector<T> > : overridable_type<Windows::Foundation::Collections::IVector<T>> {};
template<typename K> struct def<Windows::Foundation::Collections::IMapChangedEventArgs<K> > : overridable_type<> {};
template<typename K, typename V> struct def<Windows::Foundation::Collections::MapChangedEventHandler<K, V> > : delegate_type {};

// uuids

template<> struct uuid<Windows::Foundation::Collections::IVectorChangedEventArgs> { define_guid(0x575933DF, 0x34FE, 0x4480, 0xAF, 0x15, 0x7, 0x69, 0x1F, 0x3D, 0x5D, 0x9B);};
template<typename K, typename V> struct uuid_gen<Windows::Foundation::Collections::IKeyValuePair<K, V> > { define_guid(0x2B51929, 0xC1C4, 0x4A7E, 0x89, 0x40, 0x3, 0x12, 0xB5, 0xC1, 0x85, 0x0);};
template<typename T> struct uuid_gen<Windows::Foundation::Collections::IIterable<T> > { define_guid(0xFAA585EA, 0x6214, 0x4217, 0xAF, 0xDA, 0x7F, 0x46, 0xDE, 0x58, 0x69, 0xB3);};
template<typename K, typename V> struct uuid_gen<Windows::Foundation::Collections::IMap<K, V> > { define_guid(0x3C2925FE, 0x8519, 0x45C1, 0xAA, 0x79, 0x19, 0x7B, 0x67, 0x18, 0xC1, 0xC1);};
template<typename K, typename V> struct uuid_gen<Windows::Foundation::Collections::IObservableMap<K, V> > { define_guid(0x65DF2BF5, 0xBF39, 0x41B5, 0xAE, 0xBC, 0x5A, 0x9D, 0x86, 0x5E, 0x47, 0x2B);};
template<> struct uuid<Windows::Foundation::Collections::IPropertySet> { define_guid(0x8A43ED9F, 0xF4E6, 0x4421, 0xAC, 0xF9, 0x1D, 0xAB, 0x29, 0x86, 0x82, 0xC);};
template<typename T> struct uuid_gen<Windows::Foundation::Collections::IIterator<T> > { define_guid(0x6A79E863, 0x4300, 0x459A, 0x99, 0x66, 0xCB, 0xB6, 0x60, 0x96, 0x3E, 0xE1);};
template<typename T> struct uuid_gen<Windows::Foundation::Collections::IVectorView<T> > { define_guid(0xBBE1FA4C, 0xB0E3, 0x4583, 0xBA, 0xEF, 0x1F, 0x1B, 0x2E, 0x48, 0x3E, 0x56);};
template<typename T> struct uuid_gen<Windows::Foundation::Collections::IVector<T> > { define_guid(0x913337E9, 0x11A1, 0x4345, 0xA3, 0xA2, 0x4E, 0x7F, 0x95, 0x6E, 0x22, 0x2D);};
template<typename K, typename V> struct uuid_gen<Windows::Foundation::Collections::IMapView<K, V> > { define_guid(0xE480CE40, 0xA338, 0x4ADA, 0xAD, 0xCF, 0x27, 0x22, 0x72, 0xE4, 0x8C, 0xB9);};
template<typename T> struct uuid_gen<Windows::Foundation::Collections::VectorChangedEventHandler<T> > { define_guid(0xC051752, 0x9FBF, 0x4C70, 0xAA, 0xC, 0xE, 0x4C, 0x82, 0xD9, 0xA7, 0x61);};
template<typename T> struct uuid_gen<Windows::Foundation::Collections::IObservableVector<T> > { define_guid(0x5917EB53, 0x50B4, 0x4A0D, 0xB3, 0x9, 0x65, 0x86, 0x2B, 0x3F, 0x1D, 0xBC);};
template<typename K> struct uuid_gen<Windows::Foundation::Collections::IMapChangedEventArgs<K> > { define_guid(0x9939F4DF, 0x50A, 0x4C0F, 0xAA, 0x60, 0x77, 0x7, 0x5F, 0x9C, 0x47, 0x77);};
template<typename K, typename V> struct uuid_gen<Windows::Foundation::Collections::MapChangedEventHandler<K, V> > { define_guid(0x179517F3, 0x94EE, 0x41F8, 0xBD, 0xDC, 0x76, 0x8A, 0x89, 0x55, 0x44, 0xF3);};

// types

namespace Windows { namespace Foundation { namespace Collections {

// IVectorChangedEventArgs
struct IVectorChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_CollectionChange(Collections::CollectionChange *value) = 0;
	virtual STDMETHODIMP _get_Index(unsigned *value) = 0;
};
template<typename X> struct IVectorChangedEventArgs_adaptor : X {
	union {
		struct : property {
			Collections::CollectionChange get() { Collections::CollectionChange value; hrcheck(enc(&IVectorChangedEventArgs_adaptor::CollectionChange)->_get_CollectionChange(&value)); return value; }
			Collections::CollectionChange operator()() { return get(); }
			operator Collections::CollectionChange () { return get(); }
		} CollectionChange;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IVectorChangedEventArgs_adaptor::Index)->_get_Index(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Index;
	};
	IVectorChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IVectorChangedEventArgs, X> : Windows::Foundation::Collections::IVectorChangedEventArgs_adaptor<X> { typedef adapt IVectorChangedEventArgs; };
template<typename X> struct IVectorChangedEventArgs_unadaptor : X {
	STDMETHODIMP _get_CollectionChange(Collections::CollectionChange *value) { return hrtry([&, this] { get_prop(value, CollectionChange); }); }
	STDMETHODIMP _get_Index(unsigned *value) { return hrtry([&, this] { get_prop(value, Index); }); }
};
template<typename X> struct unadapt<IVectorChangedEventArgs, X> : Windows::Foundation::Collections::IVectorChangedEventArgs_unadaptor<X> {};
struct IVectorChangedEventArgs : IVectorChangedEventArgs_raw, generate<IVectorChangedEventArgs> {};

// IKeyValuePair
template<typename K, typename V> struct IKeyValuePair_raw : IInspectable {
	virtual STDMETHODIMP _get_Key(K *ret) = 0;
	virtual STDMETHODIMP _get_Value(V *ret) = 0;
};
template<typename X, typename K, typename V> struct IKeyValuePair_adaptor : X {
	typedef to_abi_t<K> KR;
	typedef to_abi_t<V> VR;
	union {
		struct : property {
			K get() { KR ret; hrcheck(enc(&IKeyValuePair_adaptor::Key)->_get_Key(&ret)); return ret; }
			K operator()() { return get(); }
			operator K () { return get(); }
		} Key;
		struct : property {
			V get() { VR ret; hrcheck(enc(&IKeyValuePair_adaptor::Value)->_get_Value(&ret)); return ret; }
			V operator()() { return get(); }
			operator V () { return get(); }
		} Value;
	};
	IKeyValuePair_adaptor() {}
};
template<typename X, typename K, typename V> struct adapt<IKeyValuePair<K, V> , X> : Windows::Foundation::Collections::IKeyValuePair_adaptor<X, K, V> { typedef adapt IKeyValuePair; };
template<typename X, typename K, typename V> struct IKeyValuePair_unadaptor : X {
	typedef to_abi_t<K> KR;
	typedef to_abi_t<V> VR;
	STDMETHODIMP _get_Key(KR *ret) { return hrtry([&, this] { get_prop(ret, Key); }); }
	STDMETHODIMP _get_Value(VR *ret) { return hrtry([&, this] { get_prop(ret, Value); }); }
};
template<typename X, typename K, typename V> struct unadapt<IKeyValuePair<K, V> , X> : Windows::Foundation::Collections::IKeyValuePair_unadaptor<X, K, V> {};
template<typename K, typename V> struct IKeyValuePair : IKeyValuePair_raw<to_abi_t<K>, to_abi_t<V>> , generate<IKeyValuePair<K, V> > {};

// IIterable
template<typename T> struct IIterable_raw : IInspectable {
	virtual STDMETHODIMP _First(IIterator<T>* *ret) = 0;
};
template<typename X, typename T> struct IIterable_adaptor : X {
	typedef to_abi_t<T> TR;
	ptr<IIterator<T>> First() { IIterator<TR>* ret; hrcheck(X::get()->_First(&ret)); return from_abi(ret); }
};
template<typename X, typename T> struct adapt<IIterable<T> , X> : Windows::Foundation::Collections::IIterable_adaptor<X, T> { typedef adapt IIterable; };
template<typename X, typename T> struct IIterable_unadaptor : X {
	typedef to_abi_t<T> TR;
	STDMETHODIMP _First(IIterator<TR>* *ret) { return hrtry([&, this] { *ret = to_abi(X::get()->First()); }); }
};
template<typename X, typename T> struct unadapt<IIterable<T> , X> : Windows::Foundation::Collections::IIterable_unadaptor<X, T> {};
template<typename T> struct IIterable : IIterable_raw<to_abi_t<T>> , generate<IIterable<T> > {};

// IMap
template<typename K, typename V> struct IMap_raw : IInspectable {
	virtual STDMETHODIMP _Lookup(K key, V *ret) = 0;
	virtual STDMETHODIMP _get_Size(unsigned *ret) = 0;
	virtual STDMETHODIMP _HasKey(K key, bool *ret) = 0;
	virtual STDMETHODIMP _GetView(IMapView<K, V>* *ret) = 0;
	virtual STDMETHODIMP _Insert(K key, V value, bool *ret) = 0;
	virtual STDMETHODIMP _Remove(K key) = 0;
	virtual STDMETHODIMP _Clear() = 0;
};
template<typename X, typename K, typename V> struct IMap_adaptor : X {
	typedef to_abi_t<K> KR;
	typedef to_abi_t<V> VR;
	union {
		struct : property {
			unsigned get() { unsigned ret; hrcheck(enc(&IMap_adaptor::Size)->_get_Size(&ret)); return ret; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Size;
	};
	V Lookup(K key) { VR ret; hrcheck(X::get()->_Lookup(key, &ret)); return ret; }
	bool HasKey(K key) { bool ret; hrcheck(X::get()->_HasKey(key, &ret)); return ret; }
	ptr<IMapView<K, V>> GetView() { IMapView<KR, VR>* ret; hrcheck(X::get()->_GetView(&ret)); return from_abi(ret); }
	bool Insert(K key, V value) { bool ret; hrcheck(X::get()->_Insert(key, value, &ret)); return ret; }
	void Remove(K key) { hrcheck(X::get()->_Remove(key)); }
	void Clear() { hrcheck(X::get()->_Clear()); }
	IMap_adaptor() {}
};
template<typename X, typename K, typename V> struct adapt<IMap<K, V> , X> : Windows::Foundation::Collections::IMap_adaptor<X, K, V> { typedef adapt IMap; };
template<typename X, typename K, typename V> struct IMap_unadaptor : X {
	typedef to_abi_t<K> KR;
	typedef to_abi_t<V> VR;
	STDMETHODIMP _Lookup(KR key, VR *ret) { return hrtry([&, this] { *ret = X::get()->Lookup(key); }); }
	STDMETHODIMP _get_Size(unsigned *ret) { return hrtry([&, this] { get_prop(ret, Size); }); }
	STDMETHODIMP _HasKey(KR key, bool *ret) { return hrtry([&, this] { *ret = X::get()->HasKey(key); }); }
	STDMETHODIMP _GetView(IMapView<KR, VR>* *ret) { return hrtry([&, this] { *ret = to_abi(X::get()->GetView()); }); }
	STDMETHODIMP _Insert(KR key, VR value, bool *ret) { return hrtry([&, this] { *ret = X::get()->Insert(key, value); }); }
	STDMETHODIMP _Remove(KR key) { return hrtry([&, this] { X::get()->Remove(key); }); }
	STDMETHODIMP _Clear() { return hrtry([&, this] { X::get()->Clear(); }); }
};
template<typename X, typename K, typename V> struct unadapt<IMap<K, V> , X> : Windows::Foundation::Collections::IMap_unadaptor<X, K, V> {};
template<typename K, typename V> struct IMap : IMap_raw<to_abi_t<K>, to_abi_t<V>> , generate<IMap<K, V> > {};

// IObservableMap
template<typename K, typename V> struct IObservableMap_raw : IInspectable {
	virtual STDMETHODIMP _add_MapChanged(MapChangedEventHandler<K, V>* vhnd, EventRegistrationToken *ret) = 0;
	virtual STDMETHODIMP _remove_MapChanged(EventRegistrationToken token) = 0;
};
template<typename X, typename K, typename V> struct IObservableMap_adaptor : X {
	typedef to_abi_t<K> KR;
	typedef to_abi_t<V> VR;
	union {
		struct : property {
			EventRegistrationToken operator+=(handler_ref<MapChangedEventHandler<K, V>> vhnd) { EventRegistrationToken ret; hrcheck(enc(&IObservableMap_adaptor::MapChanged)->_add_MapChanged(to_abi(vhnd), &ret)); return ret; }
			void operator-=(const EventRegistrationToken& token) { hrcheck(enc(&IObservableMap_adaptor::MapChanged)->_remove_MapChanged(token)); }
		} MapChanged;
	};
	IObservableMap_adaptor() {}
};
template<typename X, typename K, typename V> struct adapt<IObservableMap<K, V> , X> : Windows::Foundation::Collections::IObservableMap_adaptor<X, K, V> { typedef adapt IObservableMap; };
template<typename X, typename K, typename V> struct IObservableMap_unadaptor : X {
	typedef to_abi_t<K> KR;
	typedef to_abi_t<V> VR;
	STDMETHODIMP _add_MapChanged(MapChangedEventHandler<KR, VR>* vhnd, EventRegistrationToken *ret) { return hrtry([&, this] { *ret = X::get()->MapChanged+=vhnd; }); }
	STDMETHODIMP _remove_MapChanged(EventRegistrationToken token) { return hrtry([&, this] { X::get()->MapChanged-=token; }); }
};
template<typename X, typename K, typename V> struct unadapt<IObservableMap<K, V> , X> : Windows::Foundation::Collections::IObservableMap_unadaptor<X, K, V> {};
template<typename K, typename V> struct IObservableMap : IObservableMap_raw<to_abi_t<K>, to_abi_t<V>> , generate<IObservableMap<K, V> > {};

// IPropertySet
struct IPropertySet : IInspectable, generate<IPropertySet> {};

// PropertySet
template<typename X> struct statics<PropertySet, X> : X {
	typedef typename X::root_type PropertySet;
};
struct PropertySet : generate<PropertySet> {};

// ValueSet
template<typename X> struct statics<ValueSet, X> : X {
	typedef typename X::root_type ValueSet;
};
struct ValueSet : generate<ValueSet> {};

// StringMap
template<typename X> struct statics<StringMap, X> : X {
	typedef typename X::root_type StringMap;
};
struct StringMap : generate<StringMap> {};

// IIterator
template<typename T> struct IIterator_raw : IInspectable {
	virtual STDMETHODIMP _get_Current(T *ret) = 0;
	virtual STDMETHODIMP _get_HasCurrent(bool *ret) = 0;
	virtual STDMETHODIMP _MoveNext(bool *ret) = 0;
	virtual STDMETHODIMP _GetMany(unsigned itemsSize, T *items, unsigned *ret) = 0;
};
template<typename X, typename T> struct IIterator_adaptor : X {
	typedef to_abi_t<T> TR;
	union {
		struct : property {
			T get() { TR ret; hrcheck(enc(&IIterator_adaptor::Current)->_get_Current(&ret)); return ret; }
			T operator()() { return get(); }
			operator T () { return get(); }
		} Current;
		struct : property {
			bool get() { bool ret; hrcheck(enc(&IIterator_adaptor::HasCurrent)->_get_HasCurrent(&ret)); return ret; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasCurrent;
	};
	bool MoveNext() { bool ret; hrcheck(X::get()->_MoveNext(&ret)); return ret; }
	unsigned GetMany(const szarray<T>& items) { unsigned ret; hrcheck(X::get()->_GetMany(items.size, to_abi(items.p), &ret)); return ret; }
	IIterator_adaptor() {}
};
template<typename X, typename T> struct adapt<IIterator<T> , X> : Windows::Foundation::Collections::IIterator_adaptor<X, T> { typedef adapt IIterator; };
template<typename X, typename T> struct IIterator_unadaptor : X {
	typedef to_abi_t<T> TR;
	STDMETHODIMP _get_Current(TR *ret) { return hrtry([&, this] { get_prop(ret, Current); }); }
	STDMETHODIMP _get_HasCurrent(bool *ret) { return hrtry([&, this] { get_prop(ret, HasCurrent); }); }
	STDMETHODIMP _MoveNext(bool *ret) { return hrtry([&, this] { *ret = X::get()->MoveNext(); }); }
	STDMETHODIMP _GetMany(unsigned itemsSize, TR *items, unsigned *ret) { return hrtry([&, this] { *ret = X::get()->GetMany({(T*)items, itemsSize}); }); }
};
template<typename X, typename T> struct unadapt<IIterator<T> , X> : Windows::Foundation::Collections::IIterator_unadaptor<X, T> {};
template<typename T> struct IIterator : IIterator_raw<to_abi_t<T>> , generate<IIterator<T> > {};

// IVectorView
template<typename T> struct IVectorView_raw : IInspectable {
	virtual STDMETHODIMP _GetAt(unsigned index, T *ret) = 0;
	virtual STDMETHODIMP _get_Size(unsigned *ret) = 0;
	virtual STDMETHODIMP _IndexOf(T value, unsigned *index, bool *ret) = 0;
	virtual STDMETHODIMP _GetMany(unsigned startIndex, unsigned itemsSize, T *items, unsigned *ret) = 0;
};
template<typename X, typename T> struct IVectorView_adaptor : X {
	typedef to_abi_t<T> TR;
	union {
		struct : property {
			unsigned get() { unsigned ret; hrcheck(enc(&IVectorView_adaptor::Size)->_get_Size(&ret)); return ret; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Size;
	};
	T GetAt(unsigned index) { TR ret; hrcheck(X::get()->_GetAt(index, &ret)); return ret; }
	bool IndexOf(T value, unsigned *index) { bool ret; hrcheck(X::get()->_IndexOf(value, index, &ret)); return ret; }
	unsigned GetMany(unsigned startIndex, const szarray<T>& items) { unsigned ret; hrcheck(X::get()->_GetMany(startIndex, items.size, to_abi(items.p), &ret)); return ret; }
	IVectorView_adaptor() {}
};
template<typename X, typename T> struct adapt<IVectorView<T> , X> : Windows::Foundation::Collections::IVectorView_adaptor<X, T> { typedef adapt IVectorView; };
template<typename X, typename T> struct IVectorView_unadaptor : X {
	typedef to_abi_t<T> TR;
	STDMETHODIMP _GetAt(unsigned index, TR *ret) { return hrtry([&, this] { *ret = X::get()->GetAt(index); }); }
	STDMETHODIMP _get_Size(unsigned *ret) { return hrtry([&, this] { get_prop(ret, Size); }); }
	STDMETHODIMP _IndexOf(TR value, unsigned *index, bool *ret) { return hrtry([&, this] { *ret = X::get()->IndexOf(value, index); }); }
	STDMETHODIMP _GetMany(unsigned startIndex, unsigned itemsSize, TR *items, unsigned *ret) { return hrtry([&, this] { *ret = X::get()->GetMany(startIndex, {(T*)items, itemsSize}); }); }
};
template<typename X, typename T> struct unadapt<IVectorView<T> , X> : Windows::Foundation::Collections::IVectorView_unadaptor<X, T> {};
template<typename T> struct IVectorView : IVectorView_raw<to_abi_t<T>> , generate<IVectorView<T> > {};

// IVector
template<typename T> struct IVector_raw : IInspectable {
	virtual STDMETHODIMP _GetAt(unsigned index, T *ret) = 0;
	virtual STDMETHODIMP _get_Size(unsigned *ret) = 0;
	virtual STDMETHODIMP _GetView(IVectorView<T>* *ret) = 0;
	virtual STDMETHODIMP _IndexOf(T value, unsigned *index, bool *ret) = 0;
	virtual STDMETHODIMP _SetAt(unsigned index, T value) = 0;
	virtual STDMETHODIMP _InsertAt(unsigned index, T value) = 0;
	virtual STDMETHODIMP _RemoveAt(unsigned index) = 0;
	virtual STDMETHODIMP _Append(T value) = 0;
	virtual STDMETHODIMP _RemoveAtEnd() = 0;
	virtual STDMETHODIMP _Clear() = 0;
	virtual STDMETHODIMP _GetMany(unsigned startIndex, unsigned itemsSize, T *items, unsigned *ret) = 0;
	virtual STDMETHODIMP _ReplaceAll(unsigned itemsSize, T *items) = 0;
};
template<typename X, typename T> struct IVector_adaptor : X {
	typedef to_abi_t<T> TR;
	union {
		struct : property {
			unsigned get() { unsigned ret; hrcheck(enc(&IVector_adaptor::Size)->_get_Size(&ret)); return ret; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Size;
	};
	T GetAt(unsigned index) { TR ret; hrcheck(X::get()->_GetAt(index, &ret)); return ret; }
	ptr<IVectorView<T>> GetView() { IVectorView<TR>* ret; hrcheck(X::get()->_GetView(&ret)); return from_abi(ret); }
	bool IndexOf(T value, unsigned *index) { bool ret; hrcheck(X::get()->_IndexOf(value, index, &ret)); return ret; }
	void SetAt(unsigned index, T value) { hrcheck(X::get()->_SetAt(index, value)); }
	void InsertAt(unsigned index, T value) { hrcheck(X::get()->_InsertAt(index, value)); }
	void RemoveAt(unsigned index) { hrcheck(X::get()->_RemoveAt(index)); }
	void Append(T value) { hrcheck(X::get()->_Append(value)); }
	void RemoveAtEnd() { hrcheck(X::get()->_RemoveAtEnd()); }
	void Clear() { hrcheck(X::get()->_Clear()); }
	unsigned GetMany(unsigned startIndex, const szarray<T>& items) { unsigned ret; hrcheck(X::get()->_GetMany(startIndex, items.size, to_abi(items.p), &ret)); return ret; }
	void ReplaceAll(const szarray<T>& items) { hrcheck(X::get()->_ReplaceAll(items.size, to_abi(items.p))); }
	IVector_adaptor() {}
};
template<typename X, typename T> struct adapt<IVector<T> , X> : Windows::Foundation::Collections::IVector_adaptor<X, T> { typedef adapt IVector; };
template<typename X, typename T> struct IVector_unadaptor : X {
	typedef to_abi_t<T> TR;
	STDMETHODIMP _GetAt(unsigned index, TR *ret) { return hrtry([&, this] { *ret = X::get()->GetAt(index); }); }
	STDMETHODIMP _get_Size(unsigned *ret) { return hrtry([&, this] { get_prop(ret, Size); }); }
	STDMETHODIMP _GetView(IVectorView<TR>* *ret) { return hrtry([&, this] { *ret = to_abi(X::get()->GetView()); }); }
	STDMETHODIMP _IndexOf(TR value, unsigned *index, bool *ret) { return hrtry([&, this] { *ret = X::get()->IndexOf(value, index); }); }
	STDMETHODIMP _SetAt(unsigned index, TR value) { return hrtry([&, this] { X::get()->SetAt(index, value); }); }
	STDMETHODIMP _InsertAt(unsigned index, TR value) { return hrtry([&, this] { X::get()->InsertAt(index, value); }); }
	STDMETHODIMP _RemoveAt(unsigned index) { return hrtry([&, this] { X::get()->RemoveAt(index); }); }
	STDMETHODIMP _Append(TR value) { return hrtry([&, this] { X::get()->Append(value); }); }
	STDMETHODIMP _RemoveAtEnd() { return hrtry([&, this] { X::get()->RemoveAtEnd(); }); }
	STDMETHODIMP _Clear() { return hrtry([&, this] { X::get()->Clear(); }); }
	STDMETHODIMP _GetMany(unsigned startIndex, unsigned itemsSize, TR *items, unsigned *ret) { return hrtry([&, this] { *ret = X::get()->GetMany(startIndex, {(T*)items, itemsSize}); }); }
	STDMETHODIMP _ReplaceAll(unsigned itemsSize, TR *items) { return hrtry([&, this] { X::get()->ReplaceAll({(T*)items, itemsSize}); }); }
};
template<typename X, typename T> struct unadapt<IVector<T> , X> : Windows::Foundation::Collections::IVector_unadaptor<X, T> {};
template<typename T> struct IVector : IVector_raw<to_abi_t<T>> , generate<IVector<T> > {};

// IMapView
template<typename K, typename V> struct IMapView_raw : IInspectable {
	virtual STDMETHODIMP _Lookup(K key, V *ret) = 0;
	virtual STDMETHODIMP _get_Size(unsigned *ret) = 0;
	virtual STDMETHODIMP _HasKey(K key, bool *ret) = 0;
	virtual STDMETHODIMP _Split(IMapView<K, V>* *first, IMapView<K, V>* *second) = 0;
};
template<typename X, typename K, typename V> struct IMapView_adaptor : X {
	typedef to_abi_t<K> KR;
	typedef to_abi_t<V> VR;
	union {
		struct : property {
			unsigned get() { unsigned ret; hrcheck(enc(&IMapView_adaptor::Size)->_get_Size(&ret)); return ret; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Size;
	};
	V Lookup(K key) { VR ret; hrcheck(X::get()->_Lookup(key, &ret)); return ret; }
	bool HasKey(K key) { bool ret; hrcheck(X::get()->_HasKey(key, &ret)); return ret; }
	ptr<IMapView<K, V>> Split(pptr<IMapView<K, V>> *first) { IMapView<KR, VR>* second; hrcheck(X::get()->_Split(first, &second)); return from_abi(second); }
	IMapView_adaptor() {}
};
template<typename X, typename K, typename V> struct adapt<IMapView<K, V> , X> : Windows::Foundation::Collections::IMapView_adaptor<X, K, V> { typedef adapt IMapView; };
template<typename X, typename K, typename V> struct IMapView_unadaptor : X {
	typedef to_abi_t<K> KR;
	typedef to_abi_t<V> VR;
	STDMETHODIMP _Lookup(KR key, VR *ret) { return hrtry([&, this] { *ret = X::get()->Lookup(key); }); }
	STDMETHODIMP _get_Size(unsigned *ret) { return hrtry([&, this] { get_prop(ret, Size); }); }
	STDMETHODIMP _HasKey(KR key, bool *ret) { return hrtry([&, this] { *ret = X::get()->HasKey(key); }); }
	STDMETHODIMP _Split(IMapView<KR, VR>* *first, IMapView<KR, VR>* *second) { return hrtry([&, this] { *second = to_abi(X::get()->Split(first, )); }); }
};
template<typename X, typename K, typename V> struct unadapt<IMapView<K, V> , X> : Windows::Foundation::Collections::IMapView_unadaptor<X, K, V> {};
template<typename K, typename V> struct IMapView : IMapView_raw<to_abi_t<K>, to_abi_t<V>> , generate<IMapView<K, V> > {};

// VectorChangedEventHandler
template<typename T> struct VectorChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IObservableVector<T>* sender, IVectorChangedEventArgs* event) = 0;
};

// IObservableVector
template<typename T> struct IObservableVector_raw : IInspectable {
	virtual STDMETHODIMP _add_VectorChanged(VectorChangedEventHandler<T>* vhnd, EventRegistrationToken *ret) = 0;
	virtual STDMETHODIMP _remove_VectorChanged(EventRegistrationToken token) = 0;
};
template<typename X, typename T> struct IObservableVector_adaptor : X {
	typedef to_abi_t<T> TR;
	union {
		struct : property {
			EventRegistrationToken operator+=(handler_ref<VectorChangedEventHandler<T>> vhnd) { EventRegistrationToken ret; hrcheck(enc(&IObservableVector_adaptor::VectorChanged)->_add_VectorChanged(to_abi(vhnd), &ret)); return ret; }
			void operator-=(const EventRegistrationToken& token) { hrcheck(enc(&IObservableVector_adaptor::VectorChanged)->_remove_VectorChanged(token)); }
		} VectorChanged;
	};
	IObservableVector_adaptor() {}
};
template<typename X, typename T> struct adapt<IObservableVector<T> , X> : Windows::Foundation::Collections::IObservableVector_adaptor<X, T> { typedef adapt IObservableVector; };
template<typename X, typename T> struct IObservableVector_unadaptor : X {
	typedef to_abi_t<T> TR;
	STDMETHODIMP _add_VectorChanged(VectorChangedEventHandler<TR>* vhnd, EventRegistrationToken *ret) { return hrtry([&, this] { *ret = X::get()->VectorChanged+=vhnd; }); }
	STDMETHODIMP _remove_VectorChanged(EventRegistrationToken token) { return hrtry([&, this] { X::get()->VectorChanged-=token; }); }
};
template<typename X, typename T> struct unadapt<IObservableVector<T> , X> : Windows::Foundation::Collections::IObservableVector_unadaptor<X, T> {};
template<typename T> struct IObservableVector : IObservableVector_raw<to_abi_t<T>> , generate<IObservableVector<T> > {};

// IMapChangedEventArgs
template<typename K> struct IMapChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_CollectionChange(Collections::CollectionChange *ret) = 0;
	virtual STDMETHODIMP _get_Key(K *ret) = 0;
};
template<typename X, typename K> struct IMapChangedEventArgs_adaptor : X {
	typedef to_abi_t<K> KR;
	union {
		struct : property {
			Collections::CollectionChange get() { Collections::CollectionChange ret; hrcheck(enc(&IMapChangedEventArgs_adaptor::CollectionChange)->_get_CollectionChange(&ret)); return ret; }
			Collections::CollectionChange operator()() { return get(); }
			operator Collections::CollectionChange () { return get(); }
		} CollectionChange;
		struct : property {
			K get() { KR ret; hrcheck(enc(&IMapChangedEventArgs_adaptor::Key)->_get_Key(&ret)); return ret; }
			K operator()() { return get(); }
			operator K () { return get(); }
		} Key;
	};
	IMapChangedEventArgs_adaptor() {}
};
template<typename X, typename K> struct adapt<IMapChangedEventArgs<K> , X> : Windows::Foundation::Collections::IMapChangedEventArgs_adaptor<X, K> { typedef adapt IMapChangedEventArgs; };
template<typename X, typename K> struct IMapChangedEventArgs_unadaptor : X {
	typedef to_abi_t<K> KR;
	STDMETHODIMP _get_CollectionChange(Collections::CollectionChange *ret) { return hrtry([&, this] { get_prop(ret, CollectionChange); }); }
	STDMETHODIMP _get_Key(KR *ret) { return hrtry([&, this] { get_prop(ret, Key); }); }
};
template<typename X, typename K> struct unadapt<IMapChangedEventArgs<K> , X> : Windows::Foundation::Collections::IMapChangedEventArgs_unadaptor<X, K> {};
template<typename K> struct IMapChangedEventArgs : IMapChangedEventArgs_raw<to_abi_t<K>> , generate<IMapChangedEventArgs<K> > {};

// MapChangedEventHandler
template<typename K, typename V> struct MapChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IObservableMap<K, V>* sender, IMapChangedEventArgs<K>* event) = 0;
};
}}}
} // namespace iso_winrt
