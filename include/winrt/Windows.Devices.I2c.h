#pragma once
// generated by isopod tools
// namespaces:
// Windows.Devices.I2c

#include "Windows.Devices.I2c.0.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Devices { namespace I2c { namespace Provider {
struct II2cProvider;
}}}
namespace Foundation { namespace Collections {
template<typename T> struct IVectorView;
}}}

// defs

template<> struct def<Windows::Devices::I2c::I2cBusSpeed> : enum_type<int> {};
template<> struct def<Windows::Devices::I2c::I2cTransferStatus> : enum_type<int> {};
template<> struct def<Windows::Devices::I2c::I2cSharingMode> : enum_type<int> {};
template<> struct def<Windows::Devices::I2c::I2cTransferResult> : value_type<Windows::Devices::I2c::I2cTransferStatus, unsigned> {};
template<> struct def<Windows::Devices::I2c::II2cConnectionSettingsFactory> : interface_type<> {};
template<> struct def<Windows::Devices::I2c::II2cConnectionSettings> : interface_type<> {};
template<> struct def<Windows::Devices::I2c::I2cConnectionSettings> : class_type<Platform::Object, Windows::Devices::I2c::II2cConnectionSettings>, custom_activators {};
template<> struct def<Windows::Devices::I2c::II2cDeviceStatics> : overridable_type<> {};
template<> struct def<Windows::Devices::I2c::II2cDevice> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Devices::I2c::I2cDevice> : class_type<Platform::Object, Windows::Devices::I2c::II2cDevice> {};
template<> struct def<Windows::Devices::I2c::II2cController> : interface_type<> {};
template<> struct def<Windows::Devices::I2c::II2cControllerStatics> : interface_type<> {};
template<> struct def<Windows::Devices::I2c::I2cController> : class_type<Platform::Object, Windows::Devices::I2c::II2cController> {};

// uuids

template<> struct uuid<Windows::Devices::I2c::II2cConnectionSettingsFactory> { define_guid(0x81B586B3, 0x9693, 0x41B1, 0xA2, 0x43, 0xDE, 0xD4, 0xF6, 0xE6, 0x69, 0x26);};
template<> struct uuid<Windows::Devices::I2c::II2cConnectionSettings> { define_guid(0xF2DB1307, 0xAB6F, 0x4639, 0xA7, 0x67, 0x54, 0x53, 0x6D, 0xC3, 0x46, 0xF);};
template<> struct uuid<Windows::Devices::I2c::II2cDeviceStatics> { define_guid(0x91A33BE3, 0x7334, 0x4512, 0x96, 0xBC, 0xFB, 0xAE, 0x94, 0x59, 0xF5, 0xF6);};
template<> struct uuid<Windows::Devices::I2c::II2cDevice> { define_guid(0x8636C136, 0xB9C5, 0x4F70, 0x94, 0x49, 0xCC, 0x46, 0xDC, 0x6F, 0x57, 0xEB);};
template<> struct uuid<Windows::Devices::I2c::II2cController> { define_guid(0xC48AB1B2, 0x87A0, 0x4166, 0x8E, 0x3E, 0xB4, 0xB8, 0xF9, 0x7C, 0xD7, 0x29);};
template<> struct uuid<Windows::Devices::I2c::II2cControllerStatics> { define_guid(0x40FC0365, 0x5F05, 0x4E7E, 0x84, 0xBD, 0x10, 0xD, 0xB8, 0xE0, 0xAE, 0xC5);};

// types

namespace Windows { namespace Devices { namespace I2c {

// II2cConnectionSettingsFactory
struct II2cConnectionSettingsFactory : IInspectable {
	virtual STDMETHODIMP _Create(int slaveAddress, I2cConnectionSettings* *value);
};

// II2cConnectionSettings
struct II2cConnectionSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_SlaveAddress(int *value);
	virtual STDMETHODIMP _put_SlaveAddress(int value);
	virtual STDMETHODIMP _get_BusSpeed(I2cBusSpeed *value);
	virtual STDMETHODIMP _put_BusSpeed(I2cBusSpeed value);
	virtual STDMETHODIMP _get_SharingMode(I2cSharingMode *value);
	virtual STDMETHODIMP _put_SharingMode(I2cSharingMode value);
};
template<typename X> struct II2cConnectionSettings_adaptor : X {
	union {
		struct : property {
			I2cBusSpeed get() { I2cBusSpeed value; hrcheck(enc(&II2cConnectionSettings_adaptor::BusSpeed)->_get_BusSpeed(&value)); return value; }
			I2cBusSpeed operator()() { return get(); }
			operator I2cBusSpeed () { return get(); }
			void put(I2cBusSpeed value) { hrcheck(enc(&II2cConnectionSettings_adaptor::BusSpeed)->_put_BusSpeed(value)); }
			void operator=(I2cBusSpeed value) { put(value); }
			void operator()(I2cBusSpeed value) { put(value); }
		} BusSpeed;
		struct : property {
			I2cSharingMode get() { I2cSharingMode value; hrcheck(enc(&II2cConnectionSettings_adaptor::SharingMode)->_get_SharingMode(&value)); return value; }
			I2cSharingMode operator()() { return get(); }
			operator I2cSharingMode () { return get(); }
			void put(I2cSharingMode value) { hrcheck(enc(&II2cConnectionSettings_adaptor::SharingMode)->_put_SharingMode(value)); }
			void operator=(I2cSharingMode value) { put(value); }
			void operator()(I2cSharingMode value) { put(value); }
		} SharingMode;
		struct : property {
			int get() { int value; hrcheck(enc(&II2cConnectionSettings_adaptor::SlaveAddress)->_get_SlaveAddress(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&II2cConnectionSettings_adaptor::SlaveAddress)->_put_SlaveAddress(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} SlaveAddress;
	};
	II2cConnectionSettings_adaptor() {}
};
template<typename X> struct adapt<II2cConnectionSettings, X> : Windows::Devices::I2c::II2cConnectionSettings_adaptor<X> { typedef adapt II2cConnectionSettings; };
struct II2cConnectionSettings : II2cConnectionSettings_raw, generate<II2cConnectionSettings> {};

// I2cConnectionSettings
template<typename> struct I2cConnectionSettings_statics {
	static I2cConnectionSettings *activate(int slaveAddress) { I2cConnectionSettings *value; hrcheck(get_activation_factory<I2cConnectionSettings, II2cConnectionSettingsFactory>()->_Create(slaveAddress, &value)); return value; }
};

template<typename X> struct statics<I2cConnectionSettings, X> : X, Windows::Devices::I2c::I2cConnectionSettings_statics<void> {
	using Windows::Devices::I2c::I2cConnectionSettings_statics<void>::activate;
	typedef typename X::root_type I2cConnectionSettings;
};
struct I2cConnectionSettings : generate<I2cConnectionSettings> {};

// II2cDeviceStatics
struct II2cDeviceStatics_raw : IInspectable {
	virtual STDMETHODIMP _GetDeviceSelector(HSTRING *value) = 0;
	virtual STDMETHODIMP _GetDeviceSelectorFromFriendlyName(HSTRING friendlyName, HSTRING *value) = 0;
	virtual STDMETHODIMP _FromIdAsync(HSTRING deviceId, I2cConnectionSettings* settings, Foundation::IAsyncOperation<I2cDevice*>* *operation) = 0;
};
template<typename X> struct II2cDeviceStatics_adaptor : X {
	hstring GetDeviceSelector() { HSTRING value; hrcheck(X::get()->_GetDeviceSelector(&value)); return from_abi(value); }
	hstring GetDeviceSelector(hstring_ref friendlyName) { HSTRING value; hrcheck(X::get()->_GetDeviceSelectorFromFriendlyName(friendlyName, &value)); return from_abi(value); }
	ptr<Foundation::IAsyncOperation<ptr<I2cDevice>>> FromIdAsync(hstring_ref deviceId, pptr<I2cConnectionSettings> settings) { Foundation::IAsyncOperation<I2cDevice*>* operation; hrcheck(X::get()->_FromIdAsync(deviceId, settings, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<II2cDeviceStatics, X> : Windows::Devices::I2c::II2cDeviceStatics_adaptor<X> { typedef adapt II2cDeviceStatics; };
template<typename X> struct II2cDeviceStatics_unadaptor : X {
	STDMETHODIMP _GetDeviceSelector(HSTRING *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetDeviceSelector()); }); }
	STDMETHODIMP _GetDeviceSelectorFromFriendlyName(HSTRING friendlyName, HSTRING *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetDeviceSelector(friendlyName)); }); }
	STDMETHODIMP _FromIdAsync(HSTRING deviceId, I2cConnectionSettings* settings, Foundation::IAsyncOperation<I2cDevice*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->FromIdAsync(deviceId, settings)); }); }
};
template<typename X> struct unadapt<II2cDeviceStatics, X> : Windows::Devices::I2c::II2cDeviceStatics_unadaptor<X> {};
struct II2cDeviceStatics : II2cDeviceStatics_raw, generate<II2cDeviceStatics> {};

// II2cDevice
struct II2cDevice_raw : IInspectable {
	virtual STDMETHODIMP _get_DeviceId(HSTRING *value);
	virtual STDMETHODIMP _get_ConnectionSettings(I2cConnectionSettings* *value);
	virtual STDMETHODIMP _Write(unsigned bufferSize, unsigned char *buffer);
	virtual STDMETHODIMP _WritePartial(unsigned bufferSize, unsigned char *buffer, I2cTransferResult *result);
	virtual STDMETHODIMP _Read(unsigned bufferSize, unsigned char *buffer);
	virtual STDMETHODIMP _ReadPartial(unsigned bufferSize, unsigned char *buffer, I2cTransferResult *result);
	virtual STDMETHODIMP _WriteRead(unsigned writeBufferSize, unsigned char *writeBuffer, unsigned readBufferSize, unsigned char *readBuffer);
	virtual STDMETHODIMP _WriteReadPartial(unsigned writeBufferSize, unsigned char *writeBuffer, unsigned readBufferSize, unsigned char *readBuffer, I2cTransferResult *result);
};
template<typename X> struct II2cDevice_adaptor : X {
	union {
		struct : property {
			ptr<I2cConnectionSettings> get() { I2cConnectionSettings* value; hrcheck(enc(&II2cDevice_adaptor::ConnectionSettings)->_get_ConnectionSettings(&value)); return from_abi(value); }
			ptr<I2cConnectionSettings> operator()() { return get(); }
			operator ptr<I2cConnectionSettings> () { return get(); }
			ptr<I2cConnectionSettings> operator->() { return get(); }
		} ConnectionSettings;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&II2cDevice_adaptor::DeviceId)->_get_DeviceId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DeviceId;
	};
	void Write(const szarray<unsigned char>& buffer) { hrcheck(X::get()->_Write(buffer.size, to_abi(buffer.p))); }
	I2cTransferResult WritePartial(const szarray<unsigned char>& buffer) { I2cTransferResult result; hrcheck(X::get()->_WritePartial(buffer.size, to_abi(buffer.p), &result)); return result; }
	void Read(const szarray<unsigned char>& buffer) { hrcheck(X::get()->_Read(buffer.size, to_abi(buffer.p))); }
	I2cTransferResult ReadPartial(const szarray<unsigned char>& buffer) { I2cTransferResult result; hrcheck(X::get()->_ReadPartial(buffer.size, to_abi(buffer.p), &result)); return result; }
	void WriteRead(const szarray<unsigned char>& writeBuffer, const szarray<unsigned char>& readBuffer) { hrcheck(X::get()->_WriteRead(writeBuffer.size, to_abi(writeBuffer.p), readBuffer.size, to_abi(readBuffer.p))); }
	I2cTransferResult WriteReadPartial(const szarray<unsigned char>& writeBuffer, const szarray<unsigned char>& readBuffer) { I2cTransferResult result; hrcheck(X::get()->_WriteReadPartial(writeBuffer.size, to_abi(writeBuffer.p), readBuffer.size, to_abi(readBuffer.p), &result)); return result; }
	II2cDevice_adaptor() {}
};
template<typename X> struct adapt<II2cDevice, X> : Windows::Devices::I2c::II2cDevice_adaptor<X> { typedef adapt II2cDevice; };
struct II2cDevice : II2cDevice_raw, generate<II2cDevice> {};

// I2cDevice
template<typename> struct I2cDevice_statics {
	static hstring GetDeviceSelector();
	static hstring GetDeviceSelector(hstring_ref friendlyName);
	static ptr<Foundation::IAsyncOperation<ptr<I2cDevice>>> FromIdAsync(hstring_ref deviceId, pptr<I2cConnectionSettings> settings);
};

template<typename X> struct statics<I2cDevice, X> : X, Windows::Devices::I2c::I2cDevice_statics<void> {
	typedef typename X::root_type I2cDevice;
};
struct I2cDevice : generate<I2cDevice> {};

// II2cController
struct II2cController_raw : IInspectable {
	virtual STDMETHODIMP _GetDevice(I2cConnectionSettings* settings, I2cDevice* *device);
};
template<typename X> struct II2cController_adaptor : X {
	ptr<I2cDevice> GetDevice(pptr<I2cConnectionSettings> settings) { I2cDevice* device; hrcheck(X::get()->_GetDevice(settings, &device)); return from_abi(device); }
};
template<typename X> struct adapt<II2cController, X> : Windows::Devices::I2c::II2cController_adaptor<X> { typedef adapt II2cController; };
struct II2cController : II2cController_raw, generate<II2cController> {};

// II2cControllerStatics
struct II2cControllerStatics : IInspectable {
	virtual STDMETHODIMP _GetControllersAsync(Provider::II2cProvider* provider, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<I2cController*>*>* *operation);
	virtual STDMETHODIMP _GetDefaultAsync(Foundation::IAsyncOperation<I2cController*>* *operation);
};

// I2cController
template<typename> struct I2cController_statics {
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<I2cController>>>>> GetControllersAsync(pptr<Provider::II2cProvider> provider) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<I2cController*>*>* operation; hrcheck(get_activation_factory<I2cController, II2cControllerStatics>()->_GetControllersAsync(provider, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<I2cController>>> GetDefaultAsync() { Foundation::IAsyncOperation<I2cController*>* operation; hrcheck(get_activation_factory<I2cController, II2cControllerStatics>()->_GetDefaultAsync(&operation)); return from_abi(operation); }
};

template<typename X> struct statics<I2cController, X> : X, Windows::Devices::I2c::I2cController_statics<void> {
	typedef typename X::root_type I2cController;
};
struct I2cController : generate<I2cController> {};
}}}
} // namespace iso_winrt
