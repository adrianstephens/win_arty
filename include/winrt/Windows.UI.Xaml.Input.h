#pragma once
// generated by isopod tools
// namespaces:
// Windows.UI.Xaml.Input

#include "Windows.UI.Xaml.Input.0.h"
#include "Windows.System.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.UI.Core.0.h"
#include "Windows.UI.Input.0.h"
#include "Windows.Devices.Input.0.h"
#include "Windows.UI.Xaml.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IVector;
}}}

// defs

template<> struct def<Windows::UI::Xaml::Input::FocusInputDeviceKind> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Input::FocusNavigationDirection> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Input::InputScopeNameValue> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Input::KeyboardAcceleratorPlacementMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Input::KeyboardNavigationMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Input::KeyTipPlacementMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Input::ManipulationModes> : enum_type<unsigned> {};
template<> struct def<Windows::UI::Xaml::Input::XYFocusKeyboardNavigationMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Input::XYFocusNavigationStrategy> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Input::XYFocusNavigationStrategyOverride> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Input::DoubleTappedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Input::HoldingEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Input::KeyEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Input::ManipulationCompletedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Input::ManipulationDeltaEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Input::ManipulationInertiaStartingEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Input::ManipulationStartedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Input::ManipulationStartingEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Input::PointerEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Input::RightTappedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Input::TappedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Input::IPointer> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::Pointer> : class_type<Platform::Object, Windows::UI::Xaml::Input::IPointer> {};
template<> struct def<Windows::UI::Xaml::Input::IAccessKeyDisplayRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Input::IAccessKeyDisplayRequestedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Input::IAccessKeyDisplayDismissedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Input::IAccessKeyDisplayDismissedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Input::IAccessKeyInvokedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::AccessKeyInvokedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Input::IAccessKeyInvokedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Input::IProcessKeyboardAcceleratorEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Input::IProcessKeyboardAcceleratorEventArgs> {};
template<> struct def<Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs, Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs2> {};
template<> struct def<Windows::UI::Xaml::Input::ICommand> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IAccessKeyManager> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IAccessKeyManagerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IAccessKeyManagerStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::AccessKeyManager> : class_type<Platform::Object, Windows::UI::Xaml::Input::IAccessKeyManager> {};
template<> struct def<Windows::UI::Xaml::Input::IInertiaExpansionBehavior> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::InertiaExpansionBehavior> : class_type<Platform::Object, Windows::UI::Xaml::Input::IInertiaExpansionBehavior> {};
template<> struct def<Windows::UI::Xaml::Input::IInertiaRotationBehavior> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::InertiaRotationBehavior> : class_type<Platform::Object, Windows::UI::Xaml::Input::IInertiaRotationBehavior> {};
template<> struct def<Windows::UI::Xaml::Input::IInertiaTranslationBehavior> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::InertiaTranslationBehavior> : class_type<Platform::Object, Windows::UI::Xaml::Input::IInertiaTranslationBehavior> {};
template<> struct def<Windows::UI::Xaml::Input::IManipulationPivot> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IManipulationPivotFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::ManipulationPivot> : class_type<Platform::Object, Windows::UI::Xaml::Input::IManipulationPivot>, custom_activators {};
template<> struct def<Windows::UI::Xaml::Input::ICharacterReceivedRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::CharacterReceivedRoutedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::ICharacterReceivedRoutedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Input::IContextRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::ContextRequestedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::IContextRequestedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Input::IDoubleTappedRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::DoubleTappedRoutedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::IDoubleTappedRoutedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Input::IGettingFocusEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IGettingFocusEventArgs2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::GettingFocusEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::IGettingFocusEventArgs, Windows::UI::Xaml::Input::IGettingFocusEventArgs2> {};
template<> struct def<Windows::UI::Xaml::Input::IHoldingRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::HoldingRoutedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::IHoldingRoutedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Input::IInputScope> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::InputScope> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Input::IInputScope> {};
template<> struct def<Windows::UI::Xaml::Input::IInputScopeName> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IInputScopeNameFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::InputScopeName> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Input::IInputScopeName>, custom_activators {};
template<> struct def<Windows::UI::Xaml::Input::IKeyboardAccelerator> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IKeyboardAcceleratorFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IKeyboardAcceleratorStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::KeyboardAccelerator> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Input::IKeyboardAccelerator>, composer_type<Windows::UI::Xaml::Input::IKeyboardAcceleratorFactory> {};
template<> struct def<Windows::UI::Xaml::Input::IKeyRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IKeyRoutedEventArgs2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IKeyRoutedEventArgs3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::KeyRoutedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::IKeyRoutedEventArgs, Windows::UI::Xaml::Input::IKeyRoutedEventArgs2, Windows::UI::Xaml::Input::IKeyRoutedEventArgs3> {};
template<> struct def<Windows::UI::Xaml::Input::ILosingFocusEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::ILosingFocusEventArgs2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::LosingFocusEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::ILosingFocusEventArgs, Windows::UI::Xaml::Input::ILosingFocusEventArgs2> {};
template<> struct def<Windows::UI::Xaml::Input::IManipulationCompletedRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::IManipulationCompletedRoutedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgsFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgs>, composer_type<Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgsFactory> {};
template<> struct def<Windows::UI::Xaml::Input::IManipulationStartingRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::IManipulationStartingRoutedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Input::INoFocusCandidateFoundEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::NoFocusCandidateFoundEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::INoFocusCandidateFoundEventArgs> {};
template<> struct def<Windows::UI::Xaml::Input::IPointerRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IPointerRoutedEventArgs2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::PointerRoutedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::IPointerRoutedEventArgs, Windows::UI::Xaml::Input::IPointerRoutedEventArgs2> {};
template<> struct def<Windows::UI::Xaml::Input::IRightTappedRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::RightTappedRoutedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::IRightTappedRoutedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Input::ITappedRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::TappedRoutedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Input::ITappedRoutedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Input::IFindNextElementOptions> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::FindNextElementOptions> : class_type<Platform::Object, Windows::UI::Xaml::Input::IFindNextElementOptions> {};
template<> struct def<Windows::UI::Xaml::Input::IFocusManager> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IFocusManagerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IFocusManagerStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IFocusManagerStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IFocusManagerStatics4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IFocusManagerStatics5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::IFocusMovementResult> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Input::FocusMovementResult> : class_type<Platform::Object, Windows::UI::Xaml::Input::IFocusMovementResult> {};
template<> struct def<Windows::UI::Xaml::Input::FocusManager> : class_type<Platform::Object, Windows::UI::Xaml::Input::IFocusManager> {};

// uuids

template<> struct uuid<Windows::UI::Xaml::Input::DoubleTappedEventHandler> { define_guid(0x3124D025, 0x4A7, 0x4D45, 0x82, 0x5E, 0x82, 0x4, 0xA6, 0x24, 0xDB, 0xF4);};
template<> struct uuid<Windows::UI::Xaml::Input::HoldingEventHandler> { define_guid(0xECAE8CCD, 0x8E5E, 0x4FBE, 0x98, 0x46, 0x30, 0xA6, 0x37, 0xA, 0xFC, 0xDF);};
template<> struct uuid<Windows::UI::Xaml::Input::KeyEventHandler> { define_guid(0x7C63D2E5, 0x7A0E, 0x4E12, 0xB9, 0x6A, 0x77, 0x15, 0xAA, 0x6F, 0xF1, 0xC8);};
template<> struct uuid<Windows::UI::Xaml::Input::ManipulationCompletedEventHandler> { define_guid(0x38EF4B0F, 0x14F8, 0x42DF, 0x9A, 0x1E, 0xA4, 0xBC, 0xC4, 0xAF, 0x77, 0xF4);};
template<> struct uuid<Windows::UI::Xaml::Input::ManipulationDeltaEventHandler> { define_guid(0xAA1160CB, 0xDFB9, 0x4C56, 0xAB, 0xDC, 0x71, 0x1B, 0x63, 0xC8, 0xEB, 0x94);};
template<> struct uuid<Windows::UI::Xaml::Input::ManipulationInertiaStartingEventHandler> { define_guid(0xD39D6322, 0x7C9C, 0x481B, 0x82, 0x7B, 0xC8, 0xB2, 0xD9, 0xBB, 0x6F, 0xC7);};
template<> struct uuid<Windows::UI::Xaml::Input::ManipulationStartedEventHandler> { define_guid(0xF88345F8, 0xE0A3, 0x4BE2, 0xB9, 0xC, 0xDC, 0x20, 0xE6, 0xD8, 0xBE, 0xB0);};
template<> struct uuid<Windows::UI::Xaml::Input::ManipulationStartingEventHandler> { define_guid(0x10D0B04E, 0xBFE4, 0x42CB, 0x82, 0x3C, 0x3F, 0xEC, 0xD8, 0x77, 0xE, 0xF8);};
template<> struct uuid<Windows::UI::Xaml::Input::PointerEventHandler> { define_guid(0xE4385929, 0xC004, 0x4BCF, 0x89, 0x70, 0x35, 0x94, 0x86, 0xE3, 0x9F, 0x88);};
template<> struct uuid<Windows::UI::Xaml::Input::RightTappedEventHandler> { define_guid(0x2532A062, 0xF447, 0x4950, 0x9C, 0x46, 0xF1, 0xE3, 0x4A, 0x2C, 0x22, 0x38);};
template<> struct uuid<Windows::UI::Xaml::Input::TappedEventHandler> { define_guid(0x68D940CC, 0x9FF0, 0x49CE, 0xB1, 0x41, 0x3F, 0x7, 0xEC, 0x47, 0x7B, 0x97);};
template<> struct uuid<Windows::UI::Xaml::Input::IPointer> { define_guid(0x5EE8F39F, 0x747D, 0x4171, 0x90, 0xE6, 0xCD, 0x37, 0xA9, 0xDF, 0xFB, 0x11);};
template<> struct uuid<Windows::UI::Xaml::Input::IAccessKeyDisplayRequestedEventArgs> { define_guid(0xC079E55, 0x13FE, 0x4D03, 0xA6, 0x1D, 0xE1, 0x2F, 0x6, 0x56, 0x72, 0x86);};
template<> struct uuid<Windows::UI::Xaml::Input::IAccessKeyDisplayDismissedEventArgs> { define_guid(0x8A610DC6, 0xD72D, 0x4CA8, 0x9F, 0x66, 0x55, 0x6F, 0x35, 0xB5, 0x13, 0xDA);};
template<> struct uuid<Windows::UI::Xaml::Input::IAccessKeyInvokedEventArgs> { define_guid(0xCFE9CD97, 0xC718, 0x4091, 0xB7, 0xDD, 0xAD, 0xF1, 0xC0, 0x72, 0xB1, 0xE1);};
template<> struct uuid<Windows::UI::Xaml::Input::IProcessKeyboardAcceleratorEventArgs> { define_guid(0xFB79C216, 0x972B, 0x440C, 0x9B, 0x83, 0x2B, 0x41, 0x98, 0xDC, 0xF0, 0x9D);};
template<> struct uuid<Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs2> { define_guid(0xBEFCA4B8, 0x5907, 0x48EE, 0x8E, 0x21, 0x9C, 0x96, 0x90, 0x78, 0xFA, 0x11);};
template<> struct uuid<Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs> { define_guid(0xC00B03F2, 0x4E7, 0x4415, 0xB1, 0x7D, 0xD7, 0x6B, 0x94, 0x90, 0xDE, 0x2B);};
template<> struct uuid<Windows::UI::Xaml::Input::ICommand> { define_guid(0xE5AF3542, 0xCA67, 0x4081, 0x99, 0x5B, 0x70, 0x9D, 0xD1, 0x37, 0x92, 0xDF);};
template<> struct uuid<Windows::UI::Xaml::Input::IAccessKeyManager> { define_guid(0xECC973B0, 0x2EE9, 0x4B1C, 0x98, 0xD7, 0x6E, 0xE, 0x81, 0x6D, 0x33, 0x4B);};
template<> struct uuid<Windows::UI::Xaml::Input::IAccessKeyManagerStatics> { define_guid(0x4CA0EFE6, 0xD9C8, 0x4EBC, 0xB4, 0xC7, 0x30, 0xD1, 0x83, 0x8A, 0x81, 0xF1);};
template<> struct uuid<Windows::UI::Xaml::Input::IAccessKeyManagerStatics2> { define_guid(0x962BB594, 0x2AB3, 0x47C5, 0x95, 0x4B, 0x70, 0x92, 0xF3, 0x55, 0xF7, 0x97);};
template<> struct uuid<Windows::UI::Xaml::Input::IInertiaExpansionBehavior> { define_guid(0x751D87E5, 0x8D42, 0x44C5, 0x96, 0x5E, 0x3C, 0xD3, 0xC, 0xC9, 0xD6, 0xF7);};
template<> struct uuid<Windows::UI::Xaml::Input::IInertiaRotationBehavior> { define_guid(0x424CFB2E, 0xBBFD, 0x4625, 0xAE, 0x78, 0x20, 0xC6, 0x5B, 0xF1, 0xEF, 0xAF);};
template<> struct uuid<Windows::UI::Xaml::Input::IInertiaTranslationBehavior> { define_guid(0x45D3A512, 0x3B32, 0x4882, 0xA4, 0xC2, 0xEC, 0xFA, 0x2D, 0x4B, 0x6D, 0xF0);};
template<> struct uuid<Windows::UI::Xaml::Input::IManipulationPivot> { define_guid(0x2E3838A5, 0xE6C2, 0x4998, 0x82, 0xAC, 0x18, 0x74, 0x8B, 0x14, 0x16, 0x66);};
template<> struct uuid<Windows::UI::Xaml::Input::IManipulationPivotFactory> { define_guid(0x6D05B039, 0x3702, 0x4396, 0xAD, 0x9B, 0xA8, 0x25, 0xEF, 0xA6, 0x3A, 0x3B);};
template<> struct uuid<Windows::UI::Xaml::Input::ICharacterReceivedRoutedEventArgs> { define_guid(0x7849FD82, 0x48E4, 0x444D, 0x94, 0x19, 0x93, 0xAB, 0x88, 0x92, 0xC1, 0x7);};
template<> struct uuid<Windows::UI::Xaml::Input::IContextRequestedEventArgs> { define_guid(0x42618E0A, 0x1CB6, 0x46FB, 0x83, 0x74, 0xA, 0xEC, 0x68, 0xAA, 0x5E, 0x51);};
template<> struct uuid<Windows::UI::Xaml::Input::IDoubleTappedRoutedEventArgs> { define_guid(0xAF404424, 0x26DF, 0x44F4, 0x87, 0x14, 0x93, 0x59, 0x24, 0x9B, 0x62, 0xD3);};
template<> struct uuid<Windows::UI::Xaml::Input::IGettingFocusEventArgs> { define_guid(0xFA05B9CE, 0xC67C, 0x4BE8, 0x8F, 0xD4, 0xC4, 0x4D, 0x67, 0x87, 0x7E, 0xD);};
template<> struct uuid<Windows::UI::Xaml::Input::IGettingFocusEventArgs2> { define_guid(0x88754D7B, 0xB4B9, 0x4959, 0x8B, 0xCE, 0x89, 0xBF, 0x21, 0x2E, 0xD4, 0xEB);};
template<> struct uuid<Windows::UI::Xaml::Input::IHoldingRoutedEventArgs> { define_guid(0xC246FF23, 0xD80D, 0x44DE, 0x8D, 0xB9, 0xD, 0x81, 0x5E, 0x26, 0x9A, 0xC0);};
template<> struct uuid<Windows::UI::Xaml::Input::IInputScope> { define_guid(0x5C0F85F3, 0xF9D8, 0x4220, 0xB6, 0x66, 0x4, 0x5D, 0x7, 0x4D, 0x9B, 0xFA);};
template<> struct uuid<Windows::UI::Xaml::Input::IInputScopeName> { define_guid(0xFD3E6997, 0x8FB, 0x4CBA, 0xA0, 0x21, 0x79, 0x2D, 0x75, 0x89, 0xFD, 0x5A);};
template<> struct uuid<Windows::UI::Xaml::Input::IInputScopeNameFactory> { define_guid(0x4A40BB52, 0x4BD7, 0x4E54, 0x86, 0x17, 0x1C, 0xDA, 0x8A, 0x1E, 0xDA, 0x7F);};
template<> struct uuid<Windows::UI::Xaml::Input::IKeyboardAccelerator> { define_guid(0x92E6181E, 0x19AE, 0x465A, 0x9B, 0x3C, 0xA7, 0x1E, 0xE9, 0xEA, 0x74, 0x20);};
template<> struct uuid<Windows::UI::Xaml::Input::IKeyboardAcceleratorFactory> { define_guid(0x44D88A99, 0x4BFD, 0x4A47, 0xA8, 0x93, 0x51, 0x5F, 0x38, 0x86, 0x23, 0xF6);};
template<> struct uuid<Windows::UI::Xaml::Input::IKeyboardAcceleratorStatics> { define_guid(0x3BD43D51, 0x9BB3, 0x456D, 0xBF, 0x15, 0x80, 0x4A, 0xDF, 0xB8, 0x62, 0x61);};
template<> struct uuid<Windows::UI::Xaml::Input::IKeyRoutedEventArgs> { define_guid(0xD4CD3DFE, 0x4079, 0x42E9, 0xA3, 0x9A, 0x30, 0x95, 0xD3, 0xF0, 0x49, 0xC6);};
template<> struct uuid<Windows::UI::Xaml::Input::IKeyRoutedEventArgs2> { define_guid(0x1B02D57A, 0x9634, 0x4F14, 0x91, 0xB2, 0x13, 0x3E, 0x42, 0xFD, 0xB3, 0xCD);};
template<> struct uuid<Windows::UI::Xaml::Input::IKeyRoutedEventArgs3> { define_guid(0x2779F5B4, 0xCA41, 0x411B, 0xA8, 0xEF, 0xF4, 0xFC, 0x78, 0xE7, 0x80, 0x57);};
template<> struct uuid<Windows::UI::Xaml::Input::ILosingFocusEventArgs> { define_guid(0xF9F683C7, 0xD789, 0x472B, 0xAA, 0x93, 0x6D, 0x41, 0x5, 0xE6, 0xDA, 0xBE);};
template<> struct uuid<Windows::UI::Xaml::Input::ILosingFocusEventArgs2> { define_guid(0x493FAD9, 0xC27F, 0x469F, 0x8E, 0x62, 0x52, 0xB3, 0xA4, 0xF7, 0xCD, 0x54);};
template<> struct uuid<Windows::UI::Xaml::Input::IManipulationCompletedRoutedEventArgs> { define_guid(0xB5AD9B23, 0x2F41, 0x498E, 0x83, 0x19, 0x1, 0x5E, 0xE8, 0xA7, 0x53, 0x46);};
template<> struct uuid<Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs> { define_guid(0x400D5794, 0x4C6F, 0x491D, 0x82, 0xD6, 0x35, 0x17, 0x10, 0x93, 0x99, 0xC6);};
template<> struct uuid<Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs> { define_guid(0x246A91A9, 0xCA43, 0x4C0B, 0xAC, 0xEF, 0x81, 0xE8, 0xB8, 0x14, 0x75, 0x20);};
template<> struct uuid<Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgs> { define_guid(0x5DB1AA05, 0x9F80, 0x48B6, 0xAE, 0x6C, 0x4F, 0x11, 0x9D, 0xE8, 0xFF, 0x13);};
template<> struct uuid<Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgsFactory> { define_guid(0x84C1DAA7, 0x7272, 0x4463, 0xB6, 0xC3, 0xA4, 0xB, 0x9B, 0xA1, 0x51, 0xFC);};
template<> struct uuid<Windows::UI::Xaml::Input::IManipulationStartingRoutedEventArgs> { define_guid(0x18D636B7, 0x53A4, 0x4C15, 0xA4, 0x98, 0xF3, 0xA9, 0xCA, 0x21, 0x2A, 0x42);};
template<> struct uuid<Windows::UI::Xaml::Input::INoFocusCandidateFoundEventArgs> { define_guid(0xEC3601A7, 0x1007, 0x48F9, 0xB6, 0xB3, 0xED, 0xB, 0xEA, 0x53, 0x93, 0x7D);};
template<> struct uuid<Windows::UI::Xaml::Input::IPointerRoutedEventArgs> { define_guid(0xDA628F0A, 0x9752, 0x49E2, 0xBD, 0xE2, 0x49, 0xEC, 0xCA, 0xB9, 0x19, 0x4D);};
template<> struct uuid<Windows::UI::Xaml::Input::IPointerRoutedEventArgs2> { define_guid(0x821F294, 0x1DE6, 0x4711, 0xBA, 0x7C, 0x8D, 0x4B, 0x8B, 0x9, 0x11, 0xD0);};
template<> struct uuid<Windows::UI::Xaml::Input::IRightTappedRoutedEventArgs> { define_guid(0x6834869D, 0x7BD5, 0x4033, 0xB2, 0x37, 0x17, 0x2F, 0x79, 0xAB, 0xE3, 0x93);};
template<> struct uuid<Windows::UI::Xaml::Input::ITappedRoutedEventArgs> { define_guid(0xA099E6BE, 0xE624, 0x459A, 0xBB, 0x1D, 0xE0, 0x5C, 0x73, 0xE2, 0xCC, 0x66);};
template<> struct uuid<Windows::UI::Xaml::Input::IFindNextElementOptions> { define_guid(0xD88AE22B, 0x46C2, 0x41FC, 0x89, 0x7E, 0xB5, 0x96, 0x19, 0x77, 0xB8, 0x9D);};
template<> struct uuid<Windows::UI::Xaml::Input::IFocusManager> { define_guid(0xC843F50B, 0x3B83, 0x4DA1, 0x9D, 0x6F, 0x55, 0x7C, 0x11, 0x69, 0xF3, 0x41);};
template<> struct uuid<Windows::UI::Xaml::Input::IFocusManagerStatics> { define_guid(0x1ECCD326, 0x8182, 0x4482, 0x82, 0x6A, 0x9, 0x18, 0xE9, 0xED, 0x9A, 0xF7);};
template<> struct uuid<Windows::UI::Xaml::Input::IFocusManagerStatics2> { define_guid(0xA920D761, 0xDD87, 0x4F31, 0xBE, 0xDA, 0xEF, 0x41, 0x7F, 0xE7, 0xC0, 0x4A);};
template<> struct uuid<Windows::UI::Xaml::Input::IFocusManagerStatics3> { define_guid(0x60805EBF, 0xB149, 0x417D, 0x83, 0xF1, 0xBA, 0xEB, 0x56, 0xE, 0x2A, 0x47);};
template<> struct uuid<Windows::UI::Xaml::Input::IFocusManagerStatics4> { define_guid(0x29276E9C, 0x1C6C, 0x414A, 0xBA, 0x1C, 0x96, 0xEF, 0xD5, 0x96, 0x2B, 0xCD);};
template<> struct uuid<Windows::UI::Xaml::Input::IFocusManagerStatics5> { define_guid(0x280EDC61, 0x207A, 0x4D7B, 0xB9, 0x8F, 0xCE, 0x16, 0x5E, 0x1B, 0x20, 0x15);};
template<> struct uuid<Windows::UI::Xaml::Input::IFocusMovementResult> { define_guid(0x6DFEAD3, 0xC2AE, 0x44BB, 0xBF, 0xAB, 0x9C, 0x73, 0xDE, 0x84, 0x7, 0xA4);};

// types

namespace Windows { namespace UI { namespace Xaml { namespace Input {

// DoubleTappedEventHandler
struct DoubleTappedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, DoubleTappedRoutedEventArgs* e) = 0;
};

// HoldingEventHandler
struct HoldingEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, HoldingRoutedEventArgs* e) = 0;
};

// KeyEventHandler
struct KeyEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, KeyRoutedEventArgs* e) = 0;
};

// ManipulationCompletedEventHandler
struct ManipulationCompletedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, ManipulationCompletedRoutedEventArgs* e) = 0;
};

// ManipulationDeltaEventHandler
struct ManipulationDeltaEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, ManipulationDeltaRoutedEventArgs* e) = 0;
};

// ManipulationInertiaStartingEventHandler
struct ManipulationInertiaStartingEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, ManipulationInertiaStartingRoutedEventArgs* e) = 0;
};

// ManipulationStartedEventHandler
struct ManipulationStartedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, ManipulationStartedRoutedEventArgs* e) = 0;
};

// ManipulationStartingEventHandler
struct ManipulationStartingEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, ManipulationStartingRoutedEventArgs* e) = 0;
};

// PointerEventHandler
struct PointerEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, PointerRoutedEventArgs* e) = 0;
};

// RightTappedEventHandler
struct RightTappedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, RightTappedRoutedEventArgs* e) = 0;
};

// TappedEventHandler
struct TappedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, TappedRoutedEventArgs* e) = 0;
};

// IPointer
struct IPointer_raw : IInspectable {
	virtual STDMETHODIMP _get_PointerId(unsigned *value);
	virtual STDMETHODIMP _get_PointerDeviceType(Devices::Input::PointerDeviceType *value);
	virtual STDMETHODIMP _get_IsInContact(bool *value);
	virtual STDMETHODIMP _get_IsInRange(bool *value);
};
template<typename X> struct IPointer_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPointer_adaptor::IsInContact)->_get_IsInContact(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsInContact;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPointer_adaptor::IsInRange)->_get_IsInRange(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsInRange;
		struct : property {
			Devices::Input::PointerDeviceType get() { Devices::Input::PointerDeviceType value; hrcheck(enc(&IPointer_adaptor::PointerDeviceType)->_get_PointerDeviceType(&value)); return value; }
			Devices::Input::PointerDeviceType operator()() { return get(); }
			operator Devices::Input::PointerDeviceType () { return get(); }
		} PointerDeviceType;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IPointer_adaptor::PointerId)->_get_PointerId(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} PointerId;
	};
	IPointer_adaptor() {}
};
template<typename X> struct adapt<IPointer, X> : Windows::UI::Xaml::Input::IPointer_adaptor<X> { typedef adapt IPointer; };
struct IPointer : IPointer_raw, generate<IPointer> {};

// Pointer
template<typename X> struct statics<Pointer, X> : X {
	typedef typename X::root_type Pointer;
};
struct Pointer : generate<Pointer> {};

// IAccessKeyDisplayRequestedEventArgs
struct IAccessKeyDisplayRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_PressedKeys(HSTRING *value);
};
template<typename X> struct IAccessKeyDisplayRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAccessKeyDisplayRequestedEventArgs_adaptor::PressedKeys)->_get_PressedKeys(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PressedKeys;
	};
	IAccessKeyDisplayRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IAccessKeyDisplayRequestedEventArgs, X> : Windows::UI::Xaml::Input::IAccessKeyDisplayRequestedEventArgs_adaptor<X> { typedef adapt IAccessKeyDisplayRequestedEventArgs; };
struct IAccessKeyDisplayRequestedEventArgs : IAccessKeyDisplayRequestedEventArgs_raw, generate<IAccessKeyDisplayRequestedEventArgs> {};

// AccessKeyDisplayRequestedEventArgs
template<typename X> struct statics<AccessKeyDisplayRequestedEventArgs, X> : X {
	typedef typename X::root_type AccessKeyDisplayRequestedEventArgs;
};
struct AccessKeyDisplayRequestedEventArgs : generate<AccessKeyDisplayRequestedEventArgs> {};

// IAccessKeyDisplayDismissedEventArgs
struct IAccessKeyDisplayDismissedEventArgs : IInspectable, generate<IAccessKeyDisplayDismissedEventArgs> {};

// AccessKeyDisplayDismissedEventArgs
template<typename X> struct statics<AccessKeyDisplayDismissedEventArgs, X> : X {
	typedef typename X::root_type AccessKeyDisplayDismissedEventArgs;
};
struct AccessKeyDisplayDismissedEventArgs : generate<AccessKeyDisplayDismissedEventArgs> {};

// IAccessKeyInvokedEventArgs
struct IAccessKeyInvokedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
};
template<typename X> struct IAccessKeyInvokedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAccessKeyInvokedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IAccessKeyInvokedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
	};
	IAccessKeyInvokedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IAccessKeyInvokedEventArgs, X> : Windows::UI::Xaml::Input::IAccessKeyInvokedEventArgs_adaptor<X> { typedef adapt IAccessKeyInvokedEventArgs; };
struct IAccessKeyInvokedEventArgs : IAccessKeyInvokedEventArgs_raw, generate<IAccessKeyInvokedEventArgs> {};

// AccessKeyInvokedEventArgs
template<typename X> struct statics<AccessKeyInvokedEventArgs, X> : X {
	typedef typename X::root_type AccessKeyInvokedEventArgs;
};
struct AccessKeyInvokedEventArgs : generate<AccessKeyInvokedEventArgs> {};

// IProcessKeyboardAcceleratorEventArgs
struct IProcessKeyboardAcceleratorEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Key(System::VirtualKey *value);
	virtual STDMETHODIMP _get_Modifiers(System::VirtualKeyModifiers *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
};
template<typename X> struct IProcessKeyboardAcceleratorEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IProcessKeyboardAcceleratorEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IProcessKeyboardAcceleratorEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			System::VirtualKey get() { System::VirtualKey value; hrcheck(enc(&IProcessKeyboardAcceleratorEventArgs_adaptor::Key)->_get_Key(&value)); return value; }
			System::VirtualKey operator()() { return get(); }
			operator System::VirtualKey () { return get(); }
		} Key;
		struct : property {
			System::VirtualKeyModifiers get() { System::VirtualKeyModifiers value; hrcheck(enc(&IProcessKeyboardAcceleratorEventArgs_adaptor::Modifiers)->_get_Modifiers(&value)); return value; }
			System::VirtualKeyModifiers operator()() { return get(); }
			operator System::VirtualKeyModifiers () { return get(); }
		} Modifiers;
	};
	IProcessKeyboardAcceleratorEventArgs_adaptor() {}
};
template<typename X> struct adapt<IProcessKeyboardAcceleratorEventArgs, X> : Windows::UI::Xaml::Input::IProcessKeyboardAcceleratorEventArgs_adaptor<X> { typedef adapt IProcessKeyboardAcceleratorEventArgs; };
struct IProcessKeyboardAcceleratorEventArgs : IProcessKeyboardAcceleratorEventArgs_raw, generate<IProcessKeyboardAcceleratorEventArgs> {};

// ProcessKeyboardAcceleratorEventArgs
template<typename X> struct statics<ProcessKeyboardAcceleratorEventArgs, X> : X {
	typedef typename X::root_type ProcessKeyboardAcceleratorEventArgs;
};
struct ProcessKeyboardAcceleratorEventArgs : generate<ProcessKeyboardAcceleratorEventArgs> {};

// IKeyboardAcceleratorInvokedEventArgs2
struct IKeyboardAcceleratorInvokedEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyboardAccelerator(Input::KeyboardAccelerator* *value);
};
template<typename X> struct IKeyboardAcceleratorInvokedEventArgs2_adaptor : X {
	union {
		struct : property {
			ptr<Input::KeyboardAccelerator> get() { Input::KeyboardAccelerator* value; hrcheck(enc(&IKeyboardAcceleratorInvokedEventArgs2_adaptor::KeyboardAccelerator)->_get_KeyboardAccelerator(&value)); return from_abi(value); }
			ptr<Input::KeyboardAccelerator> operator()() { return get(); }
			operator ptr<Input::KeyboardAccelerator> () { return get(); }
			ptr<Input::KeyboardAccelerator> operator->() { return get(); }
		} KeyboardAccelerator;
	};
	IKeyboardAcceleratorInvokedEventArgs2_adaptor() {}
};
template<typename X> struct adapt<IKeyboardAcceleratorInvokedEventArgs2, X> : Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs2_adaptor<X> { typedef adapt IKeyboardAcceleratorInvokedEventArgs2; };
struct IKeyboardAcceleratorInvokedEventArgs2 : IKeyboardAcceleratorInvokedEventArgs2_raw, generate<IKeyboardAcceleratorInvokedEventArgs2> {};

// IKeyboardAcceleratorInvokedEventArgs
struct IKeyboardAcceleratorInvokedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _get_Element(DependencyObject* *value);
};
template<typename X> struct IKeyboardAcceleratorInvokedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IKeyboardAcceleratorInvokedEventArgs_adaptor::Element)->_get_Element(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
		} Element;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IKeyboardAcceleratorInvokedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IKeyboardAcceleratorInvokedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
	};
	IKeyboardAcceleratorInvokedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IKeyboardAcceleratorInvokedEventArgs, X> : Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs_adaptor<X> { typedef adapt IKeyboardAcceleratorInvokedEventArgs; };
struct IKeyboardAcceleratorInvokedEventArgs : IKeyboardAcceleratorInvokedEventArgs_raw, generate<IKeyboardAcceleratorInvokedEventArgs> {};

// KeyboardAcceleratorInvokedEventArgs
template<typename X> struct statics<KeyboardAcceleratorInvokedEventArgs, X> : X {
	typedef typename X::root_type KeyboardAcceleratorInvokedEventArgs;
};
struct KeyboardAcceleratorInvokedEventArgs : generate<KeyboardAcceleratorInvokedEventArgs> {};

// ICommand
struct ICommand_raw : IInspectable {
	virtual STDMETHODIMP _add_CanExecuteChanged(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token) = 0;
	virtual STDMETHODIMP _remove_CanExecuteChanged(Foundation::EventRegistrationToken token) = 0;
	virtual STDMETHODIMP _CanExecute(IInspectable* parameter, bool *returnValue) = 0;
	virtual STDMETHODIMP _Execute(IInspectable* parameter) = 0;
};
template<typename X> struct ICommand_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICommand_adaptor::CanExecuteChanged)->_add_CanExecuteChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICommand_adaptor::CanExecuteChanged)->_remove_CanExecuteChanged(token)); }
		} CanExecuteChanged;
	};
	bool CanExecute(object_ref parameter) { bool returnValue; hrcheck(X::get()->_CanExecute(parameter, &returnValue)); return returnValue; }
	void Execute(object_ref parameter) { hrcheck(X::get()->_Execute(parameter)); }
	ICommand_adaptor() {}
};
template<typename X> struct adapt<ICommand, X> : Windows::UI::Xaml::Input::ICommand_adaptor<X> { typedef adapt ICommand; };
template<typename X> struct ICommand_unadaptor : X {
	STDMETHODIMP _add_CanExecuteChanged(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token) { return hrtry([&, this] { *token = X::get()->CanExecuteChanged+=value; }); }
	STDMETHODIMP _remove_CanExecuteChanged(Foundation::EventRegistrationToken token) { return hrtry([&, this] { X::get()->CanExecuteChanged-=token; }); }
	STDMETHODIMP _CanExecute(IInspectable* parameter, bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->CanExecute(parameter); }); }
	STDMETHODIMP _Execute(IInspectable* parameter) { return hrtry([&, this] { X::get()->Execute(parameter); }); }
};
template<typename X> struct unadapt<ICommand, X> : Windows::UI::Xaml::Input::ICommand_unadaptor<X> {};
struct ICommand : ICommand_raw, generate<ICommand> {};

// IAccessKeyManager
struct IAccessKeyManager : IInspectable, generate<IAccessKeyManager> {};

// IAccessKeyManagerStatics
struct IAccessKeyManagerStatics : IInspectable {
	virtual STDMETHODIMP _get_IsDisplayModeEnabled(bool *value);
	virtual STDMETHODIMP _add_IsDisplayModeEnabledChanged(Foundation::TypedEventHandler<IInspectable*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_IsDisplayModeEnabledChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _ExitDisplayMode();
};

// IAccessKeyManagerStatics2
struct IAccessKeyManagerStatics2 : IInspectable {
	virtual STDMETHODIMP _get_AreKeyTipsEnabled(bool *value);
	virtual STDMETHODIMP _put_AreKeyTipsEnabled(bool value);
};

// AccessKeyManager
template<typename> struct AccessKeyManager_statics {
	static struct _IsDisplayModeEnabled : property {
		bool get() { bool value; hrcheck(get_activation_factory<AccessKeyManager, IAccessKeyManagerStatics>()->_get_IsDisplayModeEnabled(&value)); return value; }
		bool operator()() { return get(); }
		operator bool () { return get(); }
	} IsDisplayModeEnabled;
	static struct _IsDisplayModeEnabledChanged : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<object, object>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<AccessKeyManager, IAccessKeyManagerStatics>()->_add_IsDisplayModeEnabledChanged(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<AccessKeyManager, IAccessKeyManagerStatics>()->_remove_IsDisplayModeEnabledChanged(token)); }
	} IsDisplayModeEnabledChanged;
	static struct _AreKeyTipsEnabled : property {
		bool get() { bool value; hrcheck(get_activation_factory<AccessKeyManager, IAccessKeyManagerStatics2>()->_get_AreKeyTipsEnabled(&value)); return value; }
		bool operator()() { return get(); }
		operator bool () { return get(); }
		void put(bool value) { hrcheck(get_activation_factory<AccessKeyManager, IAccessKeyManagerStatics2>()->_put_AreKeyTipsEnabled(value)); }
		void operator=(bool value) { put(value); }
		void operator()(bool value) { put(value); }
	} AreKeyTipsEnabled;
	static void ExitDisplayMode() { hrcheck(get_activation_factory<AccessKeyManager, IAccessKeyManagerStatics>()->_ExitDisplayMode()); }
};
template<typename X> typename AccessKeyManager_statics<X>::_IsDisplayModeEnabled AccessKeyManager_statics<X>::IsDisplayModeEnabled;
template<typename X> typename AccessKeyManager_statics<X>::_IsDisplayModeEnabledChanged AccessKeyManager_statics<X>::IsDisplayModeEnabledChanged;
template<typename X> typename AccessKeyManager_statics<X>::_AreKeyTipsEnabled AccessKeyManager_statics<X>::AreKeyTipsEnabled;

template<typename X> struct statics<AccessKeyManager, X> : X, Windows::UI::Xaml::Input::AccessKeyManager_statics<void> {
	typedef typename X::root_type AccessKeyManager;
};
struct AccessKeyManager : generate<AccessKeyManager> {};

// IInertiaExpansionBehavior
struct IInertiaExpansionBehavior_raw : IInspectable {
	virtual STDMETHODIMP _get_DesiredDeceleration(double *value);
	virtual STDMETHODIMP _put_DesiredDeceleration(double value);
	virtual STDMETHODIMP _get_DesiredExpansion(double *value);
	virtual STDMETHODIMP _put_DesiredExpansion(double value);
};
template<typename X> struct IInertiaExpansionBehavior_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IInertiaExpansionBehavior_adaptor::DesiredDeceleration)->_get_DesiredDeceleration(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IInertiaExpansionBehavior_adaptor::DesiredDeceleration)->_put_DesiredDeceleration(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DesiredDeceleration;
		struct : property {
			double get() { double value; hrcheck(enc(&IInertiaExpansionBehavior_adaptor::DesiredExpansion)->_get_DesiredExpansion(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IInertiaExpansionBehavior_adaptor::DesiredExpansion)->_put_DesiredExpansion(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DesiredExpansion;
	};
	IInertiaExpansionBehavior_adaptor() {}
};
template<typename X> struct adapt<IInertiaExpansionBehavior, X> : Windows::UI::Xaml::Input::IInertiaExpansionBehavior_adaptor<X> { typedef adapt IInertiaExpansionBehavior; };
struct IInertiaExpansionBehavior : IInertiaExpansionBehavior_raw, generate<IInertiaExpansionBehavior> {};

// InertiaExpansionBehavior
template<typename X> struct statics<InertiaExpansionBehavior, X> : X {
	typedef typename X::root_type InertiaExpansionBehavior;
};
struct InertiaExpansionBehavior : generate<InertiaExpansionBehavior> {};

// IInertiaRotationBehavior
struct IInertiaRotationBehavior_raw : IInspectable {
	virtual STDMETHODIMP _get_DesiredDeceleration(double *value);
	virtual STDMETHODIMP _put_DesiredDeceleration(double value);
	virtual STDMETHODIMP _get_DesiredRotation(double *value);
	virtual STDMETHODIMP _put_DesiredRotation(double value);
};
template<typename X> struct IInertiaRotationBehavior_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IInertiaRotationBehavior_adaptor::DesiredDeceleration)->_get_DesiredDeceleration(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IInertiaRotationBehavior_adaptor::DesiredDeceleration)->_put_DesiredDeceleration(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DesiredDeceleration;
		struct : property {
			double get() { double value; hrcheck(enc(&IInertiaRotationBehavior_adaptor::DesiredRotation)->_get_DesiredRotation(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IInertiaRotationBehavior_adaptor::DesiredRotation)->_put_DesiredRotation(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DesiredRotation;
	};
	IInertiaRotationBehavior_adaptor() {}
};
template<typename X> struct adapt<IInertiaRotationBehavior, X> : Windows::UI::Xaml::Input::IInertiaRotationBehavior_adaptor<X> { typedef adapt IInertiaRotationBehavior; };
struct IInertiaRotationBehavior : IInertiaRotationBehavior_raw, generate<IInertiaRotationBehavior> {};

// InertiaRotationBehavior
template<typename X> struct statics<InertiaRotationBehavior, X> : X {
	typedef typename X::root_type InertiaRotationBehavior;
};
struct InertiaRotationBehavior : generate<InertiaRotationBehavior> {};

// IInertiaTranslationBehavior
struct IInertiaTranslationBehavior_raw : IInspectable {
	virtual STDMETHODIMP _get_DesiredDeceleration(double *value);
	virtual STDMETHODIMP _put_DesiredDeceleration(double value);
	virtual STDMETHODIMP _get_DesiredDisplacement(double *value);
	virtual STDMETHODIMP _put_DesiredDisplacement(double value);
};
template<typename X> struct IInertiaTranslationBehavior_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IInertiaTranslationBehavior_adaptor::DesiredDeceleration)->_get_DesiredDeceleration(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IInertiaTranslationBehavior_adaptor::DesiredDeceleration)->_put_DesiredDeceleration(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DesiredDeceleration;
		struct : property {
			double get() { double value; hrcheck(enc(&IInertiaTranslationBehavior_adaptor::DesiredDisplacement)->_get_DesiredDisplacement(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IInertiaTranslationBehavior_adaptor::DesiredDisplacement)->_put_DesiredDisplacement(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DesiredDisplacement;
	};
	IInertiaTranslationBehavior_adaptor() {}
};
template<typename X> struct adapt<IInertiaTranslationBehavior, X> : Windows::UI::Xaml::Input::IInertiaTranslationBehavior_adaptor<X> { typedef adapt IInertiaTranslationBehavior; };
struct IInertiaTranslationBehavior : IInertiaTranslationBehavior_raw, generate<IInertiaTranslationBehavior> {};

// InertiaTranslationBehavior
template<typename X> struct statics<InertiaTranslationBehavior, X> : X {
	typedef typename X::root_type InertiaTranslationBehavior;
};
struct InertiaTranslationBehavior : generate<InertiaTranslationBehavior> {};

// IManipulationPivot
struct IManipulationPivot_raw : IInspectable {
	virtual STDMETHODIMP _get_Center(Foundation::Point *value);
	virtual STDMETHODIMP _put_Center(Foundation::Point value);
	virtual STDMETHODIMP _get_Radius(double *value);
	virtual STDMETHODIMP _put_Radius(double value);
};
template<typename X> struct IManipulationPivot_adaptor : X {
	union {
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IManipulationPivot_adaptor::Center)->_get_Center(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&IManipulationPivot_adaptor::Center)->_put_Center(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} Center;
		struct : property {
			double get() { double value; hrcheck(enc(&IManipulationPivot_adaptor::Radius)->_get_Radius(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IManipulationPivot_adaptor::Radius)->_put_Radius(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Radius;
	};
	IManipulationPivot_adaptor() {}
};
template<typename X> struct adapt<IManipulationPivot, X> : Windows::UI::Xaml::Input::IManipulationPivot_adaptor<X> { typedef adapt IManipulationPivot; };
struct IManipulationPivot : IManipulationPivot_raw, generate<IManipulationPivot> {};

// IManipulationPivotFactory
struct IManipulationPivotFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithCenterAndRadius(Foundation::Point center, double radius, ManipulationPivot* *instance);
};

// ManipulationPivot
template<typename> struct ManipulationPivot_statics {
	static ManipulationPivot *activate(const Foundation::Point& center, double radius) { ManipulationPivot *instance; hrcheck(get_activation_factory<ManipulationPivot, IManipulationPivotFactory>()->_CreateInstanceWithCenterAndRadius(center, radius, &instance)); return instance; }
	static ManipulationPivot *activate() { ManipulationPivot *t; get_activation_factory<ManipulationPivot>()->ActivateInstance((IInspectable**)&t); return t; }
};

template<typename X> struct statics<ManipulationPivot, X> : X, Windows::UI::Xaml::Input::ManipulationPivot_statics<void> {
	using Windows::UI::Xaml::Input::ManipulationPivot_statics<void>::activate;
	typedef typename X::root_type ManipulationPivot;
};
struct ManipulationPivot : generate<ManipulationPivot> {};

// ICharacterReceivedRoutedEventArgs
struct ICharacterReceivedRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Character(char *value);
	virtual STDMETHODIMP _get_KeyStatus(Core::CorePhysicalKeyStatus *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
};
template<typename X> struct ICharacterReceivedRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			char get() { char value; hrcheck(enc(&ICharacterReceivedRoutedEventArgs_adaptor::Character)->_get_Character(&value)); return value; }
			char operator()() { return get(); }
			operator char () { return get(); }
		} Character;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICharacterReceivedRoutedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICharacterReceivedRoutedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			Core::CorePhysicalKeyStatus get() { Core::CorePhysicalKeyStatus value; hrcheck(enc(&ICharacterReceivedRoutedEventArgs_adaptor::KeyStatus)->_get_KeyStatus(&value)); return value; }
			Core::CorePhysicalKeyStatus operator()() { return get(); }
			operator Core::CorePhysicalKeyStatus () { return get(); }
		} KeyStatus;
	};
	ICharacterReceivedRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ICharacterReceivedRoutedEventArgs, X> : Windows::UI::Xaml::Input::ICharacterReceivedRoutedEventArgs_adaptor<X> { typedef adapt ICharacterReceivedRoutedEventArgs; };
struct ICharacterReceivedRoutedEventArgs : ICharacterReceivedRoutedEventArgs_raw, generate<ICharacterReceivedRoutedEventArgs> {};

// CharacterReceivedRoutedEventArgs
template<typename X> struct statics<CharacterReceivedRoutedEventArgs, X> : X {
	typedef typename X::root_type CharacterReceivedRoutedEventArgs;
};
struct CharacterReceivedRoutedEventArgs : generate<CharacterReceivedRoutedEventArgs> {};

// IContextRequestedEventArgs
struct IContextRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _TryGetPosition(UIElement* relativeTo, Foundation::Point *point, bool *returnValue);
};
template<typename X> struct IContextRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IContextRequestedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IContextRequestedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
	};
	bool TryGetPosition(pptr<UIElement> relativeTo, Foundation::Point *point) { bool returnValue; hrcheck(X::get()->_TryGetPosition(relativeTo, point, &returnValue)); return returnValue; }
	IContextRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IContextRequestedEventArgs, X> : Windows::UI::Xaml::Input::IContextRequestedEventArgs_adaptor<X> { typedef adapt IContextRequestedEventArgs; };
struct IContextRequestedEventArgs : IContextRequestedEventArgs_raw, generate<IContextRequestedEventArgs> {};

// ContextRequestedEventArgs
template<typename X> struct statics<ContextRequestedEventArgs, X> : X {
	typedef typename X::root_type ContextRequestedEventArgs;
};
struct ContextRequestedEventArgs : generate<ContextRequestedEventArgs> {};

// IDoubleTappedRoutedEventArgs
struct IDoubleTappedRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_PointerDeviceType(Devices::Input::PointerDeviceType *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _GetPosition(UIElement* relativeTo, Foundation::Point *returnValue);
};
template<typename X> struct IDoubleTappedRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDoubleTappedRoutedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDoubleTappedRoutedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			Devices::Input::PointerDeviceType get() { Devices::Input::PointerDeviceType value; hrcheck(enc(&IDoubleTappedRoutedEventArgs_adaptor::PointerDeviceType)->_get_PointerDeviceType(&value)); return value; }
			Devices::Input::PointerDeviceType operator()() { return get(); }
			operator Devices::Input::PointerDeviceType () { return get(); }
		} PointerDeviceType;
	};
	Foundation::Point GetPosition(pptr<UIElement> relativeTo) { Foundation::Point returnValue; hrcheck(X::get()->_GetPosition(relativeTo, &returnValue)); return returnValue; }
	IDoubleTappedRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDoubleTappedRoutedEventArgs, X> : Windows::UI::Xaml::Input::IDoubleTappedRoutedEventArgs_adaptor<X> { typedef adapt IDoubleTappedRoutedEventArgs; };
struct IDoubleTappedRoutedEventArgs : IDoubleTappedRoutedEventArgs_raw, generate<IDoubleTappedRoutedEventArgs> {};

// DoubleTappedRoutedEventArgs
template<typename X> struct statics<DoubleTappedRoutedEventArgs, X> : X {
	typedef typename X::root_type DoubleTappedRoutedEventArgs;
};
struct DoubleTappedRoutedEventArgs : generate<DoubleTappedRoutedEventArgs> {};

// IGettingFocusEventArgs
struct IGettingFocusEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_OldFocusedElement(DependencyObject* *value);
	virtual STDMETHODIMP _get_NewFocusedElement(DependencyObject* *value);
	virtual STDMETHODIMP _put_NewFocusedElement(DependencyObject* value);
	virtual STDMETHODIMP _get_FocusState(Xaml::FocusState *value);
	virtual STDMETHODIMP _get_Direction(FocusNavigationDirection *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _get_InputDevice(FocusInputDeviceKind *value);
	virtual STDMETHODIMP _get_Cancel(bool *value);
	virtual STDMETHODIMP _put_Cancel(bool value);
};
template<typename X> struct IGettingFocusEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGettingFocusEventArgs_adaptor::Cancel)->_get_Cancel(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IGettingFocusEventArgs_adaptor::Cancel)->_put_Cancel(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Cancel;
		struct : property {
			FocusNavigationDirection get() { FocusNavigationDirection value; hrcheck(enc(&IGettingFocusEventArgs_adaptor::Direction)->_get_Direction(&value)); return value; }
			FocusNavigationDirection operator()() { return get(); }
			operator FocusNavigationDirection () { return get(); }
		} Direction;
		struct : property {
			Xaml::FocusState get() { Xaml::FocusState value; hrcheck(enc(&IGettingFocusEventArgs_adaptor::FocusState)->_get_FocusState(&value)); return value; }
			Xaml::FocusState operator()() { return get(); }
			operator Xaml::FocusState () { return get(); }
		} FocusState;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGettingFocusEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IGettingFocusEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			FocusInputDeviceKind get() { FocusInputDeviceKind value; hrcheck(enc(&IGettingFocusEventArgs_adaptor::InputDevice)->_get_InputDevice(&value)); return value; }
			FocusInputDeviceKind operator()() { return get(); }
			operator FocusInputDeviceKind () { return get(); }
		} InputDevice;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IGettingFocusEventArgs_adaptor::NewFocusedElement)->_get_NewFocusedElement(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IGettingFocusEventArgs_adaptor::NewFocusedElement)->_put_NewFocusedElement(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} NewFocusedElement;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IGettingFocusEventArgs_adaptor::OldFocusedElement)->_get_OldFocusedElement(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
		} OldFocusedElement;
	};
	IGettingFocusEventArgs_adaptor() {}
};
template<typename X> struct adapt<IGettingFocusEventArgs, X> : Windows::UI::Xaml::Input::IGettingFocusEventArgs_adaptor<X> { typedef adapt IGettingFocusEventArgs; };
struct IGettingFocusEventArgs : IGettingFocusEventArgs_raw, generate<IGettingFocusEventArgs> {};

// IGettingFocusEventArgs2
struct IGettingFocusEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _TryCancel(bool *returnValue);
	virtual STDMETHODIMP _TrySetNewFocusedElement(DependencyObject* element, bool *returnValue);
};
template<typename X> struct IGettingFocusEventArgs2_adaptor : X {
	bool TryCancel() { bool returnValue; hrcheck(X::get()->_TryCancel(&returnValue)); return returnValue; }
	bool TrySetNewFocusedElement(pptr<DependencyObject> element) { bool returnValue; hrcheck(X::get()->_TrySetNewFocusedElement(element, &returnValue)); return returnValue; }
};
template<typename X> struct adapt<IGettingFocusEventArgs2, X> : Windows::UI::Xaml::Input::IGettingFocusEventArgs2_adaptor<X> { typedef adapt IGettingFocusEventArgs2; };
struct IGettingFocusEventArgs2 : IGettingFocusEventArgs2_raw, generate<IGettingFocusEventArgs2> {};

// GettingFocusEventArgs
template<typename X> struct statics<GettingFocusEventArgs, X> : X {
	typedef typename X::root_type GettingFocusEventArgs;
};
struct GettingFocusEventArgs : generate<GettingFocusEventArgs> {};

// IHoldingRoutedEventArgs
struct IHoldingRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_PointerDeviceType(Devices::Input::PointerDeviceType *value);
	virtual STDMETHODIMP _get_HoldingState(UI::Input::HoldingState *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _GetPosition(UIElement* relativeTo, Foundation::Point *returnValue);
};
template<typename X> struct IHoldingRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IHoldingRoutedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IHoldingRoutedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			UI::Input::HoldingState get() { UI::Input::HoldingState value; hrcheck(enc(&IHoldingRoutedEventArgs_adaptor::HoldingState)->_get_HoldingState(&value)); return value; }
			UI::Input::HoldingState operator()() { return get(); }
			operator UI::Input::HoldingState () { return get(); }
		} HoldingState;
		struct : property {
			Devices::Input::PointerDeviceType get() { Devices::Input::PointerDeviceType value; hrcheck(enc(&IHoldingRoutedEventArgs_adaptor::PointerDeviceType)->_get_PointerDeviceType(&value)); return value; }
			Devices::Input::PointerDeviceType operator()() { return get(); }
			operator Devices::Input::PointerDeviceType () { return get(); }
		} PointerDeviceType;
	};
	Foundation::Point GetPosition(pptr<UIElement> relativeTo) { Foundation::Point returnValue; hrcheck(X::get()->_GetPosition(relativeTo, &returnValue)); return returnValue; }
	IHoldingRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IHoldingRoutedEventArgs, X> : Windows::UI::Xaml::Input::IHoldingRoutedEventArgs_adaptor<X> { typedef adapt IHoldingRoutedEventArgs; };
struct IHoldingRoutedEventArgs : IHoldingRoutedEventArgs_raw, generate<IHoldingRoutedEventArgs> {};

// HoldingRoutedEventArgs
template<typename X> struct statics<HoldingRoutedEventArgs, X> : X {
	typedef typename X::root_type HoldingRoutedEventArgs;
};
struct HoldingRoutedEventArgs : generate<HoldingRoutedEventArgs> {};

// IInputScope
struct IInputScope_raw : IInspectable {
	virtual STDMETHODIMP _get_Names(Foundation::Collections::IVector<InputScopeName*>* *value);
};
template<typename X> struct IInputScope_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<InputScopeName>>> get() { Foundation::Collections::IVector<InputScopeName*>* value; hrcheck(enc(&IInputScope_adaptor::Names)->_get_Names(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<InputScopeName>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<InputScopeName>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<InputScopeName>>> operator->() { return get(); }
		} Names;
	};
	IInputScope_adaptor() {}
};
template<typename X> struct adapt<IInputScope, X> : Windows::UI::Xaml::Input::IInputScope_adaptor<X> { typedef adapt IInputScope; };
struct IInputScope : IInputScope_raw, generate<IInputScope> {};

// InputScope
template<typename X> struct statics<InputScope, X> : X {
	typedef typename X::root_type InputScope;
};
struct InputScope : generate<InputScope> {};

// IInputScopeName
struct IInputScopeName_raw : IInspectable {
	virtual STDMETHODIMP _get_NameValue(InputScopeNameValue *value);
	virtual STDMETHODIMP _put_NameValue(InputScopeNameValue value);
};
template<typename X> struct IInputScopeName_adaptor : X {
	union {
		struct : property {
			InputScopeNameValue get() { InputScopeNameValue value; hrcheck(enc(&IInputScopeName_adaptor::NameValue)->_get_NameValue(&value)); return value; }
			InputScopeNameValue operator()() { return get(); }
			operator InputScopeNameValue () { return get(); }
			void put(InputScopeNameValue value) { hrcheck(enc(&IInputScopeName_adaptor::NameValue)->_put_NameValue(value)); }
			void operator=(InputScopeNameValue value) { put(value); }
			void operator()(InputScopeNameValue value) { put(value); }
		} NameValue;
	};
	IInputScopeName_adaptor() {}
};
template<typename X> struct adapt<IInputScopeName, X> : Windows::UI::Xaml::Input::IInputScopeName_adaptor<X> { typedef adapt IInputScopeName; };
struct IInputScopeName : IInputScopeName_raw, generate<IInputScopeName> {};

// IInputScopeNameFactory
struct IInputScopeNameFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(InputScopeNameValue nameValue, InputScopeName* *instance);
};

// InputScopeName
template<typename> struct InputScopeName_statics {
	static InputScopeName *activate() { InputScopeName *t; get_activation_factory<InputScopeName>()->ActivateInstance((IInspectable**)&t); return t; }
	static InputScopeName *activate(InputScopeNameValue nameValue) { InputScopeName *instance; hrcheck(get_activation_factory<InputScopeName, IInputScopeNameFactory>()->_CreateInstance(nameValue, &instance)); return instance; }
};

template<typename X> struct statics<InputScopeName, X> : X, Windows::UI::Xaml::Input::InputScopeName_statics<void> {
	using Windows::UI::Xaml::Input::InputScopeName_statics<void>::activate;
	typedef typename X::root_type InputScopeName;
};
struct InputScopeName : generate<InputScopeName> {};

// IKeyboardAccelerator
struct IKeyboardAccelerator_raw : IInspectable {
	virtual STDMETHODIMP _get_Key(System::VirtualKey *value);
	virtual STDMETHODIMP _put_Key(System::VirtualKey value);
	virtual STDMETHODIMP _get_Modifiers(System::VirtualKeyModifiers *value);
	virtual STDMETHODIMP _put_Modifiers(System::VirtualKeyModifiers value);
	virtual STDMETHODIMP _get_IsEnabled(bool *value);
	virtual STDMETHODIMP _put_IsEnabled(bool value);
	virtual STDMETHODIMP _get_ScopeOwner(DependencyObject* *value);
	virtual STDMETHODIMP _put_ScopeOwner(DependencyObject* value);
	virtual STDMETHODIMP _add_Invoked(Foundation::TypedEventHandler<KeyboardAccelerator*, KeyboardAcceleratorInvokedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Invoked(Foundation::EventRegistrationToken token);
};
template<typename X> struct IKeyboardAccelerator_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IKeyboardAccelerator_adaptor::IsEnabled)->_get_IsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IKeyboardAccelerator_adaptor::IsEnabled)->_put_IsEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsEnabled;
		struct : property {
			System::VirtualKey get() { System::VirtualKey value; hrcheck(enc(&IKeyboardAccelerator_adaptor::Key)->_get_Key(&value)); return value; }
			System::VirtualKey operator()() { return get(); }
			operator System::VirtualKey () { return get(); }
			void put(System::VirtualKey value) { hrcheck(enc(&IKeyboardAccelerator_adaptor::Key)->_put_Key(value)); }
			void operator=(System::VirtualKey value) { put(value); }
			void operator()(System::VirtualKey value) { put(value); }
		} Key;
		struct : property {
			System::VirtualKeyModifiers get() { System::VirtualKeyModifiers value; hrcheck(enc(&IKeyboardAccelerator_adaptor::Modifiers)->_get_Modifiers(&value)); return value; }
			System::VirtualKeyModifiers operator()() { return get(); }
			operator System::VirtualKeyModifiers () { return get(); }
			void put(System::VirtualKeyModifiers value) { hrcheck(enc(&IKeyboardAccelerator_adaptor::Modifiers)->_put_Modifiers(value)); }
			void operator=(System::VirtualKeyModifiers value) { put(value); }
			void operator()(System::VirtualKeyModifiers value) { put(value); }
		} Modifiers;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IKeyboardAccelerator_adaptor::ScopeOwner)->_get_ScopeOwner(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IKeyboardAccelerator_adaptor::ScopeOwner)->_put_ScopeOwner(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} ScopeOwner;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<KeyboardAccelerator>, ptr<KeyboardAcceleratorInvokedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IKeyboardAccelerator_adaptor::Invoked)->_add_Invoked(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IKeyboardAccelerator_adaptor::Invoked)->_remove_Invoked(token)); }
		} Invoked;
	};
	IKeyboardAccelerator_adaptor() {}
};
template<typename X> struct adapt<IKeyboardAccelerator, X> : Windows::UI::Xaml::Input::IKeyboardAccelerator_adaptor<X> { typedef adapt IKeyboardAccelerator; };
struct IKeyboardAccelerator : IKeyboardAccelerator_raw, generate<IKeyboardAccelerator> {};

// IKeyboardAcceleratorFactory
struct IKeyboardAcceleratorFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, KeyboardAccelerator* *instance);
};

// IKeyboardAcceleratorStatics
struct IKeyboardAcceleratorStatics : IInspectable {
	virtual STDMETHODIMP _get_KeyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ModifiersProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ScopeOwnerProperty(DependencyProperty* *value);
};

// KeyboardAccelerator
template<typename> struct KeyboardAccelerator_statics {
	static struct _IsEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<KeyboardAccelerator, IKeyboardAcceleratorStatics>()->_get_IsEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsEnabledProperty;
	static struct _KeyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<KeyboardAccelerator, IKeyboardAcceleratorStatics>()->_get_KeyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeyProperty;
	static struct _ModifiersProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<KeyboardAccelerator, IKeyboardAcceleratorStatics>()->_get_ModifiersProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ModifiersProperty;
	static struct _ScopeOwnerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<KeyboardAccelerator, IKeyboardAcceleratorStatics>()->_get_ScopeOwnerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ScopeOwnerProperty;
	static KeyboardAccelerator *activate(object_ref outer, IInspectable* *inner) { KeyboardAccelerator *instance; hrcheck(get_activation_factory<KeyboardAccelerator, IKeyboardAcceleratorFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename KeyboardAccelerator_statics<X>::_IsEnabledProperty KeyboardAccelerator_statics<X>::IsEnabledProperty;
template<typename X> typename KeyboardAccelerator_statics<X>::_KeyProperty KeyboardAccelerator_statics<X>::KeyProperty;
template<typename X> typename KeyboardAccelerator_statics<X>::_ModifiersProperty KeyboardAccelerator_statics<X>::ModifiersProperty;
template<typename X> typename KeyboardAccelerator_statics<X>::_ScopeOwnerProperty KeyboardAccelerator_statics<X>::ScopeOwnerProperty;

template<typename X> struct statics<KeyboardAccelerator, X> : X, Windows::UI::Xaml::Input::KeyboardAccelerator_statics<void> {
	using Windows::UI::Xaml::Input::KeyboardAccelerator_statics<void>::activate;
	typedef typename X::root_type KeyboardAccelerator;
};
struct KeyboardAccelerator : generate<KeyboardAccelerator> {};

// IKeyRoutedEventArgs
struct IKeyRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Key(System::VirtualKey *value);
	virtual STDMETHODIMP _get_KeyStatus(Core::CorePhysicalKeyStatus *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
};
template<typename X> struct IKeyRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IKeyRoutedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IKeyRoutedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			System::VirtualKey get() { System::VirtualKey value; hrcheck(enc(&IKeyRoutedEventArgs_adaptor::Key)->_get_Key(&value)); return value; }
			System::VirtualKey operator()() { return get(); }
			operator System::VirtualKey () { return get(); }
		} Key;
		struct : property {
			Core::CorePhysicalKeyStatus get() { Core::CorePhysicalKeyStatus value; hrcheck(enc(&IKeyRoutedEventArgs_adaptor::KeyStatus)->_get_KeyStatus(&value)); return value; }
			Core::CorePhysicalKeyStatus operator()() { return get(); }
			operator Core::CorePhysicalKeyStatus () { return get(); }
		} KeyStatus;
	};
	IKeyRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IKeyRoutedEventArgs, X> : Windows::UI::Xaml::Input::IKeyRoutedEventArgs_adaptor<X> { typedef adapt IKeyRoutedEventArgs; };
struct IKeyRoutedEventArgs : IKeyRoutedEventArgs_raw, generate<IKeyRoutedEventArgs> {};

// IKeyRoutedEventArgs2
struct IKeyRoutedEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _get_OriginalKey(System::VirtualKey *value);
};
template<typename X> struct IKeyRoutedEventArgs2_adaptor : X {
	union {
		struct : property {
			System::VirtualKey get() { System::VirtualKey value; hrcheck(enc(&IKeyRoutedEventArgs2_adaptor::OriginalKey)->_get_OriginalKey(&value)); return value; }
			System::VirtualKey operator()() { return get(); }
			operator System::VirtualKey () { return get(); }
		} OriginalKey;
	};
	IKeyRoutedEventArgs2_adaptor() {}
};
template<typename X> struct adapt<IKeyRoutedEventArgs2, X> : Windows::UI::Xaml::Input::IKeyRoutedEventArgs2_adaptor<X> { typedef adapt IKeyRoutedEventArgs2; };
struct IKeyRoutedEventArgs2 : IKeyRoutedEventArgs2_raw, generate<IKeyRoutedEventArgs2> {};

// IKeyRoutedEventArgs3
struct IKeyRoutedEventArgs3_raw : IInspectable {
	virtual STDMETHODIMP _get_DeviceId(HSTRING *value);
};
template<typename X> struct IKeyRoutedEventArgs3_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IKeyRoutedEventArgs3_adaptor::DeviceId)->_get_DeviceId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DeviceId;
	};
	IKeyRoutedEventArgs3_adaptor() {}
};
template<typename X> struct adapt<IKeyRoutedEventArgs3, X> : Windows::UI::Xaml::Input::IKeyRoutedEventArgs3_adaptor<X> { typedef adapt IKeyRoutedEventArgs3; };
struct IKeyRoutedEventArgs3 : IKeyRoutedEventArgs3_raw, generate<IKeyRoutedEventArgs3> {};

// KeyRoutedEventArgs
template<typename X> struct statics<KeyRoutedEventArgs, X> : X {
	typedef typename X::root_type KeyRoutedEventArgs;
};
struct KeyRoutedEventArgs : generate<KeyRoutedEventArgs> {};

// ILosingFocusEventArgs
struct ILosingFocusEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_OldFocusedElement(DependencyObject* *value);
	virtual STDMETHODIMP _get_NewFocusedElement(DependencyObject* *value);
	virtual STDMETHODIMP _put_NewFocusedElement(DependencyObject* value);
	virtual STDMETHODIMP _get_FocusState(Xaml::FocusState *value);
	virtual STDMETHODIMP _get_Direction(FocusNavigationDirection *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _get_InputDevice(FocusInputDeviceKind *value);
	virtual STDMETHODIMP _get_Cancel(bool *value);
	virtual STDMETHODIMP _put_Cancel(bool value);
};
template<typename X> struct ILosingFocusEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILosingFocusEventArgs_adaptor::Cancel)->_get_Cancel(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ILosingFocusEventArgs_adaptor::Cancel)->_put_Cancel(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Cancel;
		struct : property {
			FocusNavigationDirection get() { FocusNavigationDirection value; hrcheck(enc(&ILosingFocusEventArgs_adaptor::Direction)->_get_Direction(&value)); return value; }
			FocusNavigationDirection operator()() { return get(); }
			operator FocusNavigationDirection () { return get(); }
		} Direction;
		struct : property {
			Xaml::FocusState get() { Xaml::FocusState value; hrcheck(enc(&ILosingFocusEventArgs_adaptor::FocusState)->_get_FocusState(&value)); return value; }
			Xaml::FocusState operator()() { return get(); }
			operator Xaml::FocusState () { return get(); }
		} FocusState;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILosingFocusEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ILosingFocusEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			FocusInputDeviceKind get() { FocusInputDeviceKind value; hrcheck(enc(&ILosingFocusEventArgs_adaptor::InputDevice)->_get_InputDevice(&value)); return value; }
			FocusInputDeviceKind operator()() { return get(); }
			operator FocusInputDeviceKind () { return get(); }
		} InputDevice;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&ILosingFocusEventArgs_adaptor::NewFocusedElement)->_get_NewFocusedElement(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&ILosingFocusEventArgs_adaptor::NewFocusedElement)->_put_NewFocusedElement(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} NewFocusedElement;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&ILosingFocusEventArgs_adaptor::OldFocusedElement)->_get_OldFocusedElement(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
		} OldFocusedElement;
	};
	ILosingFocusEventArgs_adaptor() {}
};
template<typename X> struct adapt<ILosingFocusEventArgs, X> : Windows::UI::Xaml::Input::ILosingFocusEventArgs_adaptor<X> { typedef adapt ILosingFocusEventArgs; };
struct ILosingFocusEventArgs : ILosingFocusEventArgs_raw, generate<ILosingFocusEventArgs> {};

// ILosingFocusEventArgs2
struct ILosingFocusEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _TryCancel(bool *returnValue);
	virtual STDMETHODIMP _TrySetNewFocusedElement(DependencyObject* element, bool *returnValue);
};
template<typename X> struct ILosingFocusEventArgs2_adaptor : X {
	bool TryCancel() { bool returnValue; hrcheck(X::get()->_TryCancel(&returnValue)); return returnValue; }
	bool TrySetNewFocusedElement(pptr<DependencyObject> element) { bool returnValue; hrcheck(X::get()->_TrySetNewFocusedElement(element, &returnValue)); return returnValue; }
};
template<typename X> struct adapt<ILosingFocusEventArgs2, X> : Windows::UI::Xaml::Input::ILosingFocusEventArgs2_adaptor<X> { typedef adapt ILosingFocusEventArgs2; };
struct ILosingFocusEventArgs2 : ILosingFocusEventArgs2_raw, generate<ILosingFocusEventArgs2> {};

// LosingFocusEventArgs
template<typename X> struct statics<LosingFocusEventArgs, X> : X {
	typedef typename X::root_type LosingFocusEventArgs;
};
struct LosingFocusEventArgs : generate<LosingFocusEventArgs> {};

// IManipulationCompletedRoutedEventArgs
struct IManipulationCompletedRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Container(UIElement* *value);
	virtual STDMETHODIMP _get_Position(Foundation::Point *value);
	virtual STDMETHODIMP _get_IsInertial(bool *value);
	virtual STDMETHODIMP _get_Cumulative(UI::Input::ManipulationDelta *value);
	virtual STDMETHODIMP _get_Velocities(UI::Input::ManipulationVelocities *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _get_PointerDeviceType(Devices::Input::PointerDeviceType *value);
};
template<typename X> struct IManipulationCompletedRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IManipulationCompletedRoutedEventArgs_adaptor::Container)->_get_Container(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
		} Container;
		struct : property {
			UI::Input::ManipulationDelta get() { UI::Input::ManipulationDelta value; hrcheck(enc(&IManipulationCompletedRoutedEventArgs_adaptor::Cumulative)->_get_Cumulative(&value)); return value; }
			UI::Input::ManipulationDelta operator()() { return get(); }
			operator UI::Input::ManipulationDelta () { return get(); }
		} Cumulative;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IManipulationCompletedRoutedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IManipulationCompletedRoutedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IManipulationCompletedRoutedEventArgs_adaptor::IsInertial)->_get_IsInertial(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsInertial;
		struct : property {
			Devices::Input::PointerDeviceType get() { Devices::Input::PointerDeviceType value; hrcheck(enc(&IManipulationCompletedRoutedEventArgs_adaptor::PointerDeviceType)->_get_PointerDeviceType(&value)); return value; }
			Devices::Input::PointerDeviceType operator()() { return get(); }
			operator Devices::Input::PointerDeviceType () { return get(); }
		} PointerDeviceType;
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IManipulationCompletedRoutedEventArgs_adaptor::Position)->_get_Position(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
		} Position;
		struct : property {
			UI::Input::ManipulationVelocities get() { UI::Input::ManipulationVelocities value; hrcheck(enc(&IManipulationCompletedRoutedEventArgs_adaptor::Velocities)->_get_Velocities(&value)); return value; }
			UI::Input::ManipulationVelocities operator()() { return get(); }
			operator UI::Input::ManipulationVelocities () { return get(); }
		} Velocities;
	};
	IManipulationCompletedRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IManipulationCompletedRoutedEventArgs, X> : Windows::UI::Xaml::Input::IManipulationCompletedRoutedEventArgs_adaptor<X> { typedef adapt IManipulationCompletedRoutedEventArgs; };
struct IManipulationCompletedRoutedEventArgs : IManipulationCompletedRoutedEventArgs_raw, generate<IManipulationCompletedRoutedEventArgs> {};

// ManipulationCompletedRoutedEventArgs
template<typename X> struct statics<ManipulationCompletedRoutedEventArgs, X> : X {
	typedef typename X::root_type ManipulationCompletedRoutedEventArgs;
};
struct ManipulationCompletedRoutedEventArgs : generate<ManipulationCompletedRoutedEventArgs> {};

// IManipulationDeltaRoutedEventArgs
struct IManipulationDeltaRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Container(UIElement* *value);
	virtual STDMETHODIMP _get_Position(Foundation::Point *value);
	virtual STDMETHODIMP _get_IsInertial(bool *value);
	virtual STDMETHODIMP _get_Delta(UI::Input::ManipulationDelta *value);
	virtual STDMETHODIMP _get_Cumulative(UI::Input::ManipulationDelta *value);
	virtual STDMETHODIMP _get_Velocities(UI::Input::ManipulationVelocities *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _get_PointerDeviceType(Devices::Input::PointerDeviceType *value);
	virtual STDMETHODIMP _Complete();
};
template<typename X> struct IManipulationDeltaRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IManipulationDeltaRoutedEventArgs_adaptor::Container)->_get_Container(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
		} Container;
		struct : property {
			UI::Input::ManipulationDelta get() { UI::Input::ManipulationDelta value; hrcheck(enc(&IManipulationDeltaRoutedEventArgs_adaptor::Cumulative)->_get_Cumulative(&value)); return value; }
			UI::Input::ManipulationDelta operator()() { return get(); }
			operator UI::Input::ManipulationDelta () { return get(); }
		} Cumulative;
		struct : property {
			UI::Input::ManipulationDelta get() { UI::Input::ManipulationDelta value; hrcheck(enc(&IManipulationDeltaRoutedEventArgs_adaptor::Delta)->_get_Delta(&value)); return value; }
			UI::Input::ManipulationDelta operator()() { return get(); }
			operator UI::Input::ManipulationDelta () { return get(); }
		} Delta;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IManipulationDeltaRoutedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IManipulationDeltaRoutedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IManipulationDeltaRoutedEventArgs_adaptor::IsInertial)->_get_IsInertial(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsInertial;
		struct : property {
			Devices::Input::PointerDeviceType get() { Devices::Input::PointerDeviceType value; hrcheck(enc(&IManipulationDeltaRoutedEventArgs_adaptor::PointerDeviceType)->_get_PointerDeviceType(&value)); return value; }
			Devices::Input::PointerDeviceType operator()() { return get(); }
			operator Devices::Input::PointerDeviceType () { return get(); }
		} PointerDeviceType;
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IManipulationDeltaRoutedEventArgs_adaptor::Position)->_get_Position(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
		} Position;
		struct : property {
			UI::Input::ManipulationVelocities get() { UI::Input::ManipulationVelocities value; hrcheck(enc(&IManipulationDeltaRoutedEventArgs_adaptor::Velocities)->_get_Velocities(&value)); return value; }
			UI::Input::ManipulationVelocities operator()() { return get(); }
			operator UI::Input::ManipulationVelocities () { return get(); }
		} Velocities;
	};
	void Complete() { hrcheck(X::get()->_Complete()); }
	IManipulationDeltaRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IManipulationDeltaRoutedEventArgs, X> : Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs_adaptor<X> { typedef adapt IManipulationDeltaRoutedEventArgs; };
struct IManipulationDeltaRoutedEventArgs : IManipulationDeltaRoutedEventArgs_raw, generate<IManipulationDeltaRoutedEventArgs> {};

// ManipulationDeltaRoutedEventArgs
template<typename X> struct statics<ManipulationDeltaRoutedEventArgs, X> : X {
	typedef typename X::root_type ManipulationDeltaRoutedEventArgs;
};
struct ManipulationDeltaRoutedEventArgs : generate<ManipulationDeltaRoutedEventArgs> {};

// IManipulationInertiaStartingRoutedEventArgs
struct IManipulationInertiaStartingRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Container(UIElement* *value);
	virtual STDMETHODIMP _get_ExpansionBehavior(InertiaExpansionBehavior* *value);
	virtual STDMETHODIMP _put_ExpansionBehavior(InertiaExpansionBehavior* value);
	virtual STDMETHODIMP _get_RotationBehavior(InertiaRotationBehavior* *value);
	virtual STDMETHODIMP _put_RotationBehavior(InertiaRotationBehavior* value);
	virtual STDMETHODIMP _get_TranslationBehavior(InertiaTranslationBehavior* *value);
	virtual STDMETHODIMP _put_TranslationBehavior(InertiaTranslationBehavior* value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _get_PointerDeviceType(Devices::Input::PointerDeviceType *value);
	virtual STDMETHODIMP _get_Delta(UI::Input::ManipulationDelta *value);
	virtual STDMETHODIMP _get_Cumulative(UI::Input::ManipulationDelta *value);
	virtual STDMETHODIMP _get_Velocities(UI::Input::ManipulationVelocities *value);
};
template<typename X> struct IManipulationInertiaStartingRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IManipulationInertiaStartingRoutedEventArgs_adaptor::Container)->_get_Container(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
		} Container;
		struct : property {
			UI::Input::ManipulationDelta get() { UI::Input::ManipulationDelta value; hrcheck(enc(&IManipulationInertiaStartingRoutedEventArgs_adaptor::Cumulative)->_get_Cumulative(&value)); return value; }
			UI::Input::ManipulationDelta operator()() { return get(); }
			operator UI::Input::ManipulationDelta () { return get(); }
		} Cumulative;
		struct : property {
			UI::Input::ManipulationDelta get() { UI::Input::ManipulationDelta value; hrcheck(enc(&IManipulationInertiaStartingRoutedEventArgs_adaptor::Delta)->_get_Delta(&value)); return value; }
			UI::Input::ManipulationDelta operator()() { return get(); }
			operator UI::Input::ManipulationDelta () { return get(); }
		} Delta;
		struct : property {
			ptr<InertiaExpansionBehavior> get() { InertiaExpansionBehavior* value; hrcheck(enc(&IManipulationInertiaStartingRoutedEventArgs_adaptor::ExpansionBehavior)->_get_ExpansionBehavior(&value)); return from_abi(value); }
			ptr<InertiaExpansionBehavior> operator()() { return get(); }
			operator ptr<InertiaExpansionBehavior> () { return get(); }
			ptr<InertiaExpansionBehavior> operator->() { return get(); }
			void put(pptr<InertiaExpansionBehavior> value) { hrcheck(enc(&IManipulationInertiaStartingRoutedEventArgs_adaptor::ExpansionBehavior)->_put_ExpansionBehavior(value)); }
			void operator=(pptr<InertiaExpansionBehavior> value) { put(value); }
			void operator()(pptr<InertiaExpansionBehavior> value) { put(value); }
		} ExpansionBehavior;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IManipulationInertiaStartingRoutedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IManipulationInertiaStartingRoutedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			Devices::Input::PointerDeviceType get() { Devices::Input::PointerDeviceType value; hrcheck(enc(&IManipulationInertiaStartingRoutedEventArgs_adaptor::PointerDeviceType)->_get_PointerDeviceType(&value)); return value; }
			Devices::Input::PointerDeviceType operator()() { return get(); }
			operator Devices::Input::PointerDeviceType () { return get(); }
		} PointerDeviceType;
		struct : property {
			ptr<InertiaRotationBehavior> get() { InertiaRotationBehavior* value; hrcheck(enc(&IManipulationInertiaStartingRoutedEventArgs_adaptor::RotationBehavior)->_get_RotationBehavior(&value)); return from_abi(value); }
			ptr<InertiaRotationBehavior> operator()() { return get(); }
			operator ptr<InertiaRotationBehavior> () { return get(); }
			ptr<InertiaRotationBehavior> operator->() { return get(); }
			void put(pptr<InertiaRotationBehavior> value) { hrcheck(enc(&IManipulationInertiaStartingRoutedEventArgs_adaptor::RotationBehavior)->_put_RotationBehavior(value)); }
			void operator=(pptr<InertiaRotationBehavior> value) { put(value); }
			void operator()(pptr<InertiaRotationBehavior> value) { put(value); }
		} RotationBehavior;
		struct : property {
			ptr<InertiaTranslationBehavior> get() { InertiaTranslationBehavior* value; hrcheck(enc(&IManipulationInertiaStartingRoutedEventArgs_adaptor::TranslationBehavior)->_get_TranslationBehavior(&value)); return from_abi(value); }
			ptr<InertiaTranslationBehavior> operator()() { return get(); }
			operator ptr<InertiaTranslationBehavior> () { return get(); }
			ptr<InertiaTranslationBehavior> operator->() { return get(); }
			void put(pptr<InertiaTranslationBehavior> value) { hrcheck(enc(&IManipulationInertiaStartingRoutedEventArgs_adaptor::TranslationBehavior)->_put_TranslationBehavior(value)); }
			void operator=(pptr<InertiaTranslationBehavior> value) { put(value); }
			void operator()(pptr<InertiaTranslationBehavior> value) { put(value); }
		} TranslationBehavior;
		struct : property {
			UI::Input::ManipulationVelocities get() { UI::Input::ManipulationVelocities value; hrcheck(enc(&IManipulationInertiaStartingRoutedEventArgs_adaptor::Velocities)->_get_Velocities(&value)); return value; }
			UI::Input::ManipulationVelocities operator()() { return get(); }
			operator UI::Input::ManipulationVelocities () { return get(); }
		} Velocities;
	};
	IManipulationInertiaStartingRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IManipulationInertiaStartingRoutedEventArgs, X> : Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs_adaptor<X> { typedef adapt IManipulationInertiaStartingRoutedEventArgs; };
struct IManipulationInertiaStartingRoutedEventArgs : IManipulationInertiaStartingRoutedEventArgs_raw, generate<IManipulationInertiaStartingRoutedEventArgs> {};

// ManipulationInertiaStartingRoutedEventArgs
template<typename X> struct statics<ManipulationInertiaStartingRoutedEventArgs, X> : X {
	typedef typename X::root_type ManipulationInertiaStartingRoutedEventArgs;
};
struct ManipulationInertiaStartingRoutedEventArgs : generate<ManipulationInertiaStartingRoutedEventArgs> {};

// IManipulationStartedRoutedEventArgs
struct IManipulationStartedRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Container(UIElement* *value);
	virtual STDMETHODIMP _get_Position(Foundation::Point *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _get_PointerDeviceType(Devices::Input::PointerDeviceType *value);
	virtual STDMETHODIMP _get_Cumulative(UI::Input::ManipulationDelta *value);
	virtual STDMETHODIMP _Complete();
};
template<typename X> struct IManipulationStartedRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IManipulationStartedRoutedEventArgs_adaptor::Container)->_get_Container(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
		} Container;
		struct : property {
			UI::Input::ManipulationDelta get() { UI::Input::ManipulationDelta value; hrcheck(enc(&IManipulationStartedRoutedEventArgs_adaptor::Cumulative)->_get_Cumulative(&value)); return value; }
			UI::Input::ManipulationDelta operator()() { return get(); }
			operator UI::Input::ManipulationDelta () { return get(); }
		} Cumulative;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IManipulationStartedRoutedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IManipulationStartedRoutedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			Devices::Input::PointerDeviceType get() { Devices::Input::PointerDeviceType value; hrcheck(enc(&IManipulationStartedRoutedEventArgs_adaptor::PointerDeviceType)->_get_PointerDeviceType(&value)); return value; }
			Devices::Input::PointerDeviceType operator()() { return get(); }
			operator Devices::Input::PointerDeviceType () { return get(); }
		} PointerDeviceType;
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IManipulationStartedRoutedEventArgs_adaptor::Position)->_get_Position(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
		} Position;
	};
	void Complete() { hrcheck(X::get()->_Complete()); }
	IManipulationStartedRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IManipulationStartedRoutedEventArgs, X> : Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgs_adaptor<X> { typedef adapt IManipulationStartedRoutedEventArgs; };
struct IManipulationStartedRoutedEventArgs : IManipulationStartedRoutedEventArgs_raw, generate<IManipulationStartedRoutedEventArgs> {};

// IManipulationStartedRoutedEventArgsFactory
struct IManipulationStartedRoutedEventArgsFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ManipulationStartedRoutedEventArgs* *instance);
};

// ManipulationStartedRoutedEventArgs
template<typename> struct ManipulationStartedRoutedEventArgs_statics {
	static ManipulationStartedRoutedEventArgs *activate(object_ref outer, IInspectable* *inner) { ManipulationStartedRoutedEventArgs *instance; hrcheck(get_activation_factory<ManipulationStartedRoutedEventArgs, IManipulationStartedRoutedEventArgsFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<ManipulationStartedRoutedEventArgs, X> : X, Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs_statics<void> {
	using Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs_statics<void>::activate;
	typedef typename X::root_type ManipulationStartedRoutedEventArgs;
};
struct ManipulationStartedRoutedEventArgs : generate<ManipulationStartedRoutedEventArgs> {};

// IManipulationStartingRoutedEventArgs
struct IManipulationStartingRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Mode(ManipulationModes *value);
	virtual STDMETHODIMP _put_Mode(ManipulationModes value);
	virtual STDMETHODIMP _get_Container(UIElement* *value);
	virtual STDMETHODIMP _put_Container(UIElement* value);
	virtual STDMETHODIMP _get_Pivot(ManipulationPivot* *value);
	virtual STDMETHODIMP _put_Pivot(ManipulationPivot* value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
};
template<typename X> struct IManipulationStartingRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IManipulationStartingRoutedEventArgs_adaptor::Container)->_get_Container(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IManipulationStartingRoutedEventArgs_adaptor::Container)->_put_Container(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} Container;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IManipulationStartingRoutedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IManipulationStartingRoutedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			ManipulationModes get() { ManipulationModes value; hrcheck(enc(&IManipulationStartingRoutedEventArgs_adaptor::Mode)->_get_Mode(&value)); return value; }
			ManipulationModes operator()() { return get(); }
			operator ManipulationModes () { return get(); }
			void put(ManipulationModes value) { hrcheck(enc(&IManipulationStartingRoutedEventArgs_adaptor::Mode)->_put_Mode(value)); }
			void operator=(ManipulationModes value) { put(value); }
			void operator()(ManipulationModes value) { put(value); }
		} Mode;
		struct : property {
			ptr<ManipulationPivot> get() { ManipulationPivot* value; hrcheck(enc(&IManipulationStartingRoutedEventArgs_adaptor::Pivot)->_get_Pivot(&value)); return from_abi(value); }
			ptr<ManipulationPivot> operator()() { return get(); }
			operator ptr<ManipulationPivot> () { return get(); }
			ptr<ManipulationPivot> operator->() { return get(); }
			void put(pptr<ManipulationPivot> value) { hrcheck(enc(&IManipulationStartingRoutedEventArgs_adaptor::Pivot)->_put_Pivot(value)); }
			void operator=(pptr<ManipulationPivot> value) { put(value); }
			void operator()(pptr<ManipulationPivot> value) { put(value); }
		} Pivot;
	};
	IManipulationStartingRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IManipulationStartingRoutedEventArgs, X> : Windows::UI::Xaml::Input::IManipulationStartingRoutedEventArgs_adaptor<X> { typedef adapt IManipulationStartingRoutedEventArgs; };
struct IManipulationStartingRoutedEventArgs : IManipulationStartingRoutedEventArgs_raw, generate<IManipulationStartingRoutedEventArgs> {};

// ManipulationStartingRoutedEventArgs
template<typename X> struct statics<ManipulationStartingRoutedEventArgs, X> : X {
	typedef typename X::root_type ManipulationStartingRoutedEventArgs;
};
struct ManipulationStartingRoutedEventArgs : generate<ManipulationStartingRoutedEventArgs> {};

// INoFocusCandidateFoundEventArgs
struct INoFocusCandidateFoundEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Direction(FocusNavigationDirection *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _get_InputDevice(FocusInputDeviceKind *value);
};
template<typename X> struct INoFocusCandidateFoundEventArgs_adaptor : X {
	union {
		struct : property {
			FocusNavigationDirection get() { FocusNavigationDirection value; hrcheck(enc(&INoFocusCandidateFoundEventArgs_adaptor::Direction)->_get_Direction(&value)); return value; }
			FocusNavigationDirection operator()() { return get(); }
			operator FocusNavigationDirection () { return get(); }
		} Direction;
		struct : property {
			bool get() { bool value; hrcheck(enc(&INoFocusCandidateFoundEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&INoFocusCandidateFoundEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			FocusInputDeviceKind get() { FocusInputDeviceKind value; hrcheck(enc(&INoFocusCandidateFoundEventArgs_adaptor::InputDevice)->_get_InputDevice(&value)); return value; }
			FocusInputDeviceKind operator()() { return get(); }
			operator FocusInputDeviceKind () { return get(); }
		} InputDevice;
	};
	INoFocusCandidateFoundEventArgs_adaptor() {}
};
template<typename X> struct adapt<INoFocusCandidateFoundEventArgs, X> : Windows::UI::Xaml::Input::INoFocusCandidateFoundEventArgs_adaptor<X> { typedef adapt INoFocusCandidateFoundEventArgs; };
struct INoFocusCandidateFoundEventArgs : INoFocusCandidateFoundEventArgs_raw, generate<INoFocusCandidateFoundEventArgs> {};

// NoFocusCandidateFoundEventArgs
template<typename X> struct statics<NoFocusCandidateFoundEventArgs, X> : X {
	typedef typename X::root_type NoFocusCandidateFoundEventArgs;
};
struct NoFocusCandidateFoundEventArgs : generate<NoFocusCandidateFoundEventArgs> {};

// IPointerRoutedEventArgs
struct IPointerRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Pointer(Input::Pointer* *value);
	virtual STDMETHODIMP _get_KeyModifiers(System::VirtualKeyModifiers *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _GetCurrentPoint(UIElement* relativeTo, UI::Input::PointerPoint* *returnValue);
	virtual STDMETHODIMP _GetIntermediatePoints(UIElement* relativeTo, Foundation::Collections::IVector<UI::Input::PointerPoint*>* *returnValue);
};
template<typename X> struct IPointerRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPointerRoutedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IPointerRoutedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			System::VirtualKeyModifiers get() { System::VirtualKeyModifiers value; hrcheck(enc(&IPointerRoutedEventArgs_adaptor::KeyModifiers)->_get_KeyModifiers(&value)); return value; }
			System::VirtualKeyModifiers operator()() { return get(); }
			operator System::VirtualKeyModifiers () { return get(); }
		} KeyModifiers;
		struct : property {
			ptr<Input::Pointer> get() { Input::Pointer* value; hrcheck(enc(&IPointerRoutedEventArgs_adaptor::Pointer)->_get_Pointer(&value)); return from_abi(value); }
			ptr<Input::Pointer> operator()() { return get(); }
			operator ptr<Input::Pointer> () { return get(); }
			ptr<Input::Pointer> operator->() { return get(); }
		} Pointer;
	};
	ptr<UI::Input::PointerPoint> GetCurrentPoint(pptr<UIElement> relativeTo) { UI::Input::PointerPoint* returnValue; hrcheck(X::get()->_GetCurrentPoint(relativeTo, &returnValue)); return from_abi(returnValue); }
	ptr<Foundation::Collections::IVector<ptr<UI::Input::PointerPoint>>> GetIntermediatePoints(pptr<UIElement> relativeTo) { Foundation::Collections::IVector<UI::Input::PointerPoint*>* returnValue; hrcheck(X::get()->_GetIntermediatePoints(relativeTo, &returnValue)); return from_abi(returnValue); }
	IPointerRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IPointerRoutedEventArgs, X> : Windows::UI::Xaml::Input::IPointerRoutedEventArgs_adaptor<X> { typedef adapt IPointerRoutedEventArgs; };
struct IPointerRoutedEventArgs : IPointerRoutedEventArgs_raw, generate<IPointerRoutedEventArgs> {};

// IPointerRoutedEventArgs2
struct IPointerRoutedEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsGenerated(bool *value);
};
template<typename X> struct IPointerRoutedEventArgs2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPointerRoutedEventArgs2_adaptor::IsGenerated)->_get_IsGenerated(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsGenerated;
	};
	IPointerRoutedEventArgs2_adaptor() {}
};
template<typename X> struct adapt<IPointerRoutedEventArgs2, X> : Windows::UI::Xaml::Input::IPointerRoutedEventArgs2_adaptor<X> { typedef adapt IPointerRoutedEventArgs2; };
struct IPointerRoutedEventArgs2 : IPointerRoutedEventArgs2_raw, generate<IPointerRoutedEventArgs2> {};

// PointerRoutedEventArgs
template<typename X> struct statics<PointerRoutedEventArgs, X> : X {
	typedef typename X::root_type PointerRoutedEventArgs;
};
struct PointerRoutedEventArgs : generate<PointerRoutedEventArgs> {};

// IRightTappedRoutedEventArgs
struct IRightTappedRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_PointerDeviceType(Devices::Input::PointerDeviceType *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _GetPosition(UIElement* relativeTo, Foundation::Point *returnValue);
};
template<typename X> struct IRightTappedRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRightTappedRoutedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IRightTappedRoutedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			Devices::Input::PointerDeviceType get() { Devices::Input::PointerDeviceType value; hrcheck(enc(&IRightTappedRoutedEventArgs_adaptor::PointerDeviceType)->_get_PointerDeviceType(&value)); return value; }
			Devices::Input::PointerDeviceType operator()() { return get(); }
			operator Devices::Input::PointerDeviceType () { return get(); }
		} PointerDeviceType;
	};
	Foundation::Point GetPosition(pptr<UIElement> relativeTo) { Foundation::Point returnValue; hrcheck(X::get()->_GetPosition(relativeTo, &returnValue)); return returnValue; }
	IRightTappedRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IRightTappedRoutedEventArgs, X> : Windows::UI::Xaml::Input::IRightTappedRoutedEventArgs_adaptor<X> { typedef adapt IRightTappedRoutedEventArgs; };
struct IRightTappedRoutedEventArgs : IRightTappedRoutedEventArgs_raw, generate<IRightTappedRoutedEventArgs> {};

// RightTappedRoutedEventArgs
template<typename X> struct statics<RightTappedRoutedEventArgs, X> : X {
	typedef typename X::root_type RightTappedRoutedEventArgs;
};
struct RightTappedRoutedEventArgs : generate<RightTappedRoutedEventArgs> {};

// ITappedRoutedEventArgs
struct ITappedRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_PointerDeviceType(Devices::Input::PointerDeviceType *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _GetPosition(UIElement* relativeTo, Foundation::Point *returnValue);
};
template<typename X> struct ITappedRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITappedRoutedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITappedRoutedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			Devices::Input::PointerDeviceType get() { Devices::Input::PointerDeviceType value; hrcheck(enc(&ITappedRoutedEventArgs_adaptor::PointerDeviceType)->_get_PointerDeviceType(&value)); return value; }
			Devices::Input::PointerDeviceType operator()() { return get(); }
			operator Devices::Input::PointerDeviceType () { return get(); }
		} PointerDeviceType;
	};
	Foundation::Point GetPosition(pptr<UIElement> relativeTo) { Foundation::Point returnValue; hrcheck(X::get()->_GetPosition(relativeTo, &returnValue)); return returnValue; }
	ITappedRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITappedRoutedEventArgs, X> : Windows::UI::Xaml::Input::ITappedRoutedEventArgs_adaptor<X> { typedef adapt ITappedRoutedEventArgs; };
struct ITappedRoutedEventArgs : ITappedRoutedEventArgs_raw, generate<ITappedRoutedEventArgs> {};

// TappedRoutedEventArgs
template<typename X> struct statics<TappedRoutedEventArgs, X> : X {
	typedef typename X::root_type TappedRoutedEventArgs;
};
struct TappedRoutedEventArgs : generate<TappedRoutedEventArgs> {};

// IFindNextElementOptions
struct IFindNextElementOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_SearchRoot(DependencyObject* *value);
	virtual STDMETHODIMP _put_SearchRoot(DependencyObject* value);
	virtual STDMETHODIMP _get_ExclusionRect(Foundation::Rect *value);
	virtual STDMETHODIMP _put_ExclusionRect(Foundation::Rect value);
	virtual STDMETHODIMP _get_HintRect(Foundation::Rect *value);
	virtual STDMETHODIMP _put_HintRect(Foundation::Rect value);
	virtual STDMETHODIMP _get_XYFocusNavigationStrategyOverride(Input::XYFocusNavigationStrategyOverride *value);
	virtual STDMETHODIMP _put_XYFocusNavigationStrategyOverride(Input::XYFocusNavigationStrategyOverride value);
};
template<typename X> struct IFindNextElementOptions_adaptor : X {
	union {
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&IFindNextElementOptions_adaptor::ExclusionRect)->_get_ExclusionRect(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
			void put(const Foundation::Rect& value) { hrcheck(enc(&IFindNextElementOptions_adaptor::ExclusionRect)->_put_ExclusionRect(value)); }
			void operator=(const Foundation::Rect& value) { put(value); }
			void operator()(const Foundation::Rect& value) { put(value); }
		} ExclusionRect;
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&IFindNextElementOptions_adaptor::HintRect)->_get_HintRect(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
			void put(const Foundation::Rect& value) { hrcheck(enc(&IFindNextElementOptions_adaptor::HintRect)->_put_HintRect(value)); }
			void operator=(const Foundation::Rect& value) { put(value); }
			void operator()(const Foundation::Rect& value) { put(value); }
		} HintRect;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IFindNextElementOptions_adaptor::SearchRoot)->_get_SearchRoot(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IFindNextElementOptions_adaptor::SearchRoot)->_put_SearchRoot(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} SearchRoot;
		struct : property {
			Input::XYFocusNavigationStrategyOverride get() { Input::XYFocusNavigationStrategyOverride value; hrcheck(enc(&IFindNextElementOptions_adaptor::XYFocusNavigationStrategyOverride)->_get_XYFocusNavigationStrategyOverride(&value)); return value; }
			Input::XYFocusNavigationStrategyOverride operator()() { return get(); }
			operator Input::XYFocusNavigationStrategyOverride () { return get(); }
			void put(Input::XYFocusNavigationStrategyOverride value) { hrcheck(enc(&IFindNextElementOptions_adaptor::XYFocusNavigationStrategyOverride)->_put_XYFocusNavigationStrategyOverride(value)); }
			void operator=(Input::XYFocusNavigationStrategyOverride value) { put(value); }
			void operator()(Input::XYFocusNavigationStrategyOverride value) { put(value); }
		} XYFocusNavigationStrategyOverride;
	};
	IFindNextElementOptions_adaptor() {}
};
template<typename X> struct adapt<IFindNextElementOptions, X> : Windows::UI::Xaml::Input::IFindNextElementOptions_adaptor<X> { typedef adapt IFindNextElementOptions; };
struct IFindNextElementOptions : IFindNextElementOptions_raw, generate<IFindNextElementOptions> {};

// FindNextElementOptions
template<typename X> struct statics<FindNextElementOptions, X> : X {
	typedef typename X::root_type FindNextElementOptions;
};
struct FindNextElementOptions : generate<FindNextElementOptions> {};

// IFocusManager
struct IFocusManager : IInspectable, generate<IFocusManager> {};

// IFocusManagerStatics
struct IFocusManagerStatics : IInspectable {
	virtual STDMETHODIMP _GetFocusedElement(IInspectable* *returnValue);
};

// IFocusManagerStatics2
struct IFocusManagerStatics2 : IInspectable {
	virtual STDMETHODIMP _TryMoveFocus(FocusNavigationDirection focusNavigationDirection, bool *returnValue);
};

// IFocusManagerStatics3
struct IFocusManagerStatics3 : IInspectable {
	virtual STDMETHODIMP _FindNextFocusableElement(FocusNavigationDirection focusNavigationDirection, UIElement* *result);
	virtual STDMETHODIMP _FindNextFocusableElementWithHint(FocusNavigationDirection focusNavigationDirection, Foundation::Rect hintRect, UIElement* *result);
};

// IFocusManagerStatics4
struct IFocusManagerStatics4 : IInspectable {
	virtual STDMETHODIMP _TryMoveFocusWithOptions(FocusNavigationDirection focusNavigationDirection, FindNextElementOptions* focusNavigationOptions, bool *returnValue);
	virtual STDMETHODIMP _FindNextElement(FocusNavigationDirection focusNavigationDirection, DependencyObject* *returnValue);
	virtual STDMETHODIMP _FindFirstFocusableElement(DependencyObject* searchScope, DependencyObject* *returnValue);
	virtual STDMETHODIMP _FindLastFocusableElement(DependencyObject* searchScope, DependencyObject* *returnValue);
	virtual STDMETHODIMP _FindNextElementWithOptions(FocusNavigationDirection focusNavigationDirection, FindNextElementOptions* focusNavigationOptions, DependencyObject* *returnValue);
};

// IFocusManagerStatics5
struct IFocusManagerStatics5 : IInspectable {
	virtual STDMETHODIMP _TryFocusAsync(DependencyObject* element, FocusState value, Foundation::IAsyncOperation<FocusMovementResult*>* *returnValue);
	virtual STDMETHODIMP _TryMoveFocusAsync(FocusNavigationDirection focusNavigationDirection, Foundation::IAsyncOperation<FocusMovementResult*>* *returnValue);
	virtual STDMETHODIMP _TryMoveFocusWithOptionsAsync(FocusNavigationDirection focusNavigationDirection, FindNextElementOptions* focusNavigationOptions, Foundation::IAsyncOperation<FocusMovementResult*>* *returnValue);
};

// IFocusMovementResult
struct IFocusMovementResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Succeeded(bool *value);
};
template<typename X> struct IFocusMovementResult_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFocusMovementResult_adaptor::Succeeded)->_get_Succeeded(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Succeeded;
	};
	IFocusMovementResult_adaptor() {}
};
template<typename X> struct adapt<IFocusMovementResult, X> : Windows::UI::Xaml::Input::IFocusMovementResult_adaptor<X> { typedef adapt IFocusMovementResult; };
struct IFocusMovementResult : IFocusMovementResult_raw, generate<IFocusMovementResult> {};

// FocusMovementResult
template<typename X> struct statics<FocusMovementResult, X> : X {
	typedef typename X::root_type FocusMovementResult;
};
struct FocusMovementResult : generate<FocusMovementResult> {};

// FocusManager
template<typename> struct FocusManager_statics {
	static ptr<Foundation::IAsyncOperation<ptr<FocusMovementResult>>> TryFocusAsync(pptr<DependencyObject> element, FocusState value) { Foundation::IAsyncOperation<FocusMovementResult*>* returnValue; hrcheck(get_activation_factory<FocusManager, IFocusManagerStatics5>()->_TryFocusAsync(element, value, &returnValue)); return from_abi(returnValue); }
	static ptr<Foundation::IAsyncOperation<ptr<FocusMovementResult>>> TryMoveFocusAsync(FocusNavigationDirection focusNavigationDirection) { Foundation::IAsyncOperation<FocusMovementResult*>* returnValue; hrcheck(get_activation_factory<FocusManager, IFocusManagerStatics5>()->_TryMoveFocusAsync(focusNavigationDirection, &returnValue)); return from_abi(returnValue); }
	static ptr<Foundation::IAsyncOperation<ptr<FocusMovementResult>>> TryMoveFocusAsync(FocusNavigationDirection focusNavigationDirection, pptr<FindNextElementOptions> focusNavigationOptions) { Foundation::IAsyncOperation<FocusMovementResult*>* returnValue; hrcheck(get_activation_factory<FocusManager, IFocusManagerStatics5>()->_TryMoveFocusWithOptionsAsync(focusNavigationDirection, focusNavigationOptions, &returnValue)); return from_abi(returnValue); }
	static bool TryMoveFocus(FocusNavigationDirection focusNavigationDirection, pptr<FindNextElementOptions> focusNavigationOptions) { bool returnValue; hrcheck(get_activation_factory<FocusManager, IFocusManagerStatics4>()->_TryMoveFocusWithOptions(focusNavigationDirection, focusNavigationOptions, &returnValue)); return returnValue; }
	static ptr<DependencyObject> FindNextElement(FocusNavigationDirection focusNavigationDirection) { DependencyObject* returnValue; hrcheck(get_activation_factory<FocusManager, IFocusManagerStatics4>()->_FindNextElement(focusNavigationDirection, &returnValue)); return from_abi(returnValue); }
	static ptr<DependencyObject> FindFirstFocusableElement(pptr<DependencyObject> searchScope) { DependencyObject* returnValue; hrcheck(get_activation_factory<FocusManager, IFocusManagerStatics4>()->_FindFirstFocusableElement(searchScope, &returnValue)); return from_abi(returnValue); }
	static ptr<DependencyObject> FindLastFocusableElement(pptr<DependencyObject> searchScope) { DependencyObject* returnValue; hrcheck(get_activation_factory<FocusManager, IFocusManagerStatics4>()->_FindLastFocusableElement(searchScope, &returnValue)); return from_abi(returnValue); }
	static ptr<DependencyObject> FindNextElement(FocusNavigationDirection focusNavigationDirection, pptr<FindNextElementOptions> focusNavigationOptions) { DependencyObject* returnValue; hrcheck(get_activation_factory<FocusManager, IFocusManagerStatics4>()->_FindNextElementWithOptions(focusNavigationDirection, focusNavigationOptions, &returnValue)); return from_abi(returnValue); }
	static ptr<UIElement> FindNextFocusableElement(FocusNavigationDirection focusNavigationDirection) { UIElement* result; hrcheck(get_activation_factory<FocusManager, IFocusManagerStatics3>()->_FindNextFocusableElement(focusNavigationDirection, &result)); return from_abi(result); }
	static ptr<UIElement> FindNextFocusableElement(FocusNavigationDirection focusNavigationDirection, const Foundation::Rect& hintRect) { UIElement* result; hrcheck(get_activation_factory<FocusManager, IFocusManagerStatics3>()->_FindNextFocusableElementWithHint(focusNavigationDirection, hintRect, &result)); return from_abi(result); }
	static bool TryMoveFocus(FocusNavigationDirection focusNavigationDirection) { bool returnValue; hrcheck(get_activation_factory<FocusManager, IFocusManagerStatics2>()->_TryMoveFocus(focusNavigationDirection, &returnValue)); return returnValue; }
	static object GetFocusedElement() { IInspectable* returnValue; hrcheck(get_activation_factory<FocusManager, IFocusManagerStatics>()->_GetFocusedElement(&returnValue)); return from_abi(returnValue); }
};

template<typename X> struct statics<FocusManager, X> : X, Windows::UI::Xaml::Input::FocusManager_statics<void> {
	typedef typename X::root_type FocusManager;
};
struct FocusManager : generate<FocusManager> {};
}}}}
} // namespace iso_winrt
