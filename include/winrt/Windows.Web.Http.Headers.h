#pragma once
// generated by isopod tools
// namespaces:
// Windows.Web.Http.Headers

#include "Windows.Web.Http.Headers.0.h"
#include "Windows.Foundation.Collections.h"
#include "Windows.Foundation.h"
#include "Windows.Globalization.h"
#include "Windows.Web.Http.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Networking {
struct HostName;
}
namespace Storage { namespace Streams {
struct IBuffer;
}}}

// defs

template<> struct def<Windows::Web::Http::Headers::IHttpContentHeaderCollection> : interface_type<Windows::Foundation::Collections::IMap<HSTRING, HSTRING>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, HSTRING>>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpContentHeaderCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpContentHeaderCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpRequestHeaderCollection> : interface_type<Windows::Foundation::Collections::IMap<HSTRING, HSTRING>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, HSTRING>>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpRequestHeaderCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpRequestHeaderCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpResponseHeaderCollection> : interface_type<Windows::Foundation::Collections::IMap<HSTRING, HSTRING>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, HSTRING>>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpResponseHeaderCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpResponseHeaderCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpContentDispositionHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpContentDispositionHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpContentDispositionHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpContentDispositionHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpContentDispositionHeaderValue, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::Headers::IHttpContentCodingHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpContentCodingHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpContentCodingHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpContentCodingHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpContentCodingHeaderValue, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::Headers::IHttpContentCodingHeaderValueCollection> : interface_type<Windows::Foundation::Collections::IVector<ptr<Windows::Web::Http::Headers::HttpContentCodingHeaderValue>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Web::Http::Headers::HttpContentCodingHeaderValue>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpContentCodingHeaderValueCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpContentCodingHeaderValueCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpLanguageHeaderValueCollection> : interface_type<Windows::Foundation::Collections::IVector<ptr<Windows::Globalization::Language>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Globalization::Language>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpLanguageHeaderValueCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpLanguageHeaderValueCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpContentRangeHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpContentRangeHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpContentRangeHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpContentRangeHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpContentRangeHeaderValue, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::Headers::IHttpMediaTypeHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpMediaTypeHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpMediaTypeHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpMediaTypeHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpMediaTypeHeaderValue, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::Headers::IHttpMediaTypeWithQualityHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpMediaTypeWithQualityHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpMediaTypeWithQualityHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpMediaTypeWithQualityHeaderValue, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::Headers::IHttpMediaTypeWithQualityHeaderValueCollection> : interface_type<Windows::Foundation::Collections::IVector<ptr<Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValueCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpMediaTypeWithQualityHeaderValueCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpContentCodingWithQualityHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpContentCodingWithQualityHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpContentCodingWithQualityHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpContentCodingWithQualityHeaderValue, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::Headers::IHttpContentCodingWithQualityHeaderValueCollection> : interface_type<Windows::Foundation::Collections::IVector<ptr<Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValueCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpContentCodingWithQualityHeaderValueCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpLanguageRangeWithQualityHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpLanguageRangeWithQualityHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpLanguageRangeWithQualityHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpLanguageRangeWithQualityHeaderValue, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::Headers::IHttpLanguageRangeWithQualityHeaderValueCollection> : interface_type<Windows::Foundation::Collections::IVector<ptr<Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValueCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpLanguageRangeWithQualityHeaderValueCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpCredentialsHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpCredentialsHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpCredentialsHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpCredentialsHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpCredentialsHeaderValue, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::Headers::IHttpNameValueHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpNameValueHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpNameValueHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpNameValueHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpNameValueHeaderValue, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::Headers::IHttpCacheDirectiveHeaderValueCollection> : interface_type<Windows::Foundation::Collections::IVector<ptr<Windows::Web::Http::Headers::HttpNameValueHeaderValue>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Web::Http::Headers::HttpNameValueHeaderValue>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpCacheDirectiveHeaderValueCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpCacheDirectiveHeaderValueCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpConnectionOptionHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpConnectionOptionHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpConnectionOptionHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpConnectionOptionHeaderValue, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::Headers::IHttpConnectionOptionHeaderValueCollection> : interface_type<Windows::Foundation::Collections::IVector<ptr<Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpConnectionOptionHeaderValueCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpConnectionOptionHeaderValueCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpCookiePairHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpCookiePairHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpCookiePairHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpCookiePairHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpCookiePairHeaderValue, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::Headers::IHttpCookiePairHeaderValueCollection> : interface_type<Windows::Foundation::Collections::IVector<ptr<Windows::Web::Http::Headers::HttpCookiePairHeaderValue>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Web::Http::Headers::HttpCookiePairHeaderValue>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpCookiePairHeaderValueCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpCookiePairHeaderValueCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpExpectationHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpExpectationHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpExpectationHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpExpectationHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpExpectationHeaderValue, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::Headers::IHttpExpectationHeaderValueCollection> : interface_type<Windows::Foundation::Collections::IVector<ptr<Windows::Web::Http::Headers::HttpExpectationHeaderValue>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Web::Http::Headers::HttpExpectationHeaderValue>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpExpectationHeaderValueCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpExpectationHeaderValueCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpTransferCodingHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpTransferCodingHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpTransferCodingHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpTransferCodingHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpTransferCodingHeaderValue, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::Headers::IHttpTransferCodingHeaderValueCollection> : interface_type<Windows::Foundation::Collections::IVector<ptr<Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Web::Http::Headers::HttpTransferCodingHeaderValue>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpTransferCodingHeaderValueCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpTransferCodingHeaderValueCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpProductInfoHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpProductInfoHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpProductInfoHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpProductInfoHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpProductInfoHeaderValue, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::Headers::IHttpProductInfoHeaderValueCollection> : interface_type<Windows::Foundation::Collections::IVector<ptr<Windows::Web::Http::Headers::HttpProductInfoHeaderValue>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Web::Http::Headers::HttpProductInfoHeaderValue>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpProductInfoHeaderValueCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpProductInfoHeaderValueCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpMethodHeaderValueCollection> : interface_type<Windows::Foundation::Collections::IVector<ptr<Windows::Web::Http::HttpMethod>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Web::Http::HttpMethod>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpMethodHeaderValueCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpMethodHeaderValueCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpChallengeHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpChallengeHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpChallengeHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpChallengeHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpChallengeHeaderValue, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::Headers::IHttpChallengeHeaderValueCollection> : interface_type<Windows::Foundation::Collections::IVector<ptr<Windows::Web::Http::Headers::HttpChallengeHeaderValue>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Web::Http::Headers::HttpChallengeHeaderValue>>> {};
template<> struct def<Windows::Web::Http::Headers::HttpChallengeHeaderValueCollection> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpChallengeHeaderValueCollection, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpDateOrDeltaHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpDateOrDeltaHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpDateOrDeltaHeaderValue, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::Headers::IHttpProductHeaderValueStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpProductHeaderValueFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::IHttpProductHeaderValue> : interface_type<> {};
template<> struct def<Windows::Web::Http::Headers::HttpProductHeaderValue> : class_type<Platform::Object, Windows::Web::Http::Headers::IHttpProductHeaderValue, Windows::Foundation::IStringable>, custom_activators {};

// uuids

template<> struct uuid<Windows::Web::Http::Headers::IHttpContentHeaderCollection> { define_guid(0x40612A44, 0x47AE, 0x4B7E, 0x91, 0x24, 0x69, 0x62, 0x8B, 0x64, 0xAA, 0x18);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpRequestHeaderCollection> { define_guid(0xAF40329B, 0xB544, 0x469B, 0x86, 0xB9, 0xAC, 0x3D, 0x46, 0x6F, 0xEA, 0x36);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpResponseHeaderCollection> { define_guid(0x7A990969, 0xFA3F, 0x41ED, 0xAA, 0xC6, 0xBF, 0x95, 0x79, 0x75, 0xC1, 0x6B);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpContentDispositionHeaderValueStatics> { define_guid(0x29C56067, 0x5A37, 0x46E4, 0xB0, 0x74, 0xC5, 0x17, 0x7D, 0x69, 0xCA, 0x66);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpContentDispositionHeaderValueFactory> { define_guid(0x9915BBC4, 0x456C, 0x4E81, 0x82, 0x95, 0xB2, 0xAB, 0x3C, 0xBC, 0xF5, 0x45);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpContentDispositionHeaderValue> { define_guid(0xF2A2EEDC, 0x2629, 0x4B49, 0x99, 0x8, 0x96, 0xA1, 0x68, 0xE9, 0x36, 0x5E);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpContentCodingHeaderValueStatics> { define_guid(0x94D8602E, 0xF9BF, 0x42F7, 0xAA, 0x46, 0xED, 0x27, 0x2A, 0x41, 0xE2, 0x12);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpContentCodingHeaderValueFactory> { define_guid(0xC53D2BD7, 0x332B, 0x4350, 0x85, 0x10, 0x2E, 0x67, 0xA2, 0x28, 0x9A, 0x5A);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpContentCodingHeaderValue> { define_guid(0xBCF7F92A, 0x9376, 0x4D85, 0xBC, 0xCC, 0x9F, 0x4F, 0x9A, 0xCA, 0xB4, 0x34);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpContentCodingHeaderValueCollection> { define_guid(0x7D221721, 0xA6DB, 0x436E, 0x8E, 0x83, 0x91, 0x59, 0x61, 0x92, 0x81, 0x9C);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpLanguageHeaderValueCollection> { define_guid(0x9EBD7CA3, 0x8219, 0x44F6, 0x99, 0x2, 0x8C, 0x56, 0xDF, 0xD3, 0x34, 0xC);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpContentRangeHeaderValueStatics> { define_guid(0x80A346CA, 0x174C, 0x4FAE, 0x82, 0x1C, 0x13, 0x4C, 0xD2, 0x94, 0xAA, 0x38);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpContentRangeHeaderValueFactory> { define_guid(0x3F5BD691, 0xA03C, 0x4456, 0x9A, 0x6F, 0xEF, 0x27, 0xEC, 0xD0, 0x3C, 0xAE);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpContentRangeHeaderValue> { define_guid(0x4D967D3, 0xA4F6, 0x495C, 0x95, 0x30, 0x85, 0x79, 0xFC, 0xBA, 0x8A, 0xA9);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpMediaTypeHeaderValueStatics> { define_guid(0xE04D83DF, 0x1D41, 0x4D8C, 0xA2, 0xDE, 0x6F, 0xD2, 0xED, 0x87, 0x39, 0x9B);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpMediaTypeHeaderValueFactory> { define_guid(0xBED747A8, 0xCD17, 0x42DD, 0x93, 0x67, 0xAB, 0x9C, 0x5B, 0x56, 0xDD, 0x7D);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpMediaTypeHeaderValue> { define_guid(0x16B28533, 0xE728, 0x4FCB, 0xBD, 0xB0, 0x8, 0xA4, 0x31, 0xA1, 0x48, 0x44);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpMediaTypeWithQualityHeaderValueStatics> { define_guid(0x5B070CD9, 0xB560, 0x4FC8, 0x98, 0x35, 0x7E, 0x6C, 0xA, 0x65, 0x7B, 0x24);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpMediaTypeWithQualityHeaderValueFactory> { define_guid(0x4C6D20F4, 0x9457, 0x44E6, 0xA3, 0x23, 0xD1, 0x22, 0xB9, 0x58, 0x78, 0xB);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpMediaTypeWithQualityHeaderValue> { define_guid(0x188D5E32, 0x76BE, 0x44A0, 0xB1, 0xCD, 0x20, 0x74, 0xBD, 0xED, 0x2D, 0xDE);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpMediaTypeWithQualityHeaderValueCollection> { define_guid(0x3C0C6B73, 0x1342, 0x4587, 0xA0, 0x56, 0x18, 0xD0, 0x2F, 0xF6, 0x71, 0x65);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpContentCodingWithQualityHeaderValueStatics> { define_guid(0xE8C9357C, 0x8F89, 0x4801, 0x8E, 0x75, 0x4C, 0x9A, 0xBF, 0xC3, 0xDE, 0x71);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpContentCodingWithQualityHeaderValueFactory> { define_guid(0xC45EEE1A, 0xC553, 0x46FC, 0xAD, 0xE2, 0xD7, 0x5C, 0x1D, 0x53, 0xDF, 0x7B);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpContentCodingWithQualityHeaderValue> { define_guid(0x94531CD5, 0x8B13, 0x4D73, 0x86, 0x51, 0xF7, 0x6B, 0x38, 0xF8, 0x84, 0x95);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpContentCodingWithQualityHeaderValueCollection> { define_guid(0x7C0D753E, 0xE899, 0x4378, 0xB5, 0xC8, 0x41, 0x2D, 0x82, 0x7, 0x11, 0xCC);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpLanguageRangeWithQualityHeaderValueStatics> { define_guid(0x2541E146, 0xF308, 0x46F5, 0xB6, 0x95, 0x42, 0xF5, 0x40, 0x24, 0xEC, 0x68);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpLanguageRangeWithQualityHeaderValueFactory> { define_guid(0x7BB83970, 0x780F, 0x4C83, 0x9F, 0xE4, 0xDC, 0x30, 0x87, 0xF6, 0xBD, 0x55);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpLanguageRangeWithQualityHeaderValue> { define_guid(0x7256E102, 0x80, 0x4DB4, 0xA0, 0x83, 0x7D, 0xE7, 0xB2, 0xE5, 0xBA, 0x4C);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpLanguageRangeWithQualityHeaderValueCollection> { define_guid(0x885D5ABD, 0x4B4F, 0x480A, 0x89, 0xCE, 0x8A, 0xED, 0xCE, 0xE6, 0xE3, 0xA0);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpCredentialsHeaderValueStatics> { define_guid(0xA69B2BE6, 0xCE8C, 0x4443, 0xA3, 0x5A, 0x1B, 0x72, 0x7B, 0x13, 0x10, 0x36);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpCredentialsHeaderValueFactory> { define_guid(0xF21D9E91, 0x4D1C, 0x4182, 0xBF, 0xD1, 0x34, 0x47, 0xA, 0x62, 0xF9, 0x50);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpCredentialsHeaderValue> { define_guid(0xC34CC3CB, 0x542E, 0x4177, 0xA6, 0xC7, 0xB6, 0x74, 0xCE, 0x19, 0x3F, 0xBF);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpNameValueHeaderValueStatics> { define_guid(0xFFD4030F, 0x1130, 0x4152, 0x86, 0x59, 0x25, 0x69, 0x9, 0xA9, 0xD1, 0x15);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpNameValueHeaderValueFactory> { define_guid(0x770E2267, 0xCBF8, 0x4736, 0xA9, 0x25, 0x93, 0xFB, 0xE1, 0xC, 0x7C, 0xA8);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpNameValueHeaderValue> { define_guid(0xD8BA7463, 0x5B9A, 0x4D1B, 0x93, 0xF9, 0xAA, 0x5B, 0x44, 0xEC, 0xFD, 0xDF);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpCacheDirectiveHeaderValueCollection> { define_guid(0x9A586B89, 0xD5D0, 0x4FBE, 0xBD, 0x9D, 0xB5, 0xB3, 0x63, 0x68, 0x11, 0xB4);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpConnectionOptionHeaderValueStatics> { define_guid(0xAAA75D37, 0xA946, 0x4B1F, 0x85, 0xAF, 0x48, 0xB6, 0x8B, 0x3C, 0x50, 0xBD);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpConnectionOptionHeaderValueFactory> { define_guid(0xD93CCC1E, 0xB7D, 0x4C3F, 0xA5, 0x8D, 0xA2, 0xA1, 0xBD, 0xEA, 0xBC, 0xA);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpConnectionOptionHeaderValue> { define_guid(0xCB4AF27A, 0x4E90, 0x45EB, 0x8D, 0xCD, 0xFD, 0x14, 0x8, 0xF4, 0xC4, 0x4F);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpConnectionOptionHeaderValueCollection> { define_guid(0xE4F56C1D, 0x5142, 0x4E00, 0x8E, 0xF, 0x1, 0x95, 0x9, 0x33, 0x76, 0x29);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpCookiePairHeaderValueStatics> { define_guid(0x6E866D48, 0x6AF, 0x4462, 0x81, 0x58, 0x99, 0x38, 0x8D, 0x5D, 0xCA, 0x81);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpCookiePairHeaderValueFactory> { define_guid(0x635E326F, 0x146F, 0x4F56, 0xAA, 0x21, 0x2C, 0xB7, 0xD6, 0xD5, 0x8B, 0x1E);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpCookiePairHeaderValue> { define_guid(0xCBD46217, 0x4B29, 0x412B, 0xBD, 0x90, 0xB3, 0xD8, 0x14, 0xAB, 0x8E, 0x1B);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpCookiePairHeaderValueCollection> { define_guid(0xF3F44350, 0x581E, 0x4ECC, 0x9F, 0x59, 0xE5, 0x7, 0xD0, 0x4F, 0x6, 0xE6);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpExpectationHeaderValueStatics> { define_guid(0x3019ABE2, 0xCFE5, 0x473B, 0xA5, 0x7F, 0xFB, 0xA5, 0xB1, 0x4E, 0xB2, 0x57);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpExpectationHeaderValueFactory> { define_guid(0x4EA275CB, 0xD53E, 0x4868, 0x88, 0x56, 0x1E, 0x21, 0xA5, 0x3, 0xD, 0xC0);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpExpectationHeaderValue> { define_guid(0x4CE585CD, 0x3A99, 0x43AF, 0xA2, 0xE6, 0xEC, 0x23, 0x2F, 0xEA, 0x96, 0x58);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpExpectationHeaderValueCollection> { define_guid(0xE78521B3, 0xA0E2, 0x4AC4, 0x9E, 0x66, 0x79, 0x70, 0x6C, 0xB9, 0xFD, 0x58);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpTransferCodingHeaderValueStatics> { define_guid(0x6AB8892A, 0x1A98, 0x4D32, 0xA9, 0x6, 0x74, 0x70, 0xA9, 0x87, 0x5C, 0xE5);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpTransferCodingHeaderValueFactory> { define_guid(0xBB62DFFC, 0xE361, 0x4F08, 0x8E, 0x4F, 0xC9, 0xE7, 0x23, 0xDE, 0x70, 0x3B);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpTransferCodingHeaderValue> { define_guid(0x436F32F9, 0x3DED, 0x42BD, 0xB3, 0x8A, 0x54, 0x96, 0xA2, 0x51, 0x1C, 0xE6);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpTransferCodingHeaderValueCollection> { define_guid(0x202C8C34, 0x2C03, 0x49B8, 0x96, 0x65, 0x73, 0xE2, 0x7C, 0xB2, 0xFC, 0x79);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpProductInfoHeaderValueStatics> { define_guid(0xDB7FD857, 0x327A, 0x4E73, 0x81, 0xE5, 0x70, 0x59, 0xA3, 0x2, 0xB0, 0x42);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpProductInfoHeaderValueFactory> { define_guid(0x24220FBE, 0xEABE, 0x4464, 0xB4, 0x60, 0xEC, 0x1, 0xB, 0x7C, 0x41, 0xE2);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpProductInfoHeaderValue> { define_guid(0x1B1A8732, 0x4C35, 0x486A, 0x96, 0x6F, 0x64, 0x64, 0x89, 0x19, 0x8E, 0x4D);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpProductInfoHeaderValueCollection> { define_guid(0x877DF74A, 0xD69B, 0x44F8, 0xAD, 0x4F, 0x45, 0x3A, 0xF9, 0xC4, 0x2E, 0xD0);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpMethodHeaderValueCollection> { define_guid(0x43BC3FF4, 0x6119, 0x4ADF, 0x93, 0x8C, 0x34, 0xBF, 0xFF, 0xCF, 0x92, 0xED);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpChallengeHeaderValueStatics> { define_guid(0xF3D38A72, 0xFC01, 0x4D01, 0xA0, 0x8, 0xFC, 0xB7, 0xC4, 0x59, 0xD6, 0x35);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpChallengeHeaderValueFactory> { define_guid(0xC452C451, 0xD99C, 0x40AA, 0x93, 0x99, 0x90, 0xEE, 0xB9, 0x8F, 0xC6, 0x13);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpChallengeHeaderValue> { define_guid(0x393361AF, 0xF7D, 0x4820, 0x9F, 0xDD, 0xA2, 0xB9, 0x56, 0xEE, 0xAE, 0xAB);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpChallengeHeaderValueCollection> { define_guid(0xCA9E5F81, 0xAEE0, 0x4353, 0xA1, 0xB, 0xE6, 0x25, 0xBA, 0xBD, 0x64, 0xC2);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpDateOrDeltaHeaderValueStatics> { define_guid(0x7C2659A8, 0x6672, 0x4E90, 0x9A, 0x9A, 0xF3, 0x97, 0x66, 0xF7, 0xF5, 0x76);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpDateOrDeltaHeaderValue> { define_guid(0xEAFCAA6A, 0xC4DC, 0x49E2, 0xA2, 0x7D, 0x4, 0x3A, 0xDF, 0x58, 0x67, 0xA3);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpProductHeaderValueStatics> { define_guid(0x90C33E29, 0xBEFC, 0x4337, 0xBE, 0x62, 0x49, 0xF0, 0x97, 0x97, 0x5F, 0x53);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpProductHeaderValueFactory> { define_guid(0x611AA4F5, 0x82BC, 0x42FB, 0x97, 0x7B, 0xDC, 0x0, 0x53, 0x6E, 0x5E, 0x86);};
template<> struct uuid<Windows::Web::Http::Headers::IHttpProductHeaderValue> { define_guid(0xF4FEEE03, 0xEBD4, 0x4160, 0xB9, 0xFF, 0x80, 0x7C, 0x51, 0x83, 0xB6, 0xE6);};

// types

namespace Windows { namespace Web { namespace Http { namespace Headers {

// IHttpContentHeaderCollection
struct IHttpContentHeaderCollection_raw : IInspectable {
	virtual STDMETHODIMP _get_ContentDisposition(HttpContentDispositionHeaderValue* *value);
	virtual STDMETHODIMP _put_ContentDisposition(HttpContentDispositionHeaderValue* value);
	virtual STDMETHODIMP _get_ContentEncoding(HttpContentCodingHeaderValueCollection* *value);
	virtual STDMETHODIMP _get_ContentLanguage(HttpLanguageHeaderValueCollection* *value);
	virtual STDMETHODIMP _get_ContentLength(Foundation::IReference<unsigned __int64>* *value);
	virtual STDMETHODIMP _put_ContentLength(Foundation::IReference<unsigned __int64>* value);
	virtual STDMETHODIMP _get_ContentLocation(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_ContentLocation(Foundation::Uri* value);
	virtual STDMETHODIMP _get_ContentMD5(Storage::Streams::IBuffer* *value);
	virtual STDMETHODIMP _put_ContentMD5(Storage::Streams::IBuffer* value);
	virtual STDMETHODIMP _get_ContentRange(HttpContentRangeHeaderValue* *value);
	virtual STDMETHODIMP _put_ContentRange(HttpContentRangeHeaderValue* value);
	virtual STDMETHODIMP _get_ContentType(HttpMediaTypeHeaderValue* *value);
	virtual STDMETHODIMP _put_ContentType(HttpMediaTypeHeaderValue* value);
	virtual STDMETHODIMP _get_Expires(Foundation::IReference<Foundation::DateTime>* *value);
	virtual STDMETHODIMP _put_Expires(Foundation::IReference<Foundation::DateTime>* value);
	virtual STDMETHODIMP _get_LastModified(Foundation::IReference<Foundation::DateTime>* *value);
	virtual STDMETHODIMP _put_LastModified(Foundation::IReference<Foundation::DateTime>* value);
	virtual STDMETHODIMP _Append(HSTRING name, HSTRING value);
	virtual STDMETHODIMP _TryAppendWithoutValidation(HSTRING name, HSTRING value, bool *succeeded);
};
template<typename X> struct IHttpContentHeaderCollection_adaptor : X {
	union {
		struct : property {
			ptr<HttpContentDispositionHeaderValue> get() { HttpContentDispositionHeaderValue* value; hrcheck(enc(&IHttpContentHeaderCollection_adaptor::ContentDisposition)->_get_ContentDisposition(&value)); return from_abi(value); }
			ptr<HttpContentDispositionHeaderValue> operator()() { return get(); }
			operator ptr<HttpContentDispositionHeaderValue> () { return get(); }
			ptr<HttpContentDispositionHeaderValue> operator->() { return get(); }
			void put(pptr<HttpContentDispositionHeaderValue> value) { hrcheck(enc(&IHttpContentHeaderCollection_adaptor::ContentDisposition)->_put_ContentDisposition(value)); }
			void operator=(pptr<HttpContentDispositionHeaderValue> value) { put(value); }
			void operator()(pptr<HttpContentDispositionHeaderValue> value) { put(value); }
		} ContentDisposition;
		struct : property {
			ptr<HttpContentCodingHeaderValueCollection> get() { HttpContentCodingHeaderValueCollection* value; hrcheck(enc(&IHttpContentHeaderCollection_adaptor::ContentEncoding)->_get_ContentEncoding(&value)); return from_abi(value); }
			ptr<HttpContentCodingHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpContentCodingHeaderValueCollection> () { return get(); }
			ptr<HttpContentCodingHeaderValueCollection> operator->() { return get(); }
		} ContentEncoding;
		struct : property {
			ptr<HttpLanguageHeaderValueCollection> get() { HttpLanguageHeaderValueCollection* value; hrcheck(enc(&IHttpContentHeaderCollection_adaptor::ContentLanguage)->_get_ContentLanguage(&value)); return from_abi(value); }
			ptr<HttpLanguageHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpLanguageHeaderValueCollection> () { return get(); }
			ptr<HttpLanguageHeaderValueCollection> operator->() { return get(); }
		} ContentLanguage;
		struct : property {
			ptr<Foundation::IReference<unsigned __int64>> get() { Foundation::IReference<unsigned __int64>* value; hrcheck(enc(&IHttpContentHeaderCollection_adaptor::ContentLength)->_get_ContentLength(&value)); return from_abi(value); }
			ptr<Foundation::IReference<unsigned __int64>> operator()() { return get(); }
			operator ptr<Foundation::IReference<unsigned __int64>> () { return get(); }
			ptr<Foundation::IReference<unsigned __int64>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<unsigned __int64>> value) { hrcheck(enc(&IHttpContentHeaderCollection_adaptor::ContentLength)->_put_ContentLength(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<unsigned __int64>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<unsigned __int64>> value) { put(to_abi(value)); }
		} ContentLength;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IHttpContentHeaderCollection_adaptor::ContentLocation)->_get_ContentLocation(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IHttpContentHeaderCollection_adaptor::ContentLocation)->_put_ContentLocation(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} ContentLocation;
		struct : property {
			ptr<Storage::Streams::IBuffer> get() { Storage::Streams::IBuffer* value; hrcheck(enc(&IHttpContentHeaderCollection_adaptor::ContentMD5)->_get_ContentMD5(&value)); return from_abi(value); }
			ptr<Storage::Streams::IBuffer> operator()() { return get(); }
			operator ptr<Storage::Streams::IBuffer> () { return get(); }
			ptr<Storage::Streams::IBuffer> operator->() { return get(); }
			void put(pptr<Storage::Streams::IBuffer> value) { hrcheck(enc(&IHttpContentHeaderCollection_adaptor::ContentMD5)->_put_ContentMD5(value)); }
			void operator=(pptr<Storage::Streams::IBuffer> value) { put(value); }
			void operator()(pptr<Storage::Streams::IBuffer> value) { put(value); }
		} ContentMD5;
		struct : property {
			ptr<HttpContentRangeHeaderValue> get() { HttpContentRangeHeaderValue* value; hrcheck(enc(&IHttpContentHeaderCollection_adaptor::ContentRange)->_get_ContentRange(&value)); return from_abi(value); }
			ptr<HttpContentRangeHeaderValue> operator()() { return get(); }
			operator ptr<HttpContentRangeHeaderValue> () { return get(); }
			ptr<HttpContentRangeHeaderValue> operator->() { return get(); }
			void put(pptr<HttpContentRangeHeaderValue> value) { hrcheck(enc(&IHttpContentHeaderCollection_adaptor::ContentRange)->_put_ContentRange(value)); }
			void operator=(pptr<HttpContentRangeHeaderValue> value) { put(value); }
			void operator()(pptr<HttpContentRangeHeaderValue> value) { put(value); }
		} ContentRange;
		struct : property {
			ptr<HttpMediaTypeHeaderValue> get() { HttpMediaTypeHeaderValue* value; hrcheck(enc(&IHttpContentHeaderCollection_adaptor::ContentType)->_get_ContentType(&value)); return from_abi(value); }
			ptr<HttpMediaTypeHeaderValue> operator()() { return get(); }
			operator ptr<HttpMediaTypeHeaderValue> () { return get(); }
			ptr<HttpMediaTypeHeaderValue> operator->() { return get(); }
			void put(pptr<HttpMediaTypeHeaderValue> value) { hrcheck(enc(&IHttpContentHeaderCollection_adaptor::ContentType)->_put_ContentType(value)); }
			void operator=(pptr<HttpMediaTypeHeaderValue> value) { put(value); }
			void operator()(pptr<HttpMediaTypeHeaderValue> value) { put(value); }
		} ContentType;
		struct : property {
			ptr<Foundation::IReference<Foundation::DateTime>> get() { Foundation::IReference<Foundation::DateTime>* value; hrcheck(enc(&IHttpContentHeaderCollection_adaptor::Expires)->_get_Expires(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::DateTime>> value) { hrcheck(enc(&IHttpContentHeaderCollection_adaptor::Expires)->_put_Expires(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
		} Expires;
		struct : property {
			ptr<Foundation::IReference<Foundation::DateTime>> get() { Foundation::IReference<Foundation::DateTime>* value; hrcheck(enc(&IHttpContentHeaderCollection_adaptor::LastModified)->_get_LastModified(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::DateTime>> value) { hrcheck(enc(&IHttpContentHeaderCollection_adaptor::LastModified)->_put_LastModified(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
		} LastModified;
	};
	void Append(hstring_ref name, hstring_ref value) { hrcheck(X::get()->_Append(name, value)); }
	bool TryAppendWithoutValidation(hstring_ref name, hstring_ref value) { bool succeeded; hrcheck(X::get()->_TryAppendWithoutValidation(name, value, &succeeded)); return succeeded; }
	IHttpContentHeaderCollection_adaptor() {}
};
template<typename X> struct adapt<IHttpContentHeaderCollection, X> : Windows::Web::Http::Headers::IHttpContentHeaderCollection_adaptor<X> { typedef adapt IHttpContentHeaderCollection; };
struct IHttpContentHeaderCollection : IHttpContentHeaderCollection_raw, generate<IHttpContentHeaderCollection> {};

// HttpContentHeaderCollection
template<typename X> struct statics<HttpContentHeaderCollection, X> : X {
	typedef typename X::root_type HttpContentHeaderCollection;
};
struct HttpContentHeaderCollection : generate<HttpContentHeaderCollection> {};

// IHttpRequestHeaderCollection
struct IHttpRequestHeaderCollection_raw : IInspectable {
	virtual STDMETHODIMP _get_Accept(HttpMediaTypeWithQualityHeaderValueCollection* *value);
	virtual STDMETHODIMP _get_AcceptEncoding(HttpContentCodingWithQualityHeaderValueCollection* *value);
	virtual STDMETHODIMP _get_AcceptLanguage(HttpLanguageRangeWithQualityHeaderValueCollection* *value);
	virtual STDMETHODIMP _get_Authorization(HttpCredentialsHeaderValue* *value);
	virtual STDMETHODIMP _put_Authorization(HttpCredentialsHeaderValue* value);
	virtual STDMETHODIMP _get_CacheControl(HttpCacheDirectiveHeaderValueCollection* *value);
	virtual STDMETHODIMP _get_Connection(HttpConnectionOptionHeaderValueCollection* *value);
	virtual STDMETHODIMP _get_Cookie(HttpCookiePairHeaderValueCollection* *value);
	virtual STDMETHODIMP _get_Date(Foundation::IReference<Foundation::DateTime>* *value);
	virtual STDMETHODIMP _put_Date(Foundation::IReference<Foundation::DateTime>* value);
	virtual STDMETHODIMP _get_Expect(HttpExpectationHeaderValueCollection* *value);
	virtual STDMETHODIMP _get_From(HSTRING *value);
	virtual STDMETHODIMP _put_From(HSTRING value);
	virtual STDMETHODIMP _get_Host(Networking::HostName* *value);
	virtual STDMETHODIMP _put_Host(Networking::HostName* value);
	virtual STDMETHODIMP _get_IfModifiedSince(Foundation::IReference<Foundation::DateTime>* *value);
	virtual STDMETHODIMP _put_IfModifiedSince(Foundation::IReference<Foundation::DateTime>* value);
	virtual STDMETHODIMP _get_IfUnmodifiedSince(Foundation::IReference<Foundation::DateTime>* *value);
	virtual STDMETHODIMP _put_IfUnmodifiedSince(Foundation::IReference<Foundation::DateTime>* value);
	virtual STDMETHODIMP _get_MaxForwards(Foundation::IReference<unsigned>* *value);
	virtual STDMETHODIMP _put_MaxForwards(Foundation::IReference<unsigned>* value);
	virtual STDMETHODIMP _get_ProxyAuthorization(HttpCredentialsHeaderValue* *value);
	virtual STDMETHODIMP _put_ProxyAuthorization(HttpCredentialsHeaderValue* value);
	virtual STDMETHODIMP _get_Referer(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_Referer(Foundation::Uri* value);
	virtual STDMETHODIMP _get_TransferEncoding(HttpTransferCodingHeaderValueCollection* *value);
	virtual STDMETHODIMP _get_UserAgent(HttpProductInfoHeaderValueCollection* *value);
	virtual STDMETHODIMP _Append(HSTRING name, HSTRING value);
	virtual STDMETHODIMP _TryAppendWithoutValidation(HSTRING name, HSTRING value, bool *succeeded);
};
template<typename X> struct IHttpRequestHeaderCollection_adaptor : X {
	union {
		struct : property {
			ptr<HttpMediaTypeWithQualityHeaderValueCollection> get() { HttpMediaTypeWithQualityHeaderValueCollection* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::Accept)->_get_Accept(&value)); return from_abi(value); }
			ptr<HttpMediaTypeWithQualityHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpMediaTypeWithQualityHeaderValueCollection> () { return get(); }
			ptr<HttpMediaTypeWithQualityHeaderValueCollection> operator->() { return get(); }
		} Accept;
		struct : property {
			ptr<HttpContentCodingWithQualityHeaderValueCollection> get() { HttpContentCodingWithQualityHeaderValueCollection* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::AcceptEncoding)->_get_AcceptEncoding(&value)); return from_abi(value); }
			ptr<HttpContentCodingWithQualityHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpContentCodingWithQualityHeaderValueCollection> () { return get(); }
			ptr<HttpContentCodingWithQualityHeaderValueCollection> operator->() { return get(); }
		} AcceptEncoding;
		struct : property {
			ptr<HttpLanguageRangeWithQualityHeaderValueCollection> get() { HttpLanguageRangeWithQualityHeaderValueCollection* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::AcceptLanguage)->_get_AcceptLanguage(&value)); return from_abi(value); }
			ptr<HttpLanguageRangeWithQualityHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpLanguageRangeWithQualityHeaderValueCollection> () { return get(); }
			ptr<HttpLanguageRangeWithQualityHeaderValueCollection> operator->() { return get(); }
		} AcceptLanguage;
		struct : property {
			ptr<HttpCredentialsHeaderValue> get() { HttpCredentialsHeaderValue* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::Authorization)->_get_Authorization(&value)); return from_abi(value); }
			ptr<HttpCredentialsHeaderValue> operator()() { return get(); }
			operator ptr<HttpCredentialsHeaderValue> () { return get(); }
			ptr<HttpCredentialsHeaderValue> operator->() { return get(); }
			void put(pptr<HttpCredentialsHeaderValue> value) { hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::Authorization)->_put_Authorization(value)); }
			void operator=(pptr<HttpCredentialsHeaderValue> value) { put(value); }
			void operator()(pptr<HttpCredentialsHeaderValue> value) { put(value); }
		} Authorization;
		struct : property {
			ptr<HttpCacheDirectiveHeaderValueCollection> get() { HttpCacheDirectiveHeaderValueCollection* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::CacheControl)->_get_CacheControl(&value)); return from_abi(value); }
			ptr<HttpCacheDirectiveHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpCacheDirectiveHeaderValueCollection> () { return get(); }
			ptr<HttpCacheDirectiveHeaderValueCollection> operator->() { return get(); }
		} CacheControl;
		struct : property {
			ptr<HttpConnectionOptionHeaderValueCollection> get() { HttpConnectionOptionHeaderValueCollection* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::Connection)->_get_Connection(&value)); return from_abi(value); }
			ptr<HttpConnectionOptionHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpConnectionOptionHeaderValueCollection> () { return get(); }
			ptr<HttpConnectionOptionHeaderValueCollection> operator->() { return get(); }
		} Connection;
		struct : property {
			ptr<HttpCookiePairHeaderValueCollection> get() { HttpCookiePairHeaderValueCollection* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::Cookie)->_get_Cookie(&value)); return from_abi(value); }
			ptr<HttpCookiePairHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpCookiePairHeaderValueCollection> () { return get(); }
			ptr<HttpCookiePairHeaderValueCollection> operator->() { return get(); }
		} Cookie;
		struct : property {
			ptr<Foundation::IReference<Foundation::DateTime>> get() { Foundation::IReference<Foundation::DateTime>* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::Date)->_get_Date(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::DateTime>> value) { hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::Date)->_put_Date(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
		} Date;
		struct : property {
			ptr<HttpExpectationHeaderValueCollection> get() { HttpExpectationHeaderValueCollection* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::Expect)->_get_Expect(&value)); return from_abi(value); }
			ptr<HttpExpectationHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpExpectationHeaderValueCollection> () { return get(); }
			ptr<HttpExpectationHeaderValueCollection> operator->() { return get(); }
		} Expect;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::From)->_get_From(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::From)->_put_From(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} From;
		struct : property {
			ptr<Networking::HostName> get() { Networking::HostName* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::Host)->_get_Host(&value)); return from_abi(value); }
			ptr<Networking::HostName> operator()() { return get(); }
			operator ptr<Networking::HostName> () { return get(); }
			ptr<Networking::HostName> operator->() { return get(); }
			void put(pptr<Networking::HostName> value) { hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::Host)->_put_Host(value)); }
			void operator=(pptr<Networking::HostName> value) { put(value); }
			void operator()(pptr<Networking::HostName> value) { put(value); }
		} Host;
		struct : property {
			ptr<Foundation::IReference<Foundation::DateTime>> get() { Foundation::IReference<Foundation::DateTime>* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::IfModifiedSince)->_get_IfModifiedSince(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::DateTime>> value) { hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::IfModifiedSince)->_put_IfModifiedSince(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
		} IfModifiedSince;
		struct : property {
			ptr<Foundation::IReference<Foundation::DateTime>> get() { Foundation::IReference<Foundation::DateTime>* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::IfUnmodifiedSince)->_get_IfUnmodifiedSince(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::DateTime>> value) { hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::IfUnmodifiedSince)->_put_IfUnmodifiedSince(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
		} IfUnmodifiedSince;
		struct : property {
			ptr<Foundation::IReference<unsigned>> get() { Foundation::IReference<unsigned>* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::MaxForwards)->_get_MaxForwards(&value)); return from_abi(value); }
			ptr<Foundation::IReference<unsigned>> operator()() { return get(); }
			operator ptr<Foundation::IReference<unsigned>> () { return get(); }
			ptr<Foundation::IReference<unsigned>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<unsigned>> value) { hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::MaxForwards)->_put_MaxForwards(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<unsigned>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<unsigned>> value) { put(to_abi(value)); }
		} MaxForwards;
		struct : property {
			ptr<HttpCredentialsHeaderValue> get() { HttpCredentialsHeaderValue* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::ProxyAuthorization)->_get_ProxyAuthorization(&value)); return from_abi(value); }
			ptr<HttpCredentialsHeaderValue> operator()() { return get(); }
			operator ptr<HttpCredentialsHeaderValue> () { return get(); }
			ptr<HttpCredentialsHeaderValue> operator->() { return get(); }
			void put(pptr<HttpCredentialsHeaderValue> value) { hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::ProxyAuthorization)->_put_ProxyAuthorization(value)); }
			void operator=(pptr<HttpCredentialsHeaderValue> value) { put(value); }
			void operator()(pptr<HttpCredentialsHeaderValue> value) { put(value); }
		} ProxyAuthorization;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::Referer)->_get_Referer(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::Referer)->_put_Referer(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} Referer;
		struct : property {
			ptr<HttpTransferCodingHeaderValueCollection> get() { HttpTransferCodingHeaderValueCollection* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::TransferEncoding)->_get_TransferEncoding(&value)); return from_abi(value); }
			ptr<HttpTransferCodingHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpTransferCodingHeaderValueCollection> () { return get(); }
			ptr<HttpTransferCodingHeaderValueCollection> operator->() { return get(); }
		} TransferEncoding;
		struct : property {
			ptr<HttpProductInfoHeaderValueCollection> get() { HttpProductInfoHeaderValueCollection* value; hrcheck(enc(&IHttpRequestHeaderCollection_adaptor::UserAgent)->_get_UserAgent(&value)); return from_abi(value); }
			ptr<HttpProductInfoHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpProductInfoHeaderValueCollection> () { return get(); }
			ptr<HttpProductInfoHeaderValueCollection> operator->() { return get(); }
		} UserAgent;
	};
	void Append(hstring_ref name, hstring_ref value) { hrcheck(X::get()->_Append(name, value)); }
	bool TryAppendWithoutValidation(hstring_ref name, hstring_ref value) { bool succeeded; hrcheck(X::get()->_TryAppendWithoutValidation(name, value, &succeeded)); return succeeded; }
	IHttpRequestHeaderCollection_adaptor() {}
};
template<typename X> struct adapt<IHttpRequestHeaderCollection, X> : Windows::Web::Http::Headers::IHttpRequestHeaderCollection_adaptor<X> { typedef adapt IHttpRequestHeaderCollection; };
struct IHttpRequestHeaderCollection : IHttpRequestHeaderCollection_raw, generate<IHttpRequestHeaderCollection> {};

// HttpRequestHeaderCollection
template<typename X> struct statics<HttpRequestHeaderCollection, X> : X {
	typedef typename X::root_type HttpRequestHeaderCollection;
};
struct HttpRequestHeaderCollection : generate<HttpRequestHeaderCollection> {};

// IHttpResponseHeaderCollection
struct IHttpResponseHeaderCollection_raw : IInspectable {
	virtual STDMETHODIMP _get_Age(Foundation::IReference<Foundation::TimeSpan>* *value);
	virtual STDMETHODIMP _put_Age(Foundation::IReference<Foundation::TimeSpan>* value);
	virtual STDMETHODIMP _get_Allow(HttpMethodHeaderValueCollection* *value);
	virtual STDMETHODIMP _get_CacheControl(HttpCacheDirectiveHeaderValueCollection* *value);
	virtual STDMETHODIMP _get_Connection(HttpConnectionOptionHeaderValueCollection* *value);
	virtual STDMETHODIMP _get_Date(Foundation::IReference<Foundation::DateTime>* *value);
	virtual STDMETHODIMP _put_Date(Foundation::IReference<Foundation::DateTime>* value);
	virtual STDMETHODIMP _get_Location(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_Location(Foundation::Uri* value);
	virtual STDMETHODIMP _get_ProxyAuthenticate(HttpChallengeHeaderValueCollection* *value);
	virtual STDMETHODIMP _get_RetryAfter(HttpDateOrDeltaHeaderValue* *value);
	virtual STDMETHODIMP _put_RetryAfter(HttpDateOrDeltaHeaderValue* value);
	virtual STDMETHODIMP _get_TransferEncoding(HttpTransferCodingHeaderValueCollection* *value);
	virtual STDMETHODIMP _get_WwwAuthenticate(HttpChallengeHeaderValueCollection* *value);
	virtual STDMETHODIMP _Append(HSTRING name, HSTRING value);
	virtual STDMETHODIMP _TryAppendWithoutValidation(HSTRING name, HSTRING value, bool *succeeded);
};
template<typename X> struct IHttpResponseHeaderCollection_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IHttpResponseHeaderCollection_adaptor::Age)->_get_Age(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&IHttpResponseHeaderCollection_adaptor::Age)->_put_Age(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} Age;
		struct : property {
			ptr<HttpMethodHeaderValueCollection> get() { HttpMethodHeaderValueCollection* value; hrcheck(enc(&IHttpResponseHeaderCollection_adaptor::Allow)->_get_Allow(&value)); return from_abi(value); }
			ptr<HttpMethodHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpMethodHeaderValueCollection> () { return get(); }
			ptr<HttpMethodHeaderValueCollection> operator->() { return get(); }
		} Allow;
		struct : property {
			ptr<HttpCacheDirectiveHeaderValueCollection> get() { HttpCacheDirectiveHeaderValueCollection* value; hrcheck(enc(&IHttpResponseHeaderCollection_adaptor::CacheControl)->_get_CacheControl(&value)); return from_abi(value); }
			ptr<HttpCacheDirectiveHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpCacheDirectiveHeaderValueCollection> () { return get(); }
			ptr<HttpCacheDirectiveHeaderValueCollection> operator->() { return get(); }
		} CacheControl;
		struct : property {
			ptr<HttpConnectionOptionHeaderValueCollection> get() { HttpConnectionOptionHeaderValueCollection* value; hrcheck(enc(&IHttpResponseHeaderCollection_adaptor::Connection)->_get_Connection(&value)); return from_abi(value); }
			ptr<HttpConnectionOptionHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpConnectionOptionHeaderValueCollection> () { return get(); }
			ptr<HttpConnectionOptionHeaderValueCollection> operator->() { return get(); }
		} Connection;
		struct : property {
			ptr<Foundation::IReference<Foundation::DateTime>> get() { Foundation::IReference<Foundation::DateTime>* value; hrcheck(enc(&IHttpResponseHeaderCollection_adaptor::Date)->_get_Date(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::DateTime>> value) { hrcheck(enc(&IHttpResponseHeaderCollection_adaptor::Date)->_put_Date(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
		} Date;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IHttpResponseHeaderCollection_adaptor::Location)->_get_Location(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IHttpResponseHeaderCollection_adaptor::Location)->_put_Location(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} Location;
		struct : property {
			ptr<HttpChallengeHeaderValueCollection> get() { HttpChallengeHeaderValueCollection* value; hrcheck(enc(&IHttpResponseHeaderCollection_adaptor::ProxyAuthenticate)->_get_ProxyAuthenticate(&value)); return from_abi(value); }
			ptr<HttpChallengeHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpChallengeHeaderValueCollection> () { return get(); }
			ptr<HttpChallengeHeaderValueCollection> operator->() { return get(); }
		} ProxyAuthenticate;
		struct : property {
			ptr<HttpDateOrDeltaHeaderValue> get() { HttpDateOrDeltaHeaderValue* value; hrcheck(enc(&IHttpResponseHeaderCollection_adaptor::RetryAfter)->_get_RetryAfter(&value)); return from_abi(value); }
			ptr<HttpDateOrDeltaHeaderValue> operator()() { return get(); }
			operator ptr<HttpDateOrDeltaHeaderValue> () { return get(); }
			ptr<HttpDateOrDeltaHeaderValue> operator->() { return get(); }
			void put(pptr<HttpDateOrDeltaHeaderValue> value) { hrcheck(enc(&IHttpResponseHeaderCollection_adaptor::RetryAfter)->_put_RetryAfter(value)); }
			void operator=(pptr<HttpDateOrDeltaHeaderValue> value) { put(value); }
			void operator()(pptr<HttpDateOrDeltaHeaderValue> value) { put(value); }
		} RetryAfter;
		struct : property {
			ptr<HttpTransferCodingHeaderValueCollection> get() { HttpTransferCodingHeaderValueCollection* value; hrcheck(enc(&IHttpResponseHeaderCollection_adaptor::TransferEncoding)->_get_TransferEncoding(&value)); return from_abi(value); }
			ptr<HttpTransferCodingHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpTransferCodingHeaderValueCollection> () { return get(); }
			ptr<HttpTransferCodingHeaderValueCollection> operator->() { return get(); }
		} TransferEncoding;
		struct : property {
			ptr<HttpChallengeHeaderValueCollection> get() { HttpChallengeHeaderValueCollection* value; hrcheck(enc(&IHttpResponseHeaderCollection_adaptor::WwwAuthenticate)->_get_WwwAuthenticate(&value)); return from_abi(value); }
			ptr<HttpChallengeHeaderValueCollection> operator()() { return get(); }
			operator ptr<HttpChallengeHeaderValueCollection> () { return get(); }
			ptr<HttpChallengeHeaderValueCollection> operator->() { return get(); }
		} WwwAuthenticate;
	};
	void Append(hstring_ref name, hstring_ref value) { hrcheck(X::get()->_Append(name, value)); }
	bool TryAppendWithoutValidation(hstring_ref name, hstring_ref value) { bool succeeded; hrcheck(X::get()->_TryAppendWithoutValidation(name, value, &succeeded)); return succeeded; }
	IHttpResponseHeaderCollection_adaptor() {}
};
template<typename X> struct adapt<IHttpResponseHeaderCollection, X> : Windows::Web::Http::Headers::IHttpResponseHeaderCollection_adaptor<X> { typedef adapt IHttpResponseHeaderCollection; };
struct IHttpResponseHeaderCollection : IHttpResponseHeaderCollection_raw, generate<IHttpResponseHeaderCollection> {};

// HttpResponseHeaderCollection
template<typename X> struct statics<HttpResponseHeaderCollection, X> : X {
	typedef typename X::root_type HttpResponseHeaderCollection;
};
struct HttpResponseHeaderCollection : generate<HttpResponseHeaderCollection> {};

// IHttpContentDispositionHeaderValueStatics
struct IHttpContentDispositionHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpContentDispositionHeaderValue* *contentDispositionHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpContentDispositionHeaderValue* *contentDispositionHeaderValue, bool *succeeded);
};

// IHttpContentDispositionHeaderValueFactory
struct IHttpContentDispositionHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _Create(HSTRING dispositionType, HttpContentDispositionHeaderValue* *contentDispositionHeaderValue);
};

// IHttpContentDispositionHeaderValue
struct IHttpContentDispositionHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_DispositionType(HSTRING *value);
	virtual STDMETHODIMP _put_DispositionType(HSTRING value);
	virtual STDMETHODIMP _get_FileName(HSTRING *value);
	virtual STDMETHODIMP _put_FileName(HSTRING value);
	virtual STDMETHODIMP _get_FileNameStar(HSTRING *value);
	virtual STDMETHODIMP _put_FileNameStar(HSTRING value);
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _put_Name(HSTRING value);
	virtual STDMETHODIMP _get_Parameters(Foundation::Collections::IVector<HttpNameValueHeaderValue*>* *value);
	virtual STDMETHODIMP _get_Size(Foundation::IReference<unsigned __int64>* *value);
	virtual STDMETHODIMP _put_Size(Foundation::IReference<unsigned __int64>* value);
};
template<typename X> struct IHttpContentDispositionHeaderValue_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpContentDispositionHeaderValue_adaptor::DispositionType)->_get_DispositionType(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IHttpContentDispositionHeaderValue_adaptor::DispositionType)->_put_DispositionType(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DispositionType;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpContentDispositionHeaderValue_adaptor::FileName)->_get_FileName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IHttpContentDispositionHeaderValue_adaptor::FileName)->_put_FileName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} FileName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpContentDispositionHeaderValue_adaptor::FileNameStar)->_get_FileNameStar(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IHttpContentDispositionHeaderValue_adaptor::FileNameStar)->_put_FileNameStar(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} FileNameStar;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpContentDispositionHeaderValue_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IHttpContentDispositionHeaderValue_adaptor::Name)->_put_Name(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Name;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> get() { Foundation::Collections::IVector<HttpNameValueHeaderValue*>* value; hrcheck(enc(&IHttpContentDispositionHeaderValue_adaptor::Parameters)->_get_Parameters(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> operator->() { return get(); }
		} Parameters;
		struct : property {
			ptr<Foundation::IReference<unsigned __int64>> get() { Foundation::IReference<unsigned __int64>* value; hrcheck(enc(&IHttpContentDispositionHeaderValue_adaptor::Size)->_get_Size(&value)); return from_abi(value); }
			ptr<Foundation::IReference<unsigned __int64>> operator()() { return get(); }
			operator ptr<Foundation::IReference<unsigned __int64>> () { return get(); }
			ptr<Foundation::IReference<unsigned __int64>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<unsigned __int64>> value) { hrcheck(enc(&IHttpContentDispositionHeaderValue_adaptor::Size)->_put_Size(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<unsigned __int64>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<unsigned __int64>> value) { put(to_abi(value)); }
		} Size;
	};
	IHttpContentDispositionHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpContentDispositionHeaderValue, X> : Windows::Web::Http::Headers::IHttpContentDispositionHeaderValue_adaptor<X> { typedef adapt IHttpContentDispositionHeaderValue; };
struct IHttpContentDispositionHeaderValue : IHttpContentDispositionHeaderValue_raw, generate<IHttpContentDispositionHeaderValue> {};

// HttpContentDispositionHeaderValue
template<typename> struct HttpContentDispositionHeaderValue_statics {
	static ptr<HttpContentDispositionHeaderValue> Parse(hstring_ref input) { HttpContentDispositionHeaderValue* contentDispositionHeaderValue; hrcheck(get_activation_factory<HttpContentDispositionHeaderValue, IHttpContentDispositionHeaderValueStatics>()->_Parse(input, &contentDispositionHeaderValue)); return from_abi(contentDispositionHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpContentDispositionHeaderValue> *contentDispositionHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpContentDispositionHeaderValue, IHttpContentDispositionHeaderValueStatics>()->_TryParse(input, contentDispositionHeaderValue, &succeeded)); return succeeded; }
	static HttpContentDispositionHeaderValue *activate(hstring_ref dispositionType) { HttpContentDispositionHeaderValue *contentDispositionHeaderValue; hrcheck(get_activation_factory<HttpContentDispositionHeaderValue, IHttpContentDispositionHeaderValueFactory>()->_Create(dispositionType, &contentDispositionHeaderValue)); return contentDispositionHeaderValue; }
};

template<typename X> struct statics<HttpContentDispositionHeaderValue, X> : X, Windows::Web::Http::Headers::HttpContentDispositionHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpContentDispositionHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpContentDispositionHeaderValue;
};
struct HttpContentDispositionHeaderValue : generate<HttpContentDispositionHeaderValue> {};

// IHttpContentCodingHeaderValueStatics
struct IHttpContentCodingHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpContentCodingHeaderValue* *contentCodingHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpContentCodingHeaderValue* *contentCodingHeaderValue, bool *succeeded);
};

// IHttpContentCodingHeaderValueFactory
struct IHttpContentCodingHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _Create(HSTRING contentCoding, HttpContentCodingHeaderValue* *contentCodingHeaderValue);
};

// IHttpContentCodingHeaderValue
struct IHttpContentCodingHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_ContentCoding(HSTRING *value);
};
template<typename X> struct IHttpContentCodingHeaderValue_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpContentCodingHeaderValue_adaptor::ContentCoding)->_get_ContentCoding(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ContentCoding;
	};
	IHttpContentCodingHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpContentCodingHeaderValue, X> : Windows::Web::Http::Headers::IHttpContentCodingHeaderValue_adaptor<X> { typedef adapt IHttpContentCodingHeaderValue; };
struct IHttpContentCodingHeaderValue : IHttpContentCodingHeaderValue_raw, generate<IHttpContentCodingHeaderValue> {};

// HttpContentCodingHeaderValue
template<typename> struct HttpContentCodingHeaderValue_statics {
	static ptr<HttpContentCodingHeaderValue> Parse(hstring_ref input) { HttpContentCodingHeaderValue* contentCodingHeaderValue; hrcheck(get_activation_factory<HttpContentCodingHeaderValue, IHttpContentCodingHeaderValueStatics>()->_Parse(input, &contentCodingHeaderValue)); return from_abi(contentCodingHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpContentCodingHeaderValue> *contentCodingHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpContentCodingHeaderValue, IHttpContentCodingHeaderValueStatics>()->_TryParse(input, contentCodingHeaderValue, &succeeded)); return succeeded; }
	static HttpContentCodingHeaderValue *activate(hstring_ref contentCoding) { HttpContentCodingHeaderValue *contentCodingHeaderValue; hrcheck(get_activation_factory<HttpContentCodingHeaderValue, IHttpContentCodingHeaderValueFactory>()->_Create(contentCoding, &contentCodingHeaderValue)); return contentCodingHeaderValue; }
};

template<typename X> struct statics<HttpContentCodingHeaderValue, X> : X, Windows::Web::Http::Headers::HttpContentCodingHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpContentCodingHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpContentCodingHeaderValue;
};
struct HttpContentCodingHeaderValue : generate<HttpContentCodingHeaderValue> {};

// IHttpContentCodingHeaderValueCollection
struct IHttpContentCodingHeaderValueCollection_raw : IInspectable {
	virtual STDMETHODIMP _ParseAdd(HSTRING input);
	virtual STDMETHODIMP _TryParseAdd(HSTRING input, bool *succeeded);
};
template<typename X> struct IHttpContentCodingHeaderValueCollection_adaptor : X {
	void ParseAdd(hstring_ref input) { hrcheck(X::get()->_ParseAdd(input)); }
	bool TryParseAdd(hstring_ref input) { bool succeeded; hrcheck(X::get()->_TryParseAdd(input, &succeeded)); return succeeded; }
};
template<typename X> struct adapt<IHttpContentCodingHeaderValueCollection, X> : Windows::Web::Http::Headers::IHttpContentCodingHeaderValueCollection_adaptor<X> { typedef adapt IHttpContentCodingHeaderValueCollection; };
struct IHttpContentCodingHeaderValueCollection : IHttpContentCodingHeaderValueCollection_raw, generate<IHttpContentCodingHeaderValueCollection> {};

// HttpContentCodingHeaderValueCollection
template<typename X> struct statics<HttpContentCodingHeaderValueCollection, X> : X {
	typedef typename X::root_type HttpContentCodingHeaderValueCollection;
};
struct HttpContentCodingHeaderValueCollection : generate<HttpContentCodingHeaderValueCollection> {};

// IHttpLanguageHeaderValueCollection
struct IHttpLanguageHeaderValueCollection_raw : IInspectable {
	virtual STDMETHODIMP _ParseAdd(HSTRING input);
	virtual STDMETHODIMP _TryParseAdd(HSTRING input, bool *succeeded);
};
template<typename X> struct IHttpLanguageHeaderValueCollection_adaptor : X {
	void ParseAdd(hstring_ref input) { hrcheck(X::get()->_ParseAdd(input)); }
	bool TryParseAdd(hstring_ref input) { bool succeeded; hrcheck(X::get()->_TryParseAdd(input, &succeeded)); return succeeded; }
};
template<typename X> struct adapt<IHttpLanguageHeaderValueCollection, X> : Windows::Web::Http::Headers::IHttpLanguageHeaderValueCollection_adaptor<X> { typedef adapt IHttpLanguageHeaderValueCollection; };
struct IHttpLanguageHeaderValueCollection : IHttpLanguageHeaderValueCollection_raw, generate<IHttpLanguageHeaderValueCollection> {};

// HttpLanguageHeaderValueCollection
template<typename X> struct statics<HttpLanguageHeaderValueCollection, X> : X {
	typedef typename X::root_type HttpLanguageHeaderValueCollection;
};
struct HttpLanguageHeaderValueCollection : generate<HttpLanguageHeaderValueCollection> {};

// IHttpContentRangeHeaderValueStatics
struct IHttpContentRangeHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpContentRangeHeaderValue* *contentRangeHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpContentRangeHeaderValue* *contentRangeHeaderValue, bool *succeeded);
};

// IHttpContentRangeHeaderValueFactory
struct IHttpContentRangeHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromLength(unsigned __int64 length, HttpContentRangeHeaderValue* *contentRangeHeaderValue);
	virtual STDMETHODIMP _CreateFromRange(unsigned __int64 from, unsigned __int64 to, HttpContentRangeHeaderValue* *contentRangeHeaderValue);
	virtual STDMETHODIMP _CreateFromRangeWithLength(unsigned __int64 from, unsigned __int64 to, unsigned __int64 length, HttpContentRangeHeaderValue* *contentRangeHeaderValue);
};

// IHttpContentRangeHeaderValue
struct IHttpContentRangeHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_FirstBytePosition(Foundation::IReference<unsigned __int64>* *value);
	virtual STDMETHODIMP _get_LastBytePosition(Foundation::IReference<unsigned __int64>* *value);
	virtual STDMETHODIMP _get_Length(Foundation::IReference<unsigned __int64>* *value);
	virtual STDMETHODIMP _get_Unit(HSTRING *value);
	virtual STDMETHODIMP _put_Unit(HSTRING value);
};
template<typename X> struct IHttpContentRangeHeaderValue_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<unsigned __int64>> get() { Foundation::IReference<unsigned __int64>* value; hrcheck(enc(&IHttpContentRangeHeaderValue_adaptor::FirstBytePosition)->_get_FirstBytePosition(&value)); return from_abi(value); }
			ptr<Foundation::IReference<unsigned __int64>> operator()() { return get(); }
			operator ptr<Foundation::IReference<unsigned __int64>> () { return get(); }
			ptr<Foundation::IReference<unsigned __int64>> operator->() { return get(); }
		} FirstBytePosition;
		struct : property {
			ptr<Foundation::IReference<unsigned __int64>> get() { Foundation::IReference<unsigned __int64>* value; hrcheck(enc(&IHttpContentRangeHeaderValue_adaptor::LastBytePosition)->_get_LastBytePosition(&value)); return from_abi(value); }
			ptr<Foundation::IReference<unsigned __int64>> operator()() { return get(); }
			operator ptr<Foundation::IReference<unsigned __int64>> () { return get(); }
			ptr<Foundation::IReference<unsigned __int64>> operator->() { return get(); }
		} LastBytePosition;
		struct : property {
			ptr<Foundation::IReference<unsigned __int64>> get() { Foundation::IReference<unsigned __int64>* value; hrcheck(enc(&IHttpContentRangeHeaderValue_adaptor::Length)->_get_Length(&value)); return from_abi(value); }
			ptr<Foundation::IReference<unsigned __int64>> operator()() { return get(); }
			operator ptr<Foundation::IReference<unsigned __int64>> () { return get(); }
			ptr<Foundation::IReference<unsigned __int64>> operator->() { return get(); }
		} Length;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpContentRangeHeaderValue_adaptor::Unit)->_get_Unit(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IHttpContentRangeHeaderValue_adaptor::Unit)->_put_Unit(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Unit;
	};
	IHttpContentRangeHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpContentRangeHeaderValue, X> : Windows::Web::Http::Headers::IHttpContentRangeHeaderValue_adaptor<X> { typedef adapt IHttpContentRangeHeaderValue; };
struct IHttpContentRangeHeaderValue : IHttpContentRangeHeaderValue_raw, generate<IHttpContentRangeHeaderValue> {};

// HttpContentRangeHeaderValue
template<typename> struct HttpContentRangeHeaderValue_statics {
	static ptr<HttpContentRangeHeaderValue> Parse(hstring_ref input) { HttpContentRangeHeaderValue* contentRangeHeaderValue; hrcheck(get_activation_factory<HttpContentRangeHeaderValue, IHttpContentRangeHeaderValueStatics>()->_Parse(input, &contentRangeHeaderValue)); return from_abi(contentRangeHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpContentRangeHeaderValue> *contentRangeHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpContentRangeHeaderValue, IHttpContentRangeHeaderValueStatics>()->_TryParse(input, contentRangeHeaderValue, &succeeded)); return succeeded; }
	static HttpContentRangeHeaderValue *activate(unsigned __int64 length) { HttpContentRangeHeaderValue *contentRangeHeaderValue; hrcheck(get_activation_factory<HttpContentRangeHeaderValue, IHttpContentRangeHeaderValueFactory>()->_CreateFromLength(length, &contentRangeHeaderValue)); return contentRangeHeaderValue; }
	static HttpContentRangeHeaderValue *activate(unsigned __int64 from, unsigned __int64 to) { HttpContentRangeHeaderValue *contentRangeHeaderValue; hrcheck(get_activation_factory<HttpContentRangeHeaderValue, IHttpContentRangeHeaderValueFactory>()->_CreateFromRange(from, to, &contentRangeHeaderValue)); return contentRangeHeaderValue; }
	static HttpContentRangeHeaderValue *activate(unsigned __int64 from, unsigned __int64 to, unsigned __int64 length) { HttpContentRangeHeaderValue *contentRangeHeaderValue; hrcheck(get_activation_factory<HttpContentRangeHeaderValue, IHttpContentRangeHeaderValueFactory>()->_CreateFromRangeWithLength(from, to, length, &contentRangeHeaderValue)); return contentRangeHeaderValue; }
};

template<typename X> struct statics<HttpContentRangeHeaderValue, X> : X, Windows::Web::Http::Headers::HttpContentRangeHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpContentRangeHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpContentRangeHeaderValue;
};
struct HttpContentRangeHeaderValue : generate<HttpContentRangeHeaderValue> {};

// IHttpMediaTypeHeaderValueStatics
struct IHttpMediaTypeHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpMediaTypeHeaderValue* *mediaTypeHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpMediaTypeHeaderValue* *mediaTypeHeaderValue, bool *succeeded);
};

// IHttpMediaTypeHeaderValueFactory
struct IHttpMediaTypeHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _Create(HSTRING mediaType, HttpMediaTypeHeaderValue* *mediaTypeHeaderValue);
};

// IHttpMediaTypeHeaderValue
struct IHttpMediaTypeHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_CharSet(HSTRING *value);
	virtual STDMETHODIMP _put_CharSet(HSTRING value);
	virtual STDMETHODIMP _get_MediaType(HSTRING *value);
	virtual STDMETHODIMP _put_MediaType(HSTRING value);
	virtual STDMETHODIMP _get_Parameters(Foundation::Collections::IVector<HttpNameValueHeaderValue*>* *value);
};
template<typename X> struct IHttpMediaTypeHeaderValue_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpMediaTypeHeaderValue_adaptor::CharSet)->_get_CharSet(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IHttpMediaTypeHeaderValue_adaptor::CharSet)->_put_CharSet(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} CharSet;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpMediaTypeHeaderValue_adaptor::MediaType)->_get_MediaType(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IHttpMediaTypeHeaderValue_adaptor::MediaType)->_put_MediaType(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} MediaType;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> get() { Foundation::Collections::IVector<HttpNameValueHeaderValue*>* value; hrcheck(enc(&IHttpMediaTypeHeaderValue_adaptor::Parameters)->_get_Parameters(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> operator->() { return get(); }
		} Parameters;
	};
	IHttpMediaTypeHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpMediaTypeHeaderValue, X> : Windows::Web::Http::Headers::IHttpMediaTypeHeaderValue_adaptor<X> { typedef adapt IHttpMediaTypeHeaderValue; };
struct IHttpMediaTypeHeaderValue : IHttpMediaTypeHeaderValue_raw, generate<IHttpMediaTypeHeaderValue> {};

// HttpMediaTypeHeaderValue
template<typename> struct HttpMediaTypeHeaderValue_statics {
	static ptr<HttpMediaTypeHeaderValue> Parse(hstring_ref input) { HttpMediaTypeHeaderValue* mediaTypeHeaderValue; hrcheck(get_activation_factory<HttpMediaTypeHeaderValue, IHttpMediaTypeHeaderValueStatics>()->_Parse(input, &mediaTypeHeaderValue)); return from_abi(mediaTypeHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpMediaTypeHeaderValue> *mediaTypeHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpMediaTypeHeaderValue, IHttpMediaTypeHeaderValueStatics>()->_TryParse(input, mediaTypeHeaderValue, &succeeded)); return succeeded; }
	static HttpMediaTypeHeaderValue *activate(hstring_ref mediaType) { HttpMediaTypeHeaderValue *mediaTypeHeaderValue; hrcheck(get_activation_factory<HttpMediaTypeHeaderValue, IHttpMediaTypeHeaderValueFactory>()->_Create(mediaType, &mediaTypeHeaderValue)); return mediaTypeHeaderValue; }
};

template<typename X> struct statics<HttpMediaTypeHeaderValue, X> : X, Windows::Web::Http::Headers::HttpMediaTypeHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpMediaTypeHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpMediaTypeHeaderValue;
};
struct HttpMediaTypeHeaderValue : generate<HttpMediaTypeHeaderValue> {};

// IHttpMediaTypeWithQualityHeaderValueStatics
struct IHttpMediaTypeWithQualityHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpMediaTypeWithQualityHeaderValue* *mediaTypeWithQualityHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpMediaTypeWithQualityHeaderValue* *mediaTypeWithQualityHeaderValue, bool *succeeded);
};

// IHttpMediaTypeWithQualityHeaderValueFactory
struct IHttpMediaTypeWithQualityHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromMediaType(HSTRING mediaType, HttpMediaTypeWithQualityHeaderValue* *mediaTypeWithQualityHeaderValue);
	virtual STDMETHODIMP _CreateFromMediaTypeWithQuality(HSTRING mediaType, double quality, HttpMediaTypeWithQualityHeaderValue* *mediaTypeWithQualityHeaderValue);
};

// IHttpMediaTypeWithQualityHeaderValue
struct IHttpMediaTypeWithQualityHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_CharSet(HSTRING *value);
	virtual STDMETHODIMP _put_CharSet(HSTRING value);
	virtual STDMETHODIMP _get_MediaType(HSTRING *value);
	virtual STDMETHODIMP _put_MediaType(HSTRING value);
	virtual STDMETHODIMP _get_Parameters(Foundation::Collections::IVector<HttpNameValueHeaderValue*>* *value);
	virtual STDMETHODIMP _get_Quality(Foundation::IReference<double>* *value);
	virtual STDMETHODIMP _put_Quality(Foundation::IReference<double>* value);
};
template<typename X> struct IHttpMediaTypeWithQualityHeaderValue_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpMediaTypeWithQualityHeaderValue_adaptor::CharSet)->_get_CharSet(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IHttpMediaTypeWithQualityHeaderValue_adaptor::CharSet)->_put_CharSet(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} CharSet;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpMediaTypeWithQualityHeaderValue_adaptor::MediaType)->_get_MediaType(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IHttpMediaTypeWithQualityHeaderValue_adaptor::MediaType)->_put_MediaType(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} MediaType;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> get() { Foundation::Collections::IVector<HttpNameValueHeaderValue*>* value; hrcheck(enc(&IHttpMediaTypeWithQualityHeaderValue_adaptor::Parameters)->_get_Parameters(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> operator->() { return get(); }
		} Parameters;
		struct : property {
			ptr<Foundation::IReference<double>> get() { Foundation::IReference<double>* value; hrcheck(enc(&IHttpMediaTypeWithQualityHeaderValue_adaptor::Quality)->_get_Quality(&value)); return from_abi(value); }
			ptr<Foundation::IReference<double>> operator()() { return get(); }
			operator ptr<Foundation::IReference<double>> () { return get(); }
			ptr<Foundation::IReference<double>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<double>> value) { hrcheck(enc(&IHttpMediaTypeWithQualityHeaderValue_adaptor::Quality)->_put_Quality(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<double>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<double>> value) { put(to_abi(value)); }
		} Quality;
	};
	IHttpMediaTypeWithQualityHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpMediaTypeWithQualityHeaderValue, X> : Windows::Web::Http::Headers::IHttpMediaTypeWithQualityHeaderValue_adaptor<X> { typedef adapt IHttpMediaTypeWithQualityHeaderValue; };
struct IHttpMediaTypeWithQualityHeaderValue : IHttpMediaTypeWithQualityHeaderValue_raw, generate<IHttpMediaTypeWithQualityHeaderValue> {};

// HttpMediaTypeWithQualityHeaderValue
template<typename> struct HttpMediaTypeWithQualityHeaderValue_statics {
	static ptr<HttpMediaTypeWithQualityHeaderValue> Parse(hstring_ref input) { HttpMediaTypeWithQualityHeaderValue* mediaTypeWithQualityHeaderValue; hrcheck(get_activation_factory<HttpMediaTypeWithQualityHeaderValue, IHttpMediaTypeWithQualityHeaderValueStatics>()->_Parse(input, &mediaTypeWithQualityHeaderValue)); return from_abi(mediaTypeWithQualityHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpMediaTypeWithQualityHeaderValue> *mediaTypeWithQualityHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpMediaTypeWithQualityHeaderValue, IHttpMediaTypeWithQualityHeaderValueStatics>()->_TryParse(input, mediaTypeWithQualityHeaderValue, &succeeded)); return succeeded; }
	static HttpMediaTypeWithQualityHeaderValue *activate(hstring_ref mediaType) { HttpMediaTypeWithQualityHeaderValue *mediaTypeWithQualityHeaderValue; hrcheck(get_activation_factory<HttpMediaTypeWithQualityHeaderValue, IHttpMediaTypeWithQualityHeaderValueFactory>()->_CreateFromMediaType(mediaType, &mediaTypeWithQualityHeaderValue)); return mediaTypeWithQualityHeaderValue; }
	static HttpMediaTypeWithQualityHeaderValue *activate(hstring_ref mediaType, double quality) { HttpMediaTypeWithQualityHeaderValue *mediaTypeWithQualityHeaderValue; hrcheck(get_activation_factory<HttpMediaTypeWithQualityHeaderValue, IHttpMediaTypeWithQualityHeaderValueFactory>()->_CreateFromMediaTypeWithQuality(mediaType, quality, &mediaTypeWithQualityHeaderValue)); return mediaTypeWithQualityHeaderValue; }
};

template<typename X> struct statics<HttpMediaTypeWithQualityHeaderValue, X> : X, Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpMediaTypeWithQualityHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpMediaTypeWithQualityHeaderValue;
};
struct HttpMediaTypeWithQualityHeaderValue : generate<HttpMediaTypeWithQualityHeaderValue> {};

// IHttpMediaTypeWithQualityHeaderValueCollection
struct IHttpMediaTypeWithQualityHeaderValueCollection_raw : IInspectable {
	virtual STDMETHODIMP _ParseAdd(HSTRING input);
	virtual STDMETHODIMP _TryParseAdd(HSTRING input, bool *succeeded);
};
template<typename X> struct IHttpMediaTypeWithQualityHeaderValueCollection_adaptor : X {
	void ParseAdd(hstring_ref input) { hrcheck(X::get()->_ParseAdd(input)); }
	bool TryParseAdd(hstring_ref input) { bool succeeded; hrcheck(X::get()->_TryParseAdd(input, &succeeded)); return succeeded; }
};
template<typename X> struct adapt<IHttpMediaTypeWithQualityHeaderValueCollection, X> : Windows::Web::Http::Headers::IHttpMediaTypeWithQualityHeaderValueCollection_adaptor<X> { typedef adapt IHttpMediaTypeWithQualityHeaderValueCollection; };
struct IHttpMediaTypeWithQualityHeaderValueCollection : IHttpMediaTypeWithQualityHeaderValueCollection_raw, generate<IHttpMediaTypeWithQualityHeaderValueCollection> {};

// HttpMediaTypeWithQualityHeaderValueCollection
template<typename X> struct statics<HttpMediaTypeWithQualityHeaderValueCollection, X> : X {
	typedef typename X::root_type HttpMediaTypeWithQualityHeaderValueCollection;
};
struct HttpMediaTypeWithQualityHeaderValueCollection : generate<HttpMediaTypeWithQualityHeaderValueCollection> {};

// IHttpContentCodingWithQualityHeaderValueStatics
struct IHttpContentCodingWithQualityHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpContentCodingWithQualityHeaderValue* *contentCodingWithQualityHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpContentCodingWithQualityHeaderValue* *contentCodingWithQualityHeaderValue, bool *succeeded);
};

// IHttpContentCodingWithQualityHeaderValueFactory
struct IHttpContentCodingWithQualityHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromValue(HSTRING contentCoding, HttpContentCodingWithQualityHeaderValue* *contentCodingWithQualityHeaderValue);
	virtual STDMETHODIMP _CreateFromValueWithQuality(HSTRING contentCoding, double quality, HttpContentCodingWithQualityHeaderValue* *contentCodingWithQualityHeaderValue);
};

// IHttpContentCodingWithQualityHeaderValue
struct IHttpContentCodingWithQualityHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_ContentCoding(HSTRING *value);
	virtual STDMETHODIMP _get_Quality(Foundation::IReference<double>* *value);
};
template<typename X> struct IHttpContentCodingWithQualityHeaderValue_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpContentCodingWithQualityHeaderValue_adaptor::ContentCoding)->_get_ContentCoding(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ContentCoding;
		struct : property {
			ptr<Foundation::IReference<double>> get() { Foundation::IReference<double>* value; hrcheck(enc(&IHttpContentCodingWithQualityHeaderValue_adaptor::Quality)->_get_Quality(&value)); return from_abi(value); }
			ptr<Foundation::IReference<double>> operator()() { return get(); }
			operator ptr<Foundation::IReference<double>> () { return get(); }
			ptr<Foundation::IReference<double>> operator->() { return get(); }
		} Quality;
	};
	IHttpContentCodingWithQualityHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpContentCodingWithQualityHeaderValue, X> : Windows::Web::Http::Headers::IHttpContentCodingWithQualityHeaderValue_adaptor<X> { typedef adapt IHttpContentCodingWithQualityHeaderValue; };
struct IHttpContentCodingWithQualityHeaderValue : IHttpContentCodingWithQualityHeaderValue_raw, generate<IHttpContentCodingWithQualityHeaderValue> {};

// HttpContentCodingWithQualityHeaderValue
template<typename> struct HttpContentCodingWithQualityHeaderValue_statics {
	static ptr<HttpContentCodingWithQualityHeaderValue> Parse(hstring_ref input) { HttpContentCodingWithQualityHeaderValue* contentCodingWithQualityHeaderValue; hrcheck(get_activation_factory<HttpContentCodingWithQualityHeaderValue, IHttpContentCodingWithQualityHeaderValueStatics>()->_Parse(input, &contentCodingWithQualityHeaderValue)); return from_abi(contentCodingWithQualityHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpContentCodingWithQualityHeaderValue> *contentCodingWithQualityHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpContentCodingWithQualityHeaderValue, IHttpContentCodingWithQualityHeaderValueStatics>()->_TryParse(input, contentCodingWithQualityHeaderValue, &succeeded)); return succeeded; }
	static HttpContentCodingWithQualityHeaderValue *activate(hstring_ref contentCoding) { HttpContentCodingWithQualityHeaderValue *contentCodingWithQualityHeaderValue; hrcheck(get_activation_factory<HttpContentCodingWithQualityHeaderValue, IHttpContentCodingWithQualityHeaderValueFactory>()->_CreateFromValue(contentCoding, &contentCodingWithQualityHeaderValue)); return contentCodingWithQualityHeaderValue; }
	static HttpContentCodingWithQualityHeaderValue *activate(hstring_ref contentCoding, double quality) { HttpContentCodingWithQualityHeaderValue *contentCodingWithQualityHeaderValue; hrcheck(get_activation_factory<HttpContentCodingWithQualityHeaderValue, IHttpContentCodingWithQualityHeaderValueFactory>()->_CreateFromValueWithQuality(contentCoding, quality, &contentCodingWithQualityHeaderValue)); return contentCodingWithQualityHeaderValue; }
};

template<typename X> struct statics<HttpContentCodingWithQualityHeaderValue, X> : X, Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpContentCodingWithQualityHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpContentCodingWithQualityHeaderValue;
};
struct HttpContentCodingWithQualityHeaderValue : generate<HttpContentCodingWithQualityHeaderValue> {};

// IHttpContentCodingWithQualityHeaderValueCollection
struct IHttpContentCodingWithQualityHeaderValueCollection_raw : IInspectable {
	virtual STDMETHODIMP _ParseAdd(HSTRING input);
	virtual STDMETHODIMP _TryParseAdd(HSTRING input, bool *succeeded);
};
template<typename X> struct IHttpContentCodingWithQualityHeaderValueCollection_adaptor : X {
	void ParseAdd(hstring_ref input) { hrcheck(X::get()->_ParseAdd(input)); }
	bool TryParseAdd(hstring_ref input) { bool succeeded; hrcheck(X::get()->_TryParseAdd(input, &succeeded)); return succeeded; }
};
template<typename X> struct adapt<IHttpContentCodingWithQualityHeaderValueCollection, X> : Windows::Web::Http::Headers::IHttpContentCodingWithQualityHeaderValueCollection_adaptor<X> { typedef adapt IHttpContentCodingWithQualityHeaderValueCollection; };
struct IHttpContentCodingWithQualityHeaderValueCollection : IHttpContentCodingWithQualityHeaderValueCollection_raw, generate<IHttpContentCodingWithQualityHeaderValueCollection> {};

// HttpContentCodingWithQualityHeaderValueCollection
template<typename X> struct statics<HttpContentCodingWithQualityHeaderValueCollection, X> : X {
	typedef typename X::root_type HttpContentCodingWithQualityHeaderValueCollection;
};
struct HttpContentCodingWithQualityHeaderValueCollection : generate<HttpContentCodingWithQualityHeaderValueCollection> {};

// IHttpLanguageRangeWithQualityHeaderValueStatics
struct IHttpLanguageRangeWithQualityHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpLanguageRangeWithQualityHeaderValue* *languageRangeWithQualityHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpLanguageRangeWithQualityHeaderValue* *languageRangeWithQualityHeaderValue, bool *succeeded);
};

// IHttpLanguageRangeWithQualityHeaderValueFactory
struct IHttpLanguageRangeWithQualityHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromLanguageRange(HSTRING languageRange, HttpLanguageRangeWithQualityHeaderValue* *languageRangeWithQualityHeaderValue);
	virtual STDMETHODIMP _CreateFromLanguageRangeWithQuality(HSTRING languageRange, double quality, HttpLanguageRangeWithQualityHeaderValue* *languageRangeWithQualityHeaderValue);
};

// IHttpLanguageRangeWithQualityHeaderValue
struct IHttpLanguageRangeWithQualityHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_LanguageRange(HSTRING *languageRange);
	virtual STDMETHODIMP _get_Quality(Foundation::IReference<double>* *value);
};
template<typename X> struct IHttpLanguageRangeWithQualityHeaderValue_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING languageRange; hrcheck(enc(&IHttpLanguageRangeWithQualityHeaderValue_adaptor::LanguageRange)->_get_LanguageRange(&languageRange)); return from_abi(languageRange); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} LanguageRange;
		struct : property {
			ptr<Foundation::IReference<double>> get() { Foundation::IReference<double>* value; hrcheck(enc(&IHttpLanguageRangeWithQualityHeaderValue_adaptor::Quality)->_get_Quality(&value)); return from_abi(value); }
			ptr<Foundation::IReference<double>> operator()() { return get(); }
			operator ptr<Foundation::IReference<double>> () { return get(); }
			ptr<Foundation::IReference<double>> operator->() { return get(); }
		} Quality;
	};
	IHttpLanguageRangeWithQualityHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpLanguageRangeWithQualityHeaderValue, X> : Windows::Web::Http::Headers::IHttpLanguageRangeWithQualityHeaderValue_adaptor<X> { typedef adapt IHttpLanguageRangeWithQualityHeaderValue; };
struct IHttpLanguageRangeWithQualityHeaderValue : IHttpLanguageRangeWithQualityHeaderValue_raw, generate<IHttpLanguageRangeWithQualityHeaderValue> {};

// HttpLanguageRangeWithQualityHeaderValue
template<typename> struct HttpLanguageRangeWithQualityHeaderValue_statics {
	static ptr<HttpLanguageRangeWithQualityHeaderValue> Parse(hstring_ref input) { HttpLanguageRangeWithQualityHeaderValue* languageRangeWithQualityHeaderValue; hrcheck(get_activation_factory<HttpLanguageRangeWithQualityHeaderValue, IHttpLanguageRangeWithQualityHeaderValueStatics>()->_Parse(input, &languageRangeWithQualityHeaderValue)); return from_abi(languageRangeWithQualityHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpLanguageRangeWithQualityHeaderValue> *languageRangeWithQualityHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpLanguageRangeWithQualityHeaderValue, IHttpLanguageRangeWithQualityHeaderValueStatics>()->_TryParse(input, languageRangeWithQualityHeaderValue, &succeeded)); return succeeded; }
	static HttpLanguageRangeWithQualityHeaderValue *activate(hstring_ref languageRange) { HttpLanguageRangeWithQualityHeaderValue *languageRangeWithQualityHeaderValue; hrcheck(get_activation_factory<HttpLanguageRangeWithQualityHeaderValue, IHttpLanguageRangeWithQualityHeaderValueFactory>()->_CreateFromLanguageRange(languageRange, &languageRangeWithQualityHeaderValue)); return languageRangeWithQualityHeaderValue; }
	static HttpLanguageRangeWithQualityHeaderValue *activate(hstring_ref languageRange, double quality) { HttpLanguageRangeWithQualityHeaderValue *languageRangeWithQualityHeaderValue; hrcheck(get_activation_factory<HttpLanguageRangeWithQualityHeaderValue, IHttpLanguageRangeWithQualityHeaderValueFactory>()->_CreateFromLanguageRangeWithQuality(languageRange, quality, &languageRangeWithQualityHeaderValue)); return languageRangeWithQualityHeaderValue; }
};

template<typename X> struct statics<HttpLanguageRangeWithQualityHeaderValue, X> : X, Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpLanguageRangeWithQualityHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpLanguageRangeWithQualityHeaderValue;
};
struct HttpLanguageRangeWithQualityHeaderValue : generate<HttpLanguageRangeWithQualityHeaderValue> {};

// IHttpLanguageRangeWithQualityHeaderValueCollection
struct IHttpLanguageRangeWithQualityHeaderValueCollection_raw : IInspectable {
	virtual STDMETHODIMP _ParseAdd(HSTRING input);
	virtual STDMETHODIMP _TryParseAdd(HSTRING input, bool *succeeded);
};
template<typename X> struct IHttpLanguageRangeWithQualityHeaderValueCollection_adaptor : X {
	void ParseAdd(hstring_ref input) { hrcheck(X::get()->_ParseAdd(input)); }
	bool TryParseAdd(hstring_ref input) { bool succeeded; hrcheck(X::get()->_TryParseAdd(input, &succeeded)); return succeeded; }
};
template<typename X> struct adapt<IHttpLanguageRangeWithQualityHeaderValueCollection, X> : Windows::Web::Http::Headers::IHttpLanguageRangeWithQualityHeaderValueCollection_adaptor<X> { typedef adapt IHttpLanguageRangeWithQualityHeaderValueCollection; };
struct IHttpLanguageRangeWithQualityHeaderValueCollection : IHttpLanguageRangeWithQualityHeaderValueCollection_raw, generate<IHttpLanguageRangeWithQualityHeaderValueCollection> {};

// HttpLanguageRangeWithQualityHeaderValueCollection
template<typename X> struct statics<HttpLanguageRangeWithQualityHeaderValueCollection, X> : X {
	typedef typename X::root_type HttpLanguageRangeWithQualityHeaderValueCollection;
};
struct HttpLanguageRangeWithQualityHeaderValueCollection : generate<HttpLanguageRangeWithQualityHeaderValueCollection> {};

// IHttpCredentialsHeaderValueStatics
struct IHttpCredentialsHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpCredentialsHeaderValue* *credentialsHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpCredentialsHeaderValue* *credentialsHeaderValue, bool *succeeded);
};

// IHttpCredentialsHeaderValueFactory
struct IHttpCredentialsHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromScheme(HSTRING scheme, HttpCredentialsHeaderValue* *credentialsHeaderValue);
	virtual STDMETHODIMP _CreateFromSchemeWithToken(HSTRING scheme, HSTRING token, HttpCredentialsHeaderValue* *credentialsHeaderValue);
};

// IHttpCredentialsHeaderValue
struct IHttpCredentialsHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_Parameters(Foundation::Collections::IVector<HttpNameValueHeaderValue*>* *value);
	virtual STDMETHODIMP _get_Scheme(HSTRING *value);
	virtual STDMETHODIMP _get_Token(HSTRING *value);
};
template<typename X> struct IHttpCredentialsHeaderValue_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> get() { Foundation::Collections::IVector<HttpNameValueHeaderValue*>* value; hrcheck(enc(&IHttpCredentialsHeaderValue_adaptor::Parameters)->_get_Parameters(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> operator->() { return get(); }
		} Parameters;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpCredentialsHeaderValue_adaptor::Scheme)->_get_Scheme(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Scheme;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpCredentialsHeaderValue_adaptor::Token)->_get_Token(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Token;
	};
	IHttpCredentialsHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpCredentialsHeaderValue, X> : Windows::Web::Http::Headers::IHttpCredentialsHeaderValue_adaptor<X> { typedef adapt IHttpCredentialsHeaderValue; };
struct IHttpCredentialsHeaderValue : IHttpCredentialsHeaderValue_raw, generate<IHttpCredentialsHeaderValue> {};

// HttpCredentialsHeaderValue
template<typename> struct HttpCredentialsHeaderValue_statics {
	static ptr<HttpCredentialsHeaderValue> Parse(hstring_ref input) { HttpCredentialsHeaderValue* credentialsHeaderValue; hrcheck(get_activation_factory<HttpCredentialsHeaderValue, IHttpCredentialsHeaderValueStatics>()->_Parse(input, &credentialsHeaderValue)); return from_abi(credentialsHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpCredentialsHeaderValue> *credentialsHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpCredentialsHeaderValue, IHttpCredentialsHeaderValueStatics>()->_TryParse(input, credentialsHeaderValue, &succeeded)); return succeeded; }
	static HttpCredentialsHeaderValue *activate(hstring_ref scheme) { HttpCredentialsHeaderValue *credentialsHeaderValue; hrcheck(get_activation_factory<HttpCredentialsHeaderValue, IHttpCredentialsHeaderValueFactory>()->_CreateFromScheme(scheme, &credentialsHeaderValue)); return credentialsHeaderValue; }
	static HttpCredentialsHeaderValue *activate(hstring_ref scheme, hstring_ref token) { HttpCredentialsHeaderValue *credentialsHeaderValue; hrcheck(get_activation_factory<HttpCredentialsHeaderValue, IHttpCredentialsHeaderValueFactory>()->_CreateFromSchemeWithToken(scheme, token, &credentialsHeaderValue)); return credentialsHeaderValue; }
};

template<typename X> struct statics<HttpCredentialsHeaderValue, X> : X, Windows::Web::Http::Headers::HttpCredentialsHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpCredentialsHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpCredentialsHeaderValue;
};
struct HttpCredentialsHeaderValue : generate<HttpCredentialsHeaderValue> {};

// IHttpNameValueHeaderValueStatics
struct IHttpNameValueHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpNameValueHeaderValue* *nameValueHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpNameValueHeaderValue* *nameValueHeaderValue, bool *succeeded);
};

// IHttpNameValueHeaderValueFactory
struct IHttpNameValueHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromName(HSTRING name, HttpNameValueHeaderValue* *nameValueHeaderValue);
	virtual STDMETHODIMP _CreateFromNameWithValue(HSTRING name, HSTRING value, HttpNameValueHeaderValue* *nameValueHeaderValue);
};

// IHttpNameValueHeaderValue
struct IHttpNameValueHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_Value(HSTRING *value);
	virtual STDMETHODIMP _put_Value(HSTRING value);
};
template<typename X> struct IHttpNameValueHeaderValue_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpNameValueHeaderValue_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpNameValueHeaderValue_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IHttpNameValueHeaderValue_adaptor::Value)->_put_Value(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Value;
	};
	IHttpNameValueHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpNameValueHeaderValue, X> : Windows::Web::Http::Headers::IHttpNameValueHeaderValue_adaptor<X> { typedef adapt IHttpNameValueHeaderValue; };
struct IHttpNameValueHeaderValue : IHttpNameValueHeaderValue_raw, generate<IHttpNameValueHeaderValue> {};

// HttpNameValueHeaderValue
template<typename> struct HttpNameValueHeaderValue_statics {
	static ptr<HttpNameValueHeaderValue> Parse(hstring_ref input) { HttpNameValueHeaderValue* nameValueHeaderValue; hrcheck(get_activation_factory<HttpNameValueHeaderValue, IHttpNameValueHeaderValueStatics>()->_Parse(input, &nameValueHeaderValue)); return from_abi(nameValueHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpNameValueHeaderValue> *nameValueHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpNameValueHeaderValue, IHttpNameValueHeaderValueStatics>()->_TryParse(input, nameValueHeaderValue, &succeeded)); return succeeded; }
	static HttpNameValueHeaderValue *activate(hstring_ref name) { HttpNameValueHeaderValue *nameValueHeaderValue; hrcheck(get_activation_factory<HttpNameValueHeaderValue, IHttpNameValueHeaderValueFactory>()->_CreateFromName(name, &nameValueHeaderValue)); return nameValueHeaderValue; }
	static HttpNameValueHeaderValue *activate(hstring_ref name, hstring_ref value) { HttpNameValueHeaderValue *nameValueHeaderValue; hrcheck(get_activation_factory<HttpNameValueHeaderValue, IHttpNameValueHeaderValueFactory>()->_CreateFromNameWithValue(name, value, &nameValueHeaderValue)); return nameValueHeaderValue; }
};

template<typename X> struct statics<HttpNameValueHeaderValue, X> : X, Windows::Web::Http::Headers::HttpNameValueHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpNameValueHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpNameValueHeaderValue;
};
struct HttpNameValueHeaderValue : generate<HttpNameValueHeaderValue> {};

// IHttpCacheDirectiveHeaderValueCollection
struct IHttpCacheDirectiveHeaderValueCollection_raw : IInspectable {
	virtual STDMETHODIMP _get_MaxAge(Foundation::IReference<Foundation::TimeSpan>* *value);
	virtual STDMETHODIMP _put_MaxAge(Foundation::IReference<Foundation::TimeSpan>* value);
	virtual STDMETHODIMP _get_MaxStale(Foundation::IReference<Foundation::TimeSpan>* *value);
	virtual STDMETHODIMP _put_MaxStale(Foundation::IReference<Foundation::TimeSpan>* value);
	virtual STDMETHODIMP _get_MinFresh(Foundation::IReference<Foundation::TimeSpan>* *value);
	virtual STDMETHODIMP _put_MinFresh(Foundation::IReference<Foundation::TimeSpan>* value);
	virtual STDMETHODIMP _get_SharedMaxAge(Foundation::IReference<Foundation::TimeSpan>* *value);
	virtual STDMETHODIMP _put_SharedMaxAge(Foundation::IReference<Foundation::TimeSpan>* value);
	virtual STDMETHODIMP _ParseAdd(HSTRING input);
	virtual STDMETHODIMP _TryParseAdd(HSTRING input, bool *succeeded);
};
template<typename X> struct IHttpCacheDirectiveHeaderValueCollection_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IHttpCacheDirectiveHeaderValueCollection_adaptor::MaxAge)->_get_MaxAge(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&IHttpCacheDirectiveHeaderValueCollection_adaptor::MaxAge)->_put_MaxAge(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} MaxAge;
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IHttpCacheDirectiveHeaderValueCollection_adaptor::MaxStale)->_get_MaxStale(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&IHttpCacheDirectiveHeaderValueCollection_adaptor::MaxStale)->_put_MaxStale(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} MaxStale;
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IHttpCacheDirectiveHeaderValueCollection_adaptor::MinFresh)->_get_MinFresh(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&IHttpCacheDirectiveHeaderValueCollection_adaptor::MinFresh)->_put_MinFresh(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} MinFresh;
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IHttpCacheDirectiveHeaderValueCollection_adaptor::SharedMaxAge)->_get_SharedMaxAge(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&IHttpCacheDirectiveHeaderValueCollection_adaptor::SharedMaxAge)->_put_SharedMaxAge(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} SharedMaxAge;
	};
	void ParseAdd(hstring_ref input) { hrcheck(X::get()->_ParseAdd(input)); }
	bool TryParseAdd(hstring_ref input) { bool succeeded; hrcheck(X::get()->_TryParseAdd(input, &succeeded)); return succeeded; }
	IHttpCacheDirectiveHeaderValueCollection_adaptor() {}
};
template<typename X> struct adapt<IHttpCacheDirectiveHeaderValueCollection, X> : Windows::Web::Http::Headers::IHttpCacheDirectiveHeaderValueCollection_adaptor<X> { typedef adapt IHttpCacheDirectiveHeaderValueCollection; };
struct IHttpCacheDirectiveHeaderValueCollection : IHttpCacheDirectiveHeaderValueCollection_raw, generate<IHttpCacheDirectiveHeaderValueCollection> {};

// HttpCacheDirectiveHeaderValueCollection
template<typename X> struct statics<HttpCacheDirectiveHeaderValueCollection, X> : X {
	typedef typename X::root_type HttpCacheDirectiveHeaderValueCollection;
};
struct HttpCacheDirectiveHeaderValueCollection : generate<HttpCacheDirectiveHeaderValueCollection> {};

// IHttpConnectionOptionHeaderValueStatics
struct IHttpConnectionOptionHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpConnectionOptionHeaderValue* *connectionOptionHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpConnectionOptionHeaderValue* *connectionOptionHeaderValue, bool *succeeded);
};

// IHttpConnectionOptionHeaderValueFactory
struct IHttpConnectionOptionHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _Create(HSTRING token, HttpConnectionOptionHeaderValue* *connectionOptionHeaderValue);
};

// IHttpConnectionOptionHeaderValue
struct IHttpConnectionOptionHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_Token(HSTRING *value);
};
template<typename X> struct IHttpConnectionOptionHeaderValue_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpConnectionOptionHeaderValue_adaptor::Token)->_get_Token(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Token;
	};
	IHttpConnectionOptionHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpConnectionOptionHeaderValue, X> : Windows::Web::Http::Headers::IHttpConnectionOptionHeaderValue_adaptor<X> { typedef adapt IHttpConnectionOptionHeaderValue; };
struct IHttpConnectionOptionHeaderValue : IHttpConnectionOptionHeaderValue_raw, generate<IHttpConnectionOptionHeaderValue> {};

// HttpConnectionOptionHeaderValue
template<typename> struct HttpConnectionOptionHeaderValue_statics {
	static ptr<HttpConnectionOptionHeaderValue> Parse(hstring_ref input) { HttpConnectionOptionHeaderValue* connectionOptionHeaderValue; hrcheck(get_activation_factory<HttpConnectionOptionHeaderValue, IHttpConnectionOptionHeaderValueStatics>()->_Parse(input, &connectionOptionHeaderValue)); return from_abi(connectionOptionHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpConnectionOptionHeaderValue> *connectionOptionHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpConnectionOptionHeaderValue, IHttpConnectionOptionHeaderValueStatics>()->_TryParse(input, connectionOptionHeaderValue, &succeeded)); return succeeded; }
	static HttpConnectionOptionHeaderValue *activate(hstring_ref token) { HttpConnectionOptionHeaderValue *connectionOptionHeaderValue; hrcheck(get_activation_factory<HttpConnectionOptionHeaderValue, IHttpConnectionOptionHeaderValueFactory>()->_Create(token, &connectionOptionHeaderValue)); return connectionOptionHeaderValue; }
};

template<typename X> struct statics<HttpConnectionOptionHeaderValue, X> : X, Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpConnectionOptionHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpConnectionOptionHeaderValue;
};
struct HttpConnectionOptionHeaderValue : generate<HttpConnectionOptionHeaderValue> {};

// IHttpConnectionOptionHeaderValueCollection
struct IHttpConnectionOptionHeaderValueCollection_raw : IInspectable {
	virtual STDMETHODIMP _ParseAdd(HSTRING input);
	virtual STDMETHODIMP _TryParseAdd(HSTRING input, bool *succeeded);
};
template<typename X> struct IHttpConnectionOptionHeaderValueCollection_adaptor : X {
	void ParseAdd(hstring_ref input) { hrcheck(X::get()->_ParseAdd(input)); }
	bool TryParseAdd(hstring_ref input) { bool succeeded; hrcheck(X::get()->_TryParseAdd(input, &succeeded)); return succeeded; }
};
template<typename X> struct adapt<IHttpConnectionOptionHeaderValueCollection, X> : Windows::Web::Http::Headers::IHttpConnectionOptionHeaderValueCollection_adaptor<X> { typedef adapt IHttpConnectionOptionHeaderValueCollection; };
struct IHttpConnectionOptionHeaderValueCollection : IHttpConnectionOptionHeaderValueCollection_raw, generate<IHttpConnectionOptionHeaderValueCollection> {};

// HttpConnectionOptionHeaderValueCollection
template<typename X> struct statics<HttpConnectionOptionHeaderValueCollection, X> : X {
	typedef typename X::root_type HttpConnectionOptionHeaderValueCollection;
};
struct HttpConnectionOptionHeaderValueCollection : generate<HttpConnectionOptionHeaderValueCollection> {};

// IHttpCookiePairHeaderValueStatics
struct IHttpCookiePairHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpCookiePairHeaderValue* *cookiePairHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpCookiePairHeaderValue* *cookiePairHeaderValue, bool *succeeded);
};

// IHttpCookiePairHeaderValueFactory
struct IHttpCookiePairHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromName(HSTRING name, HttpCookiePairHeaderValue* *cookiePairHeaderValue);
	virtual STDMETHODIMP _CreateFromNameWithValue(HSTRING name, HSTRING value, HttpCookiePairHeaderValue* *cookiePairHeaderValue);
};

// IHttpCookiePairHeaderValue
struct IHttpCookiePairHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_Value(HSTRING *value);
	virtual STDMETHODIMP _put_Value(HSTRING value);
};
template<typename X> struct IHttpCookiePairHeaderValue_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpCookiePairHeaderValue_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpCookiePairHeaderValue_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IHttpCookiePairHeaderValue_adaptor::Value)->_put_Value(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Value;
	};
	IHttpCookiePairHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpCookiePairHeaderValue, X> : Windows::Web::Http::Headers::IHttpCookiePairHeaderValue_adaptor<X> { typedef adapt IHttpCookiePairHeaderValue; };
struct IHttpCookiePairHeaderValue : IHttpCookiePairHeaderValue_raw, generate<IHttpCookiePairHeaderValue> {};

// HttpCookiePairHeaderValue
template<typename> struct HttpCookiePairHeaderValue_statics {
	static ptr<HttpCookiePairHeaderValue> Parse(hstring_ref input) { HttpCookiePairHeaderValue* cookiePairHeaderValue; hrcheck(get_activation_factory<HttpCookiePairHeaderValue, IHttpCookiePairHeaderValueStatics>()->_Parse(input, &cookiePairHeaderValue)); return from_abi(cookiePairHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpCookiePairHeaderValue> *cookiePairHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpCookiePairHeaderValue, IHttpCookiePairHeaderValueStatics>()->_TryParse(input, cookiePairHeaderValue, &succeeded)); return succeeded; }
	static HttpCookiePairHeaderValue *activate(hstring_ref name) { HttpCookiePairHeaderValue *cookiePairHeaderValue; hrcheck(get_activation_factory<HttpCookiePairHeaderValue, IHttpCookiePairHeaderValueFactory>()->_CreateFromName(name, &cookiePairHeaderValue)); return cookiePairHeaderValue; }
	static HttpCookiePairHeaderValue *activate(hstring_ref name, hstring_ref value) { HttpCookiePairHeaderValue *cookiePairHeaderValue; hrcheck(get_activation_factory<HttpCookiePairHeaderValue, IHttpCookiePairHeaderValueFactory>()->_CreateFromNameWithValue(name, value, &cookiePairHeaderValue)); return cookiePairHeaderValue; }
};

template<typename X> struct statics<HttpCookiePairHeaderValue, X> : X, Windows::Web::Http::Headers::HttpCookiePairHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpCookiePairHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpCookiePairHeaderValue;
};
struct HttpCookiePairHeaderValue : generate<HttpCookiePairHeaderValue> {};

// IHttpCookiePairHeaderValueCollection
struct IHttpCookiePairHeaderValueCollection_raw : IInspectable {
	virtual STDMETHODIMP _ParseAdd(HSTRING input);
	virtual STDMETHODIMP _TryParseAdd(HSTRING input, bool *succeeded);
};
template<typename X> struct IHttpCookiePairHeaderValueCollection_adaptor : X {
	void ParseAdd(hstring_ref input) { hrcheck(X::get()->_ParseAdd(input)); }
	bool TryParseAdd(hstring_ref input) { bool succeeded; hrcheck(X::get()->_TryParseAdd(input, &succeeded)); return succeeded; }
};
template<typename X> struct adapt<IHttpCookiePairHeaderValueCollection, X> : Windows::Web::Http::Headers::IHttpCookiePairHeaderValueCollection_adaptor<X> { typedef adapt IHttpCookiePairHeaderValueCollection; };
struct IHttpCookiePairHeaderValueCollection : IHttpCookiePairHeaderValueCollection_raw, generate<IHttpCookiePairHeaderValueCollection> {};

// HttpCookiePairHeaderValueCollection
template<typename X> struct statics<HttpCookiePairHeaderValueCollection, X> : X {
	typedef typename X::root_type HttpCookiePairHeaderValueCollection;
};
struct HttpCookiePairHeaderValueCollection : generate<HttpCookiePairHeaderValueCollection> {};

// IHttpExpectationHeaderValueStatics
struct IHttpExpectationHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpExpectationHeaderValue* *expectationHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpExpectationHeaderValue* *expectationHeaderValue, bool *succeeded);
};

// IHttpExpectationHeaderValueFactory
struct IHttpExpectationHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromName(HSTRING name, HttpExpectationHeaderValue* *expectationHeaderValue);
	virtual STDMETHODIMP _CreateFromNameWithValue(HSTRING name, HSTRING value, HttpExpectationHeaderValue* *expectationHeaderValue);
};

// IHttpExpectationHeaderValue
struct IHttpExpectationHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_Value(HSTRING *value);
	virtual STDMETHODIMP _put_Value(HSTRING value);
	virtual STDMETHODIMP _get_Parameters(Foundation::Collections::IVector<HttpNameValueHeaderValue*>* *value);
};
template<typename X> struct IHttpExpectationHeaderValue_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpExpectationHeaderValue_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> get() { Foundation::Collections::IVector<HttpNameValueHeaderValue*>* value; hrcheck(enc(&IHttpExpectationHeaderValue_adaptor::Parameters)->_get_Parameters(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> operator->() { return get(); }
		} Parameters;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpExpectationHeaderValue_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IHttpExpectationHeaderValue_adaptor::Value)->_put_Value(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Value;
	};
	IHttpExpectationHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpExpectationHeaderValue, X> : Windows::Web::Http::Headers::IHttpExpectationHeaderValue_adaptor<X> { typedef adapt IHttpExpectationHeaderValue; };
struct IHttpExpectationHeaderValue : IHttpExpectationHeaderValue_raw, generate<IHttpExpectationHeaderValue> {};

// HttpExpectationHeaderValue
template<typename> struct HttpExpectationHeaderValue_statics {
	static ptr<HttpExpectationHeaderValue> Parse(hstring_ref input) { HttpExpectationHeaderValue* expectationHeaderValue; hrcheck(get_activation_factory<HttpExpectationHeaderValue, IHttpExpectationHeaderValueStatics>()->_Parse(input, &expectationHeaderValue)); return from_abi(expectationHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpExpectationHeaderValue> *expectationHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpExpectationHeaderValue, IHttpExpectationHeaderValueStatics>()->_TryParse(input, expectationHeaderValue, &succeeded)); return succeeded; }
	static HttpExpectationHeaderValue *activate(hstring_ref name) { HttpExpectationHeaderValue *expectationHeaderValue; hrcheck(get_activation_factory<HttpExpectationHeaderValue, IHttpExpectationHeaderValueFactory>()->_CreateFromName(name, &expectationHeaderValue)); return expectationHeaderValue; }
	static HttpExpectationHeaderValue *activate(hstring_ref name, hstring_ref value) { HttpExpectationHeaderValue *expectationHeaderValue; hrcheck(get_activation_factory<HttpExpectationHeaderValue, IHttpExpectationHeaderValueFactory>()->_CreateFromNameWithValue(name, value, &expectationHeaderValue)); return expectationHeaderValue; }
};

template<typename X> struct statics<HttpExpectationHeaderValue, X> : X, Windows::Web::Http::Headers::HttpExpectationHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpExpectationHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpExpectationHeaderValue;
};
struct HttpExpectationHeaderValue : generate<HttpExpectationHeaderValue> {};

// IHttpExpectationHeaderValueCollection
struct IHttpExpectationHeaderValueCollection_raw : IInspectable {
	virtual STDMETHODIMP _ParseAdd(HSTRING input);
	virtual STDMETHODIMP _TryParseAdd(HSTRING input, bool *succeeded);
};
template<typename X> struct IHttpExpectationHeaderValueCollection_adaptor : X {
	void ParseAdd(hstring_ref input) { hrcheck(X::get()->_ParseAdd(input)); }
	bool TryParseAdd(hstring_ref input) { bool succeeded; hrcheck(X::get()->_TryParseAdd(input, &succeeded)); return succeeded; }
};
template<typename X> struct adapt<IHttpExpectationHeaderValueCollection, X> : Windows::Web::Http::Headers::IHttpExpectationHeaderValueCollection_adaptor<X> { typedef adapt IHttpExpectationHeaderValueCollection; };
struct IHttpExpectationHeaderValueCollection : IHttpExpectationHeaderValueCollection_raw, generate<IHttpExpectationHeaderValueCollection> {};

// HttpExpectationHeaderValueCollection
template<typename X> struct statics<HttpExpectationHeaderValueCollection, X> : X {
	typedef typename X::root_type HttpExpectationHeaderValueCollection;
};
struct HttpExpectationHeaderValueCollection : generate<HttpExpectationHeaderValueCollection> {};

// IHttpTransferCodingHeaderValueStatics
struct IHttpTransferCodingHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpTransferCodingHeaderValue* *transferCodingHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpTransferCodingHeaderValue* *transferCodingHeaderValue, bool *succeeded);
};

// IHttpTransferCodingHeaderValueFactory
struct IHttpTransferCodingHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _Create(HSTRING input, HttpTransferCodingHeaderValue* *transferCodingHeaderValue);
};

// IHttpTransferCodingHeaderValue
struct IHttpTransferCodingHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_Parameters(Foundation::Collections::IVector<HttpNameValueHeaderValue*>* *value);
	virtual STDMETHODIMP _get_Value(HSTRING *value);
};
template<typename X> struct IHttpTransferCodingHeaderValue_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> get() { Foundation::Collections::IVector<HttpNameValueHeaderValue*>* value; hrcheck(enc(&IHttpTransferCodingHeaderValue_adaptor::Parameters)->_get_Parameters(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> operator->() { return get(); }
		} Parameters;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpTransferCodingHeaderValue_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Value;
	};
	IHttpTransferCodingHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpTransferCodingHeaderValue, X> : Windows::Web::Http::Headers::IHttpTransferCodingHeaderValue_adaptor<X> { typedef adapt IHttpTransferCodingHeaderValue; };
struct IHttpTransferCodingHeaderValue : IHttpTransferCodingHeaderValue_raw, generate<IHttpTransferCodingHeaderValue> {};

// HttpTransferCodingHeaderValue
template<typename> struct HttpTransferCodingHeaderValue_statics {
	static ptr<HttpTransferCodingHeaderValue> Parse(hstring_ref input) { HttpTransferCodingHeaderValue* transferCodingHeaderValue; hrcheck(get_activation_factory<HttpTransferCodingHeaderValue, IHttpTransferCodingHeaderValueStatics>()->_Parse(input, &transferCodingHeaderValue)); return from_abi(transferCodingHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpTransferCodingHeaderValue> *transferCodingHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpTransferCodingHeaderValue, IHttpTransferCodingHeaderValueStatics>()->_TryParse(input, transferCodingHeaderValue, &succeeded)); return succeeded; }
	static HttpTransferCodingHeaderValue *activate(hstring_ref input) { HttpTransferCodingHeaderValue *transferCodingHeaderValue; hrcheck(get_activation_factory<HttpTransferCodingHeaderValue, IHttpTransferCodingHeaderValueFactory>()->_Create(input, &transferCodingHeaderValue)); return transferCodingHeaderValue; }
};

template<typename X> struct statics<HttpTransferCodingHeaderValue, X> : X, Windows::Web::Http::Headers::HttpTransferCodingHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpTransferCodingHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpTransferCodingHeaderValue;
};
struct HttpTransferCodingHeaderValue : generate<HttpTransferCodingHeaderValue> {};

// IHttpTransferCodingHeaderValueCollection
struct IHttpTransferCodingHeaderValueCollection_raw : IInspectable {
	virtual STDMETHODIMP _ParseAdd(HSTRING input);
	virtual STDMETHODIMP _TryParseAdd(HSTRING input, bool *succeeded);
};
template<typename X> struct IHttpTransferCodingHeaderValueCollection_adaptor : X {
	void ParseAdd(hstring_ref input) { hrcheck(X::get()->_ParseAdd(input)); }
	bool TryParseAdd(hstring_ref input) { bool succeeded; hrcheck(X::get()->_TryParseAdd(input, &succeeded)); return succeeded; }
};
template<typename X> struct adapt<IHttpTransferCodingHeaderValueCollection, X> : Windows::Web::Http::Headers::IHttpTransferCodingHeaderValueCollection_adaptor<X> { typedef adapt IHttpTransferCodingHeaderValueCollection; };
struct IHttpTransferCodingHeaderValueCollection : IHttpTransferCodingHeaderValueCollection_raw, generate<IHttpTransferCodingHeaderValueCollection> {};

// HttpTransferCodingHeaderValueCollection
template<typename X> struct statics<HttpTransferCodingHeaderValueCollection, X> : X {
	typedef typename X::root_type HttpTransferCodingHeaderValueCollection;
};
struct HttpTransferCodingHeaderValueCollection : generate<HttpTransferCodingHeaderValueCollection> {};

// IHttpProductInfoHeaderValueStatics
struct IHttpProductInfoHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpProductInfoHeaderValue* *productInfoHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpProductInfoHeaderValue* *productInfoHeaderValue, bool *succeeded);
};

// IHttpProductInfoHeaderValueFactory
struct IHttpProductInfoHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromComment(HSTRING productComment, HttpProductInfoHeaderValue* *productInfoHeaderValue);
	virtual STDMETHODIMP _CreateFromNameWithVersion(HSTRING productName, HSTRING productVersion, HttpProductInfoHeaderValue* *productInfoHeaderValue);
};

// IHttpProductInfoHeaderValue
struct IHttpProductInfoHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_Product(HttpProductHeaderValue* *value);
	virtual STDMETHODIMP _get_Comment(HSTRING *value);
};
template<typename X> struct IHttpProductInfoHeaderValue_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpProductInfoHeaderValue_adaptor::Comment)->_get_Comment(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Comment;
		struct : property {
			ptr<HttpProductHeaderValue> get() { HttpProductHeaderValue* value; hrcheck(enc(&IHttpProductInfoHeaderValue_adaptor::Product)->_get_Product(&value)); return from_abi(value); }
			ptr<HttpProductHeaderValue> operator()() { return get(); }
			operator ptr<HttpProductHeaderValue> () { return get(); }
			ptr<HttpProductHeaderValue> operator->() { return get(); }
		} Product;
	};
	IHttpProductInfoHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpProductInfoHeaderValue, X> : Windows::Web::Http::Headers::IHttpProductInfoHeaderValue_adaptor<X> { typedef adapt IHttpProductInfoHeaderValue; };
struct IHttpProductInfoHeaderValue : IHttpProductInfoHeaderValue_raw, generate<IHttpProductInfoHeaderValue> {};

// HttpProductInfoHeaderValue
template<typename> struct HttpProductInfoHeaderValue_statics {
	static ptr<HttpProductInfoHeaderValue> Parse(hstring_ref input) { HttpProductInfoHeaderValue* productInfoHeaderValue; hrcheck(get_activation_factory<HttpProductInfoHeaderValue, IHttpProductInfoHeaderValueStatics>()->_Parse(input, &productInfoHeaderValue)); return from_abi(productInfoHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpProductInfoHeaderValue> *productInfoHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpProductInfoHeaderValue, IHttpProductInfoHeaderValueStatics>()->_TryParse(input, productInfoHeaderValue, &succeeded)); return succeeded; }
	static HttpProductInfoHeaderValue *activate(hstring_ref productComment) { HttpProductInfoHeaderValue *productInfoHeaderValue; hrcheck(get_activation_factory<HttpProductInfoHeaderValue, IHttpProductInfoHeaderValueFactory>()->_CreateFromComment(productComment, &productInfoHeaderValue)); return productInfoHeaderValue; }
	static HttpProductInfoHeaderValue *activate(hstring_ref productName, hstring_ref productVersion) { HttpProductInfoHeaderValue *productInfoHeaderValue; hrcheck(get_activation_factory<HttpProductInfoHeaderValue, IHttpProductInfoHeaderValueFactory>()->_CreateFromNameWithVersion(productName, productVersion, &productInfoHeaderValue)); return productInfoHeaderValue; }
};

template<typename X> struct statics<HttpProductInfoHeaderValue, X> : X, Windows::Web::Http::Headers::HttpProductInfoHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpProductInfoHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpProductInfoHeaderValue;
};
struct HttpProductInfoHeaderValue : generate<HttpProductInfoHeaderValue> {};

// IHttpProductInfoHeaderValueCollection
struct IHttpProductInfoHeaderValueCollection_raw : IInspectable {
	virtual STDMETHODIMP _ParseAdd(HSTRING input);
	virtual STDMETHODIMP _TryParseAdd(HSTRING input, bool *succeeded);
};
template<typename X> struct IHttpProductInfoHeaderValueCollection_adaptor : X {
	void ParseAdd(hstring_ref input) { hrcheck(X::get()->_ParseAdd(input)); }
	bool TryParseAdd(hstring_ref input) { bool succeeded; hrcheck(X::get()->_TryParseAdd(input, &succeeded)); return succeeded; }
};
template<typename X> struct adapt<IHttpProductInfoHeaderValueCollection, X> : Windows::Web::Http::Headers::IHttpProductInfoHeaderValueCollection_adaptor<X> { typedef adapt IHttpProductInfoHeaderValueCollection; };
struct IHttpProductInfoHeaderValueCollection : IHttpProductInfoHeaderValueCollection_raw, generate<IHttpProductInfoHeaderValueCollection> {};

// HttpProductInfoHeaderValueCollection
template<typename X> struct statics<HttpProductInfoHeaderValueCollection, X> : X {
	typedef typename X::root_type HttpProductInfoHeaderValueCollection;
};
struct HttpProductInfoHeaderValueCollection : generate<HttpProductInfoHeaderValueCollection> {};

// IHttpMethodHeaderValueCollection
struct IHttpMethodHeaderValueCollection_raw : IInspectable {
	virtual STDMETHODIMP _ParseAdd(HSTRING input);
	virtual STDMETHODIMP _TryParseAdd(HSTRING input, bool *succeeded);
};
template<typename X> struct IHttpMethodHeaderValueCollection_adaptor : X {
	void ParseAdd(hstring_ref input) { hrcheck(X::get()->_ParseAdd(input)); }
	bool TryParseAdd(hstring_ref input) { bool succeeded; hrcheck(X::get()->_TryParseAdd(input, &succeeded)); return succeeded; }
};
template<typename X> struct adapt<IHttpMethodHeaderValueCollection, X> : Windows::Web::Http::Headers::IHttpMethodHeaderValueCollection_adaptor<X> { typedef adapt IHttpMethodHeaderValueCollection; };
struct IHttpMethodHeaderValueCollection : IHttpMethodHeaderValueCollection_raw, generate<IHttpMethodHeaderValueCollection> {};

// HttpMethodHeaderValueCollection
template<typename X> struct statics<HttpMethodHeaderValueCollection, X> : X {
	typedef typename X::root_type HttpMethodHeaderValueCollection;
};
struct HttpMethodHeaderValueCollection : generate<HttpMethodHeaderValueCollection> {};

// IHttpChallengeHeaderValueStatics
struct IHttpChallengeHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpChallengeHeaderValue* *challengeHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpChallengeHeaderValue* *challengeHeaderValue, bool *succeeded);
};

// IHttpChallengeHeaderValueFactory
struct IHttpChallengeHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromScheme(HSTRING scheme, HttpChallengeHeaderValue* *challengeHeaderValue);
	virtual STDMETHODIMP _CreateFromSchemeWithToken(HSTRING scheme, HSTRING token, HttpChallengeHeaderValue* *challengeHeaderValue);
};

// IHttpChallengeHeaderValue
struct IHttpChallengeHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_Parameters(Foundation::Collections::IVector<HttpNameValueHeaderValue*>* *value);
	virtual STDMETHODIMP _get_Scheme(HSTRING *value);
	virtual STDMETHODIMP _get_Token(HSTRING *value);
};
template<typename X> struct IHttpChallengeHeaderValue_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> get() { Foundation::Collections::IVector<HttpNameValueHeaderValue*>* value; hrcheck(enc(&IHttpChallengeHeaderValue_adaptor::Parameters)->_get_Parameters(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<HttpNameValueHeaderValue>>> operator->() { return get(); }
		} Parameters;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpChallengeHeaderValue_adaptor::Scheme)->_get_Scheme(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Scheme;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpChallengeHeaderValue_adaptor::Token)->_get_Token(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Token;
	};
	IHttpChallengeHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpChallengeHeaderValue, X> : Windows::Web::Http::Headers::IHttpChallengeHeaderValue_adaptor<X> { typedef adapt IHttpChallengeHeaderValue; };
struct IHttpChallengeHeaderValue : IHttpChallengeHeaderValue_raw, generate<IHttpChallengeHeaderValue> {};

// HttpChallengeHeaderValue
template<typename> struct HttpChallengeHeaderValue_statics {
	static ptr<HttpChallengeHeaderValue> Parse(hstring_ref input) { HttpChallengeHeaderValue* challengeHeaderValue; hrcheck(get_activation_factory<HttpChallengeHeaderValue, IHttpChallengeHeaderValueStatics>()->_Parse(input, &challengeHeaderValue)); return from_abi(challengeHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpChallengeHeaderValue> *challengeHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpChallengeHeaderValue, IHttpChallengeHeaderValueStatics>()->_TryParse(input, challengeHeaderValue, &succeeded)); return succeeded; }
	static HttpChallengeHeaderValue *activate(hstring_ref scheme) { HttpChallengeHeaderValue *challengeHeaderValue; hrcheck(get_activation_factory<HttpChallengeHeaderValue, IHttpChallengeHeaderValueFactory>()->_CreateFromScheme(scheme, &challengeHeaderValue)); return challengeHeaderValue; }
	static HttpChallengeHeaderValue *activate(hstring_ref scheme, hstring_ref token) { HttpChallengeHeaderValue *challengeHeaderValue; hrcheck(get_activation_factory<HttpChallengeHeaderValue, IHttpChallengeHeaderValueFactory>()->_CreateFromSchemeWithToken(scheme, token, &challengeHeaderValue)); return challengeHeaderValue; }
};

template<typename X> struct statics<HttpChallengeHeaderValue, X> : X, Windows::Web::Http::Headers::HttpChallengeHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpChallengeHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpChallengeHeaderValue;
};
struct HttpChallengeHeaderValue : generate<HttpChallengeHeaderValue> {};

// IHttpChallengeHeaderValueCollection
struct IHttpChallengeHeaderValueCollection_raw : IInspectable {
	virtual STDMETHODIMP _ParseAdd(HSTRING input);
	virtual STDMETHODIMP _TryParseAdd(HSTRING input, bool *succeeded);
};
template<typename X> struct IHttpChallengeHeaderValueCollection_adaptor : X {
	void ParseAdd(hstring_ref input) { hrcheck(X::get()->_ParseAdd(input)); }
	bool TryParseAdd(hstring_ref input) { bool succeeded; hrcheck(X::get()->_TryParseAdd(input, &succeeded)); return succeeded; }
};
template<typename X> struct adapt<IHttpChallengeHeaderValueCollection, X> : Windows::Web::Http::Headers::IHttpChallengeHeaderValueCollection_adaptor<X> { typedef adapt IHttpChallengeHeaderValueCollection; };
struct IHttpChallengeHeaderValueCollection : IHttpChallengeHeaderValueCollection_raw, generate<IHttpChallengeHeaderValueCollection> {};

// HttpChallengeHeaderValueCollection
template<typename X> struct statics<HttpChallengeHeaderValueCollection, X> : X {
	typedef typename X::root_type HttpChallengeHeaderValueCollection;
};
struct HttpChallengeHeaderValueCollection : generate<HttpChallengeHeaderValueCollection> {};

// IHttpDateOrDeltaHeaderValueStatics
struct IHttpDateOrDeltaHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpDateOrDeltaHeaderValue* *dateOrDeltaHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpDateOrDeltaHeaderValue* *dateOrDeltaHeaderValue, bool *succeeded);
};

// IHttpDateOrDeltaHeaderValue
struct IHttpDateOrDeltaHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_Date(Foundation::IReference<Foundation::DateTime>* *value);
	virtual STDMETHODIMP _get_Delta(Foundation::IReference<Foundation::TimeSpan>* *value);
};
template<typename X> struct IHttpDateOrDeltaHeaderValue_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Foundation::DateTime>> get() { Foundation::IReference<Foundation::DateTime>* value; hrcheck(enc(&IHttpDateOrDeltaHeaderValue_adaptor::Date)->_get_Date(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator->() { return get(); }
		} Date;
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IHttpDateOrDeltaHeaderValue_adaptor::Delta)->_get_Delta(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
		} Delta;
	};
	IHttpDateOrDeltaHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpDateOrDeltaHeaderValue, X> : Windows::Web::Http::Headers::IHttpDateOrDeltaHeaderValue_adaptor<X> { typedef adapt IHttpDateOrDeltaHeaderValue; };
struct IHttpDateOrDeltaHeaderValue : IHttpDateOrDeltaHeaderValue_raw, generate<IHttpDateOrDeltaHeaderValue> {};

// HttpDateOrDeltaHeaderValue
template<typename> struct HttpDateOrDeltaHeaderValue_statics {
	static ptr<HttpDateOrDeltaHeaderValue> Parse(hstring_ref input) { HttpDateOrDeltaHeaderValue* dateOrDeltaHeaderValue; hrcheck(get_activation_factory<HttpDateOrDeltaHeaderValue, IHttpDateOrDeltaHeaderValueStatics>()->_Parse(input, &dateOrDeltaHeaderValue)); return from_abi(dateOrDeltaHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpDateOrDeltaHeaderValue> *dateOrDeltaHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpDateOrDeltaHeaderValue, IHttpDateOrDeltaHeaderValueStatics>()->_TryParse(input, dateOrDeltaHeaderValue, &succeeded)); return succeeded; }
};

template<typename X> struct statics<HttpDateOrDeltaHeaderValue, X> : X, Windows::Web::Http::Headers::HttpDateOrDeltaHeaderValue_statics<void> {
	typedef typename X::root_type HttpDateOrDeltaHeaderValue;
};
struct HttpDateOrDeltaHeaderValue : generate<HttpDateOrDeltaHeaderValue> {};

// IHttpProductHeaderValueStatics
struct IHttpProductHeaderValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, HttpProductHeaderValue* *productHeaderValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, HttpProductHeaderValue* *productHeaderValue, bool *succeeded);
};

// IHttpProductHeaderValueFactory
struct IHttpProductHeaderValueFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromName(HSTRING productName, HttpProductHeaderValue* *productHeaderValue);
	virtual STDMETHODIMP _CreateFromNameWithVersion(HSTRING productName, HSTRING productVersion, HttpProductHeaderValue* *productHeaderValue);
};

// IHttpProductHeaderValue
struct IHttpProductHeaderValue_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_Version(HSTRING *value);
};
template<typename X> struct IHttpProductHeaderValue_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpProductHeaderValue_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpProductHeaderValue_adaptor::Version)->_get_Version(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Version;
	};
	IHttpProductHeaderValue_adaptor() {}
};
template<typename X> struct adapt<IHttpProductHeaderValue, X> : Windows::Web::Http::Headers::IHttpProductHeaderValue_adaptor<X> { typedef adapt IHttpProductHeaderValue; };
struct IHttpProductHeaderValue : IHttpProductHeaderValue_raw, generate<IHttpProductHeaderValue> {};

// HttpProductHeaderValue
template<typename> struct HttpProductHeaderValue_statics {
	static ptr<HttpProductHeaderValue> Parse(hstring_ref input) { HttpProductHeaderValue* productHeaderValue; hrcheck(get_activation_factory<HttpProductHeaderValue, IHttpProductHeaderValueStatics>()->_Parse(input, &productHeaderValue)); return from_abi(productHeaderValue); }
	static bool TryParse(hstring_ref input, pptr<HttpProductHeaderValue> *productHeaderValue) { bool succeeded; hrcheck(get_activation_factory<HttpProductHeaderValue, IHttpProductHeaderValueStatics>()->_TryParse(input, productHeaderValue, &succeeded)); return succeeded; }
	static HttpProductHeaderValue *activate(hstring_ref productName) { HttpProductHeaderValue *productHeaderValue; hrcheck(get_activation_factory<HttpProductHeaderValue, IHttpProductHeaderValueFactory>()->_CreateFromName(productName, &productHeaderValue)); return productHeaderValue; }
	static HttpProductHeaderValue *activate(hstring_ref productName, hstring_ref productVersion) { HttpProductHeaderValue *productHeaderValue; hrcheck(get_activation_factory<HttpProductHeaderValue, IHttpProductHeaderValueFactory>()->_CreateFromNameWithVersion(productName, productVersion, &productHeaderValue)); return productHeaderValue; }
};

template<typename X> struct statics<HttpProductHeaderValue, X> : X, Windows::Web::Http::Headers::HttpProductHeaderValue_statics<void> {
	using Windows::Web::Http::Headers::HttpProductHeaderValue_statics<void>::activate;
	typedef typename X::root_type HttpProductHeaderValue;
};
struct HttpProductHeaderValue : generate<HttpProductHeaderValue> {};
}}}}
} // namespace iso_winrt
