#pragma once
// generated by isopod tools
// namespaces:
// Windows.Services.Maps.Guidance

#include "Windows.Services.Maps.Guidance.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.UI.0.h"
#include "Windows.Devices.Geolocation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IVectorView;
}}
namespace Services { namespace Maps {
struct MapRoute;
}}}

// defs

template<> struct def<Windows::Services::Maps::Guidance::IGuidanceRoadSignpost> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceRoadSignpost> : class_type<Platform::Object, Windows::Services::Maps::Guidance::IGuidanceRoadSignpost> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceManeuverKind> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceMode> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceAudioMeasurementSystem> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceAudioNotifications> : enum_type<unsigned> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceAudioNotificationKind> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceLaneMarkers> : enum_type<unsigned> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceManeuver> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceManeuver> : class_type<Platform::Object, Windows::Services::Maps::Guidance::IGuidanceManeuver> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceUpdatedEventArgs> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceRouteStatics> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceRoute> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceRoute> : class_type<Platform::Object, Windows::Services::Maps::Guidance::IGuidanceRoute> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceMapMatchedCoordinate> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceMapMatchedCoordinate> : class_type<Platform::Object, Windows::Services::Maps::Guidance::IGuidanceMapMatchedCoordinate> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceLaneInfo> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceLaneInfo> : class_type<Platform::Object, Windows::Services::Maps::Guidance::IGuidanceLaneInfo> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs> : class_type<Platform::Object, Windows::Services::Maps::Guidance::IGuidanceUpdatedEventArgs> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceReroutedEventArgs> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceReroutedEventArgs> : class_type<Platform::Object, Windows::Services::Maps::Guidance::IGuidanceReroutedEventArgs> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceAudioNotificationRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceAudioNotificationRequestedEventArgs> : class_type<Platform::Object, Windows::Services::Maps::Guidance::IGuidanceAudioNotificationRequestedEventArgs> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceNavigator> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceNavigatorStatics2> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceNavigatorStatics> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceNavigator2> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceNavigator> : class_type<Platform::Object, Windows::Services::Maps::Guidance::IGuidanceNavigator, Windows::Services::Maps::Guidance::IGuidanceNavigator2> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceRoadSegment> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceRoadSegment2> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceRoadSegment> : class_type<Platform::Object, Windows::Services::Maps::Guidance::IGuidanceRoadSegment, Windows::Services::Maps::Guidance::IGuidanceRoadSegment2> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceTelemetryCollectorStatics> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::IGuidanceTelemetryCollector> : interface_type<> {};
template<> struct def<Windows::Services::Maps::Guidance::GuidanceTelemetryCollector> : class_type<Platform::Object, Windows::Services::Maps::Guidance::IGuidanceTelemetryCollector> {};

// uuids

template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceRoadSignpost> { define_guid(0xF1A728B6, 0xF77A, 0x4742, 0x83, 0x12, 0x53, 0x30, 0xF, 0x98, 0x45, 0xF0);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceManeuver> { define_guid(0xFC09326C, 0xECC9, 0x4928, 0xA2, 0xA1, 0x72, 0x32, 0xB9, 0x9B, 0x94, 0xA1);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceUpdatedEventArgs> { define_guid(0xFDAC160B, 0x9E8D, 0x4DE3, 0xA9, 0xFA, 0xB0, 0x63, 0x21, 0xD1, 0x8D, 0xB9);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceRouteStatics> { define_guid(0xF56D926A, 0x55ED, 0x49C1, 0xB0, 0x9C, 0x4B, 0x82, 0x23, 0xB5, 0xD, 0xB3);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceRoute> { define_guid(0x3A14545D, 0x801A, 0x40BD, 0xA2, 0x86, 0xAF, 0xB2, 0x1, 0xC, 0xCE, 0x6C);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceMapMatchedCoordinate> { define_guid(0xB7ACB168, 0x2912, 0x4A99, 0xAF, 0xF1, 0x79, 0x86, 0x9, 0xB9, 0x81, 0xFE);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceLaneInfo> { define_guid(0x8404D114, 0x6581, 0x43B7, 0xAC, 0x15, 0xC9, 0x7, 0x9B, 0xF9, 0xD, 0xF1);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceReroutedEventArgs> { define_guid(0x115D4008, 0xD528, 0x454E, 0xBB, 0x94, 0xA5, 0x3, 0x41, 0xD2, 0xC9, 0xF1);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceAudioNotificationRequestedEventArgs> { define_guid(0xCA2AA24A, 0xC7C2, 0x4D4C, 0x9D, 0x7C, 0x49, 0x95, 0x76, 0xBC, 0xED, 0xDB);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceNavigator> { define_guid(0x8F17EF7, 0x8E3F, 0x4D9A, 0xBE, 0x8A, 0x10, 0x8F, 0x9A, 0x1, 0x2C, 0x67);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceNavigatorStatics2> { define_guid(0x54C5C3E2, 0x7784, 0x4C85, 0x8C, 0x95, 0xD0, 0xC6, 0xEF, 0xB4, 0x39, 0x65);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceNavigatorStatics> { define_guid(0xFD9513, 0x4456, 0x4E66, 0xA1, 0x43, 0x3A, 0xDD, 0x6B, 0xE0, 0x84, 0x26);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceNavigator2> { define_guid(0x6CDC50D1, 0x41C, 0x4BF3, 0xB6, 0x33, 0xA1, 0x1, 0xFC, 0x2F, 0x6B, 0x57);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceRoadSegment> { define_guid(0xB32758A6, 0xBE78, 0x4C63, 0xAF, 0xE7, 0x6C, 0x29, 0x57, 0x47, 0x9B, 0x3E);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceRoadSegment2> { define_guid(0x2474A61D, 0x1723, 0x49F1, 0x89, 0x5B, 0x47, 0xA2, 0xC4, 0xAA, 0x9C, 0x55);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceTelemetryCollectorStatics> { define_guid(0x36532047, 0xF160, 0x44FB, 0xB5, 0x78, 0x94, 0x57, 0x7C, 0xA0, 0x59, 0x90);};
template<> struct uuid<Windows::Services::Maps::Guidance::IGuidanceTelemetryCollector> { define_guid(0xDB1F8DA5, 0xB878, 0x4D92, 0x98, 0xDD, 0x34, 0x7D, 0x23, 0xD3, 0x82, 0x62);};

// types

namespace Windows { namespace Services { namespace Maps { namespace Guidance {

// IGuidanceRoadSignpost
struct IGuidanceRoadSignpost_raw : IInspectable {
	virtual STDMETHODIMP _get_ExitNumber(HSTRING *value);
	virtual STDMETHODIMP _get_Exit(HSTRING *value);
	virtual STDMETHODIMP _get_BackgroundColor(UI::Color *value);
	virtual STDMETHODIMP _get_ForegroundColor(UI::Color *value);
	virtual STDMETHODIMP _get_ExitDirections(Foundation::Collections::IVectorView<HSTRING>* *value);
};
template<typename X> struct IGuidanceRoadSignpost_adaptor : X {
	union {
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&IGuidanceRoadSignpost_adaptor::BackgroundColor)->_get_BackgroundColor(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
		} BackgroundColor;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGuidanceRoadSignpost_adaptor::Exit)->_get_Exit(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Exit;
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&IGuidanceRoadSignpost_adaptor::ExitDirections)->_get_ExitDirections(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} ExitDirections;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGuidanceRoadSignpost_adaptor::ExitNumber)->_get_ExitNumber(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ExitNumber;
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&IGuidanceRoadSignpost_adaptor::ForegroundColor)->_get_ForegroundColor(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
		} ForegroundColor;
	};
	IGuidanceRoadSignpost_adaptor() {}
};
template<typename X> struct adapt<IGuidanceRoadSignpost, X> : Windows::Services::Maps::Guidance::IGuidanceRoadSignpost_adaptor<X> { typedef adapt IGuidanceRoadSignpost; };
struct IGuidanceRoadSignpost : IGuidanceRoadSignpost_raw, generate<IGuidanceRoadSignpost> {};

// GuidanceRoadSignpost
template<typename X> struct statics<GuidanceRoadSignpost, X> : X {
	typedef typename X::root_type GuidanceRoadSignpost;
};
struct GuidanceRoadSignpost : generate<GuidanceRoadSignpost> {};

// IGuidanceManeuver
struct IGuidanceManeuver_raw : IInspectable {
	virtual STDMETHODIMP _get_StartLocation(Devices::Geolocation::Geopoint* *value);
	virtual STDMETHODIMP _get_DistanceFromRouteStart(int *value);
	virtual STDMETHODIMP _get_DistanceFromPreviousManeuver(int *value);
	virtual STDMETHODIMP _get_DepartureRoadName(HSTRING *value);
	virtual STDMETHODIMP _get_NextRoadName(HSTRING *value);
	virtual STDMETHODIMP _get_DepartureShortRoadName(HSTRING *value);
	virtual STDMETHODIMP _get_NextShortRoadName(HSTRING *value);
	virtual STDMETHODIMP _get_Kind(GuidanceManeuverKind *value);
	virtual STDMETHODIMP _get_StartAngle(int *value);
	virtual STDMETHODIMP _get_EndAngle(int *value);
	virtual STDMETHODIMP _get_RoadSignpost(GuidanceRoadSignpost* *value);
	virtual STDMETHODIMP _get_InstructionText(HSTRING *value);
};
template<typename X> struct IGuidanceManeuver_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGuidanceManeuver_adaptor::DepartureRoadName)->_get_DepartureRoadName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DepartureRoadName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGuidanceManeuver_adaptor::DepartureShortRoadName)->_get_DepartureShortRoadName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DepartureShortRoadName;
		struct : property {
			int get() { int value; hrcheck(enc(&IGuidanceManeuver_adaptor::DistanceFromPreviousManeuver)->_get_DistanceFromPreviousManeuver(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} DistanceFromPreviousManeuver;
		struct : property {
			int get() { int value; hrcheck(enc(&IGuidanceManeuver_adaptor::DistanceFromRouteStart)->_get_DistanceFromRouteStart(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} DistanceFromRouteStart;
		struct : property {
			int get() { int value; hrcheck(enc(&IGuidanceManeuver_adaptor::EndAngle)->_get_EndAngle(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} EndAngle;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGuidanceManeuver_adaptor::InstructionText)->_get_InstructionText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} InstructionText;
		struct : property {
			GuidanceManeuverKind get() { GuidanceManeuverKind value; hrcheck(enc(&IGuidanceManeuver_adaptor::Kind)->_get_Kind(&value)); return value; }
			GuidanceManeuverKind operator()() { return get(); }
			operator GuidanceManeuverKind () { return get(); }
		} Kind;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGuidanceManeuver_adaptor::NextRoadName)->_get_NextRoadName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} NextRoadName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGuidanceManeuver_adaptor::NextShortRoadName)->_get_NextShortRoadName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} NextShortRoadName;
		struct : property {
			ptr<GuidanceRoadSignpost> get() { GuidanceRoadSignpost* value; hrcheck(enc(&IGuidanceManeuver_adaptor::RoadSignpost)->_get_RoadSignpost(&value)); return from_abi(value); }
			ptr<GuidanceRoadSignpost> operator()() { return get(); }
			operator ptr<GuidanceRoadSignpost> () { return get(); }
			ptr<GuidanceRoadSignpost> operator->() { return get(); }
		} RoadSignpost;
		struct : property {
			int get() { int value; hrcheck(enc(&IGuidanceManeuver_adaptor::StartAngle)->_get_StartAngle(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} StartAngle;
		struct : property {
			ptr<Devices::Geolocation::Geopoint> get() { Devices::Geolocation::Geopoint* value; hrcheck(enc(&IGuidanceManeuver_adaptor::StartLocation)->_get_StartLocation(&value)); return from_abi(value); }
			ptr<Devices::Geolocation::Geopoint> operator()() { return get(); }
			operator ptr<Devices::Geolocation::Geopoint> () { return get(); }
			ptr<Devices::Geolocation::Geopoint> operator->() { return get(); }
		} StartLocation;
	};
	IGuidanceManeuver_adaptor() {}
};
template<typename X> struct adapt<IGuidanceManeuver, X> : Windows::Services::Maps::Guidance::IGuidanceManeuver_adaptor<X> { typedef adapt IGuidanceManeuver; };
struct IGuidanceManeuver : IGuidanceManeuver_raw, generate<IGuidanceManeuver> {};

// GuidanceManeuver
template<typename X> struct statics<GuidanceManeuver, X> : X {
	typedef typename X::root_type GuidanceManeuver;
};
struct GuidanceManeuver : generate<GuidanceManeuver> {};

// IGuidanceUpdatedEventArgs
struct IGuidanceUpdatedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Mode(GuidanceMode *value);
	virtual STDMETHODIMP _get_NextManeuver(GuidanceManeuver* *value);
	virtual STDMETHODIMP _get_NextManeuverDistance(int *value);
	virtual STDMETHODIMP _get_AfterNextManeuver(GuidanceManeuver* *value);
	virtual STDMETHODIMP _get_AfterNextManeuverDistance(int *value);
	virtual STDMETHODIMP _get_DistanceToDestination(int *value);
	virtual STDMETHODIMP _get_ElapsedDistance(int *value);
	virtual STDMETHODIMP _get_ElapsedTime(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_TimeToDestination(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_RoadName(HSTRING *value);
	virtual STDMETHODIMP _get_Route(GuidanceRoute* *result);
	virtual STDMETHODIMP _get_CurrentLocation(GuidanceMapMatchedCoordinate* *result);
	virtual STDMETHODIMP _get_IsNewManeuver(bool *value);
	virtual STDMETHODIMP _get_LaneInfo(Foundation::Collections::IVectorView<GuidanceLaneInfo*>* *value);
};
template<typename X> struct IGuidanceUpdatedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<GuidanceManeuver> get() { GuidanceManeuver* value; hrcheck(enc(&IGuidanceUpdatedEventArgs_adaptor::AfterNextManeuver)->_get_AfterNextManeuver(&value)); return from_abi(value); }
			ptr<GuidanceManeuver> operator()() { return get(); }
			operator ptr<GuidanceManeuver> () { return get(); }
			ptr<GuidanceManeuver> operator->() { return get(); }
		} AfterNextManeuver;
		struct : property {
			int get() { int value; hrcheck(enc(&IGuidanceUpdatedEventArgs_adaptor::AfterNextManeuverDistance)->_get_AfterNextManeuverDistance(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} AfterNextManeuverDistance;
		struct : property {
			ptr<GuidanceMapMatchedCoordinate> get() { GuidanceMapMatchedCoordinate* result; hrcheck(enc(&IGuidanceUpdatedEventArgs_adaptor::CurrentLocation)->_get_CurrentLocation(&result)); return from_abi(result); }
			ptr<GuidanceMapMatchedCoordinate> operator()() { return get(); }
			operator ptr<GuidanceMapMatchedCoordinate> () { return get(); }
			ptr<GuidanceMapMatchedCoordinate> operator->() { return get(); }
		} CurrentLocation;
		struct : property {
			int get() { int value; hrcheck(enc(&IGuidanceUpdatedEventArgs_adaptor::DistanceToDestination)->_get_DistanceToDestination(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} DistanceToDestination;
		struct : property {
			int get() { int value; hrcheck(enc(&IGuidanceUpdatedEventArgs_adaptor::ElapsedDistance)->_get_ElapsedDistance(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} ElapsedDistance;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IGuidanceUpdatedEventArgs_adaptor::ElapsedTime)->_get_ElapsedTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} ElapsedTime;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGuidanceUpdatedEventArgs_adaptor::IsNewManeuver)->_get_IsNewManeuver(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsNewManeuver;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<GuidanceLaneInfo>>> get() { Foundation::Collections::IVectorView<GuidanceLaneInfo*>* value; hrcheck(enc(&IGuidanceUpdatedEventArgs_adaptor::LaneInfo)->_get_LaneInfo(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<GuidanceLaneInfo>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<GuidanceLaneInfo>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<GuidanceLaneInfo>>> operator->() { return get(); }
		} LaneInfo;
		struct : property {
			GuidanceMode get() { GuidanceMode value; hrcheck(enc(&IGuidanceUpdatedEventArgs_adaptor::Mode)->_get_Mode(&value)); return value; }
			GuidanceMode operator()() { return get(); }
			operator GuidanceMode () { return get(); }
		} Mode;
		struct : property {
			ptr<GuidanceManeuver> get() { GuidanceManeuver* value; hrcheck(enc(&IGuidanceUpdatedEventArgs_adaptor::NextManeuver)->_get_NextManeuver(&value)); return from_abi(value); }
			ptr<GuidanceManeuver> operator()() { return get(); }
			operator ptr<GuidanceManeuver> () { return get(); }
			ptr<GuidanceManeuver> operator->() { return get(); }
		} NextManeuver;
		struct : property {
			int get() { int value; hrcheck(enc(&IGuidanceUpdatedEventArgs_adaptor::NextManeuverDistance)->_get_NextManeuverDistance(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} NextManeuverDistance;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGuidanceUpdatedEventArgs_adaptor::RoadName)->_get_RoadName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} RoadName;
		struct : property {
			ptr<GuidanceRoute> get() { GuidanceRoute* result; hrcheck(enc(&IGuidanceUpdatedEventArgs_adaptor::Route)->_get_Route(&result)); return from_abi(result); }
			ptr<GuidanceRoute> operator()() { return get(); }
			operator ptr<GuidanceRoute> () { return get(); }
			ptr<GuidanceRoute> operator->() { return get(); }
		} Route;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IGuidanceUpdatedEventArgs_adaptor::TimeToDestination)->_get_TimeToDestination(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} TimeToDestination;
	};
	IGuidanceUpdatedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IGuidanceUpdatedEventArgs, X> : Windows::Services::Maps::Guidance::IGuidanceUpdatedEventArgs_adaptor<X> { typedef adapt IGuidanceUpdatedEventArgs; };
struct IGuidanceUpdatedEventArgs : IGuidanceUpdatedEventArgs_raw, generate<IGuidanceUpdatedEventArgs> {};

// IGuidanceRouteStatics
struct IGuidanceRouteStatics : IInspectable {
	virtual STDMETHODIMP _CanCreateFromMapRoute(MapRoute* mapRoute, bool *result);
	virtual STDMETHODIMP _TryCreateFromMapRoute(MapRoute* mapRoute, GuidanceRoute* *result);
};

// IGuidanceRoute
struct IGuidanceRoute_raw : IInspectable {
	virtual STDMETHODIMP _get_Duration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_Distance(int *value);
	virtual STDMETHODIMP _get_Maneuvers(Foundation::Collections::IVectorView<GuidanceManeuver*>* *value);
	virtual STDMETHODIMP _get_BoundingBox(Devices::Geolocation::GeoboundingBox* *value);
	virtual STDMETHODIMP _get_Path(Devices::Geolocation::Geopath* *value);
	virtual STDMETHODIMP _get_RoadSegments(Foundation::Collections::IVectorView<GuidanceRoadSegment*>* *value);
	virtual STDMETHODIMP _ConvertToMapRoute(MapRoute* *result);
};
template<typename X> struct IGuidanceRoute_adaptor : X {
	union {
		struct : property {
			ptr<Devices::Geolocation::GeoboundingBox> get() { Devices::Geolocation::GeoboundingBox* value; hrcheck(enc(&IGuidanceRoute_adaptor::BoundingBox)->_get_BoundingBox(&value)); return from_abi(value); }
			ptr<Devices::Geolocation::GeoboundingBox> operator()() { return get(); }
			operator ptr<Devices::Geolocation::GeoboundingBox> () { return get(); }
			ptr<Devices::Geolocation::GeoboundingBox> operator->() { return get(); }
		} BoundingBox;
		struct : property {
			int get() { int value; hrcheck(enc(&IGuidanceRoute_adaptor::Distance)->_get_Distance(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} Distance;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IGuidanceRoute_adaptor::Duration)->_get_Duration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} Duration;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<GuidanceManeuver>>> get() { Foundation::Collections::IVectorView<GuidanceManeuver*>* value; hrcheck(enc(&IGuidanceRoute_adaptor::Maneuvers)->_get_Maneuvers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<GuidanceManeuver>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<GuidanceManeuver>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<GuidanceManeuver>>> operator->() { return get(); }
		} Maneuvers;
		struct : property {
			ptr<Devices::Geolocation::Geopath> get() { Devices::Geolocation::Geopath* value; hrcheck(enc(&IGuidanceRoute_adaptor::Path)->_get_Path(&value)); return from_abi(value); }
			ptr<Devices::Geolocation::Geopath> operator()() { return get(); }
			operator ptr<Devices::Geolocation::Geopath> () { return get(); }
			ptr<Devices::Geolocation::Geopath> operator->() { return get(); }
		} Path;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<GuidanceRoadSegment>>> get() { Foundation::Collections::IVectorView<GuidanceRoadSegment*>* value; hrcheck(enc(&IGuidanceRoute_adaptor::RoadSegments)->_get_RoadSegments(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<GuidanceRoadSegment>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<GuidanceRoadSegment>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<GuidanceRoadSegment>>> operator->() { return get(); }
		} RoadSegments;
	};
	ptr<MapRoute> ConvertToMapRoute() { MapRoute* result; hrcheck(X::get()->_ConvertToMapRoute(&result)); return from_abi(result); }
	IGuidanceRoute_adaptor() {}
};
template<typename X> struct adapt<IGuidanceRoute, X> : Windows::Services::Maps::Guidance::IGuidanceRoute_adaptor<X> { typedef adapt IGuidanceRoute; };
struct IGuidanceRoute : IGuidanceRoute_raw, generate<IGuidanceRoute> {};

// GuidanceRoute
template<typename> struct GuidanceRoute_statics {
	static bool CanCreateFromMapRoute(pptr<MapRoute> mapRoute) { bool result; hrcheck(get_activation_factory<GuidanceRoute, IGuidanceRouteStatics>()->_CanCreateFromMapRoute(mapRoute, &result)); return result; }
	static ptr<GuidanceRoute> TryCreateFromMapRoute(pptr<MapRoute> mapRoute) { GuidanceRoute* result; hrcheck(get_activation_factory<GuidanceRoute, IGuidanceRouteStatics>()->_TryCreateFromMapRoute(mapRoute, &result)); return from_abi(result); }
};

template<typename X> struct statics<GuidanceRoute, X> : X, Windows::Services::Maps::Guidance::GuidanceRoute_statics<void> {
	typedef typename X::root_type GuidanceRoute;
};
struct GuidanceRoute : generate<GuidanceRoute> {};

// IGuidanceMapMatchedCoordinate
struct IGuidanceMapMatchedCoordinate_raw : IInspectable {
	virtual STDMETHODIMP _get_Location(Devices::Geolocation::Geopoint* *value);
	virtual STDMETHODIMP _get_CurrentHeading(double *value);
	virtual STDMETHODIMP _get_CurrentSpeed(double *value);
	virtual STDMETHODIMP _get_IsOnStreet(bool *value);
	virtual STDMETHODIMP _get_Road(GuidanceRoadSegment* *value);
};
template<typename X> struct IGuidanceMapMatchedCoordinate_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IGuidanceMapMatchedCoordinate_adaptor::CurrentHeading)->_get_CurrentHeading(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} CurrentHeading;
		struct : property {
			double get() { double value; hrcheck(enc(&IGuidanceMapMatchedCoordinate_adaptor::CurrentSpeed)->_get_CurrentSpeed(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} CurrentSpeed;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGuidanceMapMatchedCoordinate_adaptor::IsOnStreet)->_get_IsOnStreet(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsOnStreet;
		struct : property {
			ptr<Devices::Geolocation::Geopoint> get() { Devices::Geolocation::Geopoint* value; hrcheck(enc(&IGuidanceMapMatchedCoordinate_adaptor::Location)->_get_Location(&value)); return from_abi(value); }
			ptr<Devices::Geolocation::Geopoint> operator()() { return get(); }
			operator ptr<Devices::Geolocation::Geopoint> () { return get(); }
			ptr<Devices::Geolocation::Geopoint> operator->() { return get(); }
		} Location;
		struct : property {
			ptr<GuidanceRoadSegment> get() { GuidanceRoadSegment* value; hrcheck(enc(&IGuidanceMapMatchedCoordinate_adaptor::Road)->_get_Road(&value)); return from_abi(value); }
			ptr<GuidanceRoadSegment> operator()() { return get(); }
			operator ptr<GuidanceRoadSegment> () { return get(); }
			ptr<GuidanceRoadSegment> operator->() { return get(); }
		} Road;
	};
	IGuidanceMapMatchedCoordinate_adaptor() {}
};
template<typename X> struct adapt<IGuidanceMapMatchedCoordinate, X> : Windows::Services::Maps::Guidance::IGuidanceMapMatchedCoordinate_adaptor<X> { typedef adapt IGuidanceMapMatchedCoordinate; };
struct IGuidanceMapMatchedCoordinate : IGuidanceMapMatchedCoordinate_raw, generate<IGuidanceMapMatchedCoordinate> {};

// GuidanceMapMatchedCoordinate
template<typename X> struct statics<GuidanceMapMatchedCoordinate, X> : X {
	typedef typename X::root_type GuidanceMapMatchedCoordinate;
};
struct GuidanceMapMatchedCoordinate : generate<GuidanceMapMatchedCoordinate> {};

// IGuidanceLaneInfo
struct IGuidanceLaneInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_LaneMarkers(GuidanceLaneMarkers *value);
	virtual STDMETHODIMP _get_IsOnRoute(bool *value);
};
template<typename X> struct IGuidanceLaneInfo_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGuidanceLaneInfo_adaptor::IsOnRoute)->_get_IsOnRoute(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsOnRoute;
		struct : property {
			GuidanceLaneMarkers get() { GuidanceLaneMarkers value; hrcheck(enc(&IGuidanceLaneInfo_adaptor::LaneMarkers)->_get_LaneMarkers(&value)); return value; }
			GuidanceLaneMarkers operator()() { return get(); }
			operator GuidanceLaneMarkers () { return get(); }
		} LaneMarkers;
	};
	IGuidanceLaneInfo_adaptor() {}
};
template<typename X> struct adapt<IGuidanceLaneInfo, X> : Windows::Services::Maps::Guidance::IGuidanceLaneInfo_adaptor<X> { typedef adapt IGuidanceLaneInfo; };
struct IGuidanceLaneInfo : IGuidanceLaneInfo_raw, generate<IGuidanceLaneInfo> {};

// GuidanceLaneInfo
template<typename X> struct statics<GuidanceLaneInfo, X> : X {
	typedef typename X::root_type GuidanceLaneInfo;
};
struct GuidanceLaneInfo : generate<GuidanceLaneInfo> {};

// GuidanceUpdatedEventArgs
template<typename X> struct statics<GuidanceUpdatedEventArgs, X> : X {
	typedef typename X::root_type GuidanceUpdatedEventArgs;
};
struct GuidanceUpdatedEventArgs : generate<GuidanceUpdatedEventArgs> {};

// IGuidanceReroutedEventArgs
struct IGuidanceReroutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Route(GuidanceRoute* *result);
};
template<typename X> struct IGuidanceReroutedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<GuidanceRoute> get() { GuidanceRoute* result; hrcheck(enc(&IGuidanceReroutedEventArgs_adaptor::Route)->_get_Route(&result)); return from_abi(result); }
			ptr<GuidanceRoute> operator()() { return get(); }
			operator ptr<GuidanceRoute> () { return get(); }
			ptr<GuidanceRoute> operator->() { return get(); }
		} Route;
	};
	IGuidanceReroutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IGuidanceReroutedEventArgs, X> : Windows::Services::Maps::Guidance::IGuidanceReroutedEventArgs_adaptor<X> { typedef adapt IGuidanceReroutedEventArgs; };
struct IGuidanceReroutedEventArgs : IGuidanceReroutedEventArgs_raw, generate<IGuidanceReroutedEventArgs> {};

// GuidanceReroutedEventArgs
template<typename X> struct statics<GuidanceReroutedEventArgs, X> : X {
	typedef typename X::root_type GuidanceReroutedEventArgs;
};
struct GuidanceReroutedEventArgs : generate<GuidanceReroutedEventArgs> {};

// IGuidanceAudioNotificationRequestedEventArgs
struct IGuidanceAudioNotificationRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_AudioNotification(GuidanceAudioNotificationKind *value);
	virtual STDMETHODIMP _get_AudioFilePaths(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _get_AudioText(HSTRING *value);
};
template<typename X> struct IGuidanceAudioNotificationRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&IGuidanceAudioNotificationRequestedEventArgs_adaptor::AudioFilePaths)->_get_AudioFilePaths(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} AudioFilePaths;
		struct : property {
			GuidanceAudioNotificationKind get() { GuidanceAudioNotificationKind value; hrcheck(enc(&IGuidanceAudioNotificationRequestedEventArgs_adaptor::AudioNotification)->_get_AudioNotification(&value)); return value; }
			GuidanceAudioNotificationKind operator()() { return get(); }
			operator GuidanceAudioNotificationKind () { return get(); }
		} AudioNotification;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGuidanceAudioNotificationRequestedEventArgs_adaptor::AudioText)->_get_AudioText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} AudioText;
	};
	IGuidanceAudioNotificationRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IGuidanceAudioNotificationRequestedEventArgs, X> : Windows::Services::Maps::Guidance::IGuidanceAudioNotificationRequestedEventArgs_adaptor<X> { typedef adapt IGuidanceAudioNotificationRequestedEventArgs; };
struct IGuidanceAudioNotificationRequestedEventArgs : IGuidanceAudioNotificationRequestedEventArgs_raw, generate<IGuidanceAudioNotificationRequestedEventArgs> {};

// GuidanceAudioNotificationRequestedEventArgs
template<typename X> struct statics<GuidanceAudioNotificationRequestedEventArgs, X> : X {
	typedef typename X::root_type GuidanceAudioNotificationRequestedEventArgs;
};
struct GuidanceAudioNotificationRequestedEventArgs : generate<GuidanceAudioNotificationRequestedEventArgs> {};

// IGuidanceNavigator
struct IGuidanceNavigator_raw : IInspectable {
	virtual STDMETHODIMP _StartNavigating(GuidanceRoute* route);
	virtual STDMETHODIMP _StartSimulating(GuidanceRoute* route, int speedInMetersPerSecond);
	virtual STDMETHODIMP _StartTracking();
	virtual STDMETHODIMP _Pause();
	virtual STDMETHODIMP _Resume();
	virtual STDMETHODIMP _Stop();
	virtual STDMETHODIMP _RepeatLastAudioNotification();
	virtual STDMETHODIMP _get_AudioMeasurementSystem(GuidanceAudioMeasurementSystem *value);
	virtual STDMETHODIMP _put_AudioMeasurementSystem(GuidanceAudioMeasurementSystem value);
	virtual STDMETHODIMP _get_AudioNotifications(GuidanceAudioNotifications *value);
	virtual STDMETHODIMP _put_AudioNotifications(GuidanceAudioNotifications value);
	virtual STDMETHODIMP _add_GuidanceUpdated(Foundation::TypedEventHandler<GuidanceNavigator*, GuidanceUpdatedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_GuidanceUpdated(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DestinationReached(Foundation::TypedEventHandler<GuidanceNavigator*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DestinationReached(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Rerouting(Foundation::TypedEventHandler<GuidanceNavigator*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Rerouting(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Rerouted(Foundation::TypedEventHandler<GuidanceNavigator*, GuidanceReroutedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Rerouted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_RerouteFailed(Foundation::TypedEventHandler<GuidanceNavigator*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_RerouteFailed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_UserLocationLost(Foundation::TypedEventHandler<GuidanceNavigator*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_UserLocationLost(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_UserLocationRestored(Foundation::TypedEventHandler<GuidanceNavigator*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_UserLocationRestored(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _SetGuidanceVoice(int voiceId, HSTRING voiceFolder);
	virtual STDMETHODIMP _UpdateUserLocation(Devices::Geolocation::Geocoordinate* userLocation);
	virtual STDMETHODIMP _UpdateUserLocationWithPositionOverride(Devices::Geolocation::Geocoordinate* userLocation, Devices::Geolocation::BasicGeoposition positionOverride);
};
template<typename X> struct IGuidanceNavigator_adaptor : X {
	union {
		struct : property {
			GuidanceAudioMeasurementSystem get() { GuidanceAudioMeasurementSystem value; hrcheck(enc(&IGuidanceNavigator_adaptor::AudioMeasurementSystem)->_get_AudioMeasurementSystem(&value)); return value; }
			GuidanceAudioMeasurementSystem operator()() { return get(); }
			operator GuidanceAudioMeasurementSystem () { return get(); }
			void put(GuidanceAudioMeasurementSystem value) { hrcheck(enc(&IGuidanceNavigator_adaptor::AudioMeasurementSystem)->_put_AudioMeasurementSystem(value)); }
			void operator=(GuidanceAudioMeasurementSystem value) { put(value); }
			void operator()(GuidanceAudioMeasurementSystem value) { put(value); }
		} AudioMeasurementSystem;
		struct : property {
			GuidanceAudioNotifications get() { GuidanceAudioNotifications value; hrcheck(enc(&IGuidanceNavigator_adaptor::AudioNotifications)->_get_AudioNotifications(&value)); return value; }
			GuidanceAudioNotifications operator()() { return get(); }
			operator GuidanceAudioNotifications () { return get(); }
			void put(GuidanceAudioNotifications value) { hrcheck(enc(&IGuidanceNavigator_adaptor::AudioNotifications)->_put_AudioNotifications(value)); }
			void operator=(GuidanceAudioNotifications value) { put(value); }
			void operator()(GuidanceAudioNotifications value) { put(value); }
		} AudioNotifications;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<GuidanceNavigator>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGuidanceNavigator_adaptor::DestinationReached)->_add_DestinationReached(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGuidanceNavigator_adaptor::DestinationReached)->_remove_DestinationReached(token)); }
		} DestinationReached;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<GuidanceNavigator>, ptr<GuidanceUpdatedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGuidanceNavigator_adaptor::GuidanceUpdated)->_add_GuidanceUpdated(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGuidanceNavigator_adaptor::GuidanceUpdated)->_remove_GuidanceUpdated(token)); }
		} GuidanceUpdated;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<GuidanceNavigator>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGuidanceNavigator_adaptor::RerouteFailed)->_add_RerouteFailed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGuidanceNavigator_adaptor::RerouteFailed)->_remove_RerouteFailed(token)); }
		} RerouteFailed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<GuidanceNavigator>, ptr<GuidanceReroutedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGuidanceNavigator_adaptor::Rerouted)->_add_Rerouted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGuidanceNavigator_adaptor::Rerouted)->_remove_Rerouted(token)); }
		} Rerouted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<GuidanceNavigator>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGuidanceNavigator_adaptor::Rerouting)->_add_Rerouting(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGuidanceNavigator_adaptor::Rerouting)->_remove_Rerouting(token)); }
		} Rerouting;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<GuidanceNavigator>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGuidanceNavigator_adaptor::UserLocationLost)->_add_UserLocationLost(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGuidanceNavigator_adaptor::UserLocationLost)->_remove_UserLocationLost(token)); }
		} UserLocationLost;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<GuidanceNavigator>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGuidanceNavigator_adaptor::UserLocationRestored)->_add_UserLocationRestored(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGuidanceNavigator_adaptor::UserLocationRestored)->_remove_UserLocationRestored(token)); }
		} UserLocationRestored;
	};
	void StartNavigating(pptr<GuidanceRoute> route) { hrcheck(X::get()->_StartNavigating(route)); }
	void StartSimulating(pptr<GuidanceRoute> route, int speedInMetersPerSecond) { hrcheck(X::get()->_StartSimulating(route, speedInMetersPerSecond)); }
	void StartTracking() { hrcheck(X::get()->_StartTracking()); }
	void Pause() { hrcheck(X::get()->_Pause()); }
	void Resume() { hrcheck(X::get()->_Resume()); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	void RepeatLastAudioNotification() { hrcheck(X::get()->_RepeatLastAudioNotification()); }
	void SetGuidanceVoice(int voiceId, hstring_ref voiceFolder) { hrcheck(X::get()->_SetGuidanceVoice(voiceId, voiceFolder)); }
	void UpdateUserLocation(pptr<Devices::Geolocation::Geocoordinate> userLocation) { hrcheck(X::get()->_UpdateUserLocation(userLocation)); }
	void UpdateUserLocation(pptr<Devices::Geolocation::Geocoordinate> userLocation, const Devices::Geolocation::BasicGeoposition& positionOverride) { hrcheck(X::get()->_UpdateUserLocationWithPositionOverride(userLocation, positionOverride)); }
	IGuidanceNavigator_adaptor() {}
};
template<typename X> struct adapt<IGuidanceNavigator, X> : Windows::Services::Maps::Guidance::IGuidanceNavigator_adaptor<X> { typedef adapt IGuidanceNavigator; };
struct IGuidanceNavigator : IGuidanceNavigator_raw, generate<IGuidanceNavigator> {};

// IGuidanceNavigatorStatics2
struct IGuidanceNavigatorStatics2 : IInspectable {
	virtual STDMETHODIMP _get_UseAppProvidedVoice(bool *value);
};

// IGuidanceNavigatorStatics
struct IGuidanceNavigatorStatics : IInspectable {
	virtual STDMETHODIMP _GetCurrent(GuidanceNavigator* *result);
};

// IGuidanceNavigator2
struct IGuidanceNavigator2_raw : IInspectable {
	virtual STDMETHODIMP _add_AudioNotificationRequested(Foundation::TypedEventHandler<GuidanceNavigator*, GuidanceAudioNotificationRequestedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_AudioNotificationRequested(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_IsGuidanceAudioMuted(bool *value);
	virtual STDMETHODIMP _put_IsGuidanceAudioMuted(bool value);
};
template<typename X> struct IGuidanceNavigator2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGuidanceNavigator2_adaptor::IsGuidanceAudioMuted)->_get_IsGuidanceAudioMuted(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IGuidanceNavigator2_adaptor::IsGuidanceAudioMuted)->_put_IsGuidanceAudioMuted(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsGuidanceAudioMuted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<GuidanceNavigator>, ptr<GuidanceAudioNotificationRequestedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGuidanceNavigator2_adaptor::AudioNotificationRequested)->_add_AudioNotificationRequested(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGuidanceNavigator2_adaptor::AudioNotificationRequested)->_remove_AudioNotificationRequested(token)); }
		} AudioNotificationRequested;
	};
	IGuidanceNavigator2_adaptor() {}
};
template<typename X> struct adapt<IGuidanceNavigator2, X> : Windows::Services::Maps::Guidance::IGuidanceNavigator2_adaptor<X> { typedef adapt IGuidanceNavigator2; };
struct IGuidanceNavigator2 : IGuidanceNavigator2_raw, generate<IGuidanceNavigator2> {};

// GuidanceNavigator
template<typename> struct GuidanceNavigator_statics {
	static struct _UseAppProvidedVoice : property {
		bool get() { bool value; hrcheck(get_activation_factory<GuidanceNavigator, IGuidanceNavigatorStatics2>()->_get_UseAppProvidedVoice(&value)); return value; }
		bool operator()() { return get(); }
		operator bool () { return get(); }
	} UseAppProvidedVoice;
	static ptr<GuidanceNavigator> GetCurrent() { GuidanceNavigator* result; hrcheck(get_activation_factory<GuidanceNavigator, IGuidanceNavigatorStatics>()->_GetCurrent(&result)); return from_abi(result); }
};
template<typename X> typename GuidanceNavigator_statics<X>::_UseAppProvidedVoice GuidanceNavigator_statics<X>::UseAppProvidedVoice;

template<typename X> struct statics<GuidanceNavigator, X> : X, Windows::Services::Maps::Guidance::GuidanceNavigator_statics<void> {
	typedef typename X::root_type GuidanceNavigator;
};
struct GuidanceNavigator : generate<GuidanceNavigator> {
	using IGuidanceNavigator::UpdateUserLocation;
};

// IGuidanceRoadSegment
struct IGuidanceRoadSegment_raw : IInspectable {
	virtual STDMETHODIMP _get_RoadName(HSTRING *value);
	virtual STDMETHODIMP _get_ShortRoadName(HSTRING *value);
	virtual STDMETHODIMP _get_SpeedLimit(double *value);
	virtual STDMETHODIMP _get_TravelTime(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_Path(Devices::Geolocation::Geopath* *value);
	virtual STDMETHODIMP _get_Id(HSTRING *value);
	virtual STDMETHODIMP _get_IsHighway(bool *value);
	virtual STDMETHODIMP _get_IsTunnel(bool *value);
	virtual STDMETHODIMP _get_IsTollRoad(bool *value);
};
template<typename X> struct IGuidanceRoadSegment_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGuidanceRoadSegment_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGuidanceRoadSegment_adaptor::IsHighway)->_get_IsHighway(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsHighway;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGuidanceRoadSegment_adaptor::IsTollRoad)->_get_IsTollRoad(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsTollRoad;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGuidanceRoadSegment_adaptor::IsTunnel)->_get_IsTunnel(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsTunnel;
		struct : property {
			ptr<Devices::Geolocation::Geopath> get() { Devices::Geolocation::Geopath* value; hrcheck(enc(&IGuidanceRoadSegment_adaptor::Path)->_get_Path(&value)); return from_abi(value); }
			ptr<Devices::Geolocation::Geopath> operator()() { return get(); }
			operator ptr<Devices::Geolocation::Geopath> () { return get(); }
			ptr<Devices::Geolocation::Geopath> operator->() { return get(); }
		} Path;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGuidanceRoadSegment_adaptor::RoadName)->_get_RoadName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} RoadName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGuidanceRoadSegment_adaptor::ShortRoadName)->_get_ShortRoadName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ShortRoadName;
		struct : property {
			double get() { double value; hrcheck(enc(&IGuidanceRoadSegment_adaptor::SpeedLimit)->_get_SpeedLimit(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} SpeedLimit;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IGuidanceRoadSegment_adaptor::TravelTime)->_get_TravelTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} TravelTime;
	};
	IGuidanceRoadSegment_adaptor() {}
};
template<typename X> struct adapt<IGuidanceRoadSegment, X> : Windows::Services::Maps::Guidance::IGuidanceRoadSegment_adaptor<X> { typedef adapt IGuidanceRoadSegment; };
struct IGuidanceRoadSegment : IGuidanceRoadSegment_raw, generate<IGuidanceRoadSegment> {};

// IGuidanceRoadSegment2
struct IGuidanceRoadSegment2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsScenic(bool *value);
};
template<typename X> struct IGuidanceRoadSegment2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGuidanceRoadSegment2_adaptor::IsScenic)->_get_IsScenic(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsScenic;
	};
	IGuidanceRoadSegment2_adaptor() {}
};
template<typename X> struct adapt<IGuidanceRoadSegment2, X> : Windows::Services::Maps::Guidance::IGuidanceRoadSegment2_adaptor<X> { typedef adapt IGuidanceRoadSegment2; };
struct IGuidanceRoadSegment2 : IGuidanceRoadSegment2_raw, generate<IGuidanceRoadSegment2> {};

// GuidanceRoadSegment
template<typename X> struct statics<GuidanceRoadSegment, X> : X {
	typedef typename X::root_type GuidanceRoadSegment;
};
struct GuidanceRoadSegment : generate<GuidanceRoadSegment> {};

// IGuidanceTelemetryCollectorStatics
struct IGuidanceTelemetryCollectorStatics : IInspectable {
	virtual STDMETHODIMP _GetCurrent(GuidanceTelemetryCollector* *result);
};

// IGuidanceTelemetryCollector
struct IGuidanceTelemetryCollector_raw : IInspectable {
	virtual STDMETHODIMP _get_Enabled(bool *value);
	virtual STDMETHODIMP _put_Enabled(bool value);
	virtual STDMETHODIMP _ClearLocalData();
	virtual STDMETHODIMP _get_SpeedTrigger(double *value);
	virtual STDMETHODIMP _put_SpeedTrigger(double value);
	virtual STDMETHODIMP _get_UploadFrequency(int *value);
	virtual STDMETHODIMP _put_UploadFrequency(int value);
};
template<typename X> struct IGuidanceTelemetryCollector_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGuidanceTelemetryCollector_adaptor::Enabled)->_get_Enabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IGuidanceTelemetryCollector_adaptor::Enabled)->_put_Enabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Enabled;
		struct : property {
			double get() { double value; hrcheck(enc(&IGuidanceTelemetryCollector_adaptor::SpeedTrigger)->_get_SpeedTrigger(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IGuidanceTelemetryCollector_adaptor::SpeedTrigger)->_put_SpeedTrigger(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} SpeedTrigger;
		struct : property {
			int get() { int value; hrcheck(enc(&IGuidanceTelemetryCollector_adaptor::UploadFrequency)->_get_UploadFrequency(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IGuidanceTelemetryCollector_adaptor::UploadFrequency)->_put_UploadFrequency(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} UploadFrequency;
	};
	void ClearLocalData() { hrcheck(X::get()->_ClearLocalData()); }
	IGuidanceTelemetryCollector_adaptor() {}
};
template<typename X> struct adapt<IGuidanceTelemetryCollector, X> : Windows::Services::Maps::Guidance::IGuidanceTelemetryCollector_adaptor<X> { typedef adapt IGuidanceTelemetryCollector; };
struct IGuidanceTelemetryCollector : IGuidanceTelemetryCollector_raw, generate<IGuidanceTelemetryCollector> {};

// GuidanceTelemetryCollector
template<typename> struct GuidanceTelemetryCollector_statics {
	static ptr<GuidanceTelemetryCollector> GetCurrent() { GuidanceTelemetryCollector* result; hrcheck(get_activation_factory<GuidanceTelemetryCollector, IGuidanceTelemetryCollectorStatics>()->_GetCurrent(&result)); return from_abi(result); }
};

template<typename X> struct statics<GuidanceTelemetryCollector, X> : X, Windows::Services::Maps::Guidance::GuidanceTelemetryCollector_statics<void> {
	typedef typename X::root_type GuidanceTelemetryCollector;
};
struct GuidanceTelemetryCollector : generate<GuidanceTelemetryCollector> {};
}}}}
} // namespace iso_winrt
