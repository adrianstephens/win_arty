#pragma once
// generated by isopod tools
// namespaces:
// Windows.Gaming.Preview.GamesEnumeration

#include "Windows.Gaming.Preview.GamesEnumeration.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace ApplicationModel {
struct AppDisplayInfo;
}
namespace Foundation { namespace Collections {
template<typename T> struct IVectorView;
template<typename K, typename V> struct IMapView;
template<typename T> struct IVector;
}}
namespace Storage {
struct IStorageFile;
}}

// defs

template<> struct def<Windows::Gaming::Preview::GamesEnumeration::GameListCategory> : enum_type<int> {};
template<> struct def<Windows::Gaming::Preview::GamesEnumeration::IGameListEntry> : overridable_type<> {};
template<> struct def<Windows::Gaming::Preview::GamesEnumeration::IGameModeConfiguration> : interface_type<> {};
template<> struct def<Windows::Gaming::Preview::GamesEnumeration::GameListEntryLaunchableState> : enum_type<int> {};
template<> struct def<Windows::Gaming::Preview::GamesEnumeration::IGameListEntry2> : interface_type<Windows::Gaming::Preview::GamesEnumeration::IGameListEntry> {};
template<> struct def<Windows::Gaming::Preview::GamesEnumeration::GameModeConfiguration> : class_type<Platform::Object, Windows::Gaming::Preview::GamesEnumeration::IGameModeConfiguration> {};
template<> struct def<Windows::Gaming::Preview::GamesEnumeration::IGameModeUserConfiguration> : interface_type<> {};
template<> struct def<Windows::Gaming::Preview::GamesEnumeration::GameListEntry> : class_type<Platform::Object, Windows::Gaming::Preview::GamesEnumeration::IGameListEntry, Windows::Gaming::Preview::GamesEnumeration::IGameListEntry2> {};
template<> struct def<Windows::Gaming::Preview::GamesEnumeration::IGameModeUserConfigurationStatics> : interface_type<> {};
template<> struct def<Windows::Gaming::Preview::GamesEnumeration::GameModeUserConfiguration> : class_type<Platform::Object, Windows::Gaming::Preview::GamesEnumeration::IGameModeUserConfiguration> {};
template<> struct def<Windows::Gaming::Preview::GamesEnumeration::GameListChangedEventHandler> : delegate_type {};
template<> struct def<Windows::Gaming::Preview::GamesEnumeration::GameListRemovedEventHandler> : delegate_type {};
template<> struct def<Windows::Gaming::Preview::GamesEnumeration::IGameListStatics> : interface_type<> {};
template<> struct def<Windows::Gaming::Preview::GamesEnumeration::IGameListStatics2> : interface_type<> {};
template<> struct def<Windows::Gaming::Preview::GamesEnumeration::GameList> : class_type<Platform::Object, Platform::Object> {};

// uuids

template<> struct uuid<Windows::Gaming::Preview::GamesEnumeration::IGameListEntry> { define_guid(0x735924D3, 0x811F, 0x4494, 0xB6, 0x9C, 0xC6, 0x41, 0xA0, 0xC6, 0x15, 0x43);};
template<> struct uuid<Windows::Gaming::Preview::GamesEnumeration::IGameModeConfiguration> { define_guid(0x78E591AF, 0xB142, 0x4EF0, 0x88, 0x30, 0x55, 0xBC, 0x2B, 0xE4, 0xF5, 0xEA);};
template<> struct uuid<Windows::Gaming::Preview::GamesEnumeration::IGameListEntry2> { define_guid(0xD84A8F8B, 0x8749, 0x4A25, 0x90, 0xD3, 0xF6, 0xC5, 0xA4, 0x27, 0x88, 0x6D);};
template<> struct uuid<Windows::Gaming::Preview::GamesEnumeration::IGameModeUserConfiguration> { define_guid(0x72D34AF4, 0x756B, 0x470F, 0xA0, 0xC2, 0xBA, 0x62, 0xA9, 0x7, 0x95, 0xDB);};
template<> struct uuid<Windows::Gaming::Preview::GamesEnumeration::IGameModeUserConfigurationStatics> { define_guid(0x6E50D97C, 0x66EA, 0x478E, 0xA4, 0xA1, 0xF5, 0x7C, 0xE, 0x8D, 0x0, 0xE7);};
template<> struct uuid<Windows::Gaming::Preview::GamesEnumeration::GameListChangedEventHandler> { define_guid(0x25F6A421, 0xD8F5, 0x4D91, 0xB4, 0xE, 0x53, 0xD5, 0xE8, 0x6F, 0xDE, 0x64);};
template<> struct uuid<Windows::Gaming::Preview::GamesEnumeration::GameListRemovedEventHandler> { define_guid(0x10C5648F, 0x6C8F, 0x4712, 0x9B, 0x38, 0x47, 0x4B, 0xC2, 0x2E, 0x76, 0xD8);};
template<> struct uuid<Windows::Gaming::Preview::GamesEnumeration::IGameListStatics> { define_guid(0x2DDD0F6F, 0x9C66, 0x4B05, 0x94, 0x5C, 0xD6, 0xED, 0x78, 0x49, 0x1B, 0x8C);};
template<> struct uuid<Windows::Gaming::Preview::GamesEnumeration::IGameListStatics2> { define_guid(0x395F2098, 0xEA1A, 0x45AA, 0x92, 0x68, 0xA8, 0x39, 0x5, 0x68, 0x6F, 0x27);};

// types

namespace Windows { namespace Gaming { namespace Preview { namespace GamesEnumeration {

// IGameListEntry
struct IGameListEntry_raw : IInspectable {
	virtual STDMETHODIMP _get_DisplayInfo(ApplicationModel::AppDisplayInfo* *value) = 0;
	virtual STDMETHODIMP _LaunchAsync(Foundation::IAsyncOperation<bool>* *operation) = 0;
	virtual STDMETHODIMP _get_Category(GameListCategory *value) = 0;
	virtual STDMETHODIMP _get_Properties(Foundation::Collections::IMapView<HSTRING, IInspectable*>* *value) = 0;
	virtual STDMETHODIMP _SetCategoryAsync(GameListCategory value, Foundation::IAsyncAction* *action) = 0;
};
template<typename X> struct IGameListEntry_adaptor : X {
	union {
		struct : property {
			GameListCategory get() { GameListCategory value; hrcheck(enc(&IGameListEntry_adaptor::Category)->_get_Category(&value)); return value; }
			GameListCategory operator()() { return get(); }
			operator GameListCategory () { return get(); }
		} Category;
		struct : property {
			ptr<ApplicationModel::AppDisplayInfo> get() { ApplicationModel::AppDisplayInfo* value; hrcheck(enc(&IGameListEntry_adaptor::DisplayInfo)->_get_DisplayInfo(&value)); return from_abi(value); }
			ptr<ApplicationModel::AppDisplayInfo> operator()() { return get(); }
			operator ptr<ApplicationModel::AppDisplayInfo> () { return get(); }
			ptr<ApplicationModel::AppDisplayInfo> operator->() { return get(); }
		} DisplayInfo;
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, object>> get() { Foundation::Collections::IMapView<HSTRING, IInspectable*>* value; hrcheck(enc(&IGameListEntry_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMapView<hstring, object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, object>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, object>> operator->() { return get(); }
		} Properties;
	};
	ptr<Foundation::IAsyncOperation<bool>> LaunchAsync() { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_LaunchAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> SetCategoryAsync(GameListCategory value) { Foundation::IAsyncAction* action; hrcheck(X::get()->_SetCategoryAsync(value, &action)); return from_abi(action); }
	IGameListEntry_adaptor() {}
};
template<typename X> struct adapt<IGameListEntry, X> : Windows::Gaming::Preview::GamesEnumeration::IGameListEntry_adaptor<X> { typedef adapt IGameListEntry; };
template<typename X> struct IGameListEntry_unadaptor : X {
	STDMETHODIMP _get_DisplayInfo(ApplicationModel::AppDisplayInfo* *value) { return hrtry([&, this] { get_prop(value, DisplayInfo); }); }
	STDMETHODIMP _LaunchAsync(Foundation::IAsyncOperation<bool>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->LaunchAsync()); }); }
	STDMETHODIMP _get_Category(GameListCategory *value) { return hrtry([&, this] { get_prop(value, Category); }); }
	STDMETHODIMP _get_Properties(Foundation::Collections::IMapView<HSTRING, IInspectable*>* *value) { return hrtry([&, this] { get_prop(value, Properties); }); }
	STDMETHODIMP _SetCategoryAsync(GameListCategory value, Foundation::IAsyncAction* *action) { return hrtry([&, this] { *action = to_abi(X::get()->SetCategoryAsync(value)); }); }
};
template<typename X> struct unadapt<IGameListEntry, X> : Windows::Gaming::Preview::GamesEnumeration::IGameListEntry_unadaptor<X> {};
struct IGameListEntry : IGameListEntry_raw, generate<IGameListEntry> {};

// IGameModeConfiguration
struct IGameModeConfiguration_raw : IInspectable {
	virtual STDMETHODIMP _get_IsEnabled(bool *value);
	virtual STDMETHODIMP _put_IsEnabled(bool value);
	virtual STDMETHODIMP _get_RelatedProcessNames(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_PercentGpuTimeAllocatedToGame(Foundation::IReference<int>* *value);
	virtual STDMETHODIMP _put_PercentGpuTimeAllocatedToGame(Foundation::IReference<int>* value);
	virtual STDMETHODIMP _get_PercentGpuMemoryAllocatedToGame(Foundation::IReference<int>* *value);
	virtual STDMETHODIMP _put_PercentGpuMemoryAllocatedToGame(Foundation::IReference<int>* value);
	virtual STDMETHODIMP _get_PercentGpuMemoryAllocatedToSystemCompositor(Foundation::IReference<int>* *value);
	virtual STDMETHODIMP _put_PercentGpuMemoryAllocatedToSystemCompositor(Foundation::IReference<int>* value);
	virtual STDMETHODIMP _get_MaxCpuCount(Foundation::IReference<int>* *value);
	virtual STDMETHODIMP _put_MaxCpuCount(Foundation::IReference<int>* value);
	virtual STDMETHODIMP _get_CpuExclusivityMaskLow(Foundation::IReference<int>* *value);
	virtual STDMETHODIMP _put_CpuExclusivityMaskLow(Foundation::IReference<int>* value);
	virtual STDMETHODIMP _get_CpuExclusivityMaskHigh(Foundation::IReference<int>* *value);
	virtual STDMETHODIMP _put_CpuExclusivityMaskHigh(Foundation::IReference<int>* value);
	virtual STDMETHODIMP _get_AffinitizeToExclusiveCpus(bool *value);
	virtual STDMETHODIMP _put_AffinitizeToExclusiveCpus(bool value);
	virtual STDMETHODIMP _SaveAsync(Foundation::IAsyncAction* *operation);
};
template<typename X> struct IGameModeConfiguration_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGameModeConfiguration_adaptor::AffinitizeToExclusiveCpus)->_get_AffinitizeToExclusiveCpus(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IGameModeConfiguration_adaptor::AffinitizeToExclusiveCpus)->_put_AffinitizeToExclusiveCpus(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AffinitizeToExclusiveCpus;
		struct : property {
			ptr<Foundation::IReference<int>> get() { Foundation::IReference<int>* value; hrcheck(enc(&IGameModeConfiguration_adaptor::CpuExclusivityMaskHigh)->_get_CpuExclusivityMaskHigh(&value)); return from_abi(value); }
			ptr<Foundation::IReference<int>> operator()() { return get(); }
			operator ptr<Foundation::IReference<int>> () { return get(); }
			ptr<Foundation::IReference<int>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<int>> value) { hrcheck(enc(&IGameModeConfiguration_adaptor::CpuExclusivityMaskHigh)->_put_CpuExclusivityMaskHigh(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
		} CpuExclusivityMaskHigh;
		struct : property {
			ptr<Foundation::IReference<int>> get() { Foundation::IReference<int>* value; hrcheck(enc(&IGameModeConfiguration_adaptor::CpuExclusivityMaskLow)->_get_CpuExclusivityMaskLow(&value)); return from_abi(value); }
			ptr<Foundation::IReference<int>> operator()() { return get(); }
			operator ptr<Foundation::IReference<int>> () { return get(); }
			ptr<Foundation::IReference<int>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<int>> value) { hrcheck(enc(&IGameModeConfiguration_adaptor::CpuExclusivityMaskLow)->_put_CpuExclusivityMaskLow(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
		} CpuExclusivityMaskLow;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGameModeConfiguration_adaptor::IsEnabled)->_get_IsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IGameModeConfiguration_adaptor::IsEnabled)->_put_IsEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsEnabled;
		struct : property {
			ptr<Foundation::IReference<int>> get() { Foundation::IReference<int>* value; hrcheck(enc(&IGameModeConfiguration_adaptor::MaxCpuCount)->_get_MaxCpuCount(&value)); return from_abi(value); }
			ptr<Foundation::IReference<int>> operator()() { return get(); }
			operator ptr<Foundation::IReference<int>> () { return get(); }
			ptr<Foundation::IReference<int>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<int>> value) { hrcheck(enc(&IGameModeConfiguration_adaptor::MaxCpuCount)->_put_MaxCpuCount(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
		} MaxCpuCount;
		struct : property {
			ptr<Foundation::IReference<int>> get() { Foundation::IReference<int>* value; hrcheck(enc(&IGameModeConfiguration_adaptor::PercentGpuMemoryAllocatedToGame)->_get_PercentGpuMemoryAllocatedToGame(&value)); return from_abi(value); }
			ptr<Foundation::IReference<int>> operator()() { return get(); }
			operator ptr<Foundation::IReference<int>> () { return get(); }
			ptr<Foundation::IReference<int>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<int>> value) { hrcheck(enc(&IGameModeConfiguration_adaptor::PercentGpuMemoryAllocatedToGame)->_put_PercentGpuMemoryAllocatedToGame(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
		} PercentGpuMemoryAllocatedToGame;
		struct : property {
			ptr<Foundation::IReference<int>> get() { Foundation::IReference<int>* value; hrcheck(enc(&IGameModeConfiguration_adaptor::PercentGpuMemoryAllocatedToSystemCompositor)->_get_PercentGpuMemoryAllocatedToSystemCompositor(&value)); return from_abi(value); }
			ptr<Foundation::IReference<int>> operator()() { return get(); }
			operator ptr<Foundation::IReference<int>> () { return get(); }
			ptr<Foundation::IReference<int>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<int>> value) { hrcheck(enc(&IGameModeConfiguration_adaptor::PercentGpuMemoryAllocatedToSystemCompositor)->_put_PercentGpuMemoryAllocatedToSystemCompositor(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
		} PercentGpuMemoryAllocatedToSystemCompositor;
		struct : property {
			ptr<Foundation::IReference<int>> get() { Foundation::IReference<int>* value; hrcheck(enc(&IGameModeConfiguration_adaptor::PercentGpuTimeAllocatedToGame)->_get_PercentGpuTimeAllocatedToGame(&value)); return from_abi(value); }
			ptr<Foundation::IReference<int>> operator()() { return get(); }
			operator ptr<Foundation::IReference<int>> () { return get(); }
			ptr<Foundation::IReference<int>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<int>> value) { hrcheck(enc(&IGameModeConfiguration_adaptor::PercentGpuTimeAllocatedToGame)->_put_PercentGpuTimeAllocatedToGame(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
		} PercentGpuTimeAllocatedToGame;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IGameModeConfiguration_adaptor::RelatedProcessNames)->_get_RelatedProcessNames(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} RelatedProcessNames;
	};
	ptr<Foundation::IAsyncAction> SaveAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_SaveAsync(&operation)); return from_abi(operation); }
	IGameModeConfiguration_adaptor() {}
};
template<typename X> struct adapt<IGameModeConfiguration, X> : Windows::Gaming::Preview::GamesEnumeration::IGameModeConfiguration_adaptor<X> { typedef adapt IGameModeConfiguration; };
struct IGameModeConfiguration : IGameModeConfiguration_raw, generate<IGameModeConfiguration> {};

// IGameListEntry2
struct IGameListEntry2_raw : IInspectable {
	virtual STDMETHODIMP _get_LaunchableState(GameListEntryLaunchableState *value);
	virtual STDMETHODIMP _get_LauncherExecutable(Storage::IStorageFile* *value);
	virtual STDMETHODIMP _get_LaunchParameters(HSTRING *value);
	virtual STDMETHODIMP _SetLauncherExecutableFileAsync(Storage::IStorageFile* executableFile, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _SetLauncherExecutableFileWithParamsAsync(Storage::IStorageFile* executableFile, HSTRING launchParams, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _get_TitleId(HSTRING *value);
	virtual STDMETHODIMP _SetTitleIdAsync(HSTRING id, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _get_GameModeConfiguration(GamesEnumeration::GameModeConfiguration* *value);
};
template<typename X> struct IGameListEntry2_adaptor : X {
	union {
		struct : property {
			ptr<GamesEnumeration::GameModeConfiguration> get() { GamesEnumeration::GameModeConfiguration* value; hrcheck(enc(&IGameListEntry2_adaptor::GameModeConfiguration)->_get_GameModeConfiguration(&value)); return from_abi(value); }
			ptr<GamesEnumeration::GameModeConfiguration> operator()() { return get(); }
			operator ptr<GamesEnumeration::GameModeConfiguration> () { return get(); }
			ptr<GamesEnumeration::GameModeConfiguration> operator->() { return get(); }
		} GameModeConfiguration;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGameListEntry2_adaptor::LaunchParameters)->_get_LaunchParameters(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} LaunchParameters;
		struct : property {
			GameListEntryLaunchableState get() { GameListEntryLaunchableState value; hrcheck(enc(&IGameListEntry2_adaptor::LaunchableState)->_get_LaunchableState(&value)); return value; }
			GameListEntryLaunchableState operator()() { return get(); }
			operator GameListEntryLaunchableState () { return get(); }
		} LaunchableState;
		struct : property {
			ptr<Storage::IStorageFile> get() { Storage::IStorageFile* value; hrcheck(enc(&IGameListEntry2_adaptor::LauncherExecutable)->_get_LauncherExecutable(&value)); return from_abi(value); }
			ptr<Storage::IStorageFile> operator()() { return get(); }
			operator ptr<Storage::IStorageFile> () { return get(); }
			ptr<Storage::IStorageFile> operator->() { return get(); }
		} LauncherExecutable;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGameListEntry2_adaptor::TitleId)->_get_TitleId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} TitleId;
	};
	ptr<Foundation::IAsyncAction> SetLauncherExecutableFileAsync(pptr<Storage::IStorageFile> executableFile) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_SetLauncherExecutableFileAsync(executableFile, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> SetLauncherExecutableFileAsync(pptr<Storage::IStorageFile> executableFile, hstring_ref launchParams) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_SetLauncherExecutableFileWithParamsAsync(executableFile, launchParams, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> SetTitleIdAsync(hstring_ref id) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_SetTitleIdAsync(id, &operation)); return from_abi(operation); }
	IGameListEntry2_adaptor() {}
};
template<typename X> struct adapt<IGameListEntry2, X> : Windows::Gaming::Preview::GamesEnumeration::IGameListEntry2_adaptor<X> { typedef adapt IGameListEntry2; };
struct IGameListEntry2 : IGameListEntry2_raw, generate<IGameListEntry2> {};

// GameModeConfiguration
template<typename X> struct statics<GameModeConfiguration, X> : X {
	typedef typename X::root_type GameModeConfiguration;
};
struct GameModeConfiguration : generate<GameModeConfiguration> {};

// IGameModeUserConfiguration
struct IGameModeUserConfiguration_raw : IInspectable {
	virtual STDMETHODIMP _get_GamingRelatedProcessNames(Foundation::Collections::IVector<HSTRING>* *processNames);
	virtual STDMETHODIMP _SaveAsync(Foundation::IAsyncAction* *operation);
};
template<typename X> struct IGameModeUserConfiguration_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* processNames; hrcheck(enc(&IGameModeUserConfiguration_adaptor::GamingRelatedProcessNames)->_get_GamingRelatedProcessNames(&processNames)); return from_abi(processNames); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} GamingRelatedProcessNames;
	};
	ptr<Foundation::IAsyncAction> SaveAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_SaveAsync(&operation)); return from_abi(operation); }
	IGameModeUserConfiguration_adaptor() {}
};
template<typename X> struct adapt<IGameModeUserConfiguration, X> : Windows::Gaming::Preview::GamesEnumeration::IGameModeUserConfiguration_adaptor<X> { typedef adapt IGameModeUserConfiguration; };
struct IGameModeUserConfiguration : IGameModeUserConfiguration_raw, generate<IGameModeUserConfiguration> {};

// GameListEntry
template<typename X> struct statics<GameListEntry, X> : X {
	typedef typename X::root_type GameListEntry;
};
struct GameListEntry : generate<GameListEntry> {
	using IGameListEntry2::SetLauncherExecutableFileAsync;
};

// IGameModeUserConfigurationStatics
struct IGameModeUserConfigurationStatics : IInspectable {
	virtual STDMETHODIMP _GetDefault(GameModeUserConfiguration* *userConfiguration);
};

// GameModeUserConfiguration
template<typename> struct GameModeUserConfiguration_statics {
	static ptr<GameModeUserConfiguration> GetDefault() { GameModeUserConfiguration* userConfiguration; hrcheck(get_activation_factory<GameModeUserConfiguration, IGameModeUserConfigurationStatics>()->_GetDefault(&userConfiguration)); return from_abi(userConfiguration); }
};

template<typename X> struct statics<GameModeUserConfiguration, X> : X, Windows::Gaming::Preview::GamesEnumeration::GameModeUserConfiguration_statics<void> {
	typedef typename X::root_type GameModeUserConfiguration;
};
struct GameModeUserConfiguration : generate<GameModeUserConfiguration> {};

// GameListChangedEventHandler
struct GameListChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(GameListEntry* game) = 0;
};

// GameListRemovedEventHandler
struct GameListRemovedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(HSTRING identifier) = 0;
};

// IGameListStatics
struct IGameListStatics : IInspectable {
	virtual STDMETHODIMP _FindAllAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<GameListEntry*>*>* *operation);
	virtual STDMETHODIMP _FindAllAsyncPackageFamilyName(HSTRING packageFamilyName, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<GameListEntry*>*>* *operation);
	virtual STDMETHODIMP _add_GameAdded(GameListChangedEventHandler* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_GameAdded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_GameRemoved(GameListRemovedEventHandler* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_GameRemoved(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_GameUpdated(GameListChangedEventHandler* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_GameUpdated(Foundation::EventRegistrationToken token);
};

// IGameListStatics2
struct IGameListStatics2 : IInspectable {
	virtual STDMETHODIMP _MergeEntriesAsync(GameListEntry* left, GameListEntry* right, Foundation::IAsyncOperation<GameListEntry*>* *operation);
	virtual STDMETHODIMP _UnmergeEntryAsync(GameListEntry* mergedEntry, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<GameListEntry*>*>* *operation);
};

// GameList
template<typename> struct GameList_statics {
	static struct _GameAdded : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<GameListChangedEventHandler> handler) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<GameList, IGameListStatics>()->_add_GameAdded(handler, &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<GameList, IGameListStatics>()->_remove_GameAdded(token)); }
	} GameAdded;
	static struct _GameRemoved : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<GameListRemovedEventHandler> handler) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<GameList, IGameListStatics>()->_add_GameRemoved(handler, &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<GameList, IGameListStatics>()->_remove_GameRemoved(token)); }
	} GameRemoved;
	static struct _GameUpdated : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<GameListChangedEventHandler> handler) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<GameList, IGameListStatics>()->_add_GameUpdated(handler, &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<GameList, IGameListStatics>()->_remove_GameUpdated(token)); }
	} GameUpdated;
	static ptr<Foundation::IAsyncOperation<ptr<GameListEntry>>> MergeEntriesAsync(pptr<GameListEntry> left, pptr<GameListEntry> right) { Foundation::IAsyncOperation<GameListEntry*>* operation; hrcheck(get_activation_factory<GameList, IGameListStatics2>()->_MergeEntriesAsync(left, right, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<GameListEntry>>>>> UnmergeEntryAsync(pptr<GameListEntry> mergedEntry) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<GameListEntry*>*>* operation; hrcheck(get_activation_factory<GameList, IGameListStatics2>()->_UnmergeEntryAsync(mergedEntry, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<GameListEntry>>>>> FindAllAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<GameListEntry*>*>* operation; hrcheck(get_activation_factory<GameList, IGameListStatics>()->_FindAllAsync(&operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<GameListEntry>>>>> FindAllAsync(hstring_ref packageFamilyName) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<GameListEntry*>*>* operation; hrcheck(get_activation_factory<GameList, IGameListStatics>()->_FindAllAsyncPackageFamilyName(packageFamilyName, &operation)); return from_abi(operation); }
};
template<typename X> typename GameList_statics<X>::_GameAdded GameList_statics<X>::GameAdded;
template<typename X> typename GameList_statics<X>::_GameRemoved GameList_statics<X>::GameRemoved;
template<typename X> typename GameList_statics<X>::_GameUpdated GameList_statics<X>::GameUpdated;

template<typename X> struct statics<GameList, X> : X, Windows::Gaming::Preview::GamesEnumeration::GameList_statics<void> {
	typedef typename X::root_type GameList;
};
struct GameList : generate<GameList> {};
}}}}
} // namespace iso_winrt
