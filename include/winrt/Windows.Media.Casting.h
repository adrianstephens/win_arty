#pragma once
// generated by isopod tools
// namespaces:
// Windows.Media.Casting

#include "Windows.Media.Casting.0.h"
#include "Windows.UI.Popups.0.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Devices { namespace Enumeration {
struct DeviceInformation;
struct DevicePickerAppearance;
}}
namespace Foundation { namespace Collections {
template<typename T> struct IVector;
}}
namespace Storage { namespace Streams {
struct IRandomAccessStreamWithContentType;
}}}

// defs

template<> struct def<Windows::Media::Casting::CastingPlaybackTypes> : enum_type<unsigned> {};
template<> struct def<Windows::Media::Casting::CastingConnectionErrorStatus> : enum_type<int> {};
template<> struct def<Windows::Media::Casting::CastingConnectionState> : enum_type<int> {};
template<> struct def<Windows::Media::Casting::ICastingSource> : interface_type<> {};
template<> struct def<Windows::Media::Casting::CastingSource> : class_type<Platform::Object, Windows::Media::Casting::ICastingSource> {};
template<> struct def<Windows::Media::Casting::ICastingConnectionErrorOccurredEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Casting::CastingConnectionErrorOccurredEventArgs> : class_type<Platform::Object, Windows::Media::Casting::ICastingConnectionErrorOccurredEventArgs> {};
template<> struct def<Windows::Media::Casting::ICastingConnection> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Media::Casting::ICastingDeviceStatics> : interface_type<> {};
template<> struct def<Windows::Media::Casting::ICastingDevice> : interface_type<> {};
template<> struct def<Windows::Media::Casting::CastingDevice> : class_type<Platform::Object, Windows::Media::Casting::ICastingDevice> {};
template<> struct def<Windows::Media::Casting::CastingConnection> : class_type<Platform::Object, Windows::Media::Casting::ICastingConnection> {};
template<> struct def<Windows::Media::Casting::ICastingDeviceSelectedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Casting::CastingDeviceSelectedEventArgs> : class_type<Platform::Object, Windows::Media::Casting::ICastingDeviceSelectedEventArgs> {};
template<> struct def<Windows::Media::Casting::ICastingDevicePickerFilter> : interface_type<> {};
template<> struct def<Windows::Media::Casting::CastingDevicePickerFilter> : class_type<Platform::Object, Windows::Media::Casting::ICastingDevicePickerFilter> {};
template<> struct def<Windows::Media::Casting::ICastingDevicePicker> : interface_type<> {};
template<> struct def<Windows::Media::Casting::CastingDevicePicker> : class_type<Platform::Object, Windows::Media::Casting::ICastingDevicePicker> {};

// uuids

template<> struct uuid<Windows::Media::Casting::ICastingSource> { define_guid(0xF429EA72, 0x3467, 0x47E6, 0xA0, 0x27, 0x52, 0x29, 0x23, 0xE9, 0xD7, 0x27);};
template<> struct uuid<Windows::Media::Casting::ICastingConnectionErrorOccurredEventArgs> { define_guid(0xA7FB3C69, 0x8719, 0x4F00, 0x81, 0xFB, 0x96, 0x18, 0x63, 0xC7, 0x9A, 0x32);};
template<> struct uuid<Windows::Media::Casting::ICastingConnection> { define_guid(0xCD951653, 0xC2F1, 0x4498, 0x8B, 0x78, 0x5F, 0xB4, 0xCD, 0x36, 0x40, 0xDD);};
template<> struct uuid<Windows::Media::Casting::ICastingDeviceStatics> { define_guid(0xE7D958D7, 0x4D13, 0x4237, 0xA3, 0x65, 0x4C, 0x4F, 0x6A, 0x4C, 0xFD, 0x2F);};
template<> struct uuid<Windows::Media::Casting::ICastingDevice> { define_guid(0xDE721C83, 0x4A43, 0x4AD1, 0xA6, 0xD2, 0x24, 0x92, 0xA7, 0x96, 0xC3, 0xF2);};
template<> struct uuid<Windows::Media::Casting::ICastingDeviceSelectedEventArgs> { define_guid(0xDC439E86, 0xDD57, 0x4D0D, 0x94, 0x0, 0xAF, 0x45, 0xE4, 0xFB, 0x36, 0x63);};
template<> struct uuid<Windows::Media::Casting::ICastingDevicePickerFilter> { define_guid(0xBE8C619C, 0xB563, 0x4354, 0xAE, 0x33, 0x9F, 0xDA, 0xAD, 0x8C, 0x62, 0x91);};
template<> struct uuid<Windows::Media::Casting::ICastingDevicePicker> { define_guid(0xDCD39924, 0x591, 0x49BE, 0xAA, 0xCB, 0x4B, 0x82, 0xEE, 0x75, 0x6A, 0x95);};

// types

namespace Windows { namespace Media { namespace Casting {

// ICastingSource
struct ICastingSource_raw : IInspectable {
	virtual STDMETHODIMP _get_PreferredSourceUri(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_PreferredSourceUri(Foundation::Uri* value);
};
template<typename X> struct ICastingSource_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&ICastingSource_adaptor::PreferredSourceUri)->_get_PreferredSourceUri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&ICastingSource_adaptor::PreferredSourceUri)->_put_PreferredSourceUri(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} PreferredSourceUri;
	};
	ICastingSource_adaptor() {}
};
template<typename X> struct adapt<ICastingSource, X> : Windows::Media::Casting::ICastingSource_adaptor<X> { typedef adapt ICastingSource; };
struct ICastingSource : ICastingSource_raw, generate<ICastingSource> {};

// CastingSource
template<typename X> struct statics<CastingSource, X> : X {
	typedef typename X::root_type CastingSource;
};
struct CastingSource : generate<CastingSource> {};

// ICastingConnectionErrorOccurredEventArgs
struct ICastingConnectionErrorOccurredEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ErrorStatus(CastingConnectionErrorStatus *value);
	virtual STDMETHODIMP _get_Message(HSTRING *value);
};
template<typename X> struct ICastingConnectionErrorOccurredEventArgs_adaptor : X {
	union {
		struct : property {
			CastingConnectionErrorStatus get() { CastingConnectionErrorStatus value; hrcheck(enc(&ICastingConnectionErrorOccurredEventArgs_adaptor::ErrorStatus)->_get_ErrorStatus(&value)); return value; }
			CastingConnectionErrorStatus operator()() { return get(); }
			operator CastingConnectionErrorStatus () { return get(); }
		} ErrorStatus;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICastingConnectionErrorOccurredEventArgs_adaptor::Message)->_get_Message(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Message;
	};
	ICastingConnectionErrorOccurredEventArgs_adaptor() {}
};
template<typename X> struct adapt<ICastingConnectionErrorOccurredEventArgs, X> : Windows::Media::Casting::ICastingConnectionErrorOccurredEventArgs_adaptor<X> { typedef adapt ICastingConnectionErrorOccurredEventArgs; };
struct ICastingConnectionErrorOccurredEventArgs : ICastingConnectionErrorOccurredEventArgs_raw, generate<ICastingConnectionErrorOccurredEventArgs> {};

// CastingConnectionErrorOccurredEventArgs
template<typename X> struct statics<CastingConnectionErrorOccurredEventArgs, X> : X {
	typedef typename X::root_type CastingConnectionErrorOccurredEventArgs;
};
struct CastingConnectionErrorOccurredEventArgs : generate<CastingConnectionErrorOccurredEventArgs> {};

// ICastingConnection
struct ICastingConnection_raw : IInspectable {
	virtual STDMETHODIMP _get_State(CastingConnectionState *value);
	virtual STDMETHODIMP _get_Device(CastingDevice* *value);
	virtual STDMETHODIMP _get_Source(CastingSource* *value);
	virtual STDMETHODIMP _put_Source(CastingSource* value);
	virtual STDMETHODIMP _add_StateChanged(Foundation::TypedEventHandler<CastingConnection*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_StateChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ErrorOccurred(Foundation::TypedEventHandler<CastingConnection*, CastingConnectionErrorOccurredEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ErrorOccurred(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _RequestStartCastingAsync(CastingSource* value, Foundation::IAsyncOperation<CastingConnectionErrorStatus>* *operation);
	virtual STDMETHODIMP _DisconnectAsync(Foundation::IAsyncOperation<CastingConnectionErrorStatus>* *operation);
};
template<typename X> struct ICastingConnection_adaptor : X {
	union {
		struct : property {
			ptr<CastingDevice> get() { CastingDevice* value; hrcheck(enc(&ICastingConnection_adaptor::Device)->_get_Device(&value)); return from_abi(value); }
			ptr<CastingDevice> operator()() { return get(); }
			operator ptr<CastingDevice> () { return get(); }
			ptr<CastingDevice> operator->() { return get(); }
		} Device;
		struct : property {
			ptr<CastingSource> get() { CastingSource* value; hrcheck(enc(&ICastingConnection_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			ptr<CastingSource> operator()() { return get(); }
			operator ptr<CastingSource> () { return get(); }
			ptr<CastingSource> operator->() { return get(); }
			void put(pptr<CastingSource> value) { hrcheck(enc(&ICastingConnection_adaptor::Source)->_put_Source(value)); }
			void operator=(pptr<CastingSource> value) { put(value); }
			void operator()(pptr<CastingSource> value) { put(value); }
		} Source;
		struct : property {
			CastingConnectionState get() { CastingConnectionState value; hrcheck(enc(&ICastingConnection_adaptor::State)->_get_State(&value)); return value; }
			CastingConnectionState operator()() { return get(); }
			operator CastingConnectionState () { return get(); }
		} State;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<CastingConnection>, ptr<CastingConnectionErrorOccurredEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICastingConnection_adaptor::ErrorOccurred)->_add_ErrorOccurred(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICastingConnection_adaptor::ErrorOccurred)->_remove_ErrorOccurred(token)); }
		} ErrorOccurred;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<CastingConnection>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICastingConnection_adaptor::StateChanged)->_add_StateChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICastingConnection_adaptor::StateChanged)->_remove_StateChanged(token)); }
		} StateChanged;
	};
	ptr<Foundation::IAsyncOperation<CastingConnectionErrorStatus>> RequestStartCastingAsync(pptr<CastingSource> value) { Foundation::IAsyncOperation<CastingConnectionErrorStatus>* operation; hrcheck(X::get()->_RequestStartCastingAsync(value, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<CastingConnectionErrorStatus>> DisconnectAsync() { Foundation::IAsyncOperation<CastingConnectionErrorStatus>* operation; hrcheck(X::get()->_DisconnectAsync(&operation)); return from_abi(operation); }
	ICastingConnection_adaptor() {}
};
template<typename X> struct adapt<ICastingConnection, X> : Windows::Media::Casting::ICastingConnection_adaptor<X> { typedef adapt ICastingConnection; };
struct ICastingConnection : ICastingConnection_raw, generate<ICastingConnection> {};

// ICastingDeviceStatics
struct ICastingDeviceStatics : IInspectable {
	virtual STDMETHODIMP _GetDeviceSelector(CastingPlaybackTypes type, HSTRING *value);
	virtual STDMETHODIMP _GetDeviceSelectorFromCastingSourceAsync(CastingSource* castingSource, Foundation::IAsyncOperation<HSTRING>* *operation);
	virtual STDMETHODIMP _FromIdAsync(HSTRING value, Foundation::IAsyncOperation<CastingDevice*>* *operation);
	virtual STDMETHODIMP _DeviceInfoSupportsCastingAsync(Windows::Devices::Enumeration::DeviceInformation* device, Foundation::IAsyncOperation<bool>* *operation);
};

// ICastingDevice
struct ICastingDevice_raw : IInspectable {
	virtual STDMETHODIMP _get_Id(HSTRING *value);
	virtual STDMETHODIMP _get_FriendlyName(HSTRING *value);
	virtual STDMETHODIMP _get_Icon(Storage::Streams::IRandomAccessStreamWithContentType* *value);
	virtual STDMETHODIMP _GetSupportedCastingPlaybackTypesAsync(Foundation::IAsyncOperation<CastingPlaybackTypes>* *operation);
	virtual STDMETHODIMP _CreateCastingConnection(CastingConnection* *value);
};
template<typename X> struct ICastingDevice_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICastingDevice_adaptor::FriendlyName)->_get_FriendlyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} FriendlyName;
		struct : property {
			ptr<Storage::Streams::IRandomAccessStreamWithContentType> get() { Storage::Streams::IRandomAccessStreamWithContentType* value; hrcheck(enc(&ICastingDevice_adaptor::Icon)->_get_Icon(&value)); return from_abi(value); }
			ptr<Storage::Streams::IRandomAccessStreamWithContentType> operator()() { return get(); }
			operator ptr<Storage::Streams::IRandomAccessStreamWithContentType> () { return get(); }
			ptr<Storage::Streams::IRandomAccessStreamWithContentType> operator->() { return get(); }
		} Icon;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICastingDevice_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
	};
	ptr<Foundation::IAsyncOperation<CastingPlaybackTypes>> GetSupportedCastingPlaybackTypesAsync() { Foundation::IAsyncOperation<CastingPlaybackTypes>* operation; hrcheck(X::get()->_GetSupportedCastingPlaybackTypesAsync(&operation)); return from_abi(operation); }
	ptr<CastingConnection> CreateCastingConnection() { CastingConnection* value; hrcheck(X::get()->_CreateCastingConnection(&value)); return from_abi(value); }
	ICastingDevice_adaptor() {}
};
template<typename X> struct adapt<ICastingDevice, X> : Windows::Media::Casting::ICastingDevice_adaptor<X> { typedef adapt ICastingDevice; };
struct ICastingDevice : ICastingDevice_raw, generate<ICastingDevice> {};

// CastingDevice
template<typename> struct CastingDevice_statics {
	static hstring GetDeviceSelector(CastingPlaybackTypes type) { HSTRING value; hrcheck(get_activation_factory<CastingDevice, ICastingDeviceStatics>()->_GetDeviceSelector(type, &value)); return from_abi(value); }
	static ptr<Foundation::IAsyncOperation<hstring>> GetDeviceSelectorFromCastingSourceAsync(pptr<CastingSource> castingSource) { Foundation::IAsyncOperation<HSTRING>* operation; hrcheck(get_activation_factory<CastingDevice, ICastingDeviceStatics>()->_GetDeviceSelectorFromCastingSourceAsync(castingSource, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<CastingDevice>>> FromIdAsync(hstring_ref value) { Foundation::IAsyncOperation<CastingDevice*>* operation; hrcheck(get_activation_factory<CastingDevice, ICastingDeviceStatics>()->_FromIdAsync(value, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<bool>> DeviceInfoSupportsCastingAsync(pptr<Windows::Devices::Enumeration::DeviceInformation> device) { Foundation::IAsyncOperation<bool>* operation; hrcheck(get_activation_factory<CastingDevice, ICastingDeviceStatics>()->_DeviceInfoSupportsCastingAsync(device, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<CastingDevice, X> : X, Windows::Media::Casting::CastingDevice_statics<void> {
	typedef typename X::root_type CastingDevice;
};
struct CastingDevice : generate<CastingDevice> {};

// CastingConnection
template<typename X> struct statics<CastingConnection, X> : X {
	typedef typename X::root_type CastingConnection;
};
struct CastingConnection : generate<CastingConnection> {};

// ICastingDeviceSelectedEventArgs
struct ICastingDeviceSelectedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_SelectedCastingDevice(CastingDevice* *value);
};
template<typename X> struct ICastingDeviceSelectedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<CastingDevice> get() { CastingDevice* value; hrcheck(enc(&ICastingDeviceSelectedEventArgs_adaptor::SelectedCastingDevice)->_get_SelectedCastingDevice(&value)); return from_abi(value); }
			ptr<CastingDevice> operator()() { return get(); }
			operator ptr<CastingDevice> () { return get(); }
			ptr<CastingDevice> operator->() { return get(); }
		} SelectedCastingDevice;
	};
	ICastingDeviceSelectedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ICastingDeviceSelectedEventArgs, X> : Windows::Media::Casting::ICastingDeviceSelectedEventArgs_adaptor<X> { typedef adapt ICastingDeviceSelectedEventArgs; };
struct ICastingDeviceSelectedEventArgs : ICastingDeviceSelectedEventArgs_raw, generate<ICastingDeviceSelectedEventArgs> {};

// CastingDeviceSelectedEventArgs
template<typename X> struct statics<CastingDeviceSelectedEventArgs, X> : X {
	typedef typename X::root_type CastingDeviceSelectedEventArgs;
};
struct CastingDeviceSelectedEventArgs : generate<CastingDeviceSelectedEventArgs> {};

// ICastingDevicePickerFilter
struct ICastingDevicePickerFilter_raw : IInspectable {
	virtual STDMETHODIMP _get_SupportsAudio(bool *value);
	virtual STDMETHODIMP _put_SupportsAudio(bool value);
	virtual STDMETHODIMP _get_SupportsVideo(bool *value);
	virtual STDMETHODIMP _put_SupportsVideo(bool value);
	virtual STDMETHODIMP _get_SupportsPictures(bool *value);
	virtual STDMETHODIMP _put_SupportsPictures(bool value);
	virtual STDMETHODIMP _get_SupportedCastingSources(Foundation::Collections::IVector<CastingSource*>* *value);
};
template<typename X> struct ICastingDevicePickerFilter_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<CastingSource>>> get() { Foundation::Collections::IVector<CastingSource*>* value; hrcheck(enc(&ICastingDevicePickerFilter_adaptor::SupportedCastingSources)->_get_SupportedCastingSources(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<CastingSource>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<CastingSource>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<CastingSource>>> operator->() { return get(); }
		} SupportedCastingSources;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICastingDevicePickerFilter_adaptor::SupportsAudio)->_get_SupportsAudio(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICastingDevicePickerFilter_adaptor::SupportsAudio)->_put_SupportsAudio(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} SupportsAudio;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICastingDevicePickerFilter_adaptor::SupportsPictures)->_get_SupportsPictures(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICastingDevicePickerFilter_adaptor::SupportsPictures)->_put_SupportsPictures(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} SupportsPictures;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICastingDevicePickerFilter_adaptor::SupportsVideo)->_get_SupportsVideo(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICastingDevicePickerFilter_adaptor::SupportsVideo)->_put_SupportsVideo(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} SupportsVideo;
	};
	ICastingDevicePickerFilter_adaptor() {}
};
template<typename X> struct adapt<ICastingDevicePickerFilter, X> : Windows::Media::Casting::ICastingDevicePickerFilter_adaptor<X> { typedef adapt ICastingDevicePickerFilter; };
struct ICastingDevicePickerFilter : ICastingDevicePickerFilter_raw, generate<ICastingDevicePickerFilter> {};

// CastingDevicePickerFilter
template<typename X> struct statics<CastingDevicePickerFilter, X> : X {
	typedef typename X::root_type CastingDevicePickerFilter;
};
struct CastingDevicePickerFilter : generate<CastingDevicePickerFilter> {};

// ICastingDevicePicker
struct ICastingDevicePicker_raw : IInspectable {
	virtual STDMETHODIMP _get_Filter(CastingDevicePickerFilter* *value);
	virtual STDMETHODIMP _get_Appearance(Windows::Devices::Enumeration::DevicePickerAppearance* *value);
	virtual STDMETHODIMP _add_CastingDeviceSelected(Foundation::TypedEventHandler<CastingDevicePicker*, CastingDeviceSelectedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CastingDeviceSelected(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_CastingDevicePickerDismissed(Foundation::TypedEventHandler<CastingDevicePicker*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CastingDevicePickerDismissed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _Show(Foundation::Rect selection);
	virtual STDMETHODIMP _ShowWithPlacement(Foundation::Rect selection, UI::Popups::Placement preferredPlacement);
	virtual STDMETHODIMP _Hide();
};
template<typename X> struct ICastingDevicePicker_adaptor : X {
	union {
		struct : property {
			ptr<Windows::Devices::Enumeration::DevicePickerAppearance> get() { Windows::Devices::Enumeration::DevicePickerAppearance* value; hrcheck(enc(&ICastingDevicePicker_adaptor::Appearance)->_get_Appearance(&value)); return from_abi(value); }
			ptr<Windows::Devices::Enumeration::DevicePickerAppearance> operator()() { return get(); }
			operator ptr<Windows::Devices::Enumeration::DevicePickerAppearance> () { return get(); }
			ptr<Windows::Devices::Enumeration::DevicePickerAppearance> operator->() { return get(); }
		} Appearance;
		struct : property {
			ptr<CastingDevicePickerFilter> get() { CastingDevicePickerFilter* value; hrcheck(enc(&ICastingDevicePicker_adaptor::Filter)->_get_Filter(&value)); return from_abi(value); }
			ptr<CastingDevicePickerFilter> operator()() { return get(); }
			operator ptr<CastingDevicePickerFilter> () { return get(); }
			ptr<CastingDevicePickerFilter> operator->() { return get(); }
		} Filter;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<CastingDevicePicker>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICastingDevicePicker_adaptor::CastingDevicePickerDismissed)->_add_CastingDevicePickerDismissed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICastingDevicePicker_adaptor::CastingDevicePickerDismissed)->_remove_CastingDevicePickerDismissed(token)); }
		} CastingDevicePickerDismissed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<CastingDevicePicker>, ptr<CastingDeviceSelectedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICastingDevicePicker_adaptor::CastingDeviceSelected)->_add_CastingDeviceSelected(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICastingDevicePicker_adaptor::CastingDeviceSelected)->_remove_CastingDeviceSelected(token)); }
		} CastingDeviceSelected;
	};
	void Show(const Foundation::Rect& selection) { hrcheck(X::get()->_Show(selection)); }
	void Show(const Foundation::Rect& selection, UI::Popups::Placement preferredPlacement) { hrcheck(X::get()->_ShowWithPlacement(selection, preferredPlacement)); }
	void Hide() { hrcheck(X::get()->_Hide()); }
	ICastingDevicePicker_adaptor() {}
};
template<typename X> struct adapt<ICastingDevicePicker, X> : Windows::Media::Casting::ICastingDevicePicker_adaptor<X> { typedef adapt ICastingDevicePicker; };
struct ICastingDevicePicker : ICastingDevicePicker_raw, generate<ICastingDevicePicker> {};

// CastingDevicePicker
template<typename X> struct statics<CastingDevicePicker, X> : X {
	typedef typename X::root_type CastingDevicePicker;
};
struct CastingDevicePicker : generate<CastingDevicePicker> {
	using ICastingDevicePicker::Show;
};
}}}
} // namespace iso_winrt
