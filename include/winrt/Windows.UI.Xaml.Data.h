#pragma once
// generated by isopod tools
// namespaces:
// Windows.UI.Xaml.Data

#include "Windows.UI.Xaml.Data.0.h"
#include "Windows.UI.Xaml.Interop.0.h"
#include "Windows.Foundation.Collections.h"
#include "Windows.Foundation.h"
#include "Windows.UI.Xaml.h"

namespace iso_winrt {

// forward types


// defs

template<> struct def<Windows::UI::Xaml::Data::IItemsRangeInfo> : overridable_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::UI::Xaml::Data::ISelectionInfo> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Data::BindingMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Data::RelativeSourceMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Data::UpdateSourceTrigger> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Data::LoadMoreItemsResult> : value_type<unsigned> {};
template<> struct def<Windows::UI::Xaml::Data::BindableAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::UI::Xaml::Data::CurrentChangingEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Data::ICurrentChangingEventArgsFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::ICurrentChangingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::CurrentChangingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Data::ICurrentChangingEventArgs>, composer_type<Windows::UI::Xaml::Data::ICurrentChangingEventArgsFactory> {};
template<> struct def<Windows::UI::Xaml::Data::PropertyChangedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Data::IPropertyChangedEventArgsFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::IPropertyChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::PropertyChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Data::IPropertyChangedEventArgs>, composer_type<Windows::UI::Xaml::Data::IPropertyChangedEventArgsFactory> {};
template<> struct def<Windows::UI::Xaml::Data::ICustomProperty> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Data::ICustomPropertyProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Data::INotifyPropertyChanged> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Data::ISupportIncrementalLoading> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Data::IValueConverter> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Data::IBindingExpressionBase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::IBindingExpressionBaseFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::BindingExpressionBase> : class_type<Platform::Object, Windows::UI::Xaml::Data::IBindingExpressionBase> {};
template<> struct def<Windows::UI::Xaml::Data::IBindingOperations> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::IBindingOperationsStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::BindingOperations> : class_type<Platform::Object, Windows::UI::Xaml::Data::IBindingOperations> {};
template<> struct def<Windows::UI::Xaml::Data::IBindingBase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::IBindingBaseFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::BindingBase> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Data::IBindingBase>, composer_type<Windows::UI::Xaml::Data::IBindingBaseFactory> {};
template<> struct def<Windows::UI::Xaml::Data::IBindingExpression> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::IBindingExpressionFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::BindingExpression> : class_type<Windows::UI::Xaml::Data::BindingExpressionBase, Windows::UI::Xaml::Data::IBindingExpression> {};
template<> struct def<Windows::UI::Xaml::Data::IRelativeSource> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::IRelativeSourceFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::RelativeSource> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Data::IRelativeSource>, composer_type<Windows::UI::Xaml::Data::IRelativeSourceFactory> {};
template<> struct def<Windows::UI::Xaml::Data::IBinding> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::IBindingFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::IBinding2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::Binding> : class_type<Windows::UI::Xaml::Data::BindingBase, Windows::UI::Xaml::Data::IBinding, Windows::UI::Xaml::Data::IBinding2>, composer_type<Windows::UI::Xaml::Data::IBindingFactory> {};
template<> struct def<Windows::UI::Xaml::Data::ICollectionView> : overridable_type<Windows::Foundation::Collections::IObservableVector<object>, Windows::Foundation::Collections::IVector<object>, Windows::Foundation::Collections::IIterable<object>> {};
template<> struct def<Windows::UI::Xaml::Data::ICollectionViewFactory> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Data::ICollectionViewGroup> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Data::IItemIndexRange> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::IItemIndexRangeFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::ItemIndexRange> : class_type<Platform::Object, Windows::UI::Xaml::Data::IItemIndexRange>, composer_type<Windows::UI::Xaml::Data::IItemIndexRangeFactory> {};
template<> struct def<Windows::UI::Xaml::Data::ICollectionViewSource> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::ICollectionViewSourceStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Data::CollectionViewSource> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Data::ICollectionViewSource> {};

// uuids

template<> struct uuid<Windows::UI::Xaml::Data::IItemsRangeInfo> { define_guid(0xF05F5665, 0x71FD, 0x45A2, 0xBE, 0x13, 0xA0, 0x81, 0xD2, 0x94, 0xA6, 0x8D);};
template<> struct uuid<Windows::UI::Xaml::Data::ISelectionInfo> { define_guid(0x2E12CA86, 0xE1ED, 0x4245, 0xBE, 0x49, 0x20, 0x7E, 0x42, 0xAE, 0xC5, 0x24);};
template<> struct uuid<Windows::UI::Xaml::Data::CurrentChangingEventHandler> { define_guid(0xF3888DB8, 0x139F, 0x4DCE, 0x8D, 0xC9, 0xF7, 0xF1, 0x44, 0x4D, 0x11, 0x85);};
template<> struct uuid<Windows::UI::Xaml::Data::ICurrentChangingEventArgsFactory> { define_guid(0x153BBEEE, 0x62F3, 0x48CF, 0x81, 0x83, 0x8B, 0xE2, 0x6D, 0xE3, 0xA6, 0x6E);};
template<> struct uuid<Windows::UI::Xaml::Data::ICurrentChangingEventArgs> { define_guid(0xF9891E29, 0x51CC, 0x47DD, 0xA5, 0xB9, 0x35, 0xDC, 0x49, 0x14, 0xAF, 0x69);};
template<> struct uuid<Windows::UI::Xaml::Data::PropertyChangedEventHandler> { define_guid(0x50F19C16, 0xA22, 0x4D8E, 0xA0, 0x89, 0x1E, 0xA9, 0x95, 0x16, 0x57, 0xD2);};
template<> struct uuid<Windows::UI::Xaml::Data::IPropertyChangedEventArgsFactory> { define_guid(0x6DCC9C03, 0xE0C7, 0x4EEE, 0x8E, 0xA9, 0x37, 0xE3, 0x40, 0x6E, 0xEB, 0x1C);};
template<> struct uuid<Windows::UI::Xaml::Data::IPropertyChangedEventArgs> { define_guid(0x4F33A9A0, 0x5CF4, 0x47A4, 0xB1, 0x6F, 0xD7, 0xFA, 0xAF, 0x17, 0x45, 0x7E);};
template<> struct uuid<Windows::UI::Xaml::Data::ICustomProperty> { define_guid(0x30DA92C0, 0x23E8, 0x42A0, 0xAE, 0x7C, 0x73, 0x4A, 0xE, 0x5D, 0x27, 0x82);};
template<> struct uuid<Windows::UI::Xaml::Data::ICustomPropertyProvider> { define_guid(0x7C925755, 0x3E48, 0x42B4, 0x86, 0x77, 0x76, 0x37, 0x22, 0x67, 0x3, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::Data::INotifyPropertyChanged> { define_guid(0xCF75D69C, 0xF2F4, 0x486B, 0xB3, 0x2, 0xBB, 0x4C, 0x9, 0xBA, 0xEB, 0xFA);};
template<> struct uuid<Windows::UI::Xaml::Data::ISupportIncrementalLoading> { define_guid(0x7F5EE992, 0x7694, 0x4E6C, 0xA5, 0x1B, 0xE3, 0x4B, 0xF4, 0x3D, 0xE7, 0x43);};
template<> struct uuid<Windows::UI::Xaml::Data::IValueConverter> { define_guid(0xE6F2FEF0, 0x712, 0x487F, 0xB3, 0x13, 0xF3, 0x0, 0xB8, 0xD7, 0x9A, 0xA1);};
template<> struct uuid<Windows::UI::Xaml::Data::IBindingExpressionBase> { define_guid(0xFDED3154, 0xE954, 0x4F67, 0x8F, 0xB6, 0x6E, 0xD7, 0x9B, 0x3A, 0x1C, 0xB3);};
template<> struct uuid<Windows::UI::Xaml::Data::IBindingExpressionBaseFactory> { define_guid(0xEA7116A7, 0xC2D9, 0x4375, 0xB4, 0x71, 0x66, 0xB9, 0xC4, 0x8C, 0x79, 0x30);};
template<> struct uuid<Windows::UI::Xaml::Data::IBindingOperations> { define_guid(0x6FFFD738, 0x9839, 0x419C, 0xA1, 0x7A, 0x4B, 0x36, 0x4, 0xE1, 0x52, 0x4E);};
template<> struct uuid<Windows::UI::Xaml::Data::IBindingOperationsStatics> { define_guid(0xE155EF73, 0x95A0, 0x4AAB, 0x8C, 0x7D, 0x2A, 0x47, 0xDA, 0x7, 0x3C, 0x79);};
template<> struct uuid<Windows::UI::Xaml::Data::IBindingBase> { define_guid(0x1589A2AB, 0x3D15, 0x49BC, 0xA4, 0x47, 0x8A, 0x54, 0x48, 0xE5, 0x88, 0x70);};
template<> struct uuid<Windows::UI::Xaml::Data::IBindingBaseFactory> { define_guid(0x22DAFC3A, 0x7701, 0x4666, 0xA1, 0xBA, 0x98, 0x59, 0xBD, 0xCF, 0xEC, 0x34);};
template<> struct uuid<Windows::UI::Xaml::Data::IBindingExpression> { define_guid(0x516A19A5, 0xC2FD, 0x4A9E, 0x9F, 0xD3, 0x9A, 0xA4, 0x2F, 0x99, 0x5A, 0x3C);};
template<> struct uuid<Windows::UI::Xaml::Data::IBindingExpressionFactory> { define_guid(0x1CB55CD9, 0xDB72, 0x40B3, 0xA2, 0xB5, 0x24, 0xEE, 0x6E, 0xA5, 0xC3, 0x28);};
template<> struct uuid<Windows::UI::Xaml::Data::IRelativeSource> { define_guid(0x2397CE84, 0x2822, 0x483A, 0xB4, 0x99, 0xD0, 0xF0, 0x31, 0xE0, 0x6C, 0x6B);};
template<> struct uuid<Windows::UI::Xaml::Data::IRelativeSourceFactory> { define_guid(0xEF8392CD, 0x446E, 0x4F93, 0xAA, 0xCB, 0x9B, 0x12, 0x55, 0x57, 0x74, 0x60);};
template<> struct uuid<Windows::UI::Xaml::Data::IBinding> { define_guid(0x3F7A0C6B, 0xD00F, 0x4730, 0x8C, 0x1D, 0x48, 0xE1, 0x6C, 0x46, 0xF9, 0xCA);};
template<> struct uuid<Windows::UI::Xaml::Data::IBindingFactory> { define_guid(0xFF42BB08, 0xC39E, 0x4F7E, 0x84, 0x34, 0xA1, 0x56, 0x90, 0x83, 0x88, 0x3C);};
template<> struct uuid<Windows::UI::Xaml::Data::IBinding2> { define_guid(0x34F96FCB, 0x406, 0x48B3, 0x9E, 0x82, 0xF3, 0x33, 0xEC, 0x4C, 0x69, 0x10);};
template<> struct uuid<Windows::UI::Xaml::Data::ICollectionView> { define_guid(0x8BE8BFE4, 0xDBEF, 0x44DF, 0x81, 0x26, 0xA3, 0x1A, 0x89, 0x12, 0x1D, 0xDC);};
template<> struct uuid<Windows::UI::Xaml::Data::ICollectionViewFactory> { define_guid(0x34D4AAF4, 0x8E72, 0x4950, 0x91, 0x92, 0xEC, 0xD0, 0x7D, 0x39, 0x9D, 0xA);};
template<> struct uuid<Windows::UI::Xaml::Data::ICollectionViewGroup> { define_guid(0x7E01B9D8, 0xD7B5, 0x48B6, 0xB3, 0x1C, 0x5B, 0xB5, 0xBD, 0xF5, 0xF0, 0x9B);};
template<> struct uuid<Windows::UI::Xaml::Data::IItemIndexRange> { define_guid(0x83B834BE, 0x583, 0x4A26, 0x9B, 0x64, 0x8B, 0xF4, 0xA2, 0xF6, 0x57, 0x4);};
template<> struct uuid<Windows::UI::Xaml::Data::IItemIndexRangeFactory> { define_guid(0x86E2C440, 0x2E7A, 0x4C7D, 0xA6, 0x64, 0xE8, 0xAB, 0xF0, 0x7B, 0xFC, 0x7E);};
template<> struct uuid<Windows::UI::Xaml::Data::ICollectionViewSource> { define_guid(0xA66A1146, 0xD2FB, 0x4EAD, 0xBE, 0x9F, 0x35, 0x78, 0xA4, 0x66, 0xDC, 0xFE);};
template<> struct uuid<Windows::UI::Xaml::Data::ICollectionViewSourceStatics> { define_guid(0x173A0710, 0x46AF, 0x4C0C, 0x81, 0x8B, 0x21, 0xB6, 0xEF, 0x81, 0xBF, 0x65);};

// types

namespace Windows { namespace UI { namespace Xaml { namespace Data {

// IItemsRangeInfo
struct IItemsRangeInfo_raw : IInspectable {
	virtual STDMETHODIMP _RangesChanged(ItemIndexRange* visibleRange, Foundation::Collections::IVectorView<ItemIndexRange*>* trackedItems) = 0;
};
template<typename X> struct IItemsRangeInfo_adaptor : X {
	void RangesChanged(pptr<ItemIndexRange> visibleRange, pptr<Foundation::Collections::IVectorView<ptr<ItemIndexRange>>> trackedItems) { hrcheck(X::get()->_RangesChanged(visibleRange, to_abi(trackedItems))); }
};
template<typename X> struct adapt<IItemsRangeInfo, X> : Windows::UI::Xaml::Data::IItemsRangeInfo_adaptor<X> { typedef adapt IItemsRangeInfo; };
template<typename X> struct IItemsRangeInfo_unadaptor : X {
	STDMETHODIMP _RangesChanged(ItemIndexRange* visibleRange, Foundation::Collections::IVectorView<ItemIndexRange*>* trackedItems) { return hrtry([&, this] { X::get()->RangesChanged(visibleRange, trackedItems); }); }
};
template<typename X> struct unadapt<IItemsRangeInfo, X> : Windows::UI::Xaml::Data::IItemsRangeInfo_unadaptor<X> {};
struct IItemsRangeInfo : IItemsRangeInfo_raw, generate<IItemsRangeInfo> {};

// ISelectionInfo
struct ISelectionInfo_raw : IInspectable {
	virtual STDMETHODIMP _SelectRange(ItemIndexRange* itemIndexRange) = 0;
	virtual STDMETHODIMP _DeselectRange(ItemIndexRange* itemIndexRange) = 0;
	virtual STDMETHODIMP _IsSelected(int index, bool *returnValue) = 0;
	virtual STDMETHODIMP _GetSelectedRanges(Foundation::Collections::IVectorView<ItemIndexRange*>* *returnValue) = 0;
};
template<typename X> struct ISelectionInfo_adaptor : X {
	void SelectRange(pptr<ItemIndexRange> itemIndexRange) { hrcheck(X::get()->_SelectRange(itemIndexRange)); }
	void DeselectRange(pptr<ItemIndexRange> itemIndexRange) { hrcheck(X::get()->_DeselectRange(itemIndexRange)); }
	bool IsSelected(int index) { bool returnValue; hrcheck(X::get()->_IsSelected(index, &returnValue)); return returnValue; }
	ptr<Foundation::Collections::IVectorView<ptr<ItemIndexRange>>> GetSelectedRanges() { Foundation::Collections::IVectorView<ItemIndexRange*>* returnValue; hrcheck(X::get()->_GetSelectedRanges(&returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<ISelectionInfo, X> : Windows::UI::Xaml::Data::ISelectionInfo_adaptor<X> { typedef adapt ISelectionInfo; };
template<typename X> struct ISelectionInfo_unadaptor : X {
	STDMETHODIMP _SelectRange(ItemIndexRange* itemIndexRange) { return hrtry([&, this] { X::get()->SelectRange(itemIndexRange); }); }
	STDMETHODIMP _DeselectRange(ItemIndexRange* itemIndexRange) { return hrtry([&, this] { X::get()->DeselectRange(itemIndexRange); }); }
	STDMETHODIMP _IsSelected(int index, bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->IsSelected(index); }); }
	STDMETHODIMP _GetSelectedRanges(Foundation::Collections::IVectorView<ItemIndexRange*>* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetSelectedRanges()); }); }
};
template<typename X> struct unadapt<ISelectionInfo, X> : Windows::UI::Xaml::Data::ISelectionInfo_unadaptor<X> {};
struct ISelectionInfo : ISelectionInfo_raw, generate<ISelectionInfo> {};

// BindableAttribute
template<typename X> struct statics<BindableAttribute, X> : X {
	typedef typename X::root_type BindableAttribute;
};
struct BindableAttribute : generate<BindableAttribute> {};

// CurrentChangingEventHandler
struct CurrentChangingEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, CurrentChangingEventArgs* e) = 0;
};

// ICurrentChangingEventArgsFactory
struct ICurrentChangingEventArgsFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, CurrentChangingEventArgs* *instance);
	virtual STDMETHODIMP _CreateWithCancelableParameter(bool isCancelable, IInspectable* outer, IInspectable* *inner, CurrentChangingEventArgs* *instance);
};

// ICurrentChangingEventArgs
struct ICurrentChangingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Cancel(bool *value);
	virtual STDMETHODIMP _put_Cancel(bool value);
	virtual STDMETHODIMP _get_IsCancelable(bool *value);
};
template<typename X> struct ICurrentChangingEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICurrentChangingEventArgs_adaptor::Cancel)->_get_Cancel(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICurrentChangingEventArgs_adaptor::Cancel)->_put_Cancel(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Cancel;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICurrentChangingEventArgs_adaptor::IsCancelable)->_get_IsCancelable(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsCancelable;
	};
	ICurrentChangingEventArgs_adaptor() {}
};
template<typename X> struct adapt<ICurrentChangingEventArgs, X> : Windows::UI::Xaml::Data::ICurrentChangingEventArgs_adaptor<X> { typedef adapt ICurrentChangingEventArgs; };
struct ICurrentChangingEventArgs : ICurrentChangingEventArgs_raw, generate<ICurrentChangingEventArgs> {};

// CurrentChangingEventArgs
template<typename> struct CurrentChangingEventArgs_statics {
	static CurrentChangingEventArgs *activate(object_ref outer, IInspectable* *inner) { CurrentChangingEventArgs *instance; hrcheck(get_activation_factory<CurrentChangingEventArgs, ICurrentChangingEventArgsFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
	static CurrentChangingEventArgs *activate(bool isCancelable, object_ref outer, IInspectable* *inner) { CurrentChangingEventArgs *instance; hrcheck(get_activation_factory<CurrentChangingEventArgs, ICurrentChangingEventArgsFactory>()->_CreateWithCancelableParameter(isCancelable, outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<CurrentChangingEventArgs, X> : X, Windows::UI::Xaml::Data::CurrentChangingEventArgs_statics<void> {
	using Windows::UI::Xaml::Data::CurrentChangingEventArgs_statics<void>::activate;
	typedef typename X::root_type CurrentChangingEventArgs;
};
struct CurrentChangingEventArgs : generate<CurrentChangingEventArgs> {};

// PropertyChangedEventHandler
struct PropertyChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, PropertyChangedEventArgs* e) = 0;
};

// IPropertyChangedEventArgsFactory
struct IPropertyChangedEventArgsFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(HSTRING name, IInspectable* outer, IInspectable* *inner, PropertyChangedEventArgs* *instance);
};

// IPropertyChangedEventArgs
struct IPropertyChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_PropertyName(HSTRING *value);
};
template<typename X> struct IPropertyChangedEventArgs_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPropertyChangedEventArgs_adaptor::PropertyName)->_get_PropertyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PropertyName;
	};
	IPropertyChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IPropertyChangedEventArgs, X> : Windows::UI::Xaml::Data::IPropertyChangedEventArgs_adaptor<X> { typedef adapt IPropertyChangedEventArgs; };
struct IPropertyChangedEventArgs : IPropertyChangedEventArgs_raw, generate<IPropertyChangedEventArgs> {};

// PropertyChangedEventArgs
template<typename> struct PropertyChangedEventArgs_statics {
	static PropertyChangedEventArgs *activate(hstring_ref name, object_ref outer, IInspectable* *inner) { PropertyChangedEventArgs *instance; hrcheck(get_activation_factory<PropertyChangedEventArgs, IPropertyChangedEventArgsFactory>()->_CreateInstance(name, outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<PropertyChangedEventArgs, X> : X, Windows::UI::Xaml::Data::PropertyChangedEventArgs_statics<void> {
	using Windows::UI::Xaml::Data::PropertyChangedEventArgs_statics<void>::activate;
	typedef typename X::root_type PropertyChangedEventArgs;
};
struct PropertyChangedEventArgs : generate<PropertyChangedEventArgs> {};

// ICustomProperty
struct ICustomProperty_raw : IInspectable {
	virtual STDMETHODIMP _get_Type(Interop::TypeName *value) = 0;
	virtual STDMETHODIMP _get_Name(HSTRING *value) = 0;
	virtual STDMETHODIMP _GetValue(IInspectable* target, IInspectable* *returnValue) = 0;
	virtual STDMETHODIMP _SetValue(IInspectable* target, IInspectable* value) = 0;
	virtual STDMETHODIMP _GetIndexedValue(IInspectable* target, IInspectable* index, IInspectable* *returnValue) = 0;
	virtual STDMETHODIMP _SetIndexedValue(IInspectable* target, IInspectable* value, IInspectable* index) = 0;
	virtual STDMETHODIMP _get_CanWrite(bool *value) = 0;
	virtual STDMETHODIMP _get_CanRead(bool *value) = 0;
};
template<typename X> struct ICustomProperty_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICustomProperty_adaptor::CanRead)->_get_CanRead(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanRead;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICustomProperty_adaptor::CanWrite)->_get_CanWrite(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanWrite;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICustomProperty_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			Interop::TypeName get() { Interop::TypeName value; hrcheck(enc(&ICustomProperty_adaptor::Type)->_get_Type(&value)); return value; }
			Interop::TypeName operator()() { return get(); }
			operator Interop::TypeName () { return get(); }
		} Type;
	};
	object GetValue(object_ref target) { IInspectable* returnValue; hrcheck(X::get()->_GetValue(target, &returnValue)); return from_abi(returnValue); }
	void SetValue(object_ref target, object_ref value) { hrcheck(X::get()->_SetValue(target, value)); }
	object GetIndexedValue(object_ref target, object_ref index) { IInspectable* returnValue; hrcheck(X::get()->_GetIndexedValue(target, index, &returnValue)); return from_abi(returnValue); }
	void SetIndexedValue(object_ref target, object_ref value, object_ref index) { hrcheck(X::get()->_SetIndexedValue(target, value, index)); }
	ICustomProperty_adaptor() {}
};
template<typename X> struct adapt<ICustomProperty, X> : Windows::UI::Xaml::Data::ICustomProperty_adaptor<X> { typedef adapt ICustomProperty; };
template<typename X> struct ICustomProperty_unadaptor : X {
	STDMETHODIMP _get_Type(Interop::TypeName *value) { return hrtry([&, this] { get_prop(value, Type); }); }
	STDMETHODIMP _get_Name(HSTRING *value) { return hrtry([&, this] { get_prop(value, Name); }); }
	STDMETHODIMP _GetValue(IInspectable* target, IInspectable* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetValue(target)); }); }
	STDMETHODIMP _SetValue(IInspectable* target, IInspectable* value) { return hrtry([&, this] { X::get()->SetValue(target, value); }); }
	STDMETHODIMP _GetIndexedValue(IInspectable* target, IInspectable* index, IInspectable* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetIndexedValue(target, index)); }); }
	STDMETHODIMP _SetIndexedValue(IInspectable* target, IInspectable* value, IInspectable* index) { return hrtry([&, this] { X::get()->SetIndexedValue(target, value, index); }); }
	STDMETHODIMP _get_CanWrite(bool *value) { return hrtry([&, this] { get_prop(value, CanWrite); }); }
	STDMETHODIMP _get_CanRead(bool *value) { return hrtry([&, this] { get_prop(value, CanRead); }); }
};
template<typename X> struct unadapt<ICustomProperty, X> : Windows::UI::Xaml::Data::ICustomProperty_unadaptor<X> {};
struct ICustomProperty : ICustomProperty_raw, generate<ICustomProperty> {};

// ICustomPropertyProvider
struct ICustomPropertyProvider_raw : IInspectable {
	virtual STDMETHODIMP _GetCustomProperty(HSTRING name, ICustomProperty* *returnValue) = 0;
	virtual STDMETHODIMP _GetIndexedProperty(HSTRING name, Interop::TypeName type, ICustomProperty* *returnValue) = 0;
	virtual STDMETHODIMP _GetStringRepresentation(HSTRING *returnValue) = 0;
	virtual STDMETHODIMP _get_Type(Interop::TypeName *value) = 0;
};
template<typename X> struct ICustomPropertyProvider_adaptor : X {
	union {
		struct : property {
			Interop::TypeName get() { Interop::TypeName value; hrcheck(enc(&ICustomPropertyProvider_adaptor::Type)->_get_Type(&value)); return value; }
			Interop::TypeName operator()() { return get(); }
			operator Interop::TypeName () { return get(); }
		} Type;
	};
	ptr<ICustomProperty> GetCustomProperty(hstring_ref name) { ICustomProperty* returnValue; hrcheck(X::get()->_GetCustomProperty(name, &returnValue)); return from_abi(returnValue); }
	ptr<ICustomProperty> GetIndexedProperty(hstring_ref name, const Interop::TypeName& type) { ICustomProperty* returnValue; hrcheck(X::get()->_GetIndexedProperty(name, type, &returnValue)); return from_abi(returnValue); }
	hstring GetStringRepresentation() { HSTRING returnValue; hrcheck(X::get()->_GetStringRepresentation(&returnValue)); return from_abi(returnValue); }
	ICustomPropertyProvider_adaptor() {}
};
template<typename X> struct adapt<ICustomPropertyProvider, X> : Windows::UI::Xaml::Data::ICustomPropertyProvider_adaptor<X> { typedef adapt ICustomPropertyProvider; };
template<typename X> struct ICustomPropertyProvider_unadaptor : X {
	STDMETHODIMP _GetCustomProperty(HSTRING name, ICustomProperty* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetCustomProperty(name)); }); }
	STDMETHODIMP _GetIndexedProperty(HSTRING name, Interop::TypeName type, ICustomProperty* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetIndexedProperty(name, type)); }); }
	STDMETHODIMP _GetStringRepresentation(HSTRING *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetStringRepresentation()); }); }
	STDMETHODIMP _get_Type(Interop::TypeName *value) { return hrtry([&, this] { get_prop(value, Type); }); }
};
template<typename X> struct unadapt<ICustomPropertyProvider, X> : Windows::UI::Xaml::Data::ICustomPropertyProvider_unadaptor<X> {};
struct ICustomPropertyProvider : ICustomPropertyProvider_raw, generate<ICustomPropertyProvider> {};

// INotifyPropertyChanged
struct INotifyPropertyChanged_raw : IInspectable {
	virtual STDMETHODIMP _add_PropertyChanged(PropertyChangedEventHandler* value, Foundation::EventRegistrationToken *token) = 0;
	virtual STDMETHODIMP _remove_PropertyChanged(Foundation::EventRegistrationToken token) = 0;
};
template<typename X> struct INotifyPropertyChanged_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<PropertyChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&INotifyPropertyChanged_adaptor::PropertyChanged)->_add_PropertyChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&INotifyPropertyChanged_adaptor::PropertyChanged)->_remove_PropertyChanged(token)); }
		} PropertyChanged;
	};
	INotifyPropertyChanged_adaptor() {}
};
template<typename X> struct adapt<INotifyPropertyChanged, X> : Windows::UI::Xaml::Data::INotifyPropertyChanged_adaptor<X> { typedef adapt INotifyPropertyChanged; };
template<typename X> struct INotifyPropertyChanged_unadaptor : X {
	STDMETHODIMP _add_PropertyChanged(PropertyChangedEventHandler* value, Foundation::EventRegistrationToken *token) { return hrtry([&, this] { *token = X::get()->PropertyChanged+=value; }); }
	STDMETHODIMP _remove_PropertyChanged(Foundation::EventRegistrationToken token) { return hrtry([&, this] { X::get()->PropertyChanged-=token; }); }
};
template<typename X> struct unadapt<INotifyPropertyChanged, X> : Windows::UI::Xaml::Data::INotifyPropertyChanged_unadaptor<X> {};
struct INotifyPropertyChanged : INotifyPropertyChanged_raw, generate<INotifyPropertyChanged> {};

// ISupportIncrementalLoading
struct ISupportIncrementalLoading_raw : IInspectable {
	virtual STDMETHODIMP _LoadMoreItemsAsync(unsigned count, Foundation::IAsyncOperation<LoadMoreItemsResult>* *operation) = 0;
	virtual STDMETHODIMP _get_HasMoreItems(bool *value) = 0;
};
template<typename X> struct ISupportIncrementalLoading_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISupportIncrementalLoading_adaptor::HasMoreItems)->_get_HasMoreItems(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasMoreItems;
	};
	ptr<Foundation::IAsyncOperation<LoadMoreItemsResult>> LoadMoreItemsAsync(unsigned count) { Foundation::IAsyncOperation<LoadMoreItemsResult>* operation; hrcheck(X::get()->_LoadMoreItemsAsync(count, &operation)); return from_abi(operation); }
	ISupportIncrementalLoading_adaptor() {}
};
template<typename X> struct adapt<ISupportIncrementalLoading, X> : Windows::UI::Xaml::Data::ISupportIncrementalLoading_adaptor<X> { typedef adapt ISupportIncrementalLoading; };
template<typename X> struct ISupportIncrementalLoading_unadaptor : X {
	STDMETHODIMP _LoadMoreItemsAsync(unsigned count, Foundation::IAsyncOperation<LoadMoreItemsResult>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->LoadMoreItemsAsync(count)); }); }
	STDMETHODIMP _get_HasMoreItems(bool *value) { return hrtry([&, this] { get_prop(value, HasMoreItems); }); }
};
template<typename X> struct unadapt<ISupportIncrementalLoading, X> : Windows::UI::Xaml::Data::ISupportIncrementalLoading_unadaptor<X> {};
struct ISupportIncrementalLoading : ISupportIncrementalLoading_raw, generate<ISupportIncrementalLoading> {};

// IValueConverter
struct IValueConverter_raw : IInspectable {
	virtual STDMETHODIMP _Convert(IInspectable* value, Interop::TypeName targetType, IInspectable* parameter, HSTRING language, IInspectable* *returnValue) = 0;
	virtual STDMETHODIMP _ConvertBack(IInspectable* value, Interop::TypeName targetType, IInspectable* parameter, HSTRING language, IInspectable* *returnValue) = 0;
};
template<typename X> struct IValueConverter_adaptor : X {
	object Convert(object_ref value, const Interop::TypeName& targetType, object_ref parameter, hstring_ref language) { IInspectable* returnValue; hrcheck(X::get()->_Convert(value, targetType, parameter, language, &returnValue)); return from_abi(returnValue); }
	object ConvertBack(object_ref value, const Interop::TypeName& targetType, object_ref parameter, hstring_ref language) { IInspectable* returnValue; hrcheck(X::get()->_ConvertBack(value, targetType, parameter, language, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IValueConverter, X> : Windows::UI::Xaml::Data::IValueConverter_adaptor<X> { typedef adapt IValueConverter; };
template<typename X> struct IValueConverter_unadaptor : X {
	STDMETHODIMP _Convert(IInspectable* value, Interop::TypeName targetType, IInspectable* parameter, HSTRING language, IInspectable* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->Convert(value, targetType, parameter, language)); }); }
	STDMETHODIMP _ConvertBack(IInspectable* value, Interop::TypeName targetType, IInspectable* parameter, HSTRING language, IInspectable* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->ConvertBack(value, targetType, parameter, language)); }); }
};
template<typename X> struct unadapt<IValueConverter, X> : Windows::UI::Xaml::Data::IValueConverter_unadaptor<X> {};
struct IValueConverter : IValueConverter_raw, generate<IValueConverter> {};

// IBindingExpressionBase
struct IBindingExpressionBase : IInspectable, generate<IBindingExpressionBase> {};

// IBindingExpressionBaseFactory
struct IBindingExpressionBaseFactory : IInspectable, generate<IBindingExpressionBaseFactory> {};

// BindingExpressionBase
template<typename X> struct statics<BindingExpressionBase, X> : X {
	typedef typename X::root_type BindingExpressionBase;
};
struct BindingExpressionBase : generate<BindingExpressionBase> {};

// IBindingOperations
struct IBindingOperations : IInspectable, generate<IBindingOperations> {};

// IBindingOperationsStatics
struct IBindingOperationsStatics : IInspectable {
	virtual STDMETHODIMP _SetBinding(DependencyObject* target, DependencyProperty* dp, BindingBase* binding);
};

// BindingOperations
template<typename> struct BindingOperations_statics {
	static void SetBinding(pptr<DependencyObject> target, pptr<DependencyProperty> dp, pptr<BindingBase> binding) { hrcheck(get_activation_factory<BindingOperations, IBindingOperationsStatics>()->_SetBinding(target, dp, binding)); }
};

template<typename X> struct statics<BindingOperations, X> : X, Windows::UI::Xaml::Data::BindingOperations_statics<void> {
	typedef typename X::root_type BindingOperations;
};
struct BindingOperations : generate<BindingOperations> {};

// IBindingBase
struct IBindingBase : IInspectable, generate<IBindingBase> {};

// IBindingBaseFactory
struct IBindingBaseFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, BindingBase* *instance);
};

// BindingBase
template<typename> struct BindingBase_statics {
	static BindingBase *activate(object_ref outer, IInspectable* *inner) { BindingBase *instance; hrcheck(get_activation_factory<BindingBase, IBindingBaseFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<BindingBase, X> : X, Windows::UI::Xaml::Data::BindingBase_statics<void> {
	using Windows::UI::Xaml::Data::BindingBase_statics<void>::activate;
	typedef typename X::root_type BindingBase;
};
struct BindingBase : generate<BindingBase> {};

// IBindingExpression
struct IBindingExpression_raw : IInspectable {
	virtual STDMETHODIMP _get_DataItem(IInspectable* *value);
	virtual STDMETHODIMP _get_ParentBinding(Binding* *value);
	virtual STDMETHODIMP _UpdateSource();
};
template<typename X> struct IBindingExpression_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IBindingExpression_adaptor::DataItem)->_get_DataItem(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} DataItem;
		struct : property {
			ptr<Binding> get() { Binding* value; hrcheck(enc(&IBindingExpression_adaptor::ParentBinding)->_get_ParentBinding(&value)); return from_abi(value); }
			ptr<Binding> operator()() { return get(); }
			operator ptr<Binding> () { return get(); }
			ptr<Binding> operator->() { return get(); }
		} ParentBinding;
	};
	void UpdateSource() { hrcheck(X::get()->_UpdateSource()); }
	IBindingExpression_adaptor() {}
};
template<typename X> struct adapt<IBindingExpression, X> : Windows::UI::Xaml::Data::IBindingExpression_adaptor<X> { typedef adapt IBindingExpression; };
struct IBindingExpression : IBindingExpression_raw, generate<IBindingExpression> {};

// IBindingExpressionFactory
struct IBindingExpressionFactory : IInspectable, generate<IBindingExpressionFactory> {};

// BindingExpression
template<typename X> struct statics<BindingExpression, X> : X {
	typedef typename X::root_type BindingExpression;
};
struct BindingExpression : generate<BindingExpression> {};

// IRelativeSource
struct IRelativeSource_raw : IInspectable {
	virtual STDMETHODIMP _get_Mode(RelativeSourceMode *value);
	virtual STDMETHODIMP _put_Mode(RelativeSourceMode value);
};
template<typename X> struct IRelativeSource_adaptor : X {
	union {
		struct : property {
			RelativeSourceMode get() { RelativeSourceMode value; hrcheck(enc(&IRelativeSource_adaptor::Mode)->_get_Mode(&value)); return value; }
			RelativeSourceMode operator()() { return get(); }
			operator RelativeSourceMode () { return get(); }
			void put(RelativeSourceMode value) { hrcheck(enc(&IRelativeSource_adaptor::Mode)->_put_Mode(value)); }
			void operator=(RelativeSourceMode value) { put(value); }
			void operator()(RelativeSourceMode value) { put(value); }
		} Mode;
	};
	IRelativeSource_adaptor() {}
};
template<typename X> struct adapt<IRelativeSource, X> : Windows::UI::Xaml::Data::IRelativeSource_adaptor<X> { typedef adapt IRelativeSource; };
struct IRelativeSource : IRelativeSource_raw, generate<IRelativeSource> {};

// IRelativeSourceFactory
struct IRelativeSourceFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, RelativeSource* *instance);
};

// RelativeSource
template<typename> struct RelativeSource_statics {
	static RelativeSource *activate(object_ref outer, IInspectable* *inner) { RelativeSource *instance; hrcheck(get_activation_factory<RelativeSource, IRelativeSourceFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<RelativeSource, X> : X, Windows::UI::Xaml::Data::RelativeSource_statics<void> {
	using Windows::UI::Xaml::Data::RelativeSource_statics<void>::activate;
	typedef typename X::root_type RelativeSource;
};
struct RelativeSource : generate<RelativeSource> {};

// IBinding
struct IBinding_raw : IInspectable {
	virtual STDMETHODIMP _get_Path(PropertyPath* *value);
	virtual STDMETHODIMP _put_Path(PropertyPath* value);
	virtual STDMETHODIMP _get_Mode(BindingMode *value);
	virtual STDMETHODIMP _put_Mode(BindingMode value);
	virtual STDMETHODIMP _get_Source(IInspectable* *value);
	virtual STDMETHODIMP _put_Source(IInspectable* value);
	virtual STDMETHODIMP _get_RelativeSource(Data::RelativeSource* *value);
	virtual STDMETHODIMP _put_RelativeSource(Data::RelativeSource* value);
	virtual STDMETHODIMP _get_ElementName(HSTRING *value);
	virtual STDMETHODIMP _put_ElementName(HSTRING value);
	virtual STDMETHODIMP _get_Converter(IValueConverter* *value);
	virtual STDMETHODIMP _put_Converter(IValueConverter* value);
	virtual STDMETHODIMP _get_ConverterParameter(IInspectable* *value);
	virtual STDMETHODIMP _put_ConverterParameter(IInspectable* value);
	virtual STDMETHODIMP _get_ConverterLanguage(HSTRING *value);
	virtual STDMETHODIMP _put_ConverterLanguage(HSTRING value);
};
template<typename X> struct IBinding_adaptor : X {
	union {
		struct : property {
			ptr<IValueConverter> get() { IValueConverter* value; hrcheck(enc(&IBinding_adaptor::Converter)->_get_Converter(&value)); return from_abi(value); }
			ptr<IValueConverter> operator()() { return get(); }
			operator ptr<IValueConverter> () { return get(); }
			ptr<IValueConverter> operator->() { return get(); }
			void put(pptr<IValueConverter> value) { hrcheck(enc(&IBinding_adaptor::Converter)->_put_Converter(value)); }
			void operator=(pptr<IValueConverter> value) { put(value); }
			void operator()(pptr<IValueConverter> value) { put(value); }
		} Converter;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IBinding_adaptor::ConverterLanguage)->_get_ConverterLanguage(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IBinding_adaptor::ConverterLanguage)->_put_ConverterLanguage(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ConverterLanguage;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IBinding_adaptor::ConverterParameter)->_get_ConverterParameter(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IBinding_adaptor::ConverterParameter)->_put_ConverterParameter(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} ConverterParameter;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IBinding_adaptor::ElementName)->_get_ElementName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IBinding_adaptor::ElementName)->_put_ElementName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ElementName;
		struct : property {
			BindingMode get() { BindingMode value; hrcheck(enc(&IBinding_adaptor::Mode)->_get_Mode(&value)); return value; }
			BindingMode operator()() { return get(); }
			operator BindingMode () { return get(); }
			void put(BindingMode value) { hrcheck(enc(&IBinding_adaptor::Mode)->_put_Mode(value)); }
			void operator=(BindingMode value) { put(value); }
			void operator()(BindingMode value) { put(value); }
		} Mode;
		struct : property {
			ptr<PropertyPath> get() { PropertyPath* value; hrcheck(enc(&IBinding_adaptor::Path)->_get_Path(&value)); return from_abi(value); }
			ptr<PropertyPath> operator()() { return get(); }
			operator ptr<PropertyPath> () { return get(); }
			ptr<PropertyPath> operator->() { return get(); }
			void put(pptr<PropertyPath> value) { hrcheck(enc(&IBinding_adaptor::Path)->_put_Path(value)); }
			void operator=(pptr<PropertyPath> value) { put(value); }
			void operator()(pptr<PropertyPath> value) { put(value); }
		} Path;
		struct : property {
			ptr<Data::RelativeSource> get() { Data::RelativeSource* value; hrcheck(enc(&IBinding_adaptor::RelativeSource)->_get_RelativeSource(&value)); return from_abi(value); }
			ptr<Data::RelativeSource> operator()() { return get(); }
			operator ptr<Data::RelativeSource> () { return get(); }
			ptr<Data::RelativeSource> operator->() { return get(); }
			void put(pptr<Data::RelativeSource> value) { hrcheck(enc(&IBinding_adaptor::RelativeSource)->_put_RelativeSource(value)); }
			void operator=(pptr<Data::RelativeSource> value) { put(value); }
			void operator()(pptr<Data::RelativeSource> value) { put(value); }
		} RelativeSource;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IBinding_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IBinding_adaptor::Source)->_put_Source(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Source;
	};
	IBinding_adaptor() {}
};
template<typename X> struct adapt<IBinding, X> : Windows::UI::Xaml::Data::IBinding_adaptor<X> { typedef adapt IBinding; };
struct IBinding : IBinding_raw, generate<IBinding> {};

// IBindingFactory
struct IBindingFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Binding* *instance);
};

// IBinding2
struct IBinding2_raw : IInspectable {
	virtual STDMETHODIMP _get_FallbackValue(IInspectable* *value);
	virtual STDMETHODIMP _put_FallbackValue(IInspectable* value);
	virtual STDMETHODIMP _get_TargetNullValue(IInspectable* *value);
	virtual STDMETHODIMP _put_TargetNullValue(IInspectable* value);
	virtual STDMETHODIMP _get_UpdateSourceTrigger(Data::UpdateSourceTrigger *value);
	virtual STDMETHODIMP _put_UpdateSourceTrigger(Data::UpdateSourceTrigger value);
};
template<typename X> struct IBinding2_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IBinding2_adaptor::FallbackValue)->_get_FallbackValue(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IBinding2_adaptor::FallbackValue)->_put_FallbackValue(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} FallbackValue;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IBinding2_adaptor::TargetNullValue)->_get_TargetNullValue(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IBinding2_adaptor::TargetNullValue)->_put_TargetNullValue(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} TargetNullValue;
		struct : property {
			Data::UpdateSourceTrigger get() { Data::UpdateSourceTrigger value; hrcheck(enc(&IBinding2_adaptor::UpdateSourceTrigger)->_get_UpdateSourceTrigger(&value)); return value; }
			Data::UpdateSourceTrigger operator()() { return get(); }
			operator Data::UpdateSourceTrigger () { return get(); }
			void put(Data::UpdateSourceTrigger value) { hrcheck(enc(&IBinding2_adaptor::UpdateSourceTrigger)->_put_UpdateSourceTrigger(value)); }
			void operator=(Data::UpdateSourceTrigger value) { put(value); }
			void operator()(Data::UpdateSourceTrigger value) { put(value); }
		} UpdateSourceTrigger;
	};
	IBinding2_adaptor() {}
};
template<typename X> struct adapt<IBinding2, X> : Windows::UI::Xaml::Data::IBinding2_adaptor<X> { typedef adapt IBinding2; };
struct IBinding2 : IBinding2_raw, generate<IBinding2> {};

// Binding
template<typename> struct Binding_statics {
	static Binding *activate(object_ref outer, IInspectable* *inner) { Binding *instance; hrcheck(get_activation_factory<Binding, IBindingFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<Binding, X> : X, Windows::UI::Xaml::Data::Binding_statics<void> {
	using Windows::UI::Xaml::Data::Binding_statics<void>::activate;
	typedef typename X::root_type Binding;
};
struct Binding : generate<Binding> {};

// ICollectionView
struct ICollectionView_raw : IInspectable {
	virtual STDMETHODIMP _get_CurrentItem(IInspectable* *value) = 0;
	virtual STDMETHODIMP _get_CurrentPosition(int *value) = 0;
	virtual STDMETHODIMP _get_IsCurrentAfterLast(bool *value) = 0;
	virtual STDMETHODIMP _get_IsCurrentBeforeFirst(bool *value) = 0;
	virtual STDMETHODIMP _get_CollectionGroups(Foundation::Collections::IObservableVector<IInspectable*>* *value) = 0;
	virtual STDMETHODIMP _get_HasMoreItems(bool *value) = 0;
	virtual STDMETHODIMP _add_CurrentChanged(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token) = 0;
	virtual STDMETHODIMP _remove_CurrentChanged(Foundation::EventRegistrationToken token) = 0;
	virtual STDMETHODIMP _add_CurrentChanging(CurrentChangingEventHandler* value, Foundation::EventRegistrationToken *token) = 0;
	virtual STDMETHODIMP _remove_CurrentChanging(Foundation::EventRegistrationToken token) = 0;
	virtual STDMETHODIMP _MoveCurrentTo(IInspectable* item, bool *returnValue) = 0;
	virtual STDMETHODIMP _MoveCurrentToPosition(int index, bool *returnValue) = 0;
	virtual STDMETHODIMP _MoveCurrentToFirst(bool *returnValue) = 0;
	virtual STDMETHODIMP _MoveCurrentToLast(bool *returnValue) = 0;
	virtual STDMETHODIMP _MoveCurrentToNext(bool *returnValue) = 0;
	virtual STDMETHODIMP _MoveCurrentToPrevious(bool *returnValue) = 0;
	virtual STDMETHODIMP _LoadMoreItemsAsync(unsigned count, Foundation::IAsyncOperation<LoadMoreItemsResult>* *returnValue) = 0;
};
template<typename X> struct ICollectionView_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IObservableVector<object>> get() { Foundation::Collections::IObservableVector<IInspectable*>* value; hrcheck(enc(&ICollectionView_adaptor::CollectionGroups)->_get_CollectionGroups(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IObservableVector<object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IObservableVector<object>> () { return get(); }
			ptr<Foundation::Collections::IObservableVector<object>> operator->() { return get(); }
		} CollectionGroups;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ICollectionView_adaptor::CurrentItem)->_get_CurrentItem(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} CurrentItem;
		struct : property {
			int get() { int value; hrcheck(enc(&ICollectionView_adaptor::CurrentPosition)->_get_CurrentPosition(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} CurrentPosition;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICollectionView_adaptor::HasMoreItems)->_get_HasMoreItems(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasMoreItems;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICollectionView_adaptor::IsCurrentAfterLast)->_get_IsCurrentAfterLast(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsCurrentAfterLast;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICollectionView_adaptor::IsCurrentBeforeFirst)->_get_IsCurrentBeforeFirst(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsCurrentBeforeFirst;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICollectionView_adaptor::CurrentChanged)->_add_CurrentChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICollectionView_adaptor::CurrentChanged)->_remove_CurrentChanged(token)); }
		} CurrentChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<CurrentChangingEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICollectionView_adaptor::CurrentChanging)->_add_CurrentChanging(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICollectionView_adaptor::CurrentChanging)->_remove_CurrentChanging(token)); }
		} CurrentChanging;
	};
	bool MoveCurrentTo(object_ref item) { bool returnValue; hrcheck(X::get()->_MoveCurrentTo(item, &returnValue)); return returnValue; }
	bool MoveCurrentToPosition(int index) { bool returnValue; hrcheck(X::get()->_MoveCurrentToPosition(index, &returnValue)); return returnValue; }
	bool MoveCurrentToFirst() { bool returnValue; hrcheck(X::get()->_MoveCurrentToFirst(&returnValue)); return returnValue; }
	bool MoveCurrentToLast() { bool returnValue; hrcheck(X::get()->_MoveCurrentToLast(&returnValue)); return returnValue; }
	bool MoveCurrentToNext() { bool returnValue; hrcheck(X::get()->_MoveCurrentToNext(&returnValue)); return returnValue; }
	bool MoveCurrentToPrevious() { bool returnValue; hrcheck(X::get()->_MoveCurrentToPrevious(&returnValue)); return returnValue; }
	ptr<Foundation::IAsyncOperation<LoadMoreItemsResult>> LoadMoreItemsAsync(unsigned count) { Foundation::IAsyncOperation<LoadMoreItemsResult>* returnValue; hrcheck(X::get()->_LoadMoreItemsAsync(count, &returnValue)); return from_abi(returnValue); }
	ICollectionView_adaptor() {}
};
template<typename X> struct adapt<ICollectionView, X> : Windows::UI::Xaml::Data::ICollectionView_adaptor<X> { typedef adapt ICollectionView; };
template<typename X> struct ICollectionView_unadaptor : X {
	STDMETHODIMP _get_CurrentItem(IInspectable* *value) { return hrtry([&, this] { get_prop(value, CurrentItem); }); }
	STDMETHODIMP _get_CurrentPosition(int *value) { return hrtry([&, this] { get_prop(value, CurrentPosition); }); }
	STDMETHODIMP _get_IsCurrentAfterLast(bool *value) { return hrtry([&, this] { get_prop(value, IsCurrentAfterLast); }); }
	STDMETHODIMP _get_IsCurrentBeforeFirst(bool *value) { return hrtry([&, this] { get_prop(value, IsCurrentBeforeFirst); }); }
	STDMETHODIMP _get_CollectionGroups(Foundation::Collections::IObservableVector<IInspectable*>* *value) { return hrtry([&, this] { get_prop(value, CollectionGroups); }); }
	STDMETHODIMP _get_HasMoreItems(bool *value) { return hrtry([&, this] { get_prop(value, HasMoreItems); }); }
	STDMETHODIMP _add_CurrentChanged(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token) { return hrtry([&, this] { *token = X::get()->CurrentChanged+=value; }); }
	STDMETHODIMP _remove_CurrentChanged(Foundation::EventRegistrationToken token) { return hrtry([&, this] { X::get()->CurrentChanged-=token; }); }
	STDMETHODIMP _add_CurrentChanging(CurrentChangingEventHandler* value, Foundation::EventRegistrationToken *token) { return hrtry([&, this] { *token = X::get()->CurrentChanging+=value; }); }
	STDMETHODIMP _remove_CurrentChanging(Foundation::EventRegistrationToken token) { return hrtry([&, this] { X::get()->CurrentChanging-=token; }); }
	STDMETHODIMP _MoveCurrentTo(IInspectable* item, bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->MoveCurrentTo(item); }); }
	STDMETHODIMP _MoveCurrentToPosition(int index, bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->MoveCurrentToPosition(index); }); }
	STDMETHODIMP _MoveCurrentToFirst(bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->MoveCurrentToFirst(); }); }
	STDMETHODIMP _MoveCurrentToLast(bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->MoveCurrentToLast(); }); }
	STDMETHODIMP _MoveCurrentToNext(bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->MoveCurrentToNext(); }); }
	STDMETHODIMP _MoveCurrentToPrevious(bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->MoveCurrentToPrevious(); }); }
	STDMETHODIMP _LoadMoreItemsAsync(unsigned count, Foundation::IAsyncOperation<LoadMoreItemsResult>* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->LoadMoreItemsAsync(count)); }); }
};
template<typename X> struct unadapt<ICollectionView, X> : Windows::UI::Xaml::Data::ICollectionView_unadaptor<X> {};
struct ICollectionView : ICollectionView_raw, generate<ICollectionView> {};

// ICollectionViewFactory
struct ICollectionViewFactory_raw : IInspectable {
	virtual STDMETHODIMP _CreateView(ICollectionView* *result) = 0;
};
template<typename X> struct ICollectionViewFactory_adaptor : X {
	ptr<ICollectionView> CreateView() { ICollectionView* result; hrcheck(X::get()->_CreateView(&result)); return from_abi(result); }
};
template<typename X> struct adapt<ICollectionViewFactory, X> : Windows::UI::Xaml::Data::ICollectionViewFactory_adaptor<X> { typedef adapt ICollectionViewFactory; };
template<typename X> struct ICollectionViewFactory_unadaptor : X {
	STDMETHODIMP _CreateView(ICollectionView* *result) { return hrtry([&, this] { *result = to_abi(X::get()->CreateView()); }); }
};
template<typename X> struct unadapt<ICollectionViewFactory, X> : Windows::UI::Xaml::Data::ICollectionViewFactory_unadaptor<X> {};
struct ICollectionViewFactory : ICollectionViewFactory_raw, generate<ICollectionViewFactory> {};

// ICollectionViewGroup
struct ICollectionViewGroup_raw : IInspectable {
	virtual STDMETHODIMP _get_Group(IInspectable* *value) = 0;
	virtual STDMETHODIMP _get_GroupItems(Foundation::Collections::IObservableVector<IInspectable*>* *value) = 0;
};
template<typename X> struct ICollectionViewGroup_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ICollectionViewGroup_adaptor::Group)->_get_Group(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} Group;
		struct : property {
			ptr<Foundation::Collections::IObservableVector<object>> get() { Foundation::Collections::IObservableVector<IInspectable*>* value; hrcheck(enc(&ICollectionViewGroup_adaptor::GroupItems)->_get_GroupItems(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IObservableVector<object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IObservableVector<object>> () { return get(); }
			ptr<Foundation::Collections::IObservableVector<object>> operator->() { return get(); }
		} GroupItems;
	};
	ICollectionViewGroup_adaptor() {}
};
template<typename X> struct adapt<ICollectionViewGroup, X> : Windows::UI::Xaml::Data::ICollectionViewGroup_adaptor<X> { typedef adapt ICollectionViewGroup; };
template<typename X> struct ICollectionViewGroup_unadaptor : X {
	STDMETHODIMP _get_Group(IInspectable* *value) { return hrtry([&, this] { get_prop(value, Group); }); }
	STDMETHODIMP _get_GroupItems(Foundation::Collections::IObservableVector<IInspectable*>* *value) { return hrtry([&, this] { get_prop(value, GroupItems); }); }
};
template<typename X> struct unadapt<ICollectionViewGroup, X> : Windows::UI::Xaml::Data::ICollectionViewGroup_unadaptor<X> {};
struct ICollectionViewGroup : ICollectionViewGroup_raw, generate<ICollectionViewGroup> {};

// IItemIndexRange
struct IItemIndexRange_raw : IInspectable {
	virtual STDMETHODIMP _get_FirstIndex(int *value);
	virtual STDMETHODIMP _get_Length(unsigned *value);
	virtual STDMETHODIMP _get_LastIndex(int *value);
};
template<typename X> struct IItemIndexRange_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IItemIndexRange_adaptor::FirstIndex)->_get_FirstIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} FirstIndex;
		struct : property {
			int get() { int value; hrcheck(enc(&IItemIndexRange_adaptor::LastIndex)->_get_LastIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} LastIndex;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IItemIndexRange_adaptor::Length)->_get_Length(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Length;
	};
	IItemIndexRange_adaptor() {}
};
template<typename X> struct adapt<IItemIndexRange, X> : Windows::UI::Xaml::Data::IItemIndexRange_adaptor<X> { typedef adapt IItemIndexRange; };
struct IItemIndexRange : IItemIndexRange_raw, generate<IItemIndexRange> {};

// IItemIndexRangeFactory
struct IItemIndexRangeFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(int firstIndex, unsigned length, IInspectable* outer, IInspectable* *inner, ItemIndexRange* *instance);
};

// ItemIndexRange
template<typename> struct ItemIndexRange_statics {
	static ItemIndexRange *activate(int firstIndex, unsigned length, object_ref outer, IInspectable* *inner) { ItemIndexRange *instance; hrcheck(get_activation_factory<ItemIndexRange, IItemIndexRangeFactory>()->_CreateInstance(firstIndex, length, outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<ItemIndexRange, X> : X, Windows::UI::Xaml::Data::ItemIndexRange_statics<void> {
	using Windows::UI::Xaml::Data::ItemIndexRange_statics<void>::activate;
	typedef typename X::root_type ItemIndexRange;
};
struct ItemIndexRange : generate<ItemIndexRange> {};

// ICollectionViewSource
struct ICollectionViewSource_raw : IInspectable {
	virtual STDMETHODIMP _get_Source(IInspectable* *value);
	virtual STDMETHODIMP _put_Source(IInspectable* value);
	virtual STDMETHODIMP _get_View(ICollectionView* *value);
	virtual STDMETHODIMP _get_IsSourceGrouped(bool *value);
	virtual STDMETHODIMP _put_IsSourceGrouped(bool value);
	virtual STDMETHODIMP _get_ItemsPath(PropertyPath* *value);
	virtual STDMETHODIMP _put_ItemsPath(PropertyPath* value);
};
template<typename X> struct ICollectionViewSource_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICollectionViewSource_adaptor::IsSourceGrouped)->_get_IsSourceGrouped(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICollectionViewSource_adaptor::IsSourceGrouped)->_put_IsSourceGrouped(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSourceGrouped;
		struct : property {
			ptr<PropertyPath> get() { PropertyPath* value; hrcheck(enc(&ICollectionViewSource_adaptor::ItemsPath)->_get_ItemsPath(&value)); return from_abi(value); }
			ptr<PropertyPath> operator()() { return get(); }
			operator ptr<PropertyPath> () { return get(); }
			ptr<PropertyPath> operator->() { return get(); }
			void put(pptr<PropertyPath> value) { hrcheck(enc(&ICollectionViewSource_adaptor::ItemsPath)->_put_ItemsPath(value)); }
			void operator=(pptr<PropertyPath> value) { put(value); }
			void operator()(pptr<PropertyPath> value) { put(value); }
		} ItemsPath;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ICollectionViewSource_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&ICollectionViewSource_adaptor::Source)->_put_Source(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Source;
		struct : property {
			ptr<ICollectionView> get() { ICollectionView* value; hrcheck(enc(&ICollectionViewSource_adaptor::View)->_get_View(&value)); return from_abi(value); }
			ptr<ICollectionView> operator()() { return get(); }
			operator ptr<ICollectionView> () { return get(); }
			ptr<ICollectionView> operator->() { return get(); }
		} View;
	};
	ICollectionViewSource_adaptor() {}
};
template<typename X> struct adapt<ICollectionViewSource, X> : Windows::UI::Xaml::Data::ICollectionViewSource_adaptor<X> { typedef adapt ICollectionViewSource; };
struct ICollectionViewSource : ICollectionViewSource_raw, generate<ICollectionViewSource> {};

// ICollectionViewSourceStatics
struct ICollectionViewSourceStatics : IInspectable {
	virtual STDMETHODIMP _get_SourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ViewProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsSourceGroupedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemsPathProperty(DependencyProperty* *value);
};

// CollectionViewSource
template<typename> struct CollectionViewSource_statics {
	static struct _IsSourceGroupedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CollectionViewSource, ICollectionViewSourceStatics>()->_get_IsSourceGroupedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsSourceGroupedProperty;
	static struct _ItemsPathProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CollectionViewSource, ICollectionViewSourceStatics>()->_get_ItemsPathProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemsPathProperty;
	static struct _SourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CollectionViewSource, ICollectionViewSourceStatics>()->_get_SourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SourceProperty;
	static struct _ViewProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CollectionViewSource, ICollectionViewSourceStatics>()->_get_ViewProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ViewProperty;
};
template<typename X> typename CollectionViewSource_statics<X>::_IsSourceGroupedProperty CollectionViewSource_statics<X>::IsSourceGroupedProperty;
template<typename X> typename CollectionViewSource_statics<X>::_ItemsPathProperty CollectionViewSource_statics<X>::ItemsPathProperty;
template<typename X> typename CollectionViewSource_statics<X>::_SourceProperty CollectionViewSource_statics<X>::SourceProperty;
template<typename X> typename CollectionViewSource_statics<X>::_ViewProperty CollectionViewSource_statics<X>::ViewProperty;

template<typename X> struct statics<CollectionViewSource, X> : X, Windows::UI::Xaml::Data::CollectionViewSource_statics<void> {
	typedef typename X::root_type CollectionViewSource;
};
struct CollectionViewSource : generate<CollectionViewSource> {};
}}}}
} // namespace iso_winrt
