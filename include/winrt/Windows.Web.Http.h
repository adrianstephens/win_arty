#pragma once
// generated by isopod tools
// namespaces:
// Windows.Web.Http

#include "Windows.Web.Http.0.h"
#include "Windows.Storage.Streams.0.h"
#include "Windows.Networking.Sockets.0.h"
#include "Windows.Security.Cryptography.Certificates.0.h"
#include "Windows.Foundation.Collections.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Web { namespace Http { namespace Filters {
struct IHttpFilter;
}
namespace Headers {
struct HttpContentHeaderCollection;
struct HttpRequestHeaderCollection;
struct HttpResponseHeaderCollection;
}}}}

// defs

template<> struct def<Windows::Web::Http::HttpVersion> : enum_type<int> {};
template<> struct def<Windows::Web::Http::HttpCompletionOption> : enum_type<int> {};
template<> struct def<Windows::Web::Http::HttpStatusCode> : enum_type<int> {};
template<> struct def<Windows::Web::Http::HttpProgressStage> : enum_type<int> {};
template<> struct def<Windows::Web::Http::HttpResponseMessageSource> : enum_type<int> {};
template<> struct def<Windows::Web::Http::HttpProgress> : value_type<Windows::Web::Http::HttpProgressStage, unsigned __int64, Windows::Foundation::IReference<unsigned __int64>*, unsigned __int64, Windows::Foundation::IReference<unsigned __int64>*, unsigned> {};
template<> struct def<Windows::Web::Http::IHttpClientFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::IHttpRequestMessageFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::IHttpRequestMessage> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Web::Http::HttpRequestMessage> : class_type<Platform::Object, Windows::Web::Http::IHttpRequestMessage, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::IHttpResponseMessageFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::IHttpResponseMessage> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Web::Http::HttpResponseMessage> : class_type<Platform::Object, Windows::Web::Http::IHttpResponseMessage, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::IHttpClient> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Web::Http::HttpClient> : class_type<Platform::Object, Windows::Web::Http::IHttpClient, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::IHttpContent> : overridable_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Web::Http::IHttpCookieManager> : interface_type<> {};
template<> struct def<Windows::Web::Http::IHttpCookieFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::IHttpCookie> : interface_type<> {};
template<> struct def<Windows::Web::Http::HttpCookie> : class_type<Platform::Object, Windows::Web::Http::IHttpCookie, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::HttpCookieCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVectorView<ptr<Windows::Web::Http::HttpCookie>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Web::Http::HttpCookie>>> {};
template<> struct def<Windows::Web::Http::IHttpMethodStatics> : interface_type<> {};
template<> struct def<Windows::Web::Http::IHttpMethodFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::IHttpMethod> : interface_type<> {};
template<> struct def<Windows::Web::Http::HttpMethod> : class_type<Platform::Object, Windows::Web::Http::IHttpMethod, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::IHttpTransportInformation> : interface_type<> {};
template<> struct def<Windows::Web::Http::HttpTransportInformation> : class_type<Platform::Object, Windows::Web::Http::IHttpTransportInformation, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Web::Http::IHttpStringContentFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::HttpStringContent> : class_type<Platform::Object, Windows::Web::Http::IHttpContent, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::IHttpBufferContentFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::HttpBufferContent> : class_type<Platform::Object, Windows::Web::Http::IHttpContent, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::IHttpStreamContentFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::HttpStreamContent> : class_type<Platform::Object, Windows::Web::Http::IHttpContent, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::IHttpFormUrlEncodedContentFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::HttpFormUrlEncodedContent> : class_type<Platform::Object, Windows::Web::Http::IHttpContent, Windows::Foundation::IStringable>, custom_activators {};
template<> struct def<Windows::Web::Http::IHttpMultipartContentFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::IHttpMultipartContent> : interface_type<Windows::Foundation::Collections::IIterable<ptr<Windows::Web::Http::IHttpContent>>> {};
template<> struct def<Windows::Web::Http::HttpMultipartContent> : class_type<Platform::Object, Windows::Web::Http::IHttpContent, Windows::Foundation::IStringable, Windows::Web::Http::IHttpMultipartContent>, custom_activators {};
template<> struct def<Windows::Web::Http::IHttpMultipartFormDataContentFactory> : interface_type<> {};
template<> struct def<Windows::Web::Http::IHttpMultipartFormDataContent> : interface_type<Windows::Foundation::Collections::IIterable<ptr<Windows::Web::Http::IHttpContent>>> {};
template<> struct def<Windows::Web::Http::HttpMultipartFormDataContent> : class_type<Platform::Object, Windows::Web::Http::IHttpContent, Windows::Foundation::IStringable, Windows::Web::Http::IHttpMultipartFormDataContent>, custom_activators {};
template<> struct def<Windows::Web::Http::HttpCookieManager> : class_type<Platform::Object, Windows::Web::Http::IHttpCookieManager> {};

// uuids

template<> struct uuid<Windows::Web::Http::IHttpClientFactory> { define_guid(0xC30C4ECA, 0xE3FA, 0x4F99, 0xAF, 0xB4, 0x63, 0xCC, 0x65, 0x0, 0x94, 0x62);};
template<> struct uuid<Windows::Web::Http::IHttpRequestMessageFactory> { define_guid(0x5BAC994E, 0x3886, 0x412E, 0xAE, 0xC3, 0x52, 0xEC, 0x7F, 0x25, 0x61, 0x6F);};
template<> struct uuid<Windows::Web::Http::IHttpRequestMessage> { define_guid(0xF5762B3C, 0x74D4, 0x4811, 0xB5, 0xDC, 0x9F, 0x8B, 0x4E, 0x2F, 0x9A, 0xBF);};
template<> struct uuid<Windows::Web::Http::IHttpResponseMessageFactory> { define_guid(0x52A8AF99, 0xF095, 0x43DA, 0xB6, 0xF, 0x7C, 0xFC, 0x2B, 0xC7, 0xEA, 0x2F);};
template<> struct uuid<Windows::Web::Http::IHttpResponseMessage> { define_guid(0xFEE200FB, 0x8664, 0x44E0, 0x95, 0xD9, 0x42, 0x69, 0x61, 0x99, 0xBF, 0xFC);};
template<> struct uuid<Windows::Web::Http::IHttpClient> { define_guid(0x7FDA1151, 0x3574, 0x4880, 0xA8, 0xBA, 0xE6, 0xB1, 0xE0, 0x6, 0x1F, 0x3D);};
template<> struct uuid<Windows::Web::Http::IHttpContent> { define_guid(0x6B14A441, 0xFBA7, 0x4BD2, 0xAF, 0xA, 0x83, 0x9D, 0xE7, 0xC2, 0x95, 0xDA);};
template<> struct uuid<Windows::Web::Http::IHttpCookieManager> { define_guid(0x7A431780, 0xCD4F, 0x4E57, 0xA8, 0x4A, 0x5B, 0xA, 0x53, 0xD6, 0xBB, 0x96);};
template<> struct uuid<Windows::Web::Http::IHttpCookieFactory> { define_guid(0x6A0585A9, 0x931C, 0x4CD1, 0xA9, 0x6D, 0xC2, 0x17, 0x1, 0x78, 0x5C, 0x5F);};
template<> struct uuid<Windows::Web::Http::IHttpCookie> { define_guid(0x1F5488E2, 0xCC2D, 0x4779, 0x86, 0xA7, 0x88, 0xF1, 0x6, 0x87, 0xD2, 0x49);};
template<> struct uuid<Windows::Web::Http::IHttpMethodStatics> { define_guid(0x64D171F0, 0xD99A, 0x4153, 0x8D, 0xC6, 0xD6, 0x8C, 0xC4, 0xCC, 0xE3, 0x17);};
template<> struct uuid<Windows::Web::Http::IHttpMethodFactory> { define_guid(0x3C51D10D, 0x36D7, 0x40F8, 0xA8, 0x6D, 0xE7, 0x59, 0xCA, 0xF2, 0xF8, 0x3F);};
template<> struct uuid<Windows::Web::Http::IHttpMethod> { define_guid(0x728D4022, 0x700D, 0x4FE0, 0xAF, 0xA5, 0x40, 0x29, 0x9C, 0x58, 0xDB, 0xFD);};
template<> struct uuid<Windows::Web::Http::IHttpTransportInformation> { define_guid(0x70127198, 0xC6A7, 0x4ED0, 0x83, 0x3A, 0x83, 0xFD, 0x8B, 0x8F, 0x17, 0x8D);};
template<> struct uuid<Windows::Web::Http::IHttpStringContentFactory> { define_guid(0x46649D5B, 0x2E93, 0x48EB, 0x8E, 0x61, 0x19, 0x67, 0x78, 0x78, 0xE5, 0x7F);};
template<> struct uuid<Windows::Web::Http::IHttpBufferContentFactory> { define_guid(0xBC20C193, 0xC41F, 0x4FF7, 0x91, 0x23, 0x64, 0x35, 0x73, 0x6E, 0xAD, 0xC2);};
template<> struct uuid<Windows::Web::Http::IHttpStreamContentFactory> { define_guid(0xF3E64D9D, 0xF725, 0x407E, 0x94, 0x2F, 0xE, 0xDA, 0x18, 0x98, 0x9, 0xF4);};
template<> struct uuid<Windows::Web::Http::IHttpFormUrlEncodedContentFactory> { define_guid(0x43F0138C, 0x2F73, 0x4302, 0xB5, 0xF3, 0xEA, 0xE9, 0x23, 0x8A, 0x5E, 0x1);};
template<> struct uuid<Windows::Web::Http::IHttpMultipartContentFactory> { define_guid(0x7EB42E62, 0x222, 0x4F20, 0xB3, 0x72, 0x47, 0xD5, 0xDB, 0x5D, 0x33, 0xB4);};
template<> struct uuid<Windows::Web::Http::IHttpMultipartContent> { define_guid(0xDF916AFF, 0x9926, 0x4AC9, 0xAA, 0xF1, 0xE0, 0xD0, 0x4E, 0xF0, 0x9B, 0xB9);};
template<> struct uuid<Windows::Web::Http::IHttpMultipartFormDataContentFactory> { define_guid(0xA04D7311, 0x5017, 0x4622, 0x93, 0xA8, 0x49, 0xB2, 0x4A, 0x4F, 0xCB, 0xFC);};
template<> struct uuid<Windows::Web::Http::IHttpMultipartFormDataContent> { define_guid(0x64D337E2, 0xE967, 0x4624, 0xB6, 0xD1, 0xCF, 0x74, 0x60, 0x4A, 0x4A, 0x42);};

// types

namespace Windows { namespace Web { namespace Http {

// IHttpClientFactory
struct IHttpClientFactory : IInspectable {
	virtual STDMETHODIMP _Create(Filters::IHttpFilter* filter, HttpClient* *client);
};

// IHttpRequestMessageFactory
struct IHttpRequestMessageFactory : IInspectable {
	virtual STDMETHODIMP _Create(HttpMethod* method, Foundation::Uri* uri, HttpRequestMessage* *httpRequestMessage);
};

// IHttpRequestMessage
struct IHttpRequestMessage_raw : IInspectable {
	virtual STDMETHODIMP _get_Content(IHttpContent* *value);
	virtual STDMETHODIMP _put_Content(IHttpContent* value);
	virtual STDMETHODIMP _get_Headers(Headers::HttpRequestHeaderCollection* *value);
	virtual STDMETHODIMP _get_Method(HttpMethod* *value);
	virtual STDMETHODIMP _put_Method(HttpMethod* value);
	virtual STDMETHODIMP _get_Properties(Foundation::Collections::IMap<HSTRING, IInspectable*>* *value);
	virtual STDMETHODIMP _get_RequestUri(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_RequestUri(Foundation::Uri* value);
	virtual STDMETHODIMP _get_TransportInformation(HttpTransportInformation* *value);
};
template<typename X> struct IHttpRequestMessage_adaptor : X {
	union {
		struct : property {
			ptr<IHttpContent> get() { IHttpContent* value; hrcheck(enc(&IHttpRequestMessage_adaptor::Content)->_get_Content(&value)); return from_abi(value); }
			ptr<IHttpContent> operator()() { return get(); }
			operator ptr<IHttpContent> () { return get(); }
			ptr<IHttpContent> operator->() { return get(); }
			void put(pptr<IHttpContent> value) { hrcheck(enc(&IHttpRequestMessage_adaptor::Content)->_put_Content(value)); }
			void operator=(pptr<IHttpContent> value) { put(value); }
			void operator()(pptr<IHttpContent> value) { put(value); }
		} Content;
		struct : property {
			ptr<Headers::HttpRequestHeaderCollection> get() { Headers::HttpRequestHeaderCollection* value; hrcheck(enc(&IHttpRequestMessage_adaptor::Headers)->_get_Headers(&value)); return from_abi(value); }
			ptr<Headers::HttpRequestHeaderCollection> operator()() { return get(); }
			operator ptr<Headers::HttpRequestHeaderCollection> () { return get(); }
			ptr<Headers::HttpRequestHeaderCollection> operator->() { return get(); }
		} Headers;
		struct : property {
			ptr<HttpMethod> get() { HttpMethod* value; hrcheck(enc(&IHttpRequestMessage_adaptor::Method)->_get_Method(&value)); return from_abi(value); }
			ptr<HttpMethod> operator()() { return get(); }
			operator ptr<HttpMethod> () { return get(); }
			ptr<HttpMethod> operator->() { return get(); }
			void put(pptr<HttpMethod> value) { hrcheck(enc(&IHttpRequestMessage_adaptor::Method)->_put_Method(value)); }
			void operator=(pptr<HttpMethod> value) { put(value); }
			void operator()(pptr<HttpMethod> value) { put(value); }
		} Method;
		struct : property {
			ptr<Foundation::Collections::IMap<hstring, object>> get() { Foundation::Collections::IMap<HSTRING, IInspectable*>* value; hrcheck(enc(&IHttpRequestMessage_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMap<hstring, object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMap<hstring, object>> () { return get(); }
			ptr<Foundation::Collections::IMap<hstring, object>> operator->() { return get(); }
		} Properties;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IHttpRequestMessage_adaptor::RequestUri)->_get_RequestUri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IHttpRequestMessage_adaptor::RequestUri)->_put_RequestUri(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} RequestUri;
		struct : property {
			ptr<HttpTransportInformation> get() { HttpTransportInformation* value; hrcheck(enc(&IHttpRequestMessage_adaptor::TransportInformation)->_get_TransportInformation(&value)); return from_abi(value); }
			ptr<HttpTransportInformation> operator()() { return get(); }
			operator ptr<HttpTransportInformation> () { return get(); }
			ptr<HttpTransportInformation> operator->() { return get(); }
		} TransportInformation;
	};
	IHttpRequestMessage_adaptor() {}
};
template<typename X> struct adapt<IHttpRequestMessage, X> : Windows::Web::Http::IHttpRequestMessage_adaptor<X> { typedef adapt IHttpRequestMessage; };
struct IHttpRequestMessage : IHttpRequestMessage_raw, generate<IHttpRequestMessage> {};

// HttpRequestMessage
template<typename> struct HttpRequestMessage_statics {
	static HttpRequestMessage *activate() { HttpRequestMessage *t; get_activation_factory<HttpRequestMessage>()->ActivateInstance((IInspectable**)&t); return t; }
	static HttpRequestMessage *activate(pptr<HttpMethod> method, pptr<Foundation::Uri> uri) { HttpRequestMessage *httpRequestMessage; hrcheck(get_activation_factory<HttpRequestMessage, IHttpRequestMessageFactory>()->_Create(method, uri, &httpRequestMessage)); return httpRequestMessage; }
};

template<typename X> struct statics<HttpRequestMessage, X> : X, Windows::Web::Http::HttpRequestMessage_statics<void> {
	using Windows::Web::Http::HttpRequestMessage_statics<void>::activate;
	typedef typename X::root_type HttpRequestMessage;
};
struct HttpRequestMessage : generate<HttpRequestMessage> {};

// IHttpResponseMessageFactory
struct IHttpResponseMessageFactory : IInspectable {
	virtual STDMETHODIMP _Create(HttpStatusCode statusCode, HttpResponseMessage* *httpResponseMessage);
};

// IHttpResponseMessage
struct IHttpResponseMessage_raw : IInspectable {
	virtual STDMETHODIMP _get_Content(IHttpContent* *value);
	virtual STDMETHODIMP _put_Content(IHttpContent* value);
	virtual STDMETHODIMP _get_Headers(Headers::HttpResponseHeaderCollection* *value);
	virtual STDMETHODIMP _get_IsSuccessStatusCode(bool *value);
	virtual STDMETHODIMP _get_ReasonPhrase(HSTRING *value);
	virtual STDMETHODIMP _put_ReasonPhrase(HSTRING value);
	virtual STDMETHODIMP _get_RequestMessage(HttpRequestMessage* *value);
	virtual STDMETHODIMP _put_RequestMessage(HttpRequestMessage* value);
	virtual STDMETHODIMP _get_Source(HttpResponseMessageSource *value);
	virtual STDMETHODIMP _put_Source(HttpResponseMessageSource value);
	virtual STDMETHODIMP _get_StatusCode(HttpStatusCode *value);
	virtual STDMETHODIMP _put_StatusCode(HttpStatusCode value);
	virtual STDMETHODIMP _get_Version(HttpVersion *value);
	virtual STDMETHODIMP _put_Version(HttpVersion value);
	virtual STDMETHODIMP _EnsureSuccessStatusCode(HttpResponseMessage* *httpResponseMessage);
};
template<typename X> struct IHttpResponseMessage_adaptor : X {
	union {
		struct : property {
			ptr<IHttpContent> get() { IHttpContent* value; hrcheck(enc(&IHttpResponseMessage_adaptor::Content)->_get_Content(&value)); return from_abi(value); }
			ptr<IHttpContent> operator()() { return get(); }
			operator ptr<IHttpContent> () { return get(); }
			ptr<IHttpContent> operator->() { return get(); }
			void put(pptr<IHttpContent> value) { hrcheck(enc(&IHttpResponseMessage_adaptor::Content)->_put_Content(value)); }
			void operator=(pptr<IHttpContent> value) { put(value); }
			void operator()(pptr<IHttpContent> value) { put(value); }
		} Content;
		struct : property {
			ptr<Headers::HttpResponseHeaderCollection> get() { Headers::HttpResponseHeaderCollection* value; hrcheck(enc(&IHttpResponseMessage_adaptor::Headers)->_get_Headers(&value)); return from_abi(value); }
			ptr<Headers::HttpResponseHeaderCollection> operator()() { return get(); }
			operator ptr<Headers::HttpResponseHeaderCollection> () { return get(); }
			ptr<Headers::HttpResponseHeaderCollection> operator->() { return get(); }
		} Headers;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IHttpResponseMessage_adaptor::IsSuccessStatusCode)->_get_IsSuccessStatusCode(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsSuccessStatusCode;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpResponseMessage_adaptor::ReasonPhrase)->_get_ReasonPhrase(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IHttpResponseMessage_adaptor::ReasonPhrase)->_put_ReasonPhrase(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ReasonPhrase;
		struct : property {
			ptr<HttpRequestMessage> get() { HttpRequestMessage* value; hrcheck(enc(&IHttpResponseMessage_adaptor::RequestMessage)->_get_RequestMessage(&value)); return from_abi(value); }
			ptr<HttpRequestMessage> operator()() { return get(); }
			operator ptr<HttpRequestMessage> () { return get(); }
			ptr<HttpRequestMessage> operator->() { return get(); }
			void put(pptr<HttpRequestMessage> value) { hrcheck(enc(&IHttpResponseMessage_adaptor::RequestMessage)->_put_RequestMessage(value)); }
			void operator=(pptr<HttpRequestMessage> value) { put(value); }
			void operator()(pptr<HttpRequestMessage> value) { put(value); }
		} RequestMessage;
		struct : property {
			HttpResponseMessageSource get() { HttpResponseMessageSource value; hrcheck(enc(&IHttpResponseMessage_adaptor::Source)->_get_Source(&value)); return value; }
			HttpResponseMessageSource operator()() { return get(); }
			operator HttpResponseMessageSource () { return get(); }
			void put(HttpResponseMessageSource value) { hrcheck(enc(&IHttpResponseMessage_adaptor::Source)->_put_Source(value)); }
			void operator=(HttpResponseMessageSource value) { put(value); }
			void operator()(HttpResponseMessageSource value) { put(value); }
		} Source;
		struct : property {
			HttpStatusCode get() { HttpStatusCode value; hrcheck(enc(&IHttpResponseMessage_adaptor::StatusCode)->_get_StatusCode(&value)); return value; }
			HttpStatusCode operator()() { return get(); }
			operator HttpStatusCode () { return get(); }
			void put(HttpStatusCode value) { hrcheck(enc(&IHttpResponseMessage_adaptor::StatusCode)->_put_StatusCode(value)); }
			void operator=(HttpStatusCode value) { put(value); }
			void operator()(HttpStatusCode value) { put(value); }
		} StatusCode;
		struct : property {
			HttpVersion get() { HttpVersion value; hrcheck(enc(&IHttpResponseMessage_adaptor::Version)->_get_Version(&value)); return value; }
			HttpVersion operator()() { return get(); }
			operator HttpVersion () { return get(); }
			void put(HttpVersion value) { hrcheck(enc(&IHttpResponseMessage_adaptor::Version)->_put_Version(value)); }
			void operator=(HttpVersion value) { put(value); }
			void operator()(HttpVersion value) { put(value); }
		} Version;
	};
	ptr<HttpResponseMessage> EnsureSuccessStatusCode() { HttpResponseMessage* httpResponseMessage; hrcheck(X::get()->_EnsureSuccessStatusCode(&httpResponseMessage)); return from_abi(httpResponseMessage); }
	IHttpResponseMessage_adaptor() {}
};
template<typename X> struct adapt<IHttpResponseMessage, X> : Windows::Web::Http::IHttpResponseMessage_adaptor<X> { typedef adapt IHttpResponseMessage; };
struct IHttpResponseMessage : IHttpResponseMessage_raw, generate<IHttpResponseMessage> {};

// HttpResponseMessage
template<typename> struct HttpResponseMessage_statics {
	static HttpResponseMessage *activate(HttpStatusCode statusCode) { HttpResponseMessage *httpResponseMessage; hrcheck(get_activation_factory<HttpResponseMessage, IHttpResponseMessageFactory>()->_Create(statusCode, &httpResponseMessage)); return httpResponseMessage; }
	static HttpResponseMessage *activate() { HttpResponseMessage *t; get_activation_factory<HttpResponseMessage>()->ActivateInstance((IInspectable**)&t); return t; }
};

template<typename X> struct statics<HttpResponseMessage, X> : X, Windows::Web::Http::HttpResponseMessage_statics<void> {
	using Windows::Web::Http::HttpResponseMessage_statics<void>::activate;
	typedef typename X::root_type HttpResponseMessage;
};
struct HttpResponseMessage : generate<HttpResponseMessage> {};

// IHttpClient
struct IHttpClient_raw : IInspectable {
	virtual STDMETHODIMP _DeleteAsync(Foundation::Uri* uri, Foundation::IAsyncOperationWithProgress<HttpResponseMessage*, HttpProgress>* *operation);
	virtual STDMETHODIMP _GetAsync(Foundation::Uri* uri, Foundation::IAsyncOperationWithProgress<HttpResponseMessage*, HttpProgress>* *operation);
	virtual STDMETHODIMP _GetWithOptionAsync(Foundation::Uri* uri, HttpCompletionOption completionOption, Foundation::IAsyncOperationWithProgress<HttpResponseMessage*, HttpProgress>* *operation);
	virtual STDMETHODIMP _GetBufferAsync(Foundation::Uri* uri, Foundation::IAsyncOperationWithProgress<Storage::Streams::IBuffer*, HttpProgress>* *operation);
	virtual STDMETHODIMP _GetInputStreamAsync(Foundation::Uri* uri, Foundation::IAsyncOperationWithProgress<Storage::Streams::IInputStream*, HttpProgress>* *operation);
	virtual STDMETHODIMP _GetStringAsync(Foundation::Uri* uri, Foundation::IAsyncOperationWithProgress<HSTRING, HttpProgress>* *operation);
	virtual STDMETHODIMP _PostAsync(Foundation::Uri* uri, IHttpContent* content, Foundation::IAsyncOperationWithProgress<HttpResponseMessage*, HttpProgress>* *operation);
	virtual STDMETHODIMP _PutAsync(Foundation::Uri* uri, IHttpContent* content, Foundation::IAsyncOperationWithProgress<HttpResponseMessage*, HttpProgress>* *operation);
	virtual STDMETHODIMP _SendRequestAsync(HttpRequestMessage* request, Foundation::IAsyncOperationWithProgress<HttpResponseMessage*, HttpProgress>* *operation);
	virtual STDMETHODIMP _SendRequestWithOptionAsync(HttpRequestMessage* request, HttpCompletionOption completionOption, Foundation::IAsyncOperationWithProgress<HttpResponseMessage*, HttpProgress>* *operation);
	virtual STDMETHODIMP _get_DefaultRequestHeaders(Headers::HttpRequestHeaderCollection* *value);
};
template<typename X> struct IHttpClient_adaptor : X {
	union {
		struct : property {
			ptr<Headers::HttpRequestHeaderCollection> get() { Headers::HttpRequestHeaderCollection* value; hrcheck(enc(&IHttpClient_adaptor::DefaultRequestHeaders)->_get_DefaultRequestHeaders(&value)); return from_abi(value); }
			ptr<Headers::HttpRequestHeaderCollection> operator()() { return get(); }
			operator ptr<Headers::HttpRequestHeaderCollection> () { return get(); }
			ptr<Headers::HttpRequestHeaderCollection> operator->() { return get(); }
		} DefaultRequestHeaders;
	};
	ptr<Foundation::IAsyncOperationWithProgress<ptr<HttpResponseMessage>, HttpProgress>> DeleteAsync(pptr<Foundation::Uri> uri) { Foundation::IAsyncOperationWithProgress<HttpResponseMessage*, HttpProgress>* operation; hrcheck(X::get()->_DeleteAsync(uri, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<HttpResponseMessage>, HttpProgress>> GetAsync(pptr<Foundation::Uri> uri) { Foundation::IAsyncOperationWithProgress<HttpResponseMessage*, HttpProgress>* operation; hrcheck(X::get()->_GetAsync(uri, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<HttpResponseMessage>, HttpProgress>> GetAsync(pptr<Foundation::Uri> uri, HttpCompletionOption completionOption) { Foundation::IAsyncOperationWithProgress<HttpResponseMessage*, HttpProgress>* operation; hrcheck(X::get()->_GetWithOptionAsync(uri, completionOption, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<Storage::Streams::IBuffer>, HttpProgress>> GetBufferAsync(pptr<Foundation::Uri> uri) { Foundation::IAsyncOperationWithProgress<Storage::Streams::IBuffer*, HttpProgress>* operation; hrcheck(X::get()->_GetBufferAsync(uri, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<Storage::Streams::IInputStream>, HttpProgress>> GetInputStreamAsync(pptr<Foundation::Uri> uri) { Foundation::IAsyncOperationWithProgress<Storage::Streams::IInputStream*, HttpProgress>* operation; hrcheck(X::get()->_GetInputStreamAsync(uri, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<hstring, HttpProgress>> GetStringAsync(pptr<Foundation::Uri> uri) { Foundation::IAsyncOperationWithProgress<HSTRING, HttpProgress>* operation; hrcheck(X::get()->_GetStringAsync(uri, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<HttpResponseMessage>, HttpProgress>> PostAsync(pptr<Foundation::Uri> uri, pptr<IHttpContent> content) { Foundation::IAsyncOperationWithProgress<HttpResponseMessage*, HttpProgress>* operation; hrcheck(X::get()->_PostAsync(uri, content, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<HttpResponseMessage>, HttpProgress>> PutAsync(pptr<Foundation::Uri> uri, pptr<IHttpContent> content) { Foundation::IAsyncOperationWithProgress<HttpResponseMessage*, HttpProgress>* operation; hrcheck(X::get()->_PutAsync(uri, content, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<HttpResponseMessage>, HttpProgress>> SendRequestAsync(pptr<HttpRequestMessage> request) { Foundation::IAsyncOperationWithProgress<HttpResponseMessage*, HttpProgress>* operation; hrcheck(X::get()->_SendRequestAsync(request, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<HttpResponseMessage>, HttpProgress>> SendRequestAsync(pptr<HttpRequestMessage> request, HttpCompletionOption completionOption) { Foundation::IAsyncOperationWithProgress<HttpResponseMessage*, HttpProgress>* operation; hrcheck(X::get()->_SendRequestWithOptionAsync(request, completionOption, &operation)); return from_abi(operation); }
	IHttpClient_adaptor() {}
};
template<typename X> struct adapt<IHttpClient, X> : Windows::Web::Http::IHttpClient_adaptor<X> { typedef adapt IHttpClient; };
struct IHttpClient : IHttpClient_raw, generate<IHttpClient> {};

// HttpClient
template<typename> struct HttpClient_statics {
	static HttpClient *activate() { HttpClient *t; get_activation_factory<HttpClient>()->ActivateInstance((IInspectable**)&t); return t; }
	static HttpClient *activate(pptr<Filters::IHttpFilter> filter) { HttpClient *client; hrcheck(get_activation_factory<HttpClient, IHttpClientFactory>()->_Create(filter, &client)); return client; }
};

template<typename X> struct statics<HttpClient, X> : X, Windows::Web::Http::HttpClient_statics<void> {
	using Windows::Web::Http::HttpClient_statics<void>::activate;
	typedef typename X::root_type HttpClient;
};
struct HttpClient : generate<HttpClient> {
	using IHttpClient::GetAsync;
	using IHttpClient::SendRequestAsync;
};

// IHttpContent
struct IHttpContent_raw : IInspectable {
	virtual STDMETHODIMP _get_Headers(Headers::HttpContentHeaderCollection* *value) = 0;
	virtual STDMETHODIMP _BufferAllAsync(Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>* *operation) = 0;
	virtual STDMETHODIMP _ReadAsBufferAsync(Foundation::IAsyncOperationWithProgress<Storage::Streams::IBuffer*, unsigned __int64>* *operation) = 0;
	virtual STDMETHODIMP _ReadAsInputStreamAsync(Foundation::IAsyncOperationWithProgress<Storage::Streams::IInputStream*, unsigned __int64>* *operation) = 0;
	virtual STDMETHODIMP _ReadAsStringAsync(Foundation::IAsyncOperationWithProgress<HSTRING, unsigned __int64>* *operation) = 0;
	virtual STDMETHODIMP _TryComputeLength(unsigned __int64 *length, bool *succeeded) = 0;
	virtual STDMETHODIMP _WriteToStreamAsync(Storage::Streams::IOutputStream* outputStream, Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>* *operation) = 0;
};
template<typename X> struct IHttpContent_adaptor : X {
	union {
		struct : property {
			ptr<Headers::HttpContentHeaderCollection> get() { Headers::HttpContentHeaderCollection* value; hrcheck(enc(&IHttpContent_adaptor::Headers)->_get_Headers(&value)); return from_abi(value); }
			ptr<Headers::HttpContentHeaderCollection> operator()() { return get(); }
			operator ptr<Headers::HttpContentHeaderCollection> () { return get(); }
			ptr<Headers::HttpContentHeaderCollection> operator->() { return get(); }
		} Headers;
	};
	ptr<Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>> BufferAllAsync() { Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>* operation; hrcheck(X::get()->_BufferAllAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<Storage::Streams::IBuffer>, unsigned __int64>> ReadAsBufferAsync() { Foundation::IAsyncOperationWithProgress<Storage::Streams::IBuffer*, unsigned __int64>* operation; hrcheck(X::get()->_ReadAsBufferAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<Storage::Streams::IInputStream>, unsigned __int64>> ReadAsInputStreamAsync() { Foundation::IAsyncOperationWithProgress<Storage::Streams::IInputStream*, unsigned __int64>* operation; hrcheck(X::get()->_ReadAsInputStreamAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<hstring, unsigned __int64>> ReadAsStringAsync() { Foundation::IAsyncOperationWithProgress<HSTRING, unsigned __int64>* operation; hrcheck(X::get()->_ReadAsStringAsync(&operation)); return from_abi(operation); }
	bool TryComputeLength(unsigned __int64 *length) { bool succeeded; hrcheck(X::get()->_TryComputeLength(length, &succeeded)); return succeeded; }
	ptr<Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>> WriteToStreamAsync(pptr<Storage::Streams::IOutputStream> outputStream) { Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>* operation; hrcheck(X::get()->_WriteToStreamAsync(outputStream, &operation)); return from_abi(operation); }
	IHttpContent_adaptor() {}
};
template<typename X> struct adapt<IHttpContent, X> : Windows::Web::Http::IHttpContent_adaptor<X> { typedef adapt IHttpContent; };
template<typename X> struct IHttpContent_unadaptor : X {
	STDMETHODIMP _get_Headers(Headers::HttpContentHeaderCollection* *value) { return hrtry([&, this] { get_prop(value, Headers); }); }
	STDMETHODIMP _BufferAllAsync(Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->BufferAllAsync()); }); }
	STDMETHODIMP _ReadAsBufferAsync(Foundation::IAsyncOperationWithProgress<Storage::Streams::IBuffer*, unsigned __int64>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->ReadAsBufferAsync()); }); }
	STDMETHODIMP _ReadAsInputStreamAsync(Foundation::IAsyncOperationWithProgress<Storage::Streams::IInputStream*, unsigned __int64>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->ReadAsInputStreamAsync()); }); }
	STDMETHODIMP _ReadAsStringAsync(Foundation::IAsyncOperationWithProgress<HSTRING, unsigned __int64>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->ReadAsStringAsync()); }); }
	STDMETHODIMP _TryComputeLength(unsigned __int64 *length, bool *succeeded) { return hrtry([&, this] { *succeeded = X::get()->TryComputeLength(length); }); }
	STDMETHODIMP _WriteToStreamAsync(Storage::Streams::IOutputStream* outputStream, Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->WriteToStreamAsync(outputStream)); }); }
};
template<typename X> struct unadapt<IHttpContent, X> : Windows::Web::Http::IHttpContent_unadaptor<X> {};
struct IHttpContent : IHttpContent_raw, generate<IHttpContent> {};

// IHttpCookieManager
struct IHttpCookieManager_raw : IInspectable {
	virtual STDMETHODIMP _SetCookie(HttpCookie* cookie, bool *replaced);
	virtual STDMETHODIMP _SetCookieWithThirdParty(HttpCookie* cookie, bool thirdParty, bool *replaced);
	virtual STDMETHODIMP _DeleteCookie(HttpCookie* cookie);
	virtual STDMETHODIMP _GetCookies(Foundation::Uri* uri, HttpCookieCollection* *value);
};
template<typename X> struct IHttpCookieManager_adaptor : X {
	bool SetCookie(pptr<HttpCookie> cookie) { bool replaced; hrcheck(X::get()->_SetCookie(cookie, &replaced)); return replaced; }
	bool SetCookie(pptr<HttpCookie> cookie, bool thirdParty) { bool replaced; hrcheck(X::get()->_SetCookieWithThirdParty(cookie, thirdParty, &replaced)); return replaced; }
	void DeleteCookie(pptr<HttpCookie> cookie) { hrcheck(X::get()->_DeleteCookie(cookie)); }
	ptr<HttpCookieCollection> GetCookies(pptr<Foundation::Uri> uri) { HttpCookieCollection* value; hrcheck(X::get()->_GetCookies(uri, &value)); return from_abi(value); }
};
template<typename X> struct adapt<IHttpCookieManager, X> : Windows::Web::Http::IHttpCookieManager_adaptor<X> { typedef adapt IHttpCookieManager; };
struct IHttpCookieManager : IHttpCookieManager_raw, generate<IHttpCookieManager> {};

// IHttpCookieFactory
struct IHttpCookieFactory : IInspectable {
	virtual STDMETHODIMP _Create(HSTRING name, HSTRING domain, HSTRING path, HttpCookie* *cookie);
};

// IHttpCookie
struct IHttpCookie_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_Domain(HSTRING *value);
	virtual STDMETHODIMP _get_Path(HSTRING *value);
	virtual STDMETHODIMP _get_Expires(Foundation::IReference<Foundation::DateTime>* *value);
	virtual STDMETHODIMP _put_Expires(Foundation::IReference<Foundation::DateTime>* value);
	virtual STDMETHODIMP _get_HttpOnly(bool *value);
	virtual STDMETHODIMP _put_HttpOnly(bool value);
	virtual STDMETHODIMP _get_Secure(bool *value);
	virtual STDMETHODIMP _put_Secure(bool value);
	virtual STDMETHODIMP _get_Value(HSTRING *value);
	virtual STDMETHODIMP _put_Value(HSTRING value);
};
template<typename X> struct IHttpCookie_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpCookie_adaptor::Domain)->_get_Domain(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Domain;
		struct : property {
			ptr<Foundation::IReference<Foundation::DateTime>> get() { Foundation::IReference<Foundation::DateTime>* value; hrcheck(enc(&IHttpCookie_adaptor::Expires)->_get_Expires(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::DateTime>> value) { hrcheck(enc(&IHttpCookie_adaptor::Expires)->_put_Expires(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
		} Expires;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IHttpCookie_adaptor::HttpOnly)->_get_HttpOnly(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IHttpCookie_adaptor::HttpOnly)->_put_HttpOnly(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} HttpOnly;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpCookie_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpCookie_adaptor::Path)->_get_Path(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Path;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IHttpCookie_adaptor::Secure)->_get_Secure(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IHttpCookie_adaptor::Secure)->_put_Secure(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Secure;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpCookie_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IHttpCookie_adaptor::Value)->_put_Value(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Value;
	};
	IHttpCookie_adaptor() {}
};
template<typename X> struct adapt<IHttpCookie, X> : Windows::Web::Http::IHttpCookie_adaptor<X> { typedef adapt IHttpCookie; };
struct IHttpCookie : IHttpCookie_raw, generate<IHttpCookie> {};

// HttpCookie
template<typename> struct HttpCookie_statics {
	static HttpCookie *activate(hstring_ref name, hstring_ref domain, hstring_ref path) { HttpCookie *cookie; hrcheck(get_activation_factory<HttpCookie, IHttpCookieFactory>()->_Create(name, domain, path, &cookie)); return cookie; }
};

template<typename X> struct statics<HttpCookie, X> : X, Windows::Web::Http::HttpCookie_statics<void> {
	using Windows::Web::Http::HttpCookie_statics<void>::activate;
	typedef typename X::root_type HttpCookie;
};
struct HttpCookie : generate<HttpCookie> {};

// HttpCookieCollection
template<typename X> struct statics<HttpCookieCollection, X> : X {
	typedef typename X::root_type HttpCookieCollection;
};
struct HttpCookieCollection : generate<HttpCookieCollection> {};

// IHttpMethodStatics
struct IHttpMethodStatics : IInspectable {
	virtual STDMETHODIMP _get_Delete(HttpMethod* *value);
	virtual STDMETHODIMP _get_Get(HttpMethod* *value);
	virtual STDMETHODIMP _get_Head(HttpMethod* *value);
	virtual STDMETHODIMP _get_Options(HttpMethod* *value);
	virtual STDMETHODIMP _get_Patch(HttpMethod* *value);
	virtual STDMETHODIMP _get_Post(HttpMethod* *value);
	virtual STDMETHODIMP _get_Put(HttpMethod* *value);
};

// IHttpMethodFactory
struct IHttpMethodFactory : IInspectable {
	virtual STDMETHODIMP _Create(HSTRING method, HttpMethod* *httpMethod);
};

// IHttpMethod
struct IHttpMethod_raw : IInspectable {
	virtual STDMETHODIMP _get_Method(HSTRING *value);
};
template<typename X> struct IHttpMethod_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHttpMethod_adaptor::Method)->_get_Method(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Method;
	};
	IHttpMethod_adaptor() {}
};
template<typename X> struct adapt<IHttpMethod, X> : Windows::Web::Http::IHttpMethod_adaptor<X> { typedef adapt IHttpMethod; };
struct IHttpMethod : IHttpMethod_raw, generate<IHttpMethod> {};

// HttpMethod
template<typename> struct HttpMethod_statics {
	static struct _Delete : property {
		ptr<HttpMethod> get() { HttpMethod* value; hrcheck(get_activation_factory<HttpMethod, IHttpMethodStatics>()->_get_Delete(&value)); return from_abi(value); }
		ptr<HttpMethod> operator()() { return get(); }
		operator ptr<HttpMethod> () { return get(); }
		ptr<HttpMethod> operator->() { return get(); }
	} Delete;
	static struct _Get : property {
		ptr<HttpMethod> get() { HttpMethod* value; hrcheck(get_activation_factory<HttpMethod, IHttpMethodStatics>()->_get_Get(&value)); return from_abi(value); }
		ptr<HttpMethod> operator()() { return get(); }
		operator ptr<HttpMethod> () { return get(); }
		ptr<HttpMethod> operator->() { return get(); }
	} Get;
	static struct _Head : property {
		ptr<HttpMethod> get() { HttpMethod* value; hrcheck(get_activation_factory<HttpMethod, IHttpMethodStatics>()->_get_Head(&value)); return from_abi(value); }
		ptr<HttpMethod> operator()() { return get(); }
		operator ptr<HttpMethod> () { return get(); }
		ptr<HttpMethod> operator->() { return get(); }
	} Head;
	static struct _Options : property {
		ptr<HttpMethod> get() { HttpMethod* value; hrcheck(get_activation_factory<HttpMethod, IHttpMethodStatics>()->_get_Options(&value)); return from_abi(value); }
		ptr<HttpMethod> operator()() { return get(); }
		operator ptr<HttpMethod> () { return get(); }
		ptr<HttpMethod> operator->() { return get(); }
	} Options;
	static struct _Patch : property {
		ptr<HttpMethod> get() { HttpMethod* value; hrcheck(get_activation_factory<HttpMethod, IHttpMethodStatics>()->_get_Patch(&value)); return from_abi(value); }
		ptr<HttpMethod> operator()() { return get(); }
		operator ptr<HttpMethod> () { return get(); }
		ptr<HttpMethod> operator->() { return get(); }
	} Patch;
	static struct _Post : property {
		ptr<HttpMethod> get() { HttpMethod* value; hrcheck(get_activation_factory<HttpMethod, IHttpMethodStatics>()->_get_Post(&value)); return from_abi(value); }
		ptr<HttpMethod> operator()() { return get(); }
		operator ptr<HttpMethod> () { return get(); }
		ptr<HttpMethod> operator->() { return get(); }
	} Post;
	static struct _Put : property {
		ptr<HttpMethod> get() { HttpMethod* value; hrcheck(get_activation_factory<HttpMethod, IHttpMethodStatics>()->_get_Put(&value)); return from_abi(value); }
		ptr<HttpMethod> operator()() { return get(); }
		operator ptr<HttpMethod> () { return get(); }
		ptr<HttpMethod> operator->() { return get(); }
	} Put;
	static HttpMethod *activate(hstring_ref method) { HttpMethod *httpMethod; hrcheck(get_activation_factory<HttpMethod, IHttpMethodFactory>()->_Create(method, &httpMethod)); return httpMethod; }
};
template<typename X> typename HttpMethod_statics<X>::_Delete HttpMethod_statics<X>::Delete;
template<typename X> typename HttpMethod_statics<X>::_Get HttpMethod_statics<X>::Get;
template<typename X> typename HttpMethod_statics<X>::_Head HttpMethod_statics<X>::Head;
template<typename X> typename HttpMethod_statics<X>::_Options HttpMethod_statics<X>::Options;
template<typename X> typename HttpMethod_statics<X>::_Patch HttpMethod_statics<X>::Patch;
template<typename X> typename HttpMethod_statics<X>::_Post HttpMethod_statics<X>::Post;
template<typename X> typename HttpMethod_statics<X>::_Put HttpMethod_statics<X>::Put;

template<typename X> struct statics<HttpMethod, X> : X, Windows::Web::Http::HttpMethod_statics<void> {
	using Windows::Web::Http::HttpMethod_statics<void>::activate;
	typedef typename X::root_type HttpMethod;
};
struct HttpMethod : generate<HttpMethod> {};

// IHttpTransportInformation
struct IHttpTransportInformation_raw : IInspectable {
	virtual STDMETHODIMP _get_ServerCertificate(Security::Cryptography::Certificates::Certificate* *value);
	virtual STDMETHODIMP _get_ServerCertificateErrorSeverity(Networking::Sockets::SocketSslErrorSeverity *value);
	virtual STDMETHODIMP _get_ServerCertificateErrors(Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>* *value);
	virtual STDMETHODIMP _get_ServerIntermediateCertificates(Foundation::Collections::IVectorView<Security::Cryptography::Certificates::Certificate*>* *value);
};
template<typename X> struct IHttpTransportInformation_adaptor : X {
	union {
		struct : property {
			ptr<Security::Cryptography::Certificates::Certificate> get() { Security::Cryptography::Certificates::Certificate* value; hrcheck(enc(&IHttpTransportInformation_adaptor::ServerCertificate)->_get_ServerCertificate(&value)); return from_abi(value); }
			ptr<Security::Cryptography::Certificates::Certificate> operator()() { return get(); }
			operator ptr<Security::Cryptography::Certificates::Certificate> () { return get(); }
			ptr<Security::Cryptography::Certificates::Certificate> operator->() { return get(); }
		} ServerCertificate;
		struct : property {
			Networking::Sockets::SocketSslErrorSeverity get() { Networking::Sockets::SocketSslErrorSeverity value; hrcheck(enc(&IHttpTransportInformation_adaptor::ServerCertificateErrorSeverity)->_get_ServerCertificateErrorSeverity(&value)); return value; }
			Networking::Sockets::SocketSslErrorSeverity operator()() { return get(); }
			operator Networking::Sockets::SocketSslErrorSeverity () { return get(); }
		} ServerCertificateErrorSeverity;
		struct : property {
			ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> get() { Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>* value; hrcheck(enc(&IHttpTransportInformation_adaptor::ServerCertificateErrors)->_get_ServerCertificateErrors(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> operator->() { return get(); }
		} ServerCertificateErrors;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> get() { Foundation::Collections::IVectorView<Security::Cryptography::Certificates::Certificate*>* value; hrcheck(enc(&IHttpTransportInformation_adaptor::ServerIntermediateCertificates)->_get_ServerIntermediateCertificates(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> operator->() { return get(); }
		} ServerIntermediateCertificates;
	};
	IHttpTransportInformation_adaptor() {}
};
template<typename X> struct adapt<IHttpTransportInformation, X> : Windows::Web::Http::IHttpTransportInformation_adaptor<X> { typedef adapt IHttpTransportInformation; };
struct IHttpTransportInformation : IHttpTransportInformation_raw, generate<IHttpTransportInformation> {};

// HttpTransportInformation
template<typename X> struct statics<HttpTransportInformation, X> : X {
	typedef typename X::root_type HttpTransportInformation;
};
struct HttpTransportInformation : generate<HttpTransportInformation> {};

// IHttpStringContentFactory
struct IHttpStringContentFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromString(HSTRING content, HttpStringContent* *stringContent);
	virtual STDMETHODIMP _CreateFromStringWithEncoding(HSTRING content, Storage::Streams::UnicodeEncoding encoding, HttpStringContent* *stringContent);
	virtual STDMETHODIMP _CreateFromStringWithEncodingAndMediaType(HSTRING content, Storage::Streams::UnicodeEncoding encoding, HSTRING mediaType, HttpStringContent* *stringContent);
};

// HttpStringContent
template<typename> struct HttpStringContent_statics {
	static HttpStringContent *activate(hstring_ref content) { HttpStringContent *stringContent; hrcheck(get_activation_factory<HttpStringContent, IHttpStringContentFactory>()->_CreateFromString(content, &stringContent)); return stringContent; }
	static HttpStringContent *activate(hstring_ref content, Storage::Streams::UnicodeEncoding encoding) { HttpStringContent *stringContent; hrcheck(get_activation_factory<HttpStringContent, IHttpStringContentFactory>()->_CreateFromStringWithEncoding(content, encoding, &stringContent)); return stringContent; }
	static HttpStringContent *activate(hstring_ref content, Storage::Streams::UnicodeEncoding encoding, hstring_ref mediaType) { HttpStringContent *stringContent; hrcheck(get_activation_factory<HttpStringContent, IHttpStringContentFactory>()->_CreateFromStringWithEncodingAndMediaType(content, encoding, mediaType, &stringContent)); return stringContent; }
};

template<typename X> struct statics<HttpStringContent, X> : X, Windows::Web::Http::HttpStringContent_statics<void> {
	using Windows::Web::Http::HttpStringContent_statics<void>::activate;
	typedef typename X::root_type HttpStringContent;
};
struct HttpStringContent : generate<HttpStringContent> {};

// IHttpBufferContentFactory
struct IHttpBufferContentFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromBuffer(Storage::Streams::IBuffer* content, HttpBufferContent* *bufferContent);
	virtual STDMETHODIMP _CreateFromBufferWithOffset(Storage::Streams::IBuffer* content, unsigned offset, unsigned count, HttpBufferContent* *bufferContent);
};

// HttpBufferContent
template<typename> struct HttpBufferContent_statics {
	static HttpBufferContent *activate(pptr<Storage::Streams::IBuffer> content) { HttpBufferContent *bufferContent; hrcheck(get_activation_factory<HttpBufferContent, IHttpBufferContentFactory>()->_CreateFromBuffer(content, &bufferContent)); return bufferContent; }
	static HttpBufferContent *activate(pptr<Storage::Streams::IBuffer> content, unsigned offset, unsigned count) { HttpBufferContent *bufferContent; hrcheck(get_activation_factory<HttpBufferContent, IHttpBufferContentFactory>()->_CreateFromBufferWithOffset(content, offset, count, &bufferContent)); return bufferContent; }
};

template<typename X> struct statics<HttpBufferContent, X> : X, Windows::Web::Http::HttpBufferContent_statics<void> {
	using Windows::Web::Http::HttpBufferContent_statics<void>::activate;
	typedef typename X::root_type HttpBufferContent;
};
struct HttpBufferContent : generate<HttpBufferContent> {};

// IHttpStreamContentFactory
struct IHttpStreamContentFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromInputStream(Storage::Streams::IInputStream* content, HttpStreamContent* *streamContent);
};

// HttpStreamContent
template<typename> struct HttpStreamContent_statics {
	static HttpStreamContent *activate(pptr<Storage::Streams::IInputStream> content) { HttpStreamContent *streamContent; hrcheck(get_activation_factory<HttpStreamContent, IHttpStreamContentFactory>()->_CreateFromInputStream(content, &streamContent)); return streamContent; }
};

template<typename X> struct statics<HttpStreamContent, X> : X, Windows::Web::Http::HttpStreamContent_statics<void> {
	using Windows::Web::Http::HttpStreamContent_statics<void>::activate;
	typedef typename X::root_type HttpStreamContent;
};
struct HttpStreamContent : generate<HttpStreamContent> {};

// IHttpFormUrlEncodedContentFactory
struct IHttpFormUrlEncodedContentFactory : IInspectable {
	virtual STDMETHODIMP _Create(Foundation::Collections::IIterable<Foundation::Collections::IKeyValuePair<HSTRING, HSTRING>*>* content, HttpFormUrlEncodedContent* *formUrlEncodedContent);
};

// HttpFormUrlEncodedContent
template<typename> struct HttpFormUrlEncodedContent_statics {
	static HttpFormUrlEncodedContent *activate(pptr<Foundation::Collections::IIterable<ptr<Foundation::Collections::IKeyValuePair<hstring, hstring>>>> content) { HttpFormUrlEncodedContent *formUrlEncodedContent; hrcheck(get_activation_factory<HttpFormUrlEncodedContent, IHttpFormUrlEncodedContentFactory>()->_Create(to_abi(content), &formUrlEncodedContent)); return formUrlEncodedContent; }
};

template<typename X> struct statics<HttpFormUrlEncodedContent, X> : X, Windows::Web::Http::HttpFormUrlEncodedContent_statics<void> {
	using Windows::Web::Http::HttpFormUrlEncodedContent_statics<void>::activate;
	typedef typename X::root_type HttpFormUrlEncodedContent;
};
struct HttpFormUrlEncodedContent : generate<HttpFormUrlEncodedContent> {};

// IHttpMultipartContentFactory
struct IHttpMultipartContentFactory : IInspectable {
	virtual STDMETHODIMP _CreateWithSubtype(HSTRING subtype, HttpMultipartContent* *multipartContent);
	virtual STDMETHODIMP _CreateWithSubtypeAndBoundary(HSTRING subtype, HSTRING boundary, HttpMultipartContent* *multipartContent);
};

// IHttpMultipartContent
struct IHttpMultipartContent_raw : IInspectable {
	virtual STDMETHODIMP _Add(IHttpContent* content);
};
template<typename X> struct IHttpMultipartContent_adaptor : X {
	void Add(pptr<IHttpContent> content) { hrcheck(X::get()->_Add(content)); }
};
template<typename X> struct adapt<IHttpMultipartContent, X> : Windows::Web::Http::IHttpMultipartContent_adaptor<X> { typedef adapt IHttpMultipartContent; };
struct IHttpMultipartContent : IHttpMultipartContent_raw, generate<IHttpMultipartContent> {};

// HttpMultipartContent
template<typename> struct HttpMultipartContent_statics {
	static HttpMultipartContent *activate(hstring_ref subtype) { HttpMultipartContent *multipartContent; hrcheck(get_activation_factory<HttpMultipartContent, IHttpMultipartContentFactory>()->_CreateWithSubtype(subtype, &multipartContent)); return multipartContent; }
	static HttpMultipartContent *activate(hstring_ref subtype, hstring_ref boundary) { HttpMultipartContent *multipartContent; hrcheck(get_activation_factory<HttpMultipartContent, IHttpMultipartContentFactory>()->_CreateWithSubtypeAndBoundary(subtype, boundary, &multipartContent)); return multipartContent; }
	static HttpMultipartContent *activate() { HttpMultipartContent *t; get_activation_factory<HttpMultipartContent>()->ActivateInstance((IInspectable**)&t); return t; }
};

template<typename X> struct statics<HttpMultipartContent, X> : X, Windows::Web::Http::HttpMultipartContent_statics<void> {
	using Windows::Web::Http::HttpMultipartContent_statics<void>::activate;
	typedef typename X::root_type HttpMultipartContent;
};
struct HttpMultipartContent : generate<HttpMultipartContent> {};

// IHttpMultipartFormDataContentFactory
struct IHttpMultipartFormDataContentFactory : IInspectable {
	virtual STDMETHODIMP _CreateWithBoundary(HSTRING boundary, HttpMultipartFormDataContent* *multipartFormDataContent);
};

// IHttpMultipartFormDataContent
struct IHttpMultipartFormDataContent_raw : IInspectable {
	virtual STDMETHODIMP _Add(IHttpContent* content);
	virtual STDMETHODIMP _AddWithName(IHttpContent* content, HSTRING name);
	virtual STDMETHODIMP _AddWithNameAndFileName(IHttpContent* content, HSTRING name, HSTRING fileName);
};
template<typename X> struct IHttpMultipartFormDataContent_adaptor : X {
	void Add(pptr<IHttpContent> content) { hrcheck(X::get()->_Add(content)); }
	void Add(pptr<IHttpContent> content, hstring_ref name) { hrcheck(X::get()->_AddWithName(content, name)); }
	void Add(pptr<IHttpContent> content, hstring_ref name, hstring_ref fileName) { hrcheck(X::get()->_AddWithNameAndFileName(content, name, fileName)); }
};
template<typename X> struct adapt<IHttpMultipartFormDataContent, X> : Windows::Web::Http::IHttpMultipartFormDataContent_adaptor<X> { typedef adapt IHttpMultipartFormDataContent; };
struct IHttpMultipartFormDataContent : IHttpMultipartFormDataContent_raw, generate<IHttpMultipartFormDataContent> {};

// HttpMultipartFormDataContent
template<typename> struct HttpMultipartFormDataContent_statics {
	static HttpMultipartFormDataContent *activate() { HttpMultipartFormDataContent *t; get_activation_factory<HttpMultipartFormDataContent>()->ActivateInstance((IInspectable**)&t); return t; }
	static HttpMultipartFormDataContent *activate(hstring_ref boundary) { HttpMultipartFormDataContent *multipartFormDataContent; hrcheck(get_activation_factory<HttpMultipartFormDataContent, IHttpMultipartFormDataContentFactory>()->_CreateWithBoundary(boundary, &multipartFormDataContent)); return multipartFormDataContent; }
};

template<typename X> struct statics<HttpMultipartFormDataContent, X> : X, Windows::Web::Http::HttpMultipartFormDataContent_statics<void> {
	using Windows::Web::Http::HttpMultipartFormDataContent_statics<void>::activate;
	typedef typename X::root_type HttpMultipartFormDataContent;
};
struct HttpMultipartFormDataContent : generate<HttpMultipartFormDataContent> {
	using IHttpMultipartFormDataContent::Add;
};

// HttpCookieManager
template<typename X> struct statics<HttpCookieManager, X> : X {
	typedef typename X::root_type HttpCookieManager;
};
struct HttpCookieManager : generate<HttpCookieManager> {
	using IHttpCookieManager::SetCookie;
};
}}}
} // namespace iso_winrt
