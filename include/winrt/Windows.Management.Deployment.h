#pragma once
// generated by isopod tools
// namespaces:
// Windows.Management.Deployment

#include "Windows.Management.Deployment.0.h"
#include "Windows.ApplicationModel.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IVector;
template<typename T> struct IIterable;
template<typename T> struct IVectorView;
}}}

// defs

template<> struct def<Windows::Management::Deployment::DeploymentProgressState> : enum_type<int> {};
template<> struct def<Windows::Management::Deployment::DeploymentProgress> : value_type<Windows::Management::Deployment::DeploymentProgressState, unsigned> {};
template<> struct def<Windows::Management::Deployment::DeploymentOptions> : enum_type<unsigned> {};
template<> struct def<Windows::Management::Deployment::RemovalOptions> : enum_type<unsigned> {};
template<> struct def<Windows::Management::Deployment::AddPackageByAppInstallerOptions> : enum_type<unsigned> {};
template<> struct def<Windows::Management::Deployment::PackageTypes> : enum_type<unsigned> {};
template<> struct def<Windows::Management::Deployment::IDeploymentResult> : interface_type<> {};
template<> struct def<Windows::Management::Deployment::IDeploymentResult2> : interface_type<> {};
template<> struct def<Windows::Management::Deployment::DeploymentResult> : class_type<Platform::Object, Windows::Management::Deployment::IDeploymentResult, Windows::Management::Deployment::IDeploymentResult2> {};
template<> struct def<Windows::Management::Deployment::PackageInstallState> : enum_type<int> {};
template<> struct def<Windows::Management::Deployment::IPackageUserInformation> : interface_type<> {};
template<> struct def<Windows::Management::Deployment::PackageUserInformation> : class_type<Platform::Object, Windows::Management::Deployment::IPackageUserInformation> {};
template<> struct def<Windows::Management::Deployment::PackageState> : enum_type<int> {};
template<> struct def<Windows::Management::Deployment::PackageStatus> : enum_type<unsigned> {};
template<> struct def<Windows::Management::Deployment::IPackageManager> : interface_type<> {};
template<> struct def<Windows::Management::Deployment::IPackageManager2> : interface_type<> {};
template<> struct def<Windows::Management::Deployment::IPackageManager3> : interface_type<> {};
template<> struct def<Windows::Management::Deployment::IPackageVolume2> : interface_type<> {};
template<> struct def<Windows::Management::Deployment::IPackageVolume> : interface_type<> {};
template<> struct def<Windows::Management::Deployment::PackageVolume> : class_type<Platform::Object, Windows::Management::Deployment::IPackageVolume, Windows::Management::Deployment::IPackageVolume2> {};
template<> struct def<Windows::Management::Deployment::IPackageManager4> : interface_type<> {};
template<> struct def<Windows::Management::Deployment::IPackageManager5> : interface_type<> {};
template<> struct def<Windows::Management::Deployment::IPackageManagerDebugSettings> : interface_type<> {};
template<> struct def<Windows::Management::Deployment::PackageManagerDebugSettings> : class_type<Platform::Object, Windows::Management::Deployment::IPackageManagerDebugSettings> {};
template<> struct def<Windows::Management::Deployment::IPackageManager6> : interface_type<> {};
template<> struct def<Windows::Management::Deployment::IPackageManager7> : interface_type<> {};
template<> struct def<Windows::Management::Deployment::PackageManager> : class_type<Platform::Object, Windows::Management::Deployment::IPackageManager, Windows::Management::Deployment::IPackageManager2, Windows::Management::Deployment::IPackageManager3, Windows::Management::Deployment::IPackageManager4, Windows::Management::Deployment::IPackageManager5, Windows::Management::Deployment::IPackageManager6, Windows::Management::Deployment::IPackageManager7> {};

// uuids

template<> struct uuid<Windows::Management::Deployment::IDeploymentResult> { define_guid(0x2563B9AE, 0xB77D, 0x4C1F, 0x8A, 0x7B, 0x20, 0xE6, 0xAD, 0x51, 0x5E, 0xF3);};
template<> struct uuid<Windows::Management::Deployment::IDeploymentResult2> { define_guid(0xFC0E715C, 0x5A01, 0x4BD7, 0xBC, 0xF1, 0x38, 0x1C, 0x8C, 0x82, 0xE0, 0x4A);};
template<> struct uuid<Windows::Management::Deployment::IPackageUserInformation> { define_guid(0xF6383423, 0xFA09, 0x4CBC, 0x90, 0x55, 0x15, 0xCA, 0x27, 0x5E, 0x2E, 0x7E);};
template<> struct uuid<Windows::Management::Deployment::IPackageManager> { define_guid(0x9A7D4B65, 0x5E8F, 0x4FC7, 0xA2, 0xE5, 0x7F, 0x69, 0x25, 0xCB, 0x8B, 0x53);};
template<> struct uuid<Windows::Management::Deployment::IPackageManager2> { define_guid(0xF7AAD08D, 0x840, 0x46F2, 0xB5, 0xD8, 0xCA, 0xD4, 0x76, 0x93, 0xA0, 0x95);};
template<> struct uuid<Windows::Management::Deployment::IPackageManager3> { define_guid(0xDAAD9948, 0x36F1, 0x41A7, 0x91, 0x88, 0xBC, 0x26, 0x3E, 0xD, 0xCB, 0x72);};
template<> struct uuid<Windows::Management::Deployment::IPackageVolume2> { define_guid(0x46ABCF2E, 0x9DD4, 0x47A2, 0xAB, 0x8C, 0xC6, 0x40, 0x83, 0x49, 0xBC, 0xD8);};
template<> struct uuid<Windows::Management::Deployment::IPackageVolume> { define_guid(0xCF2672C3, 0x1A40, 0x4450, 0x97, 0x39, 0x2A, 0xCE, 0x2E, 0x89, 0x88, 0x53);};
template<> struct uuid<Windows::Management::Deployment::IPackageManager4> { define_guid(0x3C719963, 0xBAB6, 0x46BF, 0x8F, 0xF7, 0xDA, 0x47, 0x19, 0x23, 0xA, 0xE6);};
template<> struct uuid<Windows::Management::Deployment::IPackageManager5> { define_guid(0x711F3117, 0x1AFD, 0x4313, 0x97, 0x8C, 0x9B, 0xB6, 0xE1, 0xB8, 0x64, 0xA7);};
template<> struct uuid<Windows::Management::Deployment::IPackageManagerDebugSettings> { define_guid(0x1A611683, 0xA988, 0x4FCF, 0x8F, 0xF, 0xCE, 0x17, 0x58, 0x98, 0xE8, 0xEB);};
template<> struct uuid<Windows::Management::Deployment::IPackageManager6> { define_guid(0x847E909, 0x53CD, 0x4E4F, 0x83, 0x2E, 0x57, 0xD1, 0x80, 0xF6, 0xE4, 0x47);};
template<> struct uuid<Windows::Management::Deployment::IPackageManager7> { define_guid(0xF28654F4, 0x2BA7, 0x4B80, 0x88, 0xD6, 0xBE, 0x15, 0xF9, 0xA2, 0x3F, 0xBA);};

// types

namespace Windows { namespace Management { namespace Deployment {

// IDeploymentResult
struct IDeploymentResult_raw : IInspectable {
	virtual STDMETHODIMP _get_ErrorText(HSTRING *value);
	virtual STDMETHODIMP _get_ActivityId(Platform::Guid *value);
	virtual STDMETHODIMP _get_ExtendedErrorCode(Foundation::HResult *value);
};
template<typename X> struct IDeploymentResult_adaptor : X {
	union {
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IDeploymentResult_adaptor::ActivityId)->_get_ActivityId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} ActivityId;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDeploymentResult_adaptor::ErrorText)->_get_ErrorText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ErrorText;
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IDeploymentResult_adaptor::ExtendedErrorCode)->_get_ExtendedErrorCode(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedErrorCode;
	};
	IDeploymentResult_adaptor() {}
};
template<typename X> struct adapt<IDeploymentResult, X> : Windows::Management::Deployment::IDeploymentResult_adaptor<X> { typedef adapt IDeploymentResult; };
struct IDeploymentResult : IDeploymentResult_raw, generate<IDeploymentResult> {};

// IDeploymentResult2
struct IDeploymentResult2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsRegistered(bool *value);
};
template<typename X> struct IDeploymentResult2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDeploymentResult2_adaptor::IsRegistered)->_get_IsRegistered(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsRegistered;
	};
	IDeploymentResult2_adaptor() {}
};
template<typename X> struct adapt<IDeploymentResult2, X> : Windows::Management::Deployment::IDeploymentResult2_adaptor<X> { typedef adapt IDeploymentResult2; };
struct IDeploymentResult2 : IDeploymentResult2_raw, generate<IDeploymentResult2> {};

// DeploymentResult
template<typename X> struct statics<DeploymentResult, X> : X {
	typedef typename X::root_type DeploymentResult;
};
struct DeploymentResult : generate<DeploymentResult> {};

// IPackageUserInformation
struct IPackageUserInformation_raw : IInspectable {
	virtual STDMETHODIMP _get_UserSecurityId(HSTRING *value);
	virtual STDMETHODIMP _get_InstallState(PackageInstallState *value);
};
template<typename X> struct IPackageUserInformation_adaptor : X {
	union {
		struct : property {
			PackageInstallState get() { PackageInstallState value; hrcheck(enc(&IPackageUserInformation_adaptor::InstallState)->_get_InstallState(&value)); return value; }
			PackageInstallState operator()() { return get(); }
			operator PackageInstallState () { return get(); }
		} InstallState;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackageUserInformation_adaptor::UserSecurityId)->_get_UserSecurityId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} UserSecurityId;
	};
	IPackageUserInformation_adaptor() {}
};
template<typename X> struct adapt<IPackageUserInformation, X> : Windows::Management::Deployment::IPackageUserInformation_adaptor<X> { typedef adapt IPackageUserInformation; };
struct IPackageUserInformation : IPackageUserInformation_raw, generate<IPackageUserInformation> {};

// PackageUserInformation
template<typename X> struct statics<PackageUserInformation, X> : X {
	typedef typename X::root_type PackageUserInformation;
};
struct PackageUserInformation : generate<PackageUserInformation> {};

// IPackageManager
struct IPackageManager_raw : IInspectable {
	virtual STDMETHODIMP _AddPackageAsync(Foundation::Uri* packageUri, Foundation::Collections::IIterable<Foundation::Uri*>* dependencyPackageUris, DeploymentOptions deploymentOptions, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _UpdatePackageAsync(Foundation::Uri* packageUri, Foundation::Collections::IIterable<Foundation::Uri*>* dependencyPackageUris, DeploymentOptions deploymentOptions, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _RemovePackageAsync(HSTRING packageFullName, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _StagePackageAsync(Foundation::Uri* packageUri, Foundation::Collections::IIterable<Foundation::Uri*>* dependencyPackageUris, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _RegisterPackageAsync(Foundation::Uri* manifestUri, Foundation::Collections::IIterable<Foundation::Uri*>* dependencyPackageUris, DeploymentOptions deploymentOptions, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _FindPackages(Foundation::Collections::IIterable<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByUserSecurityId(HSTRING userSecurityId, Foundation::Collections::IIterable<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByNamePublisher(HSTRING packageName, HSTRING packagePublisher, Foundation::Collections::IIterable<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByUserSecurityIdNamePublisher(HSTRING userSecurityId, HSTRING packageName, HSTRING packagePublisher, Foundation::Collections::IIterable<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindUsers(HSTRING packageFullName, Foundation::Collections::IIterable<PackageUserInformation*>* *users);
	virtual STDMETHODIMP _SetPackageState(HSTRING packageFullName, PackageState packageState);
	virtual STDMETHODIMP _FindPackageByPackageFullName(HSTRING packageFullName, ApplicationModel::Package* *packageInformation);
	virtual STDMETHODIMP _CleanupPackageForUserAsync(HSTRING packageName, HSTRING userSecurityId, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _FindPackagesByPackageFamilyName(HSTRING packageFamilyName, Foundation::Collections::IIterable<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByUserSecurityIdPackageFamilyName(HSTRING userSecurityId, HSTRING packageFamilyName, Foundation::Collections::IIterable<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackageByUserSecurityIdPackageFullName(HSTRING userSecurityId, HSTRING packageFullName, ApplicationModel::Package* *packageInformation);
};
template<typename X> struct IPackageManager_adaptor : X {
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> AddPackageAsync(pptr<Foundation::Uri> packageUri, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> dependencyPackageUris, DeploymentOptions deploymentOptions) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_AddPackageAsync(packageUri, to_abi(dependencyPackageUris), deploymentOptions, &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> UpdatePackageAsync(pptr<Foundation::Uri> packageUri, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> dependencyPackageUris, DeploymentOptions deploymentOptions) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_UpdatePackageAsync(packageUri, to_abi(dependencyPackageUris), deploymentOptions, &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> RemovePackageAsync(hstring_ref packageFullName) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_RemovePackageAsync(packageFullName, &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> StagePackageAsync(pptr<Foundation::Uri> packageUri, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> dependencyPackageUris) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_StagePackageAsync(packageUri, to_abi(dependencyPackageUris), &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> RegisterPackageAsync(pptr<Foundation::Uri> manifestUri, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> dependencyPackageUris, DeploymentOptions deploymentOptions) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_RegisterPackageAsync(manifestUri, to_abi(dependencyPackageUris), deploymentOptions, &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<Foundation::Collections::IIterable<ptr<ApplicationModel::Package>>> FindPackages() { Foundation::Collections::IIterable<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackages(&packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IIterable<ptr<ApplicationModel::Package>>> FindPackagesForUser(hstring_ref userSecurityId) { Foundation::Collections::IIterable<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByUserSecurityId(userSecurityId, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IIterable<ptr<ApplicationModel::Package>>> FindPackages(hstring_ref packageName, hstring_ref packagePublisher) { Foundation::Collections::IIterable<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByNamePublisher(packageName, packagePublisher, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IIterable<ptr<ApplicationModel::Package>>> FindPackagesForUser(hstring_ref userSecurityId, hstring_ref packageName, hstring_ref packagePublisher) { Foundation::Collections::IIterable<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByUserSecurityIdNamePublisher(userSecurityId, packageName, packagePublisher, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IIterable<ptr<PackageUserInformation>>> FindUsers(hstring_ref packageFullName) { Foundation::Collections::IIterable<PackageUserInformation*>* users; hrcheck(X::get()->_FindUsers(packageFullName, &users)); return from_abi(users); }
	void SetPackageState(hstring_ref packageFullName, PackageState packageState) { hrcheck(X::get()->_SetPackageState(packageFullName, packageState)); }
	ptr<ApplicationModel::Package> FindPackage(hstring_ref packageFullName) { ApplicationModel::Package* packageInformation; hrcheck(X::get()->_FindPackageByPackageFullName(packageFullName, &packageInformation)); return from_abi(packageInformation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> CleanupPackageForUserAsync(hstring_ref packageName, hstring_ref userSecurityId) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_CleanupPackageForUserAsync(packageName, userSecurityId, &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<Foundation::Collections::IIterable<ptr<ApplicationModel::Package>>> FindPackages(hstring_ref packageFamilyName) { Foundation::Collections::IIterable<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByPackageFamilyName(packageFamilyName, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IIterable<ptr<ApplicationModel::Package>>> FindPackagesForUser(hstring_ref userSecurityId, hstring_ref packageFamilyName) { Foundation::Collections::IIterable<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByUserSecurityIdPackageFamilyName(userSecurityId, packageFamilyName, &packageCollection)); return from_abi(packageCollection); }
	ptr<ApplicationModel::Package> FindPackageForUser(hstring_ref userSecurityId, hstring_ref packageFullName) { ApplicationModel::Package* packageInformation; hrcheck(X::get()->_FindPackageByUserSecurityIdPackageFullName(userSecurityId, packageFullName, &packageInformation)); return from_abi(packageInformation); }
};
template<typename X> struct adapt<IPackageManager, X> : Windows::Management::Deployment::IPackageManager_adaptor<X> { typedef adapt IPackageManager; };
struct IPackageManager : IPackageManager_raw, generate<IPackageManager> {};

// IPackageManager2
struct IPackageManager2_raw : IInspectable {
	virtual STDMETHODIMP _RemovePackageWithOptionsAsync(HSTRING packageFullName, RemovalOptions removalOptions, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _StagePackageWithOptionsAsync(Foundation::Uri* packageUri, Foundation::Collections::IIterable<Foundation::Uri*>* dependencyPackageUris, DeploymentOptions deploymentOptions, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _RegisterPackageByFullNameAsync(HSTRING mainPackageFullName, Foundation::Collections::IIterable<HSTRING>* dependencyPackageFullNames, DeploymentOptions deploymentOptions, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _FindPackagesWithPackageTypes(PackageTypes packageTypes, Foundation::Collections::IIterable<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByUserSecurityIdWithPackageTypes(HSTRING userSecurityId, PackageTypes packageTypes, Foundation::Collections::IIterable<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByNamePublisherWithPackageTypes(HSTRING packageName, HSTRING packagePublisher, PackageTypes packageTypes, Foundation::Collections::IIterable<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByUserSecurityIdNamePublisherWithPackageTypes(HSTRING userSecurityId, HSTRING packageName, HSTRING packagePublisher, PackageTypes packageTypes, Foundation::Collections::IIterable<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByPackageFamilyNameWithPackageTypes(HSTRING packageFamilyName, PackageTypes packageTypes, Foundation::Collections::IIterable<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByUserSecurityIdPackageFamilyNameWithPackageTypes(HSTRING userSecurityId, HSTRING packageFamilyName, PackageTypes packageTypes, Foundation::Collections::IIterable<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _StageUserDataAsync(HSTRING packageFullName, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
};
template<typename X> struct IPackageManager2_adaptor : X {
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> RemovePackageAsync(hstring_ref packageFullName, RemovalOptions removalOptions) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_RemovePackageWithOptionsAsync(packageFullName, removalOptions, &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> StagePackageAsync(pptr<Foundation::Uri> packageUri, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> dependencyPackageUris, DeploymentOptions deploymentOptions) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_StagePackageWithOptionsAsync(packageUri, to_abi(dependencyPackageUris), deploymentOptions, &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> RegisterPackageByFullNameAsync(hstring_ref mainPackageFullName, pptr<Foundation::Collections::IIterable<hstring>> dependencyPackageFullNames, DeploymentOptions deploymentOptions) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_RegisterPackageByFullNameAsync(mainPackageFullName, to_abi(dependencyPackageFullNames), deploymentOptions, &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<Foundation::Collections::IIterable<ptr<ApplicationModel::Package>>> FindPackagesWithPackageTypes(PackageTypes packageTypes) { Foundation::Collections::IIterable<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesWithPackageTypes(packageTypes, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IIterable<ptr<ApplicationModel::Package>>> FindPackagesForUserWithPackageTypes(hstring_ref userSecurityId, PackageTypes packageTypes) { Foundation::Collections::IIterable<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByUserSecurityIdWithPackageTypes(userSecurityId, packageTypes, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IIterable<ptr<ApplicationModel::Package>>> FindPackagesWithPackageTypes(hstring_ref packageName, hstring_ref packagePublisher, PackageTypes packageTypes) { Foundation::Collections::IIterable<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByNamePublisherWithPackageTypes(packageName, packagePublisher, packageTypes, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IIterable<ptr<ApplicationModel::Package>>> FindPackagesForUserWithPackageTypes(hstring_ref userSecurityId, hstring_ref packageName, hstring_ref packagePublisher, PackageTypes packageTypes) { Foundation::Collections::IIterable<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByUserSecurityIdNamePublisherWithPackageTypes(userSecurityId, packageName, packagePublisher, packageTypes, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IIterable<ptr<ApplicationModel::Package>>> FindPackagesWithPackageTypes(hstring_ref packageFamilyName, PackageTypes packageTypes) { Foundation::Collections::IIterable<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByPackageFamilyNameWithPackageTypes(packageFamilyName, packageTypes, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IIterable<ptr<ApplicationModel::Package>>> FindPackagesForUserWithPackageTypes(hstring_ref userSecurityId, hstring_ref packageFamilyName, PackageTypes packageTypes) { Foundation::Collections::IIterable<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByUserSecurityIdPackageFamilyNameWithPackageTypes(userSecurityId, packageFamilyName, packageTypes, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> StageUserDataAsync(hstring_ref packageFullName) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_StageUserDataAsync(packageFullName, &deploymentOperation)); return from_abi(deploymentOperation); }
};
template<typename X> struct adapt<IPackageManager2, X> : Windows::Management::Deployment::IPackageManager2_adaptor<X> { typedef adapt IPackageManager2; };
struct IPackageManager2 : IPackageManager2_raw, generate<IPackageManager2> {};

// IPackageManager3
struct IPackageManager3_raw : IInspectable {
	virtual STDMETHODIMP _AddPackageVolumeAsync(HSTRING packageStorePath, Foundation::IAsyncOperation<PackageVolume*>* *packageVolume);
	virtual STDMETHODIMP _AddPackageToVolumeAsync(Foundation::Uri* packageUri, Foundation::Collections::IIterable<Foundation::Uri*>* dependencyPackageUris, DeploymentOptions deploymentOptions, PackageVolume* targetVolume, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _ClearPackageStatus(HSTRING packageFullName, PackageStatus status);
	virtual STDMETHODIMP _RegisterPackageWithAppDataVolumeAsync(Foundation::Uri* manifestUri, Foundation::Collections::IIterable<Foundation::Uri*>* dependencyPackageUris, DeploymentOptions deploymentOptions, PackageVolume* appDataVolume, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _FindPackageVolumeByName(HSTRING volumeName, PackageVolume* *volume);
	virtual STDMETHODIMP _FindPackageVolumes(Foundation::Collections::IIterable<PackageVolume*>* *volumeCollection);
	virtual STDMETHODIMP _GetDefaultPackageVolume(PackageVolume* *volume);
	virtual STDMETHODIMP _MovePackageToVolumeAsync(HSTRING packageFullName, DeploymentOptions deploymentOptions, PackageVolume* targetVolume, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _RemovePackageVolumeAsync(PackageVolume* volume, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _SetDefaultPackageVolume(PackageVolume* volume);
	virtual STDMETHODIMP _SetPackageStatus(HSTRING packageFullName, PackageStatus status);
	virtual STDMETHODIMP _SetPackageVolumeOfflineAsync(PackageVolume* packageVolume, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _SetPackageVolumeOnlineAsync(PackageVolume* packageVolume, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _StagePackageToVolumeAsync(Foundation::Uri* packageUri, Foundation::Collections::IIterable<Foundation::Uri*>* dependencyPackageUris, DeploymentOptions deploymentOptions, PackageVolume* targetVolume, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _StageUserDataWithOptionsAsync(HSTRING packageFullName, DeploymentOptions deploymentOptions, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
};
template<typename X> struct IPackageManager3_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<PackageVolume>>> AddPackageVolumeAsync(hstring_ref packageStorePath) { Foundation::IAsyncOperation<PackageVolume*>* packageVolume; hrcheck(X::get()->_AddPackageVolumeAsync(packageStorePath, &packageVolume)); return from_abi(packageVolume); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> AddPackageAsync(pptr<Foundation::Uri> packageUri, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> dependencyPackageUris, DeploymentOptions deploymentOptions, pptr<PackageVolume> targetVolume) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_AddPackageToVolumeAsync(packageUri, to_abi(dependencyPackageUris), deploymentOptions, targetVolume, &deploymentOperation)); return from_abi(deploymentOperation); }
	void ClearPackageStatus(hstring_ref packageFullName, PackageStatus status) { hrcheck(X::get()->_ClearPackageStatus(packageFullName, status)); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> RegisterPackageAsync(pptr<Foundation::Uri> manifestUri, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> dependencyPackageUris, DeploymentOptions deploymentOptions, pptr<PackageVolume> appDataVolume) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_RegisterPackageWithAppDataVolumeAsync(manifestUri, to_abi(dependencyPackageUris), deploymentOptions, appDataVolume, &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<PackageVolume> FindPackageVolume(hstring_ref volumeName) { PackageVolume* volume; hrcheck(X::get()->_FindPackageVolumeByName(volumeName, &volume)); return from_abi(volume); }
	ptr<Foundation::Collections::IIterable<ptr<PackageVolume>>> FindPackageVolumes() { Foundation::Collections::IIterable<PackageVolume*>* volumeCollection; hrcheck(X::get()->_FindPackageVolumes(&volumeCollection)); return from_abi(volumeCollection); }
	ptr<PackageVolume> GetDefaultPackageVolume() { PackageVolume* volume; hrcheck(X::get()->_GetDefaultPackageVolume(&volume)); return from_abi(volume); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> MovePackageToVolumeAsync(hstring_ref packageFullName, DeploymentOptions deploymentOptions, pptr<PackageVolume> targetVolume) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_MovePackageToVolumeAsync(packageFullName, deploymentOptions, targetVolume, &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> RemovePackageVolumeAsync(pptr<PackageVolume> volume) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_RemovePackageVolumeAsync(volume, &deploymentOperation)); return from_abi(deploymentOperation); }
	void SetDefaultPackageVolume(pptr<PackageVolume> volume) { hrcheck(X::get()->_SetDefaultPackageVolume(volume)); }
	void SetPackageStatus(hstring_ref packageFullName, PackageStatus status) { hrcheck(X::get()->_SetPackageStatus(packageFullName, status)); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> SetPackageVolumeOfflineAsync(pptr<PackageVolume> packageVolume) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_SetPackageVolumeOfflineAsync(packageVolume, &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> SetPackageVolumeOnlineAsync(pptr<PackageVolume> packageVolume) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_SetPackageVolumeOnlineAsync(packageVolume, &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> StagePackageAsync(pptr<Foundation::Uri> packageUri, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> dependencyPackageUris, DeploymentOptions deploymentOptions, pptr<PackageVolume> targetVolume) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_StagePackageToVolumeAsync(packageUri, to_abi(dependencyPackageUris), deploymentOptions, targetVolume, &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> StageUserDataAsync(hstring_ref packageFullName, DeploymentOptions deploymentOptions) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_StageUserDataWithOptionsAsync(packageFullName, deploymentOptions, &deploymentOperation)); return from_abi(deploymentOperation); }
};
template<typename X> struct adapt<IPackageManager3, X> : Windows::Management::Deployment::IPackageManager3_adaptor<X> { typedef adapt IPackageManager3; };
struct IPackageManager3 : IPackageManager3_raw, generate<IPackageManager3> {};

// IPackageVolume2
struct IPackageVolume2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsFullTrustPackageSupported(bool *value);
	virtual STDMETHODIMP _get_IsAppxInstallSupported(bool *value);
	virtual STDMETHODIMP _GetAvailableSpaceAsync(Foundation::IAsyncOperation<unsigned __int64>* *operation);
};
template<typename X> struct IPackageVolume2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageVolume2_adaptor::IsAppxInstallSupported)->_get_IsAppxInstallSupported(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsAppxInstallSupported;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageVolume2_adaptor::IsFullTrustPackageSupported)->_get_IsFullTrustPackageSupported(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsFullTrustPackageSupported;
	};
	ptr<Foundation::IAsyncOperation<unsigned __int64>> GetAvailableSpaceAsync() { Foundation::IAsyncOperation<unsigned __int64>* operation; hrcheck(X::get()->_GetAvailableSpaceAsync(&operation)); return from_abi(operation); }
	IPackageVolume2_adaptor() {}
};
template<typename X> struct adapt<IPackageVolume2, X> : Windows::Management::Deployment::IPackageVolume2_adaptor<X> { typedef adapt IPackageVolume2; };
struct IPackageVolume2 : IPackageVolume2_raw, generate<IPackageVolume2> {};

// IPackageVolume
struct IPackageVolume_raw : IInspectable {
	virtual STDMETHODIMP _get_IsOffline(bool *value);
	virtual STDMETHODIMP _get_IsSystemVolume(bool *value);
	virtual STDMETHODIMP _get_MountPoint(HSTRING *value);
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_PackageStorePath(HSTRING *value);
	virtual STDMETHODIMP _get_SupportsHardLinks(bool *value);
	virtual STDMETHODIMP _FindPackages(Foundation::Collections::IVector<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByNamePublisher(HSTRING packageName, HSTRING packagePublisher, Foundation::Collections::IVector<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByPackageFamilyName(HSTRING packageFamilyName, Foundation::Collections::IVector<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesWithPackageTypes(PackageTypes packageTypes, Foundation::Collections::IVector<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByNamePublisherWithPackagesTypes(PackageTypes packageTypes, HSTRING packageName, HSTRING packagePublisher, Foundation::Collections::IVector<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByPackageFamilyNameWithPackageTypes(PackageTypes packageTypes, HSTRING packageFamilyName, Foundation::Collections::IVector<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackageByPackageFullName(HSTRING packageFullName, Foundation::Collections::IVector<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByUserSecurityId(HSTRING userSecurityId, Foundation::Collections::IVector<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByUserSecurityIdNamePublisher(HSTRING userSecurityId, HSTRING packageName, HSTRING packagePublisher, Foundation::Collections::IVector<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByUserSecurityIdPackageFamilyName(HSTRING userSecurityId, HSTRING packageFamilyName, Foundation::Collections::IVector<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByUserSecurityIdWithPackageTypes(HSTRING userSecurityId, PackageTypes packageTypes, Foundation::Collections::IVector<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByUserSecurityIdNamePublisherWithPackageTypes(HSTRING userSecurityId, PackageTypes packageTypes, HSTRING packageName, HSTRING packagePublisher, Foundation::Collections::IVector<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackagesByUserSecurityIdPackageFamilyNameWithPackagesTypes(HSTRING userSecurityId, PackageTypes packageTypes, HSTRING packageFamilyName, Foundation::Collections::IVector<ApplicationModel::Package*>* *packageCollection);
	virtual STDMETHODIMP _FindPackageByUserSecurityIdPackageFullName(HSTRING userSecurityId, HSTRING packageFullName, Foundation::Collections::IVector<ApplicationModel::Package*>* *packageCollection);
};
template<typename X> struct IPackageVolume_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageVolume_adaptor::IsOffline)->_get_IsOffline(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsOffline;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageVolume_adaptor::IsSystemVolume)->_get_IsSystemVolume(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsSystemVolume;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackageVolume_adaptor::MountPoint)->_get_MountPoint(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} MountPoint;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackageVolume_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackageVolume_adaptor::PackageStorePath)->_get_PackageStorePath(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PackageStorePath;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageVolume_adaptor::SupportsHardLinks)->_get_SupportsHardLinks(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} SupportsHardLinks;
	};
	ptr<Foundation::Collections::IVector<ptr<ApplicationModel::Package>>> FindPackages() { Foundation::Collections::IVector<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackages(&packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IVector<ptr<ApplicationModel::Package>>> FindPackages(hstring_ref packageName, hstring_ref packagePublisher) { Foundation::Collections::IVector<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByNamePublisher(packageName, packagePublisher, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IVector<ptr<ApplicationModel::Package>>> FindPackages(hstring_ref packageFamilyName) { Foundation::Collections::IVector<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByPackageFamilyName(packageFamilyName, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IVector<ptr<ApplicationModel::Package>>> FindPackagesWithPackageTypes(PackageTypes packageTypes) { Foundation::Collections::IVector<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesWithPackageTypes(packageTypes, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IVector<ptr<ApplicationModel::Package>>> FindPackagesWithPackageTypes(PackageTypes packageTypes, hstring_ref packageName, hstring_ref packagePublisher) { Foundation::Collections::IVector<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByNamePublisherWithPackagesTypes(packageTypes, packageName, packagePublisher, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IVector<ptr<ApplicationModel::Package>>> FindPackagesWithPackageTypes(PackageTypes packageTypes, hstring_ref packageFamilyName) { Foundation::Collections::IVector<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByPackageFamilyNameWithPackageTypes(packageTypes, packageFamilyName, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IVector<ptr<ApplicationModel::Package>>> FindPackage(hstring_ref packageFullName) { Foundation::Collections::IVector<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackageByPackageFullName(packageFullName, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IVector<ptr<ApplicationModel::Package>>> FindPackagesForUser(hstring_ref userSecurityId) { Foundation::Collections::IVector<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByUserSecurityId(userSecurityId, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IVector<ptr<ApplicationModel::Package>>> FindPackagesForUser(hstring_ref userSecurityId, hstring_ref packageName, hstring_ref packagePublisher) { Foundation::Collections::IVector<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByUserSecurityIdNamePublisher(userSecurityId, packageName, packagePublisher, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IVector<ptr<ApplicationModel::Package>>> FindPackagesForUser(hstring_ref userSecurityId, hstring_ref packageFamilyName) { Foundation::Collections::IVector<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByUserSecurityIdPackageFamilyName(userSecurityId, packageFamilyName, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IVector<ptr<ApplicationModel::Package>>> FindPackagesForUserWithPackageTypes(hstring_ref userSecurityId, PackageTypes packageTypes) { Foundation::Collections::IVector<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByUserSecurityIdWithPackageTypes(userSecurityId, packageTypes, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IVector<ptr<ApplicationModel::Package>>> FindPackagesForUserWithPackageTypes(hstring_ref userSecurityId, PackageTypes packageTypes, hstring_ref packageName, hstring_ref packagePublisher) { Foundation::Collections::IVector<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByUserSecurityIdNamePublisherWithPackageTypes(userSecurityId, packageTypes, packageName, packagePublisher, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IVector<ptr<ApplicationModel::Package>>> FindPackagesForUserWithPackageTypes(hstring_ref userSecurityId, PackageTypes packageTypes, hstring_ref packageFamilyName) { Foundation::Collections::IVector<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackagesByUserSecurityIdPackageFamilyNameWithPackagesTypes(userSecurityId, packageTypes, packageFamilyName, &packageCollection)); return from_abi(packageCollection); }
	ptr<Foundation::Collections::IVector<ptr<ApplicationModel::Package>>> FindPackageForUser(hstring_ref userSecurityId, hstring_ref packageFullName) { Foundation::Collections::IVector<ApplicationModel::Package*>* packageCollection; hrcheck(X::get()->_FindPackageByUserSecurityIdPackageFullName(userSecurityId, packageFullName, &packageCollection)); return from_abi(packageCollection); }
	IPackageVolume_adaptor() {}
};
template<typename X> struct adapt<IPackageVolume, X> : Windows::Management::Deployment::IPackageVolume_adaptor<X> { typedef adapt IPackageVolume; };
struct IPackageVolume : IPackageVolume_raw, generate<IPackageVolume> {};

// PackageVolume
template<typename X> struct statics<PackageVolume, X> : X {
	typedef typename X::root_type PackageVolume;
};
struct PackageVolume : generate<PackageVolume> {
	using IPackageVolume::FindPackagesForUser;
	using IPackageVolume::FindPackagesForUserWithPackageTypes;
	using IPackageVolume::FindPackages;
	using IPackageVolume::FindPackagesWithPackageTypes;
};

// IPackageManager4
struct IPackageManager4_raw : IInspectable {
	virtual STDMETHODIMP _GetPackageVolumesAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<PackageVolume*>*>* *operation);
};
template<typename X> struct IPackageManager4_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<PackageVolume>>>>> GetPackageVolumesAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<PackageVolume*>*>* operation; hrcheck(X::get()->_GetPackageVolumesAsync(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IPackageManager4, X> : Windows::Management::Deployment::IPackageManager4_adaptor<X> { typedef adapt IPackageManager4; };
struct IPackageManager4 : IPackageManager4_raw, generate<IPackageManager4> {};

// IPackageManager5
struct IPackageManager5_raw : IInspectable {
	virtual STDMETHODIMP _AddPackageToVolumeAndOptionalPackagesAsync(Foundation::Uri* packageUri, Foundation::Collections::IIterable<Foundation::Uri*>* dependencyPackageUris, DeploymentOptions deploymentOptions, PackageVolume* targetVolume, Foundation::Collections::IIterable<HSTRING>* optionalPackageFamilyNames, Foundation::Collections::IIterable<Foundation::Uri*>* externalPackageUris, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _StagePackageToVolumeAndOptionalPackagesAsync(Foundation::Uri* packageUri, Foundation::Collections::IIterable<Foundation::Uri*>* dependencyPackageUris, DeploymentOptions deploymentOptions, PackageVolume* targetVolume, Foundation::Collections::IIterable<HSTRING>* optionalPackageFamilyNames, Foundation::Collections::IIterable<Foundation::Uri*>* externalPackageUris, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _RegisterPackageByFamilyNameAndOptionalPackagesAsync(HSTRING mainPackageFamilyName, Foundation::Collections::IIterable<HSTRING>* dependencyPackageFamilyNames, DeploymentOptions deploymentOptions, PackageVolume* appDataVolume, Foundation::Collections::IIterable<HSTRING>* optionalPackageFamilyNames, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *deploymentOperation);
	virtual STDMETHODIMP _get_DebugSettings(PackageManagerDebugSettings* *value);
};
template<typename X> struct IPackageManager5_adaptor : X {
	union {
		struct : property {
			ptr<PackageManagerDebugSettings> get() { PackageManagerDebugSettings* value; hrcheck(enc(&IPackageManager5_adaptor::DebugSettings)->_get_DebugSettings(&value)); return from_abi(value); }
			ptr<PackageManagerDebugSettings> operator()() { return get(); }
			operator ptr<PackageManagerDebugSettings> () { return get(); }
			ptr<PackageManagerDebugSettings> operator->() { return get(); }
		} DebugSettings;
	};
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> AddPackageAsync(pptr<Foundation::Uri> packageUri, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> dependencyPackageUris, DeploymentOptions deploymentOptions, pptr<PackageVolume> targetVolume, pptr<Foundation::Collections::IIterable<hstring>> optionalPackageFamilyNames, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> externalPackageUris) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_AddPackageToVolumeAndOptionalPackagesAsync(packageUri, to_abi(dependencyPackageUris), deploymentOptions, targetVolume, to_abi(optionalPackageFamilyNames), to_abi(externalPackageUris), &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> StagePackageAsync(pptr<Foundation::Uri> packageUri, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> dependencyPackageUris, DeploymentOptions deploymentOptions, pptr<PackageVolume> targetVolume, pptr<Foundation::Collections::IIterable<hstring>> optionalPackageFamilyNames, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> externalPackageUris) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_StagePackageToVolumeAndOptionalPackagesAsync(packageUri, to_abi(dependencyPackageUris), deploymentOptions, targetVolume, to_abi(optionalPackageFamilyNames), to_abi(externalPackageUris), &deploymentOperation)); return from_abi(deploymentOperation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> RegisterPackageByFamilyNameAsync(hstring_ref mainPackageFamilyName, pptr<Foundation::Collections::IIterable<hstring>> dependencyPackageFamilyNames, DeploymentOptions deploymentOptions, pptr<PackageVolume> appDataVolume, pptr<Foundation::Collections::IIterable<hstring>> optionalPackageFamilyNames) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* deploymentOperation; hrcheck(X::get()->_RegisterPackageByFamilyNameAndOptionalPackagesAsync(mainPackageFamilyName, to_abi(dependencyPackageFamilyNames), deploymentOptions, appDataVolume, to_abi(optionalPackageFamilyNames), &deploymentOperation)); return from_abi(deploymentOperation); }
	IPackageManager5_adaptor() {}
};
template<typename X> struct adapt<IPackageManager5, X> : Windows::Management::Deployment::IPackageManager5_adaptor<X> { typedef adapt IPackageManager5; };
struct IPackageManager5 : IPackageManager5_raw, generate<IPackageManager5> {};

// IPackageManagerDebugSettings
struct IPackageManagerDebugSettings_raw : IInspectable {
	virtual STDMETHODIMP _SetContentGroupStateAsync(ApplicationModel::Package* package, HSTRING contentGroupName, ApplicationModel::PackageContentGroupState state, Foundation::IAsyncAction* *action);
	virtual STDMETHODIMP _SetContentGroupStateWithPercentageAsync(ApplicationModel::Package* package, HSTRING contentGroupName, ApplicationModel::PackageContentGroupState state, double completionPercentage, Foundation::IAsyncAction* *action);
};
template<typename X> struct IPackageManagerDebugSettings_adaptor : X {
	ptr<Foundation::IAsyncAction> SetContentGroupStateAsync(pptr<ApplicationModel::Package> package, hstring_ref contentGroupName, ApplicationModel::PackageContentGroupState state) { Foundation::IAsyncAction* action; hrcheck(X::get()->_SetContentGroupStateAsync(package, contentGroupName, state, &action)); return from_abi(action); }
	ptr<Foundation::IAsyncAction> SetContentGroupStateAsync(pptr<ApplicationModel::Package> package, hstring_ref contentGroupName, ApplicationModel::PackageContentGroupState state, double completionPercentage) { Foundation::IAsyncAction* action; hrcheck(X::get()->_SetContentGroupStateWithPercentageAsync(package, contentGroupName, state, completionPercentage, &action)); return from_abi(action); }
};
template<typename X> struct adapt<IPackageManagerDebugSettings, X> : Windows::Management::Deployment::IPackageManagerDebugSettings_adaptor<X> { typedef adapt IPackageManagerDebugSettings; };
struct IPackageManagerDebugSettings : IPackageManagerDebugSettings_raw, generate<IPackageManagerDebugSettings> {};

// PackageManagerDebugSettings
template<typename X> struct statics<PackageManagerDebugSettings, X> : X {
	typedef typename X::root_type PackageManagerDebugSettings;
};
struct PackageManagerDebugSettings : generate<PackageManagerDebugSettings> {
	using IPackageManagerDebugSettings::SetContentGroupStateAsync;
};

// IPackageManager6
struct IPackageManager6_raw : IInspectable {
	virtual STDMETHODIMP _ProvisionPackageForAllUsersAsync(HSTRING packageFamilyName, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *operation);
	virtual STDMETHODIMP _AddPackageByAppInstallerFileAsync(Foundation::Uri* appInstallerFileUri, AddPackageByAppInstallerOptions options, PackageVolume* targetVolume, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *operation);
	virtual STDMETHODIMP _RequestAddPackageByAppInstallerFileAsync(Foundation::Uri* appInstallerFileUri, AddPackageByAppInstallerOptions options, PackageVolume* targetVolume, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *operation);
	virtual STDMETHODIMP _AddPackageToVolumeAndRelatedSetAsync(Foundation::Uri* packageUri, Foundation::Collections::IIterable<Foundation::Uri*>* dependencyPackageUris, DeploymentOptions options, PackageVolume* targetVolume, Foundation::Collections::IIterable<HSTRING>* optionalPackageFamilyNames, Foundation::Collections::IIterable<Foundation::Uri*>* packageUrisToInstall, Foundation::Collections::IIterable<Foundation::Uri*>* relatedPackageUris, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *operation);
	virtual STDMETHODIMP _StagePackageToVolumeAndRelatedSetAsync(Foundation::Uri* packageUri, Foundation::Collections::IIterable<Foundation::Uri*>* dependencyPackageUris, DeploymentOptions options, PackageVolume* targetVolume, Foundation::Collections::IIterable<HSTRING>* optionalPackageFamilyNames, Foundation::Collections::IIterable<Foundation::Uri*>* packageUrisToInstall, Foundation::Collections::IIterable<Foundation::Uri*>* relatedPackageUris, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *operation);
	virtual STDMETHODIMP _RequestAddPackageAsync(Foundation::Uri* packageUri, Foundation::Collections::IIterable<Foundation::Uri*>* dependencyPackageUris, DeploymentOptions deploymentOptions, PackageVolume* targetVolume, Foundation::Collections::IIterable<HSTRING>* optionalPackageFamilyNames, Foundation::Collections::IIterable<Foundation::Uri*>* relatedPackageUris, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *operation);
};
template<typename X> struct IPackageManager6_adaptor : X {
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> ProvisionPackageForAllUsersAsync(hstring_ref packageFamilyName) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* operation; hrcheck(X::get()->_ProvisionPackageForAllUsersAsync(packageFamilyName, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> AddPackageByAppInstallerFileAsync(pptr<Foundation::Uri> appInstallerFileUri, AddPackageByAppInstallerOptions options, pptr<PackageVolume> targetVolume) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* operation; hrcheck(X::get()->_AddPackageByAppInstallerFileAsync(appInstallerFileUri, options, targetVolume, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> RequestAddPackageByAppInstallerFileAsync(pptr<Foundation::Uri> appInstallerFileUri, AddPackageByAppInstallerOptions options, pptr<PackageVolume> targetVolume) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* operation; hrcheck(X::get()->_RequestAddPackageByAppInstallerFileAsync(appInstallerFileUri, options, targetVolume, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> AddPackageAsync(pptr<Foundation::Uri> packageUri, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> dependencyPackageUris, DeploymentOptions options, pptr<PackageVolume> targetVolume, pptr<Foundation::Collections::IIterable<hstring>> optionalPackageFamilyNames, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> packageUrisToInstall, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> relatedPackageUris) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* operation; hrcheck(X::get()->_AddPackageToVolumeAndRelatedSetAsync(packageUri, to_abi(dependencyPackageUris), options, targetVolume, to_abi(optionalPackageFamilyNames), to_abi(packageUrisToInstall), to_abi(relatedPackageUris), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> StagePackageAsync(pptr<Foundation::Uri> packageUri, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> dependencyPackageUris, DeploymentOptions options, pptr<PackageVolume> targetVolume, pptr<Foundation::Collections::IIterable<hstring>> optionalPackageFamilyNames, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> packageUrisToInstall, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> relatedPackageUris) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* operation; hrcheck(X::get()->_StagePackageToVolumeAndRelatedSetAsync(packageUri, to_abi(dependencyPackageUris), options, targetVolume, to_abi(optionalPackageFamilyNames), to_abi(packageUrisToInstall), to_abi(relatedPackageUris), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> RequestAddPackageAsync(pptr<Foundation::Uri> packageUri, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> dependencyPackageUris, DeploymentOptions deploymentOptions, pptr<PackageVolume> targetVolume, pptr<Foundation::Collections::IIterable<hstring>> optionalPackageFamilyNames, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> relatedPackageUris) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* operation; hrcheck(X::get()->_RequestAddPackageAsync(packageUri, to_abi(dependencyPackageUris), deploymentOptions, targetVolume, to_abi(optionalPackageFamilyNames), to_abi(relatedPackageUris), &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IPackageManager6, X> : Windows::Management::Deployment::IPackageManager6_adaptor<X> { typedef adapt IPackageManager6; };
struct IPackageManager6 : IPackageManager6_raw, generate<IPackageManager6> {};

// IPackageManager7
struct IPackageManager7_raw : IInspectable {
	virtual STDMETHODIMP _RequestAddPackageAndRelatedSetAsync(Foundation::Uri* packageUri, Foundation::Collections::IIterable<Foundation::Uri*>* dependencyPackageUris, DeploymentOptions deploymentOptions, PackageVolume* targetVolume, Foundation::Collections::IIterable<HSTRING>* optionalPackageFamilyNames, Foundation::Collections::IIterable<Foundation::Uri*>* relatedPackageUris, Foundation::Collections::IIterable<Foundation::Uri*>* packageUrisToInstall, Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* *operation);
};
template<typename X> struct IPackageManager7_adaptor : X {
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DeploymentResult>, DeploymentProgress>> RequestAddPackageAsync(pptr<Foundation::Uri> packageUri, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> dependencyPackageUris, DeploymentOptions deploymentOptions, pptr<PackageVolume> targetVolume, pptr<Foundation::Collections::IIterable<hstring>> optionalPackageFamilyNames, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> relatedPackageUris, pptr<Foundation::Collections::IIterable<ptr<Foundation::Uri>>> packageUrisToInstall) { Foundation::IAsyncOperationWithProgress<DeploymentResult*, DeploymentProgress>* operation; hrcheck(X::get()->_RequestAddPackageAndRelatedSetAsync(packageUri, to_abi(dependencyPackageUris), deploymentOptions, targetVolume, to_abi(optionalPackageFamilyNames), to_abi(relatedPackageUris), to_abi(packageUrisToInstall), &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IPackageManager7, X> : Windows::Management::Deployment::IPackageManager7_adaptor<X> { typedef adapt IPackageManager7; };
struct IPackageManager7 : IPackageManager7_raw, generate<IPackageManager7> {};

// PackageManager
template<typename X> struct statics<PackageManager, X> : X {
	typedef typename X::root_type PackageManager;
};
struct PackageManager : generate<PackageManager> {
	using IPackageManager::FindPackages;
	using IPackageManager3::StagePackageAsync;
	using IPackageManager2::StagePackageAsync;
	using IPackageManager5::StagePackageAsync;
	using IPackageManager6::StagePackageAsync;
	using IPackageManager::StagePackageAsync;
	using IPackageManager2::FindPackagesForUserWithPackageTypes;
	using IPackageManager3::AddPackageAsync;
	using IPackageManager5::AddPackageAsync;
	using IPackageManager6::AddPackageAsync;
	using IPackageManager::AddPackageAsync;
	using IPackageManager2::RemovePackageAsync;
	using IPackageManager::RemovePackageAsync;
	using IPackageManager3::RegisterPackageAsync;
	using IPackageManager::RegisterPackageAsync;
	using IPackageManager::FindPackagesForUser;
	using IPackageManager2::FindPackagesWithPackageTypes;
	using IPackageManager7::RequestAddPackageAsync;
	using IPackageManager6::RequestAddPackageAsync;
	using IPackageManager3::StageUserDataAsync;
	using IPackageManager2::StageUserDataAsync;
};
}}}
} // namespace iso_winrt
