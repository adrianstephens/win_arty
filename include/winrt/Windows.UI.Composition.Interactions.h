#pragma once
// generated by isopod tools
// namespaces:
// Windows.UI.Composition.Interactions

#include "Windows.UI.Composition.Interactions.0.h"
#include "Windows.Foundation.Numerics.0.h"
#include "Windows.UI.Composition.h"
#include "Windows.Foundation.Collections.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation {
template<typename T> struct IReference;
}
namespace UI { namespace Input {
struct PointerPoint;
}}}

// defs

template<> struct def<Windows::UI::Composition::Interactions::InteractionChainingMode> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::Interactions::InteractionSourceMode> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::Interactions::VisualInteractionSourceRedirectionMode> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::Interactions::ICompositionConditionalValue> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::ICompositionConditionalValueStatics> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::ICompositionInteractionSource> : overridable_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::ICompositionInteractionSourceCollection> : interface_type<Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Composition::Interactions::ICompositionInteractionSource>>> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTracker> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerOwner> : overridable_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerCustomAnimationStateEnteredArgs> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::InteractionTrackerCustomAnimationStateEnteredArgs> : class_type<Platform::Object, Windows::UI::Composition::Interactions::IInteractionTrackerCustomAnimationStateEnteredArgs> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerIdleStateEnteredArgs> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::InteractionTrackerIdleStateEnteredArgs> : class_type<Platform::Object, Windows::UI::Composition::Interactions::IInteractionTrackerIdleStateEnteredArgs> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaStateEnteredArgs> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::InteractionTrackerInertiaStateEnteredArgs> : class_type<Platform::Object, Windows::UI::Composition::Interactions::IInteractionTrackerInertiaStateEnteredArgs> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerInteractingStateEnteredArgs> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::InteractionTrackerInteractingStateEnteredArgs> : class_type<Platform::Object, Windows::UI::Composition::Interactions::IInteractionTrackerInteractingStateEnteredArgs> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerRequestIgnoredArgs> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::InteractionTrackerRequestIgnoredArgs> : class_type<Platform::Object, Windows::UI::Composition::Interactions::IInteractionTrackerRequestIgnoredArgs> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerValuesChangedArgs> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::InteractionTrackerValuesChangedArgs> : class_type<Platform::Object, Windows::UI::Composition::Interactions::IInteractionTrackerValuesChangedArgs> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTracker2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTracker3> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaModifier> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaNaturalMotion> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaNaturalMotionStatics> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaRestingValue> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaRestingValueStatics> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaMotion> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaMotionStatics> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerVector2InertiaModifier> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IVisualInteractionSource> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IVisualInteractionSourceStatics> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IVisualInteractionSource2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaModifierFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerVector2InertiaModifierFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerVector2InertiaNaturalMotion> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IInteractionTrackerVector2InertiaNaturalMotionStatics> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::IVisualInteractionSourceObjectFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Interactions::CompositionConditionalValue> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::Interactions::ICompositionConditionalValue> {};
template<> struct def<Windows::UI::Composition::Interactions::CompositionInteractionSourceCollection> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::Interactions::ICompositionInteractionSourceCollection> {};
template<> struct def<Windows::UI::Composition::Interactions::InteractionTracker> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::Interactions::IInteractionTracker, Windows::UI::Composition::Interactions::IInteractionTracker2, Windows::UI::Composition::Interactions::IInteractionTracker3> {};
template<> struct def<Windows::UI::Composition::Interactions::InteractionTrackerInertiaModifier> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::Interactions::IInteractionTrackerInertiaModifier> {};
template<> struct def<Windows::UI::Composition::Interactions::InteractionTrackerVector2InertiaModifier> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::Interactions::IInteractionTrackerVector2InertiaModifier> {};
template<> struct def<Windows::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion> : class_type<Windows::UI::Composition::Interactions::InteractionTrackerInertiaModifier, Windows::UI::Composition::Interactions::IInteractionTrackerInertiaNaturalMotion> {};
template<> struct def<Windows::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue> : class_type<Windows::UI::Composition::Interactions::InteractionTrackerInertiaModifier, Windows::UI::Composition::Interactions::IInteractionTrackerInertiaRestingValue> {};
template<> struct def<Windows::UI::Composition::Interactions::InteractionTrackerInertiaMotion> : class_type<Windows::UI::Composition::Interactions::InteractionTrackerInertiaModifier, Windows::UI::Composition::Interactions::IInteractionTrackerInertiaMotion> {};
template<> struct def<Windows::UI::Composition::Interactions::VisualInteractionSource> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::Interactions::IVisualInteractionSource, Windows::UI::Composition::Interactions::ICompositionInteractionSource, Windows::UI::Composition::Interactions::IVisualInteractionSource2> {};
template<> struct def<Windows::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion> : class_type<Windows::UI::Composition::Interactions::InteractionTrackerVector2InertiaModifier, Windows::UI::Composition::Interactions::IInteractionTrackerVector2InertiaNaturalMotion> {};

// uuids

template<> struct uuid<Windows::UI::Composition::Interactions::ICompositionConditionalValue> { define_guid(0x43250538, 0xEB73, 0x4561, 0xA7, 0x1D, 0x1A, 0x43, 0xEA, 0xEB, 0x7A, 0x9B);};
template<> struct uuid<Windows::UI::Composition::Interactions::ICompositionConditionalValueStatics> { define_guid(0x90C4B72, 0x8467, 0x4D0A, 0x90, 0x65, 0xAC, 0x46, 0xB8, 0xA, 0x55, 0x22);};
template<> struct uuid<Windows::UI::Composition::Interactions::ICompositionInteractionSource> { define_guid(0x43B2431, 0x6E3, 0x495A, 0xBA, 0x54, 0x40, 0x9F, 0x0, 0x17, 0xFA, 0xC0);};
template<> struct uuid<Windows::UI::Composition::Interactions::ICompositionInteractionSourceCollection> { define_guid(0x1B468E4B, 0xA5BF, 0x47D8, 0xA5, 0x47, 0x38, 0x94, 0x15, 0x5A, 0x15, 0x8C);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTracker> { define_guid(0x2A8E8CB1, 0x1000, 0x4416, 0x83, 0x63, 0xCC, 0x27, 0xFB, 0x87, 0x73, 0x8);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerOwner> { define_guid(0xDB2E8AF3, 0x4DEB, 0x4E53, 0xB2, 0x9C, 0xB0, 0x6C, 0x9F, 0x96, 0xD6, 0x51);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerCustomAnimationStateEnteredArgs> { define_guid(0x8D1C8CF1, 0xD7B0, 0x434C, 0xA5, 0xD2, 0x2D, 0x76, 0x11, 0x86, 0x48, 0x34);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerIdleStateEnteredArgs> { define_guid(0x50012FAA, 0x1510, 0x4142, 0xA1, 0xA5, 0x1, 0x9B, 0x9, 0xF8, 0x85, 0x7B);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaStateEnteredArgs> { define_guid(0x87108CF2, 0xE7FF, 0x4F7D, 0x9F, 0xFD, 0xD7, 0x2F, 0x1E, 0x40, 0x9B, 0x63);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerInteractingStateEnteredArgs> { define_guid(0xA7263939, 0xA17B, 0x4011, 0x99, 0xFD, 0xB5, 0xC2, 0x4F, 0x14, 0x37, 0x48);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerRequestIgnoredArgs> { define_guid(0x80DD82F1, 0xCE25, 0x488F, 0x91, 0xDD, 0xCB, 0x64, 0x55, 0xCC, 0xFF, 0x2E);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerValuesChangedArgs> { define_guid(0xCF1578EF, 0xD3DF, 0x4501, 0xB9, 0xE6, 0xF0, 0x2F, 0xB2, 0x2F, 0x73, 0xD0);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerStatics> { define_guid(0xBBA5D7B7, 0x6590, 0x4498, 0x8D, 0x6C, 0xEB, 0x62, 0xB5, 0x14, 0xC9, 0x2A);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTracker2> { define_guid(0x25769A3E, 0xCE6D, 0x448C, 0x83, 0x86, 0x92, 0x62, 0xD, 0x24, 0x7, 0x56);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTracker3> { define_guid(0xE6C5D7A2, 0x5C4B, 0x42C6, 0x84, 0xB7, 0xF6, 0x94, 0x41, 0xB1, 0x80, 0x91);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaModifier> { define_guid(0xA0E2C920, 0x26B4, 0x4DA2, 0x8B, 0x61, 0x5E, 0x68, 0x39, 0x79, 0xBB, 0xE2);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaNaturalMotion> { define_guid(0x70ACDAAE, 0x27DC, 0x48ED, 0xA3, 0xC3, 0x6D, 0x61, 0xC9, 0xA0, 0x29, 0xD2);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaNaturalMotionStatics> { define_guid(0xCFDA55B0, 0x5E3E, 0x4289, 0x93, 0x2D, 0xEE, 0x5F, 0x50, 0xE7, 0x42, 0x83);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaRestingValue> { define_guid(0x86F7EC09, 0x5096, 0x4170, 0x9C, 0xC8, 0xDF, 0x2F, 0xE1, 0x1, 0xBB, 0x93);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaRestingValueStatics> { define_guid(0x18ED4699, 0x745, 0x4096, 0xBC, 0xAB, 0x3A, 0x4E, 0x99, 0x56, 0x9B, 0xCF);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaMotion> { define_guid(0x4922FDC, 0xF154, 0x4CB8, 0xBF, 0x33, 0xCC, 0x1B, 0xA6, 0x11, 0xE6, 0xDB);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaMotionStatics> { define_guid(0x8CC83DD6, 0xBA7B, 0x431A, 0x84, 0x4B, 0x6E, 0xAC, 0x91, 0x30, 0xF9, 0x9A);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerVector2InertiaModifier> { define_guid(0x87E08AB0, 0x3086, 0x4853, 0xA4, 0xB7, 0x77, 0x88, 0x2A, 0xD5, 0xD7, 0xE3);};
template<> struct uuid<Windows::UI::Composition::Interactions::IVisualInteractionSource> { define_guid(0xCA0E8A86, 0xD8D6, 0x4111, 0xB0, 0x88, 0x70, 0x34, 0x7B, 0xD2, 0xB0, 0xED);};
template<> struct uuid<Windows::UI::Composition::Interactions::IVisualInteractionSourceStatics> { define_guid(0x369965E1, 0x8645, 0x4F75, 0xBA, 0x0, 0x64, 0x79, 0xCD, 0x10, 0xC8, 0xE6);};
template<> struct uuid<Windows::UI::Composition::Interactions::IVisualInteractionSource2> { define_guid(0xAA914893, 0xA73C, 0x414D, 0x80, 0xD0, 0x24, 0x9B, 0xAD, 0x2F, 0xBD, 0x93);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerInertiaModifierFactory> { define_guid(0x993818FE, 0xC94E, 0x4B86, 0x87, 0xF3, 0x92, 0x26, 0x65, 0xBA, 0x46, 0xB9);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerVector2InertiaModifierFactory> { define_guid(0x7401D6C4, 0x6C6D, 0x48DF, 0xBC, 0x3E, 0x17, 0x1E, 0x22, 0x7E, 0x7D, 0x7F);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerVector2InertiaNaturalMotion> { define_guid(0x5F17695C, 0x162D, 0x4C07, 0x94, 0x0, 0xC2, 0x82, 0xB2, 0x82, 0x76, 0xCA);};
template<> struct uuid<Windows::UI::Composition::Interactions::IInteractionTrackerVector2InertiaNaturalMotionStatics> { define_guid(0x82001A48, 0x9C0, 0x434F, 0x81, 0x89, 0x14, 0x1C, 0x66, 0xDF, 0x36, 0x2F);};
template<> struct uuid<Windows::UI::Composition::Interactions::IVisualInteractionSourceObjectFactory> { define_guid(0xB2CA917C, 0xE98A, 0x41F2, 0xB3, 0xC9, 0x89, 0x1C, 0x92, 0x66, 0xC8, 0xF6);};

// types

namespace Windows { namespace UI { namespace Composition { namespace Interactions {

// ICompositionConditionalValue
struct ICompositionConditionalValue_raw : IInspectable {
	virtual STDMETHODIMP _get_Condition(ExpressionAnimation* *value);
	virtual STDMETHODIMP _put_Condition(ExpressionAnimation* value);
	virtual STDMETHODIMP _get_Value(ExpressionAnimation* *value);
	virtual STDMETHODIMP _put_Value(ExpressionAnimation* value);
};
template<typename X> struct ICompositionConditionalValue_adaptor : X {
	union {
		struct : property {
			ptr<ExpressionAnimation> get() { ExpressionAnimation* value; hrcheck(enc(&ICompositionConditionalValue_adaptor::Condition)->_get_Condition(&value)); return from_abi(value); }
			ptr<ExpressionAnimation> operator()() { return get(); }
			operator ptr<ExpressionAnimation> () { return get(); }
			ptr<ExpressionAnimation> operator->() { return get(); }
			void put(pptr<ExpressionAnimation> value) { hrcheck(enc(&ICompositionConditionalValue_adaptor::Condition)->_put_Condition(value)); }
			void operator=(pptr<ExpressionAnimation> value) { put(value); }
			void operator()(pptr<ExpressionAnimation> value) { put(value); }
		} Condition;
		struct : property {
			ptr<ExpressionAnimation> get() { ExpressionAnimation* value; hrcheck(enc(&ICompositionConditionalValue_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			ptr<ExpressionAnimation> operator()() { return get(); }
			operator ptr<ExpressionAnimation> () { return get(); }
			ptr<ExpressionAnimation> operator->() { return get(); }
			void put(pptr<ExpressionAnimation> value) { hrcheck(enc(&ICompositionConditionalValue_adaptor::Value)->_put_Value(value)); }
			void operator=(pptr<ExpressionAnimation> value) { put(value); }
			void operator()(pptr<ExpressionAnimation> value) { put(value); }
		} Value;
	};
	ICompositionConditionalValue_adaptor() {}
};
template<typename X> struct adapt<ICompositionConditionalValue, X> : Windows::UI::Composition::Interactions::ICompositionConditionalValue_adaptor<X> { typedef adapt ICompositionConditionalValue; };
struct ICompositionConditionalValue : ICompositionConditionalValue_raw, generate<ICompositionConditionalValue> {};

// ICompositionConditionalValueStatics
struct ICompositionConditionalValueStatics : IInspectable {
	virtual STDMETHODIMP _Create(Compositor* compositor, CompositionConditionalValue* *result);
};

// ICompositionInteractionSource
struct ICompositionInteractionSource : IInspectable, generate<ICompositionInteractionSource> {};

// ICompositionInteractionSourceCollection
struct ICompositionInteractionSourceCollection_raw : IInspectable {
	virtual STDMETHODIMP _get_Count(int *value);
	virtual STDMETHODIMP _Add(ICompositionInteractionSource* value);
	virtual STDMETHODIMP _Remove(ICompositionInteractionSource* value);
	virtual STDMETHODIMP _RemoveAll();
};
template<typename X> struct ICompositionInteractionSourceCollection_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&ICompositionInteractionSourceCollection_adaptor::Count)->_get_Count(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} Count;
	};
	void Add(pptr<ICompositionInteractionSource> value) { hrcheck(X::get()->_Add(value)); }
	void Remove(pptr<ICompositionInteractionSource> value) { hrcheck(X::get()->_Remove(value)); }
	void RemoveAll() { hrcheck(X::get()->_RemoveAll()); }
	ICompositionInteractionSourceCollection_adaptor() {}
};
template<typename X> struct adapt<ICompositionInteractionSourceCollection, X> : Windows::UI::Composition::Interactions::ICompositionInteractionSourceCollection_adaptor<X> { typedef adapt ICompositionInteractionSourceCollection; };
struct ICompositionInteractionSourceCollection : ICompositionInteractionSourceCollection_raw, generate<ICompositionInteractionSourceCollection> {};

// IInteractionTracker
struct IInteractionTracker_raw : IInspectable {
	virtual STDMETHODIMP _get_InteractionSources(CompositionInteractionSourceCollection* *value);
	virtual STDMETHODIMP _get_IsPositionRoundingSuggested(bool *value);
	virtual STDMETHODIMP _get_MaxPosition(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_MaxPosition(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_MaxScale(float *value);
	virtual STDMETHODIMP _put_MaxScale(float value);
	virtual STDMETHODIMP _get_MinPosition(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_MinPosition(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_MinScale(float *value);
	virtual STDMETHODIMP _put_MinScale(float value);
	virtual STDMETHODIMP _get_NaturalRestingPosition(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _get_NaturalRestingScale(float *value);
	virtual STDMETHODIMP _get_Owner(IInteractionTrackerOwner* *value);
	virtual STDMETHODIMP _get_Position(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _get_PositionInertiaDecayRate(Foundation::IReference<Foundation::Numerics::Vector3>* *value);
	virtual STDMETHODIMP _put_PositionInertiaDecayRate(Foundation::IReference<Foundation::Numerics::Vector3>* value);
	virtual STDMETHODIMP _get_PositionVelocityInPixelsPerSecond(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _get_Scale(float *value);
	virtual STDMETHODIMP _get_ScaleInertiaDecayRate(Foundation::IReference<float>* *value);
	virtual STDMETHODIMP _put_ScaleInertiaDecayRate(Foundation::IReference<float>* value);
	virtual STDMETHODIMP _get_ScaleVelocityInPercentPerSecond(float *value);
	virtual STDMETHODIMP _AdjustPositionXIfGreaterThanThreshold(float adjustment, float positionThreshold);
	virtual STDMETHODIMP _AdjustPositionYIfGreaterThanThreshold(float adjustment, float positionThreshold);
	virtual STDMETHODIMP _ConfigurePositionXInertiaModifiers(Foundation::Collections::IIterable<InteractionTrackerInertiaModifier*>* modifiers);
	virtual STDMETHODIMP _ConfigurePositionYInertiaModifiers(Foundation::Collections::IIterable<InteractionTrackerInertiaModifier*>* modifiers);
	virtual STDMETHODIMP _ConfigureScaleInertiaModifiers(Foundation::Collections::IIterable<InteractionTrackerInertiaModifier*>* modifiers);
	virtual STDMETHODIMP _TryUpdatePosition(Foundation::Numerics::Vector3 value, int *requestId);
	virtual STDMETHODIMP _TryUpdatePositionBy(Foundation::Numerics::Vector3 amount, int *requestId);
	virtual STDMETHODIMP _TryUpdatePositionWithAnimation(CompositionAnimation* animation, int *requestId);
	virtual STDMETHODIMP _TryUpdatePositionWithAdditionalVelocity(Foundation::Numerics::Vector3 velocityInPixelsPerSecond, int *requestId);
	virtual STDMETHODIMP _TryUpdateScale(float value, Foundation::Numerics::Vector3 centerPoint, int *requestId);
	virtual STDMETHODIMP _TryUpdateScaleWithAnimation(CompositionAnimation* animation, Foundation::Numerics::Vector3 centerPoint, int *requestId);
	virtual STDMETHODIMP _TryUpdateScaleWithAdditionalVelocity(float velocityInPercentPerSecond, Foundation::Numerics::Vector3 centerPoint, int *requestId);
};
template<typename X> struct IInteractionTracker_adaptor : X {
	union {
		struct : property {
			ptr<CompositionInteractionSourceCollection> get() { CompositionInteractionSourceCollection* value; hrcheck(enc(&IInteractionTracker_adaptor::InteractionSources)->_get_InteractionSources(&value)); return from_abi(value); }
			ptr<CompositionInteractionSourceCollection> operator()() { return get(); }
			operator ptr<CompositionInteractionSourceCollection> () { return get(); }
			ptr<CompositionInteractionSourceCollection> operator->() { return get(); }
		} InteractionSources;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IInteractionTracker_adaptor::IsPositionRoundingSuggested)->_get_IsPositionRoundingSuggested(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsPositionRoundingSuggested;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IInteractionTracker_adaptor::MaxPosition)->_get_MaxPosition(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IInteractionTracker_adaptor::MaxPosition)->_put_MaxPosition(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} MaxPosition;
		struct : property {
			float get() { float value; hrcheck(enc(&IInteractionTracker_adaptor::MaxScale)->_get_MaxScale(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IInteractionTracker_adaptor::MaxScale)->_put_MaxScale(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} MaxScale;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IInteractionTracker_adaptor::MinPosition)->_get_MinPosition(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IInteractionTracker_adaptor::MinPosition)->_put_MinPosition(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} MinPosition;
		struct : property {
			float get() { float value; hrcheck(enc(&IInteractionTracker_adaptor::MinScale)->_get_MinScale(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IInteractionTracker_adaptor::MinScale)->_put_MinScale(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} MinScale;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IInteractionTracker_adaptor::NaturalRestingPosition)->_get_NaturalRestingPosition(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
		} NaturalRestingPosition;
		struct : property {
			float get() { float value; hrcheck(enc(&IInteractionTracker_adaptor::NaturalRestingScale)->_get_NaturalRestingScale(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} NaturalRestingScale;
		struct : property {
			ptr<IInteractionTrackerOwner> get() { IInteractionTrackerOwner* value; hrcheck(enc(&IInteractionTracker_adaptor::Owner)->_get_Owner(&value)); return from_abi(value); }
			ptr<IInteractionTrackerOwner> operator()() { return get(); }
			operator ptr<IInteractionTrackerOwner> () { return get(); }
			ptr<IInteractionTrackerOwner> operator->() { return get(); }
		} Owner;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IInteractionTracker_adaptor::Position)->_get_Position(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
		} Position;
		struct : property {
			ptr<Foundation::IReference<Foundation::Numerics::Vector3>> get() { Foundation::IReference<Foundation::Numerics::Vector3>* value; hrcheck(enc(&IInteractionTracker_adaptor::PositionInertiaDecayRate)->_get_PositionInertiaDecayRate(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::Numerics::Vector3>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::Numerics::Vector3>> () { return get(); }
			ptr<Foundation::IReference<Foundation::Numerics::Vector3>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::Numerics::Vector3>> value) { hrcheck(enc(&IInteractionTracker_adaptor::PositionInertiaDecayRate)->_put_PositionInertiaDecayRate(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::Numerics::Vector3>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::Numerics::Vector3>> value) { put(to_abi(value)); }
		} PositionInertiaDecayRate;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IInteractionTracker_adaptor::PositionVelocityInPixelsPerSecond)->_get_PositionVelocityInPixelsPerSecond(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
		} PositionVelocityInPixelsPerSecond;
		struct : property {
			float get() { float value; hrcheck(enc(&IInteractionTracker_adaptor::Scale)->_get_Scale(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} Scale;
		struct : property {
			ptr<Foundation::IReference<float>> get() { Foundation::IReference<float>* value; hrcheck(enc(&IInteractionTracker_adaptor::ScaleInertiaDecayRate)->_get_ScaleInertiaDecayRate(&value)); return from_abi(value); }
			ptr<Foundation::IReference<float>> operator()() { return get(); }
			operator ptr<Foundation::IReference<float>> () { return get(); }
			ptr<Foundation::IReference<float>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<float>> value) { hrcheck(enc(&IInteractionTracker_adaptor::ScaleInertiaDecayRate)->_put_ScaleInertiaDecayRate(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<float>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<float>> value) { put(to_abi(value)); }
		} ScaleInertiaDecayRate;
		struct : property {
			float get() { float value; hrcheck(enc(&IInteractionTracker_adaptor::ScaleVelocityInPercentPerSecond)->_get_ScaleVelocityInPercentPerSecond(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} ScaleVelocityInPercentPerSecond;
	};
	void AdjustPositionXIfGreaterThanThreshold(float adjustment, float positionThreshold) { hrcheck(X::get()->_AdjustPositionXIfGreaterThanThreshold(adjustment, positionThreshold)); }
	void AdjustPositionYIfGreaterThanThreshold(float adjustment, float positionThreshold) { hrcheck(X::get()->_AdjustPositionYIfGreaterThanThreshold(adjustment, positionThreshold)); }
	void ConfigurePositionXInertiaModifiers(pptr<Foundation::Collections::IIterable<ptr<InteractionTrackerInertiaModifier>>> modifiers) { hrcheck(X::get()->_ConfigurePositionXInertiaModifiers(to_abi(modifiers))); }
	void ConfigurePositionYInertiaModifiers(pptr<Foundation::Collections::IIterable<ptr<InteractionTrackerInertiaModifier>>> modifiers) { hrcheck(X::get()->_ConfigurePositionYInertiaModifiers(to_abi(modifiers))); }
	void ConfigureScaleInertiaModifiers(pptr<Foundation::Collections::IIterable<ptr<InteractionTrackerInertiaModifier>>> modifiers) { hrcheck(X::get()->_ConfigureScaleInertiaModifiers(to_abi(modifiers))); }
	int TryUpdatePosition(const Foundation::Numerics::Vector3& value) { int requestId; hrcheck(X::get()->_TryUpdatePosition(value, &requestId)); return requestId; }
	int TryUpdatePositionBy(const Foundation::Numerics::Vector3& amount) { int requestId; hrcheck(X::get()->_TryUpdatePositionBy(amount, &requestId)); return requestId; }
	int TryUpdatePositionWithAnimation(pptr<CompositionAnimation> animation) { int requestId; hrcheck(X::get()->_TryUpdatePositionWithAnimation(animation, &requestId)); return requestId; }
	int TryUpdatePositionWithAdditionalVelocity(const Foundation::Numerics::Vector3& velocityInPixelsPerSecond) { int requestId; hrcheck(X::get()->_TryUpdatePositionWithAdditionalVelocity(velocityInPixelsPerSecond, &requestId)); return requestId; }
	int TryUpdateScale(float value, const Foundation::Numerics::Vector3& centerPoint) { int requestId; hrcheck(X::get()->_TryUpdateScale(value, centerPoint, &requestId)); return requestId; }
	int TryUpdateScaleWithAnimation(pptr<CompositionAnimation> animation, const Foundation::Numerics::Vector3& centerPoint) { int requestId; hrcheck(X::get()->_TryUpdateScaleWithAnimation(animation, centerPoint, &requestId)); return requestId; }
	int TryUpdateScaleWithAdditionalVelocity(float velocityInPercentPerSecond, const Foundation::Numerics::Vector3& centerPoint) { int requestId; hrcheck(X::get()->_TryUpdateScaleWithAdditionalVelocity(velocityInPercentPerSecond, centerPoint, &requestId)); return requestId; }
	IInteractionTracker_adaptor() {}
};
template<typename X> struct adapt<IInteractionTracker, X> : Windows::UI::Composition::Interactions::IInteractionTracker_adaptor<X> { typedef adapt IInteractionTracker; };
struct IInteractionTracker : IInteractionTracker_raw, generate<IInteractionTracker> {};

// IInteractionTrackerOwner
struct IInteractionTrackerOwner_raw : IInspectable {
	virtual STDMETHODIMP _CustomAnimationStateEntered(InteractionTracker* sender, InteractionTrackerCustomAnimationStateEnteredArgs* args) = 0;
	virtual STDMETHODIMP _IdleStateEntered(InteractionTracker* sender, InteractionTrackerIdleStateEnteredArgs* args) = 0;
	virtual STDMETHODIMP _InertiaStateEntered(InteractionTracker* sender, InteractionTrackerInertiaStateEnteredArgs* args) = 0;
	virtual STDMETHODIMP _InteractingStateEntered(InteractionTracker* sender, InteractionTrackerInteractingStateEnteredArgs* args) = 0;
	virtual STDMETHODIMP _RequestIgnored(InteractionTracker* sender, InteractionTrackerRequestIgnoredArgs* args) = 0;
	virtual STDMETHODIMP _ValuesChanged(InteractionTracker* sender, InteractionTrackerValuesChangedArgs* args) = 0;
};
template<typename X> struct IInteractionTrackerOwner_adaptor : X {
	void CustomAnimationStateEntered(pptr<InteractionTracker> sender, pptr<InteractionTrackerCustomAnimationStateEnteredArgs> args) { hrcheck(X::get()->_CustomAnimationStateEntered(sender, args)); }
	void IdleStateEntered(pptr<InteractionTracker> sender, pptr<InteractionTrackerIdleStateEnteredArgs> args) { hrcheck(X::get()->_IdleStateEntered(sender, args)); }
	void InertiaStateEntered(pptr<InteractionTracker> sender, pptr<InteractionTrackerInertiaStateEnteredArgs> args) { hrcheck(X::get()->_InertiaStateEntered(sender, args)); }
	void InteractingStateEntered(pptr<InteractionTracker> sender, pptr<InteractionTrackerInteractingStateEnteredArgs> args) { hrcheck(X::get()->_InteractingStateEntered(sender, args)); }
	void RequestIgnored(pptr<InteractionTracker> sender, pptr<InteractionTrackerRequestIgnoredArgs> args) { hrcheck(X::get()->_RequestIgnored(sender, args)); }
	void ValuesChanged(pptr<InteractionTracker> sender, pptr<InteractionTrackerValuesChangedArgs> args) { hrcheck(X::get()->_ValuesChanged(sender, args)); }
};
template<typename X> struct adapt<IInteractionTrackerOwner, X> : Windows::UI::Composition::Interactions::IInteractionTrackerOwner_adaptor<X> { typedef adapt IInteractionTrackerOwner; };
template<typename X> struct IInteractionTrackerOwner_unadaptor : X {
	STDMETHODIMP _CustomAnimationStateEntered(InteractionTracker* sender, InteractionTrackerCustomAnimationStateEnteredArgs* args) { return hrtry([&, this] { X::get()->CustomAnimationStateEntered(sender, args); }); }
	STDMETHODIMP _IdleStateEntered(InteractionTracker* sender, InteractionTrackerIdleStateEnteredArgs* args) { return hrtry([&, this] { X::get()->IdleStateEntered(sender, args); }); }
	STDMETHODIMP _InertiaStateEntered(InteractionTracker* sender, InteractionTrackerInertiaStateEnteredArgs* args) { return hrtry([&, this] { X::get()->InertiaStateEntered(sender, args); }); }
	STDMETHODIMP _InteractingStateEntered(InteractionTracker* sender, InteractionTrackerInteractingStateEnteredArgs* args) { return hrtry([&, this] { X::get()->InteractingStateEntered(sender, args); }); }
	STDMETHODIMP _RequestIgnored(InteractionTracker* sender, InteractionTrackerRequestIgnoredArgs* args) { return hrtry([&, this] { X::get()->RequestIgnored(sender, args); }); }
	STDMETHODIMP _ValuesChanged(InteractionTracker* sender, InteractionTrackerValuesChangedArgs* args) { return hrtry([&, this] { X::get()->ValuesChanged(sender, args); }); }
};
template<typename X> struct unadapt<IInteractionTrackerOwner, X> : Windows::UI::Composition::Interactions::IInteractionTrackerOwner_unadaptor<X> {};
struct IInteractionTrackerOwner : IInteractionTrackerOwner_raw, generate<IInteractionTrackerOwner> {};

// IInteractionTrackerCustomAnimationStateEnteredArgs
struct IInteractionTrackerCustomAnimationStateEnteredArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_RequestId(int *value);
};
template<typename X> struct IInteractionTrackerCustomAnimationStateEnteredArgs_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IInteractionTrackerCustomAnimationStateEnteredArgs_adaptor::RequestId)->_get_RequestId(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} RequestId;
	};
	IInteractionTrackerCustomAnimationStateEnteredArgs_adaptor() {}
};
template<typename X> struct adapt<IInteractionTrackerCustomAnimationStateEnteredArgs, X> : Windows::UI::Composition::Interactions::IInteractionTrackerCustomAnimationStateEnteredArgs_adaptor<X> { typedef adapt IInteractionTrackerCustomAnimationStateEnteredArgs; };
struct IInteractionTrackerCustomAnimationStateEnteredArgs : IInteractionTrackerCustomAnimationStateEnteredArgs_raw, generate<IInteractionTrackerCustomAnimationStateEnteredArgs> {};

// InteractionTrackerCustomAnimationStateEnteredArgs
template<typename X> struct statics<InteractionTrackerCustomAnimationStateEnteredArgs, X> : X {
	typedef typename X::root_type InteractionTrackerCustomAnimationStateEnteredArgs;
};
struct InteractionTrackerCustomAnimationStateEnteredArgs : generate<InteractionTrackerCustomAnimationStateEnteredArgs> {};

// IInteractionTrackerIdleStateEnteredArgs
struct IInteractionTrackerIdleStateEnteredArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_RequestId(int *value);
};
template<typename X> struct IInteractionTrackerIdleStateEnteredArgs_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IInteractionTrackerIdleStateEnteredArgs_adaptor::RequestId)->_get_RequestId(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} RequestId;
	};
	IInteractionTrackerIdleStateEnteredArgs_adaptor() {}
};
template<typename X> struct adapt<IInteractionTrackerIdleStateEnteredArgs, X> : Windows::UI::Composition::Interactions::IInteractionTrackerIdleStateEnteredArgs_adaptor<X> { typedef adapt IInteractionTrackerIdleStateEnteredArgs; };
struct IInteractionTrackerIdleStateEnteredArgs : IInteractionTrackerIdleStateEnteredArgs_raw, generate<IInteractionTrackerIdleStateEnteredArgs> {};

// InteractionTrackerIdleStateEnteredArgs
template<typename X> struct statics<InteractionTrackerIdleStateEnteredArgs, X> : X {
	typedef typename X::root_type InteractionTrackerIdleStateEnteredArgs;
};
struct InteractionTrackerIdleStateEnteredArgs : generate<InteractionTrackerIdleStateEnteredArgs> {};

// IInteractionTrackerInertiaStateEnteredArgs
struct IInteractionTrackerInertiaStateEnteredArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ModifiedRestingPosition(Foundation::IReference<Foundation::Numerics::Vector3>* *value);
	virtual STDMETHODIMP _get_ModifiedRestingScale(Foundation::IReference<float>* *value);
	virtual STDMETHODIMP _get_NaturalRestingPosition(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _get_NaturalRestingScale(float *value);
	virtual STDMETHODIMP _get_PositionVelocityInPixelsPerSecond(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _get_RequestId(int *value);
	virtual STDMETHODIMP _get_ScaleVelocityInPercentPerSecond(float *value);
};
template<typename X> struct IInteractionTrackerInertiaStateEnteredArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Foundation::Numerics::Vector3>> get() { Foundation::IReference<Foundation::Numerics::Vector3>* value; hrcheck(enc(&IInteractionTrackerInertiaStateEnteredArgs_adaptor::ModifiedRestingPosition)->_get_ModifiedRestingPosition(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::Numerics::Vector3>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::Numerics::Vector3>> () { return get(); }
			ptr<Foundation::IReference<Foundation::Numerics::Vector3>> operator->() { return get(); }
		} ModifiedRestingPosition;
		struct : property {
			ptr<Foundation::IReference<float>> get() { Foundation::IReference<float>* value; hrcheck(enc(&IInteractionTrackerInertiaStateEnteredArgs_adaptor::ModifiedRestingScale)->_get_ModifiedRestingScale(&value)); return from_abi(value); }
			ptr<Foundation::IReference<float>> operator()() { return get(); }
			operator ptr<Foundation::IReference<float>> () { return get(); }
			ptr<Foundation::IReference<float>> operator->() { return get(); }
		} ModifiedRestingScale;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IInteractionTrackerInertiaStateEnteredArgs_adaptor::NaturalRestingPosition)->_get_NaturalRestingPosition(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
		} NaturalRestingPosition;
		struct : property {
			float get() { float value; hrcheck(enc(&IInteractionTrackerInertiaStateEnteredArgs_adaptor::NaturalRestingScale)->_get_NaturalRestingScale(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} NaturalRestingScale;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IInteractionTrackerInertiaStateEnteredArgs_adaptor::PositionVelocityInPixelsPerSecond)->_get_PositionVelocityInPixelsPerSecond(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
		} PositionVelocityInPixelsPerSecond;
		struct : property {
			int get() { int value; hrcheck(enc(&IInteractionTrackerInertiaStateEnteredArgs_adaptor::RequestId)->_get_RequestId(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} RequestId;
		struct : property {
			float get() { float value; hrcheck(enc(&IInteractionTrackerInertiaStateEnteredArgs_adaptor::ScaleVelocityInPercentPerSecond)->_get_ScaleVelocityInPercentPerSecond(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} ScaleVelocityInPercentPerSecond;
	};
	IInteractionTrackerInertiaStateEnteredArgs_adaptor() {}
};
template<typename X> struct adapt<IInteractionTrackerInertiaStateEnteredArgs, X> : Windows::UI::Composition::Interactions::IInteractionTrackerInertiaStateEnteredArgs_adaptor<X> { typedef adapt IInteractionTrackerInertiaStateEnteredArgs; };
struct IInteractionTrackerInertiaStateEnteredArgs : IInteractionTrackerInertiaStateEnteredArgs_raw, generate<IInteractionTrackerInertiaStateEnteredArgs> {};

// InteractionTrackerInertiaStateEnteredArgs
template<typename X> struct statics<InteractionTrackerInertiaStateEnteredArgs, X> : X {
	typedef typename X::root_type InteractionTrackerInertiaStateEnteredArgs;
};
struct InteractionTrackerInertiaStateEnteredArgs : generate<InteractionTrackerInertiaStateEnteredArgs> {};

// IInteractionTrackerInteractingStateEnteredArgs
struct IInteractionTrackerInteractingStateEnteredArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_RequestId(int *value);
};
template<typename X> struct IInteractionTrackerInteractingStateEnteredArgs_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IInteractionTrackerInteractingStateEnteredArgs_adaptor::RequestId)->_get_RequestId(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} RequestId;
	};
	IInteractionTrackerInteractingStateEnteredArgs_adaptor() {}
};
template<typename X> struct adapt<IInteractionTrackerInteractingStateEnteredArgs, X> : Windows::UI::Composition::Interactions::IInteractionTrackerInteractingStateEnteredArgs_adaptor<X> { typedef adapt IInteractionTrackerInteractingStateEnteredArgs; };
struct IInteractionTrackerInteractingStateEnteredArgs : IInteractionTrackerInteractingStateEnteredArgs_raw, generate<IInteractionTrackerInteractingStateEnteredArgs> {};

// InteractionTrackerInteractingStateEnteredArgs
template<typename X> struct statics<InteractionTrackerInteractingStateEnteredArgs, X> : X {
	typedef typename X::root_type InteractionTrackerInteractingStateEnteredArgs;
};
struct InteractionTrackerInteractingStateEnteredArgs : generate<InteractionTrackerInteractingStateEnteredArgs> {};

// IInteractionTrackerRequestIgnoredArgs
struct IInteractionTrackerRequestIgnoredArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_RequestId(int *value);
};
template<typename X> struct IInteractionTrackerRequestIgnoredArgs_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IInteractionTrackerRequestIgnoredArgs_adaptor::RequestId)->_get_RequestId(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} RequestId;
	};
	IInteractionTrackerRequestIgnoredArgs_adaptor() {}
};
template<typename X> struct adapt<IInteractionTrackerRequestIgnoredArgs, X> : Windows::UI::Composition::Interactions::IInteractionTrackerRequestIgnoredArgs_adaptor<X> { typedef adapt IInteractionTrackerRequestIgnoredArgs; };
struct IInteractionTrackerRequestIgnoredArgs : IInteractionTrackerRequestIgnoredArgs_raw, generate<IInteractionTrackerRequestIgnoredArgs> {};

// InteractionTrackerRequestIgnoredArgs
template<typename X> struct statics<InteractionTrackerRequestIgnoredArgs, X> : X {
	typedef typename X::root_type InteractionTrackerRequestIgnoredArgs;
};
struct InteractionTrackerRequestIgnoredArgs : generate<InteractionTrackerRequestIgnoredArgs> {};

// IInteractionTrackerValuesChangedArgs
struct IInteractionTrackerValuesChangedArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Position(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _get_RequestId(int *value);
	virtual STDMETHODIMP _get_Scale(float *value);
};
template<typename X> struct IInteractionTrackerValuesChangedArgs_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IInteractionTrackerValuesChangedArgs_adaptor::Position)->_get_Position(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
		} Position;
		struct : property {
			int get() { int value; hrcheck(enc(&IInteractionTrackerValuesChangedArgs_adaptor::RequestId)->_get_RequestId(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} RequestId;
		struct : property {
			float get() { float value; hrcheck(enc(&IInteractionTrackerValuesChangedArgs_adaptor::Scale)->_get_Scale(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} Scale;
	};
	IInteractionTrackerValuesChangedArgs_adaptor() {}
};
template<typename X> struct adapt<IInteractionTrackerValuesChangedArgs, X> : Windows::UI::Composition::Interactions::IInteractionTrackerValuesChangedArgs_adaptor<X> { typedef adapt IInteractionTrackerValuesChangedArgs; };
struct IInteractionTrackerValuesChangedArgs : IInteractionTrackerValuesChangedArgs_raw, generate<IInteractionTrackerValuesChangedArgs> {};

// InteractionTrackerValuesChangedArgs
template<typename X> struct statics<InteractionTrackerValuesChangedArgs, X> : X {
	typedef typename X::root_type InteractionTrackerValuesChangedArgs;
};
struct InteractionTrackerValuesChangedArgs : generate<InteractionTrackerValuesChangedArgs> {};

// IInteractionTrackerStatics
struct IInteractionTrackerStatics : IInspectable {
	virtual STDMETHODIMP _Create(Compositor* compositor, InteractionTracker* *result);
	virtual STDMETHODIMP _CreateWithOwner(Compositor* compositor, IInteractionTrackerOwner* owner, InteractionTracker* *result);
};

// IInteractionTracker2
struct IInteractionTracker2_raw : IInspectable {
	virtual STDMETHODIMP _ConfigureCenterPointXInertiaModifiers(Foundation::Collections::IIterable<CompositionConditionalValue*>* conditionalValues);
	virtual STDMETHODIMP _ConfigureCenterPointYInertiaModifiers(Foundation::Collections::IIterable<CompositionConditionalValue*>* conditionalValues);
};
template<typename X> struct IInteractionTracker2_adaptor : X {
	void ConfigureCenterPointXInertiaModifiers(pptr<Foundation::Collections::IIterable<ptr<CompositionConditionalValue>>> conditionalValues) { hrcheck(X::get()->_ConfigureCenterPointXInertiaModifiers(to_abi(conditionalValues))); }
	void ConfigureCenterPointYInertiaModifiers(pptr<Foundation::Collections::IIterable<ptr<CompositionConditionalValue>>> conditionalValues) { hrcheck(X::get()->_ConfigureCenterPointYInertiaModifiers(to_abi(conditionalValues))); }
};
template<typename X> struct adapt<IInteractionTracker2, X> : Windows::UI::Composition::Interactions::IInteractionTracker2_adaptor<X> { typedef adapt IInteractionTracker2; };
struct IInteractionTracker2 : IInteractionTracker2_raw, generate<IInteractionTracker2> {};

// IInteractionTracker3
struct IInteractionTracker3_raw : IInspectable {
	virtual STDMETHODIMP _ConfigureVector2PositionInertiaModifiers(Foundation::Collections::IIterable<InteractionTrackerVector2InertiaModifier*>* modifiers);
};
template<typename X> struct IInteractionTracker3_adaptor : X {
	void ConfigureVector2PositionInertiaModifiers(pptr<Foundation::Collections::IIterable<ptr<InteractionTrackerVector2InertiaModifier>>> modifiers) { hrcheck(X::get()->_ConfigureVector2PositionInertiaModifiers(to_abi(modifiers))); }
};
template<typename X> struct adapt<IInteractionTracker3, X> : Windows::UI::Composition::Interactions::IInteractionTracker3_adaptor<X> { typedef adapt IInteractionTracker3; };
struct IInteractionTracker3 : IInteractionTracker3_raw, generate<IInteractionTracker3> {};

// IInteractionTrackerInertiaModifier
struct IInteractionTrackerInertiaModifier : IInspectable, generate<IInteractionTrackerInertiaModifier> {};

// IInteractionTrackerInertiaNaturalMotion
struct IInteractionTrackerInertiaNaturalMotion_raw : IInspectable {
	virtual STDMETHODIMP _get_Condition(ExpressionAnimation* *value);
	virtual STDMETHODIMP _put_Condition(ExpressionAnimation* value);
	virtual STDMETHODIMP _get_NaturalMotion(ScalarNaturalMotionAnimation* *value);
	virtual STDMETHODIMP _put_NaturalMotion(ScalarNaturalMotionAnimation* value);
};
template<typename X> struct IInteractionTrackerInertiaNaturalMotion_adaptor : X {
	union {
		struct : property {
			ptr<ExpressionAnimation> get() { ExpressionAnimation* value; hrcheck(enc(&IInteractionTrackerInertiaNaturalMotion_adaptor::Condition)->_get_Condition(&value)); return from_abi(value); }
			ptr<ExpressionAnimation> operator()() { return get(); }
			operator ptr<ExpressionAnimation> () { return get(); }
			ptr<ExpressionAnimation> operator->() { return get(); }
			void put(pptr<ExpressionAnimation> value) { hrcheck(enc(&IInteractionTrackerInertiaNaturalMotion_adaptor::Condition)->_put_Condition(value)); }
			void operator=(pptr<ExpressionAnimation> value) { put(value); }
			void operator()(pptr<ExpressionAnimation> value) { put(value); }
		} Condition;
		struct : property {
			ptr<ScalarNaturalMotionAnimation> get() { ScalarNaturalMotionAnimation* value; hrcheck(enc(&IInteractionTrackerInertiaNaturalMotion_adaptor::NaturalMotion)->_get_NaturalMotion(&value)); return from_abi(value); }
			ptr<ScalarNaturalMotionAnimation> operator()() { return get(); }
			operator ptr<ScalarNaturalMotionAnimation> () { return get(); }
			ptr<ScalarNaturalMotionAnimation> operator->() { return get(); }
			void put(pptr<ScalarNaturalMotionAnimation> value) { hrcheck(enc(&IInteractionTrackerInertiaNaturalMotion_adaptor::NaturalMotion)->_put_NaturalMotion(value)); }
			void operator=(pptr<ScalarNaturalMotionAnimation> value) { put(value); }
			void operator()(pptr<ScalarNaturalMotionAnimation> value) { put(value); }
		} NaturalMotion;
	};
	IInteractionTrackerInertiaNaturalMotion_adaptor() {}
};
template<typename X> struct adapt<IInteractionTrackerInertiaNaturalMotion, X> : Windows::UI::Composition::Interactions::IInteractionTrackerInertiaNaturalMotion_adaptor<X> { typedef adapt IInteractionTrackerInertiaNaturalMotion; };
struct IInteractionTrackerInertiaNaturalMotion : IInteractionTrackerInertiaNaturalMotion_raw, generate<IInteractionTrackerInertiaNaturalMotion> {};

// IInteractionTrackerInertiaNaturalMotionStatics
struct IInteractionTrackerInertiaNaturalMotionStatics : IInspectable {
	virtual STDMETHODIMP _Create(Compositor* compositor, InteractionTrackerInertiaNaturalMotion* *result);
};

// IInteractionTrackerInertiaRestingValue
struct IInteractionTrackerInertiaRestingValue_raw : IInspectable {
	virtual STDMETHODIMP _get_Condition(ExpressionAnimation* *value);
	virtual STDMETHODIMP _put_Condition(ExpressionAnimation* value);
	virtual STDMETHODIMP _get_RestingValue(ExpressionAnimation* *value);
	virtual STDMETHODIMP _put_RestingValue(ExpressionAnimation* value);
};
template<typename X> struct IInteractionTrackerInertiaRestingValue_adaptor : X {
	union {
		struct : property {
			ptr<ExpressionAnimation> get() { ExpressionAnimation* value; hrcheck(enc(&IInteractionTrackerInertiaRestingValue_adaptor::Condition)->_get_Condition(&value)); return from_abi(value); }
			ptr<ExpressionAnimation> operator()() { return get(); }
			operator ptr<ExpressionAnimation> () { return get(); }
			ptr<ExpressionAnimation> operator->() { return get(); }
			void put(pptr<ExpressionAnimation> value) { hrcheck(enc(&IInteractionTrackerInertiaRestingValue_adaptor::Condition)->_put_Condition(value)); }
			void operator=(pptr<ExpressionAnimation> value) { put(value); }
			void operator()(pptr<ExpressionAnimation> value) { put(value); }
		} Condition;
		struct : property {
			ptr<ExpressionAnimation> get() { ExpressionAnimation* value; hrcheck(enc(&IInteractionTrackerInertiaRestingValue_adaptor::RestingValue)->_get_RestingValue(&value)); return from_abi(value); }
			ptr<ExpressionAnimation> operator()() { return get(); }
			operator ptr<ExpressionAnimation> () { return get(); }
			ptr<ExpressionAnimation> operator->() { return get(); }
			void put(pptr<ExpressionAnimation> value) { hrcheck(enc(&IInteractionTrackerInertiaRestingValue_adaptor::RestingValue)->_put_RestingValue(value)); }
			void operator=(pptr<ExpressionAnimation> value) { put(value); }
			void operator()(pptr<ExpressionAnimation> value) { put(value); }
		} RestingValue;
	};
	IInteractionTrackerInertiaRestingValue_adaptor() {}
};
template<typename X> struct adapt<IInteractionTrackerInertiaRestingValue, X> : Windows::UI::Composition::Interactions::IInteractionTrackerInertiaRestingValue_adaptor<X> { typedef adapt IInteractionTrackerInertiaRestingValue; };
struct IInteractionTrackerInertiaRestingValue : IInteractionTrackerInertiaRestingValue_raw, generate<IInteractionTrackerInertiaRestingValue> {};

// IInteractionTrackerInertiaRestingValueStatics
struct IInteractionTrackerInertiaRestingValueStatics : IInspectable {
	virtual STDMETHODIMP _Create(Compositor* compositor, InteractionTrackerInertiaRestingValue* *result);
};

// IInteractionTrackerInertiaMotion
struct IInteractionTrackerInertiaMotion_raw : IInspectable {
	virtual STDMETHODIMP _get_Condition(ExpressionAnimation* *value);
	virtual STDMETHODIMP _put_Condition(ExpressionAnimation* value);
	virtual STDMETHODIMP _get_Motion(ExpressionAnimation* *value);
	virtual STDMETHODIMP _put_Motion(ExpressionAnimation* value);
};
template<typename X> struct IInteractionTrackerInertiaMotion_adaptor : X {
	union {
		struct : property {
			ptr<ExpressionAnimation> get() { ExpressionAnimation* value; hrcheck(enc(&IInteractionTrackerInertiaMotion_adaptor::Condition)->_get_Condition(&value)); return from_abi(value); }
			ptr<ExpressionAnimation> operator()() { return get(); }
			operator ptr<ExpressionAnimation> () { return get(); }
			ptr<ExpressionAnimation> operator->() { return get(); }
			void put(pptr<ExpressionAnimation> value) { hrcheck(enc(&IInteractionTrackerInertiaMotion_adaptor::Condition)->_put_Condition(value)); }
			void operator=(pptr<ExpressionAnimation> value) { put(value); }
			void operator()(pptr<ExpressionAnimation> value) { put(value); }
		} Condition;
		struct : property {
			ptr<ExpressionAnimation> get() { ExpressionAnimation* value; hrcheck(enc(&IInteractionTrackerInertiaMotion_adaptor::Motion)->_get_Motion(&value)); return from_abi(value); }
			ptr<ExpressionAnimation> operator()() { return get(); }
			operator ptr<ExpressionAnimation> () { return get(); }
			ptr<ExpressionAnimation> operator->() { return get(); }
			void put(pptr<ExpressionAnimation> value) { hrcheck(enc(&IInteractionTrackerInertiaMotion_adaptor::Motion)->_put_Motion(value)); }
			void operator=(pptr<ExpressionAnimation> value) { put(value); }
			void operator()(pptr<ExpressionAnimation> value) { put(value); }
		} Motion;
	};
	IInteractionTrackerInertiaMotion_adaptor() {}
};
template<typename X> struct adapt<IInteractionTrackerInertiaMotion, X> : Windows::UI::Composition::Interactions::IInteractionTrackerInertiaMotion_adaptor<X> { typedef adapt IInteractionTrackerInertiaMotion; };
struct IInteractionTrackerInertiaMotion : IInteractionTrackerInertiaMotion_raw, generate<IInteractionTrackerInertiaMotion> {};

// IInteractionTrackerInertiaMotionStatics
struct IInteractionTrackerInertiaMotionStatics : IInspectable {
	virtual STDMETHODIMP _Create(Compositor* compositor, InteractionTrackerInertiaMotion* *result);
};

// IInteractionTrackerVector2InertiaModifier
struct IInteractionTrackerVector2InertiaModifier : IInspectable, generate<IInteractionTrackerVector2InertiaModifier> {};

// IVisualInteractionSource
struct IVisualInteractionSource_raw : IInspectable {
	virtual STDMETHODIMP _get_IsPositionXRailsEnabled(bool *value);
	virtual STDMETHODIMP _put_IsPositionXRailsEnabled(bool value);
	virtual STDMETHODIMP _get_IsPositionYRailsEnabled(bool *value);
	virtual STDMETHODIMP _put_IsPositionYRailsEnabled(bool value);
	virtual STDMETHODIMP _get_ManipulationRedirectionMode(VisualInteractionSourceRedirectionMode *value);
	virtual STDMETHODIMP _put_ManipulationRedirectionMode(VisualInteractionSourceRedirectionMode value);
	virtual STDMETHODIMP _get_PositionXChainingMode(InteractionChainingMode *value);
	virtual STDMETHODIMP _put_PositionXChainingMode(InteractionChainingMode value);
	virtual STDMETHODIMP _get_PositionXSourceMode(InteractionSourceMode *value);
	virtual STDMETHODIMP _put_PositionXSourceMode(InteractionSourceMode value);
	virtual STDMETHODIMP _get_PositionYChainingMode(InteractionChainingMode *value);
	virtual STDMETHODIMP _put_PositionYChainingMode(InteractionChainingMode value);
	virtual STDMETHODIMP _get_PositionYSourceMode(InteractionSourceMode *value);
	virtual STDMETHODIMP _put_PositionYSourceMode(InteractionSourceMode value);
	virtual STDMETHODIMP _get_ScaleChainingMode(InteractionChainingMode *value);
	virtual STDMETHODIMP _put_ScaleChainingMode(InteractionChainingMode value);
	virtual STDMETHODIMP _get_ScaleSourceMode(InteractionSourceMode *value);
	virtual STDMETHODIMP _put_ScaleSourceMode(InteractionSourceMode value);
	virtual STDMETHODIMP _get_Source(Visual* *value);
	virtual STDMETHODIMP _TryRedirectForManipulation(Input::PointerPoint* pointerPoint);
};
template<typename X> struct IVisualInteractionSource_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVisualInteractionSource_adaptor::IsPositionXRailsEnabled)->_get_IsPositionXRailsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVisualInteractionSource_adaptor::IsPositionXRailsEnabled)->_put_IsPositionXRailsEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsPositionXRailsEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVisualInteractionSource_adaptor::IsPositionYRailsEnabled)->_get_IsPositionYRailsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVisualInteractionSource_adaptor::IsPositionYRailsEnabled)->_put_IsPositionYRailsEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsPositionYRailsEnabled;
		struct : property {
			VisualInteractionSourceRedirectionMode get() { VisualInteractionSourceRedirectionMode value; hrcheck(enc(&IVisualInteractionSource_adaptor::ManipulationRedirectionMode)->_get_ManipulationRedirectionMode(&value)); return value; }
			VisualInteractionSourceRedirectionMode operator()() { return get(); }
			operator VisualInteractionSourceRedirectionMode () { return get(); }
			void put(VisualInteractionSourceRedirectionMode value) { hrcheck(enc(&IVisualInteractionSource_adaptor::ManipulationRedirectionMode)->_put_ManipulationRedirectionMode(value)); }
			void operator=(VisualInteractionSourceRedirectionMode value) { put(value); }
			void operator()(VisualInteractionSourceRedirectionMode value) { put(value); }
		} ManipulationRedirectionMode;
		struct : property {
			InteractionChainingMode get() { InteractionChainingMode value; hrcheck(enc(&IVisualInteractionSource_adaptor::PositionXChainingMode)->_get_PositionXChainingMode(&value)); return value; }
			InteractionChainingMode operator()() { return get(); }
			operator InteractionChainingMode () { return get(); }
			void put(InteractionChainingMode value) { hrcheck(enc(&IVisualInteractionSource_adaptor::PositionXChainingMode)->_put_PositionXChainingMode(value)); }
			void operator=(InteractionChainingMode value) { put(value); }
			void operator()(InteractionChainingMode value) { put(value); }
		} PositionXChainingMode;
		struct : property {
			InteractionSourceMode get() { InteractionSourceMode value; hrcheck(enc(&IVisualInteractionSource_adaptor::PositionXSourceMode)->_get_PositionXSourceMode(&value)); return value; }
			InteractionSourceMode operator()() { return get(); }
			operator InteractionSourceMode () { return get(); }
			void put(InteractionSourceMode value) { hrcheck(enc(&IVisualInteractionSource_adaptor::PositionXSourceMode)->_put_PositionXSourceMode(value)); }
			void operator=(InteractionSourceMode value) { put(value); }
			void operator()(InteractionSourceMode value) { put(value); }
		} PositionXSourceMode;
		struct : property {
			InteractionChainingMode get() { InteractionChainingMode value; hrcheck(enc(&IVisualInteractionSource_adaptor::PositionYChainingMode)->_get_PositionYChainingMode(&value)); return value; }
			InteractionChainingMode operator()() { return get(); }
			operator InteractionChainingMode () { return get(); }
			void put(InteractionChainingMode value) { hrcheck(enc(&IVisualInteractionSource_adaptor::PositionYChainingMode)->_put_PositionYChainingMode(value)); }
			void operator=(InteractionChainingMode value) { put(value); }
			void operator()(InteractionChainingMode value) { put(value); }
		} PositionYChainingMode;
		struct : property {
			InteractionSourceMode get() { InteractionSourceMode value; hrcheck(enc(&IVisualInteractionSource_adaptor::PositionYSourceMode)->_get_PositionYSourceMode(&value)); return value; }
			InteractionSourceMode operator()() { return get(); }
			operator InteractionSourceMode () { return get(); }
			void put(InteractionSourceMode value) { hrcheck(enc(&IVisualInteractionSource_adaptor::PositionYSourceMode)->_put_PositionYSourceMode(value)); }
			void operator=(InteractionSourceMode value) { put(value); }
			void operator()(InteractionSourceMode value) { put(value); }
		} PositionYSourceMode;
		struct : property {
			InteractionChainingMode get() { InteractionChainingMode value; hrcheck(enc(&IVisualInteractionSource_adaptor::ScaleChainingMode)->_get_ScaleChainingMode(&value)); return value; }
			InteractionChainingMode operator()() { return get(); }
			operator InteractionChainingMode () { return get(); }
			void put(InteractionChainingMode value) { hrcheck(enc(&IVisualInteractionSource_adaptor::ScaleChainingMode)->_put_ScaleChainingMode(value)); }
			void operator=(InteractionChainingMode value) { put(value); }
			void operator()(InteractionChainingMode value) { put(value); }
		} ScaleChainingMode;
		struct : property {
			InteractionSourceMode get() { InteractionSourceMode value; hrcheck(enc(&IVisualInteractionSource_adaptor::ScaleSourceMode)->_get_ScaleSourceMode(&value)); return value; }
			InteractionSourceMode operator()() { return get(); }
			operator InteractionSourceMode () { return get(); }
			void put(InteractionSourceMode value) { hrcheck(enc(&IVisualInteractionSource_adaptor::ScaleSourceMode)->_put_ScaleSourceMode(value)); }
			void operator=(InteractionSourceMode value) { put(value); }
			void operator()(InteractionSourceMode value) { put(value); }
		} ScaleSourceMode;
		struct : property {
			ptr<Visual> get() { Visual* value; hrcheck(enc(&IVisualInteractionSource_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			ptr<Visual> operator()() { return get(); }
			operator ptr<Visual> () { return get(); }
			ptr<Visual> operator->() { return get(); }
		} Source;
	};
	void TryRedirectForManipulation(pptr<Input::PointerPoint> pointerPoint) { hrcheck(X::get()->_TryRedirectForManipulation(pointerPoint)); }
	IVisualInteractionSource_adaptor() {}
};
template<typename X> struct adapt<IVisualInteractionSource, X> : Windows::UI::Composition::Interactions::IVisualInteractionSource_adaptor<X> { typedef adapt IVisualInteractionSource; };
struct IVisualInteractionSource : IVisualInteractionSource_raw, generate<IVisualInteractionSource> {};

// IVisualInteractionSourceStatics
struct IVisualInteractionSourceStatics : IInspectable {
	virtual STDMETHODIMP _Create(Visual* source, VisualInteractionSource* *result);
};

// IVisualInteractionSource2
struct IVisualInteractionSource2_raw : IInspectable {
	virtual STDMETHODIMP _get_DeltaPosition(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _get_DeltaScale(float *value);
	virtual STDMETHODIMP _get_Position(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _get_PositionVelocity(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _get_Scale(float *value);
	virtual STDMETHODIMP _get_ScaleVelocity(float *value);
	virtual STDMETHODIMP _ConfigureCenterPointXModifiers(Foundation::Collections::IIterable<CompositionConditionalValue*>* conditionalValues);
	virtual STDMETHODIMP _ConfigureCenterPointYModifiers(Foundation::Collections::IIterable<CompositionConditionalValue*>* conditionalValues);
	virtual STDMETHODIMP _ConfigureDeltaPositionXModifiers(Foundation::Collections::IIterable<CompositionConditionalValue*>* conditionalValues);
	virtual STDMETHODIMP _ConfigureDeltaPositionYModifiers(Foundation::Collections::IIterable<CompositionConditionalValue*>* conditionalValues);
	virtual STDMETHODIMP _ConfigureDeltaScaleModifiers(Foundation::Collections::IIterable<CompositionConditionalValue*>* conditionalValues);
};
template<typename X> struct IVisualInteractionSource2_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IVisualInteractionSource2_adaptor::DeltaPosition)->_get_DeltaPosition(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
		} DeltaPosition;
		struct : property {
			float get() { float value; hrcheck(enc(&IVisualInteractionSource2_adaptor::DeltaScale)->_get_DeltaScale(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} DeltaScale;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IVisualInteractionSource2_adaptor::Position)->_get_Position(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
		} Position;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IVisualInteractionSource2_adaptor::PositionVelocity)->_get_PositionVelocity(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
		} PositionVelocity;
		struct : property {
			float get() { float value; hrcheck(enc(&IVisualInteractionSource2_adaptor::Scale)->_get_Scale(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} Scale;
		struct : property {
			float get() { float value; hrcheck(enc(&IVisualInteractionSource2_adaptor::ScaleVelocity)->_get_ScaleVelocity(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} ScaleVelocity;
	};
	void ConfigureCenterPointXModifiers(pptr<Foundation::Collections::IIterable<ptr<CompositionConditionalValue>>> conditionalValues) { hrcheck(X::get()->_ConfigureCenterPointXModifiers(to_abi(conditionalValues))); }
	void ConfigureCenterPointYModifiers(pptr<Foundation::Collections::IIterable<ptr<CompositionConditionalValue>>> conditionalValues) { hrcheck(X::get()->_ConfigureCenterPointYModifiers(to_abi(conditionalValues))); }
	void ConfigureDeltaPositionXModifiers(pptr<Foundation::Collections::IIterable<ptr<CompositionConditionalValue>>> conditionalValues) { hrcheck(X::get()->_ConfigureDeltaPositionXModifiers(to_abi(conditionalValues))); }
	void ConfigureDeltaPositionYModifiers(pptr<Foundation::Collections::IIterable<ptr<CompositionConditionalValue>>> conditionalValues) { hrcheck(X::get()->_ConfigureDeltaPositionYModifiers(to_abi(conditionalValues))); }
	void ConfigureDeltaScaleModifiers(pptr<Foundation::Collections::IIterable<ptr<CompositionConditionalValue>>> conditionalValues) { hrcheck(X::get()->_ConfigureDeltaScaleModifiers(to_abi(conditionalValues))); }
	IVisualInteractionSource2_adaptor() {}
};
template<typename X> struct adapt<IVisualInteractionSource2, X> : Windows::UI::Composition::Interactions::IVisualInteractionSource2_adaptor<X> { typedef adapt IVisualInteractionSource2; };
struct IVisualInteractionSource2 : IVisualInteractionSource2_raw, generate<IVisualInteractionSource2> {};

// IInteractionTrackerInertiaModifierFactory
struct IInteractionTrackerInertiaModifierFactory : IInspectable, generate<IInteractionTrackerInertiaModifierFactory> {};

// IInteractionTrackerVector2InertiaModifierFactory
struct IInteractionTrackerVector2InertiaModifierFactory : IInspectable, generate<IInteractionTrackerVector2InertiaModifierFactory> {};

// IInteractionTrackerVector2InertiaNaturalMotion
struct IInteractionTrackerVector2InertiaNaturalMotion_raw : IInspectable {
	virtual STDMETHODIMP _get_Condition(ExpressionAnimation* *value);
	virtual STDMETHODIMP _put_Condition(ExpressionAnimation* value);
	virtual STDMETHODIMP _get_NaturalMotion(Vector2NaturalMotionAnimation* *value);
	virtual STDMETHODIMP _put_NaturalMotion(Vector2NaturalMotionAnimation* value);
};
template<typename X> struct IInteractionTrackerVector2InertiaNaturalMotion_adaptor : X {
	union {
		struct : property {
			ptr<ExpressionAnimation> get() { ExpressionAnimation* value; hrcheck(enc(&IInteractionTrackerVector2InertiaNaturalMotion_adaptor::Condition)->_get_Condition(&value)); return from_abi(value); }
			ptr<ExpressionAnimation> operator()() { return get(); }
			operator ptr<ExpressionAnimation> () { return get(); }
			ptr<ExpressionAnimation> operator->() { return get(); }
			void put(pptr<ExpressionAnimation> value) { hrcheck(enc(&IInteractionTrackerVector2InertiaNaturalMotion_adaptor::Condition)->_put_Condition(value)); }
			void operator=(pptr<ExpressionAnimation> value) { put(value); }
			void operator()(pptr<ExpressionAnimation> value) { put(value); }
		} Condition;
		struct : property {
			ptr<Vector2NaturalMotionAnimation> get() { Vector2NaturalMotionAnimation* value; hrcheck(enc(&IInteractionTrackerVector2InertiaNaturalMotion_adaptor::NaturalMotion)->_get_NaturalMotion(&value)); return from_abi(value); }
			ptr<Vector2NaturalMotionAnimation> operator()() { return get(); }
			operator ptr<Vector2NaturalMotionAnimation> () { return get(); }
			ptr<Vector2NaturalMotionAnimation> operator->() { return get(); }
			void put(pptr<Vector2NaturalMotionAnimation> value) { hrcheck(enc(&IInteractionTrackerVector2InertiaNaturalMotion_adaptor::NaturalMotion)->_put_NaturalMotion(value)); }
			void operator=(pptr<Vector2NaturalMotionAnimation> value) { put(value); }
			void operator()(pptr<Vector2NaturalMotionAnimation> value) { put(value); }
		} NaturalMotion;
	};
	IInteractionTrackerVector2InertiaNaturalMotion_adaptor() {}
};
template<typename X> struct adapt<IInteractionTrackerVector2InertiaNaturalMotion, X> : Windows::UI::Composition::Interactions::IInteractionTrackerVector2InertiaNaturalMotion_adaptor<X> { typedef adapt IInteractionTrackerVector2InertiaNaturalMotion; };
struct IInteractionTrackerVector2InertiaNaturalMotion : IInteractionTrackerVector2InertiaNaturalMotion_raw, generate<IInteractionTrackerVector2InertiaNaturalMotion> {};

// IInteractionTrackerVector2InertiaNaturalMotionStatics
struct IInteractionTrackerVector2InertiaNaturalMotionStatics : IInspectable {
	virtual STDMETHODIMP _Create(Compositor* compositor, InteractionTrackerVector2InertiaNaturalMotion* *result);
};

// IVisualInteractionSourceObjectFactory
struct IVisualInteractionSourceObjectFactory : IInspectable, generate<IVisualInteractionSourceObjectFactory> {};

// CompositionConditionalValue
template<typename> struct CompositionConditionalValue_statics {
	static ptr<CompositionConditionalValue> Create(pptr<Composition::Compositor> compositor) { CompositionConditionalValue* result; hrcheck(get_activation_factory<CompositionConditionalValue, ICompositionConditionalValueStatics>()->_Create(compositor, &result)); return from_abi(result); }
};

template<typename X> struct statics<CompositionConditionalValue, X> : X, Windows::UI::Composition::Interactions::CompositionConditionalValue_statics<void> {
	typedef typename X::root_type CompositionConditionalValue;
};
struct CompositionConditionalValue : generate<CompositionConditionalValue> {};

// CompositionInteractionSourceCollection
template<typename X> struct statics<CompositionInteractionSourceCollection, X> : X {
	typedef typename X::root_type CompositionInteractionSourceCollection;
};
struct CompositionInteractionSourceCollection : generate<CompositionInteractionSourceCollection> {};

// InteractionTracker
template<typename> struct InteractionTracker_statics {
	static ptr<InteractionTracker> Create(pptr<Composition::Compositor> compositor) { InteractionTracker* result; hrcheck(get_activation_factory<InteractionTracker, IInteractionTrackerStatics>()->_Create(compositor, &result)); return from_abi(result); }
	static ptr<InteractionTracker> CreateWithOwner(pptr<Composition::Compositor> compositor, pptr<IInteractionTrackerOwner> owner) { InteractionTracker* result; hrcheck(get_activation_factory<InteractionTracker, IInteractionTrackerStatics>()->_CreateWithOwner(compositor, owner, &result)); return from_abi(result); }
};

template<typename X> struct statics<InteractionTracker, X> : X, Windows::UI::Composition::Interactions::InteractionTracker_statics<void> {
	typedef typename X::root_type InteractionTracker;
};
struct InteractionTracker : generate<InteractionTracker> {};

// InteractionTrackerInertiaModifier
template<typename X> struct statics<InteractionTrackerInertiaModifier, X> : X {
	typedef typename X::root_type InteractionTrackerInertiaModifier;
};
struct InteractionTrackerInertiaModifier : generate<InteractionTrackerInertiaModifier> {};

// InteractionTrackerVector2InertiaModifier
template<typename X> struct statics<InteractionTrackerVector2InertiaModifier, X> : X {
	typedef typename X::root_type InteractionTrackerVector2InertiaModifier;
};
struct InteractionTrackerVector2InertiaModifier : generate<InteractionTrackerVector2InertiaModifier> {};

// InteractionTrackerInertiaNaturalMotion
template<typename> struct InteractionTrackerInertiaNaturalMotion_statics {
	static ptr<InteractionTrackerInertiaNaturalMotion> Create(pptr<Composition::Compositor> compositor) { InteractionTrackerInertiaNaturalMotion* result; hrcheck(get_activation_factory<InteractionTrackerInertiaNaturalMotion, IInteractionTrackerInertiaNaturalMotionStatics>()->_Create(compositor, &result)); return from_abi(result); }
};

template<typename X> struct statics<InteractionTrackerInertiaNaturalMotion, X> : X, Windows::UI::Composition::Interactions::InteractionTrackerInertiaNaturalMotion_statics<void> {
	typedef typename X::root_type InteractionTrackerInertiaNaturalMotion;
};
struct InteractionTrackerInertiaNaturalMotion : generate<InteractionTrackerInertiaNaturalMotion> {};

// InteractionTrackerInertiaRestingValue
template<typename> struct InteractionTrackerInertiaRestingValue_statics {
	static ptr<InteractionTrackerInertiaRestingValue> Create(pptr<Composition::Compositor> compositor) { InteractionTrackerInertiaRestingValue* result; hrcheck(get_activation_factory<InteractionTrackerInertiaRestingValue, IInteractionTrackerInertiaRestingValueStatics>()->_Create(compositor, &result)); return from_abi(result); }
};

template<typename X> struct statics<InteractionTrackerInertiaRestingValue, X> : X, Windows::UI::Composition::Interactions::InteractionTrackerInertiaRestingValue_statics<void> {
	typedef typename X::root_type InteractionTrackerInertiaRestingValue;
};
struct InteractionTrackerInertiaRestingValue : generate<InteractionTrackerInertiaRestingValue> {};

// InteractionTrackerInertiaMotion
template<typename> struct InteractionTrackerInertiaMotion_statics {
	static ptr<InteractionTrackerInertiaMotion> Create(pptr<Composition::Compositor> compositor) { InteractionTrackerInertiaMotion* result; hrcheck(get_activation_factory<InteractionTrackerInertiaMotion, IInteractionTrackerInertiaMotionStatics>()->_Create(compositor, &result)); return from_abi(result); }
};

template<typename X> struct statics<InteractionTrackerInertiaMotion, X> : X, Windows::UI::Composition::Interactions::InteractionTrackerInertiaMotion_statics<void> {
	typedef typename X::root_type InteractionTrackerInertiaMotion;
};
struct InteractionTrackerInertiaMotion : generate<InteractionTrackerInertiaMotion> {};

// VisualInteractionSource
template<typename> struct VisualInteractionSource_statics {
	static ptr<VisualInteractionSource> Create(pptr<Visual> source) { VisualInteractionSource* result; hrcheck(get_activation_factory<VisualInteractionSource, IVisualInteractionSourceStatics>()->_Create(source, &result)); return from_abi(result); }
};

template<typename X> struct statics<VisualInteractionSource, X> : X, Windows::UI::Composition::Interactions::VisualInteractionSource_statics<void> {
	typedef typename X::root_type VisualInteractionSource;
};
struct VisualInteractionSource : generate<VisualInteractionSource> {};

// InteractionTrackerVector2InertiaNaturalMotion
template<typename> struct InteractionTrackerVector2InertiaNaturalMotion_statics {
	static ptr<InteractionTrackerVector2InertiaNaturalMotion> Create(pptr<Composition::Compositor> compositor) { InteractionTrackerVector2InertiaNaturalMotion* result; hrcheck(get_activation_factory<InteractionTrackerVector2InertiaNaturalMotion, IInteractionTrackerVector2InertiaNaturalMotionStatics>()->_Create(compositor, &result)); return from_abi(result); }
};

template<typename X> struct statics<InteractionTrackerVector2InertiaNaturalMotion, X> : X, Windows::UI::Composition::Interactions::InteractionTrackerVector2InertiaNaturalMotion_statics<void> {
	typedef typename X::root_type InteractionTrackerVector2InertiaNaturalMotion;
};
struct InteractionTrackerVector2InertiaNaturalMotion : generate<InteractionTrackerVector2InertiaNaturalMotion> {};
}}}}
} // namespace iso_winrt
