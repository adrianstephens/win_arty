#pragma once
// generated by isopod tools
// namespaces:
// Windows.UI.Xaml.Media

#include "Windows.UI.Xaml.Media.0.h"
#include "Windows.Media.Playback.0.h"
#include "Windows.UI.0.h"
#include "Windows.UI.Xaml.Media.Media3D.0.h"
#include "Windows.Foundation.Collections.h"
#include "Windows.Foundation.h"
#include "Windows.UI.Xaml.h"
#include "Windows.UI.Composition.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Storage { namespace Streams {
struct IInputStream;
struct IRandomAccessStream;
}}
namespace UI { namespace Xaml { namespace Controls { namespace Primitives {
struct Popup;
}}}}}

// defs

template<> struct def<Windows::UI::Xaml::Media::AcrylicBackgroundSource> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::IAcrylicBrush> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IAcrylicBrushStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IAcrylicBrushFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::RevealBrushState> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::IRevealBrush> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IRevealBrushFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IRevealBrushStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IRevealBorderBrushFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IRevealBorderBrush> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IRevealBackgroundBrushFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IRevealBackgroundBrush> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IVisualTreeHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IVisualTreeHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IVisualTreeHelperStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::VisualTreeHelper> : class_type<Platform::Object, Windows::UI::Xaml::Media::IVisualTreeHelper> {};
template<> struct def<Windows::UI::Xaml::Media::MediaElementState> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::IPartialMediaFailureDetectedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IPartialMediaFailureDetectedEventArgs2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::PartialMediaFailureDetectedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Media::IPartialMediaFailureDetectedEventArgs, Windows::UI::Xaml::Media::IPartialMediaFailureDetectedEventArgs2> {};
template<> struct def<Windows::UI::Xaml::Media::AudioCategory> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::AudioDeviceType> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::BrushMappingMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::ColorInterpolationMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::ElementCompositeMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::FastPlayFallbackBehaviour> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::FillRule> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::GradientSpreadMethod> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::MediaCanPlayResponse> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::PenLineCap> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::PenLineJoin> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::Stereo3DVideoPackingMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::Stereo3DVideoRenderMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::Stretch> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::StyleSimulations> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::SweepDirection> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::Matrix> : value_type<double, double, double, double, double, double> {};
template<> struct def<Windows::UI::Xaml::Media::IMatrixHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IMatrixHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::MatrixHelper> : class_type<Platform::Object, Windows::UI::Xaml::Media::IMatrixHelper> {};
template<> struct def<Windows::UI::Xaml::Media::RateChangedRoutedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Media::TimelineMarkerRoutedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Media::IBrushFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IBrushStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IBrush> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Brush> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::IBrush> {};
template<> struct def<Windows::UI::Xaml::Media::BrushCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Media::Brush>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Media::Brush>>> {};
template<> struct def<Windows::UI::Xaml::Media::ICompositionTarget> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ICompositionTargetStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ICompositionTargetStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IRenderedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::RenderedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Media::IRenderedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Media::CompositionTarget> : class_type<Platform::Object, Windows::UI::Xaml::Media::ICompositionTarget> {};
template<> struct def<Windows::UI::Xaml::Media::DoubleCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<double>, Windows::Foundation::Collections::IIterable<double>> {};
template<> struct def<Windows::UI::Xaml::Media::IFontFamily> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IFontFamilyFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IFontFamilyStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::FontFamily> : class_type<Platform::Object, Windows::UI::Xaml::Media::IFontFamily>, composer_type<Windows::UI::Xaml::Media::IFontFamilyFactory> {};
template<> struct def<Windows::UI::Xaml::Media::IMediaTransportControlsThumbnailRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Media::IMediaTransportControlsThumbnailRequestedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Media::PointCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<Windows::Foundation::Point>, Windows::Foundation::Collections::IIterable<Windows::Foundation::Point>> {};
template<> struct def<Windows::UI::Xaml::Media::IRenderingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::RenderingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Media::IRenderingEventArgs> {};
template<> struct def<Windows::UI::Xaml::Media::ITimelineMarkerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ITimelineMarker> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::TimelineMarker> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::ITimelineMarker> {};
template<> struct def<Windows::UI::Xaml::Media::TimelineMarkerCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Media::TimelineMarker>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Media::TimelineMarker>>> {};
template<> struct def<Windows::UI::Xaml::Media::ITransformFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ITransform> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IGeneralTransformFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IGeneralTransformOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IGeneralTransform> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::GeneralTransform> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::IGeneralTransform, Windows::UI::Xaml::Media::IGeneralTransformOverrides> {};
template<> struct def<Windows::UI::Xaml::Media::Transform> : class_type<Windows::UI::Xaml::Media::GeneralTransform, Windows::UI::Xaml::Media::ITransform> {};
template<> struct def<Windows::UI::Xaml::Media::TransformCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Media::Transform>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Media::Transform>>> {};
template<> struct def<Windows::UI::Xaml::Media::ICacheMode> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ICacheModeFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::CacheMode> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::ICacheMode> {};
template<> struct def<Windows::UI::Xaml::Media::IGeometry> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IGeometryStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IGeometryFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Geometry> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::IGeometry> {};
template<> struct def<Windows::UI::Xaml::Media::IImageSource> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IImageSourceFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ImageSource> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::IImageSource> {};
template<> struct def<Windows::UI::Xaml::Media::IPathSegment> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IPathSegmentFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::PathSegment> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::IPathSegment> {};
template<> struct def<Windows::UI::Xaml::Media::IProjection> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IProjectionFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Projection> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::IProjection> {};
template<> struct def<Windows::UI::Xaml::Media::IRateChangedRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::RateChangedRoutedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Media::IRateChangedRoutedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Media::ITimelineMarkerRoutedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::TimelineMarkerRoutedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Media::ITimelineMarkerRoutedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Media::IXamlLight> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IXamlLightOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IXamlLightProtected> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IXamlLightFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IXamlLightStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::XamlLight> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::IXamlLight, Windows::UI::Xaml::Media::IXamlLightOverrides, Windows::UI::Xaml::Media::IXamlLightProtected>, composer_type<Windows::UI::Xaml::Media::IXamlLightFactory> {};
template<> struct def<Windows::UI::Xaml::Media::IBitmapCache> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::BitmapCache> : class_type<Windows::UI::Xaml::Media::CacheMode, Windows::UI::Xaml::Media::IBitmapCache> {};
template<> struct def<Windows::UI::Xaml::Media::IMatrix3DProjection> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IMatrix3DProjectionStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Matrix3DProjection> : class_type<Windows::UI::Xaml::Media::Projection, Windows::UI::Xaml::Media::IMatrix3DProjection> {};
template<> struct def<Windows::UI::Xaml::Media::IPlaneProjection> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IPlaneProjectionStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::PlaneProjection> : class_type<Windows::UI::Xaml::Media::Projection, Windows::UI::Xaml::Media::IPlaneProjection> {};
template<> struct def<Windows::UI::Xaml::Media::IRectangleGeometry> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IRectangleGeometryStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::RectangleGeometry> : class_type<Windows::UI::Xaml::Media::Geometry, Windows::UI::Xaml::Media::IRectangleGeometry> {};
template<> struct def<Windows::UI::Xaml::Media::ISolidColorBrush> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ISolidColorBrushStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ISolidColorBrushFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::SolidColorBrush> : class_type<Windows::UI::Xaml::Media::Brush, Windows::UI::Xaml::Media::ISolidColorBrush>, custom_activators {};
template<> struct def<Windows::UI::Xaml::Media::ICompositeTransform> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ICompositeTransformStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::CompositeTransform> : class_type<Windows::UI::Xaml::Media::Transform, Windows::UI::Xaml::Media::ICompositeTransform> {};
template<> struct def<Windows::UI::Xaml::Media::IMatrixTransform> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IMatrixTransformStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::MatrixTransform> : class_type<Windows::UI::Xaml::Media::Transform, Windows::UI::Xaml::Media::IMatrixTransform> {};
template<> struct def<Windows::UI::Xaml::Media::IRotateTransform> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IRotateTransformStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::RotateTransform> : class_type<Windows::UI::Xaml::Media::Transform, Windows::UI::Xaml::Media::IRotateTransform> {};
template<> struct def<Windows::UI::Xaml::Media::IScaleTransform> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IScaleTransformStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ScaleTransform> : class_type<Windows::UI::Xaml::Media::Transform, Windows::UI::Xaml::Media::IScaleTransform> {};
template<> struct def<Windows::UI::Xaml::Media::ISkewTransform> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ISkewTransformStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::SkewTransform> : class_type<Windows::UI::Xaml::Media::Transform, Windows::UI::Xaml::Media::ISkewTransform> {};
template<> struct def<Windows::UI::Xaml::Media::ITransformGroup> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ITransformGroupStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::TransformGroup> : class_type<Windows::UI::Xaml::Media::Transform, Windows::UI::Xaml::Media::ITransformGroup> {};
template<> struct def<Windows::UI::Xaml::Media::ITranslateTransform> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ITranslateTransformStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::TranslateTransform> : class_type<Windows::UI::Xaml::Media::Transform, Windows::UI::Xaml::Media::ITranslateTransform> {};
template<> struct def<Windows::UI::Xaml::Media::AlignmentX> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::AlignmentY> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::LoadedImageSourceLoadStatus> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::GeometryCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Media::Geometry>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Media::Geometry>>> {};
template<> struct def<Windows::UI::Xaml::Media::IGradientStopStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IGradientStop> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::GradientStop> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::IGradientStop> {};
template<> struct def<Windows::UI::Xaml::Media::GradientStopCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Media::GradientStop>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Media::GradientStop>>> {};
template<> struct def<Windows::UI::Xaml::Media::ILoadedImageSourceLoadCompletedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Media::ILoadedImageSourceLoadCompletedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Media::ILoadedImageSurface> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ILoadedImageSurfaceStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::LoadedImageSurface> : class_type<Platform::Object, Windows::UI::Xaml::Media::ILoadedImageSurface, Windows::Foundation::IClosable, Windows::UI::Composition::ICompositionSurface> {};
template<> struct def<Windows::UI::Xaml::Media::IPathFigureStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IPathFigure> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::PathFigure> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Media::IPathFigure> {};
template<> struct def<Windows::UI::Xaml::Media::PathFigureCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Media::PathFigure>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Media::PathFigure>>> {};
template<> struct def<Windows::UI::Xaml::Media::PathSegmentCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Media::PathSegment>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Media::PathSegment>>> {};
template<> struct def<Windows::UI::Xaml::Media::IArcSegment> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IArcSegmentStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ArcSegment> : class_type<Windows::UI::Xaml::Media::PathSegment, Windows::UI::Xaml::Media::IArcSegment> {};
template<> struct def<Windows::UI::Xaml::Media::IBezierSegment> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IBezierSegmentStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::BezierSegment> : class_type<Windows::UI::Xaml::Media::PathSegment, Windows::UI::Xaml::Media::IBezierSegment> {};
template<> struct def<Windows::UI::Xaml::Media::IEllipseGeometry> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IEllipseGeometryStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::EllipseGeometry> : class_type<Windows::UI::Xaml::Media::Geometry, Windows::UI::Xaml::Media::IEllipseGeometry> {};
template<> struct def<Windows::UI::Xaml::Media::IGeometryGroup> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IGeometryGroupStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::GeometryGroup> : class_type<Windows::UI::Xaml::Media::Geometry, Windows::UI::Xaml::Media::IGeometryGroup> {};
template<> struct def<Windows::UI::Xaml::Media::IGradientBrush> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IGradientBrushStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IGradientBrushFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::GradientBrush> : class_type<Windows::UI::Xaml::Media::Brush, Windows::UI::Xaml::Media::IGradientBrush> {};
template<> struct def<Windows::UI::Xaml::Media::ILineGeometry> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ILineGeometryStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::LineGeometry> : class_type<Windows::UI::Xaml::Media::Geometry, Windows::UI::Xaml::Media::ILineGeometry> {};
template<> struct def<Windows::UI::Xaml::Media::ILineSegment> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ILineSegmentStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::LineSegment> : class_type<Windows::UI::Xaml::Media::PathSegment, Windows::UI::Xaml::Media::ILineSegment> {};
template<> struct def<Windows::UI::Xaml::Media::IPathGeometry> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IPathGeometryStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::PathGeometry> : class_type<Windows::UI::Xaml::Media::Geometry, Windows::UI::Xaml::Media::IPathGeometry> {};
template<> struct def<Windows::UI::Xaml::Media::IPolyBezierSegment> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IPolyBezierSegmentStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::PolyBezierSegment> : class_type<Windows::UI::Xaml::Media::PathSegment, Windows::UI::Xaml::Media::IPolyBezierSegment> {};
template<> struct def<Windows::UI::Xaml::Media::IPolyLineSegment> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IPolyLineSegmentStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::PolyLineSegment> : class_type<Windows::UI::Xaml::Media::PathSegment, Windows::UI::Xaml::Media::IPolyLineSegment> {};
template<> struct def<Windows::UI::Xaml::Media::IPolyQuadraticBezierSegment> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IPolyQuadraticBezierSegmentStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::PolyQuadraticBezierSegment> : class_type<Windows::UI::Xaml::Media::PathSegment, Windows::UI::Xaml::Media::IPolyQuadraticBezierSegment> {};
template<> struct def<Windows::UI::Xaml::Media::IQuadraticBezierSegment> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IQuadraticBezierSegmentStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::QuadraticBezierSegment> : class_type<Windows::UI::Xaml::Media::PathSegment, Windows::UI::Xaml::Media::IQuadraticBezierSegment> {};
template<> struct def<Windows::UI::Xaml::Media::ITileBrush> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ITileBrushStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ITileBrushFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::TileBrush> : class_type<Windows::UI::Xaml::Media::Brush, Windows::UI::Xaml::Media::ITileBrush> {};
template<> struct def<Windows::UI::Xaml::Media::IXamlCompositionBrushBase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IXamlCompositionBrushBaseOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IXamlCompositionBrushBaseProtected> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IXamlCompositionBrushBaseStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IXamlCompositionBrushBaseFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::XamlCompositionBrushBase> : class_type<Windows::UI::Xaml::Media::Brush, Windows::UI::Xaml::Media::IXamlCompositionBrushBase, Windows::UI::Xaml::Media::IXamlCompositionBrushBaseOverrides, Windows::UI::Xaml::Media::IXamlCompositionBrushBaseProtected> {};
template<> struct def<Windows::UI::Xaml::Media::AcrylicBrush> : class_type<Windows::UI::Xaml::Media::XamlCompositionBrushBase, Windows::UI::Xaml::Media::IAcrylicBrush>, composer_type<Windows::UI::Xaml::Media::IAcrylicBrushFactory> {};
template<> struct def<Windows::UI::Xaml::Media::RevealBrush> : class_type<Windows::UI::Xaml::Media::XamlCompositionBrushBase, Windows::UI::Xaml::Media::IRevealBrush> {};
template<> struct def<Windows::UI::Xaml::Media::RevealBorderBrush> : class_type<Windows::UI::Xaml::Media::RevealBrush, Windows::UI::Xaml::Media::IRevealBorderBrush>, composer_type<Windows::UI::Xaml::Media::IRevealBorderBrushFactory> {};
template<> struct def<Windows::UI::Xaml::Media::RevealBackgroundBrush> : class_type<Windows::UI::Xaml::Media::RevealBrush, Windows::UI::Xaml::Media::IRevealBackgroundBrush>, composer_type<Windows::UI::Xaml::Media::IRevealBackgroundBrushFactory> {};
template<> struct def<Windows::UI::Xaml::Media::IImageBrush> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::IImageBrushStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ImageBrush> : class_type<Windows::UI::Xaml::Media::TileBrush, Windows::UI::Xaml::Media::IImageBrush> {};
template<> struct def<Windows::UI::Xaml::Media::ILinearGradientBrush> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ILinearGradientBrushStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::ILinearGradientBrushFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::LinearGradientBrush> : class_type<Windows::UI::Xaml::Media::GradientBrush, Windows::UI::Xaml::Media::ILinearGradientBrush>, custom_activators {};

// uuids

template<> struct uuid<Windows::UI::Xaml::Media::IAcrylicBrush> { define_guid(0x79BBCF4E, 0xCD66, 0x4F1B, 0xA8, 0xB6, 0xCD, 0x6D, 0x29, 0x77, 0xC1, 0x8D);};
template<> struct uuid<Windows::UI::Xaml::Media::IAcrylicBrushStatics> { define_guid(0x2787FD79, 0xA3DA, 0x423F, 0xB8, 0x1A, 0x59, 0x91, 0x47, 0x97, 0x15, 0x23);};
template<> struct uuid<Windows::UI::Xaml::Media::IAcrylicBrushFactory> { define_guid(0x81A32568, 0xF6CC, 0x4013, 0x83, 0x63, 0x92, 0x8A, 0xE2, 0x3B, 0x7A, 0x61);};
template<> struct uuid<Windows::UI::Xaml::Media::IRevealBrush> { define_guid(0x2036A0ED, 0x8271, 0x4398, 0x90, 0x19, 0x25, 0x87, 0x20, 0x93, 0xF1, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::Media::IRevealBrushFactory> { define_guid(0x9D9379CE, 0xE3A0, 0x4AAF, 0xBE, 0x37, 0xEA, 0x9D, 0x9D, 0xD4, 0x31, 0x5);};
template<> struct uuid<Windows::UI::Xaml::Media::IRevealBrushStatics> { define_guid(0x190F2625, 0x7209, 0x4D42, 0xA8, 0x47, 0x1A, 0xC4, 0xBB, 0xBB, 0x34, 0x99);};
template<> struct uuid<Windows::UI::Xaml::Media::IRevealBorderBrushFactory> { define_guid(0x94C25298, 0xF5F8, 0x4482, 0xA2, 0x5C, 0x67, 0x58, 0x50, 0x1A, 0x86, 0x26);};
template<> struct uuid<Windows::UI::Xaml::Media::IRevealBorderBrush> { define_guid(0x60BA115, 0xC542, 0x483C, 0x82, 0x2, 0x5F, 0x3, 0x33, 0x18, 0x66, 0xC9);};
template<> struct uuid<Windows::UI::Xaml::Media::IRevealBackgroundBrushFactory> { define_guid(0x8C56BCAA, 0x2A5, 0x4F45, 0x85, 0x6, 0x8D, 0x39, 0x22, 0x8F, 0x5D, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::Media::IRevealBackgroundBrush> { define_guid(0x261DCC0E, 0x1991, 0x4CDF, 0xAE, 0xE0, 0x63, 0x50, 0xA3, 0xF9, 0xB, 0xB9);};
template<> struct uuid<Windows::UI::Xaml::Media::IVisualTreeHelper> { define_guid(0x24B935E3, 0x52C7, 0x4141, 0x8B, 0xAC, 0xA7, 0x3D, 0x6, 0x13, 0x5, 0x69);};
template<> struct uuid<Windows::UI::Xaml::Media::IVisualTreeHelperStatics> { define_guid(0xE75758C4, 0xD25D, 0x4B1D, 0x97, 0x1F, 0x59, 0x6F, 0x17, 0xF1, 0x2B, 0xAA);};
template<> struct uuid<Windows::UI::Xaml::Media::IVisualTreeHelperStatics2> { define_guid(0x7BCD176, 0x869F, 0x44A7, 0x87, 0x97, 0x21, 0x3, 0xA4, 0xC3, 0xE4, 0x7A);};
template<> struct uuid<Windows::UI::Xaml::Media::IPartialMediaFailureDetectedEventArgs> { define_guid(0x2B65A91, 0xE5A1, 0x442B, 0x88, 0xD3, 0x2D, 0xC1, 0x27, 0xBF, 0xC5, 0x9B);};
template<> struct uuid<Windows::UI::Xaml::Media::IPartialMediaFailureDetectedEventArgs2> { define_guid(0x73074875, 0x890D, 0x416B, 0xB9, 0xAE, 0xE8, 0x4D, 0xFD, 0x9C, 0x4B, 0x1B);};
template<> struct uuid<Windows::UI::Xaml::Media::IMatrixHelper> { define_guid(0xF3CF4882, 0x6B5, 0x48C8, 0x9E, 0xB2, 0x17, 0x63, 0xE9, 0x36, 0x40, 0x38);};
template<> struct uuid<Windows::UI::Xaml::Media::IMatrixHelperStatics> { define_guid(0xC18606A6, 0x39F4, 0x4B8A, 0x84, 0x3, 0x28, 0xE5, 0xE5, 0xF0, 0x33, 0xB4);};
template<> struct uuid<Windows::UI::Xaml::Media::RateChangedRoutedEventHandler> { define_guid(0x8E9A257, 0xAE05, 0x489B, 0x88, 0x39, 0x28, 0xC6, 0x22, 0x5D, 0x23, 0x49);};
template<> struct uuid<Windows::UI::Xaml::Media::TimelineMarkerRoutedEventHandler> { define_guid(0x72E2FA9C, 0x6DEA, 0x4CBE, 0xA1, 0x59, 0x6, 0xCE, 0x95, 0xFB, 0xEC, 0xED);};
template<> struct uuid<Windows::UI::Xaml::Media::IBrushFactory> { define_guid(0x399658A2, 0x14FB, 0x4B8F, 0x83, 0xE6, 0x6E, 0x3D, 0xAB, 0x12, 0x6, 0x9B);};
template<> struct uuid<Windows::UI::Xaml::Media::IBrushStatics> { define_guid(0xE70C3102, 0x225, 0x47F5, 0xB2, 0x2E, 0x4, 0x67, 0x61, 0x9F, 0x6A, 0x22);};
template<> struct uuid<Windows::UI::Xaml::Media::IBrush> { define_guid(0x8806A321, 0x1E06, 0x422C, 0xA1, 0xCC, 0x1, 0x69, 0x65, 0x59, 0xE0, 0x21);};
template<> struct uuid<Windows::UI::Xaml::Media::ICompositionTarget> { define_guid(0x26CFBFF0, 0x713C, 0x4BEC, 0x88, 0x3, 0xE1, 0x1, 0xF7, 0xB1, 0x4E, 0xD3);};
template<> struct uuid<Windows::UI::Xaml::Media::ICompositionTargetStatics> { define_guid(0x2B1AF03D, 0x1ED2, 0x4B59, 0xBD, 0x0, 0x75, 0x94, 0xEE, 0x92, 0x83, 0x2B);};
template<> struct uuid<Windows::UI::Xaml::Media::ICompositionTargetStatics3> { define_guid(0xBC0A7CD9, 0x6750, 0x4708, 0x99, 0x4C, 0x20, 0x28, 0xE0, 0x31, 0x2A, 0xC8);};
template<> struct uuid<Windows::UI::Xaml::Media::IRenderedEventArgs> { define_guid(0xE349817D, 0x81C7, 0x4938, 0x82, 0x8C, 0xA7, 0xE2, 0x79, 0x7B, 0x35, 0xA6);};
template<> struct uuid<Windows::UI::Xaml::Media::IFontFamily> { define_guid(0x92467E64, 0xD66A, 0x4CF4, 0x93, 0x22, 0x3D, 0x23, 0xB3, 0xC0, 0xC3, 0x61);};
template<> struct uuid<Windows::UI::Xaml::Media::IFontFamilyFactory> { define_guid(0xD5603377, 0x3DAE, 0x4DCD, 0xAF, 0x9, 0xF9, 0x49, 0x8E, 0x9E, 0xC6, 0x59);};
template<> struct uuid<Windows::UI::Xaml::Media::IFontFamilyStatics2> { define_guid(0x52AD7AF9, 0x37E6, 0x4297, 0xA2, 0x38, 0x97, 0xFB, 0x6A, 0x40, 0x8D, 0x9E);};
template<> struct uuid<Windows::UI::Xaml::Media::IMediaTransportControlsThumbnailRequestedEventArgs> { define_guid(0xE4A8B21C, 0xE3C2, 0x485C, 0xAE, 0x69, 0xF1, 0x53, 0x7B, 0x76, 0x75, 0x5A);};
template<> struct uuid<Windows::UI::Xaml::Media::IRenderingEventArgs> { define_guid(0x5BF7D30D, 0x9748, 0x4AED, 0x83, 0x80, 0xD7, 0x89, 0xE, 0xB7, 0x76, 0xA0);};
template<> struct uuid<Windows::UI::Xaml::Media::ITimelineMarkerStatics> { define_guid(0xC4AEF0C6, 0x16A3, 0x484B, 0x87, 0xF5, 0x65, 0x28, 0xB8, 0xF0, 0x4A, 0x47);};
template<> struct uuid<Windows::UI::Xaml::Media::ITimelineMarker> { define_guid(0xA68EF02D, 0x45BA, 0x4E50, 0x8C, 0xAD, 0xAA, 0xEA, 0x3A, 0x22, 0x7A, 0xF5);};
template<> struct uuid<Windows::UI::Xaml::Media::ITransformFactory> { define_guid(0x1A955A66, 0x7CF4, 0x4320, 0xB4, 0x16, 0x61, 0x81, 0x19, 0x2F, 0xCC, 0x6D);};
template<> struct uuid<Windows::UI::Xaml::Media::ITransform> { define_guid(0x4DF74078, 0xBFD6, 0x4ED1, 0x96, 0x82, 0xD2, 0xFD, 0x8B, 0xF2, 0xFE, 0x6F);};
template<> struct uuid<Windows::UI::Xaml::Media::IGeneralTransformFactory> { define_guid(0x7A25C930, 0x29C4, 0x4E31, 0xB6, 0xF9, 0xDE, 0xDD, 0x52, 0xE4, 0xDF, 0x1B);};
template<> struct uuid<Windows::UI::Xaml::Media::IGeneralTransformOverrides> { define_guid(0x4F121083, 0x24CF, 0x4524, 0x90, 0xAD, 0x8A, 0x42, 0xB1, 0xC1, 0x27, 0x83);};
template<> struct uuid<Windows::UI::Xaml::Media::IGeneralTransform> { define_guid(0xA06798B7, 0xA2EC, 0x415F, 0xAD, 0xE2, 0xEA, 0xDE, 0x93, 0x33, 0xF2, 0xC7);};
template<> struct uuid<Windows::UI::Xaml::Media::ICacheMode> { define_guid(0x98DC8B11, 0xC6F9, 0x4DAB, 0xB8, 0x38, 0x5F, 0xD5, 0xEC, 0x8C, 0x73, 0x50);};
template<> struct uuid<Windows::UI::Xaml::Media::ICacheModeFactory> { define_guid(0xEB1F8C5B, 0xABB, 0x4E70, 0xB8, 0xA8, 0x62, 0xD, 0xD, 0x95, 0x3A, 0xB2);};
template<> struct uuid<Windows::UI::Xaml::Media::IGeometry> { define_guid(0xFA123889, 0xACD, 0x417B, 0xB6, 0x2D, 0x5C, 0xA1, 0xBF, 0x4D, 0xFC, 0xE);};
template<> struct uuid<Windows::UI::Xaml::Media::IGeometryStatics> { define_guid(0x7A70AA8C, 0xB06, 0x465F, 0xB6, 0x37, 0x9A, 0x47, 0xE5, 0xA7, 0x1, 0x11);};
template<> struct uuid<Windows::UI::Xaml::Media::IGeometryFactory> { define_guid(0xF65DAF23, 0xD5FD, 0x42F9, 0xB3, 0x2A, 0x92, 0x9C, 0x5A, 0x4B, 0x54, 0xE1);};
template<> struct uuid<Windows::UI::Xaml::Media::IImageSource> { define_guid(0x737EF309, 0xEA41, 0x4D96, 0xA7, 0x1C, 0x98, 0xE9, 0x8E, 0xFC, 0xAB, 0x7);};
template<> struct uuid<Windows::UI::Xaml::Media::IImageSourceFactory> { define_guid(0x297EC001, 0x2540, 0x4E5A, 0xAB, 0x66, 0x88, 0x3, 0x5D, 0xD3, 0xDD, 0xB5);};
template<> struct uuid<Windows::UI::Xaml::Media::IPathSegment> { define_guid(0xFCFA71CF, 0x9CE3, 0x474F, 0x81, 0x57, 0x10, 0xB6, 0x43, 0x5A, 0x61, 0x6B);};
template<> struct uuid<Windows::UI::Xaml::Media::IPathSegmentFactory> { define_guid(0x2A1C0AAE, 0xECCD, 0x4464, 0xA1, 0x48, 0x6F, 0xFD, 0xB3, 0xAA, 0x28, 0x1F);};
template<> struct uuid<Windows::UI::Xaml::Media::IProjection> { define_guid(0xB3443557, 0x7F39, 0x4D04, 0xA8, 0x9C, 0x84, 0x43, 0x38, 0xCA, 0xC8, 0x97);};
template<> struct uuid<Windows::UI::Xaml::Media::IProjectionFactory> { define_guid(0xC4F29CAB, 0x60AD, 0x4F24, 0xBD, 0x27, 0x9D, 0x69, 0xC3, 0x12, 0x7C, 0x9A);};
template<> struct uuid<Windows::UI::Xaml::Media::IRateChangedRoutedEventArgs> { define_guid(0x9016AA6F, 0x3CA8, 0x4C80, 0x8E, 0x2F, 0x88, 0x51, 0xA6, 0x8F, 0x13, 0x1F);};
template<> struct uuid<Windows::UI::Xaml::Media::ITimelineMarkerRoutedEventArgs> { define_guid(0x7C3B3EF3, 0x2C88, 0x4D9C, 0x99, 0xB6, 0x46, 0xCD, 0xBD, 0x48, 0xD4, 0xC1);};
template<> struct uuid<Windows::UI::Xaml::Media::IXamlLight> { define_guid(0xCC3FC1F, 0xB327, 0x4A18, 0x96, 0x48, 0x7C, 0x84, 0xDB, 0x26, 0xCE, 0x22);};
template<> struct uuid<Windows::UI::Xaml::Media::IXamlLightOverrides> { define_guid(0x7C6296C7, 0x173, 0x48E1, 0xB7, 0x3D, 0x7F, 0xA2, 0x16, 0xA9, 0xAC, 0x28);};
template<> struct uuid<Windows::UI::Xaml::Media::IXamlLightProtected> { define_guid(0x5ECF220B, 0x1252, 0x43D0, 0x97, 0x29, 0x6E, 0xA6, 0x92, 0x4, 0x68, 0x38);};
template<> struct uuid<Windows::UI::Xaml::Media::IXamlLightFactory> { define_guid(0x87DED768, 0x3055, 0x43B8, 0x8E, 0xF6, 0x79, 0x8D, 0xC4, 0xC2, 0x32, 0x9A);};
template<> struct uuid<Windows::UI::Xaml::Media::IXamlLightStatics> { define_guid(0xB5EA9D69, 0xB508, 0x4E9C, 0xBD, 0x27, 0x6B, 0x4, 0x4B, 0x5F, 0x78, 0xA0);};
template<> struct uuid<Windows::UI::Xaml::Media::IBitmapCache> { define_guid(0x79C2219E, 0x44D2, 0x4610, 0x97, 0x35, 0x9B, 0xEC, 0x83, 0x80, 0x9E, 0xCF);};
template<> struct uuid<Windows::UI::Xaml::Media::IMatrix3DProjection> { define_guid(0x6F03E149, 0xBFC9, 0x4C01, 0xB5, 0x78, 0x50, 0x33, 0x8C, 0xEC, 0x97, 0xFC);};
template<> struct uuid<Windows::UI::Xaml::Media::IMatrix3DProjectionStatics> { define_guid(0xAE9D5895, 0x41EC, 0x4E37, 0xAB, 0xAA, 0x69, 0xF4, 0x1D, 0x2F, 0x87, 0x6B);};
template<> struct uuid<Windows::UI::Xaml::Media::IPlaneProjection> { define_guid(0xE6F82BFA, 0x6726, 0x469A, 0xB2, 0x59, 0xA5, 0x18, 0x83, 0x47, 0xCA, 0x8F);};
template<> struct uuid<Windows::UI::Xaml::Media::IPlaneProjectionStatics> { define_guid(0xAD919C67, 0x3BDC, 0x4855, 0x89, 0x69, 0xD1, 0xF9, 0xA3, 0xAD, 0xC2, 0x7D);};
template<> struct uuid<Windows::UI::Xaml::Media::IRectangleGeometry> { define_guid(0xA25A1F58, 0xC575, 0x4196, 0x91, 0xCF, 0x9F, 0xDF, 0xB1, 0x4, 0x45, 0xC3);};
template<> struct uuid<Windows::UI::Xaml::Media::IRectangleGeometryStatics> { define_guid(0x377F8DBA, 0x7902, 0x48E3, 0x83, 0xBE, 0x7C, 0x80, 0x2, 0xA6, 0x65, 0x3C);};
template<> struct uuid<Windows::UI::Xaml::Media::ISolidColorBrush> { define_guid(0x9D850850, 0x66F3, 0x48DF, 0x9A, 0x8F, 0x82, 0x4B, 0xD5, 0xE0, 0x70, 0xAF);};
template<> struct uuid<Windows::UI::Xaml::Media::ISolidColorBrushStatics> { define_guid(0xE1A65EFA, 0x2B23, 0x41BA, 0xB9, 0xBA, 0x70, 0x94, 0xEC, 0x8E, 0x4E, 0x9F);};
template<> struct uuid<Windows::UI::Xaml::Media::ISolidColorBrushFactory> { define_guid(0xD935CE0C, 0x86F5, 0x4DA6, 0x8A, 0x27, 0xB1, 0x61, 0x9E, 0xF7, 0xF9, 0x2B);};
template<> struct uuid<Windows::UI::Xaml::Media::ICompositeTransform> { define_guid(0xC8A4385B, 0xF24A, 0x4701, 0xA2, 0x65, 0xA7, 0x88, 0x46, 0xF1, 0x42, 0xB9);};
template<> struct uuid<Windows::UI::Xaml::Media::ICompositeTransformStatics> { define_guid(0x2F190C08, 0x8266, 0x496F, 0x96, 0x53, 0xA1, 0x8B, 0xD4, 0xF8, 0x36, 0xAA);};
template<> struct uuid<Windows::UI::Xaml::Media::IMatrixTransform> { define_guid(0xEDFDD551, 0x5FED, 0x45FC, 0xAE, 0x62, 0x92, 0xA4, 0xB6, 0xCF, 0x97, 0x7);};
template<> struct uuid<Windows::UI::Xaml::Media::IMatrixTransformStatics> { define_guid(0x43E02E47, 0x15B8, 0x4758, 0xBB, 0x97, 0x7D, 0x52, 0x42, 0xA, 0xCC, 0x5B);};
template<> struct uuid<Windows::UI::Xaml::Media::IRotateTransform> { define_guid(0x688EA9B9, 0x1E4E, 0x4596, 0x86, 0xE3, 0x42, 0x8B, 0x27, 0x33, 0x4F, 0xAF);};
template<> struct uuid<Windows::UI::Xaml::Media::IRotateTransformStatics> { define_guid(0xA131EB8A, 0x51A3, 0x41B6, 0xB9, 0xD3, 0xA1, 0xE, 0x42, 0x90, 0x54, 0xAB);};
template<> struct uuid<Windows::UI::Xaml::Media::IScaleTransform> { define_guid(0xED67F18D, 0x936E, 0x43AB, 0x92, 0x9A, 0xE9, 0xCD, 0xA, 0x51, 0x1E, 0x52);};
template<> struct uuid<Windows::UI::Xaml::Media::IScaleTransformStatics> { define_guid(0x9D9436F4, 0x40A7, 0x46DD, 0x97, 0x5A, 0x7, 0xD3, 0x37, 0xCD, 0x85, 0x2E);};
template<> struct uuid<Windows::UI::Xaml::Media::ISkewTransform> { define_guid(0x4E8A3B15, 0x7A0F, 0x4617, 0x9E, 0x98, 0x1E, 0x65, 0xBD, 0xC9, 0x21, 0x15);};
template<> struct uuid<Windows::UI::Xaml::Media::ISkewTransformStatics> { define_guid(0xECD11D73, 0x5614, 0x4B31, 0xB6, 0xAF, 0xBE, 0xAE, 0x10, 0x10, 0x56, 0x24);};
template<> struct uuid<Windows::UI::Xaml::Media::ITransformGroup> { define_guid(0x63418CCC, 0x8D2D, 0x4737, 0xB9, 0x51, 0x2A, 0xFC, 0xE1, 0xDD, 0xC4, 0xC4);};
template<> struct uuid<Windows::UI::Xaml::Media::ITransformGroupStatics> { define_guid(0x25312F2A, 0xCFAB, 0x4B24, 0x97, 0x13, 0x5B, 0xDE, 0xAD, 0x19, 0x29, 0xC0);};
template<> struct uuid<Windows::UI::Xaml::Media::ITranslateTransform> { define_guid(0xC975905C, 0x3C36, 0x4229, 0x81, 0x7B, 0x17, 0x8F, 0x64, 0xC0, 0xE1, 0x13);};
template<> struct uuid<Windows::UI::Xaml::Media::ITranslateTransformStatics> { define_guid(0xF419AA91, 0xE042, 0x4111, 0x9C, 0x2F, 0xD2, 0x1, 0x30, 0x41, 0x23, 0xDD);};
template<> struct uuid<Windows::UI::Xaml::Media::IGradientStopStatics> { define_guid(0x602A6D75, 0x6193, 0x4FE5, 0x8E, 0x82, 0xC7, 0xC6, 0xF6, 0xFE, 0xBA, 0xFD);};
template<> struct uuid<Windows::UI::Xaml::Media::IGradientStop> { define_guid(0x665F44FE, 0x2E59, 0x4C4A, 0xAB, 0x53, 0x7, 0x6A, 0x10, 0xC, 0xCD, 0x81);};
template<> struct uuid<Windows::UI::Xaml::Media::ILoadedImageSourceLoadCompletedEventArgs> { define_guid(0x1AC60B1E, 0x7837, 0x4489, 0xB3, 0xE5, 0xD0, 0xD5, 0xAD, 0xA, 0x56, 0xC4);};
template<> struct uuid<Windows::UI::Xaml::Media::ILoadedImageSurface> { define_guid(0x50C8313, 0x6737, 0x45BA, 0x85, 0x31, 0x33, 0x9, 0x4F, 0xEB, 0xEF, 0x55);};
template<> struct uuid<Windows::UI::Xaml::Media::ILoadedImageSurfaceStatics> { define_guid(0x22B8EDF6, 0x84AD, 0x40AB, 0x93, 0x7D, 0x48, 0x71, 0x61, 0x3E, 0x76, 0x5D);};
template<> struct uuid<Windows::UI::Xaml::Media::IPathFigureStatics> { define_guid(0xB60591D9, 0x2395, 0x4317, 0x95, 0x52, 0x3A, 0x58, 0x52, 0x6F, 0x8C, 0x7B);};
template<> struct uuid<Windows::UI::Xaml::Media::IPathFigure> { define_guid(0x5D955C8C, 0x5FA9, 0x4DDA, 0xA3, 0xCC, 0x10, 0xFC, 0xDC, 0xAA, 0x20, 0xD7);};
template<> struct uuid<Windows::UI::Xaml::Media::IArcSegment> { define_guid(0x7940C5F, 0x63FB, 0x4469, 0x91, 0xBE, 0xF1, 0x9, 0x7C, 0x16, 0x80, 0x52);};
template<> struct uuid<Windows::UI::Xaml::Media::IArcSegmentStatics> { define_guid(0x82348F6E, 0x8A69, 0x4204, 0x9C, 0x12, 0x72, 0x7, 0xDF, 0x31, 0x76, 0x43);};
template<> struct uuid<Windows::UI::Xaml::Media::IBezierSegment> { define_guid(0xAF4BB9EE, 0x8984, 0x49B7, 0x81, 0xDF, 0x3F, 0x35, 0x99, 0x4B, 0x95, 0xEB);};
template<> struct uuid<Windows::UI::Xaml::Media::IBezierSegmentStatics> { define_guid(0xC0287BAC, 0x1410, 0x4530, 0x84, 0x52, 0x1C, 0x9D, 0xA, 0xD1, 0xF3, 0x41);};
template<> struct uuid<Windows::UI::Xaml::Media::IEllipseGeometry> { define_guid(0xD4F61BBA, 0x4EA2, 0x40D6, 0xAA, 0x6C, 0x8D, 0x38, 0xAA, 0x87, 0x65, 0x1F);};
template<> struct uuid<Windows::UI::Xaml::Media::IEllipseGeometryStatics> { define_guid(0x1744DB47, 0xF635, 0x4B16, 0xAE, 0xE6, 0xE0, 0x52, 0xA6, 0x5D, 0xEF, 0xB2);};
template<> struct uuid<Windows::UI::Xaml::Media::IGeometryGroup> { define_guid(0x55225A61, 0x8677, 0x4C8C, 0x8E, 0x46, 0xEE, 0x3D, 0xC3, 0x55, 0x11, 0x4B);};
template<> struct uuid<Windows::UI::Xaml::Media::IGeometryGroupStatics> { define_guid(0x56C955F4, 0x8496, 0x4BB6, 0xAB, 0xF0, 0x61, 0x7B, 0x1F, 0xE7, 0x8B, 0x45);};
template<> struct uuid<Windows::UI::Xaml::Media::IGradientBrush> { define_guid(0x2166E69F, 0x935A, 0x4191, 0x8E, 0x3C, 0x1C, 0x8D, 0xFD, 0xFC, 0xDC, 0x78);};
template<> struct uuid<Windows::UI::Xaml::Media::IGradientBrushStatics> { define_guid(0x961661F9, 0x8BB4, 0x4E6C, 0xB9, 0x23, 0xB5, 0xD7, 0x87, 0xE0, 0xF1, 0xA9);};
template<> struct uuid<Windows::UI::Xaml::Media::IGradientBrushFactory> { define_guid(0xED4779CA, 0x45BD, 0x4131, 0xB6, 0x25, 0xBE, 0x86, 0xE0, 0x7C, 0x61, 0x12);};
template<> struct uuid<Windows::UI::Xaml::Media::ILineGeometry> { define_guid(0x30EDD4A2, 0x8FC5, 0x40AF, 0xA7, 0xA2, 0xC2, 0x7F, 0xE7, 0xAA, 0x13, 0x63);};
template<> struct uuid<Windows::UI::Xaml::Media::ILineGeometryStatics> { define_guid(0x578AE763, 0x5562, 0x4EE4, 0x87, 0x3, 0xEA, 0x40, 0x36, 0xD8, 0x91, 0xE3);};
template<> struct uuid<Windows::UI::Xaml::Media::ILineSegment> { define_guid(0xEF6A2E25, 0x3FF0, 0x4420, 0xA4, 0x11, 0x71, 0x82, 0xA4, 0xCE, 0xCB, 0x15);};
template<> struct uuid<Windows::UI::Xaml::Media::ILineSegmentStatics> { define_guid(0x9FCAB141, 0x4C0, 0x4AFB, 0x87, 0xB3, 0xE8, 0x0, 0xB9, 0x69, 0xB8, 0x94);};
template<> struct uuid<Windows::UI::Xaml::Media::IPathGeometry> { define_guid(0x81B9DF8, 0xBAE6, 0x4BCB, 0x81, 0x3C, 0xBD, 0xE0, 0xE4, 0x6D, 0xC8, 0xB7);};
template<> struct uuid<Windows::UI::Xaml::Media::IPathGeometryStatics> { define_guid(0xD9E58BBA, 0x2CBA, 0x4741, 0x8F, 0x8D, 0x31, 0x98, 0xCF, 0x51, 0x86, 0xB9);};
template<> struct uuid<Windows::UI::Xaml::Media::IPolyBezierSegment> { define_guid(0x36805271, 0x38C4, 0x4BCF, 0x96, 0xCD, 0x2, 0x8A, 0x6D, 0x38, 0xAF, 0x25);};
template<> struct uuid<Windows::UI::Xaml::Media::IPolyBezierSegmentStatics> { define_guid(0x1D91A6DA, 0x1492, 0x4ACC, 0xBD, 0x66, 0xA4, 0x96, 0xF3, 0xD8, 0x29, 0xD6);};
template<> struct uuid<Windows::UI::Xaml::Media::IPolyLineSegment> { define_guid(0x4B397F87, 0xA2E6, 0x479D, 0xBD, 0xC8, 0x6F, 0x44, 0x64, 0x64, 0x68, 0x87);};
template<> struct uuid<Windows::UI::Xaml::Media::IPolyLineSegmentStatics> { define_guid(0xD64A2C87, 0x33F1, 0x4E70, 0xA4, 0x7F, 0xB4, 0x98, 0x1E, 0xF6, 0x48, 0xA2);};
template<> struct uuid<Windows::UI::Xaml::Media::IPolyQuadraticBezierSegment> { define_guid(0xDD5CED7D, 0xE6DB, 0x4C96, 0xB6, 0xA1, 0x3F, 0xCE, 0x96, 0xE9, 0x87, 0xA6);};
template<> struct uuid<Windows::UI::Xaml::Media::IPolyQuadraticBezierSegmentStatics> { define_guid(0xFDF5EB75, 0x7AD5, 0x4C89, 0x81, 0x69, 0x8C, 0x97, 0x86, 0xAB, 0xD9, 0xEB);};
template<> struct uuid<Windows::UI::Xaml::Media::IQuadraticBezierSegment> { define_guid(0x2C509A5B, 0xBF18, 0x455A, 0xA0, 0x78, 0x91, 0x4B, 0x52, 0x32, 0xD8, 0xAF);};
template<> struct uuid<Windows::UI::Xaml::Media::IQuadraticBezierSegmentStatics> { define_guid(0x69C78278, 0x3C0B, 0x4B4F, 0xB7, 0xA2, 0xF0, 0x3, 0xDE, 0xD4, 0x1B, 0xB0);};
template<> struct uuid<Windows::UI::Xaml::Media::ITileBrush> { define_guid(0xC201CF06, 0xCD84, 0x48A5, 0x96, 0x7, 0x66, 0x4D, 0x73, 0x61, 0xCD, 0x61);};
template<> struct uuid<Windows::UI::Xaml::Media::ITileBrushStatics> { define_guid(0x3497C25B, 0xB562, 0x4E68, 0x84, 0x35, 0x23, 0x99, 0xF6, 0xEB, 0x94, 0xD5);};
template<> struct uuid<Windows::UI::Xaml::Media::ITileBrushFactory> { define_guid(0xAA159F7C, 0xED6A, 0x4FB3, 0xB0, 0x14, 0xB5, 0xC7, 0xE3, 0x79, 0xA4, 0xDE);};
template<> struct uuid<Windows::UI::Xaml::Media::IXamlCompositionBrushBase> { define_guid(0x3E432D9, 0xB35C, 0x4A79, 0x81, 0x1C, 0xC5, 0x65, 0x20, 0x4, 0xDA, 0xE);};
template<> struct uuid<Windows::UI::Xaml::Media::IXamlCompositionBrushBaseOverrides> { define_guid(0xD19127F1, 0x38B4, 0x4EA1, 0x8F, 0x33, 0x84, 0x96, 0x29, 0xA4, 0xC9, 0xC1);};
template<> struct uuid<Windows::UI::Xaml::Media::IXamlCompositionBrushBaseProtected> { define_guid(0x1513F3D8, 0x457, 0x4E1C, 0xAD, 0x77, 0x11, 0xC1, 0xD9, 0x87, 0x97, 0x43);};
template<> struct uuid<Windows::UI::Xaml::Media::IXamlCompositionBrushBaseStatics> { define_guid(0x4FD49B06, 0x61A, 0x441F, 0xB9, 0x7A, 0xAD, 0xFB, 0xD4, 0x1A, 0xE6, 0x81);};
template<> struct uuid<Windows::UI::Xaml::Media::IXamlCompositionBrushBaseFactory> { define_guid(0x394F0823, 0x2451, 0x4ED8, 0xBD, 0x24, 0x48, 0x81, 0x49, 0xB3, 0x42, 0x8D);};
template<> struct uuid<Windows::UI::Xaml::Media::IImageBrush> { define_guid(0x9FD11377, 0xC12A, 0x4493, 0xBF, 0x7D, 0xF3, 0xA8, 0xAD, 0x74, 0xB5, 0x54);};
template<> struct uuid<Windows::UI::Xaml::Media::IImageBrushStatics> { define_guid(0x1255B1B2, 0xDD18, 0x42E5, 0x89, 0x2C, 0xEA, 0xE3, 0xC, 0x30, 0x5B, 0x8C);};
template<> struct uuid<Windows::UI::Xaml::Media::ILinearGradientBrush> { define_guid(0x8E96D16B, 0xBB84, 0x4C6F, 0x9D, 0xBF, 0x9D, 0x6C, 0x5C, 0x6D, 0x9C, 0x39);};
template<> struct uuid<Windows::UI::Xaml::Media::ILinearGradientBrushStatics> { define_guid(0x7AF6E504, 0x2DC3, 0x40E3, 0xBE, 0xB, 0xB3, 0x14, 0xC1, 0x3C, 0xB9, 0x91);};
template<> struct uuid<Windows::UI::Xaml::Media::ILinearGradientBrushFactory> { define_guid(0xAE0861C, 0x1E7A, 0x4FED, 0x98, 0x57, 0xEA, 0x8C, 0xAA, 0x79, 0x84, 0x90);};

// types

namespace Windows { namespace UI { namespace Xaml { namespace Media {

// IAcrylicBrush
struct IAcrylicBrush_raw : IInspectable {
	virtual STDMETHODIMP _get_BackgroundSource(AcrylicBackgroundSource *value);
	virtual STDMETHODIMP _put_BackgroundSource(AcrylicBackgroundSource value);
	virtual STDMETHODIMP _get_TintColor(Color *result);
	virtual STDMETHODIMP _put_TintColor(Color value);
	virtual STDMETHODIMP _get_TintOpacity(double *value);
	virtual STDMETHODIMP _put_TintOpacity(double value);
	virtual STDMETHODIMP _get_TintTransitionDuration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_TintTransitionDuration(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_AlwaysUseFallback(bool *result);
	virtual STDMETHODIMP _put_AlwaysUseFallback(bool value);
};
template<typename X> struct IAcrylicBrush_adaptor : X {
	union {
		struct : property {
			bool get() { bool result; hrcheck(enc(&IAcrylicBrush_adaptor::AlwaysUseFallback)->_get_AlwaysUseFallback(&result)); return result; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IAcrylicBrush_adaptor::AlwaysUseFallback)->_put_AlwaysUseFallback(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AlwaysUseFallback;
		struct : property {
			AcrylicBackgroundSource get() { AcrylicBackgroundSource value; hrcheck(enc(&IAcrylicBrush_adaptor::BackgroundSource)->_get_BackgroundSource(&value)); return value; }
			AcrylicBackgroundSource operator()() { return get(); }
			operator AcrylicBackgroundSource () { return get(); }
			void put(AcrylicBackgroundSource value) { hrcheck(enc(&IAcrylicBrush_adaptor::BackgroundSource)->_put_BackgroundSource(value)); }
			void operator=(AcrylicBackgroundSource value) { put(value); }
			void operator()(AcrylicBackgroundSource value) { put(value); }
		} BackgroundSource;
		struct : property {
			Color get() { Color result; hrcheck(enc(&IAcrylicBrush_adaptor::TintColor)->_get_TintColor(&result)); return result; }
			Color operator()() { return get(); }
			operator Color () { return get(); }
			void put(const Color& value) { hrcheck(enc(&IAcrylicBrush_adaptor::TintColor)->_put_TintColor(value)); }
			void operator=(const Color& value) { put(value); }
			void operator()(const Color& value) { put(value); }
		} TintColor;
		struct : property {
			double get() { double value; hrcheck(enc(&IAcrylicBrush_adaptor::TintOpacity)->_get_TintOpacity(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IAcrylicBrush_adaptor::TintOpacity)->_put_TintOpacity(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} TintOpacity;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IAcrylicBrush_adaptor::TintTransitionDuration)->_get_TintTransitionDuration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IAcrylicBrush_adaptor::TintTransitionDuration)->_put_TintTransitionDuration(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} TintTransitionDuration;
	};
	IAcrylicBrush_adaptor() {}
};
template<typename X> struct adapt<IAcrylicBrush, X> : Windows::UI::Xaml::Media::IAcrylicBrush_adaptor<X> { typedef adapt IAcrylicBrush; };
struct IAcrylicBrush : IAcrylicBrush_raw, generate<IAcrylicBrush> {};

// IAcrylicBrushStatics
struct IAcrylicBrushStatics : IInspectable {
	virtual STDMETHODIMP _get_BackgroundSourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TintColorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TintOpacityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TintTransitionDurationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AlwaysUseFallbackProperty(DependencyProperty* *value);
};

// IAcrylicBrushFactory
struct IAcrylicBrushFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, AcrylicBrush* *instance);
};

// IRevealBrush
struct IRevealBrush_raw : IInspectable {
	virtual STDMETHODIMP _get_Color(UI::Color *result);
	virtual STDMETHODIMP _put_Color(UI::Color value);
	virtual STDMETHODIMP _get_TargetTheme(ApplicationTheme *value);
	virtual STDMETHODIMP _put_TargetTheme(ApplicationTheme value);
	virtual STDMETHODIMP _get_AlwaysUseFallback(bool *result);
	virtual STDMETHODIMP _put_AlwaysUseFallback(bool value);
};
template<typename X> struct IRevealBrush_adaptor : X {
	union {
		struct : property {
			bool get() { bool result; hrcheck(enc(&IRevealBrush_adaptor::AlwaysUseFallback)->_get_AlwaysUseFallback(&result)); return result; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IRevealBrush_adaptor::AlwaysUseFallback)->_put_AlwaysUseFallback(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AlwaysUseFallback;
		struct : property {
			UI::Color get() { UI::Color result; hrcheck(enc(&IRevealBrush_adaptor::Color)->_get_Color(&result)); return result; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IRevealBrush_adaptor::Color)->_put_Color(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} Color;
		struct : property {
			ApplicationTheme get() { ApplicationTheme value; hrcheck(enc(&IRevealBrush_adaptor::TargetTheme)->_get_TargetTheme(&value)); return value; }
			ApplicationTheme operator()() { return get(); }
			operator ApplicationTheme () { return get(); }
			void put(ApplicationTheme value) { hrcheck(enc(&IRevealBrush_adaptor::TargetTheme)->_put_TargetTheme(value)); }
			void operator=(ApplicationTheme value) { put(value); }
			void operator()(ApplicationTheme value) { put(value); }
		} TargetTheme;
	};
	IRevealBrush_adaptor() {}
};
template<typename X> struct adapt<IRevealBrush, X> : Windows::UI::Xaml::Media::IRevealBrush_adaptor<X> { typedef adapt IRevealBrush; };
struct IRevealBrush : IRevealBrush_raw, generate<IRevealBrush> {};

// IRevealBrushFactory
struct IRevealBrushFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, RevealBrush* *instance);
};

// IRevealBrushStatics
struct IRevealBrushStatics : IInspectable {
	virtual STDMETHODIMP _get_ColorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TargetThemeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AlwaysUseFallbackProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_StateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _SetState(UIElement* element, RevealBrushState value);
	virtual STDMETHODIMP _GetState(UIElement* element, RevealBrushState *result);
};

// IRevealBorderBrushFactory
struct IRevealBorderBrushFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, RevealBorderBrush* *instance);
};

// IRevealBorderBrush
struct IRevealBorderBrush : IInspectable, generate<IRevealBorderBrush> {};

// IRevealBackgroundBrushFactory
struct IRevealBackgroundBrushFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, RevealBackgroundBrush* *instance);
};

// IRevealBackgroundBrush
struct IRevealBackgroundBrush : IInspectable, generate<IRevealBackgroundBrush> {};

// IVisualTreeHelper
struct IVisualTreeHelper : IInspectable, generate<IVisualTreeHelper> {};

// IVisualTreeHelperStatics
struct IVisualTreeHelperStatics : IInspectable {
	virtual STDMETHODIMP _FindElementsInHostCoordinatesPoint(Foundation::Point intersectingPoint, UIElement* subtree, Foundation::Collections::IIterable<UIElement*>* *elements);
	virtual STDMETHODIMP _FindElementsInHostCoordinatesRect(Foundation::Rect intersectingRect, UIElement* subtree, Foundation::Collections::IIterable<UIElement*>* *elements);
	virtual STDMETHODIMP _FindAllElementsInHostCoordinatesPoint(Foundation::Point intersectingPoint, UIElement* subtree, bool includeAllElements, Foundation::Collections::IIterable<UIElement*>* *elements);
	virtual STDMETHODIMP _FindAllElementsInHostCoordinatesRect(Foundation::Rect intersectingRect, UIElement* subtree, bool includeAllElements, Foundation::Collections::IIterable<UIElement*>* *elements);
	virtual STDMETHODIMP _GetChild(DependencyObject* reference, int childIndex, DependencyObject* *child);
	virtual STDMETHODIMP _GetChildrenCount(DependencyObject* reference, int *count);
	virtual STDMETHODIMP _GetParent(DependencyObject* reference, DependencyObject* *parent);
	virtual STDMETHODIMP _DisconnectChildrenRecursive(UIElement* element);
};

// IVisualTreeHelperStatics2
struct IVisualTreeHelperStatics2 : IInspectable {
	virtual STDMETHODIMP _GetOpenPopups(Window* window, Foundation::Collections::IVectorView<Controls::Primitives::Popup*>* *popups);
};

// VisualTreeHelper
template<typename> struct VisualTreeHelper_statics {
	static ptr<Foundation::Collections::IVectorView<ptr<Controls::Primitives::Popup>>> GetOpenPopups(pptr<Window> window) { Foundation::Collections::IVectorView<Controls::Primitives::Popup*>* popups; hrcheck(get_activation_factory<VisualTreeHelper, IVisualTreeHelperStatics2>()->_GetOpenPopups(window, &popups)); return from_abi(popups); }
	static ptr<Foundation::Collections::IIterable<ptr<UIElement>>> FindElementsInHostCoordinates(const Foundation::Point& intersectingPoint, pptr<UIElement> subtree) { Foundation::Collections::IIterable<UIElement*>* elements; hrcheck(get_activation_factory<VisualTreeHelper, IVisualTreeHelperStatics>()->_FindElementsInHostCoordinatesPoint(intersectingPoint, subtree, &elements)); return from_abi(elements); }
	static ptr<Foundation::Collections::IIterable<ptr<UIElement>>> FindElementsInHostCoordinates(const Foundation::Rect& intersectingRect, pptr<UIElement> subtree) { Foundation::Collections::IIterable<UIElement*>* elements; hrcheck(get_activation_factory<VisualTreeHelper, IVisualTreeHelperStatics>()->_FindElementsInHostCoordinatesRect(intersectingRect, subtree, &elements)); return from_abi(elements); }
	static ptr<Foundation::Collections::IIterable<ptr<UIElement>>> FindElementsInHostCoordinates(const Foundation::Point& intersectingPoint, pptr<UIElement> subtree, bool includeAllElements) { Foundation::Collections::IIterable<UIElement*>* elements; hrcheck(get_activation_factory<VisualTreeHelper, IVisualTreeHelperStatics>()->_FindAllElementsInHostCoordinatesPoint(intersectingPoint, subtree, includeAllElements, &elements)); return from_abi(elements); }
	static ptr<Foundation::Collections::IIterable<ptr<UIElement>>> FindElementsInHostCoordinates(const Foundation::Rect& intersectingRect, pptr<UIElement> subtree, bool includeAllElements) { Foundation::Collections::IIterable<UIElement*>* elements; hrcheck(get_activation_factory<VisualTreeHelper, IVisualTreeHelperStatics>()->_FindAllElementsInHostCoordinatesRect(intersectingRect, subtree, includeAllElements, &elements)); return from_abi(elements); }
	static ptr<DependencyObject> GetChild(pptr<DependencyObject> reference, int childIndex) { DependencyObject* child; hrcheck(get_activation_factory<VisualTreeHelper, IVisualTreeHelperStatics>()->_GetChild(reference, childIndex, &child)); return from_abi(child); }
	static int GetChildrenCount(pptr<DependencyObject> reference) { int count; hrcheck(get_activation_factory<VisualTreeHelper, IVisualTreeHelperStatics>()->_GetChildrenCount(reference, &count)); return count; }
	static ptr<DependencyObject> GetParent(pptr<DependencyObject> reference) { DependencyObject* parent; hrcheck(get_activation_factory<VisualTreeHelper, IVisualTreeHelperStatics>()->_GetParent(reference, &parent)); return from_abi(parent); }
	static void DisconnectChildrenRecursive(pptr<UIElement> element) { hrcheck(get_activation_factory<VisualTreeHelper, IVisualTreeHelperStatics>()->_DisconnectChildrenRecursive(element)); }
};

template<typename X> struct statics<VisualTreeHelper, X> : X, Windows::UI::Xaml::Media::VisualTreeHelper_statics<void> {
	typedef typename X::root_type VisualTreeHelper;
};
struct VisualTreeHelper : generate<VisualTreeHelper> {};

// IPartialMediaFailureDetectedEventArgs
struct IPartialMediaFailureDetectedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_StreamKind(Windows::Media::Playback::FailedMediaStreamKind *value);
};
template<typename X> struct IPartialMediaFailureDetectedEventArgs_adaptor : X {
	union {
		struct : property {
			Windows::Media::Playback::FailedMediaStreamKind get() { Windows::Media::Playback::FailedMediaStreamKind value; hrcheck(enc(&IPartialMediaFailureDetectedEventArgs_adaptor::StreamKind)->_get_StreamKind(&value)); return value; }
			Windows::Media::Playback::FailedMediaStreamKind operator()() { return get(); }
			operator Windows::Media::Playback::FailedMediaStreamKind () { return get(); }
		} StreamKind;
	};
	IPartialMediaFailureDetectedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IPartialMediaFailureDetectedEventArgs, X> : Windows::UI::Xaml::Media::IPartialMediaFailureDetectedEventArgs_adaptor<X> { typedef adapt IPartialMediaFailureDetectedEventArgs; };
struct IPartialMediaFailureDetectedEventArgs : IPartialMediaFailureDetectedEventArgs_raw, generate<IPartialMediaFailureDetectedEventArgs> {};

// IPartialMediaFailureDetectedEventArgs2
struct IPartialMediaFailureDetectedEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IPartialMediaFailureDetectedEventArgs2_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IPartialMediaFailureDetectedEventArgs2_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
	};
	IPartialMediaFailureDetectedEventArgs2_adaptor() {}
};
template<typename X> struct adapt<IPartialMediaFailureDetectedEventArgs2, X> : Windows::UI::Xaml::Media::IPartialMediaFailureDetectedEventArgs2_adaptor<X> { typedef adapt IPartialMediaFailureDetectedEventArgs2; };
struct IPartialMediaFailureDetectedEventArgs2 : IPartialMediaFailureDetectedEventArgs2_raw, generate<IPartialMediaFailureDetectedEventArgs2> {};

// PartialMediaFailureDetectedEventArgs
template<typename X> struct statics<PartialMediaFailureDetectedEventArgs, X> : X {
	typedef typename X::root_type PartialMediaFailureDetectedEventArgs;
};
struct PartialMediaFailureDetectedEventArgs : generate<PartialMediaFailureDetectedEventArgs> {};

// IMatrixHelper
struct IMatrixHelper : IInspectable, generate<IMatrixHelper> {};

// IMatrixHelperStatics
struct IMatrixHelperStatics : IInspectable {
	virtual STDMETHODIMP _get_Identity(Matrix *value);
	virtual STDMETHODIMP _FromElements(double m11, double m12, double m21, double m22, double offsetX, double offsetY, Matrix *returnValue);
	virtual STDMETHODIMP _GetIsIdentity(Matrix target, bool *value);
	virtual STDMETHODIMP _Transform(Matrix target, Foundation::Point point, Foundation::Point *returnValue);
};

// MatrixHelper
template<typename> struct MatrixHelper_statics {
	static struct _Identity : property {
		Matrix get() { Matrix value; hrcheck(get_activation_factory<MatrixHelper, IMatrixHelperStatics>()->_get_Identity(&value)); return value; }
		Matrix operator()() { return get(); }
		operator Matrix () { return get(); }
	} Identity;
	static Matrix FromElements(double m11, double m12, double m21, double m22, double offsetX, double offsetY) { Matrix returnValue; hrcheck(get_activation_factory<MatrixHelper, IMatrixHelperStatics>()->_FromElements(m11, m12, m21, m22, offsetX, offsetY, &returnValue)); return returnValue; }
	static bool GetIsIdentity(const Matrix& target) { bool value; hrcheck(get_activation_factory<MatrixHelper, IMatrixHelperStatics>()->_GetIsIdentity(target, &value)); return value; }
	static Foundation::Point Transform(const Matrix& target, const Foundation::Point& point) { Foundation::Point returnValue; hrcheck(get_activation_factory<MatrixHelper, IMatrixHelperStatics>()->_Transform(target, point, &returnValue)); return returnValue; }
};
template<typename X> typename MatrixHelper_statics<X>::_Identity MatrixHelper_statics<X>::Identity;

template<typename X> struct statics<MatrixHelper, X> : X, Windows::UI::Xaml::Media::MatrixHelper_statics<void> {
	typedef typename X::root_type MatrixHelper;
};
struct MatrixHelper : generate<MatrixHelper> {};

// RateChangedRoutedEventHandler
struct RateChangedRoutedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, RateChangedRoutedEventArgs* e) = 0;
};

// TimelineMarkerRoutedEventHandler
struct TimelineMarkerRoutedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, TimelineMarkerRoutedEventArgs* e) = 0;
};

// IBrushFactory
struct IBrushFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Brush* *instance);
};

// IBrushStatics
struct IBrushStatics : IInspectable {
	virtual STDMETHODIMP _get_OpacityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TransformProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RelativeTransformProperty(DependencyProperty* *value);
};

// IBrush
struct IBrush_raw : IInspectable {
	virtual STDMETHODIMP _get_Opacity(double *value);
	virtual STDMETHODIMP _put_Opacity(double value);
	virtual STDMETHODIMP _get_Transform(Media::Transform* *value);
	virtual STDMETHODIMP _put_Transform(Media::Transform* value);
	virtual STDMETHODIMP _get_RelativeTransform(Media::Transform* *value);
	virtual STDMETHODIMP _put_RelativeTransform(Media::Transform* value);
};
template<typename X> struct IBrush_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IBrush_adaptor::Opacity)->_get_Opacity(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IBrush_adaptor::Opacity)->_put_Opacity(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Opacity;
		struct : property {
			ptr<Media::Transform> get() { Media::Transform* value; hrcheck(enc(&IBrush_adaptor::RelativeTransform)->_get_RelativeTransform(&value)); return from_abi(value); }
			ptr<Media::Transform> operator()() { return get(); }
			operator ptr<Media::Transform> () { return get(); }
			ptr<Media::Transform> operator->() { return get(); }
			void put(pptr<Media::Transform> value) { hrcheck(enc(&IBrush_adaptor::RelativeTransform)->_put_RelativeTransform(value)); }
			void operator=(pptr<Media::Transform> value) { put(value); }
			void operator()(pptr<Media::Transform> value) { put(value); }
		} RelativeTransform;
		struct : property {
			ptr<Media::Transform> get() { Media::Transform* value; hrcheck(enc(&IBrush_adaptor::Transform)->_get_Transform(&value)); return from_abi(value); }
			ptr<Media::Transform> operator()() { return get(); }
			operator ptr<Media::Transform> () { return get(); }
			ptr<Media::Transform> operator->() { return get(); }
			void put(pptr<Media::Transform> value) { hrcheck(enc(&IBrush_adaptor::Transform)->_put_Transform(value)); }
			void operator=(pptr<Media::Transform> value) { put(value); }
			void operator()(pptr<Media::Transform> value) { put(value); }
		} Transform;
	};
	IBrush_adaptor() {}
};
template<typename X> struct adapt<IBrush, X> : Windows::UI::Xaml::Media::IBrush_adaptor<X> { typedef adapt IBrush; };
struct IBrush : IBrush_raw, generate<IBrush> {};

// Brush
template<typename> struct Brush_statics {
	static struct _OpacityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Brush, IBrushStatics>()->_get_OpacityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OpacityProperty;
	static struct _RelativeTransformProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Brush, IBrushStatics>()->_get_RelativeTransformProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RelativeTransformProperty;
	static struct _TransformProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Brush, IBrushStatics>()->_get_TransformProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TransformProperty;
};
template<typename X> typename Brush_statics<X>::_OpacityProperty Brush_statics<X>::OpacityProperty;
template<typename X> typename Brush_statics<X>::_RelativeTransformProperty Brush_statics<X>::RelativeTransformProperty;
template<typename X> typename Brush_statics<X>::_TransformProperty Brush_statics<X>::TransformProperty;

template<typename X> struct statics<Brush, X> : X, Windows::UI::Xaml::Media::Brush_statics<void> {
	typedef typename X::root_type Brush;
};
struct Brush : generate<Brush> {};

// BrushCollection
template<typename X> struct statics<BrushCollection, X> : X {
	typedef typename X::root_type BrushCollection;
};
struct BrushCollection : generate<BrushCollection> {};

// ICompositionTarget
struct ICompositionTarget : IInspectable, generate<ICompositionTarget> {};

// ICompositionTargetStatics
struct ICompositionTargetStatics : IInspectable {
	virtual STDMETHODIMP _add_Rendering(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Rendering(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_SurfaceContentsLost(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SurfaceContentsLost(Foundation::EventRegistrationToken token);
};

// ICompositionTargetStatics3
struct ICompositionTargetStatics3 : IInspectable {
	virtual STDMETHODIMP _add_Rendered(Foundation::EventHandler<RenderedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Rendered(Foundation::EventRegistrationToken token);
};

// IRenderedEventArgs
struct IRenderedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_FrameDuration(Foundation::TimeSpan *value);
};
template<typename X> struct IRenderedEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IRenderedEventArgs_adaptor::FrameDuration)->_get_FrameDuration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} FrameDuration;
	};
	IRenderedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IRenderedEventArgs, X> : Windows::UI::Xaml::Media::IRenderedEventArgs_adaptor<X> { typedef adapt IRenderedEventArgs; };
struct IRenderedEventArgs : IRenderedEventArgs_raw, generate<IRenderedEventArgs> {};

// RenderedEventArgs
template<typename X> struct statics<RenderedEventArgs, X> : X {
	typedef typename X::root_type RenderedEventArgs;
};
struct RenderedEventArgs : generate<RenderedEventArgs> {};

// CompositionTarget
template<typename> struct CompositionTarget_statics {
	static struct _Rendering : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<CompositionTarget, ICompositionTargetStatics>()->_add_Rendering(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<CompositionTarget, ICompositionTargetStatics>()->_remove_Rendering(token)); }
	} Rendering;
	static struct _SurfaceContentsLost : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<CompositionTarget, ICompositionTargetStatics>()->_add_SurfaceContentsLost(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<CompositionTarget, ICompositionTargetStatics>()->_remove_SurfaceContentsLost(token)); }
	} SurfaceContentsLost;
	static struct _Rendered : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<RenderedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<CompositionTarget, ICompositionTargetStatics3>()->_add_Rendered(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<CompositionTarget, ICompositionTargetStatics3>()->_remove_Rendered(token)); }
	} Rendered;
};
template<typename X> typename CompositionTarget_statics<X>::_Rendering CompositionTarget_statics<X>::Rendering;
template<typename X> typename CompositionTarget_statics<X>::_SurfaceContentsLost CompositionTarget_statics<X>::SurfaceContentsLost;
template<typename X> typename CompositionTarget_statics<X>::_Rendered CompositionTarget_statics<X>::Rendered;

template<typename X> struct statics<CompositionTarget, X> : X, Windows::UI::Xaml::Media::CompositionTarget_statics<void> {
	typedef typename X::root_type CompositionTarget;
};
struct CompositionTarget : generate<CompositionTarget> {};

// DoubleCollection
template<typename X> struct statics<DoubleCollection, X> : X {
	typedef typename X::root_type DoubleCollection;
};
struct DoubleCollection : generate<DoubleCollection> {};

// IFontFamily
struct IFontFamily_raw : IInspectable {
	virtual STDMETHODIMP _get_Source(HSTRING *value);
};
template<typename X> struct IFontFamily_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IFontFamily_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Source;
	};
	IFontFamily_adaptor() {}
};
template<typename X> struct adapt<IFontFamily, X> : Windows::UI::Xaml::Media::IFontFamily_adaptor<X> { typedef adapt IFontFamily; };
struct IFontFamily : IFontFamily_raw, generate<IFontFamily> {};

// IFontFamilyFactory
struct IFontFamilyFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithName(HSTRING familyName, IInspectable* outer, IInspectable* *inner, FontFamily* *instance);
};

// IFontFamilyStatics2
struct IFontFamilyStatics2 : IInspectable {
	virtual STDMETHODIMP _get_XamlAutoFontFamily(FontFamily* *value);
};

// FontFamily
template<typename> struct FontFamily_statics {
	static struct _XamlAutoFontFamily : property {
		ptr<FontFamily> get() { FontFamily* value; hrcheck(get_activation_factory<FontFamily, IFontFamilyStatics2>()->_get_XamlAutoFontFamily(&value)); return from_abi(value); }
		ptr<FontFamily> operator()() { return get(); }
		operator ptr<FontFamily> () { return get(); }
		ptr<FontFamily> operator->() { return get(); }
	} XamlAutoFontFamily;
	static FontFamily *activate(hstring_ref familyName, object_ref outer, IInspectable* *inner) { FontFamily *instance; hrcheck(get_activation_factory<FontFamily, IFontFamilyFactory>()->_CreateInstanceWithName(familyName, outer, inner, &instance)); return instance; }
};
template<typename X> typename FontFamily_statics<X>::_XamlAutoFontFamily FontFamily_statics<X>::XamlAutoFontFamily;

template<typename X> struct statics<FontFamily, X> : X, Windows::UI::Xaml::Media::FontFamily_statics<void> {
	using Windows::UI::Xaml::Media::FontFamily_statics<void>::activate;
	typedef typename X::root_type FontFamily;
};
struct FontFamily : generate<FontFamily> {};

// IMediaTransportControlsThumbnailRequestedEventArgs
struct IMediaTransportControlsThumbnailRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _SetThumbnailImage(Storage::Streams::IInputStream* source);
	virtual STDMETHODIMP _GetDeferral(Foundation::Deferral* *returnValue);
};
template<typename X> struct IMediaTransportControlsThumbnailRequestedEventArgs_adaptor : X {
	void SetThumbnailImage(pptr<Storage::Streams::IInputStream> source) { hrcheck(X::get()->_SetThumbnailImage(source)); }
	ptr<Foundation::Deferral> GetDeferral() { Foundation::Deferral* returnValue; hrcheck(X::get()->_GetDeferral(&returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IMediaTransportControlsThumbnailRequestedEventArgs, X> : Windows::UI::Xaml::Media::IMediaTransportControlsThumbnailRequestedEventArgs_adaptor<X> { typedef adapt IMediaTransportControlsThumbnailRequestedEventArgs; };
struct IMediaTransportControlsThumbnailRequestedEventArgs : IMediaTransportControlsThumbnailRequestedEventArgs_raw, generate<IMediaTransportControlsThumbnailRequestedEventArgs> {};

// MediaTransportControlsThumbnailRequestedEventArgs
template<typename X> struct statics<MediaTransportControlsThumbnailRequestedEventArgs, X> : X {
	typedef typename X::root_type MediaTransportControlsThumbnailRequestedEventArgs;
};
struct MediaTransportControlsThumbnailRequestedEventArgs : generate<MediaTransportControlsThumbnailRequestedEventArgs> {};

// PointCollection
template<typename X> struct statics<PointCollection, X> : X {
	typedef typename X::root_type PointCollection;
};
struct PointCollection : generate<PointCollection> {};

// IRenderingEventArgs
struct IRenderingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_RenderingTime(Foundation::TimeSpan *value);
};
template<typename X> struct IRenderingEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IRenderingEventArgs_adaptor::RenderingTime)->_get_RenderingTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} RenderingTime;
	};
	IRenderingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IRenderingEventArgs, X> : Windows::UI::Xaml::Media::IRenderingEventArgs_adaptor<X> { typedef adapt IRenderingEventArgs; };
struct IRenderingEventArgs : IRenderingEventArgs_raw, generate<IRenderingEventArgs> {};

// RenderingEventArgs
template<typename X> struct statics<RenderingEventArgs, X> : X {
	typedef typename X::root_type RenderingEventArgs;
};
struct RenderingEventArgs : generate<RenderingEventArgs> {};

// ITimelineMarkerStatics
struct ITimelineMarkerStatics : IInspectable {
	virtual STDMETHODIMP _get_TimeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TypeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextProperty(DependencyProperty* *value);
};

// ITimelineMarker
struct ITimelineMarker_raw : IInspectable {
	virtual STDMETHODIMP _get_Time(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_Time(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_Type(HSTRING *value);
	virtual STDMETHODIMP _put_Type(HSTRING value);
	virtual STDMETHODIMP _get_Text(HSTRING *value);
	virtual STDMETHODIMP _put_Text(HSTRING value);
};
template<typename X> struct ITimelineMarker_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITimelineMarker_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITimelineMarker_adaptor::Text)->_put_Text(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Text;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ITimelineMarker_adaptor::Time)->_get_Time(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ITimelineMarker_adaptor::Time)->_put_Time(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Time;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITimelineMarker_adaptor::Type)->_get_Type(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITimelineMarker_adaptor::Type)->_put_Type(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Type;
	};
	ITimelineMarker_adaptor() {}
};
template<typename X> struct adapt<ITimelineMarker, X> : Windows::UI::Xaml::Media::ITimelineMarker_adaptor<X> { typedef adapt ITimelineMarker; };
struct ITimelineMarker : ITimelineMarker_raw, generate<ITimelineMarker> {};

// TimelineMarker
template<typename> struct TimelineMarker_statics {
	static struct _TextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TimelineMarker, ITimelineMarkerStatics>()->_get_TextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextProperty;
	static struct _TimeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TimelineMarker, ITimelineMarkerStatics>()->_get_TimeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TimeProperty;
	static struct _TypeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TimelineMarker, ITimelineMarkerStatics>()->_get_TypeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TypeProperty;
};
template<typename X> typename TimelineMarker_statics<X>::_TextProperty TimelineMarker_statics<X>::TextProperty;
template<typename X> typename TimelineMarker_statics<X>::_TimeProperty TimelineMarker_statics<X>::TimeProperty;
template<typename X> typename TimelineMarker_statics<X>::_TypeProperty TimelineMarker_statics<X>::TypeProperty;

template<typename X> struct statics<TimelineMarker, X> : X, Windows::UI::Xaml::Media::TimelineMarker_statics<void> {
	typedef typename X::root_type TimelineMarker;
};
struct TimelineMarker : generate<TimelineMarker> {};

// TimelineMarkerCollection
template<typename X> struct statics<TimelineMarkerCollection, X> : X {
	typedef typename X::root_type TimelineMarkerCollection;
};
struct TimelineMarkerCollection : generate<TimelineMarkerCollection> {};

// ITransformFactory
struct ITransformFactory : IInspectable, generate<ITransformFactory> {};

// ITransform
struct ITransform : IInspectable, generate<ITransform> {};

// IGeneralTransformFactory
struct IGeneralTransformFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, GeneralTransform* *instance);
};

// IGeneralTransformOverrides
struct IGeneralTransformOverrides_raw : IInspectable {
	virtual STDMETHODIMP _get_InverseCore(GeneralTransform* *value) = 0;
	virtual STDMETHODIMP _TryTransformCore(Foundation::Point inPoint, Foundation::Point *outPoint, bool *returnValue) = 0;
	virtual STDMETHODIMP _TransformBoundsCore(Foundation::Rect rect, Foundation::Rect *returnValue) = 0;
};
template<typename X> struct IGeneralTransformOverrides_adaptor : X {
	union {
		struct : property {
			ptr<GeneralTransform> get() { GeneralTransform* value; hrcheck(enc(&IGeneralTransformOverrides_adaptor::InverseCore)->_get_InverseCore(&value)); return from_abi(value); }
			ptr<GeneralTransform> operator()() { return get(); }
			operator ptr<GeneralTransform> () { return get(); }
			ptr<GeneralTransform> operator->() { return get(); }
		} InverseCore;
	};
	bool TryTransformCore(const Foundation::Point& inPoint, Foundation::Point *outPoint) { bool returnValue; hrcheck(X::get()->_TryTransformCore(inPoint, outPoint, &returnValue)); return returnValue; }
	Foundation::Rect TransformBoundsCore(const Foundation::Rect& rect) { Foundation::Rect returnValue; hrcheck(X::get()->_TransformBoundsCore(rect, &returnValue)); return returnValue; }
	IGeneralTransformOverrides_adaptor() {}
};
template<typename X> struct adapt<IGeneralTransformOverrides, X> : Windows::UI::Xaml::Media::IGeneralTransformOverrides_adaptor<X> { typedef adapt IGeneralTransformOverrides; };
template<typename X> struct IGeneralTransformOverrides_unadaptor : X {
	STDMETHODIMP _get_InverseCore(GeneralTransform* *value) { return hrtry([&, this] { get_prop(value, InverseCore); }); }
	STDMETHODIMP _TryTransformCore(Foundation::Point inPoint, Foundation::Point *outPoint, bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->TryTransformCore(inPoint, outPoint); }); }
	STDMETHODIMP _TransformBoundsCore(Foundation::Rect rect, Foundation::Rect *returnValue) { return hrtry([&, this] { *returnValue = X::get()->TransformBoundsCore(rect); }); }
};
template<typename X> struct unadapt<IGeneralTransformOverrides, X> : Windows::UI::Xaml::Media::IGeneralTransformOverrides_unadaptor<X> {};
struct IGeneralTransformOverrides : IGeneralTransformOverrides_raw, generate<IGeneralTransformOverrides> {};

// IGeneralTransform
struct IGeneralTransform_raw : IInspectable {
	virtual STDMETHODIMP _get_Inverse(GeneralTransform* *value);
	virtual STDMETHODIMP _TransformPoint(Foundation::Point point, Foundation::Point *returnValue);
	virtual STDMETHODIMP _TryTransform(Foundation::Point inPoint, Foundation::Point *outPoint, bool *returnValue);
	virtual STDMETHODIMP _TransformBounds(Foundation::Rect rect, Foundation::Rect *returnValue);
};
template<typename X> struct IGeneralTransform_adaptor : X {
	union {
		struct : property {
			ptr<GeneralTransform> get() { GeneralTransform* value; hrcheck(enc(&IGeneralTransform_adaptor::Inverse)->_get_Inverse(&value)); return from_abi(value); }
			ptr<GeneralTransform> operator()() { return get(); }
			operator ptr<GeneralTransform> () { return get(); }
			ptr<GeneralTransform> operator->() { return get(); }
		} Inverse;
	};
	Foundation::Point TransformPoint(const Foundation::Point& point) { Foundation::Point returnValue; hrcheck(X::get()->_TransformPoint(point, &returnValue)); return returnValue; }
	bool TryTransform(const Foundation::Point& inPoint, Foundation::Point *outPoint) { bool returnValue; hrcheck(X::get()->_TryTransform(inPoint, outPoint, &returnValue)); return returnValue; }
	Foundation::Rect TransformBounds(const Foundation::Rect& rect) { Foundation::Rect returnValue; hrcheck(X::get()->_TransformBounds(rect, &returnValue)); return returnValue; }
	IGeneralTransform_adaptor() {}
};
template<typename X> struct adapt<IGeneralTransform, X> : Windows::UI::Xaml::Media::IGeneralTransform_adaptor<X> { typedef adapt IGeneralTransform; };
struct IGeneralTransform : IGeneralTransform_raw, generate<IGeneralTransform> {};

// GeneralTransform
template<typename X> struct statics<GeneralTransform, X> : X {
	typedef typename X::root_type GeneralTransform;
};
struct GeneralTransform : generate<GeneralTransform> {};

// Transform
template<typename X> struct statics<Transform, X> : X {
	typedef typename X::root_type Transform;
};
struct Transform : generate<Transform> {};

// TransformCollection
template<typename X> struct statics<TransformCollection, X> : X {
	typedef typename X::root_type TransformCollection;
};
struct TransformCollection : generate<TransformCollection> {};

// ICacheMode
struct ICacheMode : IInspectable, generate<ICacheMode> {};

// ICacheModeFactory
struct ICacheModeFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, CacheMode* *instance);
};

// CacheMode
template<typename X> struct statics<CacheMode, X> : X {
	typedef typename X::root_type CacheMode;
};
struct CacheMode : generate<CacheMode> {};

// IGeometry
struct IGeometry_raw : IInspectable {
	virtual STDMETHODIMP _get_Transform(Media::Transform* *value);
	virtual STDMETHODIMP _put_Transform(Media::Transform* value);
	virtual STDMETHODIMP _get_Bounds(Foundation::Rect *value);
};
template<typename X> struct IGeometry_adaptor : X {
	union {
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&IGeometry_adaptor::Bounds)->_get_Bounds(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
		} Bounds;
		struct : property {
			ptr<Media::Transform> get() { Media::Transform* value; hrcheck(enc(&IGeometry_adaptor::Transform)->_get_Transform(&value)); return from_abi(value); }
			ptr<Media::Transform> operator()() { return get(); }
			operator ptr<Media::Transform> () { return get(); }
			ptr<Media::Transform> operator->() { return get(); }
			void put(pptr<Media::Transform> value) { hrcheck(enc(&IGeometry_adaptor::Transform)->_put_Transform(value)); }
			void operator=(pptr<Media::Transform> value) { put(value); }
			void operator()(pptr<Media::Transform> value) { put(value); }
		} Transform;
	};
	IGeometry_adaptor() {}
};
template<typename X> struct adapt<IGeometry, X> : Windows::UI::Xaml::Media::IGeometry_adaptor<X> { typedef adapt IGeometry; };
struct IGeometry : IGeometry_raw, generate<IGeometry> {};

// IGeometryStatics
struct IGeometryStatics : IInspectable {
	virtual STDMETHODIMP _get_Empty(Geometry* *value);
	virtual STDMETHODIMP _get_StandardFlatteningTolerance(double *value);
	virtual STDMETHODIMP _get_TransformProperty(DependencyProperty* *value);
};

// IGeometryFactory
struct IGeometryFactory : IInspectable, generate<IGeometryFactory> {};

// Geometry
template<typename> struct Geometry_statics {
	static struct _Empty : property {
		ptr<Geometry> get() { Geometry* value; hrcheck(get_activation_factory<Geometry, IGeometryStatics>()->_get_Empty(&value)); return from_abi(value); }
		ptr<Geometry> operator()() { return get(); }
		operator ptr<Geometry> () { return get(); }
		ptr<Geometry> operator->() { return get(); }
	} Empty;
	static struct _StandardFlatteningTolerance : property {
		double get() { double value; hrcheck(get_activation_factory<Geometry, IGeometryStatics>()->_get_StandardFlatteningTolerance(&value)); return value; }
		double operator()() { return get(); }
		operator double () { return get(); }
	} StandardFlatteningTolerance;
	static struct _TransformProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Geometry, IGeometryStatics>()->_get_TransformProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TransformProperty;
};
template<typename X> typename Geometry_statics<X>::_Empty Geometry_statics<X>::Empty;
template<typename X> typename Geometry_statics<X>::_StandardFlatteningTolerance Geometry_statics<X>::StandardFlatteningTolerance;
template<typename X> typename Geometry_statics<X>::_TransformProperty Geometry_statics<X>::TransformProperty;

template<typename X> struct statics<Geometry, X> : X, Windows::UI::Xaml::Media::Geometry_statics<void> {
	typedef typename X::root_type Geometry;
};
struct Geometry : generate<Geometry> {};

// IImageSource
struct IImageSource : IInspectable, generate<IImageSource> {};

// IImageSourceFactory
struct IImageSourceFactory : IInspectable, generate<IImageSourceFactory> {};

// ImageSource
template<typename X> struct statics<ImageSource, X> : X {
	typedef typename X::root_type ImageSource;
};
struct ImageSource : generate<ImageSource> {};

// IPathSegment
struct IPathSegment : IInspectable, generate<IPathSegment> {};

// IPathSegmentFactory
struct IPathSegmentFactory : IInspectable, generate<IPathSegmentFactory> {};

// PathSegment
template<typename X> struct statics<PathSegment, X> : X {
	typedef typename X::root_type PathSegment;
};
struct PathSegment : generate<PathSegment> {};

// IProjection
struct IProjection : IInspectable, generate<IProjection> {};

// IProjectionFactory
struct IProjectionFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Projection* *instance);
};

// Projection
template<typename X> struct statics<Projection, X> : X {
	typedef typename X::root_type Projection;
};
struct Projection : generate<Projection> {};

// IRateChangedRoutedEventArgs
struct IRateChangedRoutedEventArgs : IInspectable, generate<IRateChangedRoutedEventArgs> {};

// RateChangedRoutedEventArgs
template<typename X> struct statics<RateChangedRoutedEventArgs, X> : X {
	typedef typename X::root_type RateChangedRoutedEventArgs;
};
struct RateChangedRoutedEventArgs : generate<RateChangedRoutedEventArgs> {};

// ITimelineMarkerRoutedEventArgs
struct ITimelineMarkerRoutedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Marker(TimelineMarker* *value);
	virtual STDMETHODIMP _put_Marker(TimelineMarker* value);
};
template<typename X> struct ITimelineMarkerRoutedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<TimelineMarker> get() { TimelineMarker* value; hrcheck(enc(&ITimelineMarkerRoutedEventArgs_adaptor::Marker)->_get_Marker(&value)); return from_abi(value); }
			ptr<TimelineMarker> operator()() { return get(); }
			operator ptr<TimelineMarker> () { return get(); }
			ptr<TimelineMarker> operator->() { return get(); }
			void put(pptr<TimelineMarker> value) { hrcheck(enc(&ITimelineMarkerRoutedEventArgs_adaptor::Marker)->_put_Marker(value)); }
			void operator=(pptr<TimelineMarker> value) { put(value); }
			void operator()(pptr<TimelineMarker> value) { put(value); }
		} Marker;
	};
	ITimelineMarkerRoutedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITimelineMarkerRoutedEventArgs, X> : Windows::UI::Xaml::Media::ITimelineMarkerRoutedEventArgs_adaptor<X> { typedef adapt ITimelineMarkerRoutedEventArgs; };
struct ITimelineMarkerRoutedEventArgs : ITimelineMarkerRoutedEventArgs_raw, generate<ITimelineMarkerRoutedEventArgs> {};

// TimelineMarkerRoutedEventArgs
template<typename X> struct statics<TimelineMarkerRoutedEventArgs, X> : X {
	typedef typename X::root_type TimelineMarkerRoutedEventArgs;
};
struct TimelineMarkerRoutedEventArgs : generate<TimelineMarkerRoutedEventArgs> {};

// IXamlLight
struct IXamlLight : IInspectable, generate<IXamlLight> {};

// IXamlLightOverrides
struct IXamlLightOverrides_raw : IInspectable {
	virtual STDMETHODIMP _GetId(HSTRING *returnValue) = 0;
	virtual STDMETHODIMP _OnConnected(UIElement* newElement) = 0;
	virtual STDMETHODIMP _OnDisconnected(UIElement* oldElement) = 0;
};
template<typename X> struct IXamlLightOverrides_adaptor : X {
	hstring GetId() { HSTRING returnValue; hrcheck(X::get()->_GetId(&returnValue)); return from_abi(returnValue); }
	void OnConnected(pptr<UIElement> newElement) { hrcheck(X::get()->_OnConnected(newElement)); }
	void OnDisconnected(pptr<UIElement> oldElement) { hrcheck(X::get()->_OnDisconnected(oldElement)); }
};
template<typename X> struct adapt<IXamlLightOverrides, X> : Windows::UI::Xaml::Media::IXamlLightOverrides_adaptor<X> { typedef adapt IXamlLightOverrides; };
template<typename X> struct IXamlLightOverrides_unadaptor : X {
	STDMETHODIMP _GetId(HSTRING *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetId()); }); }
	STDMETHODIMP _OnConnected(UIElement* newElement) { return hrtry([&, this] { X::get()->OnConnected(newElement); }); }
	STDMETHODIMP _OnDisconnected(UIElement* oldElement) { return hrtry([&, this] { X::get()->OnDisconnected(oldElement); }); }
};
template<typename X> struct unadapt<IXamlLightOverrides, X> : Windows::UI::Xaml::Media::IXamlLightOverrides_unadaptor<X> {};
struct IXamlLightOverrides : IXamlLightOverrides_raw, generate<IXamlLightOverrides> {};

// IXamlLightProtected
struct IXamlLightProtected_raw : IInspectable {
	virtual STDMETHODIMP _get_CompositionLight(Composition::CompositionLight* *value);
	virtual STDMETHODIMP _put_CompositionLight(Composition::CompositionLight* value);
};
template<typename X> struct IXamlLightProtected_adaptor : X {
	union {
		struct : property {
			ptr<Composition::CompositionLight> get() { Composition::CompositionLight* value; hrcheck(enc(&IXamlLightProtected_adaptor::CompositionLight)->_get_CompositionLight(&value)); return from_abi(value); }
			ptr<Composition::CompositionLight> operator()() { return get(); }
			operator ptr<Composition::CompositionLight> () { return get(); }
			ptr<Composition::CompositionLight> operator->() { return get(); }
			void put(pptr<Composition::CompositionLight> value) { hrcheck(enc(&IXamlLightProtected_adaptor::CompositionLight)->_put_CompositionLight(value)); }
			void operator=(pptr<Composition::CompositionLight> value) { put(value); }
			void operator()(pptr<Composition::CompositionLight> value) { put(value); }
		} CompositionLight;
	};
	IXamlLightProtected_adaptor() {}
};
template<typename X> struct adapt<IXamlLightProtected, X> : Windows::UI::Xaml::Media::IXamlLightProtected_adaptor<X> { typedef adapt IXamlLightProtected; };
struct IXamlLightProtected : IXamlLightProtected_raw, generate<IXamlLightProtected> {};

// IXamlLightFactory
struct IXamlLightFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, XamlLight* *instance);
};

// IXamlLightStatics
struct IXamlLightStatics : IInspectable {
	virtual STDMETHODIMP _AddTargetElement(HSTRING lightId, UIElement* element);
	virtual STDMETHODIMP _RemoveTargetElement(HSTRING lightId, UIElement* element);
	virtual STDMETHODIMP _AddTargetBrush(HSTRING lightId, Brush* brush);
	virtual STDMETHODIMP _RemoveTargetBrush(HSTRING lightId, Brush* brush);
};

// XamlLight
template<typename> struct XamlLight_statics {
	static void AddTargetElement(hstring_ref lightId, pptr<UIElement> element) { hrcheck(get_activation_factory<XamlLight, IXamlLightStatics>()->_AddTargetElement(lightId, element)); }
	static void RemoveTargetElement(hstring_ref lightId, pptr<UIElement> element) { hrcheck(get_activation_factory<XamlLight, IXamlLightStatics>()->_RemoveTargetElement(lightId, element)); }
	static void AddTargetBrush(hstring_ref lightId, pptr<Brush> brush) { hrcheck(get_activation_factory<XamlLight, IXamlLightStatics>()->_AddTargetBrush(lightId, brush)); }
	static void RemoveTargetBrush(hstring_ref lightId, pptr<Brush> brush) { hrcheck(get_activation_factory<XamlLight, IXamlLightStatics>()->_RemoveTargetBrush(lightId, brush)); }
	static XamlLight *activate(object_ref outer, IInspectable* *inner) { XamlLight *instance; hrcheck(get_activation_factory<XamlLight, IXamlLightFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<XamlLight, X> : X, Windows::UI::Xaml::Media::XamlLight_statics<void> {
	using Windows::UI::Xaml::Media::XamlLight_statics<void>::activate;
	typedef typename X::root_type XamlLight;
};
struct XamlLight : generate<XamlLight> {};

// IBitmapCache
struct IBitmapCache : IInspectable, generate<IBitmapCache> {};

// BitmapCache
template<typename X> struct statics<BitmapCache, X> : X {
	typedef typename X::root_type BitmapCache;
};
struct BitmapCache : generate<BitmapCache> {};

// IMatrix3DProjection
struct IMatrix3DProjection_raw : IInspectable {
	virtual STDMETHODIMP _get_ProjectionMatrix(Media3D::Matrix3D *value);
	virtual STDMETHODIMP _put_ProjectionMatrix(Media3D::Matrix3D value);
};
template<typename X> struct IMatrix3DProjection_adaptor : X {
	union {
		struct : property {
			Media3D::Matrix3D get() { Media3D::Matrix3D value; hrcheck(enc(&IMatrix3DProjection_adaptor::ProjectionMatrix)->_get_ProjectionMatrix(&value)); return value; }
			Media3D::Matrix3D operator()() { return get(); }
			operator Media3D::Matrix3D () { return get(); }
			void put(const Media3D::Matrix3D& value) { hrcheck(enc(&IMatrix3DProjection_adaptor::ProjectionMatrix)->_put_ProjectionMatrix(value)); }
			void operator=(const Media3D::Matrix3D& value) { put(value); }
			void operator()(const Media3D::Matrix3D& value) { put(value); }
		} ProjectionMatrix;
	};
	IMatrix3DProjection_adaptor() {}
};
template<typename X> struct adapt<IMatrix3DProjection, X> : Windows::UI::Xaml::Media::IMatrix3DProjection_adaptor<X> { typedef adapt IMatrix3DProjection; };
struct IMatrix3DProjection : IMatrix3DProjection_raw, generate<IMatrix3DProjection> {};

// IMatrix3DProjectionStatics
struct IMatrix3DProjectionStatics : IInspectable {
	virtual STDMETHODIMP _get_ProjectionMatrixProperty(DependencyProperty* *value);
};

// Matrix3DProjection
template<typename> struct Matrix3DProjection_statics {
	static struct _ProjectionMatrixProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Matrix3DProjection, IMatrix3DProjectionStatics>()->_get_ProjectionMatrixProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ProjectionMatrixProperty;
};
template<typename X> typename Matrix3DProjection_statics<X>::_ProjectionMatrixProperty Matrix3DProjection_statics<X>::ProjectionMatrixProperty;

template<typename X> struct statics<Matrix3DProjection, X> : X, Windows::UI::Xaml::Media::Matrix3DProjection_statics<void> {
	typedef typename X::root_type Matrix3DProjection;
};
struct Matrix3DProjection : generate<Matrix3DProjection> {};

// IPlaneProjection
struct IPlaneProjection_raw : IInspectable {
	virtual STDMETHODIMP _get_LocalOffsetX(double *value);
	virtual STDMETHODIMP _put_LocalOffsetX(double value);
	virtual STDMETHODIMP _get_LocalOffsetY(double *value);
	virtual STDMETHODIMP _put_LocalOffsetY(double value);
	virtual STDMETHODIMP _get_LocalOffsetZ(double *value);
	virtual STDMETHODIMP _put_LocalOffsetZ(double value);
	virtual STDMETHODIMP _get_RotationX(double *value);
	virtual STDMETHODIMP _put_RotationX(double value);
	virtual STDMETHODIMP _get_RotationY(double *value);
	virtual STDMETHODIMP _put_RotationY(double value);
	virtual STDMETHODIMP _get_RotationZ(double *value);
	virtual STDMETHODIMP _put_RotationZ(double value);
	virtual STDMETHODIMP _get_CenterOfRotationX(double *value);
	virtual STDMETHODIMP _put_CenterOfRotationX(double value);
	virtual STDMETHODIMP _get_CenterOfRotationY(double *value);
	virtual STDMETHODIMP _put_CenterOfRotationY(double value);
	virtual STDMETHODIMP _get_CenterOfRotationZ(double *value);
	virtual STDMETHODIMP _put_CenterOfRotationZ(double value);
	virtual STDMETHODIMP _get_GlobalOffsetX(double *value);
	virtual STDMETHODIMP _put_GlobalOffsetX(double value);
	virtual STDMETHODIMP _get_GlobalOffsetY(double *value);
	virtual STDMETHODIMP _put_GlobalOffsetY(double value);
	virtual STDMETHODIMP _get_GlobalOffsetZ(double *value);
	virtual STDMETHODIMP _put_GlobalOffsetZ(double value);
	virtual STDMETHODIMP _get_ProjectionMatrix(Media3D::Matrix3D *value);
};
template<typename X> struct IPlaneProjection_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IPlaneProjection_adaptor::CenterOfRotationX)->_get_CenterOfRotationX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPlaneProjection_adaptor::CenterOfRotationX)->_put_CenterOfRotationX(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CenterOfRotationX;
		struct : property {
			double get() { double value; hrcheck(enc(&IPlaneProjection_adaptor::CenterOfRotationY)->_get_CenterOfRotationY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPlaneProjection_adaptor::CenterOfRotationY)->_put_CenterOfRotationY(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CenterOfRotationY;
		struct : property {
			double get() { double value; hrcheck(enc(&IPlaneProjection_adaptor::CenterOfRotationZ)->_get_CenterOfRotationZ(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPlaneProjection_adaptor::CenterOfRotationZ)->_put_CenterOfRotationZ(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CenterOfRotationZ;
		struct : property {
			double get() { double value; hrcheck(enc(&IPlaneProjection_adaptor::GlobalOffsetX)->_get_GlobalOffsetX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPlaneProjection_adaptor::GlobalOffsetX)->_put_GlobalOffsetX(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} GlobalOffsetX;
		struct : property {
			double get() { double value; hrcheck(enc(&IPlaneProjection_adaptor::GlobalOffsetY)->_get_GlobalOffsetY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPlaneProjection_adaptor::GlobalOffsetY)->_put_GlobalOffsetY(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} GlobalOffsetY;
		struct : property {
			double get() { double value; hrcheck(enc(&IPlaneProjection_adaptor::GlobalOffsetZ)->_get_GlobalOffsetZ(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPlaneProjection_adaptor::GlobalOffsetZ)->_put_GlobalOffsetZ(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} GlobalOffsetZ;
		struct : property {
			double get() { double value; hrcheck(enc(&IPlaneProjection_adaptor::LocalOffsetX)->_get_LocalOffsetX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPlaneProjection_adaptor::LocalOffsetX)->_put_LocalOffsetX(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} LocalOffsetX;
		struct : property {
			double get() { double value; hrcheck(enc(&IPlaneProjection_adaptor::LocalOffsetY)->_get_LocalOffsetY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPlaneProjection_adaptor::LocalOffsetY)->_put_LocalOffsetY(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} LocalOffsetY;
		struct : property {
			double get() { double value; hrcheck(enc(&IPlaneProjection_adaptor::LocalOffsetZ)->_get_LocalOffsetZ(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPlaneProjection_adaptor::LocalOffsetZ)->_put_LocalOffsetZ(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} LocalOffsetZ;
		struct : property {
			Media3D::Matrix3D get() { Media3D::Matrix3D value; hrcheck(enc(&IPlaneProjection_adaptor::ProjectionMatrix)->_get_ProjectionMatrix(&value)); return value; }
			Media3D::Matrix3D operator()() { return get(); }
			operator Media3D::Matrix3D () { return get(); }
		} ProjectionMatrix;
		struct : property {
			double get() { double value; hrcheck(enc(&IPlaneProjection_adaptor::RotationX)->_get_RotationX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPlaneProjection_adaptor::RotationX)->_put_RotationX(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} RotationX;
		struct : property {
			double get() { double value; hrcheck(enc(&IPlaneProjection_adaptor::RotationY)->_get_RotationY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPlaneProjection_adaptor::RotationY)->_put_RotationY(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} RotationY;
		struct : property {
			double get() { double value; hrcheck(enc(&IPlaneProjection_adaptor::RotationZ)->_get_RotationZ(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPlaneProjection_adaptor::RotationZ)->_put_RotationZ(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} RotationZ;
	};
	IPlaneProjection_adaptor() {}
};
template<typename X> struct adapt<IPlaneProjection, X> : Windows::UI::Xaml::Media::IPlaneProjection_adaptor<X> { typedef adapt IPlaneProjection; };
struct IPlaneProjection : IPlaneProjection_raw, generate<IPlaneProjection> {};

// IPlaneProjectionStatics
struct IPlaneProjectionStatics : IInspectable {
	virtual STDMETHODIMP _get_LocalOffsetXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_LocalOffsetYProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_LocalOffsetZProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RotationXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RotationYProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RotationZProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CenterOfRotationXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CenterOfRotationYProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CenterOfRotationZProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_GlobalOffsetXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_GlobalOffsetYProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_GlobalOffsetZProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ProjectionMatrixProperty(DependencyProperty* *value);
};

// PlaneProjection
template<typename> struct PlaneProjection_statics {
	static struct _CenterOfRotationXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PlaneProjection, IPlaneProjectionStatics>()->_get_CenterOfRotationXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CenterOfRotationXProperty;
	static struct _CenterOfRotationYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PlaneProjection, IPlaneProjectionStatics>()->_get_CenterOfRotationYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CenterOfRotationYProperty;
	static struct _CenterOfRotationZProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PlaneProjection, IPlaneProjectionStatics>()->_get_CenterOfRotationZProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CenterOfRotationZProperty;
	static struct _GlobalOffsetXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PlaneProjection, IPlaneProjectionStatics>()->_get_GlobalOffsetXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GlobalOffsetXProperty;
	static struct _GlobalOffsetYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PlaneProjection, IPlaneProjectionStatics>()->_get_GlobalOffsetYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GlobalOffsetYProperty;
	static struct _GlobalOffsetZProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PlaneProjection, IPlaneProjectionStatics>()->_get_GlobalOffsetZProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GlobalOffsetZProperty;
	static struct _LocalOffsetXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PlaneProjection, IPlaneProjectionStatics>()->_get_LocalOffsetXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LocalOffsetXProperty;
	static struct _LocalOffsetYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PlaneProjection, IPlaneProjectionStatics>()->_get_LocalOffsetYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LocalOffsetYProperty;
	static struct _LocalOffsetZProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PlaneProjection, IPlaneProjectionStatics>()->_get_LocalOffsetZProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LocalOffsetZProperty;
	static struct _ProjectionMatrixProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PlaneProjection, IPlaneProjectionStatics>()->_get_ProjectionMatrixProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ProjectionMatrixProperty;
	static struct _RotationXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PlaneProjection, IPlaneProjectionStatics>()->_get_RotationXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RotationXProperty;
	static struct _RotationYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PlaneProjection, IPlaneProjectionStatics>()->_get_RotationYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RotationYProperty;
	static struct _RotationZProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PlaneProjection, IPlaneProjectionStatics>()->_get_RotationZProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RotationZProperty;
};
template<typename X> typename PlaneProjection_statics<X>::_CenterOfRotationXProperty PlaneProjection_statics<X>::CenterOfRotationXProperty;
template<typename X> typename PlaneProjection_statics<X>::_CenterOfRotationYProperty PlaneProjection_statics<X>::CenterOfRotationYProperty;
template<typename X> typename PlaneProjection_statics<X>::_CenterOfRotationZProperty PlaneProjection_statics<X>::CenterOfRotationZProperty;
template<typename X> typename PlaneProjection_statics<X>::_GlobalOffsetXProperty PlaneProjection_statics<X>::GlobalOffsetXProperty;
template<typename X> typename PlaneProjection_statics<X>::_GlobalOffsetYProperty PlaneProjection_statics<X>::GlobalOffsetYProperty;
template<typename X> typename PlaneProjection_statics<X>::_GlobalOffsetZProperty PlaneProjection_statics<X>::GlobalOffsetZProperty;
template<typename X> typename PlaneProjection_statics<X>::_LocalOffsetXProperty PlaneProjection_statics<X>::LocalOffsetXProperty;
template<typename X> typename PlaneProjection_statics<X>::_LocalOffsetYProperty PlaneProjection_statics<X>::LocalOffsetYProperty;
template<typename X> typename PlaneProjection_statics<X>::_LocalOffsetZProperty PlaneProjection_statics<X>::LocalOffsetZProperty;
template<typename X> typename PlaneProjection_statics<X>::_ProjectionMatrixProperty PlaneProjection_statics<X>::ProjectionMatrixProperty;
template<typename X> typename PlaneProjection_statics<X>::_RotationXProperty PlaneProjection_statics<X>::RotationXProperty;
template<typename X> typename PlaneProjection_statics<X>::_RotationYProperty PlaneProjection_statics<X>::RotationYProperty;
template<typename X> typename PlaneProjection_statics<X>::_RotationZProperty PlaneProjection_statics<X>::RotationZProperty;

template<typename X> struct statics<PlaneProjection, X> : X, Windows::UI::Xaml::Media::PlaneProjection_statics<void> {
	typedef typename X::root_type PlaneProjection;
};
struct PlaneProjection : generate<PlaneProjection> {};

// IRectangleGeometry
struct IRectangleGeometry_raw : IInspectable {
	virtual STDMETHODIMP _get_Rect(Foundation::Rect *value);
	virtual STDMETHODIMP _put_Rect(Foundation::Rect value);
};
template<typename X> struct IRectangleGeometry_adaptor : X {
	union {
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&IRectangleGeometry_adaptor::Rect)->_get_Rect(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
			void put(const Foundation::Rect& value) { hrcheck(enc(&IRectangleGeometry_adaptor::Rect)->_put_Rect(value)); }
			void operator=(const Foundation::Rect& value) { put(value); }
			void operator()(const Foundation::Rect& value) { put(value); }
		} Rect;
	};
	IRectangleGeometry_adaptor() {}
};
template<typename X> struct adapt<IRectangleGeometry, X> : Windows::UI::Xaml::Media::IRectangleGeometry_adaptor<X> { typedef adapt IRectangleGeometry; };
struct IRectangleGeometry : IRectangleGeometry_raw, generate<IRectangleGeometry> {};

// IRectangleGeometryStatics
struct IRectangleGeometryStatics : IInspectable {
	virtual STDMETHODIMP _get_RectProperty(DependencyProperty* *value);
};

// RectangleGeometry
template<typename> struct RectangleGeometry_statics {
	static struct _RectProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RectangleGeometry, IRectangleGeometryStatics>()->_get_RectProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RectProperty;
};
template<typename X> typename RectangleGeometry_statics<X>::_RectProperty RectangleGeometry_statics<X>::RectProperty;

template<typename X> struct statics<RectangleGeometry, X> : X, Windows::UI::Xaml::Media::RectangleGeometry_statics<void> {
	typedef typename X::root_type RectangleGeometry;
};
struct RectangleGeometry : generate<RectangleGeometry> {};

// ISolidColorBrush
struct ISolidColorBrush_raw : IInspectable {
	virtual STDMETHODIMP _get_Color(UI::Color *value);
	virtual STDMETHODIMP _put_Color(UI::Color value);
};
template<typename X> struct ISolidColorBrush_adaptor : X {
	union {
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&ISolidColorBrush_adaptor::Color)->_get_Color(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&ISolidColorBrush_adaptor::Color)->_put_Color(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} Color;
	};
	ISolidColorBrush_adaptor() {}
};
template<typename X> struct adapt<ISolidColorBrush, X> : Windows::UI::Xaml::Media::ISolidColorBrush_adaptor<X> { typedef adapt ISolidColorBrush; };
struct ISolidColorBrush : ISolidColorBrush_raw, generate<ISolidColorBrush> {};

// ISolidColorBrushStatics
struct ISolidColorBrushStatics : IInspectable {
	virtual STDMETHODIMP _get_ColorProperty(DependencyProperty* *value);
};

// ISolidColorBrushFactory
struct ISolidColorBrushFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithColor(Color color, SolidColorBrush* *instance);
};

// SolidColorBrush
template<typename> struct SolidColorBrush_statics {
	static struct _ColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SolidColorBrush, ISolidColorBrushStatics>()->_get_ColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ColorProperty;
	static SolidColorBrush *activate() { SolidColorBrush *t; get_activation_factory<SolidColorBrush>()->ActivateInstance((IInspectable**)&t); return t; }
	static SolidColorBrush *activate(const UI::Color& color) { SolidColorBrush *instance; hrcheck(get_activation_factory<SolidColorBrush, ISolidColorBrushFactory>()->_CreateInstanceWithColor(color, &instance)); return instance; }
};
template<typename X> typename SolidColorBrush_statics<X>::_ColorProperty SolidColorBrush_statics<X>::ColorProperty;

template<typename X> struct statics<SolidColorBrush, X> : X, Windows::UI::Xaml::Media::SolidColorBrush_statics<void> {
	using Windows::UI::Xaml::Media::SolidColorBrush_statics<void>::activate;
	typedef typename X::root_type SolidColorBrush;
};
struct SolidColorBrush : generate<SolidColorBrush> {};

// ICompositeTransform
struct ICompositeTransform_raw : IInspectable {
	virtual STDMETHODIMP _get_CenterX(double *value);
	virtual STDMETHODIMP _put_CenterX(double value);
	virtual STDMETHODIMP _get_CenterY(double *value);
	virtual STDMETHODIMP _put_CenterY(double value);
	virtual STDMETHODIMP _get_ScaleX(double *value);
	virtual STDMETHODIMP _put_ScaleX(double value);
	virtual STDMETHODIMP _get_ScaleY(double *value);
	virtual STDMETHODIMP _put_ScaleY(double value);
	virtual STDMETHODIMP _get_SkewX(double *value);
	virtual STDMETHODIMP _put_SkewX(double value);
	virtual STDMETHODIMP _get_SkewY(double *value);
	virtual STDMETHODIMP _put_SkewY(double value);
	virtual STDMETHODIMP _get_Rotation(double *value);
	virtual STDMETHODIMP _put_Rotation(double value);
	virtual STDMETHODIMP _get_TranslateX(double *value);
	virtual STDMETHODIMP _put_TranslateX(double value);
	virtual STDMETHODIMP _get_TranslateY(double *value);
	virtual STDMETHODIMP _put_TranslateY(double value);
};
template<typename X> struct ICompositeTransform_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&ICompositeTransform_adaptor::CenterX)->_get_CenterX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ICompositeTransform_adaptor::CenterX)->_put_CenterX(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CenterX;
		struct : property {
			double get() { double value; hrcheck(enc(&ICompositeTransform_adaptor::CenterY)->_get_CenterY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ICompositeTransform_adaptor::CenterY)->_put_CenterY(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CenterY;
		struct : property {
			double get() { double value; hrcheck(enc(&ICompositeTransform_adaptor::Rotation)->_get_Rotation(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ICompositeTransform_adaptor::Rotation)->_put_Rotation(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Rotation;
		struct : property {
			double get() { double value; hrcheck(enc(&ICompositeTransform_adaptor::ScaleX)->_get_ScaleX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ICompositeTransform_adaptor::ScaleX)->_put_ScaleX(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ScaleX;
		struct : property {
			double get() { double value; hrcheck(enc(&ICompositeTransform_adaptor::ScaleY)->_get_ScaleY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ICompositeTransform_adaptor::ScaleY)->_put_ScaleY(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ScaleY;
		struct : property {
			double get() { double value; hrcheck(enc(&ICompositeTransform_adaptor::SkewX)->_get_SkewX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ICompositeTransform_adaptor::SkewX)->_put_SkewX(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} SkewX;
		struct : property {
			double get() { double value; hrcheck(enc(&ICompositeTransform_adaptor::SkewY)->_get_SkewY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ICompositeTransform_adaptor::SkewY)->_put_SkewY(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} SkewY;
		struct : property {
			double get() { double value; hrcheck(enc(&ICompositeTransform_adaptor::TranslateX)->_get_TranslateX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ICompositeTransform_adaptor::TranslateX)->_put_TranslateX(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} TranslateX;
		struct : property {
			double get() { double value; hrcheck(enc(&ICompositeTransform_adaptor::TranslateY)->_get_TranslateY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ICompositeTransform_adaptor::TranslateY)->_put_TranslateY(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} TranslateY;
	};
	ICompositeTransform_adaptor() {}
};
template<typename X> struct adapt<ICompositeTransform, X> : Windows::UI::Xaml::Media::ICompositeTransform_adaptor<X> { typedef adapt ICompositeTransform; };
struct ICompositeTransform : ICompositeTransform_raw, generate<ICompositeTransform> {};

// ICompositeTransformStatics
struct ICompositeTransformStatics : IInspectable {
	virtual STDMETHODIMP _get_CenterXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CenterYProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ScaleXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ScaleYProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SkewXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SkewYProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RotationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TranslateXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TranslateYProperty(DependencyProperty* *value);
};

// CompositeTransform
template<typename> struct CompositeTransform_statics {
	static struct _CenterXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CompositeTransform, ICompositeTransformStatics>()->_get_CenterXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CenterXProperty;
	static struct _CenterYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CompositeTransform, ICompositeTransformStatics>()->_get_CenterYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CenterYProperty;
	static struct _RotationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CompositeTransform, ICompositeTransformStatics>()->_get_RotationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RotationProperty;
	static struct _ScaleXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CompositeTransform, ICompositeTransformStatics>()->_get_ScaleXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ScaleXProperty;
	static struct _ScaleYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CompositeTransform, ICompositeTransformStatics>()->_get_ScaleYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ScaleYProperty;
	static struct _SkewXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CompositeTransform, ICompositeTransformStatics>()->_get_SkewXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SkewXProperty;
	static struct _SkewYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CompositeTransform, ICompositeTransformStatics>()->_get_SkewYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SkewYProperty;
	static struct _TranslateXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CompositeTransform, ICompositeTransformStatics>()->_get_TranslateXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TranslateXProperty;
	static struct _TranslateYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CompositeTransform, ICompositeTransformStatics>()->_get_TranslateYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TranslateYProperty;
};
template<typename X> typename CompositeTransform_statics<X>::_CenterXProperty CompositeTransform_statics<X>::CenterXProperty;
template<typename X> typename CompositeTransform_statics<X>::_CenterYProperty CompositeTransform_statics<X>::CenterYProperty;
template<typename X> typename CompositeTransform_statics<X>::_RotationProperty CompositeTransform_statics<X>::RotationProperty;
template<typename X> typename CompositeTransform_statics<X>::_ScaleXProperty CompositeTransform_statics<X>::ScaleXProperty;
template<typename X> typename CompositeTransform_statics<X>::_ScaleYProperty CompositeTransform_statics<X>::ScaleYProperty;
template<typename X> typename CompositeTransform_statics<X>::_SkewXProperty CompositeTransform_statics<X>::SkewXProperty;
template<typename X> typename CompositeTransform_statics<X>::_SkewYProperty CompositeTransform_statics<X>::SkewYProperty;
template<typename X> typename CompositeTransform_statics<X>::_TranslateXProperty CompositeTransform_statics<X>::TranslateXProperty;
template<typename X> typename CompositeTransform_statics<X>::_TranslateYProperty CompositeTransform_statics<X>::TranslateYProperty;

template<typename X> struct statics<CompositeTransform, X> : X, Windows::UI::Xaml::Media::CompositeTransform_statics<void> {
	typedef typename X::root_type CompositeTransform;
};
struct CompositeTransform : generate<CompositeTransform> {};

// IMatrixTransform
struct IMatrixTransform_raw : IInspectable {
	virtual STDMETHODIMP _get_Matrix(Media::Matrix *value);
	virtual STDMETHODIMP _put_Matrix(Media::Matrix value);
};
template<typename X> struct IMatrixTransform_adaptor : X {
	union {
		struct : property {
			Media::Matrix get() { Media::Matrix value; hrcheck(enc(&IMatrixTransform_adaptor::Matrix)->_get_Matrix(&value)); return value; }
			Media::Matrix operator()() { return get(); }
			operator Media::Matrix () { return get(); }
			void put(const Media::Matrix& value) { hrcheck(enc(&IMatrixTransform_adaptor::Matrix)->_put_Matrix(value)); }
			void operator=(const Media::Matrix& value) { put(value); }
			void operator()(const Media::Matrix& value) { put(value); }
		} Matrix;
	};
	IMatrixTransform_adaptor() {}
};
template<typename X> struct adapt<IMatrixTransform, X> : Windows::UI::Xaml::Media::IMatrixTransform_adaptor<X> { typedef adapt IMatrixTransform; };
struct IMatrixTransform : IMatrixTransform_raw, generate<IMatrixTransform> {};

// IMatrixTransformStatics
struct IMatrixTransformStatics : IInspectable {
	virtual STDMETHODIMP _get_MatrixProperty(DependencyProperty* *value);
};

// MatrixTransform
template<typename> struct MatrixTransform_statics {
	static struct _MatrixProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MatrixTransform, IMatrixTransformStatics>()->_get_MatrixProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MatrixProperty;
};
template<typename X> typename MatrixTransform_statics<X>::_MatrixProperty MatrixTransform_statics<X>::MatrixProperty;

template<typename X> struct statics<MatrixTransform, X> : X, Windows::UI::Xaml::Media::MatrixTransform_statics<void> {
	typedef typename X::root_type MatrixTransform;
};
struct MatrixTransform : generate<MatrixTransform> {};

// IRotateTransform
struct IRotateTransform_raw : IInspectable {
	virtual STDMETHODIMP _get_CenterX(double *value);
	virtual STDMETHODIMP _put_CenterX(double value);
	virtual STDMETHODIMP _get_CenterY(double *value);
	virtual STDMETHODIMP _put_CenterY(double value);
	virtual STDMETHODIMP _get_Angle(double *value);
	virtual STDMETHODIMP _put_Angle(double value);
};
template<typename X> struct IRotateTransform_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IRotateTransform_adaptor::Angle)->_get_Angle(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRotateTransform_adaptor::Angle)->_put_Angle(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Angle;
		struct : property {
			double get() { double value; hrcheck(enc(&IRotateTransform_adaptor::CenterX)->_get_CenterX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRotateTransform_adaptor::CenterX)->_put_CenterX(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CenterX;
		struct : property {
			double get() { double value; hrcheck(enc(&IRotateTransform_adaptor::CenterY)->_get_CenterY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRotateTransform_adaptor::CenterY)->_put_CenterY(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CenterY;
	};
	IRotateTransform_adaptor() {}
};
template<typename X> struct adapt<IRotateTransform, X> : Windows::UI::Xaml::Media::IRotateTransform_adaptor<X> { typedef adapt IRotateTransform; };
struct IRotateTransform : IRotateTransform_raw, generate<IRotateTransform> {};

// IRotateTransformStatics
struct IRotateTransformStatics : IInspectable {
	virtual STDMETHODIMP _get_CenterXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CenterYProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AngleProperty(DependencyProperty* *value);
};

// RotateTransform
template<typename> struct RotateTransform_statics {
	static struct _AngleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RotateTransform, IRotateTransformStatics>()->_get_AngleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AngleProperty;
	static struct _CenterXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RotateTransform, IRotateTransformStatics>()->_get_CenterXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CenterXProperty;
	static struct _CenterYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RotateTransform, IRotateTransformStatics>()->_get_CenterYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CenterYProperty;
};
template<typename X> typename RotateTransform_statics<X>::_AngleProperty RotateTransform_statics<X>::AngleProperty;
template<typename X> typename RotateTransform_statics<X>::_CenterXProperty RotateTransform_statics<X>::CenterXProperty;
template<typename X> typename RotateTransform_statics<X>::_CenterYProperty RotateTransform_statics<X>::CenterYProperty;

template<typename X> struct statics<RotateTransform, X> : X, Windows::UI::Xaml::Media::RotateTransform_statics<void> {
	typedef typename X::root_type RotateTransform;
};
struct RotateTransform : generate<RotateTransform> {};

// IScaleTransform
struct IScaleTransform_raw : IInspectable {
	virtual STDMETHODIMP _get_CenterX(double *value);
	virtual STDMETHODIMP _put_CenterX(double value);
	virtual STDMETHODIMP _get_CenterY(double *value);
	virtual STDMETHODIMP _put_CenterY(double value);
	virtual STDMETHODIMP _get_ScaleX(double *value);
	virtual STDMETHODIMP _put_ScaleX(double value);
	virtual STDMETHODIMP _get_ScaleY(double *value);
	virtual STDMETHODIMP _put_ScaleY(double value);
};
template<typename X> struct IScaleTransform_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IScaleTransform_adaptor::CenterX)->_get_CenterX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IScaleTransform_adaptor::CenterX)->_put_CenterX(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CenterX;
		struct : property {
			double get() { double value; hrcheck(enc(&IScaleTransform_adaptor::CenterY)->_get_CenterY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IScaleTransform_adaptor::CenterY)->_put_CenterY(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CenterY;
		struct : property {
			double get() { double value; hrcheck(enc(&IScaleTransform_adaptor::ScaleX)->_get_ScaleX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IScaleTransform_adaptor::ScaleX)->_put_ScaleX(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ScaleX;
		struct : property {
			double get() { double value; hrcheck(enc(&IScaleTransform_adaptor::ScaleY)->_get_ScaleY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IScaleTransform_adaptor::ScaleY)->_put_ScaleY(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ScaleY;
	};
	IScaleTransform_adaptor() {}
};
template<typename X> struct adapt<IScaleTransform, X> : Windows::UI::Xaml::Media::IScaleTransform_adaptor<X> { typedef adapt IScaleTransform; };
struct IScaleTransform : IScaleTransform_raw, generate<IScaleTransform> {};

// IScaleTransformStatics
struct IScaleTransformStatics : IInspectable {
	virtual STDMETHODIMP _get_CenterXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CenterYProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ScaleXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ScaleYProperty(DependencyProperty* *value);
};

// ScaleTransform
template<typename> struct ScaleTransform_statics {
	static struct _CenterXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScaleTransform, IScaleTransformStatics>()->_get_CenterXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CenterXProperty;
	static struct _CenterYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScaleTransform, IScaleTransformStatics>()->_get_CenterYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CenterYProperty;
	static struct _ScaleXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScaleTransform, IScaleTransformStatics>()->_get_ScaleXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ScaleXProperty;
	static struct _ScaleYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScaleTransform, IScaleTransformStatics>()->_get_ScaleYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ScaleYProperty;
};
template<typename X> typename ScaleTransform_statics<X>::_CenterXProperty ScaleTransform_statics<X>::CenterXProperty;
template<typename X> typename ScaleTransform_statics<X>::_CenterYProperty ScaleTransform_statics<X>::CenterYProperty;
template<typename X> typename ScaleTransform_statics<X>::_ScaleXProperty ScaleTransform_statics<X>::ScaleXProperty;
template<typename X> typename ScaleTransform_statics<X>::_ScaleYProperty ScaleTransform_statics<X>::ScaleYProperty;

template<typename X> struct statics<ScaleTransform, X> : X, Windows::UI::Xaml::Media::ScaleTransform_statics<void> {
	typedef typename X::root_type ScaleTransform;
};
struct ScaleTransform : generate<ScaleTransform> {};

// ISkewTransform
struct ISkewTransform_raw : IInspectable {
	virtual STDMETHODIMP _get_CenterX(double *value);
	virtual STDMETHODIMP _put_CenterX(double value);
	virtual STDMETHODIMP _get_CenterY(double *value);
	virtual STDMETHODIMP _put_CenterY(double value);
	virtual STDMETHODIMP _get_AngleX(double *value);
	virtual STDMETHODIMP _put_AngleX(double value);
	virtual STDMETHODIMP _get_AngleY(double *value);
	virtual STDMETHODIMP _put_AngleY(double value);
};
template<typename X> struct ISkewTransform_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&ISkewTransform_adaptor::AngleX)->_get_AngleX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISkewTransform_adaptor::AngleX)->_put_AngleX(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} AngleX;
		struct : property {
			double get() { double value; hrcheck(enc(&ISkewTransform_adaptor::AngleY)->_get_AngleY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISkewTransform_adaptor::AngleY)->_put_AngleY(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} AngleY;
		struct : property {
			double get() { double value; hrcheck(enc(&ISkewTransform_adaptor::CenterX)->_get_CenterX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISkewTransform_adaptor::CenterX)->_put_CenterX(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CenterX;
		struct : property {
			double get() { double value; hrcheck(enc(&ISkewTransform_adaptor::CenterY)->_get_CenterY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISkewTransform_adaptor::CenterY)->_put_CenterY(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CenterY;
	};
	ISkewTransform_adaptor() {}
};
template<typename X> struct adapt<ISkewTransform, X> : Windows::UI::Xaml::Media::ISkewTransform_adaptor<X> { typedef adapt ISkewTransform; };
struct ISkewTransform : ISkewTransform_raw, generate<ISkewTransform> {};

// ISkewTransformStatics
struct ISkewTransformStatics : IInspectable {
	virtual STDMETHODIMP _get_CenterXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CenterYProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AngleXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AngleYProperty(DependencyProperty* *value);
};

// SkewTransform
template<typename> struct SkewTransform_statics {
	static struct _AngleXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SkewTransform, ISkewTransformStatics>()->_get_AngleXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AngleXProperty;
	static struct _AngleYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SkewTransform, ISkewTransformStatics>()->_get_AngleYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AngleYProperty;
	static struct _CenterXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SkewTransform, ISkewTransformStatics>()->_get_CenterXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CenterXProperty;
	static struct _CenterYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SkewTransform, ISkewTransformStatics>()->_get_CenterYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CenterYProperty;
};
template<typename X> typename SkewTransform_statics<X>::_AngleXProperty SkewTransform_statics<X>::AngleXProperty;
template<typename X> typename SkewTransform_statics<X>::_AngleYProperty SkewTransform_statics<X>::AngleYProperty;
template<typename X> typename SkewTransform_statics<X>::_CenterXProperty SkewTransform_statics<X>::CenterXProperty;
template<typename X> typename SkewTransform_statics<X>::_CenterYProperty SkewTransform_statics<X>::CenterYProperty;

template<typename X> struct statics<SkewTransform, X> : X, Windows::UI::Xaml::Media::SkewTransform_statics<void> {
	typedef typename X::root_type SkewTransform;
};
struct SkewTransform : generate<SkewTransform> {};

// ITransformGroup
struct ITransformGroup_raw : IInspectable {
	virtual STDMETHODIMP _get_Children(TransformCollection* *value);
	virtual STDMETHODIMP _put_Children(TransformCollection* value);
	virtual STDMETHODIMP _get_Value(Matrix *value);
};
template<typename X> struct ITransformGroup_adaptor : X {
	union {
		struct : property {
			ptr<TransformCollection> get() { TransformCollection* value; hrcheck(enc(&ITransformGroup_adaptor::Children)->_get_Children(&value)); return from_abi(value); }
			ptr<TransformCollection> operator()() { return get(); }
			operator ptr<TransformCollection> () { return get(); }
			ptr<TransformCollection> operator->() { return get(); }
			void put(pptr<TransformCollection> value) { hrcheck(enc(&ITransformGroup_adaptor::Children)->_put_Children(value)); }
			void operator=(pptr<TransformCollection> value) { put(value); }
			void operator()(pptr<TransformCollection> value) { put(value); }
		} Children;
		struct : property {
			Matrix get() { Matrix value; hrcheck(enc(&ITransformGroup_adaptor::Value)->_get_Value(&value)); return value; }
			Matrix operator()() { return get(); }
			operator Matrix () { return get(); }
		} Value;
	};
	ITransformGroup_adaptor() {}
};
template<typename X> struct adapt<ITransformGroup, X> : Windows::UI::Xaml::Media::ITransformGroup_adaptor<X> { typedef adapt ITransformGroup; };
struct ITransformGroup : ITransformGroup_raw, generate<ITransformGroup> {};

// ITransformGroupStatics
struct ITransformGroupStatics : IInspectable {
	virtual STDMETHODIMP _get_ChildrenProperty(DependencyProperty* *value);
};

// TransformGroup
template<typename> struct TransformGroup_statics {
	static struct _ChildrenProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TransformGroup, ITransformGroupStatics>()->_get_ChildrenProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ChildrenProperty;
};
template<typename X> typename TransformGroup_statics<X>::_ChildrenProperty TransformGroup_statics<X>::ChildrenProperty;

template<typename X> struct statics<TransformGroup, X> : X, Windows::UI::Xaml::Media::TransformGroup_statics<void> {
	typedef typename X::root_type TransformGroup;
};
struct TransformGroup : generate<TransformGroup> {};

// ITranslateTransform
struct ITranslateTransform_raw : IInspectable {
	virtual STDMETHODIMP _get_X(double *value);
	virtual STDMETHODIMP _put_X(double value);
	virtual STDMETHODIMP _get_Y(double *value);
	virtual STDMETHODIMP _put_Y(double value);
};
template<typename Z> struct ITranslateTransform_adaptor : Z {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&ITranslateTransform_adaptor::X)->_get_X(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ITranslateTransform_adaptor::X)->_put_X(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} X;
		struct : property {
			double get() { double value; hrcheck(enc(&ITranslateTransform_adaptor::Y)->_get_Y(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ITranslateTransform_adaptor::Y)->_put_Y(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Y;
	};
	ITranslateTransform_adaptor() {}
};
template<typename X> struct adapt<ITranslateTransform, X> : Windows::UI::Xaml::Media::ITranslateTransform_adaptor<X> { typedef adapt ITranslateTransform; };
struct ITranslateTransform : ITranslateTransform_raw, generate<ITranslateTransform> {};

// ITranslateTransformStatics
struct ITranslateTransformStatics : IInspectable {
	virtual STDMETHODIMP _get_XProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_YProperty(DependencyProperty* *value);
};

// TranslateTransform
template<typename> struct TranslateTransform_statics {
	static struct _XProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TranslateTransform, ITranslateTransformStatics>()->_get_XProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} XProperty;
	static struct _YProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TranslateTransform, ITranslateTransformStatics>()->_get_YProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} YProperty;
};
template<typename X> typename TranslateTransform_statics<X>::_XProperty TranslateTransform_statics<X>::XProperty;
template<typename X> typename TranslateTransform_statics<X>::_YProperty TranslateTransform_statics<X>::YProperty;

template<typename X> struct statics<TranslateTransform, X> : X, Windows::UI::Xaml::Media::TranslateTransform_statics<void> {
	typedef typename X::root_type TranslateTransform;
};
struct TranslateTransform : generate<TranslateTransform> {};

// GeometryCollection
template<typename X> struct statics<GeometryCollection, X> : X {
	typedef typename X::root_type GeometryCollection;
};
struct GeometryCollection : generate<GeometryCollection> {};

// IGradientStopStatics
struct IGradientStopStatics : IInspectable {
	virtual STDMETHODIMP _get_ColorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OffsetProperty(DependencyProperty* *value);
};

// IGradientStop
struct IGradientStop_raw : IInspectable {
	virtual STDMETHODIMP _get_Color(UI::Color *value);
	virtual STDMETHODIMP _put_Color(UI::Color value);
	virtual STDMETHODIMP _get_Offset(double *value);
	virtual STDMETHODIMP _put_Offset(double value);
};
template<typename X> struct IGradientStop_adaptor : X {
	union {
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&IGradientStop_adaptor::Color)->_get_Color(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IGradientStop_adaptor::Color)->_put_Color(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} Color;
		struct : property {
			double get() { double value; hrcheck(enc(&IGradientStop_adaptor::Offset)->_get_Offset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IGradientStop_adaptor::Offset)->_put_Offset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Offset;
	};
	IGradientStop_adaptor() {}
};
template<typename X> struct adapt<IGradientStop, X> : Windows::UI::Xaml::Media::IGradientStop_adaptor<X> { typedef adapt IGradientStop; };
struct IGradientStop : IGradientStop_raw, generate<IGradientStop> {};

// GradientStop
template<typename> struct GradientStop_statics {
	static struct _ColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GradientStop, IGradientStopStatics>()->_get_ColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ColorProperty;
	static struct _OffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GradientStop, IGradientStopStatics>()->_get_OffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OffsetProperty;
};
template<typename X> typename GradientStop_statics<X>::_ColorProperty GradientStop_statics<X>::ColorProperty;
template<typename X> typename GradientStop_statics<X>::_OffsetProperty GradientStop_statics<X>::OffsetProperty;

template<typename X> struct statics<GradientStop, X> : X, Windows::UI::Xaml::Media::GradientStop_statics<void> {
	typedef typename X::root_type GradientStop;
};
struct GradientStop : generate<GradientStop> {};

// GradientStopCollection
template<typename X> struct statics<GradientStopCollection, X> : X {
	typedef typename X::root_type GradientStopCollection;
};
struct GradientStopCollection : generate<GradientStopCollection> {};

// ILoadedImageSourceLoadCompletedEventArgs
struct ILoadedImageSourceLoadCompletedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(LoadedImageSourceLoadStatus *value);
};
template<typename X> struct ILoadedImageSourceLoadCompletedEventArgs_adaptor : X {
	union {
		struct : property {
			LoadedImageSourceLoadStatus get() { LoadedImageSourceLoadStatus value; hrcheck(enc(&ILoadedImageSourceLoadCompletedEventArgs_adaptor::Status)->_get_Status(&value)); return value; }
			LoadedImageSourceLoadStatus operator()() { return get(); }
			operator LoadedImageSourceLoadStatus () { return get(); }
		} Status;
	};
	ILoadedImageSourceLoadCompletedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ILoadedImageSourceLoadCompletedEventArgs, X> : Windows::UI::Xaml::Media::ILoadedImageSourceLoadCompletedEventArgs_adaptor<X> { typedef adapt ILoadedImageSourceLoadCompletedEventArgs; };
struct ILoadedImageSourceLoadCompletedEventArgs : ILoadedImageSourceLoadCompletedEventArgs_raw, generate<ILoadedImageSourceLoadCompletedEventArgs> {};

// LoadedImageSourceLoadCompletedEventArgs
template<typename X> struct statics<LoadedImageSourceLoadCompletedEventArgs, X> : X {
	typedef typename X::root_type LoadedImageSourceLoadCompletedEventArgs;
};
struct LoadedImageSourceLoadCompletedEventArgs : generate<LoadedImageSourceLoadCompletedEventArgs> {};

// ILoadedImageSurface
struct ILoadedImageSurface_raw : IInspectable {
	virtual STDMETHODIMP _get_DecodedPhysicalSize(Foundation::Size *value);
	virtual STDMETHODIMP _get_DecodedSize(Foundation::Size *value);
	virtual STDMETHODIMP _get_NaturalSize(Foundation::Size *value);
	virtual STDMETHODIMP _add_LoadCompleted(Foundation::TypedEventHandler<LoadedImageSurface*, LoadedImageSourceLoadCompletedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_LoadCompleted(Foundation::EventRegistrationToken token);
};
template<typename X> struct ILoadedImageSurface_adaptor : X {
	union {
		struct : property {
			Foundation::Size get() { Foundation::Size value; hrcheck(enc(&ILoadedImageSurface_adaptor::DecodedPhysicalSize)->_get_DecodedPhysicalSize(&value)); return value; }
			Foundation::Size operator()() { return get(); }
			operator Foundation::Size () { return get(); }
		} DecodedPhysicalSize;
		struct : property {
			Foundation::Size get() { Foundation::Size value; hrcheck(enc(&ILoadedImageSurface_adaptor::DecodedSize)->_get_DecodedSize(&value)); return value; }
			Foundation::Size operator()() { return get(); }
			operator Foundation::Size () { return get(); }
		} DecodedSize;
		struct : property {
			Foundation::Size get() { Foundation::Size value; hrcheck(enc(&ILoadedImageSurface_adaptor::NaturalSize)->_get_NaturalSize(&value)); return value; }
			Foundation::Size operator()() { return get(); }
			operator Foundation::Size () { return get(); }
		} NaturalSize;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<LoadedImageSurface>, ptr<LoadedImageSourceLoadCompletedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ILoadedImageSurface_adaptor::LoadCompleted)->_add_LoadCompleted(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ILoadedImageSurface_adaptor::LoadCompleted)->_remove_LoadCompleted(token)); }
		} LoadCompleted;
	};
	ILoadedImageSurface_adaptor() {}
};
template<typename X> struct adapt<ILoadedImageSurface, X> : Windows::UI::Xaml::Media::ILoadedImageSurface_adaptor<X> { typedef adapt ILoadedImageSurface; };
struct ILoadedImageSurface : ILoadedImageSurface_raw, generate<ILoadedImageSurface> {};

// ILoadedImageSurfaceStatics
struct ILoadedImageSurfaceStatics : IInspectable {
	virtual STDMETHODIMP _StartLoadFromUriWithSize(Foundation::Uri* uri, Foundation::Size desiredMaxSize, LoadedImageSurface* *returnValue);
	virtual STDMETHODIMP _StartLoadFromUri(Foundation::Uri* uri, LoadedImageSurface* *returnValue);
	virtual STDMETHODIMP _StartLoadFromStreamWithSize(Storage::Streams::IRandomAccessStream* stream, Foundation::Size desiredMaxSize, LoadedImageSurface* *returnValue);
	virtual STDMETHODIMP _StartLoadFromStream(Storage::Streams::IRandomAccessStream* stream, LoadedImageSurface* *returnValue);
};

// LoadedImageSurface
template<typename> struct LoadedImageSurface_statics {
	static ptr<LoadedImageSurface> StartLoadFromUri(pptr<Foundation::Uri> uri, const Foundation::Size& desiredMaxSize) { LoadedImageSurface* returnValue; hrcheck(get_activation_factory<LoadedImageSurface, ILoadedImageSurfaceStatics>()->_StartLoadFromUriWithSize(uri, desiredMaxSize, &returnValue)); return from_abi(returnValue); }
	static ptr<LoadedImageSurface> StartLoadFromUri(pptr<Foundation::Uri> uri) { LoadedImageSurface* returnValue; hrcheck(get_activation_factory<LoadedImageSurface, ILoadedImageSurfaceStatics>()->_StartLoadFromUri(uri, &returnValue)); return from_abi(returnValue); }
	static ptr<LoadedImageSurface> StartLoadFromStream(pptr<Storage::Streams::IRandomAccessStream> stream, const Foundation::Size& desiredMaxSize) { LoadedImageSurface* returnValue; hrcheck(get_activation_factory<LoadedImageSurface, ILoadedImageSurfaceStatics>()->_StartLoadFromStreamWithSize(stream, desiredMaxSize, &returnValue)); return from_abi(returnValue); }
	static ptr<LoadedImageSurface> StartLoadFromStream(pptr<Storage::Streams::IRandomAccessStream> stream) { LoadedImageSurface* returnValue; hrcheck(get_activation_factory<LoadedImageSurface, ILoadedImageSurfaceStatics>()->_StartLoadFromStream(stream, &returnValue)); return from_abi(returnValue); }
};

template<typename X> struct statics<LoadedImageSurface, X> : X, Windows::UI::Xaml::Media::LoadedImageSurface_statics<void> {
	typedef typename X::root_type LoadedImageSurface;
};
struct LoadedImageSurface : generate<LoadedImageSurface> {};

// IPathFigureStatics
struct IPathFigureStatics : IInspectable {
	virtual STDMETHODIMP _get_SegmentsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_StartPointProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsClosedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsFilledProperty(DependencyProperty* *value);
};

// IPathFigure
struct IPathFigure_raw : IInspectable {
	virtual STDMETHODIMP _get_Segments(PathSegmentCollection* *value);
	virtual STDMETHODIMP _put_Segments(PathSegmentCollection* value);
	virtual STDMETHODIMP _get_StartPoint(Foundation::Point *value);
	virtual STDMETHODIMP _put_StartPoint(Foundation::Point value);
	virtual STDMETHODIMP _get_IsClosed(bool *value);
	virtual STDMETHODIMP _put_IsClosed(bool value);
	virtual STDMETHODIMP _get_IsFilled(bool *value);
	virtual STDMETHODIMP _put_IsFilled(bool value);
};
template<typename X> struct IPathFigure_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPathFigure_adaptor::IsClosed)->_get_IsClosed(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IPathFigure_adaptor::IsClosed)->_put_IsClosed(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsClosed;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPathFigure_adaptor::IsFilled)->_get_IsFilled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IPathFigure_adaptor::IsFilled)->_put_IsFilled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsFilled;
		struct : property {
			ptr<PathSegmentCollection> get() { PathSegmentCollection* value; hrcheck(enc(&IPathFigure_adaptor::Segments)->_get_Segments(&value)); return from_abi(value); }
			ptr<PathSegmentCollection> operator()() { return get(); }
			operator ptr<PathSegmentCollection> () { return get(); }
			ptr<PathSegmentCollection> operator->() { return get(); }
			void put(pptr<PathSegmentCollection> value) { hrcheck(enc(&IPathFigure_adaptor::Segments)->_put_Segments(value)); }
			void operator=(pptr<PathSegmentCollection> value) { put(value); }
			void operator()(pptr<PathSegmentCollection> value) { put(value); }
		} Segments;
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IPathFigure_adaptor::StartPoint)->_get_StartPoint(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&IPathFigure_adaptor::StartPoint)->_put_StartPoint(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} StartPoint;
	};
	IPathFigure_adaptor() {}
};
template<typename X> struct adapt<IPathFigure, X> : Windows::UI::Xaml::Media::IPathFigure_adaptor<X> { typedef adapt IPathFigure; };
struct IPathFigure : IPathFigure_raw, generate<IPathFigure> {};

// PathFigure
template<typename> struct PathFigure_statics {
	static struct _IsClosedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PathFigure, IPathFigureStatics>()->_get_IsClosedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsClosedProperty;
	static struct _IsFilledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PathFigure, IPathFigureStatics>()->_get_IsFilledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsFilledProperty;
	static struct _SegmentsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PathFigure, IPathFigureStatics>()->_get_SegmentsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SegmentsProperty;
	static struct _StartPointProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PathFigure, IPathFigureStatics>()->_get_StartPointProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StartPointProperty;
};
template<typename X> typename PathFigure_statics<X>::_IsClosedProperty PathFigure_statics<X>::IsClosedProperty;
template<typename X> typename PathFigure_statics<X>::_IsFilledProperty PathFigure_statics<X>::IsFilledProperty;
template<typename X> typename PathFigure_statics<X>::_SegmentsProperty PathFigure_statics<X>::SegmentsProperty;
template<typename X> typename PathFigure_statics<X>::_StartPointProperty PathFigure_statics<X>::StartPointProperty;

template<typename X> struct statics<PathFigure, X> : X, Windows::UI::Xaml::Media::PathFigure_statics<void> {
	typedef typename X::root_type PathFigure;
};
struct PathFigure : generate<PathFigure> {};

// PathFigureCollection
template<typename X> struct statics<PathFigureCollection, X> : X {
	typedef typename X::root_type PathFigureCollection;
};
struct PathFigureCollection : generate<PathFigureCollection> {};

// PathSegmentCollection
template<typename X> struct statics<PathSegmentCollection, X> : X {
	typedef typename X::root_type PathSegmentCollection;
};
struct PathSegmentCollection : generate<PathSegmentCollection> {};

// IArcSegment
struct IArcSegment_raw : IInspectable {
	virtual STDMETHODIMP _get_Point(Foundation::Point *value);
	virtual STDMETHODIMP _put_Point(Foundation::Point value);
	virtual STDMETHODIMP _get_Size(Foundation::Size *value);
	virtual STDMETHODIMP _put_Size(Foundation::Size value);
	virtual STDMETHODIMP _get_RotationAngle(double *value);
	virtual STDMETHODIMP _put_RotationAngle(double value);
	virtual STDMETHODIMP _get_IsLargeArc(bool *value);
	virtual STDMETHODIMP _put_IsLargeArc(bool value);
	virtual STDMETHODIMP _get_SweepDirection(Media::SweepDirection *value);
	virtual STDMETHODIMP _put_SweepDirection(Media::SweepDirection value);
};
template<typename X> struct IArcSegment_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IArcSegment_adaptor::IsLargeArc)->_get_IsLargeArc(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IArcSegment_adaptor::IsLargeArc)->_put_IsLargeArc(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsLargeArc;
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IArcSegment_adaptor::Point)->_get_Point(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&IArcSegment_adaptor::Point)->_put_Point(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} Point;
		struct : property {
			double get() { double value; hrcheck(enc(&IArcSegment_adaptor::RotationAngle)->_get_RotationAngle(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IArcSegment_adaptor::RotationAngle)->_put_RotationAngle(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} RotationAngle;
		struct : property {
			Foundation::Size get() { Foundation::Size value; hrcheck(enc(&IArcSegment_adaptor::Size)->_get_Size(&value)); return value; }
			Foundation::Size operator()() { return get(); }
			operator Foundation::Size () { return get(); }
			void put(const Foundation::Size& value) { hrcheck(enc(&IArcSegment_adaptor::Size)->_put_Size(value)); }
			void operator=(const Foundation::Size& value) { put(value); }
			void operator()(const Foundation::Size& value) { put(value); }
		} Size;
		struct : property {
			Media::SweepDirection get() { Media::SweepDirection value; hrcheck(enc(&IArcSegment_adaptor::SweepDirection)->_get_SweepDirection(&value)); return value; }
			Media::SweepDirection operator()() { return get(); }
			operator Media::SweepDirection () { return get(); }
			void put(Media::SweepDirection value) { hrcheck(enc(&IArcSegment_adaptor::SweepDirection)->_put_SweepDirection(value)); }
			void operator=(Media::SweepDirection value) { put(value); }
			void operator()(Media::SweepDirection value) { put(value); }
		} SweepDirection;
	};
	IArcSegment_adaptor() {}
};
template<typename X> struct adapt<IArcSegment, X> : Windows::UI::Xaml::Media::IArcSegment_adaptor<X> { typedef adapt IArcSegment; };
struct IArcSegment : IArcSegment_raw, generate<IArcSegment> {};

// IArcSegmentStatics
struct IArcSegmentStatics : IInspectable {
	virtual STDMETHODIMP _get_PointProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SizeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RotationAngleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsLargeArcProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SweepDirectionProperty(DependencyProperty* *value);
};

// ArcSegment
template<typename> struct ArcSegment_statics {
	static struct _IsLargeArcProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ArcSegment, IArcSegmentStatics>()->_get_IsLargeArcProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsLargeArcProperty;
	static struct _PointProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ArcSegment, IArcSegmentStatics>()->_get_PointProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PointProperty;
	static struct _RotationAngleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ArcSegment, IArcSegmentStatics>()->_get_RotationAngleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RotationAngleProperty;
	static struct _SizeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ArcSegment, IArcSegmentStatics>()->_get_SizeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SizeProperty;
	static struct _SweepDirectionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ArcSegment, IArcSegmentStatics>()->_get_SweepDirectionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SweepDirectionProperty;
};
template<typename X> typename ArcSegment_statics<X>::_IsLargeArcProperty ArcSegment_statics<X>::IsLargeArcProperty;
template<typename X> typename ArcSegment_statics<X>::_PointProperty ArcSegment_statics<X>::PointProperty;
template<typename X> typename ArcSegment_statics<X>::_RotationAngleProperty ArcSegment_statics<X>::RotationAngleProperty;
template<typename X> typename ArcSegment_statics<X>::_SizeProperty ArcSegment_statics<X>::SizeProperty;
template<typename X> typename ArcSegment_statics<X>::_SweepDirectionProperty ArcSegment_statics<X>::SweepDirectionProperty;

template<typename X> struct statics<ArcSegment, X> : X, Windows::UI::Xaml::Media::ArcSegment_statics<void> {
	typedef typename X::root_type ArcSegment;
};
struct ArcSegment : generate<ArcSegment> {};

// IBezierSegment
struct IBezierSegment_raw : IInspectable {
	virtual STDMETHODIMP _get_Point1(Foundation::Point *value);
	virtual STDMETHODIMP _put_Point1(Foundation::Point value);
	virtual STDMETHODIMP _get_Point2(Foundation::Point *value);
	virtual STDMETHODIMP _put_Point2(Foundation::Point value);
	virtual STDMETHODIMP _get_Point3(Foundation::Point *value);
	virtual STDMETHODIMP _put_Point3(Foundation::Point value);
};
template<typename X> struct IBezierSegment_adaptor : X {
	union {
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IBezierSegment_adaptor::Point1)->_get_Point1(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&IBezierSegment_adaptor::Point1)->_put_Point1(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} Point1;
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IBezierSegment_adaptor::Point2)->_get_Point2(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&IBezierSegment_adaptor::Point2)->_put_Point2(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} Point2;
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IBezierSegment_adaptor::Point3)->_get_Point3(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&IBezierSegment_adaptor::Point3)->_put_Point3(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} Point3;
	};
	IBezierSegment_adaptor() {}
};
template<typename X> struct adapt<IBezierSegment, X> : Windows::UI::Xaml::Media::IBezierSegment_adaptor<X> { typedef adapt IBezierSegment; };
struct IBezierSegment : IBezierSegment_raw, generate<IBezierSegment> {};

// IBezierSegmentStatics
struct IBezierSegmentStatics : IInspectable {
	virtual STDMETHODIMP _get_Point1Property(DependencyProperty* *value);
	virtual STDMETHODIMP _get_Point2Property(DependencyProperty* *value);
	virtual STDMETHODIMP _get_Point3Property(DependencyProperty* *value);
};

// BezierSegment
template<typename> struct BezierSegment_statics {
	static struct _Point1Property : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BezierSegment, IBezierSegmentStatics>()->_get_Point1Property(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} Point1Property;
	static struct _Point2Property : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BezierSegment, IBezierSegmentStatics>()->_get_Point2Property(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} Point2Property;
	static struct _Point3Property : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BezierSegment, IBezierSegmentStatics>()->_get_Point3Property(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} Point3Property;
};
template<typename X> typename BezierSegment_statics<X>::_Point1Property BezierSegment_statics<X>::Point1Property;
template<typename X> typename BezierSegment_statics<X>::_Point2Property BezierSegment_statics<X>::Point2Property;
template<typename X> typename BezierSegment_statics<X>::_Point3Property BezierSegment_statics<X>::Point3Property;

template<typename X> struct statics<BezierSegment, X> : X, Windows::UI::Xaml::Media::BezierSegment_statics<void> {
	typedef typename X::root_type BezierSegment;
};
struct BezierSegment : generate<BezierSegment> {};

// IEllipseGeometry
struct IEllipseGeometry_raw : IInspectable {
	virtual STDMETHODIMP _get_Center(Foundation::Point *value);
	virtual STDMETHODIMP _put_Center(Foundation::Point value);
	virtual STDMETHODIMP _get_RadiusX(double *value);
	virtual STDMETHODIMP _put_RadiusX(double value);
	virtual STDMETHODIMP _get_RadiusY(double *value);
	virtual STDMETHODIMP _put_RadiusY(double value);
};
template<typename X> struct IEllipseGeometry_adaptor : X {
	union {
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IEllipseGeometry_adaptor::Center)->_get_Center(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&IEllipseGeometry_adaptor::Center)->_put_Center(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} Center;
		struct : property {
			double get() { double value; hrcheck(enc(&IEllipseGeometry_adaptor::RadiusX)->_get_RadiusX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IEllipseGeometry_adaptor::RadiusX)->_put_RadiusX(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} RadiusX;
		struct : property {
			double get() { double value; hrcheck(enc(&IEllipseGeometry_adaptor::RadiusY)->_get_RadiusY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IEllipseGeometry_adaptor::RadiusY)->_put_RadiusY(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} RadiusY;
	};
	IEllipseGeometry_adaptor() {}
};
template<typename X> struct adapt<IEllipseGeometry, X> : Windows::UI::Xaml::Media::IEllipseGeometry_adaptor<X> { typedef adapt IEllipseGeometry; };
struct IEllipseGeometry : IEllipseGeometry_raw, generate<IEllipseGeometry> {};

// IEllipseGeometryStatics
struct IEllipseGeometryStatics : IInspectable {
	virtual STDMETHODIMP _get_CenterProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RadiusXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RadiusYProperty(DependencyProperty* *value);
};

// EllipseGeometry
template<typename> struct EllipseGeometry_statics {
	static struct _CenterProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<EllipseGeometry, IEllipseGeometryStatics>()->_get_CenterProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CenterProperty;
	static struct _RadiusXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<EllipseGeometry, IEllipseGeometryStatics>()->_get_RadiusXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RadiusXProperty;
	static struct _RadiusYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<EllipseGeometry, IEllipseGeometryStatics>()->_get_RadiusYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RadiusYProperty;
};
template<typename X> typename EllipseGeometry_statics<X>::_CenterProperty EllipseGeometry_statics<X>::CenterProperty;
template<typename X> typename EllipseGeometry_statics<X>::_RadiusXProperty EllipseGeometry_statics<X>::RadiusXProperty;
template<typename X> typename EllipseGeometry_statics<X>::_RadiusYProperty EllipseGeometry_statics<X>::RadiusYProperty;

template<typename X> struct statics<EllipseGeometry, X> : X, Windows::UI::Xaml::Media::EllipseGeometry_statics<void> {
	typedef typename X::root_type EllipseGeometry;
};
struct EllipseGeometry : generate<EllipseGeometry> {};

// IGeometryGroup
struct IGeometryGroup_raw : IInspectable {
	virtual STDMETHODIMP _get_FillRule(Media::FillRule *value);
	virtual STDMETHODIMP _put_FillRule(Media::FillRule value);
	virtual STDMETHODIMP _get_Children(GeometryCollection* *value);
	virtual STDMETHODIMP _put_Children(GeometryCollection* value);
};
template<typename X> struct IGeometryGroup_adaptor : X {
	union {
		struct : property {
			ptr<GeometryCollection> get() { GeometryCollection* value; hrcheck(enc(&IGeometryGroup_adaptor::Children)->_get_Children(&value)); return from_abi(value); }
			ptr<GeometryCollection> operator()() { return get(); }
			operator ptr<GeometryCollection> () { return get(); }
			ptr<GeometryCollection> operator->() { return get(); }
			void put(pptr<GeometryCollection> value) { hrcheck(enc(&IGeometryGroup_adaptor::Children)->_put_Children(value)); }
			void operator=(pptr<GeometryCollection> value) { put(value); }
			void operator()(pptr<GeometryCollection> value) { put(value); }
		} Children;
		struct : property {
			Media::FillRule get() { Media::FillRule value; hrcheck(enc(&IGeometryGroup_adaptor::FillRule)->_get_FillRule(&value)); return value; }
			Media::FillRule operator()() { return get(); }
			operator Media::FillRule () { return get(); }
			void put(Media::FillRule value) { hrcheck(enc(&IGeometryGroup_adaptor::FillRule)->_put_FillRule(value)); }
			void operator=(Media::FillRule value) { put(value); }
			void operator()(Media::FillRule value) { put(value); }
		} FillRule;
	};
	IGeometryGroup_adaptor() {}
};
template<typename X> struct adapt<IGeometryGroup, X> : Windows::UI::Xaml::Media::IGeometryGroup_adaptor<X> { typedef adapt IGeometryGroup; };
struct IGeometryGroup : IGeometryGroup_raw, generate<IGeometryGroup> {};

// IGeometryGroupStatics
struct IGeometryGroupStatics : IInspectable {
	virtual STDMETHODIMP _get_FillRuleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ChildrenProperty(DependencyProperty* *value);
};

// GeometryGroup
template<typename> struct GeometryGroup_statics {
	static struct _ChildrenProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GeometryGroup, IGeometryGroupStatics>()->_get_ChildrenProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ChildrenProperty;
	static struct _FillRuleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GeometryGroup, IGeometryGroupStatics>()->_get_FillRuleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FillRuleProperty;
};
template<typename X> typename GeometryGroup_statics<X>::_ChildrenProperty GeometryGroup_statics<X>::ChildrenProperty;
template<typename X> typename GeometryGroup_statics<X>::_FillRuleProperty GeometryGroup_statics<X>::FillRuleProperty;

template<typename X> struct statics<GeometryGroup, X> : X, Windows::UI::Xaml::Media::GeometryGroup_statics<void> {
	typedef typename X::root_type GeometryGroup;
};
struct GeometryGroup : generate<GeometryGroup> {};

// IGradientBrush
struct IGradientBrush_raw : IInspectable {
	virtual STDMETHODIMP _get_SpreadMethod(GradientSpreadMethod *value);
	virtual STDMETHODIMP _put_SpreadMethod(GradientSpreadMethod value);
	virtual STDMETHODIMP _get_MappingMode(BrushMappingMode *value);
	virtual STDMETHODIMP _put_MappingMode(BrushMappingMode value);
	virtual STDMETHODIMP _get_ColorInterpolationMode(Media::ColorInterpolationMode *value);
	virtual STDMETHODIMP _put_ColorInterpolationMode(Media::ColorInterpolationMode value);
	virtual STDMETHODIMP _get_GradientStops(GradientStopCollection* *value);
	virtual STDMETHODIMP _put_GradientStops(GradientStopCollection* value);
};
template<typename X> struct IGradientBrush_adaptor : X {
	union {
		struct : property {
			Media::ColorInterpolationMode get() { Media::ColorInterpolationMode value; hrcheck(enc(&IGradientBrush_adaptor::ColorInterpolationMode)->_get_ColorInterpolationMode(&value)); return value; }
			Media::ColorInterpolationMode operator()() { return get(); }
			operator Media::ColorInterpolationMode () { return get(); }
			void put(Media::ColorInterpolationMode value) { hrcheck(enc(&IGradientBrush_adaptor::ColorInterpolationMode)->_put_ColorInterpolationMode(value)); }
			void operator=(Media::ColorInterpolationMode value) { put(value); }
			void operator()(Media::ColorInterpolationMode value) { put(value); }
		} ColorInterpolationMode;
		struct : property {
			ptr<GradientStopCollection> get() { GradientStopCollection* value; hrcheck(enc(&IGradientBrush_adaptor::GradientStops)->_get_GradientStops(&value)); return from_abi(value); }
			ptr<GradientStopCollection> operator()() { return get(); }
			operator ptr<GradientStopCollection> () { return get(); }
			ptr<GradientStopCollection> operator->() { return get(); }
			void put(pptr<GradientStopCollection> value) { hrcheck(enc(&IGradientBrush_adaptor::GradientStops)->_put_GradientStops(value)); }
			void operator=(pptr<GradientStopCollection> value) { put(value); }
			void operator()(pptr<GradientStopCollection> value) { put(value); }
		} GradientStops;
		struct : property {
			BrushMappingMode get() { BrushMappingMode value; hrcheck(enc(&IGradientBrush_adaptor::MappingMode)->_get_MappingMode(&value)); return value; }
			BrushMappingMode operator()() { return get(); }
			operator BrushMappingMode () { return get(); }
			void put(BrushMappingMode value) { hrcheck(enc(&IGradientBrush_adaptor::MappingMode)->_put_MappingMode(value)); }
			void operator=(BrushMappingMode value) { put(value); }
			void operator()(BrushMappingMode value) { put(value); }
		} MappingMode;
		struct : property {
			GradientSpreadMethod get() { GradientSpreadMethod value; hrcheck(enc(&IGradientBrush_adaptor::SpreadMethod)->_get_SpreadMethod(&value)); return value; }
			GradientSpreadMethod operator()() { return get(); }
			operator GradientSpreadMethod () { return get(); }
			void put(GradientSpreadMethod value) { hrcheck(enc(&IGradientBrush_adaptor::SpreadMethod)->_put_SpreadMethod(value)); }
			void operator=(GradientSpreadMethod value) { put(value); }
			void operator()(GradientSpreadMethod value) { put(value); }
		} SpreadMethod;
	};
	IGradientBrush_adaptor() {}
};
template<typename X> struct adapt<IGradientBrush, X> : Windows::UI::Xaml::Media::IGradientBrush_adaptor<X> { typedef adapt IGradientBrush; };
struct IGradientBrush : IGradientBrush_raw, generate<IGradientBrush> {};

// IGradientBrushStatics
struct IGradientBrushStatics : IInspectable {
	virtual STDMETHODIMP _get_SpreadMethodProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MappingModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ColorInterpolationModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_GradientStopsProperty(DependencyProperty* *value);
};

// IGradientBrushFactory
struct IGradientBrushFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, GradientBrush* *instance);
};

// GradientBrush
template<typename> struct GradientBrush_statics {
	static struct _ColorInterpolationModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GradientBrush, IGradientBrushStatics>()->_get_ColorInterpolationModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ColorInterpolationModeProperty;
	static struct _GradientStopsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GradientBrush, IGradientBrushStatics>()->_get_GradientStopsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GradientStopsProperty;
	static struct _MappingModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GradientBrush, IGradientBrushStatics>()->_get_MappingModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MappingModeProperty;
	static struct _SpreadMethodProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GradientBrush, IGradientBrushStatics>()->_get_SpreadMethodProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SpreadMethodProperty;
};
template<typename X> typename GradientBrush_statics<X>::_ColorInterpolationModeProperty GradientBrush_statics<X>::ColorInterpolationModeProperty;
template<typename X> typename GradientBrush_statics<X>::_GradientStopsProperty GradientBrush_statics<X>::GradientStopsProperty;
template<typename X> typename GradientBrush_statics<X>::_MappingModeProperty GradientBrush_statics<X>::MappingModeProperty;
template<typename X> typename GradientBrush_statics<X>::_SpreadMethodProperty GradientBrush_statics<X>::SpreadMethodProperty;

template<typename X> struct statics<GradientBrush, X> : X, Windows::UI::Xaml::Media::GradientBrush_statics<void> {
	typedef typename X::root_type GradientBrush;
};
struct GradientBrush : generate<GradientBrush> {};

// ILineGeometry
struct ILineGeometry_raw : IInspectable {
	virtual STDMETHODIMP _get_StartPoint(Foundation::Point *value);
	virtual STDMETHODIMP _put_StartPoint(Foundation::Point value);
	virtual STDMETHODIMP _get_EndPoint(Foundation::Point *value);
	virtual STDMETHODIMP _put_EndPoint(Foundation::Point value);
};
template<typename X> struct ILineGeometry_adaptor : X {
	union {
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&ILineGeometry_adaptor::EndPoint)->_get_EndPoint(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&ILineGeometry_adaptor::EndPoint)->_put_EndPoint(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} EndPoint;
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&ILineGeometry_adaptor::StartPoint)->_get_StartPoint(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&ILineGeometry_adaptor::StartPoint)->_put_StartPoint(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} StartPoint;
	};
	ILineGeometry_adaptor() {}
};
template<typename X> struct adapt<ILineGeometry, X> : Windows::UI::Xaml::Media::ILineGeometry_adaptor<X> { typedef adapt ILineGeometry; };
struct ILineGeometry : ILineGeometry_raw, generate<ILineGeometry> {};

// ILineGeometryStatics
struct ILineGeometryStatics : IInspectable {
	virtual STDMETHODIMP _get_StartPointProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_EndPointProperty(DependencyProperty* *value);
};

// LineGeometry
template<typename> struct LineGeometry_statics {
	static struct _EndPointProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<LineGeometry, ILineGeometryStatics>()->_get_EndPointProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EndPointProperty;
	static struct _StartPointProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<LineGeometry, ILineGeometryStatics>()->_get_StartPointProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StartPointProperty;
};
template<typename X> typename LineGeometry_statics<X>::_EndPointProperty LineGeometry_statics<X>::EndPointProperty;
template<typename X> typename LineGeometry_statics<X>::_StartPointProperty LineGeometry_statics<X>::StartPointProperty;

template<typename X> struct statics<LineGeometry, X> : X, Windows::UI::Xaml::Media::LineGeometry_statics<void> {
	typedef typename X::root_type LineGeometry;
};
struct LineGeometry : generate<LineGeometry> {};

// ILineSegment
struct ILineSegment_raw : IInspectable {
	virtual STDMETHODIMP _get_Point(Foundation::Point *value);
	virtual STDMETHODIMP _put_Point(Foundation::Point value);
};
template<typename X> struct ILineSegment_adaptor : X {
	union {
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&ILineSegment_adaptor::Point)->_get_Point(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&ILineSegment_adaptor::Point)->_put_Point(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} Point;
	};
	ILineSegment_adaptor() {}
};
template<typename X> struct adapt<ILineSegment, X> : Windows::UI::Xaml::Media::ILineSegment_adaptor<X> { typedef adapt ILineSegment; };
struct ILineSegment : ILineSegment_raw, generate<ILineSegment> {};

// ILineSegmentStatics
struct ILineSegmentStatics : IInspectable {
	virtual STDMETHODIMP _get_PointProperty(DependencyProperty* *value);
};

// LineSegment
template<typename> struct LineSegment_statics {
	static struct _PointProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<LineSegment, ILineSegmentStatics>()->_get_PointProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PointProperty;
};
template<typename X> typename LineSegment_statics<X>::_PointProperty LineSegment_statics<X>::PointProperty;

template<typename X> struct statics<LineSegment, X> : X, Windows::UI::Xaml::Media::LineSegment_statics<void> {
	typedef typename X::root_type LineSegment;
};
struct LineSegment : generate<LineSegment> {};

// IPathGeometry
struct IPathGeometry_raw : IInspectable {
	virtual STDMETHODIMP _get_FillRule(Media::FillRule *value);
	virtual STDMETHODIMP _put_FillRule(Media::FillRule value);
	virtual STDMETHODIMP _get_Figures(PathFigureCollection* *value);
	virtual STDMETHODIMP _put_Figures(PathFigureCollection* value);
};
template<typename X> struct IPathGeometry_adaptor : X {
	union {
		struct : property {
			ptr<PathFigureCollection> get() { PathFigureCollection* value; hrcheck(enc(&IPathGeometry_adaptor::Figures)->_get_Figures(&value)); return from_abi(value); }
			ptr<PathFigureCollection> operator()() { return get(); }
			operator ptr<PathFigureCollection> () { return get(); }
			ptr<PathFigureCollection> operator->() { return get(); }
			void put(pptr<PathFigureCollection> value) { hrcheck(enc(&IPathGeometry_adaptor::Figures)->_put_Figures(value)); }
			void operator=(pptr<PathFigureCollection> value) { put(value); }
			void operator()(pptr<PathFigureCollection> value) { put(value); }
		} Figures;
		struct : property {
			Media::FillRule get() { Media::FillRule value; hrcheck(enc(&IPathGeometry_adaptor::FillRule)->_get_FillRule(&value)); return value; }
			Media::FillRule operator()() { return get(); }
			operator Media::FillRule () { return get(); }
			void put(Media::FillRule value) { hrcheck(enc(&IPathGeometry_adaptor::FillRule)->_put_FillRule(value)); }
			void operator=(Media::FillRule value) { put(value); }
			void operator()(Media::FillRule value) { put(value); }
		} FillRule;
	};
	IPathGeometry_adaptor() {}
};
template<typename X> struct adapt<IPathGeometry, X> : Windows::UI::Xaml::Media::IPathGeometry_adaptor<X> { typedef adapt IPathGeometry; };
struct IPathGeometry : IPathGeometry_raw, generate<IPathGeometry> {};

// IPathGeometryStatics
struct IPathGeometryStatics : IInspectable {
	virtual STDMETHODIMP _get_FillRuleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FiguresProperty(DependencyProperty* *value);
};

// PathGeometry
template<typename> struct PathGeometry_statics {
	static struct _FiguresProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PathGeometry, IPathGeometryStatics>()->_get_FiguresProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FiguresProperty;
	static struct _FillRuleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PathGeometry, IPathGeometryStatics>()->_get_FillRuleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FillRuleProperty;
};
template<typename X> typename PathGeometry_statics<X>::_FiguresProperty PathGeometry_statics<X>::FiguresProperty;
template<typename X> typename PathGeometry_statics<X>::_FillRuleProperty PathGeometry_statics<X>::FillRuleProperty;

template<typename X> struct statics<PathGeometry, X> : X, Windows::UI::Xaml::Media::PathGeometry_statics<void> {
	typedef typename X::root_type PathGeometry;
};
struct PathGeometry : generate<PathGeometry> {};

// IPolyBezierSegment
struct IPolyBezierSegment_raw : IInspectable {
	virtual STDMETHODIMP _get_Points(PointCollection* *value);
	virtual STDMETHODIMP _put_Points(PointCollection* value);
};
template<typename X> struct IPolyBezierSegment_adaptor : X {
	union {
		struct : property {
			ptr<PointCollection> get() { PointCollection* value; hrcheck(enc(&IPolyBezierSegment_adaptor::Points)->_get_Points(&value)); return from_abi(value); }
			ptr<PointCollection> operator()() { return get(); }
			operator ptr<PointCollection> () { return get(); }
			ptr<PointCollection> operator->() { return get(); }
			void put(pptr<PointCollection> value) { hrcheck(enc(&IPolyBezierSegment_adaptor::Points)->_put_Points(value)); }
			void operator=(pptr<PointCollection> value) { put(value); }
			void operator()(pptr<PointCollection> value) { put(value); }
		} Points;
	};
	IPolyBezierSegment_adaptor() {}
};
template<typename X> struct adapt<IPolyBezierSegment, X> : Windows::UI::Xaml::Media::IPolyBezierSegment_adaptor<X> { typedef adapt IPolyBezierSegment; };
struct IPolyBezierSegment : IPolyBezierSegment_raw, generate<IPolyBezierSegment> {};

// IPolyBezierSegmentStatics
struct IPolyBezierSegmentStatics : IInspectable {
	virtual STDMETHODIMP _get_PointsProperty(DependencyProperty* *value);
};

// PolyBezierSegment
template<typename> struct PolyBezierSegment_statics {
	static struct _PointsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PolyBezierSegment, IPolyBezierSegmentStatics>()->_get_PointsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PointsProperty;
};
template<typename X> typename PolyBezierSegment_statics<X>::_PointsProperty PolyBezierSegment_statics<X>::PointsProperty;

template<typename X> struct statics<PolyBezierSegment, X> : X, Windows::UI::Xaml::Media::PolyBezierSegment_statics<void> {
	typedef typename X::root_type PolyBezierSegment;
};
struct PolyBezierSegment : generate<PolyBezierSegment> {};

// IPolyLineSegment
struct IPolyLineSegment_raw : IInspectable {
	virtual STDMETHODIMP _get_Points(PointCollection* *value);
	virtual STDMETHODIMP _put_Points(PointCollection* value);
};
template<typename X> struct IPolyLineSegment_adaptor : X {
	union {
		struct : property {
			ptr<PointCollection> get() { PointCollection* value; hrcheck(enc(&IPolyLineSegment_adaptor::Points)->_get_Points(&value)); return from_abi(value); }
			ptr<PointCollection> operator()() { return get(); }
			operator ptr<PointCollection> () { return get(); }
			ptr<PointCollection> operator->() { return get(); }
			void put(pptr<PointCollection> value) { hrcheck(enc(&IPolyLineSegment_adaptor::Points)->_put_Points(value)); }
			void operator=(pptr<PointCollection> value) { put(value); }
			void operator()(pptr<PointCollection> value) { put(value); }
		} Points;
	};
	IPolyLineSegment_adaptor() {}
};
template<typename X> struct adapt<IPolyLineSegment, X> : Windows::UI::Xaml::Media::IPolyLineSegment_adaptor<X> { typedef adapt IPolyLineSegment; };
struct IPolyLineSegment : IPolyLineSegment_raw, generate<IPolyLineSegment> {};

// IPolyLineSegmentStatics
struct IPolyLineSegmentStatics : IInspectable {
	virtual STDMETHODIMP _get_PointsProperty(DependencyProperty* *value);
};

// PolyLineSegment
template<typename> struct PolyLineSegment_statics {
	static struct _PointsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PolyLineSegment, IPolyLineSegmentStatics>()->_get_PointsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PointsProperty;
};
template<typename X> typename PolyLineSegment_statics<X>::_PointsProperty PolyLineSegment_statics<X>::PointsProperty;

template<typename X> struct statics<PolyLineSegment, X> : X, Windows::UI::Xaml::Media::PolyLineSegment_statics<void> {
	typedef typename X::root_type PolyLineSegment;
};
struct PolyLineSegment : generate<PolyLineSegment> {};

// IPolyQuadraticBezierSegment
struct IPolyQuadraticBezierSegment_raw : IInspectable {
	virtual STDMETHODIMP _get_Points(PointCollection* *value);
	virtual STDMETHODIMP _put_Points(PointCollection* value);
};
template<typename X> struct IPolyQuadraticBezierSegment_adaptor : X {
	union {
		struct : property {
			ptr<PointCollection> get() { PointCollection* value; hrcheck(enc(&IPolyQuadraticBezierSegment_adaptor::Points)->_get_Points(&value)); return from_abi(value); }
			ptr<PointCollection> operator()() { return get(); }
			operator ptr<PointCollection> () { return get(); }
			ptr<PointCollection> operator->() { return get(); }
			void put(pptr<PointCollection> value) { hrcheck(enc(&IPolyQuadraticBezierSegment_adaptor::Points)->_put_Points(value)); }
			void operator=(pptr<PointCollection> value) { put(value); }
			void operator()(pptr<PointCollection> value) { put(value); }
		} Points;
	};
	IPolyQuadraticBezierSegment_adaptor() {}
};
template<typename X> struct adapt<IPolyQuadraticBezierSegment, X> : Windows::UI::Xaml::Media::IPolyQuadraticBezierSegment_adaptor<X> { typedef adapt IPolyQuadraticBezierSegment; };
struct IPolyQuadraticBezierSegment : IPolyQuadraticBezierSegment_raw, generate<IPolyQuadraticBezierSegment> {};

// IPolyQuadraticBezierSegmentStatics
struct IPolyQuadraticBezierSegmentStatics : IInspectable {
	virtual STDMETHODIMP _get_PointsProperty(DependencyProperty* *value);
};

// PolyQuadraticBezierSegment
template<typename> struct PolyQuadraticBezierSegment_statics {
	static struct _PointsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PolyQuadraticBezierSegment, IPolyQuadraticBezierSegmentStatics>()->_get_PointsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PointsProperty;
};
template<typename X> typename PolyQuadraticBezierSegment_statics<X>::_PointsProperty PolyQuadraticBezierSegment_statics<X>::PointsProperty;

template<typename X> struct statics<PolyQuadraticBezierSegment, X> : X, Windows::UI::Xaml::Media::PolyQuadraticBezierSegment_statics<void> {
	typedef typename X::root_type PolyQuadraticBezierSegment;
};
struct PolyQuadraticBezierSegment : generate<PolyQuadraticBezierSegment> {};

// IQuadraticBezierSegment
struct IQuadraticBezierSegment_raw : IInspectable {
	virtual STDMETHODIMP _get_Point1(Foundation::Point *value);
	virtual STDMETHODIMP _put_Point1(Foundation::Point value);
	virtual STDMETHODIMP _get_Point2(Foundation::Point *value);
	virtual STDMETHODIMP _put_Point2(Foundation::Point value);
};
template<typename X> struct IQuadraticBezierSegment_adaptor : X {
	union {
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IQuadraticBezierSegment_adaptor::Point1)->_get_Point1(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&IQuadraticBezierSegment_adaptor::Point1)->_put_Point1(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} Point1;
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&IQuadraticBezierSegment_adaptor::Point2)->_get_Point2(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&IQuadraticBezierSegment_adaptor::Point2)->_put_Point2(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} Point2;
	};
	IQuadraticBezierSegment_adaptor() {}
};
template<typename X> struct adapt<IQuadraticBezierSegment, X> : Windows::UI::Xaml::Media::IQuadraticBezierSegment_adaptor<X> { typedef adapt IQuadraticBezierSegment; };
struct IQuadraticBezierSegment : IQuadraticBezierSegment_raw, generate<IQuadraticBezierSegment> {};

// IQuadraticBezierSegmentStatics
struct IQuadraticBezierSegmentStatics : IInspectable {
	virtual STDMETHODIMP _get_Point1Property(DependencyProperty* *value);
	virtual STDMETHODIMP _get_Point2Property(DependencyProperty* *value);
};

// QuadraticBezierSegment
template<typename> struct QuadraticBezierSegment_statics {
	static struct _Point1Property : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<QuadraticBezierSegment, IQuadraticBezierSegmentStatics>()->_get_Point1Property(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} Point1Property;
	static struct _Point2Property : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<QuadraticBezierSegment, IQuadraticBezierSegmentStatics>()->_get_Point2Property(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} Point2Property;
};
template<typename X> typename QuadraticBezierSegment_statics<X>::_Point1Property QuadraticBezierSegment_statics<X>::Point1Property;
template<typename X> typename QuadraticBezierSegment_statics<X>::_Point2Property QuadraticBezierSegment_statics<X>::Point2Property;

template<typename X> struct statics<QuadraticBezierSegment, X> : X, Windows::UI::Xaml::Media::QuadraticBezierSegment_statics<void> {
	typedef typename X::root_type QuadraticBezierSegment;
};
struct QuadraticBezierSegment : generate<QuadraticBezierSegment> {};

// ITileBrush
struct ITileBrush_raw : IInspectable {
	virtual STDMETHODIMP _get_AlignmentX(Media::AlignmentX *value);
	virtual STDMETHODIMP _put_AlignmentX(Media::AlignmentX value);
	virtual STDMETHODIMP _get_AlignmentY(Media::AlignmentY *value);
	virtual STDMETHODIMP _put_AlignmentY(Media::AlignmentY value);
	virtual STDMETHODIMP _get_Stretch(Media::Stretch *value);
	virtual STDMETHODIMP _put_Stretch(Media::Stretch value);
};
template<typename X> struct ITileBrush_adaptor : X {
	union {
		struct : property {
			Media::AlignmentX get() { Media::AlignmentX value; hrcheck(enc(&ITileBrush_adaptor::AlignmentX)->_get_AlignmentX(&value)); return value; }
			Media::AlignmentX operator()() { return get(); }
			operator Media::AlignmentX () { return get(); }
			void put(Media::AlignmentX value) { hrcheck(enc(&ITileBrush_adaptor::AlignmentX)->_put_AlignmentX(value)); }
			void operator=(Media::AlignmentX value) { put(value); }
			void operator()(Media::AlignmentX value) { put(value); }
		} AlignmentX;
		struct : property {
			Media::AlignmentY get() { Media::AlignmentY value; hrcheck(enc(&ITileBrush_adaptor::AlignmentY)->_get_AlignmentY(&value)); return value; }
			Media::AlignmentY operator()() { return get(); }
			operator Media::AlignmentY () { return get(); }
			void put(Media::AlignmentY value) { hrcheck(enc(&ITileBrush_adaptor::AlignmentY)->_put_AlignmentY(value)); }
			void operator=(Media::AlignmentY value) { put(value); }
			void operator()(Media::AlignmentY value) { put(value); }
		} AlignmentY;
		struct : property {
			Media::Stretch get() { Media::Stretch value; hrcheck(enc(&ITileBrush_adaptor::Stretch)->_get_Stretch(&value)); return value; }
			Media::Stretch operator()() { return get(); }
			operator Media::Stretch () { return get(); }
			void put(Media::Stretch value) { hrcheck(enc(&ITileBrush_adaptor::Stretch)->_put_Stretch(value)); }
			void operator=(Media::Stretch value) { put(value); }
			void operator()(Media::Stretch value) { put(value); }
		} Stretch;
	};
	ITileBrush_adaptor() {}
};
template<typename X> struct adapt<ITileBrush, X> : Windows::UI::Xaml::Media::ITileBrush_adaptor<X> { typedef adapt ITileBrush; };
struct ITileBrush : ITileBrush_raw, generate<ITileBrush> {};

// ITileBrushStatics
struct ITileBrushStatics : IInspectable {
	virtual STDMETHODIMP _get_AlignmentXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AlignmentYProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_StretchProperty(DependencyProperty* *value);
};

// ITileBrushFactory
struct ITileBrushFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, TileBrush* *instance);
};

// TileBrush
template<typename> struct TileBrush_statics {
	static struct _AlignmentXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TileBrush, ITileBrushStatics>()->_get_AlignmentXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlignmentXProperty;
	static struct _AlignmentYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TileBrush, ITileBrushStatics>()->_get_AlignmentYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlignmentYProperty;
	static struct _StretchProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TileBrush, ITileBrushStatics>()->_get_StretchProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StretchProperty;
};
template<typename X> typename TileBrush_statics<X>::_AlignmentXProperty TileBrush_statics<X>::AlignmentXProperty;
template<typename X> typename TileBrush_statics<X>::_AlignmentYProperty TileBrush_statics<X>::AlignmentYProperty;
template<typename X> typename TileBrush_statics<X>::_StretchProperty TileBrush_statics<X>::StretchProperty;

template<typename X> struct statics<TileBrush, X> : X, Windows::UI::Xaml::Media::TileBrush_statics<void> {
	typedef typename X::root_type TileBrush;
};
struct TileBrush : generate<TileBrush> {};

// IXamlCompositionBrushBase
struct IXamlCompositionBrushBase_raw : IInspectable {
	virtual STDMETHODIMP _get_FallbackColor(Color *value);
	virtual STDMETHODIMP _put_FallbackColor(Color value);
};
template<typename X> struct IXamlCompositionBrushBase_adaptor : X {
	union {
		struct : property {
			Color get() { Color value; hrcheck(enc(&IXamlCompositionBrushBase_adaptor::FallbackColor)->_get_FallbackColor(&value)); return value; }
			Color operator()() { return get(); }
			operator Color () { return get(); }
			void put(const Color& value) { hrcheck(enc(&IXamlCompositionBrushBase_adaptor::FallbackColor)->_put_FallbackColor(value)); }
			void operator=(const Color& value) { put(value); }
			void operator()(const Color& value) { put(value); }
		} FallbackColor;
	};
	IXamlCompositionBrushBase_adaptor() {}
};
template<typename X> struct adapt<IXamlCompositionBrushBase, X> : Windows::UI::Xaml::Media::IXamlCompositionBrushBase_adaptor<X> { typedef adapt IXamlCompositionBrushBase; };
struct IXamlCompositionBrushBase : IXamlCompositionBrushBase_raw, generate<IXamlCompositionBrushBase> {};

// IXamlCompositionBrushBaseOverrides
struct IXamlCompositionBrushBaseOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnConnected() = 0;
	virtual STDMETHODIMP _OnDisconnected() = 0;
};
template<typename X> struct IXamlCompositionBrushBaseOverrides_adaptor : X {
	void OnConnected() { hrcheck(X::get()->_OnConnected()); }
	void OnDisconnected() { hrcheck(X::get()->_OnDisconnected()); }
};
template<typename X> struct adapt<IXamlCompositionBrushBaseOverrides, X> : Windows::UI::Xaml::Media::IXamlCompositionBrushBaseOverrides_adaptor<X> { typedef adapt IXamlCompositionBrushBaseOverrides; };
template<typename X> struct IXamlCompositionBrushBaseOverrides_unadaptor : X {
	STDMETHODIMP _OnConnected() { return hrtry([&, this] { X::get()->OnConnected(); }); }
	STDMETHODIMP _OnDisconnected() { return hrtry([&, this] { X::get()->OnDisconnected(); }); }
};
template<typename X> struct unadapt<IXamlCompositionBrushBaseOverrides, X> : Windows::UI::Xaml::Media::IXamlCompositionBrushBaseOverrides_unadaptor<X> {};
struct IXamlCompositionBrushBaseOverrides : IXamlCompositionBrushBaseOverrides_raw, generate<IXamlCompositionBrushBaseOverrides> {};

// IXamlCompositionBrushBaseProtected
struct IXamlCompositionBrushBaseProtected_raw : IInspectable {
	virtual STDMETHODIMP _get_CompositionBrush(Composition::CompositionBrush* *value);
	virtual STDMETHODIMP _put_CompositionBrush(Composition::CompositionBrush* value);
};
template<typename X> struct IXamlCompositionBrushBaseProtected_adaptor : X {
	union {
		struct : property {
			ptr<Composition::CompositionBrush> get() { Composition::CompositionBrush* value; hrcheck(enc(&IXamlCompositionBrushBaseProtected_adaptor::CompositionBrush)->_get_CompositionBrush(&value)); return from_abi(value); }
			ptr<Composition::CompositionBrush> operator()() { return get(); }
			operator ptr<Composition::CompositionBrush> () { return get(); }
			ptr<Composition::CompositionBrush> operator->() { return get(); }
			void put(pptr<Composition::CompositionBrush> value) { hrcheck(enc(&IXamlCompositionBrushBaseProtected_adaptor::CompositionBrush)->_put_CompositionBrush(value)); }
			void operator=(pptr<Composition::CompositionBrush> value) { put(value); }
			void operator()(pptr<Composition::CompositionBrush> value) { put(value); }
		} CompositionBrush;
	};
	IXamlCompositionBrushBaseProtected_adaptor() {}
};
template<typename X> struct adapt<IXamlCompositionBrushBaseProtected, X> : Windows::UI::Xaml::Media::IXamlCompositionBrushBaseProtected_adaptor<X> { typedef adapt IXamlCompositionBrushBaseProtected; };
struct IXamlCompositionBrushBaseProtected : IXamlCompositionBrushBaseProtected_raw, generate<IXamlCompositionBrushBaseProtected> {};

// IXamlCompositionBrushBaseStatics
struct IXamlCompositionBrushBaseStatics : IInspectable {
	virtual STDMETHODIMP _get_FallbackColorProperty(DependencyProperty* *value);
};

// IXamlCompositionBrushBaseFactory
struct IXamlCompositionBrushBaseFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, XamlCompositionBrushBase* *instance);
};

// XamlCompositionBrushBase
template<typename> struct XamlCompositionBrushBase_statics {
	static struct _FallbackColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<XamlCompositionBrushBase, IXamlCompositionBrushBaseStatics>()->_get_FallbackColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FallbackColorProperty;
};
template<typename X> typename XamlCompositionBrushBase_statics<X>::_FallbackColorProperty XamlCompositionBrushBase_statics<X>::FallbackColorProperty;

template<typename X> struct statics<XamlCompositionBrushBase, X> : X, Windows::UI::Xaml::Media::XamlCompositionBrushBase_statics<void> {
	typedef typename X::root_type XamlCompositionBrushBase;
};
struct XamlCompositionBrushBase : generate<XamlCompositionBrushBase> {};

// AcrylicBrush
template<typename> struct AcrylicBrush_statics {
	static struct _AlwaysUseFallbackProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AcrylicBrush, IAcrylicBrushStatics>()->_get_AlwaysUseFallbackProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlwaysUseFallbackProperty;
	static struct _BackgroundSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AcrylicBrush, IAcrylicBrushStatics>()->_get_BackgroundSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BackgroundSourceProperty;
	static struct _TintColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AcrylicBrush, IAcrylicBrushStatics>()->_get_TintColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TintColorProperty;
	static struct _TintOpacityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AcrylicBrush, IAcrylicBrushStatics>()->_get_TintOpacityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TintOpacityProperty;
	static struct _TintTransitionDurationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AcrylicBrush, IAcrylicBrushStatics>()->_get_TintTransitionDurationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TintTransitionDurationProperty;
	static AcrylicBrush *activate(object_ref outer, IInspectable* *inner) { AcrylicBrush *instance; hrcheck(get_activation_factory<AcrylicBrush, IAcrylicBrushFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename AcrylicBrush_statics<X>::_AlwaysUseFallbackProperty AcrylicBrush_statics<X>::AlwaysUseFallbackProperty;
template<typename X> typename AcrylicBrush_statics<X>::_BackgroundSourceProperty AcrylicBrush_statics<X>::BackgroundSourceProperty;
template<typename X> typename AcrylicBrush_statics<X>::_TintColorProperty AcrylicBrush_statics<X>::TintColorProperty;
template<typename X> typename AcrylicBrush_statics<X>::_TintOpacityProperty AcrylicBrush_statics<X>::TintOpacityProperty;
template<typename X> typename AcrylicBrush_statics<X>::_TintTransitionDurationProperty AcrylicBrush_statics<X>::TintTransitionDurationProperty;

template<typename X> struct statics<AcrylicBrush, X> : X, Windows::UI::Xaml::Media::AcrylicBrush_statics<void> {
	using Windows::UI::Xaml::Media::AcrylicBrush_statics<void>::activate;
	typedef typename X::root_type AcrylicBrush;
};
struct AcrylicBrush : generate<AcrylicBrush> {};

// RevealBrush
template<typename> struct RevealBrush_statics {
	static struct _AlwaysUseFallbackProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RevealBrush, IRevealBrushStatics>()->_get_AlwaysUseFallbackProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlwaysUseFallbackProperty;
	static struct _ColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RevealBrush, IRevealBrushStatics>()->_get_ColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ColorProperty;
	static struct _StateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RevealBrush, IRevealBrushStatics>()->_get_StateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StateProperty;
	static struct _TargetThemeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RevealBrush, IRevealBrushStatics>()->_get_TargetThemeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetThemeProperty;
	static void SetState(pptr<UIElement> element, RevealBrushState value) { hrcheck(get_activation_factory<RevealBrush, IRevealBrushStatics>()->_SetState(element, value)); }
	static RevealBrushState GetState(pptr<UIElement> element) { RevealBrushState result; hrcheck(get_activation_factory<RevealBrush, IRevealBrushStatics>()->_GetState(element, &result)); return result; }
};
template<typename X> typename RevealBrush_statics<X>::_AlwaysUseFallbackProperty RevealBrush_statics<X>::AlwaysUseFallbackProperty;
template<typename X> typename RevealBrush_statics<X>::_ColorProperty RevealBrush_statics<X>::ColorProperty;
template<typename X> typename RevealBrush_statics<X>::_StateProperty RevealBrush_statics<X>::StateProperty;
template<typename X> typename RevealBrush_statics<X>::_TargetThemeProperty RevealBrush_statics<X>::TargetThemeProperty;

template<typename X> struct statics<RevealBrush, X> : X, Windows::UI::Xaml::Media::RevealBrush_statics<void> {
	typedef typename X::root_type RevealBrush;
};
struct RevealBrush : generate<RevealBrush> {};

// RevealBorderBrush
template<typename> struct RevealBorderBrush_statics {
	static RevealBorderBrush *activate(object_ref outer, IInspectable* *inner) { RevealBorderBrush *instance; hrcheck(get_activation_factory<RevealBorderBrush, IRevealBorderBrushFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<RevealBorderBrush, X> : X, Windows::UI::Xaml::Media::RevealBorderBrush_statics<void> {
	using Windows::UI::Xaml::Media::RevealBorderBrush_statics<void>::activate;
	typedef typename X::root_type RevealBorderBrush;
};
struct RevealBorderBrush : generate<RevealBorderBrush> {};

// RevealBackgroundBrush
template<typename> struct RevealBackgroundBrush_statics {
	static RevealBackgroundBrush *activate(object_ref outer, IInspectable* *inner) { RevealBackgroundBrush *instance; hrcheck(get_activation_factory<RevealBackgroundBrush, IRevealBackgroundBrushFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<RevealBackgroundBrush, X> : X, Windows::UI::Xaml::Media::RevealBackgroundBrush_statics<void> {
	using Windows::UI::Xaml::Media::RevealBackgroundBrush_statics<void>::activate;
	typedef typename X::root_type RevealBackgroundBrush;
};
struct RevealBackgroundBrush : generate<RevealBackgroundBrush> {};

// IImageBrush
struct IImageBrush_raw : IInspectable {
	virtual STDMETHODIMP _get_ImageSource(Media::ImageSource* *value);
	virtual STDMETHODIMP _put_ImageSource(Media::ImageSource* value);
	virtual STDMETHODIMP _add_ImageFailed(ExceptionRoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ImageFailed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ImageOpened(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ImageOpened(Foundation::EventRegistrationToken token);
};
template<typename X> struct IImageBrush_adaptor : X {
	union {
		struct : property {
			ptr<Media::ImageSource> get() { Media::ImageSource* value; hrcheck(enc(&IImageBrush_adaptor::ImageSource)->_get_ImageSource(&value)); return from_abi(value); }
			ptr<Media::ImageSource> operator()() { return get(); }
			operator ptr<Media::ImageSource> () { return get(); }
			ptr<Media::ImageSource> operator->() { return get(); }
			void put(pptr<Media::ImageSource> value) { hrcheck(enc(&IImageBrush_adaptor::ImageSource)->_put_ImageSource(value)); }
			void operator=(pptr<Media::ImageSource> value) { put(value); }
			void operator()(pptr<Media::ImageSource> value) { put(value); }
		} ImageSource;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<ExceptionRoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IImageBrush_adaptor::ImageFailed)->_add_ImageFailed(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IImageBrush_adaptor::ImageFailed)->_remove_ImageFailed(token)); }
		} ImageFailed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IImageBrush_adaptor::ImageOpened)->_add_ImageOpened(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IImageBrush_adaptor::ImageOpened)->_remove_ImageOpened(token)); }
		} ImageOpened;
	};
	IImageBrush_adaptor() {}
};
template<typename X> struct adapt<IImageBrush, X> : Windows::UI::Xaml::Media::IImageBrush_adaptor<X> { typedef adapt IImageBrush; };
struct IImageBrush : IImageBrush_raw, generate<IImageBrush> {};

// IImageBrushStatics
struct IImageBrushStatics : IInspectable {
	virtual STDMETHODIMP _get_ImageSourceProperty(DependencyProperty* *value);
};

// ImageBrush
template<typename> struct ImageBrush_statics {
	static struct _ImageSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ImageBrush, IImageBrushStatics>()->_get_ImageSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ImageSourceProperty;
};
template<typename X> typename ImageBrush_statics<X>::_ImageSourceProperty ImageBrush_statics<X>::ImageSourceProperty;

template<typename X> struct statics<ImageBrush, X> : X, Windows::UI::Xaml::Media::ImageBrush_statics<void> {
	typedef typename X::root_type ImageBrush;
};
struct ImageBrush : generate<ImageBrush> {};

// ILinearGradientBrush
struct ILinearGradientBrush_raw : IInspectable {
	virtual STDMETHODIMP _get_StartPoint(Foundation::Point *value);
	virtual STDMETHODIMP _put_StartPoint(Foundation::Point value);
	virtual STDMETHODIMP _get_EndPoint(Foundation::Point *value);
	virtual STDMETHODIMP _put_EndPoint(Foundation::Point value);
};
template<typename X> struct ILinearGradientBrush_adaptor : X {
	union {
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&ILinearGradientBrush_adaptor::EndPoint)->_get_EndPoint(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&ILinearGradientBrush_adaptor::EndPoint)->_put_EndPoint(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} EndPoint;
		struct : property {
			Foundation::Point get() { Foundation::Point value; hrcheck(enc(&ILinearGradientBrush_adaptor::StartPoint)->_get_StartPoint(&value)); return value; }
			Foundation::Point operator()() { return get(); }
			operator Foundation::Point () { return get(); }
			void put(const Foundation::Point& value) { hrcheck(enc(&ILinearGradientBrush_adaptor::StartPoint)->_put_StartPoint(value)); }
			void operator=(const Foundation::Point& value) { put(value); }
			void operator()(const Foundation::Point& value) { put(value); }
		} StartPoint;
	};
	ILinearGradientBrush_adaptor() {}
};
template<typename X> struct adapt<ILinearGradientBrush, X> : Windows::UI::Xaml::Media::ILinearGradientBrush_adaptor<X> { typedef adapt ILinearGradientBrush; };
struct ILinearGradientBrush : ILinearGradientBrush_raw, generate<ILinearGradientBrush> {};

// ILinearGradientBrushStatics
struct ILinearGradientBrushStatics : IInspectable {
	virtual STDMETHODIMP _get_StartPointProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_EndPointProperty(DependencyProperty* *value);
};

// ILinearGradientBrushFactory
struct ILinearGradientBrushFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithGradientStopCollectionAndAngle(GradientStopCollection* gradientStopCollection, double angle, LinearGradientBrush* *instance);
};

// LinearGradientBrush
template<typename> struct LinearGradientBrush_statics {
	static struct _EndPointProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<LinearGradientBrush, ILinearGradientBrushStatics>()->_get_EndPointProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EndPointProperty;
	static struct _StartPointProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<LinearGradientBrush, ILinearGradientBrushStatics>()->_get_StartPointProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StartPointProperty;
	static LinearGradientBrush *activate(pptr<GradientStopCollection> gradientStopCollection, double angle) { LinearGradientBrush *instance; hrcheck(get_activation_factory<LinearGradientBrush, ILinearGradientBrushFactory>()->_CreateInstanceWithGradientStopCollectionAndAngle(gradientStopCollection, angle, &instance)); return instance; }
	static LinearGradientBrush *activate() { LinearGradientBrush *t; get_activation_factory<LinearGradientBrush>()->ActivateInstance((IInspectable**)&t); return t; }
};
template<typename X> typename LinearGradientBrush_statics<X>::_EndPointProperty LinearGradientBrush_statics<X>::EndPointProperty;
template<typename X> typename LinearGradientBrush_statics<X>::_StartPointProperty LinearGradientBrush_statics<X>::StartPointProperty;

template<typename X> struct statics<LinearGradientBrush, X> : X, Windows::UI::Xaml::Media::LinearGradientBrush_statics<void> {
	using Windows::UI::Xaml::Media::LinearGradientBrush_statics<void>::activate;
	typedef typename X::root_type LinearGradientBrush;
};
struct LinearGradientBrush : generate<LinearGradientBrush> {};
}}}}
} // namespace iso_winrt
