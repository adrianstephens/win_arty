#pragma once
// generated by isopod tools
// namespaces:
// Windows.Foundation.Metadata

#include "Windows.Foundation.Metadata.0.h"

namespace iso_winrt {

// forward types


// defs

template<> struct def<Windows::Foundation::Metadata::WebHostHiddenAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::AllowForWebAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::VariantAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::HasVariantAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::DualApiPartitionAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::MuseAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::GCPressureAmount> : enum_type<int> {};
template<> struct def<Windows::Foundation::Metadata::GCPressureAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::MetadataMarshalAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::IApiInformationStatics> : interface_type<> {};
template<> struct def<Windows::Foundation::Metadata::ApiInformation> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::Platform> : enum_type<int> {};
template<> struct def<Windows::Foundation::Metadata::ActivatableAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::VersionAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::ContractVersionAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::AllowMultipleAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::AttributeTargets> : enum_type<unsigned> {};
template<> struct def<Windows::Foundation::Metadata::AttributeUsageAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::DefaultOverloadAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::DefaultAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::GuidAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::FeatureStage> : enum_type<int> {};
template<> struct def<Windows::Foundation::Metadata::FeatureAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::ExperimentalAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::CompositionType> : enum_type<int> {};
template<> struct def<Windows::Foundation::Metadata::ComposableAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::OverloadAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::ApiContractAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::PreviousContractVersionAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::StaticAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::OverridableAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::ProtectedAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::ThreadingModel> : enum_type<int> {};
template<> struct def<Windows::Foundation::Metadata::ThreadingAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::MarshalingType> : enum_type<int> {};
template<> struct def<Windows::Foundation::Metadata::MarshalingBehaviorAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::DeprecationType> : enum_type<int> {};
template<> struct def<Windows::Foundation::Metadata::DeprecatedAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::PlatformAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::ExclusiveToAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::LengthIsAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::RangeAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::RemoteAsyncAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::InternalAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::Foundation::Metadata::CreateFromStringAttribute> : class_type<Platform::Attribute, Platform::Object> {};

// uuids

template<> struct uuid<Windows::Foundation::Metadata::IApiInformationStatics> { define_guid(0x997439FE, 0xF681, 0x4A11, 0xB4, 0x16, 0xC1, 0x3A, 0x47, 0xE8, 0xBA, 0x36);};

// types

namespace Windows { namespace Foundation { namespace Metadata {

// WebHostHiddenAttribute
template<typename X> struct statics<WebHostHiddenAttribute, X> : X {
	typedef typename X::root_type WebHostHiddenAttribute;
};
struct WebHostHiddenAttribute : generate<WebHostHiddenAttribute> {};

// AllowForWebAttribute
template<typename X> struct statics<AllowForWebAttribute, X> : X {
	typedef typename X::root_type AllowForWebAttribute;
};
struct AllowForWebAttribute : generate<AllowForWebAttribute> {};

// VariantAttribute
template<typename X> struct statics<VariantAttribute, X> : X {
	typedef typename X::root_type VariantAttribute;
};
struct VariantAttribute : generate<VariantAttribute> {};

// HasVariantAttribute
template<typename X> struct statics<HasVariantAttribute, X> : X {
	typedef typename X::root_type HasVariantAttribute;
};
struct HasVariantAttribute : generate<HasVariantAttribute> {};

// DualApiPartitionAttribute
template<typename X> struct statics<DualApiPartitionAttribute, X> : X {
	typedef typename X::root_type DualApiPartitionAttribute;
};
struct DualApiPartitionAttribute : generate<DualApiPartitionAttribute> {};

// MuseAttribute
template<typename X> struct statics<MuseAttribute, X> : X {
	typedef typename X::root_type MuseAttribute;
};
struct MuseAttribute : generate<MuseAttribute> {};

// GCPressureAttribute
template<typename X> struct statics<GCPressureAttribute, X> : X {
	typedef typename X::root_type GCPressureAttribute;
};
struct GCPressureAttribute : generate<GCPressureAttribute> {};

// MetadataMarshalAttribute
template<typename X> struct statics<MetadataMarshalAttribute, X> : X {
	typedef typename X::root_type MetadataMarshalAttribute;
};
struct MetadataMarshalAttribute : generate<MetadataMarshalAttribute> {};

// IApiInformationStatics
struct IApiInformationStatics : IInspectable {
	virtual STDMETHODIMP _IsTypePresent(HSTRING typeName, bool *result);
	virtual STDMETHODIMP _IsMethodPresent(HSTRING typeName, HSTRING methodName, bool *result);
	virtual STDMETHODIMP _IsMethodPresentWithArity(HSTRING typeName, HSTRING methodName, unsigned inputParameterCount, bool *result);
	virtual STDMETHODIMP _IsEventPresent(HSTRING typeName, HSTRING eventName, bool *result);
	virtual STDMETHODIMP _IsPropertyPresent(HSTRING typeName, HSTRING propertyName, bool *result);
	virtual STDMETHODIMP _IsReadOnlyPropertyPresent(HSTRING typeName, HSTRING propertyName, bool *result);
	virtual STDMETHODIMP _IsWriteablePropertyPresent(HSTRING typeName, HSTRING propertyName, bool *result);
	virtual STDMETHODIMP _IsEnumNamedValuePresent(HSTRING enumTypeName, HSTRING valueName, bool *result);
	virtual STDMETHODIMP _IsApiContractPresentByMajor(HSTRING contractName, unsigned short majorVersion, bool *result);
	virtual STDMETHODIMP _IsApiContractPresentByMajorAndMinor(HSTRING contractName, unsigned short majorVersion, unsigned short minorVersion, bool *result);
};

// ApiInformation
template<typename> struct ApiInformation_statics {
	static bool IsTypePresent(hstring_ref typeName) { bool result; hrcheck(get_activation_factory<ApiInformation, IApiInformationStatics>()->_IsTypePresent(typeName, &result)); return result; }
	static bool IsMethodPresent(hstring_ref typeName, hstring_ref methodName) { bool result; hrcheck(get_activation_factory<ApiInformation, IApiInformationStatics>()->_IsMethodPresent(typeName, methodName, &result)); return result; }
	static bool IsMethodPresent(hstring_ref typeName, hstring_ref methodName, unsigned inputParameterCount) { bool result; hrcheck(get_activation_factory<ApiInformation, IApiInformationStatics>()->_IsMethodPresentWithArity(typeName, methodName, inputParameterCount, &result)); return result; }
	static bool IsEventPresent(hstring_ref typeName, hstring_ref eventName) { bool result; hrcheck(get_activation_factory<ApiInformation, IApiInformationStatics>()->_IsEventPresent(typeName, eventName, &result)); return result; }
	static bool IsPropertyPresent(hstring_ref typeName, hstring_ref propertyName) { bool result; hrcheck(get_activation_factory<ApiInformation, IApiInformationStatics>()->_IsPropertyPresent(typeName, propertyName, &result)); return result; }
	static bool IsReadOnlyPropertyPresent(hstring_ref typeName, hstring_ref propertyName) { bool result; hrcheck(get_activation_factory<ApiInformation, IApiInformationStatics>()->_IsReadOnlyPropertyPresent(typeName, propertyName, &result)); return result; }
	static bool IsWriteablePropertyPresent(hstring_ref typeName, hstring_ref propertyName) { bool result; hrcheck(get_activation_factory<ApiInformation, IApiInformationStatics>()->_IsWriteablePropertyPresent(typeName, propertyName, &result)); return result; }
	static bool IsEnumNamedValuePresent(hstring_ref enumTypeName, hstring_ref valueName) { bool result; hrcheck(get_activation_factory<ApiInformation, IApiInformationStatics>()->_IsEnumNamedValuePresent(enumTypeName, valueName, &result)); return result; }
	static bool IsApiContractPresent(hstring_ref contractName, unsigned short majorVersion) { bool result; hrcheck(get_activation_factory<ApiInformation, IApiInformationStatics>()->_IsApiContractPresentByMajor(contractName, majorVersion, &result)); return result; }
	static bool IsApiContractPresent(hstring_ref contractName, unsigned short majorVersion, unsigned short minorVersion) { bool result; hrcheck(get_activation_factory<ApiInformation, IApiInformationStatics>()->_IsApiContractPresentByMajorAndMinor(contractName, majorVersion, minorVersion, &result)); return result; }
};

template<typename X> struct statics<ApiInformation, X> : X, Windows::Foundation::Metadata::ApiInformation_statics<void> {
	typedef typename X::root_type ApiInformation;
};
struct ApiInformation : generate<ApiInformation> {};

// ActivatableAttribute
template<typename X> struct statics<ActivatableAttribute, X> : X {
	typedef typename X::root_type ActivatableAttribute;
};
struct ActivatableAttribute : generate<ActivatableAttribute> {};

// VersionAttribute
template<typename X> struct statics<VersionAttribute, X> : X {
	typedef typename X::root_type VersionAttribute;
};
struct VersionAttribute : generate<VersionAttribute> {};

// ContractVersionAttribute
template<typename X> struct statics<ContractVersionAttribute, X> : X {
	typedef typename X::root_type ContractVersionAttribute;
};
struct ContractVersionAttribute : generate<ContractVersionAttribute> {};

// AllowMultipleAttribute
template<typename X> struct statics<AllowMultipleAttribute, X> : X {
	typedef typename X::root_type AllowMultipleAttribute;
};
struct AllowMultipleAttribute : generate<AllowMultipleAttribute> {};

// AttributeUsageAttribute
template<typename X> struct statics<AttributeUsageAttribute, X> : X {
	typedef typename X::root_type AttributeUsageAttribute;
};
struct AttributeUsageAttribute : generate<AttributeUsageAttribute> {};

// DefaultOverloadAttribute
template<typename X> struct statics<DefaultOverloadAttribute, X> : X {
	typedef typename X::root_type DefaultOverloadAttribute;
};
struct DefaultOverloadAttribute : generate<DefaultOverloadAttribute> {};

// DefaultAttribute
template<typename X> struct statics<DefaultAttribute, X> : X {
	typedef typename X::root_type DefaultAttribute;
};
struct DefaultAttribute : generate<DefaultAttribute> {};

// GuidAttribute
template<typename X> struct statics<GuidAttribute, X> : X {
	typedef typename X::root_type GuidAttribute;
};
struct GuidAttribute : generate<GuidAttribute> {};

// FeatureAttribute
template<typename X> struct statics<FeatureAttribute, X> : X {
	typedef typename X::root_type FeatureAttribute;
};
struct FeatureAttribute : generate<FeatureAttribute> {};

// ExperimentalAttribute
template<typename X> struct statics<ExperimentalAttribute, X> : X {
	typedef typename X::root_type ExperimentalAttribute;
};
struct ExperimentalAttribute : generate<ExperimentalAttribute> {};

// ComposableAttribute
template<typename X> struct statics<ComposableAttribute, X> : X {
	typedef typename X::root_type ComposableAttribute;
};
struct ComposableAttribute : generate<ComposableAttribute> {};

// OverloadAttribute
template<typename X> struct statics<OverloadAttribute, X> : X {
	typedef typename X::root_type OverloadAttribute;
};
struct OverloadAttribute : generate<OverloadAttribute> {};

// ApiContractAttribute
template<typename X> struct statics<ApiContractAttribute, X> : X {
	typedef typename X::root_type ApiContractAttribute;
};
struct ApiContractAttribute : generate<ApiContractAttribute> {};

// PreviousContractVersionAttribute
template<typename X> struct statics<PreviousContractVersionAttribute, X> : X {
	typedef typename X::root_type PreviousContractVersionAttribute;
};
struct PreviousContractVersionAttribute : generate<PreviousContractVersionAttribute> {};

// StaticAttribute
template<typename X> struct statics<StaticAttribute, X> : X {
	typedef typename X::root_type StaticAttribute;
};
struct StaticAttribute : generate<StaticAttribute> {};

// OverridableAttribute
template<typename X> struct statics<OverridableAttribute, X> : X {
	typedef typename X::root_type OverridableAttribute;
};
struct OverridableAttribute : generate<OverridableAttribute> {};

// ProtectedAttribute
template<typename X> struct statics<ProtectedAttribute, X> : X {
	typedef typename X::root_type ProtectedAttribute;
};
struct ProtectedAttribute : generate<ProtectedAttribute> {};

// ThreadingAttribute
template<typename X> struct statics<ThreadingAttribute, X> : X {
	typedef typename X::root_type ThreadingAttribute;
};
struct ThreadingAttribute : generate<ThreadingAttribute> {};

// MarshalingBehaviorAttribute
template<typename X> struct statics<MarshalingBehaviorAttribute, X> : X {
	typedef typename X::root_type MarshalingBehaviorAttribute;
};
struct MarshalingBehaviorAttribute : generate<MarshalingBehaviorAttribute> {};

// DeprecatedAttribute
template<typename X> struct statics<DeprecatedAttribute, X> : X {
	typedef typename X::root_type DeprecatedAttribute;
};
struct DeprecatedAttribute : generate<DeprecatedAttribute> {};

// PlatformAttribute
template<typename X> struct statics<PlatformAttribute, X> : X {
	typedef typename X::root_type PlatformAttribute;
};
struct PlatformAttribute : generate<PlatformAttribute> {};

// ExclusiveToAttribute
template<typename X> struct statics<ExclusiveToAttribute, X> : X {
	typedef typename X::root_type ExclusiveToAttribute;
};
struct ExclusiveToAttribute : generate<ExclusiveToAttribute> {};

// LengthIsAttribute
template<typename X> struct statics<LengthIsAttribute, X> : X {
	typedef typename X::root_type LengthIsAttribute;
};
struct LengthIsAttribute : generate<LengthIsAttribute> {};

// RangeAttribute
template<typename X> struct statics<RangeAttribute, X> : X {
	typedef typename X::root_type RangeAttribute;
};
struct RangeAttribute : generate<RangeAttribute> {};

// RemoteAsyncAttribute
template<typename X> struct statics<RemoteAsyncAttribute, X> : X {
	typedef typename X::root_type RemoteAsyncAttribute;
};
struct RemoteAsyncAttribute : generate<RemoteAsyncAttribute> {};

// InternalAttribute
template<typename X> struct statics<InternalAttribute, X> : X {
	typedef typename X::root_type InternalAttribute;
};
struct InternalAttribute : generate<InternalAttribute> {};

// CreateFromStringAttribute
template<typename X> struct statics<CreateFromStringAttribute, X> : X {
	typedef typename X::root_type CreateFromStringAttribute;
};
struct CreateFromStringAttribute : generate<CreateFromStringAttribute> {};
}}}
} // namespace iso_winrt
