#pragma once
// generated by isopod tools
// namespaces:
// Windows.UI.Xaml.Media.Imaging

#include "Windows.UI.Xaml.Media.Imaging.0.h"
#include "Windows.UI.Xaml.Media.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace ApplicationModel { namespace Background {
struct IBackgroundTaskInstance;
}}
namespace Graphics { namespace Imaging {
struct SoftwareBitmap;
}}
namespace Storage { namespace Streams {
struct IRandomAccessStream;
struct IBuffer;
}}
namespace UI { namespace Xaml {
struct RoutedEventHandler;
struct ExceptionRoutedEventHandler;
struct DependencyProperty;
struct UIElement;
}}}

// defs

template<> struct def<Windows::UI::Xaml::Media::Imaging::BitmapCreateOptions> : enum_type<unsigned> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::DecodePixelType> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::DownloadProgressEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IDownloadProgressEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::DownloadProgressEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Media::Imaging::IDownloadProgressEventArgs> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IBitmapSource> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IBitmapSourceStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IBitmapSourceFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::BitmapSource> : class_type<Windows::UI::Xaml::Media::ImageSource, Windows::UI::Xaml::Media::Imaging::IBitmapSource> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IRenderTargetBitmap> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IRenderTargetBitmapStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::RenderTargetBitmap> : class_type<Windows::UI::Xaml::Media::ImageSource, Windows::UI::Xaml::Media::Imaging::IRenderTargetBitmap> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::ISurfaceImageSource> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::ISurfaceImageSourceFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::SurfaceImageSource> : class_type<Windows::UI::Xaml::Media::ImageSource, Windows::UI::Xaml::Media::Imaging::ISurfaceImageSource>, composer_type<Windows::UI::Xaml::Media::Imaging::ISurfaceImageSourceFactory> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IBitmapImage> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IBitmapImageStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IBitmapImageFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IBitmapImage2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IBitmapImageStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IBitmapImage3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IBitmapImageStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::BitmapImage> : class_type<Windows::UI::Xaml::Media::Imaging::BitmapSource, Windows::UI::Xaml::Media::Imaging::IBitmapImage, Windows::UI::Xaml::Media::Imaging::IBitmapImage2, Windows::UI::Xaml::Media::Imaging::IBitmapImage3>, custom_activators {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IVirtualSurfaceImageSource> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IVirtualSurfaceImageSourceFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource> : class_type<Windows::UI::Xaml::Media::Imaging::SurfaceImageSource, Windows::UI::Xaml::Media::Imaging::IVirtualSurfaceImageSource>, custom_activators {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IWriteableBitmap> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IWriteableBitmapFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::WriteableBitmap> : class_type<Windows::UI::Xaml::Media::Imaging::BitmapSource, Windows::UI::Xaml::Media::Imaging::IWriteableBitmap>, custom_activators {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::SvgImageSourceLoadStatus> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::ISvgImageSourceFailedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Media::Imaging::ISvgImageSourceFailedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::ISvgImageSourceOpenedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::SvgImageSourceOpenedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Media::Imaging::ISvgImageSourceOpenedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IXamlRenderingBackgroundTask> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IXamlRenderingBackgroundTaskOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::IXamlRenderingBackgroundTaskFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::XamlRenderingBackgroundTask> : class_type<Platform::Object, Windows::UI::Xaml::Media::Imaging::IXamlRenderingBackgroundTask, Windows::UI::Xaml::Media::Imaging::IXamlRenderingBackgroundTaskOverrides> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::ISoftwareBitmapSource> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::SoftwareBitmapSource> : class_type<Windows::UI::Xaml::Media::ImageSource, Windows::UI::Xaml::Media::Imaging::ISoftwareBitmapSource, Windows::Foundation::IClosable> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::ISvgImageSource> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::ISvgImageSourceFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::ISvgImageSourceStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Media::Imaging::SvgImageSource> : class_type<Windows::UI::Xaml::Media::ImageSource, Windows::UI::Xaml::Media::Imaging::ISvgImageSource>, composer_type<Windows::UI::Xaml::Media::Imaging::ISvgImageSourceFactory> {};

// uuids

template<> struct uuid<Windows::UI::Xaml::Media::Imaging::DownloadProgressEventHandler> { define_guid(0x1ABAEE23, 0x74EE, 0x4CC7, 0x99, 0xBA, 0xB1, 0x71, 0xE3, 0xCD, 0xA6, 0x1E);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IDownloadProgressEventArgs> { define_guid(0x7311E0D4, 0xFE94, 0x4E70, 0x9B, 0x90, 0xCD, 0xD4, 0x7A, 0xC2, 0x3A, 0xFB);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IBitmapSource> { define_guid(0x23D86411, 0x202F, 0x41B2, 0x8C, 0x5B, 0xA8, 0xA3, 0xB3, 0x33, 0x80, 0xB);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IBitmapSourceStatics> { define_guid(0x9A9C9981, 0x827B, 0x4E51, 0x89, 0x1B, 0x8A, 0x15, 0xB5, 0x11, 0x84, 0x2D);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IBitmapSourceFactory> { define_guid(0xE240420E, 0xD4A7, 0x49A4, 0xA0, 0xB4, 0xA5, 0x9F, 0xDD, 0x77, 0xE5, 0x8);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IRenderTargetBitmap> { define_guid(0x500DEE81, 0x893C, 0x4C0A, 0x8F, 0xEC, 0x46, 0x78, 0xAC, 0x71, 0x75, 0x89);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IRenderTargetBitmapStatics> { define_guid(0xF0A1EFEE, 0xC131, 0x4D40, 0x9C, 0x47, 0xF7, 0xD7, 0xCF, 0x2B, 0x7, 0x7F);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::ISurfaceImageSource> { define_guid(0x62F7D416, 0xC714, 0x4C4C, 0x82, 0x73, 0xF8, 0x39, 0xBC, 0x58, 0x13, 0x5C);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::ISurfaceImageSourceFactory> { define_guid(0x3AB2212A, 0xEF65, 0x4A5F, 0xBF, 0xAC, 0x73, 0x99, 0x3E, 0x8C, 0x12, 0xC9);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IBitmapImage> { define_guid(0x31AF3271, 0xE3B4, 0x442D, 0xA3, 0x41, 0x4C, 0x2, 0x26, 0xB2, 0x72, 0x5B);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IBitmapImageStatics> { define_guid(0x9E282143, 0x70E8, 0x437C, 0x9F, 0xA4, 0x2C, 0xBF, 0x29, 0x5C, 0xFF, 0x84);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IBitmapImageFactory> { define_guid(0xC9132978, 0x4810, 0x4E5E, 0x80, 0x87, 0x3, 0x67, 0x1E, 0xE6, 0xD, 0x85);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IBitmapImage2> { define_guid(0x1069C1B6, 0x8C9B, 0x4762, 0xBE, 0x3D, 0x75, 0x9F, 0x56, 0x98, 0xF2, 0xB3);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IBitmapImageStatics2> { define_guid(0xC5F5576A, 0x75AF, 0x41A4, 0xB8, 0x93, 0x8F, 0xE9, 0x1F, 0xEE, 0x28, 0x82);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IBitmapImage3> { define_guid(0xF1DE6F26, 0x3C73, 0x453F, 0xA7, 0xBA, 0x9B, 0x85, 0xC1, 0x8B, 0x37, 0x33);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IBitmapImageStatics3> { define_guid(0x2B44E30D, 0xF6D5, 0x4411, 0xA8, 0xCD, 0xBF, 0x76, 0x3, 0xC4, 0xFA, 0xA0);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IVirtualSurfaceImageSource> { define_guid(0x4A711FEA, 0xBFAC, 0x11E0, 0xA0, 0x6A, 0x9D, 0xE4, 0x47, 0x24, 0x1, 0x9B);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IVirtualSurfaceImageSourceFactory> { define_guid(0x3AB2212A, 0xBFAC, 0x11E0, 0x8A, 0x92, 0x69, 0xE4, 0x47, 0x24, 0x1, 0x9B);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IWriteableBitmap> { define_guid(0xBF0B7E6F, 0xDF7C, 0x4A85, 0x84, 0x13, 0xA1, 0x21, 0x62, 0x85, 0x83, 0x5C);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IWriteableBitmapFactory> { define_guid(0x5563EBB1, 0x3EF2, 0x42C5, 0x9C, 0x6D, 0x1C, 0xF5, 0xDC, 0xC0, 0x41, 0xFF);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::ISvgImageSourceFailedEventArgs> { define_guid(0x68BB3170, 0x3CCC, 0x4035, 0xAC, 0x1, 0x98, 0x34, 0x54, 0x3D, 0x74, 0x4E);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::ISvgImageSourceOpenedEventArgs> { define_guid(0x85EF4C16, 0x748E, 0x4008, 0x95, 0xC7, 0x6A, 0x23, 0xDD, 0x73, 0x16, 0xDB);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IXamlRenderingBackgroundTask> { define_guid(0x5D5FE9AA, 0x533E, 0x44B8, 0xA9, 0x75, 0xFC, 0x5F, 0x1E, 0x3B, 0xFF, 0x52);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IXamlRenderingBackgroundTaskOverrides> { define_guid(0x9C2A6997, 0xA908, 0x4711, 0xB4, 0xB2, 0xA9, 0x60, 0xDB, 0x3D, 0x8E, 0x5A);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::IXamlRenderingBackgroundTaskFactory> { define_guid(0xA3D1BB63, 0x38F8, 0x4DA3, 0x9F, 0xCA, 0xFD, 0x81, 0x28, 0xA2, 0xCB, 0xF9);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::ISoftwareBitmapSource> { define_guid(0xD2DD9ED0, 0xD3C5, 0x4056, 0x91, 0xB5, 0xB7, 0xC1, 0xD1, 0xE8, 0x13, 0xE);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::ISvgImageSource> { define_guid(0x3E1CEC3, 0xCA8, 0x4A4E, 0x8D, 0x7C, 0xC8, 0x8, 0xA0, 0x83, 0x85, 0x86);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::ISvgImageSourceFactory> { define_guid(0xC794E9E7, 0xCF23, 0x4D72, 0xBF, 0x1A, 0xDF, 0xAA, 0x16, 0xD8, 0xEA, 0x52);};
template<> struct uuid<Windows::UI::Xaml::Media::Imaging::ISvgImageSourceStatics> { define_guid(0x9C6638CE, 0xBED1, 0x4AAB, 0xAC, 0xBB, 0xD3, 0xE2, 0x18, 0x5D, 0x31, 0x5A);};

// types

namespace Windows { namespace UI { namespace Xaml { namespace Media { namespace Imaging {

// DownloadProgressEventHandler
struct DownloadProgressEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, DownloadProgressEventArgs* e) = 0;
};

// IDownloadProgressEventArgs
struct IDownloadProgressEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Progress(int *value);
	virtual STDMETHODIMP _put_Progress(int value);
};
template<typename X> struct IDownloadProgressEventArgs_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IDownloadProgressEventArgs_adaptor::Progress)->_get_Progress(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IDownloadProgressEventArgs_adaptor::Progress)->_put_Progress(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} Progress;
	};
	IDownloadProgressEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDownloadProgressEventArgs, X> : Windows::UI::Xaml::Media::Imaging::IDownloadProgressEventArgs_adaptor<X> { typedef adapt IDownloadProgressEventArgs; };
struct IDownloadProgressEventArgs : IDownloadProgressEventArgs_raw, generate<IDownloadProgressEventArgs> {};

// DownloadProgressEventArgs
template<typename X> struct statics<DownloadProgressEventArgs, X> : X {
	typedef typename X::root_type DownloadProgressEventArgs;
};
struct DownloadProgressEventArgs : generate<DownloadProgressEventArgs> {};

// IBitmapSource
struct IBitmapSource_raw : IInspectable {
	virtual STDMETHODIMP _get_PixelWidth(int *value);
	virtual STDMETHODIMP _get_PixelHeight(int *value);
	virtual STDMETHODIMP _SetSource(Storage::Streams::IRandomAccessStream* streamSource);
	virtual STDMETHODIMP _SetSourceAsync(Storage::Streams::IRandomAccessStream* streamSource, Foundation::IAsyncAction* *returnValue);
};
template<typename X> struct IBitmapSource_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IBitmapSource_adaptor::PixelHeight)->_get_PixelHeight(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} PixelHeight;
		struct : property {
			int get() { int value; hrcheck(enc(&IBitmapSource_adaptor::PixelWidth)->_get_PixelWidth(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} PixelWidth;
	};
	void SetSource(pptr<Storage::Streams::IRandomAccessStream> streamSource) { hrcheck(X::get()->_SetSource(streamSource)); }
	ptr<Foundation::IAsyncAction> SetSourceAsync(pptr<Storage::Streams::IRandomAccessStream> streamSource) { Foundation::IAsyncAction* returnValue; hrcheck(X::get()->_SetSourceAsync(streamSource, &returnValue)); return from_abi(returnValue); }
	IBitmapSource_adaptor() {}
};
template<typename X> struct adapt<IBitmapSource, X> : Windows::UI::Xaml::Media::Imaging::IBitmapSource_adaptor<X> { typedef adapt IBitmapSource; };
struct IBitmapSource : IBitmapSource_raw, generate<IBitmapSource> {};

// IBitmapSourceStatics
struct IBitmapSourceStatics : IInspectable {
	virtual STDMETHODIMP _get_PixelWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PixelHeightProperty(DependencyProperty* *value);
};

// IBitmapSourceFactory
struct IBitmapSourceFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, BitmapSource* *instance);
};

// BitmapSource
template<typename> struct BitmapSource_statics {
	static struct _PixelHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BitmapSource, IBitmapSourceStatics>()->_get_PixelHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PixelHeightProperty;
	static struct _PixelWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BitmapSource, IBitmapSourceStatics>()->_get_PixelWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PixelWidthProperty;
};
template<typename X> typename BitmapSource_statics<X>::_PixelHeightProperty BitmapSource_statics<X>::PixelHeightProperty;
template<typename X> typename BitmapSource_statics<X>::_PixelWidthProperty BitmapSource_statics<X>::PixelWidthProperty;

template<typename X> struct statics<BitmapSource, X> : X, Windows::UI::Xaml::Media::Imaging::BitmapSource_statics<void> {
	typedef typename X::root_type BitmapSource;
};
struct BitmapSource : generate<BitmapSource> {};

// IRenderTargetBitmap
struct IRenderTargetBitmap_raw : IInspectable {
	virtual STDMETHODIMP _get_PixelWidth(int *value);
	virtual STDMETHODIMP _get_PixelHeight(int *value);
	virtual STDMETHODIMP _RenderAsync(UIElement* element, Foundation::IAsyncAction* *returnValue);
	virtual STDMETHODIMP _RenderToSizeAsync(UIElement* element, int scaledWidth, int scaledHeight, Foundation::IAsyncAction* *returnValue);
	virtual STDMETHODIMP _GetPixelsAsync(Foundation::IAsyncOperation<Storage::Streams::IBuffer*>* *returnValue);
};
template<typename X> struct IRenderTargetBitmap_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IRenderTargetBitmap_adaptor::PixelHeight)->_get_PixelHeight(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} PixelHeight;
		struct : property {
			int get() { int value; hrcheck(enc(&IRenderTargetBitmap_adaptor::PixelWidth)->_get_PixelWidth(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} PixelWidth;
	};
	ptr<Foundation::IAsyncAction> RenderAsync(pptr<UIElement> element) { Foundation::IAsyncAction* returnValue; hrcheck(X::get()->_RenderAsync(element, &returnValue)); return from_abi(returnValue); }
	ptr<Foundation::IAsyncAction> RenderAsync(pptr<UIElement> element, int scaledWidth, int scaledHeight) { Foundation::IAsyncAction* returnValue; hrcheck(X::get()->_RenderToSizeAsync(element, scaledWidth, scaledHeight, &returnValue)); return from_abi(returnValue); }
	ptr<Foundation::IAsyncOperation<ptr<Storage::Streams::IBuffer>>> GetPixelsAsync() { Foundation::IAsyncOperation<Storage::Streams::IBuffer*>* returnValue; hrcheck(X::get()->_GetPixelsAsync(&returnValue)); return from_abi(returnValue); }
	IRenderTargetBitmap_adaptor() {}
};
template<typename X> struct adapt<IRenderTargetBitmap, X> : Windows::UI::Xaml::Media::Imaging::IRenderTargetBitmap_adaptor<X> { typedef adapt IRenderTargetBitmap; };
struct IRenderTargetBitmap : IRenderTargetBitmap_raw, generate<IRenderTargetBitmap> {};

// IRenderTargetBitmapStatics
struct IRenderTargetBitmapStatics : IInspectable {
	virtual STDMETHODIMP _get_PixelWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PixelHeightProperty(DependencyProperty* *value);
};

// RenderTargetBitmap
template<typename> struct RenderTargetBitmap_statics {
	static struct _PixelHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RenderTargetBitmap, IRenderTargetBitmapStatics>()->_get_PixelHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PixelHeightProperty;
	static struct _PixelWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RenderTargetBitmap, IRenderTargetBitmapStatics>()->_get_PixelWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PixelWidthProperty;
};
template<typename X> typename RenderTargetBitmap_statics<X>::_PixelHeightProperty RenderTargetBitmap_statics<X>::PixelHeightProperty;
template<typename X> typename RenderTargetBitmap_statics<X>::_PixelWidthProperty RenderTargetBitmap_statics<X>::PixelWidthProperty;

template<typename X> struct statics<RenderTargetBitmap, X> : X, Windows::UI::Xaml::Media::Imaging::RenderTargetBitmap_statics<void> {
	typedef typename X::root_type RenderTargetBitmap;
};
struct RenderTargetBitmap : generate<RenderTargetBitmap> {
	using IRenderTargetBitmap::RenderAsync;
};

// ISurfaceImageSource
struct ISurfaceImageSource : IInspectable, generate<ISurfaceImageSource> {};

// ISurfaceImageSourceFactory
struct ISurfaceImageSourceFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithDimensions(int pixelWidth, int pixelHeight, IInspectable* outer, IInspectable* *inner, SurfaceImageSource* *instance);
	virtual STDMETHODIMP _CreateInstanceWithDimensionsAndOpacity(int pixelWidth, int pixelHeight, bool isOpaque, IInspectable* outer, IInspectable* *inner, SurfaceImageSource* *instance);
};

// SurfaceImageSource
template<typename> struct SurfaceImageSource_statics {
	static SurfaceImageSource *activate(int pixelWidth, int pixelHeight, object_ref outer, IInspectable* *inner) { SurfaceImageSource *instance; hrcheck(get_activation_factory<SurfaceImageSource, ISurfaceImageSourceFactory>()->_CreateInstanceWithDimensions(pixelWidth, pixelHeight, outer, inner, &instance)); return instance; }
	static SurfaceImageSource *activate(int pixelWidth, int pixelHeight, bool isOpaque, object_ref outer, IInspectable* *inner) { SurfaceImageSource *instance; hrcheck(get_activation_factory<SurfaceImageSource, ISurfaceImageSourceFactory>()->_CreateInstanceWithDimensionsAndOpacity(pixelWidth, pixelHeight, isOpaque, outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<SurfaceImageSource, X> : X, Windows::UI::Xaml::Media::Imaging::SurfaceImageSource_statics<void> {
	using Windows::UI::Xaml::Media::Imaging::SurfaceImageSource_statics<void>::activate;
	typedef typename X::root_type SurfaceImageSource;
};
struct SurfaceImageSource : generate<SurfaceImageSource> {};

// IBitmapImage
struct IBitmapImage_raw : IInspectable {
	virtual STDMETHODIMP _get_CreateOptions(BitmapCreateOptions *value);
	virtual STDMETHODIMP _put_CreateOptions(BitmapCreateOptions value);
	virtual STDMETHODIMP _get_UriSource(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_UriSource(Foundation::Uri* value);
	virtual STDMETHODIMP _get_DecodePixelWidth(int *value);
	virtual STDMETHODIMP _put_DecodePixelWidth(int value);
	virtual STDMETHODIMP _get_DecodePixelHeight(int *value);
	virtual STDMETHODIMP _put_DecodePixelHeight(int value);
	virtual STDMETHODIMP _add_DownloadProgress(DownloadProgressEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DownloadProgress(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ImageOpened(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ImageOpened(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ImageFailed(ExceptionRoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ImageFailed(Foundation::EventRegistrationToken token);
};
template<typename X> struct IBitmapImage_adaptor : X {
	union {
		struct : property {
			BitmapCreateOptions get() { BitmapCreateOptions value; hrcheck(enc(&IBitmapImage_adaptor::CreateOptions)->_get_CreateOptions(&value)); return value; }
			BitmapCreateOptions operator()() { return get(); }
			operator BitmapCreateOptions () { return get(); }
			void put(BitmapCreateOptions value) { hrcheck(enc(&IBitmapImage_adaptor::CreateOptions)->_put_CreateOptions(value)); }
			void operator=(BitmapCreateOptions value) { put(value); }
			void operator()(BitmapCreateOptions value) { put(value); }
		} CreateOptions;
		struct : property {
			int get() { int value; hrcheck(enc(&IBitmapImage_adaptor::DecodePixelHeight)->_get_DecodePixelHeight(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IBitmapImage_adaptor::DecodePixelHeight)->_put_DecodePixelHeight(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} DecodePixelHeight;
		struct : property {
			int get() { int value; hrcheck(enc(&IBitmapImage_adaptor::DecodePixelWidth)->_get_DecodePixelWidth(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IBitmapImage_adaptor::DecodePixelWidth)->_put_DecodePixelWidth(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} DecodePixelWidth;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IBitmapImage_adaptor::UriSource)->_get_UriSource(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IBitmapImage_adaptor::UriSource)->_put_UriSource(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} UriSource;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<DownloadProgressEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IBitmapImage_adaptor::DownloadProgress)->_add_DownloadProgress(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IBitmapImage_adaptor::DownloadProgress)->_remove_DownloadProgress(token)); }
		} DownloadProgress;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<ExceptionRoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IBitmapImage_adaptor::ImageFailed)->_add_ImageFailed(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IBitmapImage_adaptor::ImageFailed)->_remove_ImageFailed(token)); }
		} ImageFailed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IBitmapImage_adaptor::ImageOpened)->_add_ImageOpened(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IBitmapImage_adaptor::ImageOpened)->_remove_ImageOpened(token)); }
		} ImageOpened;
	};
	IBitmapImage_adaptor() {}
};
template<typename X> struct adapt<IBitmapImage, X> : Windows::UI::Xaml::Media::Imaging::IBitmapImage_adaptor<X> { typedef adapt IBitmapImage; };
struct IBitmapImage : IBitmapImage_raw, generate<IBitmapImage> {};

// IBitmapImageStatics
struct IBitmapImageStatics : IInspectable {
	virtual STDMETHODIMP _get_CreateOptionsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_UriSourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DecodePixelWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DecodePixelHeightProperty(DependencyProperty* *value);
};

// IBitmapImageFactory
struct IBitmapImageFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithUriSource(Foundation::Uri* uriSource, BitmapImage* *instance);
};

// IBitmapImage2
struct IBitmapImage2_raw : IInspectable {
	virtual STDMETHODIMP _get_DecodePixelType(Imaging::DecodePixelType *value);
	virtual STDMETHODIMP _put_DecodePixelType(Imaging::DecodePixelType value);
};
template<typename X> struct IBitmapImage2_adaptor : X {
	union {
		struct : property {
			Imaging::DecodePixelType get() { Imaging::DecodePixelType value; hrcheck(enc(&IBitmapImage2_adaptor::DecodePixelType)->_get_DecodePixelType(&value)); return value; }
			Imaging::DecodePixelType operator()() { return get(); }
			operator Imaging::DecodePixelType () { return get(); }
			void put(Imaging::DecodePixelType value) { hrcheck(enc(&IBitmapImage2_adaptor::DecodePixelType)->_put_DecodePixelType(value)); }
			void operator=(Imaging::DecodePixelType value) { put(value); }
			void operator()(Imaging::DecodePixelType value) { put(value); }
		} DecodePixelType;
	};
	IBitmapImage2_adaptor() {}
};
template<typename X> struct adapt<IBitmapImage2, X> : Windows::UI::Xaml::Media::Imaging::IBitmapImage2_adaptor<X> { typedef adapt IBitmapImage2; };
struct IBitmapImage2 : IBitmapImage2_raw, generate<IBitmapImage2> {};

// IBitmapImageStatics2
struct IBitmapImageStatics2 : IInspectable {
	virtual STDMETHODIMP _get_DecodePixelTypeProperty(DependencyProperty* *value);
};

// IBitmapImage3
struct IBitmapImage3_raw : IInspectable {
	virtual STDMETHODIMP _get_IsAnimatedBitmap(bool *value);
	virtual STDMETHODIMP _get_IsPlaying(bool *value);
	virtual STDMETHODIMP _get_AutoPlay(bool *value);
	virtual STDMETHODIMP _put_AutoPlay(bool value);
	virtual STDMETHODIMP _Play();
	virtual STDMETHODIMP _Stop();
};
template<typename X> struct IBitmapImage3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBitmapImage3_adaptor::AutoPlay)->_get_AutoPlay(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IBitmapImage3_adaptor::AutoPlay)->_put_AutoPlay(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AutoPlay;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBitmapImage3_adaptor::IsAnimatedBitmap)->_get_IsAnimatedBitmap(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsAnimatedBitmap;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBitmapImage3_adaptor::IsPlaying)->_get_IsPlaying(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsPlaying;
	};
	void Play() { hrcheck(X::get()->_Play()); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	IBitmapImage3_adaptor() {}
};
template<typename X> struct adapt<IBitmapImage3, X> : Windows::UI::Xaml::Media::Imaging::IBitmapImage3_adaptor<X> { typedef adapt IBitmapImage3; };
struct IBitmapImage3 : IBitmapImage3_raw, generate<IBitmapImage3> {};

// IBitmapImageStatics3
struct IBitmapImageStatics3 : IInspectable {
	virtual STDMETHODIMP _get_IsAnimatedBitmapProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsPlayingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AutoPlayProperty(DependencyProperty* *value);
};

// BitmapImage
template<typename> struct BitmapImage_statics {
	static struct _CreateOptionsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BitmapImage, IBitmapImageStatics>()->_get_CreateOptionsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CreateOptionsProperty;
	static struct _DecodePixelHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BitmapImage, IBitmapImageStatics>()->_get_DecodePixelHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DecodePixelHeightProperty;
	static struct _DecodePixelWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BitmapImage, IBitmapImageStatics>()->_get_DecodePixelWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DecodePixelWidthProperty;
	static struct _UriSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BitmapImage, IBitmapImageStatics>()->_get_UriSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} UriSourceProperty;
	static struct _DecodePixelTypeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BitmapImage, IBitmapImageStatics2>()->_get_DecodePixelTypeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DecodePixelTypeProperty;
	static struct _AutoPlayProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BitmapImage, IBitmapImageStatics3>()->_get_AutoPlayProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AutoPlayProperty;
	static struct _IsAnimatedBitmapProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BitmapImage, IBitmapImageStatics3>()->_get_IsAnimatedBitmapProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsAnimatedBitmapProperty;
	static struct _IsPlayingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BitmapImage, IBitmapImageStatics3>()->_get_IsPlayingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsPlayingProperty;
	static BitmapImage *activate(pptr<Foundation::Uri> uriSource) { BitmapImage *instance; hrcheck(get_activation_factory<BitmapImage, IBitmapImageFactory>()->_CreateInstanceWithUriSource(uriSource, &instance)); return instance; }
	static BitmapImage *activate() { BitmapImage *t; get_activation_factory<BitmapImage>()->ActivateInstance((IInspectable**)&t); return t; }
};
template<typename X> typename BitmapImage_statics<X>::_CreateOptionsProperty BitmapImage_statics<X>::CreateOptionsProperty;
template<typename X> typename BitmapImage_statics<X>::_DecodePixelHeightProperty BitmapImage_statics<X>::DecodePixelHeightProperty;
template<typename X> typename BitmapImage_statics<X>::_DecodePixelWidthProperty BitmapImage_statics<X>::DecodePixelWidthProperty;
template<typename X> typename BitmapImage_statics<X>::_UriSourceProperty BitmapImage_statics<X>::UriSourceProperty;
template<typename X> typename BitmapImage_statics<X>::_DecodePixelTypeProperty BitmapImage_statics<X>::DecodePixelTypeProperty;
template<typename X> typename BitmapImage_statics<X>::_AutoPlayProperty BitmapImage_statics<X>::AutoPlayProperty;
template<typename X> typename BitmapImage_statics<X>::_IsAnimatedBitmapProperty BitmapImage_statics<X>::IsAnimatedBitmapProperty;
template<typename X> typename BitmapImage_statics<X>::_IsPlayingProperty BitmapImage_statics<X>::IsPlayingProperty;

template<typename X> struct statics<BitmapImage, X> : X, Windows::UI::Xaml::Media::Imaging::BitmapImage_statics<void> {
	using Windows::UI::Xaml::Media::Imaging::BitmapImage_statics<void>::activate;
	typedef typename X::root_type BitmapImage;
};
struct BitmapImage : generate<BitmapImage> {};

// IVirtualSurfaceImageSource
struct IVirtualSurfaceImageSource : IInspectable, generate<IVirtualSurfaceImageSource> {};

// IVirtualSurfaceImageSourceFactory
struct IVirtualSurfaceImageSourceFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithDimensions(int pixelWidth, int pixelHeight, VirtualSurfaceImageSource* *instance);
	virtual STDMETHODIMP _CreateInstanceWithDimensionsAndOpacity(int pixelWidth, int pixelHeight, bool isOpaque, VirtualSurfaceImageSource* *instance);
};

// VirtualSurfaceImageSource
template<typename> struct VirtualSurfaceImageSource_statics {
	static VirtualSurfaceImageSource *activate(int pixelWidth, int pixelHeight) { VirtualSurfaceImageSource *instance; hrcheck(get_activation_factory<VirtualSurfaceImageSource, IVirtualSurfaceImageSourceFactory>()->_CreateInstanceWithDimensions(pixelWidth, pixelHeight, &instance)); return instance; }
	static VirtualSurfaceImageSource *activate(int pixelWidth, int pixelHeight, bool isOpaque) { VirtualSurfaceImageSource *instance; hrcheck(get_activation_factory<VirtualSurfaceImageSource, IVirtualSurfaceImageSourceFactory>()->_CreateInstanceWithDimensionsAndOpacity(pixelWidth, pixelHeight, isOpaque, &instance)); return instance; }
};

template<typename X> struct statics<VirtualSurfaceImageSource, X> : X, Windows::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource_statics<void> {
	using Windows::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource_statics<void>::activate;
	typedef typename X::root_type VirtualSurfaceImageSource;
};
struct VirtualSurfaceImageSource : generate<VirtualSurfaceImageSource> {};

// IWriteableBitmap
struct IWriteableBitmap_raw : IInspectable {
	virtual STDMETHODIMP _get_PixelBuffer(Storage::Streams::IBuffer* *value);
	virtual STDMETHODIMP _Invalidate();
};
template<typename X> struct IWriteableBitmap_adaptor : X {
	union {
		struct : property {
			ptr<Storage::Streams::IBuffer> get() { Storage::Streams::IBuffer* value; hrcheck(enc(&IWriteableBitmap_adaptor::PixelBuffer)->_get_PixelBuffer(&value)); return from_abi(value); }
			ptr<Storage::Streams::IBuffer> operator()() { return get(); }
			operator ptr<Storage::Streams::IBuffer> () { return get(); }
			ptr<Storage::Streams::IBuffer> operator->() { return get(); }
		} PixelBuffer;
	};
	void Invalidate() { hrcheck(X::get()->_Invalidate()); }
	IWriteableBitmap_adaptor() {}
};
template<typename X> struct adapt<IWriteableBitmap, X> : Windows::UI::Xaml::Media::Imaging::IWriteableBitmap_adaptor<X> { typedef adapt IWriteableBitmap; };
struct IWriteableBitmap : IWriteableBitmap_raw, generate<IWriteableBitmap> {};

// IWriteableBitmapFactory
struct IWriteableBitmapFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithDimensions(int pixelWidth, int pixelHeight, WriteableBitmap* *instance);
};

// WriteableBitmap
template<typename> struct WriteableBitmap_statics {
	static WriteableBitmap *activate(int pixelWidth, int pixelHeight) { WriteableBitmap *instance; hrcheck(get_activation_factory<WriteableBitmap, IWriteableBitmapFactory>()->_CreateInstanceWithDimensions(pixelWidth, pixelHeight, &instance)); return instance; }
};

template<typename X> struct statics<WriteableBitmap, X> : X, Windows::UI::Xaml::Media::Imaging::WriteableBitmap_statics<void> {
	using Windows::UI::Xaml::Media::Imaging::WriteableBitmap_statics<void>::activate;
	typedef typename X::root_type WriteableBitmap;
};
struct WriteableBitmap : generate<WriteableBitmap> {};

// ISvgImageSourceFailedEventArgs
struct ISvgImageSourceFailedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(SvgImageSourceLoadStatus *value);
};
template<typename X> struct ISvgImageSourceFailedEventArgs_adaptor : X {
	union {
		struct : property {
			SvgImageSourceLoadStatus get() { SvgImageSourceLoadStatus value; hrcheck(enc(&ISvgImageSourceFailedEventArgs_adaptor::Status)->_get_Status(&value)); return value; }
			SvgImageSourceLoadStatus operator()() { return get(); }
			operator SvgImageSourceLoadStatus () { return get(); }
		} Status;
	};
	ISvgImageSourceFailedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISvgImageSourceFailedEventArgs, X> : Windows::UI::Xaml::Media::Imaging::ISvgImageSourceFailedEventArgs_adaptor<X> { typedef adapt ISvgImageSourceFailedEventArgs; };
struct ISvgImageSourceFailedEventArgs : ISvgImageSourceFailedEventArgs_raw, generate<ISvgImageSourceFailedEventArgs> {};

// SvgImageSourceFailedEventArgs
template<typename X> struct statics<SvgImageSourceFailedEventArgs, X> : X {
	typedef typename X::root_type SvgImageSourceFailedEventArgs;
};
struct SvgImageSourceFailedEventArgs : generate<SvgImageSourceFailedEventArgs> {};

// ISvgImageSourceOpenedEventArgs
struct ISvgImageSourceOpenedEventArgs : IInspectable, generate<ISvgImageSourceOpenedEventArgs> {};

// SvgImageSourceOpenedEventArgs
template<typename X> struct statics<SvgImageSourceOpenedEventArgs, X> : X {
	typedef typename X::root_type SvgImageSourceOpenedEventArgs;
};
struct SvgImageSourceOpenedEventArgs : generate<SvgImageSourceOpenedEventArgs> {};

// IXamlRenderingBackgroundTask
struct IXamlRenderingBackgroundTask : IInspectable, generate<IXamlRenderingBackgroundTask> {};

// IXamlRenderingBackgroundTaskOverrides
struct IXamlRenderingBackgroundTaskOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnRun(ApplicationModel::Background::IBackgroundTaskInstance* taskInstance) = 0;
};
template<typename X> struct IXamlRenderingBackgroundTaskOverrides_adaptor : X {
	void OnRun(pptr<ApplicationModel::Background::IBackgroundTaskInstance> taskInstance) { hrcheck(X::get()->_OnRun(taskInstance)); }
};
template<typename X> struct adapt<IXamlRenderingBackgroundTaskOverrides, X> : Windows::UI::Xaml::Media::Imaging::IXamlRenderingBackgroundTaskOverrides_adaptor<X> { typedef adapt IXamlRenderingBackgroundTaskOverrides; };
template<typename X> struct IXamlRenderingBackgroundTaskOverrides_unadaptor : X {
	STDMETHODIMP _OnRun(ApplicationModel::Background::IBackgroundTaskInstance* taskInstance) { return hrtry([&, this] { X::get()->OnRun(taskInstance); }); }
};
template<typename X> struct unadapt<IXamlRenderingBackgroundTaskOverrides, X> : Windows::UI::Xaml::Media::Imaging::IXamlRenderingBackgroundTaskOverrides_unadaptor<X> {};
struct IXamlRenderingBackgroundTaskOverrides : IXamlRenderingBackgroundTaskOverrides_raw, generate<IXamlRenderingBackgroundTaskOverrides> {};

// IXamlRenderingBackgroundTaskFactory
struct IXamlRenderingBackgroundTaskFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, XamlRenderingBackgroundTask* *instance);
};

// XamlRenderingBackgroundTask
template<typename X> struct statics<XamlRenderingBackgroundTask, X> : X {
	typedef typename X::root_type XamlRenderingBackgroundTask;
};
struct XamlRenderingBackgroundTask : generate<XamlRenderingBackgroundTask> {};

// ISoftwareBitmapSource
struct ISoftwareBitmapSource_raw : IInspectable {
	virtual STDMETHODIMP _SetBitmapAsync(Graphics::Imaging::SoftwareBitmap* softwareBitmap, Foundation::IAsyncAction* *returnValue);
};
template<typename X> struct ISoftwareBitmapSource_adaptor : X {
	ptr<Foundation::IAsyncAction> SetBitmapAsync(pptr<Graphics::Imaging::SoftwareBitmap> softwareBitmap) { Foundation::IAsyncAction* returnValue; hrcheck(X::get()->_SetBitmapAsync(softwareBitmap, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<ISoftwareBitmapSource, X> : Windows::UI::Xaml::Media::Imaging::ISoftwareBitmapSource_adaptor<X> { typedef adapt ISoftwareBitmapSource; };
struct ISoftwareBitmapSource : ISoftwareBitmapSource_raw, generate<ISoftwareBitmapSource> {};

// SoftwareBitmapSource
template<typename X> struct statics<SoftwareBitmapSource, X> : X {
	typedef typename X::root_type SoftwareBitmapSource;
};
struct SoftwareBitmapSource : generate<SoftwareBitmapSource> {};

// ISvgImageSource
struct ISvgImageSource_raw : IInspectable {
	virtual STDMETHODIMP _get_UriSource(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_UriSource(Foundation::Uri* value);
	virtual STDMETHODIMP _get_RasterizePixelWidth(double *value);
	virtual STDMETHODIMP _put_RasterizePixelWidth(double value);
	virtual STDMETHODIMP _get_RasterizePixelHeight(double *value);
	virtual STDMETHODIMP _put_RasterizePixelHeight(double value);
	virtual STDMETHODIMP _add_Opened(Foundation::TypedEventHandler<SvgImageSource*, SvgImageSourceOpenedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Opened(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_OpenFailed(Foundation::TypedEventHandler<SvgImageSource*, SvgImageSourceFailedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_OpenFailed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _SetSourceAsync(Storage::Streams::IRandomAccessStream* streamSource, Foundation::IAsyncOperation<SvgImageSourceLoadStatus>* *returnValue);
};
template<typename X> struct ISvgImageSource_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&ISvgImageSource_adaptor::RasterizePixelHeight)->_get_RasterizePixelHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISvgImageSource_adaptor::RasterizePixelHeight)->_put_RasterizePixelHeight(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} RasterizePixelHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&ISvgImageSource_adaptor::RasterizePixelWidth)->_get_RasterizePixelWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISvgImageSource_adaptor::RasterizePixelWidth)->_put_RasterizePixelWidth(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} RasterizePixelWidth;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&ISvgImageSource_adaptor::UriSource)->_get_UriSource(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&ISvgImageSource_adaptor::UriSource)->_put_UriSource(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} UriSource;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SvgImageSource>, ptr<SvgImageSourceFailedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISvgImageSource_adaptor::OpenFailed)->_add_OpenFailed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISvgImageSource_adaptor::OpenFailed)->_remove_OpenFailed(token)); }
		} OpenFailed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SvgImageSource>, ptr<SvgImageSourceOpenedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISvgImageSource_adaptor::Opened)->_add_Opened(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISvgImageSource_adaptor::Opened)->_remove_Opened(token)); }
		} Opened;
	};
	ptr<Foundation::IAsyncOperation<SvgImageSourceLoadStatus>> SetSourceAsync(pptr<Storage::Streams::IRandomAccessStream> streamSource) { Foundation::IAsyncOperation<SvgImageSourceLoadStatus>* returnValue; hrcheck(X::get()->_SetSourceAsync(streamSource, &returnValue)); return from_abi(returnValue); }
	ISvgImageSource_adaptor() {}
};
template<typename X> struct adapt<ISvgImageSource, X> : Windows::UI::Xaml::Media::Imaging::ISvgImageSource_adaptor<X> { typedef adapt ISvgImageSource; };
struct ISvgImageSource : ISvgImageSource_raw, generate<ISvgImageSource> {};

// ISvgImageSourceFactory
struct ISvgImageSourceFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, SvgImageSource* *instance);
	virtual STDMETHODIMP _CreateInstanceWithUriSource(Foundation::Uri* uriSource, IInspectable* outer, IInspectable* *inner, SvgImageSource* *instance);
};

// ISvgImageSourceStatics
struct ISvgImageSourceStatics : IInspectable {
	virtual STDMETHODIMP _get_UriSourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RasterizePixelWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RasterizePixelHeightProperty(DependencyProperty* *value);
};

// SvgImageSource
template<typename> struct SvgImageSource_statics {
	static struct _RasterizePixelHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SvgImageSource, ISvgImageSourceStatics>()->_get_RasterizePixelHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RasterizePixelHeightProperty;
	static struct _RasterizePixelWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SvgImageSource, ISvgImageSourceStatics>()->_get_RasterizePixelWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RasterizePixelWidthProperty;
	static struct _UriSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SvgImageSource, ISvgImageSourceStatics>()->_get_UriSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} UriSourceProperty;
	static SvgImageSource *activate(object_ref outer, IInspectable* *inner) { SvgImageSource *instance; hrcheck(get_activation_factory<SvgImageSource, ISvgImageSourceFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
	static SvgImageSource *activate(pptr<Foundation::Uri> uriSource, object_ref outer, IInspectable* *inner) { SvgImageSource *instance; hrcheck(get_activation_factory<SvgImageSource, ISvgImageSourceFactory>()->_CreateInstanceWithUriSource(uriSource, outer, inner, &instance)); return instance; }
};
template<typename X> typename SvgImageSource_statics<X>::_RasterizePixelHeightProperty SvgImageSource_statics<X>::RasterizePixelHeightProperty;
template<typename X> typename SvgImageSource_statics<X>::_RasterizePixelWidthProperty SvgImageSource_statics<X>::RasterizePixelWidthProperty;
template<typename X> typename SvgImageSource_statics<X>::_UriSourceProperty SvgImageSource_statics<X>::UriSourceProperty;

template<typename X> struct statics<SvgImageSource, X> : X, Windows::UI::Xaml::Media::Imaging::SvgImageSource_statics<void> {
	using Windows::UI::Xaml::Media::Imaging::SvgImageSource_statics<void>::activate;
	typedef typename X::root_type SvgImageSource;
};
struct SvgImageSource : generate<SvgImageSource> {};
}}}}}
} // namespace iso_winrt
