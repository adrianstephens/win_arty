#pragma once
// generated by isopod tools
// namespaces:
// Windows.System.Threading.Core

#include "Windows.System.Threading.Core.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.System.Threading.0.h"

namespace iso_winrt {

// forward types


// defs

template<> struct def<Windows::System::Threading::Core::ISignalNotifierStatics> : interface_type<> {};
template<> struct def<Windows::System::Threading::Core::ISignalNotifier> : interface_type<> {};
template<> struct def<Windows::System::Threading::Core::SignalNotifier> : class_type<Platform::Object, Windows::System::Threading::Core::ISignalNotifier> {};
template<> struct def<Windows::System::Threading::Core::IPreallocatedWorkItemFactory> : interface_type<> {};
template<> struct def<Windows::System::Threading::Core::IPreallocatedWorkItem> : interface_type<> {};
template<> struct def<Windows::System::Threading::Core::PreallocatedWorkItem> : class_type<Platform::Object, Windows::System::Threading::Core::IPreallocatedWorkItem>, custom_activators {};
template<> struct def<Windows::System::Threading::Core::SignalHandler> : delegate_type {};

// uuids

template<> struct uuid<Windows::System::Threading::Core::ISignalNotifierStatics> { define_guid(0x1C4E4566, 0x8400, 0x46D3, 0xA1, 0x15, 0x7D, 0xC, 0xD, 0xFC, 0x9F, 0x62);};
template<> struct uuid<Windows::System::Threading::Core::ISignalNotifier> { define_guid(0x14285E06, 0x63A7, 0x4713, 0xB6, 0xD9, 0x62, 0xF6, 0x4B, 0x56, 0xFB, 0x8B);};
template<> struct uuid<Windows::System::Threading::Core::IPreallocatedWorkItemFactory> { define_guid(0xE3D32B45, 0xDFEA, 0x469B, 0x82, 0xC5, 0xF6, 0xE3, 0xCE, 0xFD, 0xEA, 0xFB);};
template<> struct uuid<Windows::System::Threading::Core::IPreallocatedWorkItem> { define_guid(0xB6DAA9FC, 0xBC5B, 0x401A, 0xA8, 0xB2, 0x6E, 0x75, 0x4D, 0x14, 0xDA, 0xA6);};
template<> struct uuid<Windows::System::Threading::Core::SignalHandler> { define_guid(0x923C402E, 0x4721, 0x440E, 0x9D, 0xDA, 0x55, 0xB6, 0xF2, 0xE0, 0x77, 0x10);};

// types

namespace Windows { namespace System { namespace Threading { namespace Core {

// ISignalNotifierStatics
struct ISignalNotifierStatics : IInspectable {
	virtual STDMETHODIMP _AttachToEvent(HSTRING name, SignalHandler* handler, SignalNotifier* *signalNotifier);
	virtual STDMETHODIMP _AttachToEventWithTimeout(HSTRING name, SignalHandler* handler, Foundation::TimeSpan timeout, SignalNotifier* *signalNotifier);
	virtual STDMETHODIMP _AttachToSemaphore(HSTRING name, SignalHandler* handler, SignalNotifier* *signalNotifier);
	virtual STDMETHODIMP _AttachToSemaphoreWithTimeout(HSTRING name, SignalHandler* handler, Foundation::TimeSpan timeout, SignalNotifier* *signalNotifier);
};

// ISignalNotifier
struct ISignalNotifier_raw : IInspectable {
	virtual STDMETHODIMP _Enable();
	virtual STDMETHODIMP _Terminate();
};
template<typename X> struct ISignalNotifier_adaptor : X {
	void Enable() { hrcheck(X::get()->_Enable()); }
	void Terminate() { hrcheck(X::get()->_Terminate()); }
};
template<typename X> struct adapt<ISignalNotifier, X> : Windows::System::Threading::Core::ISignalNotifier_adaptor<X> { typedef adapt ISignalNotifier; };
struct ISignalNotifier : ISignalNotifier_raw, generate<ISignalNotifier> {};

// SignalNotifier
template<typename> struct SignalNotifier_statics {
	static ptr<SignalNotifier> AttachToEvent(hstring_ref name, handler_ref<SignalHandler> handler) { SignalNotifier* signalNotifier; hrcheck(get_activation_factory<SignalNotifier, ISignalNotifierStatics>()->_AttachToEvent(name, handler, &signalNotifier)); return from_abi(signalNotifier); }
	static ptr<SignalNotifier> AttachToEvent(hstring_ref name, handler_ref<SignalHandler> handler, const Foundation::TimeSpan& timeout) { SignalNotifier* signalNotifier; hrcheck(get_activation_factory<SignalNotifier, ISignalNotifierStatics>()->_AttachToEventWithTimeout(name, handler, timeout, &signalNotifier)); return from_abi(signalNotifier); }
	static ptr<SignalNotifier> AttachToSemaphore(hstring_ref name, handler_ref<SignalHandler> handler) { SignalNotifier* signalNotifier; hrcheck(get_activation_factory<SignalNotifier, ISignalNotifierStatics>()->_AttachToSemaphore(name, handler, &signalNotifier)); return from_abi(signalNotifier); }
	static ptr<SignalNotifier> AttachToSemaphore(hstring_ref name, handler_ref<SignalHandler> handler, const Foundation::TimeSpan& timeout) { SignalNotifier* signalNotifier; hrcheck(get_activation_factory<SignalNotifier, ISignalNotifierStatics>()->_AttachToSemaphoreWithTimeout(name, handler, timeout, &signalNotifier)); return from_abi(signalNotifier); }
};

template<typename X> struct statics<SignalNotifier, X> : X, Windows::System::Threading::Core::SignalNotifier_statics<void> {
	typedef typename X::root_type SignalNotifier;
};
struct SignalNotifier : generate<SignalNotifier> {};

// IPreallocatedWorkItemFactory
struct IPreallocatedWorkItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateWorkItem(WorkItemHandler* handler, PreallocatedWorkItem* *workItem);
	virtual STDMETHODIMP _CreateWorkItemWithPriority(WorkItemHandler* handler, WorkItemPriority priority, PreallocatedWorkItem* *WorkItem);
	virtual STDMETHODIMP _CreateWorkItemWithPriorityAndOptions(WorkItemHandler* handler, WorkItemPriority priority, WorkItemOptions options, PreallocatedWorkItem* *WorkItem);
};

// IPreallocatedWorkItem
struct IPreallocatedWorkItem_raw : IInspectable {
	virtual STDMETHODIMP _RunAsync(Foundation::IAsyncAction* *operation);
};
template<typename X> struct IPreallocatedWorkItem_adaptor : X {
	ptr<Foundation::IAsyncAction> RunAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_RunAsync(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IPreallocatedWorkItem, X> : Windows::System::Threading::Core::IPreallocatedWorkItem_adaptor<X> { typedef adapt IPreallocatedWorkItem; };
struct IPreallocatedWorkItem : IPreallocatedWorkItem_raw, generate<IPreallocatedWorkItem> {};

// PreallocatedWorkItem
template<typename> struct PreallocatedWorkItem_statics {
	static PreallocatedWorkItem *activate(handler_ref<WorkItemHandler> handler) { PreallocatedWorkItem *workItem; hrcheck(get_activation_factory<PreallocatedWorkItem, IPreallocatedWorkItemFactory>()->_CreateWorkItem(handler, &workItem)); return workItem; }
	static PreallocatedWorkItem *activate(handler_ref<WorkItemHandler> handler, WorkItemPriority priority) { PreallocatedWorkItem *WorkItem; hrcheck(get_activation_factory<PreallocatedWorkItem, IPreallocatedWorkItemFactory>()->_CreateWorkItemWithPriority(handler, priority, &WorkItem)); return WorkItem; }
	static PreallocatedWorkItem *activate(handler_ref<WorkItemHandler> handler, WorkItemPriority priority, WorkItemOptions options) { PreallocatedWorkItem *WorkItem; hrcheck(get_activation_factory<PreallocatedWorkItem, IPreallocatedWorkItemFactory>()->_CreateWorkItemWithPriorityAndOptions(handler, priority, options, &WorkItem)); return WorkItem; }
};

template<typename X> struct statics<PreallocatedWorkItem, X> : X, Windows::System::Threading::Core::PreallocatedWorkItem_statics<void> {
	using Windows::System::Threading::Core::PreallocatedWorkItem_statics<void>::activate;
	typedef typename X::root_type PreallocatedWorkItem;
};
struct PreallocatedWorkItem : generate<PreallocatedWorkItem> {};

// SignalHandler
struct SignalHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(SignalNotifier* signalNotifier, bool timedOut) = 0;
};
}}}}
} // namespace iso_winrt
