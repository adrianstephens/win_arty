#pragma once
// generated by isopod tools
// namespaces:
// Windows.Media

#include "Windows.Media.0.h"
#include "Windows.Graphics.Imaging.0.h"
#include "Windows.Graphics.DirectX.0.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace ApplicationModel { namespace AppService {
struct AppServiceConnection;
}}
namespace Foundation { namespace Collections {
template<typename T> struct IVector;
template<typename T> struct IVectorView;
struct ValueSet;
struct IPropertySet;
}}
namespace Graphics { namespace DirectX { namespace Direct3D11 {
struct IDirect3DDevice;
struct IDirect3DSurface;
}}}
namespace Storage { namespace Streams {
struct RandomAccessStreamReference;
}
struct StorageFile;
}}

// defs

template<> struct def<Windows::Media::IMediaProcessingTriggerDetails> : interface_type<> {};
template<> struct def<Windows::Media::MediaProcessingTriggerDetails> : class_type<Platform::Object, Windows::Media::IMediaProcessingTriggerDetails> {};
template<> struct def<Windows::Media::IMediaFrame> : overridable_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Media::IVideoFrame> : interface_type<Windows::Media::IMediaFrame> {};
template<> struct def<Windows::Media::IVideoFrameStatics> : interface_type<> {};
template<> struct def<Windows::Media::IVideoFrameFactory> : interface_type<> {};
template<> struct def<Windows::Media::IVideoFrame2> : interface_type<> {};
template<> struct def<Windows::Media::VideoFrame> : class_type<Platform::Object, Windows::Media::IVideoFrame, Windows::Media::IVideoFrame2>, custom_activators {};
template<> struct def<Windows::Media::AudioBufferAccessMode> : enum_type<int> {};
template<> struct def<Windows::Media::IAudioFrame> : interface_type<Windows::Media::IMediaFrame> {};
template<> struct def<Windows::Media::IAudioBuffer> : interface_type<Windows::Foundation::IMemoryBuffer, Windows::Foundation::IClosable> {};
template<> struct def<Windows::Media::AudioBuffer> : class_type<Platform::Object, Windows::Media::IAudioBuffer> {};
template<> struct def<Windows::Media::IAudioFrameFactory> : interface_type<> {};
template<> struct def<Windows::Media::AudioFrame> : class_type<Platform::Object, Windows::Media::IAudioFrame>, custom_activators {};
template<> struct def<Windows::Media::SoundLevel> : enum_type<int> {};
template<> struct def<Windows::Media::IMediaMarker> : overridable_type<> {};
template<> struct def<Windows::Media::IMediaMarkers> : overridable_type<> {};
template<> struct def<Windows::Media::IMediaMarkerTypesStatics> : interface_type<> {};
template<> struct def<Windows::Media::MediaMarkerTypes> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Media::MediaPlaybackType> : enum_type<int> {};
template<> struct def<Windows::Media::MediaPlaybackAutoRepeatMode> : enum_type<int> {};
template<> struct def<Windows::Media::ISystemMediaTransportControlsTimelineProperties> : interface_type<> {};
template<> struct def<Windows::Media::SystemMediaTransportControlsTimelineProperties> : class_type<Platform::Object, Windows::Media::ISystemMediaTransportControlsTimelineProperties> {};
template<> struct def<Windows::Media::IMusicDisplayProperties> : interface_type<> {};
template<> struct def<Windows::Media::IMusicDisplayProperties2> : interface_type<> {};
template<> struct def<Windows::Media::IMusicDisplayProperties3> : interface_type<> {};
template<> struct def<Windows::Media::MusicDisplayProperties> : class_type<Platform::Object, Windows::Media::IMusicDisplayProperties, Windows::Media::IMusicDisplayProperties2, Windows::Media::IMusicDisplayProperties3> {};
template<> struct def<Windows::Media::IVideoDisplayProperties> : interface_type<> {};
template<> struct def<Windows::Media::IVideoDisplayProperties2> : interface_type<> {};
template<> struct def<Windows::Media::VideoDisplayProperties> : class_type<Platform::Object, Windows::Media::IVideoDisplayProperties, Windows::Media::IVideoDisplayProperties2> {};
template<> struct def<Windows::Media::IImageDisplayProperties> : interface_type<> {};
template<> struct def<Windows::Media::ImageDisplayProperties> : class_type<Platform::Object, Windows::Media::IImageDisplayProperties> {};
template<> struct def<Windows::Media::ISystemMediaTransportControlsDisplayUpdater> : interface_type<> {};
template<> struct def<Windows::Media::SystemMediaTransportControlsDisplayUpdater> : class_type<Platform::Object, Windows::Media::ISystemMediaTransportControlsDisplayUpdater> {};
template<> struct def<Windows::Media::MediaPlaybackStatus> : enum_type<int> {};
template<> struct def<Windows::Media::SystemMediaTransportControlsButton> : enum_type<int> {};
template<> struct def<Windows::Media::SystemMediaTransportControlsProperty> : enum_type<int> {};
template<> struct def<Windows::Media::ISystemMediaTransportControlsButtonPressedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::SystemMediaTransportControlsButtonPressedEventArgs> : class_type<Platform::Object, Windows::Media::ISystemMediaTransportControlsButtonPressedEventArgs> {};
template<> struct def<Windows::Media::ISystemMediaTransportControlsPropertyChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::SystemMediaTransportControlsPropertyChangedEventArgs> : class_type<Platform::Object, Windows::Media::ISystemMediaTransportControlsPropertyChangedEventArgs> {};
template<> struct def<Windows::Media::IPlaybackPositionChangeRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::PlaybackPositionChangeRequestedEventArgs> : class_type<Platform::Object, Windows::Media::IPlaybackPositionChangeRequestedEventArgs> {};
template<> struct def<Windows::Media::IPlaybackRateChangeRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::PlaybackRateChangeRequestedEventArgs> : class_type<Platform::Object, Windows::Media::IPlaybackRateChangeRequestedEventArgs> {};
template<> struct def<Windows::Media::IShuffleEnabledChangeRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::ShuffleEnabledChangeRequestedEventArgs> : class_type<Platform::Object, Windows::Media::IShuffleEnabledChangeRequestedEventArgs> {};
template<> struct def<Windows::Media::IAutoRepeatModeChangeRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::AutoRepeatModeChangeRequestedEventArgs> : class_type<Platform::Object, Windows::Media::IAutoRepeatModeChangeRequestedEventArgs> {};
template<> struct def<Windows::Media::ISystemMediaTransportControls> : interface_type<> {};
template<> struct def<Windows::Media::ISystemMediaTransportControlsStatics> : interface_type<> {};
template<> struct def<Windows::Media::ISystemMediaTransportControls2> : interface_type<> {};
template<> struct def<Windows::Media::SystemMediaTransportControls> : class_type<Platform::Object, Windows::Media::ISystemMediaTransportControls, Windows::Media::ISystemMediaTransportControls2> {};
template<> struct def<Windows::Media::MediaTimelineControllerState> : enum_type<int> {};
template<> struct def<Windows::Media::IMediaTimelineController> : interface_type<> {};
template<> struct def<Windows::Media::IMediaTimelineController2> : interface_type<> {};
template<> struct def<Windows::Media::MediaTimelineController> : class_type<Platform::Object, Windows::Media::IMediaTimelineController, Windows::Media::IMediaTimelineController2> {};
template<> struct def<Windows::Media::IMediaTimelineControllerFailedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::MediaTimelineControllerFailedEventArgs> : class_type<Platform::Object, Windows::Media::IMediaTimelineControllerFailedEventArgs> {};
template<> struct def<Windows::Media::AudioProcessing> : enum_type<int> {};
template<> struct def<Windows::Media::MediaTimeRange> : value_type<Windows::Foundation::TimeSpan, Windows::Foundation::TimeSpan> {};
template<> struct def<Windows::Media::IMediaExtension> : overridable_type<> {};
template<> struct def<Windows::Media::IMediaExtensionManager> : interface_type<> {};
template<> struct def<Windows::Media::IMediaExtensionManager2> : interface_type<Windows::Media::IMediaExtensionManager> {};
template<> struct def<Windows::Media::MediaExtensionManager> : class_type<Platform::Object, Windows::Media::IMediaExtensionManager, Windows::Media::IMediaExtensionManager2> {};
template<> struct def<Windows::Media::IVideoEffectsStatics> : interface_type<> {};
template<> struct def<Windows::Media::VideoEffects> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Media::MediaControlContract> : value_type<> {};
template<> struct def<Windows::Media::IMediaControl> : interface_type<> {};
template<> struct def<Windows::Media::MediaControl> : class_type<Platform::Object, Platform::Object> {};

// uuids

template<> struct uuid<Windows::Media::IMediaProcessingTriggerDetails> { define_guid(0xEB8564AC, 0xA351, 0x4F4E, 0xB4, 0xF0, 0x9B, 0xF2, 0x40, 0x89, 0x93, 0xDB);};
template<> struct uuid<Windows::Media::IMediaFrame> { define_guid(0xBFB52F8C, 0x5943, 0x47D8, 0x8E, 0x10, 0x5, 0x30, 0x8A, 0xA5, 0xFB, 0xD0);};
template<> struct uuid<Windows::Media::IVideoFrame> { define_guid(0xCC06625, 0x90FC, 0x4C92, 0xBD, 0x95, 0x7D, 0xED, 0x21, 0x81, 0x9D, 0x1C);};
template<> struct uuid<Windows::Media::IVideoFrameStatics> { define_guid(0xAB2A556F, 0x6111, 0x4B33, 0x8E, 0xC3, 0x2B, 0x20, 0x9A, 0x2, 0xE1, 0x7A);};
template<> struct uuid<Windows::Media::IVideoFrameFactory> { define_guid(0x14B6D69, 0x2228, 0x4C92, 0x92, 0xFF, 0x50, 0xC3, 0x80, 0xD3, 0xE7, 0x76);};
template<> struct uuid<Windows::Media::IVideoFrame2> { define_guid(0x3837840D, 0x336C, 0x4366, 0x8D, 0x46, 0x6, 0x7, 0x98, 0x73, 0x6C, 0x5D);};
template<> struct uuid<Windows::Media::IAudioFrame> { define_guid(0xE36AC304, 0xAAB2, 0x4277, 0x9E, 0xD0, 0x43, 0xCE, 0xDF, 0x8E, 0x29, 0xC6);};
template<> struct uuid<Windows::Media::IAudioBuffer> { define_guid(0x35175827, 0x724B, 0x4C6A, 0xB1, 0x30, 0xF6, 0x53, 0x7F, 0x9A, 0xE0, 0xD0);};
template<> struct uuid<Windows::Media::IAudioFrameFactory> { define_guid(0x91A90ADE, 0x2422, 0x40A6, 0xB9, 0xAD, 0x30, 0xD0, 0x24, 0x4, 0x31, 0x7D);};
template<> struct uuid<Windows::Media::IMediaMarker> { define_guid(0x1803DEF8, 0xDCA5, 0x4B6F, 0x9C, 0x20, 0xE3, 0xD3, 0xC0, 0x64, 0x36, 0x25);};
template<> struct uuid<Windows::Media::IMediaMarkers> { define_guid(0xAFEAB189, 0xF8DD, 0x466E, 0xAA, 0x10, 0x92, 0xB, 0x52, 0x35, 0x3F, 0xDF);};
template<> struct uuid<Windows::Media::IMediaMarkerTypesStatics> { define_guid(0xBB198040, 0x482F, 0x4743, 0x88, 0x32, 0x45, 0x85, 0x38, 0x21, 0xEC, 0xE0);};
template<> struct uuid<Windows::Media::ISystemMediaTransportControlsTimelineProperties> { define_guid(0x5125316A, 0xC3A2, 0x475B, 0x85, 0x7, 0x93, 0x53, 0x4D, 0xC8, 0x8F, 0x15);};
template<> struct uuid<Windows::Media::IMusicDisplayProperties> { define_guid(0x6BBF0C59, 0xD0A0, 0x4D26, 0x92, 0xA0, 0xF9, 0x78, 0xE1, 0xD1, 0x8E, 0x7B);};
template<> struct uuid<Windows::Media::IMusicDisplayProperties2> { define_guid(0x368462, 0x97D3, 0x44B9, 0xB0, 0xF, 0x0, 0x8A, 0xFC, 0xEF, 0xAF, 0x18);};
template<> struct uuid<Windows::Media::IMusicDisplayProperties3> { define_guid(0x4DB51AC1, 0x681, 0x4E8C, 0x94, 0x1, 0xB8, 0x15, 0x9D, 0x9E, 0xEF, 0xC7);};
template<> struct uuid<Windows::Media::IVideoDisplayProperties> { define_guid(0x5609FDB1, 0x5D2D, 0x4872, 0x81, 0x70, 0x45, 0xDE, 0xE5, 0xBC, 0x2F, 0x5C);};
template<> struct uuid<Windows::Media::IVideoDisplayProperties2> { define_guid(0xB410E1CE, 0xAB52, 0x41AB, 0xA4, 0x86, 0xCC, 0x10, 0xFA, 0xB1, 0x52, 0xF9);};
template<> struct uuid<Windows::Media::IImageDisplayProperties> { define_guid(0xCD0BC7EF, 0x54E7, 0x411F, 0x99, 0x33, 0xF0, 0xE9, 0x8B, 0xA, 0x96, 0xD2);};
template<> struct uuid<Windows::Media::ISystemMediaTransportControlsDisplayUpdater> { define_guid(0x8ABBC53E, 0xFA55, 0x4ECF, 0xAD, 0x8E, 0xC9, 0x84, 0xE5, 0xDD, 0x15, 0x50);};
template<> struct uuid<Windows::Media::ISystemMediaTransportControlsButtonPressedEventArgs> { define_guid(0xB7F47116, 0xA56F, 0x4DC8, 0x9E, 0x11, 0x92, 0x3, 0x1F, 0x4A, 0x87, 0xC2);};
template<> struct uuid<Windows::Media::ISystemMediaTransportControlsPropertyChangedEventArgs> { define_guid(0xD0CA0936, 0x339B, 0x4CB3, 0x8E, 0xEB, 0x73, 0x76, 0x7, 0xF5, 0x6E, 0x8);};
template<> struct uuid<Windows::Media::IPlaybackPositionChangeRequestedEventArgs> { define_guid(0xB4493F88, 0xEB28, 0x4961, 0x9C, 0x14, 0x33, 0x5E, 0x44, 0xF3, 0xE1, 0x25);};
template<> struct uuid<Windows::Media::IPlaybackRateChangeRequestedEventArgs> { define_guid(0x2CE2C41F, 0x3CD6, 0x4F77, 0x9B, 0xA7, 0xEB, 0x27, 0xC2, 0x6A, 0x21, 0x40);};
template<> struct uuid<Windows::Media::IShuffleEnabledChangeRequestedEventArgs> { define_guid(0x49B593FE, 0x4FD0, 0x4666, 0xA3, 0x14, 0xC0, 0xE0, 0x19, 0x40, 0xD3, 0x2);};
template<> struct uuid<Windows::Media::IAutoRepeatModeChangeRequestedEventArgs> { define_guid(0xEA137EFA, 0xD852, 0x438E, 0x88, 0x2B, 0xC9, 0x90, 0x10, 0x9A, 0x78, 0xF4);};
template<> struct uuid<Windows::Media::ISystemMediaTransportControls> { define_guid(0x99FA3FF4, 0x1742, 0x42A6, 0x90, 0x2E, 0x8, 0x7D, 0x41, 0xF9, 0x65, 0xEC);};
template<> struct uuid<Windows::Media::ISystemMediaTransportControlsStatics> { define_guid(0x43BA380A, 0xECA4, 0x4832, 0x91, 0xAB, 0xD4, 0x15, 0xFA, 0xE4, 0x84, 0xC6);};
template<> struct uuid<Windows::Media::ISystemMediaTransportControls2> { define_guid(0xEA98D2F6, 0x7F3C, 0x4AF2, 0xA5, 0x86, 0x72, 0x88, 0x98, 0x8, 0xEF, 0xB1);};
template<> struct uuid<Windows::Media::IMediaTimelineController> { define_guid(0x8ED361F3, 0xB78, 0x4360, 0xBF, 0x71, 0xC, 0x84, 0x19, 0x99, 0xEA, 0x1B);};
template<> struct uuid<Windows::Media::IMediaTimelineController2> { define_guid(0xEF74EA38, 0x9E72, 0x4DF9, 0x83, 0x55, 0x6E, 0x90, 0xC8, 0x1B, 0xBA, 0xDD);};
template<> struct uuid<Windows::Media::IMediaTimelineControllerFailedEventArgs> { define_guid(0x8821F81D, 0x3E77, 0x43FB, 0xBE, 0x26, 0x4F, 0xC8, 0x7A, 0x4, 0x48, 0x34);};
template<> struct uuid<Windows::Media::IMediaExtension> { define_guid(0x7915118, 0x45DF, 0x442B, 0x8A, 0x3F, 0xF7, 0x82, 0x6A, 0x63, 0x70, 0xAB);};
template<> struct uuid<Windows::Media::IMediaExtensionManager> { define_guid(0x4A25EAF5, 0x242D, 0x4DFB, 0x97, 0xF4, 0x69, 0xB7, 0xC4, 0x25, 0x76, 0xFF);};
template<> struct uuid<Windows::Media::IMediaExtensionManager2> { define_guid(0x5BCEBF47, 0x4043, 0x4FED, 0xAC, 0xAF, 0x54, 0xEC, 0x29, 0xDF, 0xB1, 0xF7);};
template<> struct uuid<Windows::Media::IVideoEffectsStatics> { define_guid(0x1FCDA5E8, 0xBAF1, 0x4521, 0x98, 0xC, 0x3B, 0xCE, 0xBB, 0x44, 0xCF, 0x38);};
template<> struct uuid<Windows::Media::IMediaControl> { define_guid(0x98F1FBE1, 0x7A8D, 0x42CB, 0xB6, 0xFE, 0x8F, 0xE6, 0x98, 0x26, 0x4F, 0x13);};

// types

namespace Windows { namespace Media {

// IMediaProcessingTriggerDetails
struct IMediaProcessingTriggerDetails_raw : IInspectable {
	virtual STDMETHODIMP _get_Arguments(Foundation::Collections::ValueSet* *value);
};
template<typename X> struct IMediaProcessingTriggerDetails_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::ValueSet> get() { Foundation::Collections::ValueSet* value; hrcheck(enc(&IMediaProcessingTriggerDetails_adaptor::Arguments)->_get_Arguments(&value)); return from_abi(value); }
			ptr<Foundation::Collections::ValueSet> operator()() { return get(); }
			operator ptr<Foundation::Collections::ValueSet> () { return get(); }
			ptr<Foundation::Collections::ValueSet> operator->() { return get(); }
		} Arguments;
	};
	IMediaProcessingTriggerDetails_adaptor() {}
};
template<typename X> struct adapt<IMediaProcessingTriggerDetails, X> : Windows::Media::IMediaProcessingTriggerDetails_adaptor<X> { typedef adapt IMediaProcessingTriggerDetails; };
struct IMediaProcessingTriggerDetails : IMediaProcessingTriggerDetails_raw, generate<IMediaProcessingTriggerDetails> {};

// MediaProcessingTriggerDetails
template<typename X> struct statics<MediaProcessingTriggerDetails, X> : X {
	typedef typename X::root_type MediaProcessingTriggerDetails;
};
struct MediaProcessingTriggerDetails : generate<MediaProcessingTriggerDetails> {};

// IMediaFrame
struct IMediaFrame_raw : IInspectable {
	virtual STDMETHODIMP _get_Type(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_IsReadOnly(bool *value) = 0;
	virtual STDMETHODIMP _put_RelativeTime(Foundation::IReference<Foundation::TimeSpan>* value) = 0;
	virtual STDMETHODIMP _get_RelativeTime(Foundation::IReference<Foundation::TimeSpan>* *value) = 0;
	virtual STDMETHODIMP _put_SystemRelativeTime(Foundation::IReference<Foundation::TimeSpan>* value) = 0;
	virtual STDMETHODIMP _get_SystemRelativeTime(Foundation::IReference<Foundation::TimeSpan>* *value) = 0;
	virtual STDMETHODIMP _put_Duration(Foundation::IReference<Foundation::TimeSpan>* value) = 0;
	virtual STDMETHODIMP _get_Duration(Foundation::IReference<Foundation::TimeSpan>* *value) = 0;
	virtual STDMETHODIMP _put_IsDiscontinuous(bool value) = 0;
	virtual STDMETHODIMP _get_IsDiscontinuous(bool *value) = 0;
	virtual STDMETHODIMP _get_ExtendedProperties(Foundation::Collections::IPropertySet* *value) = 0;
};
template<typename X> struct IMediaFrame_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IMediaFrame_adaptor::Duration)->_get_Duration(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&IMediaFrame_adaptor::Duration)->_put_Duration(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} Duration;
		struct : property {
			ptr<Foundation::Collections::IPropertySet> get() { Foundation::Collections::IPropertySet* value; hrcheck(enc(&IMediaFrame_adaptor::ExtendedProperties)->_get_ExtendedProperties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IPropertySet> operator()() { return get(); }
			operator ptr<Foundation::Collections::IPropertySet> () { return get(); }
			ptr<Foundation::Collections::IPropertySet> operator->() { return get(); }
		} ExtendedProperties;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaFrame_adaptor::IsDiscontinuous)->_get_IsDiscontinuous(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaFrame_adaptor::IsDiscontinuous)->_put_IsDiscontinuous(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsDiscontinuous;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaFrame_adaptor::IsReadOnly)->_get_IsReadOnly(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsReadOnly;
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IMediaFrame_adaptor::RelativeTime)->_get_RelativeTime(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&IMediaFrame_adaptor::RelativeTime)->_put_RelativeTime(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} RelativeTime;
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IMediaFrame_adaptor::SystemRelativeTime)->_get_SystemRelativeTime(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&IMediaFrame_adaptor::SystemRelativeTime)->_put_SystemRelativeTime(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} SystemRelativeTime;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMediaFrame_adaptor::Type)->_get_Type(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Type;
	};
	IMediaFrame_adaptor() {}
};
template<typename X> struct adapt<IMediaFrame, X> : Windows::Media::IMediaFrame_adaptor<X> { typedef adapt IMediaFrame; };
template<typename X> struct IMediaFrame_unadaptor : X {
	STDMETHODIMP _get_Type(HSTRING *value) { return hrtry([&, this] { get_prop(value, Type); }); }
	STDMETHODIMP _get_IsReadOnly(bool *value) { return hrtry([&, this] { get_prop(value, IsReadOnly); }); }
	STDMETHODIMP _put_RelativeTime(Foundation::IReference<Foundation::TimeSpan>* value) { return hrtry([&, this] { put_prop(value, RelativeTime); }); }
	STDMETHODIMP _get_RelativeTime(Foundation::IReference<Foundation::TimeSpan>* *value) { return hrtry([&, this] { get_prop(value, RelativeTime); }); }
	STDMETHODIMP _put_SystemRelativeTime(Foundation::IReference<Foundation::TimeSpan>* value) { return hrtry([&, this] { put_prop(value, SystemRelativeTime); }); }
	STDMETHODIMP _get_SystemRelativeTime(Foundation::IReference<Foundation::TimeSpan>* *value) { return hrtry([&, this] { get_prop(value, SystemRelativeTime); }); }
	STDMETHODIMP _put_Duration(Foundation::IReference<Foundation::TimeSpan>* value) { return hrtry([&, this] { put_prop(value, Duration); }); }
	STDMETHODIMP _get_Duration(Foundation::IReference<Foundation::TimeSpan>* *value) { return hrtry([&, this] { get_prop(value, Duration); }); }
	STDMETHODIMP _put_IsDiscontinuous(bool value) { return hrtry([&, this] { put_prop(value, IsDiscontinuous); }); }
	STDMETHODIMP _get_IsDiscontinuous(bool *value) { return hrtry([&, this] { get_prop(value, IsDiscontinuous); }); }
	STDMETHODIMP _get_ExtendedProperties(Foundation::Collections::IPropertySet* *value) { return hrtry([&, this] { get_prop(value, ExtendedProperties); }); }
};
template<typename X> struct unadapt<IMediaFrame, X> : Windows::Media::IMediaFrame_unadaptor<X> {};
struct IMediaFrame : IMediaFrame_raw, generate<IMediaFrame> {};

// IVideoFrame
struct IVideoFrame_raw : IInspectable {
	virtual STDMETHODIMP _get_SoftwareBitmap(Graphics::Imaging::SoftwareBitmap* *value);
	virtual STDMETHODIMP _CopyToAsync(VideoFrame* frame, Foundation::IAsyncAction* *value);
	virtual STDMETHODIMP _get_Direct3DSurface(Graphics::DirectX::Direct3D11::IDirect3DSurface* *value);
};
template<typename X> struct IVideoFrame_adaptor : X {
	union {
		struct : property {
			ptr<Graphics::DirectX::Direct3D11::IDirect3DSurface> get() { Graphics::DirectX::Direct3D11::IDirect3DSurface* value; hrcheck(enc(&IVideoFrame_adaptor::Direct3DSurface)->_get_Direct3DSurface(&value)); return from_abi(value); }
			ptr<Graphics::DirectX::Direct3D11::IDirect3DSurface> operator()() { return get(); }
			operator ptr<Graphics::DirectX::Direct3D11::IDirect3DSurface> () { return get(); }
			ptr<Graphics::DirectX::Direct3D11::IDirect3DSurface> operator->() { return get(); }
		} Direct3DSurface;
		struct : property {
			ptr<Graphics::Imaging::SoftwareBitmap> get() { Graphics::Imaging::SoftwareBitmap* value; hrcheck(enc(&IVideoFrame_adaptor::SoftwareBitmap)->_get_SoftwareBitmap(&value)); return from_abi(value); }
			ptr<Graphics::Imaging::SoftwareBitmap> operator()() { return get(); }
			operator ptr<Graphics::Imaging::SoftwareBitmap> () { return get(); }
			ptr<Graphics::Imaging::SoftwareBitmap> operator->() { return get(); }
		} SoftwareBitmap;
	};
	ptr<Foundation::IAsyncAction> CopyToAsync(pptr<VideoFrame> frame) { Foundation::IAsyncAction* value; hrcheck(X::get()->_CopyToAsync(frame, &value)); return from_abi(value); }
	IVideoFrame_adaptor() {}
};
template<typename X> struct adapt<IVideoFrame, X> : Windows::Media::IVideoFrame_adaptor<X> { typedef adapt IVideoFrame; };
struct IVideoFrame : IVideoFrame_raw, generate<IVideoFrame> {};

// IVideoFrameStatics
struct IVideoFrameStatics : IInspectable {
	virtual STDMETHODIMP _CreateAsDirect3D11SurfaceBacked(Graphics::DirectX::DirectXPixelFormat format, int width, int height, VideoFrame* *result);
	virtual STDMETHODIMP _CreateAsDirect3D11SurfaceBackedWithDevice(Graphics::DirectX::DirectXPixelFormat format, int width, int height, Graphics::DirectX::Direct3D11::IDirect3DDevice* device, VideoFrame* *result);
	virtual STDMETHODIMP _CreateWithSoftwareBitmap(Graphics::Imaging::SoftwareBitmap* bitmap, VideoFrame* *result);
	virtual STDMETHODIMP _CreateWithDirect3D11Surface(Graphics::DirectX::Direct3D11::IDirect3DSurface* surface, VideoFrame* *result);
};

// IVideoFrameFactory
struct IVideoFrameFactory : IInspectable {
	virtual STDMETHODIMP _Create(Graphics::Imaging::BitmapPixelFormat format, int width, int height, VideoFrame* *value);
	virtual STDMETHODIMP _CreateWithAlpha(Graphics::Imaging::BitmapPixelFormat format, int width, int height, Graphics::Imaging::BitmapAlphaMode alpha, VideoFrame* *value);
};

// IVideoFrame2
struct IVideoFrame2_raw : IInspectable {
	virtual STDMETHODIMP _CopyToWithBoundsAsync(VideoFrame* frame, Foundation::IReference<Graphics::Imaging::BitmapBounds>* sourceBounds, Foundation::IReference<Graphics::Imaging::BitmapBounds>* destinationBounds, Foundation::IAsyncAction* *operation);
};
template<typename X> struct IVideoFrame2_adaptor : X {
	ptr<Foundation::IAsyncAction> CopyToAsync(pptr<VideoFrame> frame, pptr<Foundation::IReference<Graphics::Imaging::BitmapBounds>> sourceBounds, pptr<Foundation::IReference<Graphics::Imaging::BitmapBounds>> destinationBounds) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_CopyToWithBoundsAsync(frame, to_abi(sourceBounds), to_abi(destinationBounds), &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IVideoFrame2, X> : Windows::Media::IVideoFrame2_adaptor<X> { typedef adapt IVideoFrame2; };
struct IVideoFrame2 : IVideoFrame2_raw, generate<IVideoFrame2> {};

// VideoFrame
template<typename> struct VideoFrame_statics {
	static ptr<VideoFrame> CreateAsDirect3D11SurfaceBacked(Graphics::DirectX::DirectXPixelFormat format, int width, int height) { VideoFrame* result; hrcheck(get_activation_factory<VideoFrame, IVideoFrameStatics>()->_CreateAsDirect3D11SurfaceBacked(format, width, height, &result)); return from_abi(result); }
	static ptr<VideoFrame> CreateAsDirect3D11SurfaceBacked(Graphics::DirectX::DirectXPixelFormat format, int width, int height, pptr<Graphics::DirectX::Direct3D11::IDirect3DDevice> device) { VideoFrame* result; hrcheck(get_activation_factory<VideoFrame, IVideoFrameStatics>()->_CreateAsDirect3D11SurfaceBackedWithDevice(format, width, height, device, &result)); return from_abi(result); }
	static ptr<VideoFrame> CreateWithSoftwareBitmap(pptr<Graphics::Imaging::SoftwareBitmap> bitmap) { VideoFrame* result; hrcheck(get_activation_factory<VideoFrame, IVideoFrameStatics>()->_CreateWithSoftwareBitmap(bitmap, &result)); return from_abi(result); }
	static ptr<VideoFrame> CreateWithDirect3D11Surface(pptr<Graphics::DirectX::Direct3D11::IDirect3DSurface> surface) { VideoFrame* result; hrcheck(get_activation_factory<VideoFrame, IVideoFrameStatics>()->_CreateWithDirect3D11Surface(surface, &result)); return from_abi(result); }
	static VideoFrame *activate(Graphics::Imaging::BitmapPixelFormat format, int width, int height) { VideoFrame *value; hrcheck(get_activation_factory<VideoFrame, IVideoFrameFactory>()->_Create(format, width, height, &value)); return value; }
	static VideoFrame *activate(Graphics::Imaging::BitmapPixelFormat format, int width, int height, Graphics::Imaging::BitmapAlphaMode alpha) { VideoFrame *value; hrcheck(get_activation_factory<VideoFrame, IVideoFrameFactory>()->_CreateWithAlpha(format, width, height, alpha, &value)); return value; }
};

template<typename X> struct statics<VideoFrame, X> : X, Windows::Media::VideoFrame_statics<void> {
	using Windows::Media::VideoFrame_statics<void>::activate;
	typedef typename X::root_type VideoFrame;
};
struct VideoFrame : generate<VideoFrame> {
	using IVideoFrame::CopyToAsync;
	using IVideoFrame2::CopyToAsync;
};

// IAudioFrame
struct IAudioFrame_raw : IInspectable {
	virtual STDMETHODIMP _LockBuffer(AudioBufferAccessMode mode, AudioBuffer* *value);
};
template<typename X> struct IAudioFrame_adaptor : X {
	ptr<AudioBuffer> LockBuffer(AudioBufferAccessMode mode) { AudioBuffer* value; hrcheck(X::get()->_LockBuffer(mode, &value)); return from_abi(value); }
};
template<typename X> struct adapt<IAudioFrame, X> : Windows::Media::IAudioFrame_adaptor<X> { typedef adapt IAudioFrame; };
struct IAudioFrame : IAudioFrame_raw, generate<IAudioFrame> {};

// IAudioBuffer
struct IAudioBuffer_raw : IInspectable {
	virtual STDMETHODIMP _get_Capacity(unsigned *value);
	virtual STDMETHODIMP _get_Length(unsigned *value);
	virtual STDMETHODIMP _put_Length(unsigned value);
};
template<typename X> struct IAudioBuffer_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IAudioBuffer_adaptor::Capacity)->_get_Capacity(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Capacity;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IAudioBuffer_adaptor::Length)->_get_Length(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IAudioBuffer_adaptor::Length)->_put_Length(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} Length;
	};
	IAudioBuffer_adaptor() {}
};
template<typename X> struct adapt<IAudioBuffer, X> : Windows::Media::IAudioBuffer_adaptor<X> { typedef adapt IAudioBuffer; };
struct IAudioBuffer : IAudioBuffer_raw, generate<IAudioBuffer> {};

// AudioBuffer
template<typename X> struct statics<AudioBuffer, X> : X {
	typedef typename X::root_type AudioBuffer;
};
struct AudioBuffer : generate<AudioBuffer> {};

// IAudioFrameFactory
struct IAudioFrameFactory : IInspectable {
	virtual STDMETHODIMP _Create(unsigned capacity, AudioFrame* *value);
};

// AudioFrame
template<typename> struct AudioFrame_statics {
	static AudioFrame *activate(unsigned capacity) { AudioFrame *value; hrcheck(get_activation_factory<AudioFrame, IAudioFrameFactory>()->_Create(capacity, &value)); return value; }
};

template<typename X> struct statics<AudioFrame, X> : X, Windows::Media::AudioFrame_statics<void> {
	using Windows::Media::AudioFrame_statics<void>::activate;
	typedef typename X::root_type AudioFrame;
};
struct AudioFrame : generate<AudioFrame> {};

// IMediaMarker
struct IMediaMarker_raw : IInspectable {
	virtual STDMETHODIMP _get_Time(Foundation::TimeSpan *value) = 0;
	virtual STDMETHODIMP _get_MediaMarkerType(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_Text(HSTRING *value) = 0;
};
template<typename X> struct IMediaMarker_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMediaMarker_adaptor::MediaMarkerType)->_get_MediaMarkerType(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} MediaMarkerType;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMediaMarker_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Text;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaMarker_adaptor::Time)->_get_Time(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} Time;
	};
	IMediaMarker_adaptor() {}
};
template<typename X> struct adapt<IMediaMarker, X> : Windows::Media::IMediaMarker_adaptor<X> { typedef adapt IMediaMarker; };
template<typename X> struct IMediaMarker_unadaptor : X {
	STDMETHODIMP _get_Time(Foundation::TimeSpan *value) { return hrtry([&, this] { get_prop(value, Time); }); }
	STDMETHODIMP _get_MediaMarkerType(HSTRING *value) { return hrtry([&, this] { get_prop(value, MediaMarkerType); }); }
	STDMETHODIMP _get_Text(HSTRING *value) { return hrtry([&, this] { get_prop(value, Text); }); }
};
template<typename X> struct unadapt<IMediaMarker, X> : Windows::Media::IMediaMarker_unadaptor<X> {};
struct IMediaMarker : IMediaMarker_raw, generate<IMediaMarker> {};

// IMediaMarkers
struct IMediaMarkers_raw : IInspectable {
	virtual STDMETHODIMP _get_Markers(Foundation::Collections::IVectorView<IMediaMarker*>* *value) = 0;
};
template<typename X> struct IMediaMarkers_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<IMediaMarker>>> get() { Foundation::Collections::IVectorView<IMediaMarker*>* value; hrcheck(enc(&IMediaMarkers_adaptor::Markers)->_get_Markers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<IMediaMarker>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<IMediaMarker>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<IMediaMarker>>> operator->() { return get(); }
		} Markers;
	};
	IMediaMarkers_adaptor() {}
};
template<typename X> struct adapt<IMediaMarkers, X> : Windows::Media::IMediaMarkers_adaptor<X> { typedef adapt IMediaMarkers; };
template<typename X> struct IMediaMarkers_unadaptor : X {
	STDMETHODIMP _get_Markers(Foundation::Collections::IVectorView<IMediaMarker*>* *value) { return hrtry([&, this] { get_prop(value, Markers); }); }
};
template<typename X> struct unadapt<IMediaMarkers, X> : Windows::Media::IMediaMarkers_unadaptor<X> {};
struct IMediaMarkers : IMediaMarkers_raw, generate<IMediaMarkers> {};

// IMediaMarkerTypesStatics
struct IMediaMarkerTypesStatics : IInspectable {
	virtual STDMETHODIMP _get_Bookmark(HSTRING *value);
};

// MediaMarkerTypes
template<typename> struct MediaMarkerTypes_statics {
	static struct _Bookmark : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<MediaMarkerTypes, IMediaMarkerTypesStatics>()->_get_Bookmark(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Bookmark;
};
template<typename X> typename MediaMarkerTypes_statics<X>::_Bookmark MediaMarkerTypes_statics<X>::Bookmark;

template<typename X> struct statics<MediaMarkerTypes, X> : X, Windows::Media::MediaMarkerTypes_statics<void> {
	typedef typename X::root_type MediaMarkerTypes;
};
struct MediaMarkerTypes : generate<MediaMarkerTypes> {};

// ISystemMediaTransportControlsTimelineProperties
struct ISystemMediaTransportControlsTimelineProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_StartTime(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_StartTime(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_EndTime(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_EndTime(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_MinSeekTime(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_MinSeekTime(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_MaxSeekTime(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_MaxSeekTime(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_Position(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_Position(Foundation::TimeSpan value);
};
template<typename X> struct ISystemMediaTransportControlsTimelineProperties_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ISystemMediaTransportControlsTimelineProperties_adaptor::EndTime)->_get_EndTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ISystemMediaTransportControlsTimelineProperties_adaptor::EndTime)->_put_EndTime(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} EndTime;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ISystemMediaTransportControlsTimelineProperties_adaptor::MaxSeekTime)->_get_MaxSeekTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ISystemMediaTransportControlsTimelineProperties_adaptor::MaxSeekTime)->_put_MaxSeekTime(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} MaxSeekTime;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ISystemMediaTransportControlsTimelineProperties_adaptor::MinSeekTime)->_get_MinSeekTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ISystemMediaTransportControlsTimelineProperties_adaptor::MinSeekTime)->_put_MinSeekTime(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} MinSeekTime;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ISystemMediaTransportControlsTimelineProperties_adaptor::Position)->_get_Position(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ISystemMediaTransportControlsTimelineProperties_adaptor::Position)->_put_Position(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Position;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ISystemMediaTransportControlsTimelineProperties_adaptor::StartTime)->_get_StartTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ISystemMediaTransportControlsTimelineProperties_adaptor::StartTime)->_put_StartTime(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} StartTime;
	};
	ISystemMediaTransportControlsTimelineProperties_adaptor() {}
};
template<typename X> struct adapt<ISystemMediaTransportControlsTimelineProperties, X> : Windows::Media::ISystemMediaTransportControlsTimelineProperties_adaptor<X> { typedef adapt ISystemMediaTransportControlsTimelineProperties; };
struct ISystemMediaTransportControlsTimelineProperties : ISystemMediaTransportControlsTimelineProperties_raw, generate<ISystemMediaTransportControlsTimelineProperties> {};

// SystemMediaTransportControlsTimelineProperties
template<typename X> struct statics<SystemMediaTransportControlsTimelineProperties, X> : X {
	typedef typename X::root_type SystemMediaTransportControlsTimelineProperties;
};
struct SystemMediaTransportControlsTimelineProperties : generate<SystemMediaTransportControlsTimelineProperties> {};

// IMusicDisplayProperties
struct IMusicDisplayProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_Title(HSTRING *value);
	virtual STDMETHODIMP _put_Title(HSTRING value);
	virtual STDMETHODIMP _get_AlbumArtist(HSTRING *value);
	virtual STDMETHODIMP _put_AlbumArtist(HSTRING value);
	virtual STDMETHODIMP _get_Artist(HSTRING *value);
	virtual STDMETHODIMP _put_Artist(HSTRING value);
};
template<typename X> struct IMusicDisplayProperties_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMusicDisplayProperties_adaptor::AlbumArtist)->_get_AlbumArtist(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IMusicDisplayProperties_adaptor::AlbumArtist)->_put_AlbumArtist(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} AlbumArtist;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMusicDisplayProperties_adaptor::Artist)->_get_Artist(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IMusicDisplayProperties_adaptor::Artist)->_put_Artist(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Artist;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMusicDisplayProperties_adaptor::Title)->_get_Title(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IMusicDisplayProperties_adaptor::Title)->_put_Title(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Title;
	};
	IMusicDisplayProperties_adaptor() {}
};
template<typename X> struct adapt<IMusicDisplayProperties, X> : Windows::Media::IMusicDisplayProperties_adaptor<X> { typedef adapt IMusicDisplayProperties; };
struct IMusicDisplayProperties : IMusicDisplayProperties_raw, generate<IMusicDisplayProperties> {};

// IMusicDisplayProperties2
struct IMusicDisplayProperties2_raw : IInspectable {
	virtual STDMETHODIMP _get_AlbumTitle(HSTRING *value);
	virtual STDMETHODIMP _put_AlbumTitle(HSTRING value);
	virtual STDMETHODIMP _get_TrackNumber(unsigned *value);
	virtual STDMETHODIMP _put_TrackNumber(unsigned value);
	virtual STDMETHODIMP _get_Genres(Foundation::Collections::IVector<HSTRING>* *value);
};
template<typename X> struct IMusicDisplayProperties2_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMusicDisplayProperties2_adaptor::AlbumTitle)->_get_AlbumTitle(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IMusicDisplayProperties2_adaptor::AlbumTitle)->_put_AlbumTitle(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} AlbumTitle;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IMusicDisplayProperties2_adaptor::Genres)->_get_Genres(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} Genres;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IMusicDisplayProperties2_adaptor::TrackNumber)->_get_TrackNumber(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IMusicDisplayProperties2_adaptor::TrackNumber)->_put_TrackNumber(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} TrackNumber;
	};
	IMusicDisplayProperties2_adaptor() {}
};
template<typename X> struct adapt<IMusicDisplayProperties2, X> : Windows::Media::IMusicDisplayProperties2_adaptor<X> { typedef adapt IMusicDisplayProperties2; };
struct IMusicDisplayProperties2 : IMusicDisplayProperties2_raw, generate<IMusicDisplayProperties2> {};

// IMusicDisplayProperties3
struct IMusicDisplayProperties3_raw : IInspectable {
	virtual STDMETHODIMP _get_AlbumTrackCount(unsigned *value);
	virtual STDMETHODIMP _put_AlbumTrackCount(unsigned value);
};
template<typename X> struct IMusicDisplayProperties3_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IMusicDisplayProperties3_adaptor::AlbumTrackCount)->_get_AlbumTrackCount(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IMusicDisplayProperties3_adaptor::AlbumTrackCount)->_put_AlbumTrackCount(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} AlbumTrackCount;
	};
	IMusicDisplayProperties3_adaptor() {}
};
template<typename X> struct adapt<IMusicDisplayProperties3, X> : Windows::Media::IMusicDisplayProperties3_adaptor<X> { typedef adapt IMusicDisplayProperties3; };
struct IMusicDisplayProperties3 : IMusicDisplayProperties3_raw, generate<IMusicDisplayProperties3> {};

// MusicDisplayProperties
template<typename X> struct statics<MusicDisplayProperties, X> : X {
	typedef typename X::root_type MusicDisplayProperties;
};
struct MusicDisplayProperties : generate<MusicDisplayProperties> {};

// IVideoDisplayProperties
struct IVideoDisplayProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_Title(HSTRING *value);
	virtual STDMETHODIMP _put_Title(HSTRING value);
	virtual STDMETHODIMP _get_Subtitle(HSTRING *value);
	virtual STDMETHODIMP _put_Subtitle(HSTRING value);
};
template<typename X> struct IVideoDisplayProperties_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVideoDisplayProperties_adaptor::Subtitle)->_get_Subtitle(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVideoDisplayProperties_adaptor::Subtitle)->_put_Subtitle(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Subtitle;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVideoDisplayProperties_adaptor::Title)->_get_Title(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVideoDisplayProperties_adaptor::Title)->_put_Title(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Title;
	};
	IVideoDisplayProperties_adaptor() {}
};
template<typename X> struct adapt<IVideoDisplayProperties, X> : Windows::Media::IVideoDisplayProperties_adaptor<X> { typedef adapt IVideoDisplayProperties; };
struct IVideoDisplayProperties : IVideoDisplayProperties_raw, generate<IVideoDisplayProperties> {};

// IVideoDisplayProperties2
struct IVideoDisplayProperties2_raw : IInspectable {
	virtual STDMETHODIMP _get_Genres(Foundation::Collections::IVector<HSTRING>* *value);
};
template<typename X> struct IVideoDisplayProperties2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IVideoDisplayProperties2_adaptor::Genres)->_get_Genres(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} Genres;
	};
	IVideoDisplayProperties2_adaptor() {}
};
template<typename X> struct adapt<IVideoDisplayProperties2, X> : Windows::Media::IVideoDisplayProperties2_adaptor<X> { typedef adapt IVideoDisplayProperties2; };
struct IVideoDisplayProperties2 : IVideoDisplayProperties2_raw, generate<IVideoDisplayProperties2> {};

// VideoDisplayProperties
template<typename X> struct statics<VideoDisplayProperties, X> : X {
	typedef typename X::root_type VideoDisplayProperties;
};
struct VideoDisplayProperties : generate<VideoDisplayProperties> {};

// IImageDisplayProperties
struct IImageDisplayProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_Title(HSTRING *value);
	virtual STDMETHODIMP _put_Title(HSTRING value);
	virtual STDMETHODIMP _get_Subtitle(HSTRING *value);
	virtual STDMETHODIMP _put_Subtitle(HSTRING value);
};
template<typename X> struct IImageDisplayProperties_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IImageDisplayProperties_adaptor::Subtitle)->_get_Subtitle(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IImageDisplayProperties_adaptor::Subtitle)->_put_Subtitle(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Subtitle;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IImageDisplayProperties_adaptor::Title)->_get_Title(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IImageDisplayProperties_adaptor::Title)->_put_Title(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Title;
	};
	IImageDisplayProperties_adaptor() {}
};
template<typename X> struct adapt<IImageDisplayProperties, X> : Windows::Media::IImageDisplayProperties_adaptor<X> { typedef adapt IImageDisplayProperties; };
struct IImageDisplayProperties : IImageDisplayProperties_raw, generate<IImageDisplayProperties> {};

// ImageDisplayProperties
template<typename X> struct statics<ImageDisplayProperties, X> : X {
	typedef typename X::root_type ImageDisplayProperties;
};
struct ImageDisplayProperties : generate<ImageDisplayProperties> {};

// ISystemMediaTransportControlsDisplayUpdater
struct ISystemMediaTransportControlsDisplayUpdater_raw : IInspectable {
	virtual STDMETHODIMP _get_Type(MediaPlaybackType *value);
	virtual STDMETHODIMP _put_Type(MediaPlaybackType value);
	virtual STDMETHODIMP _get_AppMediaId(HSTRING *value);
	virtual STDMETHODIMP _put_AppMediaId(HSTRING value);
	virtual STDMETHODIMP _get_Thumbnail(Storage::Streams::RandomAccessStreamReference* *value);
	virtual STDMETHODIMP _put_Thumbnail(Storage::Streams::RandomAccessStreamReference* value);
	virtual STDMETHODIMP _get_MusicProperties(MusicDisplayProperties* *value);
	virtual STDMETHODIMP _get_VideoProperties(VideoDisplayProperties* *value);
	virtual STDMETHODIMP _get_ImageProperties(ImageDisplayProperties* *value);
	virtual STDMETHODIMP _CopyFromFileAsync(MediaPlaybackType type, Storage::StorageFile* source, Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _ClearAll();
	virtual STDMETHODIMP _Update();
};
template<typename X> struct ISystemMediaTransportControlsDisplayUpdater_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemMediaTransportControlsDisplayUpdater_adaptor::AppMediaId)->_get_AppMediaId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISystemMediaTransportControlsDisplayUpdater_adaptor::AppMediaId)->_put_AppMediaId(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} AppMediaId;
		struct : property {
			ptr<ImageDisplayProperties> get() { ImageDisplayProperties* value; hrcheck(enc(&ISystemMediaTransportControlsDisplayUpdater_adaptor::ImageProperties)->_get_ImageProperties(&value)); return from_abi(value); }
			ptr<ImageDisplayProperties> operator()() { return get(); }
			operator ptr<ImageDisplayProperties> () { return get(); }
			ptr<ImageDisplayProperties> operator->() { return get(); }
		} ImageProperties;
		struct : property {
			ptr<MusicDisplayProperties> get() { MusicDisplayProperties* value; hrcheck(enc(&ISystemMediaTransportControlsDisplayUpdater_adaptor::MusicProperties)->_get_MusicProperties(&value)); return from_abi(value); }
			ptr<MusicDisplayProperties> operator()() { return get(); }
			operator ptr<MusicDisplayProperties> () { return get(); }
			ptr<MusicDisplayProperties> operator->() { return get(); }
		} MusicProperties;
		struct : property {
			ptr<Storage::Streams::RandomAccessStreamReference> get() { Storage::Streams::RandomAccessStreamReference* value; hrcheck(enc(&ISystemMediaTransportControlsDisplayUpdater_adaptor::Thumbnail)->_get_Thumbnail(&value)); return from_abi(value); }
			ptr<Storage::Streams::RandomAccessStreamReference> operator()() { return get(); }
			operator ptr<Storage::Streams::RandomAccessStreamReference> () { return get(); }
			ptr<Storage::Streams::RandomAccessStreamReference> operator->() { return get(); }
			void put(pptr<Storage::Streams::RandomAccessStreamReference> value) { hrcheck(enc(&ISystemMediaTransportControlsDisplayUpdater_adaptor::Thumbnail)->_put_Thumbnail(value)); }
			void operator=(pptr<Storage::Streams::RandomAccessStreamReference> value) { put(value); }
			void operator()(pptr<Storage::Streams::RandomAccessStreamReference> value) { put(value); }
		} Thumbnail;
		struct : property {
			MediaPlaybackType get() { MediaPlaybackType value; hrcheck(enc(&ISystemMediaTransportControlsDisplayUpdater_adaptor::Type)->_get_Type(&value)); return value; }
			MediaPlaybackType operator()() { return get(); }
			operator MediaPlaybackType () { return get(); }
			void put(MediaPlaybackType value) { hrcheck(enc(&ISystemMediaTransportControlsDisplayUpdater_adaptor::Type)->_put_Type(value)); }
			void operator=(MediaPlaybackType value) { put(value); }
			void operator()(MediaPlaybackType value) { put(value); }
		} Type;
		struct : property {
			ptr<VideoDisplayProperties> get() { VideoDisplayProperties* value; hrcheck(enc(&ISystemMediaTransportControlsDisplayUpdater_adaptor::VideoProperties)->_get_VideoProperties(&value)); return from_abi(value); }
			ptr<VideoDisplayProperties> operator()() { return get(); }
			operator ptr<VideoDisplayProperties> () { return get(); }
			ptr<VideoDisplayProperties> operator->() { return get(); }
		} VideoProperties;
	};
	ptr<Foundation::IAsyncOperation<bool>> CopyFromFileAsync(MediaPlaybackType type, pptr<Storage::StorageFile> source) { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_CopyFromFileAsync(type, source, &operation)); return from_abi(operation); }
	void ClearAll() { hrcheck(X::get()->_ClearAll()); }
	void Update() { hrcheck(X::get()->_Update()); }
	ISystemMediaTransportControlsDisplayUpdater_adaptor() {}
};
template<typename X> struct adapt<ISystemMediaTransportControlsDisplayUpdater, X> : Windows::Media::ISystemMediaTransportControlsDisplayUpdater_adaptor<X> { typedef adapt ISystemMediaTransportControlsDisplayUpdater; };
struct ISystemMediaTransportControlsDisplayUpdater : ISystemMediaTransportControlsDisplayUpdater_raw, generate<ISystemMediaTransportControlsDisplayUpdater> {};

// SystemMediaTransportControlsDisplayUpdater
template<typename X> struct statics<SystemMediaTransportControlsDisplayUpdater, X> : X {
	typedef typename X::root_type SystemMediaTransportControlsDisplayUpdater;
};
struct SystemMediaTransportControlsDisplayUpdater : generate<SystemMediaTransportControlsDisplayUpdater> {};

// ISystemMediaTransportControlsButtonPressedEventArgs
struct ISystemMediaTransportControlsButtonPressedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Button(SystemMediaTransportControlsButton *value);
};
template<typename X> struct ISystemMediaTransportControlsButtonPressedEventArgs_adaptor : X {
	union {
		struct : property {
			SystemMediaTransportControlsButton get() { SystemMediaTransportControlsButton value; hrcheck(enc(&ISystemMediaTransportControlsButtonPressedEventArgs_adaptor::Button)->_get_Button(&value)); return value; }
			SystemMediaTransportControlsButton operator()() { return get(); }
			operator SystemMediaTransportControlsButton () { return get(); }
		} Button;
	};
	ISystemMediaTransportControlsButtonPressedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISystemMediaTransportControlsButtonPressedEventArgs, X> : Windows::Media::ISystemMediaTransportControlsButtonPressedEventArgs_adaptor<X> { typedef adapt ISystemMediaTransportControlsButtonPressedEventArgs; };
struct ISystemMediaTransportControlsButtonPressedEventArgs : ISystemMediaTransportControlsButtonPressedEventArgs_raw, generate<ISystemMediaTransportControlsButtonPressedEventArgs> {};

// SystemMediaTransportControlsButtonPressedEventArgs
template<typename X> struct statics<SystemMediaTransportControlsButtonPressedEventArgs, X> : X {
	typedef typename X::root_type SystemMediaTransportControlsButtonPressedEventArgs;
};
struct SystemMediaTransportControlsButtonPressedEventArgs : generate<SystemMediaTransportControlsButtonPressedEventArgs> {};

// ISystemMediaTransportControlsPropertyChangedEventArgs
struct ISystemMediaTransportControlsPropertyChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Property(SystemMediaTransportControlsProperty *value);
};
template<typename X> struct ISystemMediaTransportControlsPropertyChangedEventArgs_adaptor : X {
	union {
		struct : property {
			SystemMediaTransportControlsProperty get() { SystemMediaTransportControlsProperty value; hrcheck(enc(&ISystemMediaTransportControlsPropertyChangedEventArgs_adaptor::Property)->_get_Property(&value)); return value; }
			SystemMediaTransportControlsProperty operator()() { return get(); }
			operator SystemMediaTransportControlsProperty () { return get(); }
		} Property;
	};
	ISystemMediaTransportControlsPropertyChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISystemMediaTransportControlsPropertyChangedEventArgs, X> : Windows::Media::ISystemMediaTransportControlsPropertyChangedEventArgs_adaptor<X> { typedef adapt ISystemMediaTransportControlsPropertyChangedEventArgs; };
struct ISystemMediaTransportControlsPropertyChangedEventArgs : ISystemMediaTransportControlsPropertyChangedEventArgs_raw, generate<ISystemMediaTransportControlsPropertyChangedEventArgs> {};

// SystemMediaTransportControlsPropertyChangedEventArgs
template<typename X> struct statics<SystemMediaTransportControlsPropertyChangedEventArgs, X> : X {
	typedef typename X::root_type SystemMediaTransportControlsPropertyChangedEventArgs;
};
struct SystemMediaTransportControlsPropertyChangedEventArgs : generate<SystemMediaTransportControlsPropertyChangedEventArgs> {};

// IPlaybackPositionChangeRequestedEventArgs
struct IPlaybackPositionChangeRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_RequestedPlaybackPosition(Foundation::TimeSpan *value);
};
template<typename X> struct IPlaybackPositionChangeRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IPlaybackPositionChangeRequestedEventArgs_adaptor::RequestedPlaybackPosition)->_get_RequestedPlaybackPosition(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} RequestedPlaybackPosition;
	};
	IPlaybackPositionChangeRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IPlaybackPositionChangeRequestedEventArgs, X> : Windows::Media::IPlaybackPositionChangeRequestedEventArgs_adaptor<X> { typedef adapt IPlaybackPositionChangeRequestedEventArgs; };
struct IPlaybackPositionChangeRequestedEventArgs : IPlaybackPositionChangeRequestedEventArgs_raw, generate<IPlaybackPositionChangeRequestedEventArgs> {};

// PlaybackPositionChangeRequestedEventArgs
template<typename X> struct statics<PlaybackPositionChangeRequestedEventArgs, X> : X {
	typedef typename X::root_type PlaybackPositionChangeRequestedEventArgs;
};
struct PlaybackPositionChangeRequestedEventArgs : generate<PlaybackPositionChangeRequestedEventArgs> {};

// IPlaybackRateChangeRequestedEventArgs
struct IPlaybackRateChangeRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_RequestedPlaybackRate(double *value);
};
template<typename X> struct IPlaybackRateChangeRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IPlaybackRateChangeRequestedEventArgs_adaptor::RequestedPlaybackRate)->_get_RequestedPlaybackRate(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} RequestedPlaybackRate;
	};
	IPlaybackRateChangeRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IPlaybackRateChangeRequestedEventArgs, X> : Windows::Media::IPlaybackRateChangeRequestedEventArgs_adaptor<X> { typedef adapt IPlaybackRateChangeRequestedEventArgs; };
struct IPlaybackRateChangeRequestedEventArgs : IPlaybackRateChangeRequestedEventArgs_raw, generate<IPlaybackRateChangeRequestedEventArgs> {};

// PlaybackRateChangeRequestedEventArgs
template<typename X> struct statics<PlaybackRateChangeRequestedEventArgs, X> : X {
	typedef typename X::root_type PlaybackRateChangeRequestedEventArgs;
};
struct PlaybackRateChangeRequestedEventArgs : generate<PlaybackRateChangeRequestedEventArgs> {};

// IShuffleEnabledChangeRequestedEventArgs
struct IShuffleEnabledChangeRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_RequestedShuffleEnabled(bool *value);
};
template<typename X> struct IShuffleEnabledChangeRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IShuffleEnabledChangeRequestedEventArgs_adaptor::RequestedShuffleEnabled)->_get_RequestedShuffleEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} RequestedShuffleEnabled;
	};
	IShuffleEnabledChangeRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IShuffleEnabledChangeRequestedEventArgs, X> : Windows::Media::IShuffleEnabledChangeRequestedEventArgs_adaptor<X> { typedef adapt IShuffleEnabledChangeRequestedEventArgs; };
struct IShuffleEnabledChangeRequestedEventArgs : IShuffleEnabledChangeRequestedEventArgs_raw, generate<IShuffleEnabledChangeRequestedEventArgs> {};

// ShuffleEnabledChangeRequestedEventArgs
template<typename X> struct statics<ShuffleEnabledChangeRequestedEventArgs, X> : X {
	typedef typename X::root_type ShuffleEnabledChangeRequestedEventArgs;
};
struct ShuffleEnabledChangeRequestedEventArgs : generate<ShuffleEnabledChangeRequestedEventArgs> {};

// IAutoRepeatModeChangeRequestedEventArgs
struct IAutoRepeatModeChangeRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_RequestedAutoRepeatMode(MediaPlaybackAutoRepeatMode *value);
};
template<typename X> struct IAutoRepeatModeChangeRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			MediaPlaybackAutoRepeatMode get() { MediaPlaybackAutoRepeatMode value; hrcheck(enc(&IAutoRepeatModeChangeRequestedEventArgs_adaptor::RequestedAutoRepeatMode)->_get_RequestedAutoRepeatMode(&value)); return value; }
			MediaPlaybackAutoRepeatMode operator()() { return get(); }
			operator MediaPlaybackAutoRepeatMode () { return get(); }
		} RequestedAutoRepeatMode;
	};
	IAutoRepeatModeChangeRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IAutoRepeatModeChangeRequestedEventArgs, X> : Windows::Media::IAutoRepeatModeChangeRequestedEventArgs_adaptor<X> { typedef adapt IAutoRepeatModeChangeRequestedEventArgs; };
struct IAutoRepeatModeChangeRequestedEventArgs : IAutoRepeatModeChangeRequestedEventArgs_raw, generate<IAutoRepeatModeChangeRequestedEventArgs> {};

// AutoRepeatModeChangeRequestedEventArgs
template<typename X> struct statics<AutoRepeatModeChangeRequestedEventArgs, X> : X {
	typedef typename X::root_type AutoRepeatModeChangeRequestedEventArgs;
};
struct AutoRepeatModeChangeRequestedEventArgs : generate<AutoRepeatModeChangeRequestedEventArgs> {};

// ISystemMediaTransportControls
struct ISystemMediaTransportControls_raw : IInspectable {
	virtual STDMETHODIMP _get_PlaybackStatus(MediaPlaybackStatus *value);
	virtual STDMETHODIMP _put_PlaybackStatus(MediaPlaybackStatus value);
	virtual STDMETHODIMP _get_DisplayUpdater(SystemMediaTransportControlsDisplayUpdater* *value);
	virtual STDMETHODIMP _get_SoundLevel(Media::SoundLevel *value);
	virtual STDMETHODIMP _get_IsEnabled(bool *value);
	virtual STDMETHODIMP _put_IsEnabled(bool value);
	virtual STDMETHODIMP _get_IsPlayEnabled(bool *value);
	virtual STDMETHODIMP _put_IsPlayEnabled(bool value);
	virtual STDMETHODIMP _get_IsStopEnabled(bool *value);
	virtual STDMETHODIMP _put_IsStopEnabled(bool value);
	virtual STDMETHODIMP _get_IsPauseEnabled(bool *value);
	virtual STDMETHODIMP _put_IsPauseEnabled(bool value);
	virtual STDMETHODIMP _get_IsRecordEnabled(bool *value);
	virtual STDMETHODIMP _put_IsRecordEnabled(bool value);
	virtual STDMETHODIMP _get_IsFastForwardEnabled(bool *value);
	virtual STDMETHODIMP _put_IsFastForwardEnabled(bool value);
	virtual STDMETHODIMP _get_IsRewindEnabled(bool *value);
	virtual STDMETHODIMP _put_IsRewindEnabled(bool value);
	virtual STDMETHODIMP _get_IsPreviousEnabled(bool *value);
	virtual STDMETHODIMP _put_IsPreviousEnabled(bool value);
	virtual STDMETHODIMP _get_IsNextEnabled(bool *value);
	virtual STDMETHODIMP _put_IsNextEnabled(bool value);
	virtual STDMETHODIMP _get_IsChannelUpEnabled(bool *value);
	virtual STDMETHODIMP _put_IsChannelUpEnabled(bool value);
	virtual STDMETHODIMP _get_IsChannelDownEnabled(bool *value);
	virtual STDMETHODIMP _put_IsChannelDownEnabled(bool value);
	virtual STDMETHODIMP _add_ButtonPressed(Foundation::TypedEventHandler<SystemMediaTransportControls*, SystemMediaTransportControlsButtonPressedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ButtonPressed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PropertyChanged(Foundation::TypedEventHandler<SystemMediaTransportControls*, SystemMediaTransportControlsPropertyChangedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PropertyChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct ISystemMediaTransportControls_adaptor : X {
	union {
		struct : property {
			ptr<SystemMediaTransportControlsDisplayUpdater> get() { SystemMediaTransportControlsDisplayUpdater* value; hrcheck(enc(&ISystemMediaTransportControls_adaptor::DisplayUpdater)->_get_DisplayUpdater(&value)); return from_abi(value); }
			ptr<SystemMediaTransportControlsDisplayUpdater> operator()() { return get(); }
			operator ptr<SystemMediaTransportControlsDisplayUpdater> () { return get(); }
			ptr<SystemMediaTransportControlsDisplayUpdater> operator->() { return get(); }
		} DisplayUpdater;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsChannelDownEnabled)->_get_IsChannelDownEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsChannelDownEnabled)->_put_IsChannelDownEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsChannelDownEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsChannelUpEnabled)->_get_IsChannelUpEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsChannelUpEnabled)->_put_IsChannelUpEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsChannelUpEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsEnabled)->_get_IsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsEnabled)->_put_IsEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsFastForwardEnabled)->_get_IsFastForwardEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsFastForwardEnabled)->_put_IsFastForwardEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsFastForwardEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsNextEnabled)->_get_IsNextEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsNextEnabled)->_put_IsNextEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsNextEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsPauseEnabled)->_get_IsPauseEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsPauseEnabled)->_put_IsPauseEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsPauseEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsPlayEnabled)->_get_IsPlayEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsPlayEnabled)->_put_IsPlayEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsPlayEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsPreviousEnabled)->_get_IsPreviousEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsPreviousEnabled)->_put_IsPreviousEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsPreviousEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsRecordEnabled)->_get_IsRecordEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsRecordEnabled)->_put_IsRecordEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsRecordEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsRewindEnabled)->_get_IsRewindEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsRewindEnabled)->_put_IsRewindEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsRewindEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsStopEnabled)->_get_IsStopEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISystemMediaTransportControls_adaptor::IsStopEnabled)->_put_IsStopEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsStopEnabled;
		struct : property {
			MediaPlaybackStatus get() { MediaPlaybackStatus value; hrcheck(enc(&ISystemMediaTransportControls_adaptor::PlaybackStatus)->_get_PlaybackStatus(&value)); return value; }
			MediaPlaybackStatus operator()() { return get(); }
			operator MediaPlaybackStatus () { return get(); }
			void put(MediaPlaybackStatus value) { hrcheck(enc(&ISystemMediaTransportControls_adaptor::PlaybackStatus)->_put_PlaybackStatus(value)); }
			void operator=(MediaPlaybackStatus value) { put(value); }
			void operator()(MediaPlaybackStatus value) { put(value); }
		} PlaybackStatus;
		struct : property {
			Media::SoundLevel get() { Media::SoundLevel value; hrcheck(enc(&ISystemMediaTransportControls_adaptor::SoundLevel)->_get_SoundLevel(&value)); return value; }
			Media::SoundLevel operator()() { return get(); }
			operator Media::SoundLevel () { return get(); }
		} SoundLevel;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SystemMediaTransportControls>, ptr<SystemMediaTransportControlsButtonPressedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISystemMediaTransportControls_adaptor::ButtonPressed)->_add_ButtonPressed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISystemMediaTransportControls_adaptor::ButtonPressed)->_remove_ButtonPressed(token)); }
		} ButtonPressed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SystemMediaTransportControls>, ptr<SystemMediaTransportControlsPropertyChangedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISystemMediaTransportControls_adaptor::PropertyChanged)->_add_PropertyChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISystemMediaTransportControls_adaptor::PropertyChanged)->_remove_PropertyChanged(token)); }
		} PropertyChanged;
	};
	ISystemMediaTransportControls_adaptor() {}
};
template<typename X> struct adapt<ISystemMediaTransportControls, X> : Windows::Media::ISystemMediaTransportControls_adaptor<X> { typedef adapt ISystemMediaTransportControls; };
struct ISystemMediaTransportControls : ISystemMediaTransportControls_raw, generate<ISystemMediaTransportControls> {};

// ISystemMediaTransportControlsStatics
struct ISystemMediaTransportControlsStatics : IInspectable {
	virtual STDMETHODIMP _GetForCurrentView(SystemMediaTransportControls* *mediaControl);
};

// ISystemMediaTransportControls2
struct ISystemMediaTransportControls2_raw : IInspectable {
	virtual STDMETHODIMP _get_AutoRepeatMode(MediaPlaybackAutoRepeatMode *value);
	virtual STDMETHODIMP _put_AutoRepeatMode(MediaPlaybackAutoRepeatMode value);
	virtual STDMETHODIMP _get_ShuffleEnabled(bool *value);
	virtual STDMETHODIMP _put_ShuffleEnabled(bool value);
	virtual STDMETHODIMP _get_PlaybackRate(double *value);
	virtual STDMETHODIMP _put_PlaybackRate(double value);
	virtual STDMETHODIMP _UpdateTimelineProperties(SystemMediaTransportControlsTimelineProperties* timelineProperties);
	virtual STDMETHODIMP _add_PlaybackPositionChangeRequested(Foundation::TypedEventHandler<SystemMediaTransportControls*, PlaybackPositionChangeRequestedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PlaybackPositionChangeRequested(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PlaybackRateChangeRequested(Foundation::TypedEventHandler<SystemMediaTransportControls*, PlaybackRateChangeRequestedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PlaybackRateChangeRequested(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ShuffleEnabledChangeRequested(Foundation::TypedEventHandler<SystemMediaTransportControls*, ShuffleEnabledChangeRequestedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ShuffleEnabledChangeRequested(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_AutoRepeatModeChangeRequested(Foundation::TypedEventHandler<SystemMediaTransportControls*, AutoRepeatModeChangeRequestedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_AutoRepeatModeChangeRequested(Foundation::EventRegistrationToken token);
};
template<typename X> struct ISystemMediaTransportControls2_adaptor : X {
	union {
		struct : property {
			MediaPlaybackAutoRepeatMode get() { MediaPlaybackAutoRepeatMode value; hrcheck(enc(&ISystemMediaTransportControls2_adaptor::AutoRepeatMode)->_get_AutoRepeatMode(&value)); return value; }
			MediaPlaybackAutoRepeatMode operator()() { return get(); }
			operator MediaPlaybackAutoRepeatMode () { return get(); }
			void put(MediaPlaybackAutoRepeatMode value) { hrcheck(enc(&ISystemMediaTransportControls2_adaptor::AutoRepeatMode)->_put_AutoRepeatMode(value)); }
			void operator=(MediaPlaybackAutoRepeatMode value) { put(value); }
			void operator()(MediaPlaybackAutoRepeatMode value) { put(value); }
		} AutoRepeatMode;
		struct : property {
			double get() { double value; hrcheck(enc(&ISystemMediaTransportControls2_adaptor::PlaybackRate)->_get_PlaybackRate(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISystemMediaTransportControls2_adaptor::PlaybackRate)->_put_PlaybackRate(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} PlaybackRate;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISystemMediaTransportControls2_adaptor::ShuffleEnabled)->_get_ShuffleEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISystemMediaTransportControls2_adaptor::ShuffleEnabled)->_put_ShuffleEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ShuffleEnabled;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SystemMediaTransportControls>, ptr<AutoRepeatModeChangeRequestedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISystemMediaTransportControls2_adaptor::AutoRepeatModeChangeRequested)->_add_AutoRepeatModeChangeRequested(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISystemMediaTransportControls2_adaptor::AutoRepeatModeChangeRequested)->_remove_AutoRepeatModeChangeRequested(token)); }
		} AutoRepeatModeChangeRequested;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SystemMediaTransportControls>, ptr<PlaybackPositionChangeRequestedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISystemMediaTransportControls2_adaptor::PlaybackPositionChangeRequested)->_add_PlaybackPositionChangeRequested(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISystemMediaTransportControls2_adaptor::PlaybackPositionChangeRequested)->_remove_PlaybackPositionChangeRequested(token)); }
		} PlaybackPositionChangeRequested;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SystemMediaTransportControls>, ptr<PlaybackRateChangeRequestedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISystemMediaTransportControls2_adaptor::PlaybackRateChangeRequested)->_add_PlaybackRateChangeRequested(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISystemMediaTransportControls2_adaptor::PlaybackRateChangeRequested)->_remove_PlaybackRateChangeRequested(token)); }
		} PlaybackRateChangeRequested;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SystemMediaTransportControls>, ptr<ShuffleEnabledChangeRequestedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISystemMediaTransportControls2_adaptor::ShuffleEnabledChangeRequested)->_add_ShuffleEnabledChangeRequested(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISystemMediaTransportControls2_adaptor::ShuffleEnabledChangeRequested)->_remove_ShuffleEnabledChangeRequested(token)); }
		} ShuffleEnabledChangeRequested;
	};
	void UpdateTimelineProperties(pptr<SystemMediaTransportControlsTimelineProperties> timelineProperties) { hrcheck(X::get()->_UpdateTimelineProperties(timelineProperties)); }
	ISystemMediaTransportControls2_adaptor() {}
};
template<typename X> struct adapt<ISystemMediaTransportControls2, X> : Windows::Media::ISystemMediaTransportControls2_adaptor<X> { typedef adapt ISystemMediaTransportControls2; };
struct ISystemMediaTransportControls2 : ISystemMediaTransportControls2_raw, generate<ISystemMediaTransportControls2> {};

// SystemMediaTransportControls
template<typename> struct SystemMediaTransportControls_statics {
	static ptr<SystemMediaTransportControls> GetForCurrentView() { SystemMediaTransportControls* mediaControl; hrcheck(get_activation_factory<SystemMediaTransportControls, ISystemMediaTransportControlsStatics>()->_GetForCurrentView(&mediaControl)); return from_abi(mediaControl); }
};

template<typename X> struct statics<SystemMediaTransportControls, X> : X, Windows::Media::SystemMediaTransportControls_statics<void> {
	typedef typename X::root_type SystemMediaTransportControls;
};
struct SystemMediaTransportControls : generate<SystemMediaTransportControls> {};

// IMediaTimelineController
struct IMediaTimelineController_raw : IInspectable {
	virtual STDMETHODIMP _Start();
	virtual STDMETHODIMP _Resume();
	virtual STDMETHODIMP _Pause();
	virtual STDMETHODIMP _get_Position(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_Position(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_ClockRate(double *value);
	virtual STDMETHODIMP _put_ClockRate(double value);
	virtual STDMETHODIMP _get_State(MediaTimelineControllerState *value);
	virtual STDMETHODIMP _add_PositionChanged(Foundation::TypedEventHandler<MediaTimelineController*, IInspectable*>* positionChangedEventHandler, Foundation::EventRegistrationToken *eventCookie);
	virtual STDMETHODIMP _remove_PositionChanged(Foundation::EventRegistrationToken eventCookie);
	virtual STDMETHODIMP _add_StateChanged(Foundation::TypedEventHandler<MediaTimelineController*, IInspectable*>* stateChangedEventHandler, Foundation::EventRegistrationToken *eventCookie);
	virtual STDMETHODIMP _remove_StateChanged(Foundation::EventRegistrationToken eventCookie);
};
template<typename X> struct IMediaTimelineController_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IMediaTimelineController_adaptor::ClockRate)->_get_ClockRate(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IMediaTimelineController_adaptor::ClockRate)->_put_ClockRate(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ClockRate;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaTimelineController_adaptor::Position)->_get_Position(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMediaTimelineController_adaptor::Position)->_put_Position(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Position;
		struct : property {
			MediaTimelineControllerState get() { MediaTimelineControllerState value; hrcheck(enc(&IMediaTimelineController_adaptor::State)->_get_State(&value)); return value; }
			MediaTimelineControllerState operator()() { return get(); }
			operator MediaTimelineControllerState () { return get(); }
		} State;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaTimelineController>, object>> positionChangedEventHandler) { Foundation::EventRegistrationToken eventCookie; hrcheck(enc(&IMediaTimelineController_adaptor::PositionChanged)->_add_PositionChanged(to_abi(positionChangedEventHandler), &eventCookie)); return eventCookie; }
			void operator-=(const Foundation::EventRegistrationToken& eventCookie) { hrcheck(enc(&IMediaTimelineController_adaptor::PositionChanged)->_remove_PositionChanged(eventCookie)); }
		} PositionChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaTimelineController>, object>> stateChangedEventHandler) { Foundation::EventRegistrationToken eventCookie; hrcheck(enc(&IMediaTimelineController_adaptor::StateChanged)->_add_StateChanged(to_abi(stateChangedEventHandler), &eventCookie)); return eventCookie; }
			void operator-=(const Foundation::EventRegistrationToken& eventCookie) { hrcheck(enc(&IMediaTimelineController_adaptor::StateChanged)->_remove_StateChanged(eventCookie)); }
		} StateChanged;
	};
	void Start() { hrcheck(X::get()->_Start()); }
	void Resume() { hrcheck(X::get()->_Resume()); }
	void Pause() { hrcheck(X::get()->_Pause()); }
	IMediaTimelineController_adaptor() {}
};
template<typename X> struct adapt<IMediaTimelineController, X> : Windows::Media::IMediaTimelineController_adaptor<X> { typedef adapt IMediaTimelineController; };
struct IMediaTimelineController : IMediaTimelineController_raw, generate<IMediaTimelineController> {};

// IMediaTimelineController2
struct IMediaTimelineController2_raw : IInspectable {
	virtual STDMETHODIMP _get_Duration(Foundation::IReference<Foundation::TimeSpan>* *value);
	virtual STDMETHODIMP _put_Duration(Foundation::IReference<Foundation::TimeSpan>* value);
	virtual STDMETHODIMP _get_IsLoopingEnabled(bool *value);
	virtual STDMETHODIMP _put_IsLoopingEnabled(bool value);
	virtual STDMETHODIMP _add_Failed(Foundation::TypedEventHandler<MediaTimelineController*, MediaTimelineControllerFailedEventArgs*>* eventHandler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Failed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Ended(Foundation::TypedEventHandler<MediaTimelineController*, IInspectable*>* eventHandler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Ended(Foundation::EventRegistrationToken token);
};
template<typename X> struct IMediaTimelineController2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IMediaTimelineController2_adaptor::Duration)->_get_Duration(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&IMediaTimelineController2_adaptor::Duration)->_put_Duration(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} Duration;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTimelineController2_adaptor::IsLoopingEnabled)->_get_IsLoopingEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTimelineController2_adaptor::IsLoopingEnabled)->_put_IsLoopingEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsLoopingEnabled;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaTimelineController>, object>> eventHandler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaTimelineController2_adaptor::Ended)->_add_Ended(to_abi(eventHandler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaTimelineController2_adaptor::Ended)->_remove_Ended(token)); }
		} Ended;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaTimelineController>, ptr<MediaTimelineControllerFailedEventArgs>>> eventHandler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaTimelineController2_adaptor::Failed)->_add_Failed(to_abi(eventHandler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaTimelineController2_adaptor::Failed)->_remove_Failed(token)); }
		} Failed;
	};
	IMediaTimelineController2_adaptor() {}
};
template<typename X> struct adapt<IMediaTimelineController2, X> : Windows::Media::IMediaTimelineController2_adaptor<X> { typedef adapt IMediaTimelineController2; };
struct IMediaTimelineController2 : IMediaTimelineController2_raw, generate<IMediaTimelineController2> {};

// MediaTimelineController
template<typename X> struct statics<MediaTimelineController, X> : X {
	typedef typename X::root_type MediaTimelineController;
};
struct MediaTimelineController : generate<MediaTimelineController> {};

// IMediaTimelineControllerFailedEventArgs
struct IMediaTimelineControllerFailedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IMediaTimelineControllerFailedEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IMediaTimelineControllerFailedEventArgs_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
	};
	IMediaTimelineControllerFailedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IMediaTimelineControllerFailedEventArgs, X> : Windows::Media::IMediaTimelineControllerFailedEventArgs_adaptor<X> { typedef adapt IMediaTimelineControllerFailedEventArgs; };
struct IMediaTimelineControllerFailedEventArgs : IMediaTimelineControllerFailedEventArgs_raw, generate<IMediaTimelineControllerFailedEventArgs> {};

// MediaTimelineControllerFailedEventArgs
template<typename X> struct statics<MediaTimelineControllerFailedEventArgs, X> : X {
	typedef typename X::root_type MediaTimelineControllerFailedEventArgs;
};
struct MediaTimelineControllerFailedEventArgs : generate<MediaTimelineControllerFailedEventArgs> {};

// IMediaExtension
struct IMediaExtension_raw : IInspectable {
	virtual STDMETHODIMP _SetProperties(Foundation::Collections::IPropertySet* configuration) = 0;
};
template<typename X> struct IMediaExtension_adaptor : X {
	void SetProperties(pptr<Foundation::Collections::IPropertySet> configuration) { hrcheck(X::get()->_SetProperties(configuration)); }
};
template<typename X> struct adapt<IMediaExtension, X> : Windows::Media::IMediaExtension_adaptor<X> { typedef adapt IMediaExtension; };
template<typename X> struct IMediaExtension_unadaptor : X {
	STDMETHODIMP _SetProperties(Foundation::Collections::IPropertySet* configuration) { return hrtry([&, this] { X::get()->SetProperties(configuration); }); }
};
template<typename X> struct unadapt<IMediaExtension, X> : Windows::Media::IMediaExtension_unadaptor<X> {};
struct IMediaExtension : IMediaExtension_raw, generate<IMediaExtension> {};

// IMediaExtensionManager
struct IMediaExtensionManager_raw : IInspectable {
	virtual STDMETHODIMP _RegisterSchemeHandler(HSTRING activatableClassId, HSTRING scheme);
	virtual STDMETHODIMP _RegisterSchemeHandlerWithSettings(HSTRING activatableClassId, HSTRING scheme, Foundation::Collections::IPropertySet* configuration);
	virtual STDMETHODIMP _RegisterByteStreamHandler(HSTRING activatableClassId, HSTRING fileExtension, HSTRING mimeType);
	virtual STDMETHODIMP _RegisterByteStreamHandlerWithSettings(HSTRING activatableClassId, HSTRING fileExtension, HSTRING mimeType, Foundation::Collections::IPropertySet* configuration);
	virtual STDMETHODIMP _RegisterAudioDecoder(HSTRING activatableClassId, Platform::Guid inputSubtype, Platform::Guid outputSubtype);
	virtual STDMETHODIMP _RegisterAudioDecoderWithSettings(HSTRING activatableClassId, Platform::Guid inputSubtype, Platform::Guid outputSubtype, Foundation::Collections::IPropertySet* configuration);
	virtual STDMETHODIMP _RegisterAudioEncoder(HSTRING activatableClassId, Platform::Guid inputSubtype, Platform::Guid outputSubtype);
	virtual STDMETHODIMP _RegisterAudioEncoderWithSettings(HSTRING activatableClassId, Platform::Guid inputSubtype, Platform::Guid outputSubtype, Foundation::Collections::IPropertySet* configuration);
	virtual STDMETHODIMP _RegisterVideoDecoder(HSTRING activatableClassId, Platform::Guid inputSubtype, Platform::Guid outputSubtype);
	virtual STDMETHODIMP _RegisterVideoDecoderWithSettings(HSTRING activatableClassId, Platform::Guid inputSubtype, Platform::Guid outputSubtype, Foundation::Collections::IPropertySet* configuration);
	virtual STDMETHODIMP _RegisterVideoEncoder(HSTRING activatableClassId, Platform::Guid inputSubtype, Platform::Guid outputSubtype);
	virtual STDMETHODIMP _RegisterVideoEncoderWithSettings(HSTRING activatableClassId, Platform::Guid inputSubtype, Platform::Guid outputSubtype, Foundation::Collections::IPropertySet* configuration);
};
template<typename X> struct IMediaExtensionManager_adaptor : X {
	void RegisterSchemeHandler(hstring_ref activatableClassId, hstring_ref scheme) { hrcheck(X::get()->_RegisterSchemeHandler(activatableClassId, scheme)); }
	void RegisterSchemeHandler(hstring_ref activatableClassId, hstring_ref scheme, pptr<Foundation::Collections::IPropertySet> configuration) { hrcheck(X::get()->_RegisterSchemeHandlerWithSettings(activatableClassId, scheme, configuration)); }
	void RegisterByteStreamHandler(hstring_ref activatableClassId, hstring_ref fileExtension, hstring_ref mimeType) { hrcheck(X::get()->_RegisterByteStreamHandler(activatableClassId, fileExtension, mimeType)); }
	void RegisterByteStreamHandler(hstring_ref activatableClassId, hstring_ref fileExtension, hstring_ref mimeType, pptr<Foundation::Collections::IPropertySet> configuration) { hrcheck(X::get()->_RegisterByteStreamHandlerWithSettings(activatableClassId, fileExtension, mimeType, configuration)); }
	void RegisterAudioDecoder(hstring_ref activatableClassId, const Platform::Guid& inputSubtype, const Platform::Guid& outputSubtype) { hrcheck(X::get()->_RegisterAudioDecoder(activatableClassId, inputSubtype, outputSubtype)); }
	void RegisterAudioDecoder(hstring_ref activatableClassId, const Platform::Guid& inputSubtype, const Platform::Guid& outputSubtype, pptr<Foundation::Collections::IPropertySet> configuration) { hrcheck(X::get()->_RegisterAudioDecoderWithSettings(activatableClassId, inputSubtype, outputSubtype, configuration)); }
	void RegisterAudioEncoder(hstring_ref activatableClassId, const Platform::Guid& inputSubtype, const Platform::Guid& outputSubtype) { hrcheck(X::get()->_RegisterAudioEncoder(activatableClassId, inputSubtype, outputSubtype)); }
	void RegisterAudioEncoder(hstring_ref activatableClassId, const Platform::Guid& inputSubtype, const Platform::Guid& outputSubtype, pptr<Foundation::Collections::IPropertySet> configuration) { hrcheck(X::get()->_RegisterAudioEncoderWithSettings(activatableClassId, inputSubtype, outputSubtype, configuration)); }
	void RegisterVideoDecoder(hstring_ref activatableClassId, const Platform::Guid& inputSubtype, const Platform::Guid& outputSubtype) { hrcheck(X::get()->_RegisterVideoDecoder(activatableClassId, inputSubtype, outputSubtype)); }
	void RegisterVideoDecoder(hstring_ref activatableClassId, const Platform::Guid& inputSubtype, const Platform::Guid& outputSubtype, pptr<Foundation::Collections::IPropertySet> configuration) { hrcheck(X::get()->_RegisterVideoDecoderWithSettings(activatableClassId, inputSubtype, outputSubtype, configuration)); }
	void RegisterVideoEncoder(hstring_ref activatableClassId, const Platform::Guid& inputSubtype, const Platform::Guid& outputSubtype) { hrcheck(X::get()->_RegisterVideoEncoder(activatableClassId, inputSubtype, outputSubtype)); }
	void RegisterVideoEncoder(hstring_ref activatableClassId, const Platform::Guid& inputSubtype, const Platform::Guid& outputSubtype, pptr<Foundation::Collections::IPropertySet> configuration) { hrcheck(X::get()->_RegisterVideoEncoderWithSettings(activatableClassId, inputSubtype, outputSubtype, configuration)); }
};
template<typename X> struct adapt<IMediaExtensionManager, X> : Windows::Media::IMediaExtensionManager_adaptor<X> { typedef adapt IMediaExtensionManager; };
struct IMediaExtensionManager : IMediaExtensionManager_raw, generate<IMediaExtensionManager> {};

// IMediaExtensionManager2
struct IMediaExtensionManager2_raw : IInspectable {
	virtual STDMETHODIMP _RegisterMediaExtensionForAppService(IMediaExtension* extension, ApplicationModel::AppService::AppServiceConnection* connection);
};
template<typename X> struct IMediaExtensionManager2_adaptor : X {
	void RegisterMediaExtensionForAppService(pptr<IMediaExtension> extension, pptr<ApplicationModel::AppService::AppServiceConnection> connection) { hrcheck(X::get()->_RegisterMediaExtensionForAppService(extension, connection)); }
};
template<typename X> struct adapt<IMediaExtensionManager2, X> : Windows::Media::IMediaExtensionManager2_adaptor<X> { typedef adapt IMediaExtensionManager2; };
struct IMediaExtensionManager2 : IMediaExtensionManager2_raw, generate<IMediaExtensionManager2> {};

// MediaExtensionManager
template<typename X> struct statics<MediaExtensionManager, X> : X {
	typedef typename X::root_type MediaExtensionManager;
};
struct MediaExtensionManager : generate<MediaExtensionManager> {
	using IMediaExtensionManager::RegisterVideoEncoder;
	using IMediaExtensionManager::RegisterAudioDecoder;
	using IMediaExtensionManager::RegisterVideoDecoder;
	using IMediaExtensionManager::RegisterByteStreamHandler;
	using IMediaExtensionManager::RegisterSchemeHandler;
	using IMediaExtensionManager::RegisterAudioEncoder;
};

// IVideoEffectsStatics
struct IVideoEffectsStatics : IInspectable {
	virtual STDMETHODIMP _get_VideoStabilization(HSTRING *value);
};

// VideoEffects
template<typename> struct VideoEffects_statics {
	static struct _VideoStabilization : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<VideoEffects, IVideoEffectsStatics>()->_get_VideoStabilization(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoStabilization;
};
template<typename X> typename VideoEffects_statics<X>::_VideoStabilization VideoEffects_statics<X>::VideoStabilization;

template<typename X> struct statics<VideoEffects, X> : X, Windows::Media::VideoEffects_statics<void> {
	typedef typename X::root_type VideoEffects;
};
struct VideoEffects : generate<VideoEffects> {};

// IMediaControl
struct IMediaControl : IInspectable {
	virtual STDMETHODIMP _add_SoundLevelChanged(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_SoundLevelChanged(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _add_PlayPressed(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_PlayPressed(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _add_PausePressed(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_PausePressed(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _add_StopPressed(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_StopPressed(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _add_PlayPauseTogglePressed(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_PlayPauseTogglePressed(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _add_RecordPressed(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_RecordPressed(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _add_NextTrackPressed(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_NextTrackPressed(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _add_PreviousTrackPressed(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_PreviousTrackPressed(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _add_FastForwardPressed(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_FastForwardPressed(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _add_RewindPressed(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_RewindPressed(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _add_ChannelUpPressed(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_ChannelUpPressed(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _add_ChannelDownPressed(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_ChannelDownPressed(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _get_SoundLevel(Media::SoundLevel *value);
	virtual STDMETHODIMP _put_TrackName(HSTRING value);
	virtual STDMETHODIMP _get_TrackName(HSTRING *value);
	virtual STDMETHODIMP _put_ArtistName(HSTRING value);
	virtual STDMETHODIMP _get_ArtistName(HSTRING *value);
	virtual STDMETHODIMP _put_IsPlaying(bool value);
	virtual STDMETHODIMP _get_IsPlaying(bool *value);
	virtual STDMETHODIMP _put_AlbumArt(Foundation::Uri* value);
	virtual STDMETHODIMP _get_AlbumArt(Foundation::Uri* *value);
};

// MediaControl
template<typename> struct MediaControl_statics {
	static struct _AlbumArt : property {
		ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_get_AlbumArt(&value)); return from_abi(value); }
		ptr<Foundation::Uri> operator()() { return get(); }
		operator ptr<Foundation::Uri> () { return get(); }
		ptr<Foundation::Uri> operator->() { return get(); }
		void put(pptr<Foundation::Uri> value) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_put_AlbumArt(value)); }
		void operator=(pptr<Foundation::Uri> value) { put(value); }
		void operator()(pptr<Foundation::Uri> value) { put(value); }
	} AlbumArt;
	static struct _ArtistName : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_get_ArtistName(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
		void put(hstring_ref value) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_put_ArtistName(value)); }
		void operator=(hstring_ref value) { put(value); }
		void operator()(hstring_ref value) { put(value); }
	} ArtistName;
	static struct _IsPlaying : property {
		bool get() { bool value; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_get_IsPlaying(&value)); return value; }
		bool operator()() { return get(); }
		operator bool () { return get(); }
		void put(bool value) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_put_IsPlaying(value)); }
		void operator=(bool value) { put(value); }
		void operator()(bool value) { put(value); }
	} IsPlaying;
	static struct _SoundLevel : property {
		Media::SoundLevel get() { Media::SoundLevel value; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_get_SoundLevel(&value)); return value; }
		Media::SoundLevel operator()() { return get(); }
		operator Media::SoundLevel () { return get(); }
	} SoundLevel;
	static struct _TrackName : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_get_TrackName(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
		void put(hstring_ref value) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_put_TrackName(value)); }
		void operator=(hstring_ref value) { put(value); }
		void operator()(hstring_ref value) { put(value); }
	} TrackName;
	static struct _ChannelDownPressed : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_add_ChannelDownPressed(to_abi(handler), &cookie)); return cookie; }
		void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_remove_ChannelDownPressed(cookie)); }
	} ChannelDownPressed;
	static struct _ChannelUpPressed : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_add_ChannelUpPressed(to_abi(handler), &cookie)); return cookie; }
		void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_remove_ChannelUpPressed(cookie)); }
	} ChannelUpPressed;
	static struct _FastForwardPressed : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_add_FastForwardPressed(to_abi(handler), &cookie)); return cookie; }
		void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_remove_FastForwardPressed(cookie)); }
	} FastForwardPressed;
	static struct _NextTrackPressed : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_add_NextTrackPressed(to_abi(handler), &cookie)); return cookie; }
		void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_remove_NextTrackPressed(cookie)); }
	} NextTrackPressed;
	static struct _PausePressed : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_add_PausePressed(to_abi(handler), &cookie)); return cookie; }
		void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_remove_PausePressed(cookie)); }
	} PausePressed;
	static struct _PlayPauseTogglePressed : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_add_PlayPauseTogglePressed(to_abi(handler), &cookie)); return cookie; }
		void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_remove_PlayPauseTogglePressed(cookie)); }
	} PlayPauseTogglePressed;
	static struct _PlayPressed : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_add_PlayPressed(to_abi(handler), &cookie)); return cookie; }
		void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_remove_PlayPressed(cookie)); }
	} PlayPressed;
	static struct _PreviousTrackPressed : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_add_PreviousTrackPressed(to_abi(handler), &cookie)); return cookie; }
		void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_remove_PreviousTrackPressed(cookie)); }
	} PreviousTrackPressed;
	static struct _RecordPressed : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_add_RecordPressed(to_abi(handler), &cookie)); return cookie; }
		void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_remove_RecordPressed(cookie)); }
	} RecordPressed;
	static struct _RewindPressed : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_add_RewindPressed(to_abi(handler), &cookie)); return cookie; }
		void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_remove_RewindPressed(cookie)); }
	} RewindPressed;
	static struct _SoundLevelChanged : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_add_SoundLevelChanged(to_abi(handler), &cookie)); return cookie; }
		void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_remove_SoundLevelChanged(cookie)); }
	} SoundLevelChanged;
	static struct _StopPressed : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_add_StopPressed(to_abi(handler), &cookie)); return cookie; }
		void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(get_activation_factory<MediaControl, IMediaControl>()->_remove_StopPressed(cookie)); }
	} StopPressed;
};
template<typename X> typename MediaControl_statics<X>::_AlbumArt MediaControl_statics<X>::AlbumArt;
template<typename X> typename MediaControl_statics<X>::_ArtistName MediaControl_statics<X>::ArtistName;
template<typename X> typename MediaControl_statics<X>::_IsPlaying MediaControl_statics<X>::IsPlaying;
template<typename X> typename MediaControl_statics<X>::_SoundLevel MediaControl_statics<X>::SoundLevel;
template<typename X> typename MediaControl_statics<X>::_TrackName MediaControl_statics<X>::TrackName;
template<typename X> typename MediaControl_statics<X>::_ChannelDownPressed MediaControl_statics<X>::ChannelDownPressed;
template<typename X> typename MediaControl_statics<X>::_ChannelUpPressed MediaControl_statics<X>::ChannelUpPressed;
template<typename X> typename MediaControl_statics<X>::_FastForwardPressed MediaControl_statics<X>::FastForwardPressed;
template<typename X> typename MediaControl_statics<X>::_NextTrackPressed MediaControl_statics<X>::NextTrackPressed;
template<typename X> typename MediaControl_statics<X>::_PausePressed MediaControl_statics<X>::PausePressed;
template<typename X> typename MediaControl_statics<X>::_PlayPauseTogglePressed MediaControl_statics<X>::PlayPauseTogglePressed;
template<typename X> typename MediaControl_statics<X>::_PlayPressed MediaControl_statics<X>::PlayPressed;
template<typename X> typename MediaControl_statics<X>::_PreviousTrackPressed MediaControl_statics<X>::PreviousTrackPressed;
template<typename X> typename MediaControl_statics<X>::_RecordPressed MediaControl_statics<X>::RecordPressed;
template<typename X> typename MediaControl_statics<X>::_RewindPressed MediaControl_statics<X>::RewindPressed;
template<typename X> typename MediaControl_statics<X>::_SoundLevelChanged MediaControl_statics<X>::SoundLevelChanged;
template<typename X> typename MediaControl_statics<X>::_StopPressed MediaControl_statics<X>::StopPressed;

template<typename X> struct statics<MediaControl, X> : X, Windows::Media::MediaControl_statics<void> {
	typedef typename X::root_type MediaControl;
};
struct MediaControl : generate<MediaControl> {};
}}
} // namespace iso_winrt
