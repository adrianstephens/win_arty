#pragma once
// generated by isopod tools
// namespaces:
// Windows.Data.Xml.Dom

#include "Windows.Data.Xml.Dom.0.h"
#include "Windows.Foundation.Collections.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation {
struct IAsyncAction;
template<typename TResult> struct IAsyncOperation;
struct Uri;
}
namespace Storage { namespace Streams {
struct IBuffer;
}
struct IStorageFile;
}}

// defs

template<> struct def<Windows::Data::Xml::Dom::NodeType> : enum_type<int> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlNodeSelector> : overridable_type<> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlNodeSerializer> : overridable_type<> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlNode> : overridable_type<Windows::Data::Xml::Dom::IXmlNodeSelector, Windows::Data::Xml::Dom::IXmlNodeSerializer> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlNodeList> : interface_type<Windows::Foundation::Collections::IVectorView<ptr<Windows::Data::Xml::Dom::IXmlNode>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Data::Xml::Dom::IXmlNode>>> {};
template<> struct def<Windows::Data::Xml::Dom::XmlNodeList> : class_type<Platform::Object, Windows::Data::Xml::Dom::IXmlNodeList> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlNamedNodeMap> : interface_type<Windows::Foundation::Collections::IVectorView<ptr<Windows::Data::Xml::Dom::IXmlNode>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Data::Xml::Dom::IXmlNode>>> {};
template<> struct def<Windows::Data::Xml::Dom::XmlNamedNodeMap> : class_type<Platform::Object, Windows::Data::Xml::Dom::IXmlNamedNodeMap> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlDocumentStatics> : interface_type<> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlDocumentIO2> : interface_type<> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlDocumentIO> : interface_type<> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlDocument> : interface_type<Windows::Data::Xml::Dom::IXmlNode> {};
template<> struct def<Windows::Data::Xml::Dom::XmlDocument> : class_type<Platform::Object, Windows::Data::Xml::Dom::IXmlDocument, Windows::Data::Xml::Dom::IXmlDocumentIO2, Windows::Data::Xml::Dom::IXmlDocumentIO> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlDomImplementation> : interface_type<> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlDocumentType> : interface_type<Windows::Data::Xml::Dom::IXmlNode> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlAttribute> : interface_type<Windows::Data::Xml::Dom::IXmlNode> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlDocumentFragment> : interface_type<Windows::Data::Xml::Dom::IXmlNode> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlElement> : interface_type<Windows::Data::Xml::Dom::IXmlNode> {};
template<> struct def<Windows::Data::Xml::Dom::XmlAttribute> : class_type<Platform::Object, Windows::Data::Xml::Dom::IXmlAttribute> {};
template<> struct def<Windows::Data::Xml::Dom::IDtdNotation> : interface_type<Windows::Data::Xml::Dom::IXmlNode> {};
template<> struct def<Windows::Data::Xml::Dom::IDtdEntity> : interface_type<Windows::Data::Xml::Dom::IXmlNode> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlEntityReference> : interface_type<Windows::Data::Xml::Dom::IXmlNode> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlProcessingInstruction> : interface_type<Windows::Data::Xml::Dom::IXmlNode> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlCharacterData> : overridable_type<Windows::Data::Xml::Dom::IXmlNode> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlComment> : interface_type<Windows::Data::Xml::Dom::IXmlCharacterData> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlText> : overridable_type<Windows::Data::Xml::Dom::IXmlCharacterData> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlCDataSection> : interface_type<Windows::Data::Xml::Dom::IXmlText> {};
template<> struct def<Windows::Data::Xml::Dom::XmlDocumentType> : class_type<Platform::Object, Windows::Data::Xml::Dom::IXmlDocumentType> {};
template<> struct def<Windows::Data::Xml::Dom::XmlDomImplementation> : class_type<Platform::Object, Windows::Data::Xml::Dom::IXmlDomImplementation> {};
template<> struct def<Windows::Data::Xml::Dom::XmlElement> : class_type<Platform::Object, Windows::Data::Xml::Dom::IXmlElement> {};
template<> struct def<Windows::Data::Xml::Dom::XmlDocumentFragment> : class_type<Platform::Object, Windows::Data::Xml::Dom::IXmlDocumentFragment> {};
template<> struct def<Windows::Data::Xml::Dom::XmlText> : class_type<Platform::Object, Windows::Data::Xml::Dom::IXmlText> {};
template<> struct def<Windows::Data::Xml::Dom::XmlComment> : class_type<Platform::Object, Windows::Data::Xml::Dom::IXmlComment> {};
template<> struct def<Windows::Data::Xml::Dom::XmlProcessingInstruction> : class_type<Platform::Object, Windows::Data::Xml::Dom::IXmlProcessingInstruction> {};
template<> struct def<Windows::Data::Xml::Dom::XmlEntityReference> : class_type<Platform::Object, Windows::Data::Xml::Dom::IXmlEntityReference> {};
template<> struct def<Windows::Data::Xml::Dom::XmlCDataSection> : class_type<Platform::Object, Windows::Data::Xml::Dom::IXmlCDataSection> {};
template<> struct def<Windows::Data::Xml::Dom::IXmlLoadSettings> : interface_type<> {};
template<> struct def<Windows::Data::Xml::Dom::XmlLoadSettings> : class_type<Platform::Object, Windows::Data::Xml::Dom::IXmlLoadSettings> {};
template<> struct def<Windows::Data::Xml::Dom::DtdNotation> : class_type<Platform::Object, Windows::Data::Xml::Dom::IDtdNotation> {};
template<> struct def<Windows::Data::Xml::Dom::DtdEntity> : class_type<Platform::Object, Windows::Data::Xml::Dom::IDtdEntity> {};

// uuids

template<> struct uuid<Windows::Data::Xml::Dom::IXmlNodeSelector> { define_guid(0x63DBBA8B, 0xD0DB, 0x4FE1, 0xB7, 0x45, 0xF9, 0x43, 0x3A, 0xFD, 0xC2, 0x5B);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlNodeSerializer> { define_guid(0x5CC5B382, 0xE6DD, 0x4991, 0xAB, 0xEF, 0x6, 0xD8, 0xD2, 0xE7, 0xBD, 0xC);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlNode> { define_guid(0x1C741D59, 0x2122, 0x47D5, 0xA8, 0x56, 0x83, 0xF3, 0xD4, 0x21, 0x48, 0x75);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlNodeList> { define_guid(0x8C60AD77, 0x83A4, 0x4EC1, 0x9C, 0x54, 0x7B, 0xA4, 0x29, 0xE1, 0x3D, 0xA6);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlNamedNodeMap> { define_guid(0xB3A69EB0, 0xAAB0, 0x4B82, 0xA6, 0xFA, 0xB1, 0x45, 0x3F, 0x7C, 0x2, 0x1B);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlDocumentStatics> { define_guid(0x5543D254, 0xD757, 0x4B79, 0x95, 0x39, 0x23, 0x2B, 0x18, 0xF5, 0xB, 0xF1);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlDocumentIO2> { define_guid(0x5D034661, 0x7BD8, 0x4AD5, 0x9E, 0xBF, 0x81, 0xE6, 0x34, 0x72, 0x63, 0xB1);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlDocumentIO> { define_guid(0x6CD0E74E, 0xEE65, 0x4489, 0x9E, 0xBF, 0xCA, 0x43, 0xE8, 0x7B, 0xA6, 0x37);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlDocument> { define_guid(0xF7F3A506, 0x1E87, 0x42D6, 0xBC, 0xFB, 0xB8, 0xC8, 0x9, 0xFA, 0x54, 0x94);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlDomImplementation> { define_guid(0x6DE58132, 0xF11D, 0x4FBB, 0x8C, 0xC6, 0x58, 0x3C, 0xBA, 0x93, 0x11, 0x2F);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlDocumentType> { define_guid(0xF7342425, 0x9781, 0x4964, 0x8E, 0x94, 0x9B, 0x1C, 0x6D, 0xFC, 0x9B, 0xC7);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlAttribute> { define_guid(0xAC144AA4, 0xB4F1, 0x4DB6, 0xB2, 0x6, 0x8A, 0x22, 0xC3, 0x8, 0xDB, 0xA);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlDocumentFragment> { define_guid(0xE2EA6A96, 0xC21, 0x44A5, 0x8B, 0xC9, 0x9E, 0x4A, 0x26, 0x27, 0x8, 0xEC);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlElement> { define_guid(0x2DFB8A1F, 0x6B10, 0x4EF8, 0x9F, 0x83, 0xEF, 0xCC, 0xE8, 0xFA, 0xEC, 0x37);};
template<> struct uuid<Windows::Data::Xml::Dom::IDtdNotation> { define_guid(0x8CB4E04D, 0x6D46, 0x4EDB, 0xAB, 0x73, 0xDF, 0x83, 0xC5, 0x1A, 0xD3, 0x97);};
template<> struct uuid<Windows::Data::Xml::Dom::IDtdEntity> { define_guid(0x6A0B5FFC, 0x63B4, 0x480F, 0x9E, 0x6A, 0x8A, 0x92, 0x81, 0x6A, 0xAD, 0xE4);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlEntityReference> { define_guid(0x2E2F47BC, 0xC3D0, 0x4CCF, 0xBB, 0x86, 0xA, 0xB8, 0xC3, 0x6A, 0x61, 0xCF);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlProcessingInstruction> { define_guid(0x2707FD1E, 0x1E92, 0x4ECE, 0xB6, 0xF4, 0x26, 0xF0, 0x69, 0x7, 0x8D, 0xDC);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlCharacterData> { define_guid(0x132E42AB, 0x4E36, 0x4DF6, 0xB1, 0xC8, 0xC, 0xE6, 0x2F, 0xD8, 0x8B, 0x26);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlComment> { define_guid(0xBCA474D5, 0xB61F, 0x4611, 0x9C, 0xAC, 0x2E, 0x92, 0xE3, 0x47, 0x6D, 0x47);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlText> { define_guid(0xF931A4CB, 0x308D, 0x4760, 0xA1, 0xD5, 0x43, 0xB6, 0x74, 0x50, 0xAC, 0x7E);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlCDataSection> { define_guid(0x4D04B46F, 0xC8BD, 0x45B4, 0x88, 0x99, 0x4, 0x0, 0xD7, 0xC2, 0xC6, 0xF);};
template<> struct uuid<Windows::Data::Xml::Dom::IXmlLoadSettings> { define_guid(0x58AA07A8, 0xFED6, 0x46F7, 0xB4, 0xC5, 0xFB, 0x1B, 0xA7, 0x21, 0x8, 0xD6);};

// types

namespace Windows { namespace Data { namespace Xml { namespace Dom {

// IXmlNodeSelector
struct IXmlNodeSelector_raw : IInspectable {
	virtual STDMETHODIMP _SelectSingleNode(HSTRING xpath, IXmlNode* *node) = 0;
	virtual STDMETHODIMP _SelectNodes(HSTRING xpath, XmlNodeList* *nodelist) = 0;
	virtual STDMETHODIMP _SelectSingleNodeNS(HSTRING xpath, IInspectable* namespaces, IXmlNode* *node) = 0;
	virtual STDMETHODIMP _SelectNodesNS(HSTRING xpath, IInspectable* namespaces, XmlNodeList* *nodelist) = 0;
};
template<typename X> struct IXmlNodeSelector_adaptor : X {
	ptr<IXmlNode> SelectSingleNode(hstring_ref xpath) { IXmlNode* node; hrcheck(X::get()->_SelectSingleNode(xpath, &node)); return from_abi(node); }
	ptr<XmlNodeList> SelectNodes(hstring_ref xpath) { XmlNodeList* nodelist; hrcheck(X::get()->_SelectNodes(xpath, &nodelist)); return from_abi(nodelist); }
	ptr<IXmlNode> SelectSingleNodeNS(hstring_ref xpath, object_ref namespaces) { IXmlNode* node; hrcheck(X::get()->_SelectSingleNodeNS(xpath, namespaces, &node)); return from_abi(node); }
	ptr<XmlNodeList> SelectNodesNS(hstring_ref xpath, object_ref namespaces) { XmlNodeList* nodelist; hrcheck(X::get()->_SelectNodesNS(xpath, namespaces, &nodelist)); return from_abi(nodelist); }
};
template<typename X> struct adapt<IXmlNodeSelector, X> : Windows::Data::Xml::Dom::IXmlNodeSelector_adaptor<X> { typedef adapt IXmlNodeSelector; };
template<typename X> struct IXmlNodeSelector_unadaptor : X {
	STDMETHODIMP _SelectSingleNode(HSTRING xpath, IXmlNode* *node) { return hrtry([&, this] { *node = to_abi(X::get()->SelectSingleNode(xpath)); }); }
	STDMETHODIMP _SelectNodes(HSTRING xpath, XmlNodeList* *nodelist) { return hrtry([&, this] { *nodelist = to_abi(X::get()->SelectNodes(xpath)); }); }
	STDMETHODIMP _SelectSingleNodeNS(HSTRING xpath, IInspectable* namespaces, IXmlNode* *node) { return hrtry([&, this] { *node = to_abi(X::get()->SelectSingleNodeNS(xpath, namespaces)); }); }
	STDMETHODIMP _SelectNodesNS(HSTRING xpath, IInspectable* namespaces, XmlNodeList* *nodelist) { return hrtry([&, this] { *nodelist = to_abi(X::get()->SelectNodesNS(xpath, namespaces)); }); }
};
template<typename X> struct unadapt<IXmlNodeSelector, X> : Windows::Data::Xml::Dom::IXmlNodeSelector_unadaptor<X> {};
struct IXmlNodeSelector : IXmlNodeSelector_raw, generate<IXmlNodeSelector> {};

// IXmlNodeSerializer
struct IXmlNodeSerializer_raw : IInspectable {
	virtual STDMETHODIMP _GetXml(HSTRING *outerXml) = 0;
	virtual STDMETHODIMP _get_InnerText(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_InnerText(HSTRING value) = 0;
};
template<typename X> struct IXmlNodeSerializer_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IXmlNodeSerializer_adaptor::InnerText)->_get_InnerText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IXmlNodeSerializer_adaptor::InnerText)->_put_InnerText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} InnerText;
	};
	hstring GetXml() { HSTRING outerXml; hrcheck(X::get()->_GetXml(&outerXml)); return from_abi(outerXml); }
	IXmlNodeSerializer_adaptor() {}
};
template<typename X> struct adapt<IXmlNodeSerializer, X> : Windows::Data::Xml::Dom::IXmlNodeSerializer_adaptor<X> { typedef adapt IXmlNodeSerializer; };
template<typename X> struct IXmlNodeSerializer_unadaptor : X {
	STDMETHODIMP _GetXml(HSTRING *outerXml) { return hrtry([&, this] { *outerXml = to_abi(X::get()->GetXml()); }); }
	STDMETHODIMP _get_InnerText(HSTRING *value) { return hrtry([&, this] { get_prop(value, InnerText); }); }
	STDMETHODIMP _put_InnerText(HSTRING value) { return hrtry([&, this] { put_prop(value, InnerText); }); }
};
template<typename X> struct unadapt<IXmlNodeSerializer, X> : Windows::Data::Xml::Dom::IXmlNodeSerializer_unadaptor<X> {};
struct IXmlNodeSerializer : IXmlNodeSerializer_raw, generate<IXmlNodeSerializer> {};

// IXmlNode
struct IXmlNode_raw : IInspectable {
	virtual STDMETHODIMP _get_NodeValue(IInspectable* *value) = 0;
	virtual STDMETHODIMP _put_NodeValue(IInspectable* value) = 0;
	virtual STDMETHODIMP _get_NodeType(Dom::NodeType *value) = 0;
	virtual STDMETHODIMP _get_NodeName(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_ParentNode(IXmlNode* *value) = 0;
	virtual STDMETHODIMP _get_ChildNodes(XmlNodeList* *value) = 0;
	virtual STDMETHODIMP _get_FirstChild(IXmlNode* *value) = 0;
	virtual STDMETHODIMP _get_LastChild(IXmlNode* *value) = 0;
	virtual STDMETHODIMP _get_PreviousSibling(IXmlNode* *value) = 0;
	virtual STDMETHODIMP _get_NextSibling(IXmlNode* *value) = 0;
	virtual STDMETHODIMP _get_Attributes(XmlNamedNodeMap* *value) = 0;
	virtual STDMETHODIMP _HasChildNodes(bool *value) = 0;
	virtual STDMETHODIMP _get_OwnerDocument(XmlDocument* *value) = 0;
	virtual STDMETHODIMP _InsertBefore(IXmlNode* newChild, IXmlNode* referenceChild, IXmlNode* *insertedChild) = 0;
	virtual STDMETHODIMP _ReplaceChild(IXmlNode* newChild, IXmlNode* referenceChild, IXmlNode* *previousChild) = 0;
	virtual STDMETHODIMP _RemoveChild(IXmlNode* childNode, IXmlNode* *removedChild) = 0;
	virtual STDMETHODIMP _AppendChild(IXmlNode* newChild, IXmlNode* *appendedChild) = 0;
	virtual STDMETHODIMP _CloneNode(bool deep, IXmlNode* *newNode) = 0;
	virtual STDMETHODIMP _get_NamespaceUri(IInspectable* *value) = 0;
	virtual STDMETHODIMP _get_LocalName(IInspectable* *value) = 0;
	virtual STDMETHODIMP _get_Prefix(IInspectable* *value) = 0;
	virtual STDMETHODIMP _Normalize() = 0;
	virtual STDMETHODIMP _put_Prefix(IInspectable* value) = 0;
};
template<typename X> struct IXmlNode_adaptor : X {
	union {
		struct : property {
			ptr<XmlNamedNodeMap> get() { XmlNamedNodeMap* value; hrcheck(enc(&IXmlNode_adaptor::Attributes)->_get_Attributes(&value)); return from_abi(value); }
			ptr<XmlNamedNodeMap> operator()() { return get(); }
			operator ptr<XmlNamedNodeMap> () { return get(); }
			ptr<XmlNamedNodeMap> operator->() { return get(); }
		} Attributes;
		struct : property {
			ptr<XmlNodeList> get() { XmlNodeList* value; hrcheck(enc(&IXmlNode_adaptor::ChildNodes)->_get_ChildNodes(&value)); return from_abi(value); }
			ptr<XmlNodeList> operator()() { return get(); }
			operator ptr<XmlNodeList> () { return get(); }
			ptr<XmlNodeList> operator->() { return get(); }
		} ChildNodes;
		struct : property {
			ptr<IXmlNode> get() { IXmlNode* value; hrcheck(enc(&IXmlNode_adaptor::FirstChild)->_get_FirstChild(&value)); return from_abi(value); }
			ptr<IXmlNode> operator()() { return get(); }
			operator ptr<IXmlNode> () { return get(); }
			ptr<IXmlNode> operator->() { return get(); }
		} FirstChild;
		struct : property {
			ptr<IXmlNode> get() { IXmlNode* value; hrcheck(enc(&IXmlNode_adaptor::LastChild)->_get_LastChild(&value)); return from_abi(value); }
			ptr<IXmlNode> operator()() { return get(); }
			operator ptr<IXmlNode> () { return get(); }
			ptr<IXmlNode> operator->() { return get(); }
		} LastChild;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IXmlNode_adaptor::LocalName)->_get_LocalName(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} LocalName;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IXmlNode_adaptor::NamespaceUri)->_get_NamespaceUri(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} NamespaceUri;
		struct : property {
			ptr<IXmlNode> get() { IXmlNode* value; hrcheck(enc(&IXmlNode_adaptor::NextSibling)->_get_NextSibling(&value)); return from_abi(value); }
			ptr<IXmlNode> operator()() { return get(); }
			operator ptr<IXmlNode> () { return get(); }
			ptr<IXmlNode> operator->() { return get(); }
		} NextSibling;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IXmlNode_adaptor::NodeName)->_get_NodeName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} NodeName;
		struct : property {
			Dom::NodeType get() { Dom::NodeType value; hrcheck(enc(&IXmlNode_adaptor::NodeType)->_get_NodeType(&value)); return value; }
			Dom::NodeType operator()() { return get(); }
			operator Dom::NodeType () { return get(); }
		} NodeType;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IXmlNode_adaptor::NodeValue)->_get_NodeValue(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IXmlNode_adaptor::NodeValue)->_put_NodeValue(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} NodeValue;
		struct : property {
			ptr<XmlDocument> get() { XmlDocument* value; hrcheck(enc(&IXmlNode_adaptor::OwnerDocument)->_get_OwnerDocument(&value)); return from_abi(value); }
			ptr<XmlDocument> operator()() { return get(); }
			operator ptr<XmlDocument> () { return get(); }
			ptr<XmlDocument> operator->() { return get(); }
		} OwnerDocument;
		struct : property {
			ptr<IXmlNode> get() { IXmlNode* value; hrcheck(enc(&IXmlNode_adaptor::ParentNode)->_get_ParentNode(&value)); return from_abi(value); }
			ptr<IXmlNode> operator()() { return get(); }
			operator ptr<IXmlNode> () { return get(); }
			ptr<IXmlNode> operator->() { return get(); }
		} ParentNode;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IXmlNode_adaptor::Prefix)->_get_Prefix(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IXmlNode_adaptor::Prefix)->_put_Prefix(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Prefix;
		struct : property {
			ptr<IXmlNode> get() { IXmlNode* value; hrcheck(enc(&IXmlNode_adaptor::PreviousSibling)->_get_PreviousSibling(&value)); return from_abi(value); }
			ptr<IXmlNode> operator()() { return get(); }
			operator ptr<IXmlNode> () { return get(); }
			ptr<IXmlNode> operator->() { return get(); }
		} PreviousSibling;
	};
	bool HasChildNodes() { bool value; hrcheck(X::get()->_HasChildNodes(&value)); return value; }
	ptr<IXmlNode> InsertBefore(pptr<IXmlNode> newChild, pptr<IXmlNode> referenceChild) { IXmlNode* insertedChild; hrcheck(X::get()->_InsertBefore(newChild, referenceChild, &insertedChild)); return from_abi(insertedChild); }
	ptr<IXmlNode> ReplaceChild(pptr<IXmlNode> newChild, pptr<IXmlNode> referenceChild) { IXmlNode* previousChild; hrcheck(X::get()->_ReplaceChild(newChild, referenceChild, &previousChild)); return from_abi(previousChild); }
	ptr<IXmlNode> RemoveChild(pptr<IXmlNode> childNode) { IXmlNode* removedChild; hrcheck(X::get()->_RemoveChild(childNode, &removedChild)); return from_abi(removedChild); }
	ptr<IXmlNode> AppendChild(pptr<IXmlNode> newChild) { IXmlNode* appendedChild; hrcheck(X::get()->_AppendChild(newChild, &appendedChild)); return from_abi(appendedChild); }
	ptr<IXmlNode> CloneNode(bool deep) { IXmlNode* newNode; hrcheck(X::get()->_CloneNode(deep, &newNode)); return from_abi(newNode); }
	void Normalize() { hrcheck(X::get()->_Normalize()); }
	IXmlNode_adaptor() {}
};
template<typename X> struct adapt<IXmlNode, X> : Windows::Data::Xml::Dom::IXmlNode_adaptor<X> { typedef adapt IXmlNode; };
template<typename X> struct IXmlNode_unadaptor : X {
	STDMETHODIMP _get_NodeValue(IInspectable* *value) { return hrtry([&, this] { get_prop(value, NodeValue); }); }
	STDMETHODIMP _put_NodeValue(IInspectable* value) { return hrtry([&, this] { put_prop(value, NodeValue); }); }
	STDMETHODIMP _get_NodeType(Dom::NodeType *value) { return hrtry([&, this] { get_prop(value, NodeType); }); }
	STDMETHODIMP _get_NodeName(HSTRING *value) { return hrtry([&, this] { get_prop(value, NodeName); }); }
	STDMETHODIMP _get_ParentNode(IXmlNode* *value) { return hrtry([&, this] { get_prop(value, ParentNode); }); }
	STDMETHODIMP _get_ChildNodes(XmlNodeList* *value) { return hrtry([&, this] { get_prop(value, ChildNodes); }); }
	STDMETHODIMP _get_FirstChild(IXmlNode* *value) { return hrtry([&, this] { get_prop(value, FirstChild); }); }
	STDMETHODIMP _get_LastChild(IXmlNode* *value) { return hrtry([&, this] { get_prop(value, LastChild); }); }
	STDMETHODIMP _get_PreviousSibling(IXmlNode* *value) { return hrtry([&, this] { get_prop(value, PreviousSibling); }); }
	STDMETHODIMP _get_NextSibling(IXmlNode* *value) { return hrtry([&, this] { get_prop(value, NextSibling); }); }
	STDMETHODIMP _get_Attributes(XmlNamedNodeMap* *value) { return hrtry([&, this] { get_prop(value, Attributes); }); }
	STDMETHODIMP _HasChildNodes(bool *value) { return hrtry([&, this] { *value = X::get()->HasChildNodes(); }); }
	STDMETHODIMP _get_OwnerDocument(XmlDocument* *value) { return hrtry([&, this] { get_prop(value, OwnerDocument); }); }
	STDMETHODIMP _InsertBefore(IXmlNode* newChild, IXmlNode* referenceChild, IXmlNode* *insertedChild) { return hrtry([&, this] { *insertedChild = to_abi(X::get()->InsertBefore(newChild, referenceChild)); }); }
	STDMETHODIMP _ReplaceChild(IXmlNode* newChild, IXmlNode* referenceChild, IXmlNode* *previousChild) { return hrtry([&, this] { *previousChild = to_abi(X::get()->ReplaceChild(newChild, referenceChild)); }); }
	STDMETHODIMP _RemoveChild(IXmlNode* childNode, IXmlNode* *removedChild) { return hrtry([&, this] { *removedChild = to_abi(X::get()->RemoveChild(childNode)); }); }
	STDMETHODIMP _AppendChild(IXmlNode* newChild, IXmlNode* *appendedChild) { return hrtry([&, this] { *appendedChild = to_abi(X::get()->AppendChild(newChild)); }); }
	STDMETHODIMP _CloneNode(bool deep, IXmlNode* *newNode) { return hrtry([&, this] { *newNode = to_abi(X::get()->CloneNode(deep)); }); }
	STDMETHODIMP _get_NamespaceUri(IInspectable* *value) { return hrtry([&, this] { get_prop(value, NamespaceUri); }); }
	STDMETHODIMP _get_LocalName(IInspectable* *value) { return hrtry([&, this] { get_prop(value, LocalName); }); }
	STDMETHODIMP _get_Prefix(IInspectable* *value) { return hrtry([&, this] { get_prop(value, Prefix); }); }
	STDMETHODIMP _Normalize() { return hrtry([&, this] { X::get()->Normalize(); }); }
	STDMETHODIMP _put_Prefix(IInspectable* value) { return hrtry([&, this] { put_prop(value, Prefix); }); }
};
template<typename X> struct unadapt<IXmlNode, X> : Windows::Data::Xml::Dom::IXmlNode_unadaptor<X> {};
struct IXmlNode : IXmlNode_raw, generate<IXmlNode> {};

// IXmlNodeList
struct IXmlNodeList_raw : IInspectable {
	virtual STDMETHODIMP _get_Length(unsigned *value);
	virtual STDMETHODIMP _Item(unsigned index, IXmlNode* *node);
};
template<typename X> struct IXmlNodeList_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IXmlNodeList_adaptor::Length)->_get_Length(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Length;
	};
	ptr<IXmlNode> Item(unsigned index) { IXmlNode* node; hrcheck(X::get()->_Item(index, &node)); return from_abi(node); }
	IXmlNodeList_adaptor() {}
};
template<typename X> struct adapt<IXmlNodeList, X> : Windows::Data::Xml::Dom::IXmlNodeList_adaptor<X> { typedef adapt IXmlNodeList; };
struct IXmlNodeList : IXmlNodeList_raw, generate<IXmlNodeList> {};

// XmlNodeList
template<typename X> struct statics<XmlNodeList, X> : X {
	typedef typename X::root_type XmlNodeList;
};
struct XmlNodeList : generate<XmlNodeList> {};

// IXmlNamedNodeMap
struct IXmlNamedNodeMap_raw : IInspectable {
	virtual STDMETHODIMP _get_Length(unsigned *value);
	virtual STDMETHODIMP _Item(unsigned index, IXmlNode* *node);
	virtual STDMETHODIMP _GetNamedItem(HSTRING name, IXmlNode* *node);
	virtual STDMETHODIMP _SetNamedItem(IXmlNode* node, IXmlNode* *previousNode);
	virtual STDMETHODIMP _RemoveNamedItem(HSTRING name, IXmlNode* *previousNode);
	virtual STDMETHODIMP _GetNamedItemNS(IInspectable* namespaceUri, HSTRING name, IXmlNode* *node);
	virtual STDMETHODIMP _RemoveNamedItemNS(IInspectable* namespaceUri, HSTRING name, IXmlNode* *previousNode);
	virtual STDMETHODIMP _SetNamedItemNS(IXmlNode* node, IXmlNode* *previousNode);
};
template<typename X> struct IXmlNamedNodeMap_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IXmlNamedNodeMap_adaptor::Length)->_get_Length(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Length;
	};
	ptr<IXmlNode> Item(unsigned index) { IXmlNode* node; hrcheck(X::get()->_Item(index, &node)); return from_abi(node); }
	ptr<IXmlNode> GetNamedItem(hstring_ref name) { IXmlNode* node; hrcheck(X::get()->_GetNamedItem(name, &node)); return from_abi(node); }
	ptr<IXmlNode> SetNamedItem(pptr<IXmlNode> node) { IXmlNode* previousNode; hrcheck(X::get()->_SetNamedItem(node, &previousNode)); return from_abi(previousNode); }
	ptr<IXmlNode> RemoveNamedItem(hstring_ref name) { IXmlNode* previousNode; hrcheck(X::get()->_RemoveNamedItem(name, &previousNode)); return from_abi(previousNode); }
	ptr<IXmlNode> GetNamedItemNS(object_ref namespaceUri, hstring_ref name) { IXmlNode* node; hrcheck(X::get()->_GetNamedItemNS(namespaceUri, name, &node)); return from_abi(node); }
	ptr<IXmlNode> RemoveNamedItemNS(object_ref namespaceUri, hstring_ref name) { IXmlNode* previousNode; hrcheck(X::get()->_RemoveNamedItemNS(namespaceUri, name, &previousNode)); return from_abi(previousNode); }
	ptr<IXmlNode> SetNamedItemNS(pptr<IXmlNode> node) { IXmlNode* previousNode; hrcheck(X::get()->_SetNamedItemNS(node, &previousNode)); return from_abi(previousNode); }
	IXmlNamedNodeMap_adaptor() {}
};
template<typename X> struct adapt<IXmlNamedNodeMap, X> : Windows::Data::Xml::Dom::IXmlNamedNodeMap_adaptor<X> { typedef adapt IXmlNamedNodeMap; };
struct IXmlNamedNodeMap : IXmlNamedNodeMap_raw, generate<IXmlNamedNodeMap> {};

// XmlNamedNodeMap
template<typename X> struct statics<XmlNamedNodeMap, X> : X {
	typedef typename X::root_type XmlNamedNodeMap;
};
struct XmlNamedNodeMap : generate<XmlNamedNodeMap> {};

// IXmlDocumentStatics
struct IXmlDocumentStatics : IInspectable {
	virtual STDMETHODIMP _LoadFromUriAsync(Foundation::Uri* uri, Foundation::IAsyncOperation<XmlDocument*>* *asyncInfo);
	virtual STDMETHODIMP _LoadFromUriWithSettingsAsync(Foundation::Uri* uri, XmlLoadSettings* loadSettings, Foundation::IAsyncOperation<XmlDocument*>* *asyncInfo);
	virtual STDMETHODIMP _LoadFromFileAsync(Storage::IStorageFile* file, Foundation::IAsyncOperation<XmlDocument*>* *asyncInfo);
	virtual STDMETHODIMP _LoadFromFileWithSettingsAsync(Storage::IStorageFile* file, XmlLoadSettings* loadSettings, Foundation::IAsyncOperation<XmlDocument*>* *asyncInfo);
};

// IXmlDocumentIO2
struct IXmlDocumentIO2_raw : IInspectable {
	virtual STDMETHODIMP _LoadXmlFromBuffer(Storage::Streams::IBuffer* buffer);
	virtual STDMETHODIMP _LoadXmlFromBufferWithSettings(Storage::Streams::IBuffer* buffer, XmlLoadSettings* loadSettings);
};
template<typename X> struct IXmlDocumentIO2_adaptor : X {
	void LoadXmlFromBuffer(pptr<Storage::Streams::IBuffer> buffer) { hrcheck(X::get()->_LoadXmlFromBuffer(buffer)); }
	void LoadXmlFromBuffer(pptr<Storage::Streams::IBuffer> buffer, pptr<XmlLoadSettings> loadSettings) { hrcheck(X::get()->_LoadXmlFromBufferWithSettings(buffer, loadSettings)); }
};
template<typename X> struct adapt<IXmlDocumentIO2, X> : Windows::Data::Xml::Dom::IXmlDocumentIO2_adaptor<X> { typedef adapt IXmlDocumentIO2; };
struct IXmlDocumentIO2 : IXmlDocumentIO2_raw, generate<IXmlDocumentIO2> {};

// IXmlDocumentIO
struct IXmlDocumentIO_raw : IInspectable {
	virtual STDMETHODIMP _LoadXml(HSTRING xml);
	virtual STDMETHODIMP _LoadXmlWithSettings(HSTRING xml, XmlLoadSettings* loadSettings);
	virtual STDMETHODIMP _SaveToFileAsync(Storage::IStorageFile* file, Foundation::IAsyncAction* *asyncInfo);
};
template<typename X> struct IXmlDocumentIO_adaptor : X {
	void LoadXml(hstring_ref xml) { hrcheck(X::get()->_LoadXml(xml)); }
	void LoadXml(hstring_ref xml, pptr<XmlLoadSettings> loadSettings) { hrcheck(X::get()->_LoadXmlWithSettings(xml, loadSettings)); }
	ptr<Foundation::IAsyncAction> SaveToFileAsync(pptr<Storage::IStorageFile> file) { Foundation::IAsyncAction* asyncInfo; hrcheck(X::get()->_SaveToFileAsync(file, &asyncInfo)); return from_abi(asyncInfo); }
};
template<typename X> struct adapt<IXmlDocumentIO, X> : Windows::Data::Xml::Dom::IXmlDocumentIO_adaptor<X> { typedef adapt IXmlDocumentIO; };
struct IXmlDocumentIO : IXmlDocumentIO_raw, generate<IXmlDocumentIO> {};

// IXmlDocument
struct IXmlDocument_raw : IInspectable {
	virtual STDMETHODIMP _get_Doctype(XmlDocumentType* *value);
	virtual STDMETHODIMP _get_Implementation(XmlDomImplementation* *value);
	virtual STDMETHODIMP _get_DocumentElement(XmlElement* *value);
	virtual STDMETHODIMP _CreateElement(HSTRING tagName, XmlElement* *newElement);
	virtual STDMETHODIMP _CreateDocumentFragment(XmlDocumentFragment* *newDocumentFragment);
	virtual STDMETHODIMP _CreateTextNode(HSTRING data, XmlText* *newTextNode);
	virtual STDMETHODIMP _CreateComment(HSTRING data, XmlComment* *newComment);
	virtual STDMETHODIMP _CreateProcessingInstruction(HSTRING target, HSTRING data, XmlProcessingInstruction* *newProcessingInstruction);
	virtual STDMETHODIMP _CreateAttribute(HSTRING name, XmlAttribute* *newAttribute);
	virtual STDMETHODIMP _CreateEntityReference(HSTRING name, XmlEntityReference* *newEntityReference);
	virtual STDMETHODIMP _GetElementsByTagName(HSTRING tagName, XmlNodeList* *elements);
	virtual STDMETHODIMP _CreateCDataSection(HSTRING data, XmlCDataSection* *newCDataSection);
	virtual STDMETHODIMP _get_DocumentUri(HSTRING *value);
	virtual STDMETHODIMP _CreateAttributeNS(IInspectable* namespaceUri, HSTRING qualifiedName, XmlAttribute* *newAttribute);
	virtual STDMETHODIMP _CreateElementNS(IInspectable* namespaceUri, HSTRING qualifiedName, XmlElement* *newElement);
	virtual STDMETHODIMP _GetElementById(HSTRING elementId, XmlElement* *element);
	virtual STDMETHODIMP _ImportNode(IXmlNode* node, bool deep, IXmlNode* *newNode);
};
template<typename X> struct IXmlDocument_adaptor : X {
	union {
		struct : property {
			ptr<XmlDocumentType> get() { XmlDocumentType* value; hrcheck(enc(&IXmlDocument_adaptor::Doctype)->_get_Doctype(&value)); return from_abi(value); }
			ptr<XmlDocumentType> operator()() { return get(); }
			operator ptr<XmlDocumentType> () { return get(); }
			ptr<XmlDocumentType> operator->() { return get(); }
		} Doctype;
		struct : property {
			ptr<XmlElement> get() { XmlElement* value; hrcheck(enc(&IXmlDocument_adaptor::DocumentElement)->_get_DocumentElement(&value)); return from_abi(value); }
			ptr<XmlElement> operator()() { return get(); }
			operator ptr<XmlElement> () { return get(); }
			ptr<XmlElement> operator->() { return get(); }
		} DocumentElement;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IXmlDocument_adaptor::DocumentUri)->_get_DocumentUri(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DocumentUri;
		struct : property {
			ptr<XmlDomImplementation> get() { XmlDomImplementation* value; hrcheck(enc(&IXmlDocument_adaptor::Implementation)->_get_Implementation(&value)); return from_abi(value); }
			ptr<XmlDomImplementation> operator()() { return get(); }
			operator ptr<XmlDomImplementation> () { return get(); }
			ptr<XmlDomImplementation> operator->() { return get(); }
		} Implementation;
	};
	ptr<XmlElement> CreateElement(hstring_ref tagName) { XmlElement* newElement; hrcheck(X::get()->_CreateElement(tagName, &newElement)); return from_abi(newElement); }
	ptr<XmlDocumentFragment> CreateDocumentFragment() { XmlDocumentFragment* newDocumentFragment; hrcheck(X::get()->_CreateDocumentFragment(&newDocumentFragment)); return from_abi(newDocumentFragment); }
	ptr<XmlText> CreateTextNode(hstring_ref data) { XmlText* newTextNode; hrcheck(X::get()->_CreateTextNode(data, &newTextNode)); return from_abi(newTextNode); }
	ptr<XmlComment> CreateComment(hstring_ref data) { XmlComment* newComment; hrcheck(X::get()->_CreateComment(data, &newComment)); return from_abi(newComment); }
	ptr<XmlProcessingInstruction> CreateProcessingInstruction(hstring_ref target, hstring_ref data) { XmlProcessingInstruction* newProcessingInstruction; hrcheck(X::get()->_CreateProcessingInstruction(target, data, &newProcessingInstruction)); return from_abi(newProcessingInstruction); }
	ptr<XmlAttribute> CreateAttribute(hstring_ref name) { XmlAttribute* newAttribute; hrcheck(X::get()->_CreateAttribute(name, &newAttribute)); return from_abi(newAttribute); }
	ptr<XmlEntityReference> CreateEntityReference(hstring_ref name) { XmlEntityReference* newEntityReference; hrcheck(X::get()->_CreateEntityReference(name, &newEntityReference)); return from_abi(newEntityReference); }
	ptr<XmlNodeList> GetElementsByTagName(hstring_ref tagName) { XmlNodeList* elements; hrcheck(X::get()->_GetElementsByTagName(tagName, &elements)); return from_abi(elements); }
	ptr<XmlCDataSection> CreateCDataSection(hstring_ref data) { XmlCDataSection* newCDataSection; hrcheck(X::get()->_CreateCDataSection(data, &newCDataSection)); return from_abi(newCDataSection); }
	ptr<XmlAttribute> CreateAttributeNS(object_ref namespaceUri, hstring_ref qualifiedName) { XmlAttribute* newAttribute; hrcheck(X::get()->_CreateAttributeNS(namespaceUri, qualifiedName, &newAttribute)); return from_abi(newAttribute); }
	ptr<XmlElement> CreateElementNS(object_ref namespaceUri, hstring_ref qualifiedName) { XmlElement* newElement; hrcheck(X::get()->_CreateElementNS(namespaceUri, qualifiedName, &newElement)); return from_abi(newElement); }
	ptr<XmlElement> GetElementById(hstring_ref elementId) { XmlElement* element; hrcheck(X::get()->_GetElementById(elementId, &element)); return from_abi(element); }
	ptr<IXmlNode> ImportNode(pptr<IXmlNode> node, bool deep) { IXmlNode* newNode; hrcheck(X::get()->_ImportNode(node, deep, &newNode)); return from_abi(newNode); }
	IXmlDocument_adaptor() {}
};
template<typename X> struct adapt<IXmlDocument, X> : Windows::Data::Xml::Dom::IXmlDocument_adaptor<X> { typedef adapt IXmlDocument; };
struct IXmlDocument : IXmlDocument_raw, generate<IXmlDocument> {};

// XmlDocument
template<typename> struct XmlDocument_statics {
	static ptr<Foundation::IAsyncOperation<ptr<XmlDocument>>> LoadFromUriAsync(pptr<Foundation::Uri> uri) { Foundation::IAsyncOperation<XmlDocument*>* asyncInfo; hrcheck(get_activation_factory<XmlDocument, IXmlDocumentStatics>()->_LoadFromUriAsync(uri, &asyncInfo)); return from_abi(asyncInfo); }
	static ptr<Foundation::IAsyncOperation<ptr<XmlDocument>>> LoadFromUriAsync(pptr<Foundation::Uri> uri, pptr<XmlLoadSettings> loadSettings) { Foundation::IAsyncOperation<XmlDocument*>* asyncInfo; hrcheck(get_activation_factory<XmlDocument, IXmlDocumentStatics>()->_LoadFromUriWithSettingsAsync(uri, loadSettings, &asyncInfo)); return from_abi(asyncInfo); }
	static ptr<Foundation::IAsyncOperation<ptr<XmlDocument>>> LoadFromFileAsync(pptr<Storage::IStorageFile> file) { Foundation::IAsyncOperation<XmlDocument*>* asyncInfo; hrcheck(get_activation_factory<XmlDocument, IXmlDocumentStatics>()->_LoadFromFileAsync(file, &asyncInfo)); return from_abi(asyncInfo); }
	static ptr<Foundation::IAsyncOperation<ptr<XmlDocument>>> LoadFromFileAsync(pptr<Storage::IStorageFile> file, pptr<XmlLoadSettings> loadSettings) { Foundation::IAsyncOperation<XmlDocument*>* asyncInfo; hrcheck(get_activation_factory<XmlDocument, IXmlDocumentStatics>()->_LoadFromFileWithSettingsAsync(file, loadSettings, &asyncInfo)); return from_abi(asyncInfo); }
};

template<typename X> struct statics<XmlDocument, X> : X, Windows::Data::Xml::Dom::XmlDocument_statics<void> {
	typedef typename X::root_type XmlDocument;
};
struct XmlDocument : generate<XmlDocument> {
	using IXmlDocumentIO::LoadXml;
	using IXmlDocumentIO2::LoadXmlFromBuffer;
};

// IXmlDomImplementation
struct IXmlDomImplementation_raw : IInspectable {
	virtual STDMETHODIMP _HasFeature(HSTRING feature, IInspectable* version, bool *featureSupported);
};
template<typename X> struct IXmlDomImplementation_adaptor : X {
	bool HasFeature(hstring_ref feature, object_ref version) { bool featureSupported; hrcheck(X::get()->_HasFeature(feature, version, &featureSupported)); return featureSupported; }
};
template<typename X> struct adapt<IXmlDomImplementation, X> : Windows::Data::Xml::Dom::IXmlDomImplementation_adaptor<X> { typedef adapt IXmlDomImplementation; };
struct IXmlDomImplementation : IXmlDomImplementation_raw, generate<IXmlDomImplementation> {};

// IXmlDocumentType
struct IXmlDocumentType_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_Entities(XmlNamedNodeMap* *value);
	virtual STDMETHODIMP _get_Notations(XmlNamedNodeMap* *value);
};
template<typename X> struct IXmlDocumentType_adaptor : X {
	union {
		struct : property {
			ptr<XmlNamedNodeMap> get() { XmlNamedNodeMap* value; hrcheck(enc(&IXmlDocumentType_adaptor::Entities)->_get_Entities(&value)); return from_abi(value); }
			ptr<XmlNamedNodeMap> operator()() { return get(); }
			operator ptr<XmlNamedNodeMap> () { return get(); }
			ptr<XmlNamedNodeMap> operator->() { return get(); }
		} Entities;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IXmlDocumentType_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			ptr<XmlNamedNodeMap> get() { XmlNamedNodeMap* value; hrcheck(enc(&IXmlDocumentType_adaptor::Notations)->_get_Notations(&value)); return from_abi(value); }
			ptr<XmlNamedNodeMap> operator()() { return get(); }
			operator ptr<XmlNamedNodeMap> () { return get(); }
			ptr<XmlNamedNodeMap> operator->() { return get(); }
		} Notations;
	};
	IXmlDocumentType_adaptor() {}
};
template<typename X> struct adapt<IXmlDocumentType, X> : Windows::Data::Xml::Dom::IXmlDocumentType_adaptor<X> { typedef adapt IXmlDocumentType; };
struct IXmlDocumentType : IXmlDocumentType_raw, generate<IXmlDocumentType> {};

// IXmlAttribute
struct IXmlAttribute_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_Specified(bool *value);
	virtual STDMETHODIMP _get_Value(HSTRING *value);
	virtual STDMETHODIMP _put_Value(HSTRING value);
};
template<typename X> struct IXmlAttribute_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IXmlAttribute_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IXmlAttribute_adaptor::Specified)->_get_Specified(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Specified;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IXmlAttribute_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IXmlAttribute_adaptor::Value)->_put_Value(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Value;
	};
	IXmlAttribute_adaptor() {}
};
template<typename X> struct adapt<IXmlAttribute, X> : Windows::Data::Xml::Dom::IXmlAttribute_adaptor<X> { typedef adapt IXmlAttribute; };
struct IXmlAttribute : IXmlAttribute_raw, generate<IXmlAttribute> {};

// IXmlDocumentFragment
struct IXmlDocumentFragment : IInspectable, generate<IXmlDocumentFragment> {};

// IXmlElement
struct IXmlElement_raw : IInspectable {
	virtual STDMETHODIMP _get_TagName(HSTRING *value);
	virtual STDMETHODIMP _GetAttribute(HSTRING attributeName, HSTRING *attributeValue);
	virtual STDMETHODIMP _SetAttribute(HSTRING attributeName, HSTRING attributeValue);
	virtual STDMETHODIMP _RemoveAttribute(HSTRING attributeName);
	virtual STDMETHODIMP _GetAttributeNode(HSTRING attributeName, XmlAttribute* *attributeNode);
	virtual STDMETHODIMP _SetAttributeNode(XmlAttribute* newAttribute, XmlAttribute* *previousAttribute);
	virtual STDMETHODIMP _RemoveAttributeNode(XmlAttribute* attributeNode, XmlAttribute* *removedAttribute);
	virtual STDMETHODIMP _GetElementsByTagName(HSTRING tagName, XmlNodeList* *elements);
	virtual STDMETHODIMP _SetAttributeNS(IInspectable* namespaceUri, HSTRING qualifiedName, HSTRING value);
	virtual STDMETHODIMP _GetAttributeNS(IInspectable* namespaceUri, HSTRING localName, HSTRING *value);
	virtual STDMETHODIMP _RemoveAttributeNS(IInspectable* namespaceUri, HSTRING localName);
	virtual STDMETHODIMP _SetAttributeNodeNS(XmlAttribute* newAttribute, XmlAttribute* *previousAttribute);
	virtual STDMETHODIMP _GetAttributeNodeNS(IInspectable* namespaceUri, HSTRING localName, XmlAttribute* *previousAttribute);
};
template<typename X> struct IXmlElement_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IXmlElement_adaptor::TagName)->_get_TagName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} TagName;
	};
	hstring GetAttribute(hstring_ref attributeName) { HSTRING attributeValue; hrcheck(X::get()->_GetAttribute(attributeName, &attributeValue)); return from_abi(attributeValue); }
	void SetAttribute(hstring_ref attributeName, hstring_ref attributeValue) { hrcheck(X::get()->_SetAttribute(attributeName, attributeValue)); }
	void RemoveAttribute(hstring_ref attributeName) { hrcheck(X::get()->_RemoveAttribute(attributeName)); }
	ptr<XmlAttribute> GetAttributeNode(hstring_ref attributeName) { XmlAttribute* attributeNode; hrcheck(X::get()->_GetAttributeNode(attributeName, &attributeNode)); return from_abi(attributeNode); }
	ptr<XmlAttribute> SetAttributeNode(pptr<XmlAttribute> newAttribute) { XmlAttribute* previousAttribute; hrcheck(X::get()->_SetAttributeNode(newAttribute, &previousAttribute)); return from_abi(previousAttribute); }
	ptr<XmlAttribute> RemoveAttributeNode(pptr<XmlAttribute> attributeNode) { XmlAttribute* removedAttribute; hrcheck(X::get()->_RemoveAttributeNode(attributeNode, &removedAttribute)); return from_abi(removedAttribute); }
	ptr<XmlNodeList> GetElementsByTagName(hstring_ref tagName) { XmlNodeList* elements; hrcheck(X::get()->_GetElementsByTagName(tagName, &elements)); return from_abi(elements); }
	void SetAttributeNS(object_ref namespaceUri, hstring_ref qualifiedName, hstring_ref value) { hrcheck(X::get()->_SetAttributeNS(namespaceUri, qualifiedName, value)); }
	hstring GetAttributeNS(object_ref namespaceUri, hstring_ref localName) { HSTRING value; hrcheck(X::get()->_GetAttributeNS(namespaceUri, localName, &value)); return from_abi(value); }
	void RemoveAttributeNS(object_ref namespaceUri, hstring_ref localName) { hrcheck(X::get()->_RemoveAttributeNS(namespaceUri, localName)); }
	ptr<XmlAttribute> SetAttributeNodeNS(pptr<XmlAttribute> newAttribute) { XmlAttribute* previousAttribute; hrcheck(X::get()->_SetAttributeNodeNS(newAttribute, &previousAttribute)); return from_abi(previousAttribute); }
	ptr<XmlAttribute> GetAttributeNodeNS(object_ref namespaceUri, hstring_ref localName) { XmlAttribute* previousAttribute; hrcheck(X::get()->_GetAttributeNodeNS(namespaceUri, localName, &previousAttribute)); return from_abi(previousAttribute); }
	IXmlElement_adaptor() {}
};
template<typename X> struct adapt<IXmlElement, X> : Windows::Data::Xml::Dom::IXmlElement_adaptor<X> { typedef adapt IXmlElement; };
struct IXmlElement : IXmlElement_raw, generate<IXmlElement> {};

// XmlAttribute
template<typename X> struct statics<XmlAttribute, X> : X {
	typedef typename X::root_type XmlAttribute;
};
struct XmlAttribute : generate<XmlAttribute> {};

// IDtdNotation
struct IDtdNotation_raw : IInspectable {
	virtual STDMETHODIMP _get_PublicId(IInspectable* *value);
	virtual STDMETHODIMP _get_SystemId(IInspectable* *value);
};
template<typename X> struct IDtdNotation_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IDtdNotation_adaptor::PublicId)->_get_PublicId(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} PublicId;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IDtdNotation_adaptor::SystemId)->_get_SystemId(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} SystemId;
	};
	IDtdNotation_adaptor() {}
};
template<typename X> struct adapt<IDtdNotation, X> : Windows::Data::Xml::Dom::IDtdNotation_adaptor<X> { typedef adapt IDtdNotation; };
struct IDtdNotation : IDtdNotation_raw, generate<IDtdNotation> {};

// IDtdEntity
struct IDtdEntity_raw : IInspectable {
	virtual STDMETHODIMP _get_PublicId(IInspectable* *value);
	virtual STDMETHODIMP _get_SystemId(IInspectable* *value);
	virtual STDMETHODIMP _get_NotationName(IInspectable* *value);
};
template<typename X> struct IDtdEntity_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IDtdEntity_adaptor::NotationName)->_get_NotationName(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} NotationName;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IDtdEntity_adaptor::PublicId)->_get_PublicId(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} PublicId;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IDtdEntity_adaptor::SystemId)->_get_SystemId(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} SystemId;
	};
	IDtdEntity_adaptor() {}
};
template<typename X> struct adapt<IDtdEntity, X> : Windows::Data::Xml::Dom::IDtdEntity_adaptor<X> { typedef adapt IDtdEntity; };
struct IDtdEntity : IDtdEntity_raw, generate<IDtdEntity> {};

// IXmlEntityReference
struct IXmlEntityReference : IInspectable, generate<IXmlEntityReference> {};

// IXmlProcessingInstruction
struct IXmlProcessingInstruction_raw : IInspectable {
	virtual STDMETHODIMP _get_Target(HSTRING *value);
	virtual STDMETHODIMP _get_Data(HSTRING *value);
	virtual STDMETHODIMP _put_Data(HSTRING value);
};
template<typename X> struct IXmlProcessingInstruction_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IXmlProcessingInstruction_adaptor::Data)->_get_Data(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IXmlProcessingInstruction_adaptor::Data)->_put_Data(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Data;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IXmlProcessingInstruction_adaptor::Target)->_get_Target(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Target;
	};
	IXmlProcessingInstruction_adaptor() {}
};
template<typename X> struct adapt<IXmlProcessingInstruction, X> : Windows::Data::Xml::Dom::IXmlProcessingInstruction_adaptor<X> { typedef adapt IXmlProcessingInstruction; };
struct IXmlProcessingInstruction : IXmlProcessingInstruction_raw, generate<IXmlProcessingInstruction> {};

// IXmlCharacterData
struct IXmlCharacterData_raw : IInspectable {
	virtual STDMETHODIMP _get_Data(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_Data(HSTRING value) = 0;
	virtual STDMETHODIMP _get_Length(unsigned *value) = 0;
	virtual STDMETHODIMP _SubstringData(unsigned offset, unsigned count, HSTRING *data) = 0;
	virtual STDMETHODIMP _AppendData(HSTRING data) = 0;
	virtual STDMETHODIMP _InsertData(unsigned offset, HSTRING data) = 0;
	virtual STDMETHODIMP _DeleteData(unsigned offset, unsigned count) = 0;
	virtual STDMETHODIMP _ReplaceData(unsigned offset, unsigned count, HSTRING data) = 0;
};
template<typename X> struct IXmlCharacterData_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IXmlCharacterData_adaptor::Data)->_get_Data(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IXmlCharacterData_adaptor::Data)->_put_Data(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Data;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IXmlCharacterData_adaptor::Length)->_get_Length(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Length;
	};
	hstring SubstringData(unsigned offset, unsigned count) { HSTRING data; hrcheck(X::get()->_SubstringData(offset, count, &data)); return from_abi(data); }
	void AppendData(hstring_ref data) { hrcheck(X::get()->_AppendData(data)); }
	void InsertData(unsigned offset, hstring_ref data) { hrcheck(X::get()->_InsertData(offset, data)); }
	void DeleteData(unsigned offset, unsigned count) { hrcheck(X::get()->_DeleteData(offset, count)); }
	void ReplaceData(unsigned offset, unsigned count, hstring_ref data) { hrcheck(X::get()->_ReplaceData(offset, count, data)); }
	IXmlCharacterData_adaptor() {}
};
template<typename X> struct adapt<IXmlCharacterData, X> : Windows::Data::Xml::Dom::IXmlCharacterData_adaptor<X> { typedef adapt IXmlCharacterData; };
template<typename X> struct IXmlCharacterData_unadaptor : X {
	STDMETHODIMP _get_Data(HSTRING *value) { return hrtry([&, this] { get_prop(value, Data); }); }
	STDMETHODIMP _put_Data(HSTRING value) { return hrtry([&, this] { put_prop(value, Data); }); }
	STDMETHODIMP _get_Length(unsigned *value) { return hrtry([&, this] { get_prop(value, Length); }); }
	STDMETHODIMP _SubstringData(unsigned offset, unsigned count, HSTRING *data) { return hrtry([&, this] { *data = to_abi(X::get()->SubstringData(offset, count)); }); }
	STDMETHODIMP _AppendData(HSTRING data) { return hrtry([&, this] { X::get()->AppendData(data); }); }
	STDMETHODIMP _InsertData(unsigned offset, HSTRING data) { return hrtry([&, this] { X::get()->InsertData(offset, data); }); }
	STDMETHODIMP _DeleteData(unsigned offset, unsigned count) { return hrtry([&, this] { X::get()->DeleteData(offset, count); }); }
	STDMETHODIMP _ReplaceData(unsigned offset, unsigned count, HSTRING data) { return hrtry([&, this] { X::get()->ReplaceData(offset, count, data); }); }
};
template<typename X> struct unadapt<IXmlCharacterData, X> : Windows::Data::Xml::Dom::IXmlCharacterData_unadaptor<X> {};
struct IXmlCharacterData : IXmlCharacterData_raw, generate<IXmlCharacterData> {};

// IXmlComment
struct IXmlComment : IInspectable, generate<IXmlComment> {};

// IXmlText
struct IXmlText_raw : IInspectable {
	virtual STDMETHODIMP _SplitText(unsigned offset, IXmlText* *secondPart) = 0;
};
template<typename X> struct IXmlText_adaptor : X {
	ptr<IXmlText> SplitText(unsigned offset) { IXmlText* secondPart; hrcheck(X::get()->_SplitText(offset, &secondPart)); return from_abi(secondPart); }
};
template<typename X> struct adapt<IXmlText, X> : Windows::Data::Xml::Dom::IXmlText_adaptor<X> { typedef adapt IXmlText; };
template<typename X> struct IXmlText_unadaptor : X {
	STDMETHODIMP _SplitText(unsigned offset, IXmlText* *secondPart) { return hrtry([&, this] { *secondPart = to_abi(X::get()->SplitText(offset)); }); }
};
template<typename X> struct unadapt<IXmlText, X> : Windows::Data::Xml::Dom::IXmlText_unadaptor<X> {};
struct IXmlText : IXmlText_raw, generate<IXmlText> {};

// IXmlCDataSection
struct IXmlCDataSection : IInspectable, generate<IXmlCDataSection> {};

// XmlDocumentType
template<typename X> struct statics<XmlDocumentType, X> : X {
	typedef typename X::root_type XmlDocumentType;
};
struct XmlDocumentType : generate<XmlDocumentType> {};

// XmlDomImplementation
template<typename X> struct statics<XmlDomImplementation, X> : X {
	typedef typename X::root_type XmlDomImplementation;
};
struct XmlDomImplementation : generate<XmlDomImplementation> {};

// XmlElement
template<typename X> struct statics<XmlElement, X> : X {
	typedef typename X::root_type XmlElement;
};
struct XmlElement : generate<XmlElement> {};

// XmlDocumentFragment
template<typename X> struct statics<XmlDocumentFragment, X> : X {
	typedef typename X::root_type XmlDocumentFragment;
};
struct XmlDocumentFragment : generate<XmlDocumentFragment> {};

// XmlText
template<typename X> struct statics<XmlText, X> : X {
	typedef typename X::root_type XmlText;
};
struct XmlText : generate<XmlText> {};

// XmlComment
template<typename X> struct statics<XmlComment, X> : X {
	typedef typename X::root_type XmlComment;
};
struct XmlComment : generate<XmlComment> {};

// XmlProcessingInstruction
template<typename X> struct statics<XmlProcessingInstruction, X> : X {
	typedef typename X::root_type XmlProcessingInstruction;
};
struct XmlProcessingInstruction : generate<XmlProcessingInstruction> {};

// XmlEntityReference
template<typename X> struct statics<XmlEntityReference, X> : X {
	typedef typename X::root_type XmlEntityReference;
};
struct XmlEntityReference : generate<XmlEntityReference> {};

// XmlCDataSection
template<typename X> struct statics<XmlCDataSection, X> : X {
	typedef typename X::root_type XmlCDataSection;
};
struct XmlCDataSection : generate<XmlCDataSection> {};

// IXmlLoadSettings
struct IXmlLoadSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_MaxElementDepth(unsigned *value);
	virtual STDMETHODIMP _put_MaxElementDepth(unsigned value);
	virtual STDMETHODIMP _get_ProhibitDtd(bool *value);
	virtual STDMETHODIMP _put_ProhibitDtd(bool value);
	virtual STDMETHODIMP _get_ResolveExternals(bool *value);
	virtual STDMETHODIMP _put_ResolveExternals(bool value);
	virtual STDMETHODIMP _get_ValidateOnParse(bool *value);
	virtual STDMETHODIMP _put_ValidateOnParse(bool value);
	virtual STDMETHODIMP _get_ElementContentWhiteSpace(bool *value);
	virtual STDMETHODIMP _put_ElementContentWhiteSpace(bool value);
};
template<typename X> struct IXmlLoadSettings_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IXmlLoadSettings_adaptor::ElementContentWhiteSpace)->_get_ElementContentWhiteSpace(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IXmlLoadSettings_adaptor::ElementContentWhiteSpace)->_put_ElementContentWhiteSpace(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ElementContentWhiteSpace;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IXmlLoadSettings_adaptor::MaxElementDepth)->_get_MaxElementDepth(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IXmlLoadSettings_adaptor::MaxElementDepth)->_put_MaxElementDepth(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} MaxElementDepth;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IXmlLoadSettings_adaptor::ProhibitDtd)->_get_ProhibitDtd(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IXmlLoadSettings_adaptor::ProhibitDtd)->_put_ProhibitDtd(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ProhibitDtd;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IXmlLoadSettings_adaptor::ResolveExternals)->_get_ResolveExternals(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IXmlLoadSettings_adaptor::ResolveExternals)->_put_ResolveExternals(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ResolveExternals;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IXmlLoadSettings_adaptor::ValidateOnParse)->_get_ValidateOnParse(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IXmlLoadSettings_adaptor::ValidateOnParse)->_put_ValidateOnParse(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ValidateOnParse;
	};
	IXmlLoadSettings_adaptor() {}
};
template<typename X> struct adapt<IXmlLoadSettings, X> : Windows::Data::Xml::Dom::IXmlLoadSettings_adaptor<X> { typedef adapt IXmlLoadSettings; };
struct IXmlLoadSettings : IXmlLoadSettings_raw, generate<IXmlLoadSettings> {};

// XmlLoadSettings
template<typename X> struct statics<XmlLoadSettings, X> : X {
	typedef typename X::root_type XmlLoadSettings;
};
struct XmlLoadSettings : generate<XmlLoadSettings> {};

// DtdNotation
template<typename X> struct statics<DtdNotation, X> : X {
	typedef typename X::root_type DtdNotation;
};
struct DtdNotation : generate<DtdNotation> {};

// DtdEntity
template<typename X> struct statics<DtdEntity, X> : X {
	typedef typename X::root_type DtdEntity;
};
struct DtdEntity : generate<DtdEntity> {};
}}}}
} // namespace iso_winrt
