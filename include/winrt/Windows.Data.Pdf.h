#pragma once
// generated by isopod tools
// namespaces:
// Windows.Data.Pdf

#include "Windows.Data.Pdf.0.h"
#include "Windows.UI.0.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Storage { namespace Streams {
struct IRandomAccessStream;
}
struct IStorageFile;
}}

// defs

template<> struct def<Windows::Data::Pdf::IPdfPageDimensions> : interface_type<> {};
template<> struct def<Windows::Data::Pdf::PdfPageRotation> : enum_type<int> {};
template<> struct def<Windows::Data::Pdf::IPdfPageRenderOptions> : interface_type<> {};
template<> struct def<Windows::Data::Pdf::IPdfPage> : interface_type<> {};
template<> struct def<Windows::Data::Pdf::PdfPageRenderOptions> : class_type<Platform::Object, Windows::Data::Pdf::IPdfPageRenderOptions> {};
template<> struct def<Windows::Data::Pdf::PdfPageDimensions> : class_type<Platform::Object, Windows::Data::Pdf::IPdfPageDimensions> {};
template<> struct def<Windows::Data::Pdf::IPdfDocument> : interface_type<> {};
template<> struct def<Windows::Data::Pdf::PdfPage> : class_type<Platform::Object, Windows::Data::Pdf::IPdfPage, Windows::Foundation::IClosable> {};
template<> struct def<Windows::Data::Pdf::IPdfDocumentStatics> : interface_type<> {};
template<> struct def<Windows::Data::Pdf::PdfDocument> : class_type<Platform::Object, Windows::Data::Pdf::IPdfDocument> {};

// uuids

template<> struct uuid<Windows::Data::Pdf::IPdfPageDimensions> { define_guid(0x22170471, 0x313E, 0x44E8, 0x83, 0x5D, 0x63, 0xA3, 0xE7, 0x62, 0x4A, 0x10);};
template<> struct uuid<Windows::Data::Pdf::IPdfPageRenderOptions> { define_guid(0x3C98056F, 0xB7CF, 0x4C29, 0x9A, 0x4, 0x52, 0xD9, 0x2, 0x67, 0xF4, 0x25);};
template<> struct uuid<Windows::Data::Pdf::IPdfPage> { define_guid(0x9DB4B0C8, 0x5320, 0x4CFC, 0xAD, 0x76, 0x49, 0x3F, 0xDA, 0xD0, 0xE5, 0x94);};
template<> struct uuid<Windows::Data::Pdf::IPdfDocument> { define_guid(0xAC7EBEDD, 0x80FA, 0x4089, 0x84, 0x6E, 0x81, 0xB7, 0x7F, 0xF5, 0xA8, 0x6C);};
template<> struct uuid<Windows::Data::Pdf::IPdfDocumentStatics> { define_guid(0x433A0B5F, 0xC007, 0x4788, 0x90, 0xF2, 0x8, 0x14, 0x3D, 0x92, 0x25, 0x99);};

// types

namespace Windows { namespace Data { namespace Pdf {

// IPdfPageDimensions
struct IPdfPageDimensions_raw : IInspectable {
	virtual STDMETHODIMP _get_MediaBox(Foundation::Rect *value);
	virtual STDMETHODIMP _get_CropBox(Foundation::Rect *value);
	virtual STDMETHODIMP _get_BleedBox(Foundation::Rect *value);
	virtual STDMETHODIMP _get_TrimBox(Foundation::Rect *value);
	virtual STDMETHODIMP _get_ArtBox(Foundation::Rect *value);
};
template<typename X> struct IPdfPageDimensions_adaptor : X {
	union {
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&IPdfPageDimensions_adaptor::ArtBox)->_get_ArtBox(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
		} ArtBox;
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&IPdfPageDimensions_adaptor::BleedBox)->_get_BleedBox(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
		} BleedBox;
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&IPdfPageDimensions_adaptor::CropBox)->_get_CropBox(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
		} CropBox;
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&IPdfPageDimensions_adaptor::MediaBox)->_get_MediaBox(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
		} MediaBox;
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&IPdfPageDimensions_adaptor::TrimBox)->_get_TrimBox(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
		} TrimBox;
	};
	IPdfPageDimensions_adaptor() {}
};
template<typename X> struct adapt<IPdfPageDimensions, X> : Windows::Data::Pdf::IPdfPageDimensions_adaptor<X> { typedef adapt IPdfPageDimensions; };
struct IPdfPageDimensions : IPdfPageDimensions_raw, generate<IPdfPageDimensions> {};

// IPdfPageRenderOptions
struct IPdfPageRenderOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_SourceRect(Foundation::Rect *value);
	virtual STDMETHODIMP _put_SourceRect(Foundation::Rect value);
	virtual STDMETHODIMP _get_DestinationWidth(unsigned *value);
	virtual STDMETHODIMP _put_DestinationWidth(unsigned value);
	virtual STDMETHODIMP _get_DestinationHeight(unsigned *value);
	virtual STDMETHODIMP _put_DestinationHeight(unsigned value);
	virtual STDMETHODIMP _get_BackgroundColor(UI::Color *value);
	virtual STDMETHODIMP _put_BackgroundColor(UI::Color value);
	virtual STDMETHODIMP _get_IsIgnoringHighContrast(bool *value);
	virtual STDMETHODIMP _put_IsIgnoringHighContrast(bool value);
	virtual STDMETHODIMP _get_BitmapEncoderId(Platform::Guid *value);
	virtual STDMETHODIMP _put_BitmapEncoderId(Platform::Guid value);
};
template<typename X> struct IPdfPageRenderOptions_adaptor : X {
	union {
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&IPdfPageRenderOptions_adaptor::BackgroundColor)->_get_BackgroundColor(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IPdfPageRenderOptions_adaptor::BackgroundColor)->_put_BackgroundColor(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} BackgroundColor;
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPdfPageRenderOptions_adaptor::BitmapEncoderId)->_get_BitmapEncoderId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
			void put(const Platform::Guid& value) { hrcheck(enc(&IPdfPageRenderOptions_adaptor::BitmapEncoderId)->_put_BitmapEncoderId(value)); }
			void operator=(const Platform::Guid& value) { put(value); }
			void operator()(const Platform::Guid& value) { put(value); }
		} BitmapEncoderId;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IPdfPageRenderOptions_adaptor::DestinationHeight)->_get_DestinationHeight(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IPdfPageRenderOptions_adaptor::DestinationHeight)->_put_DestinationHeight(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} DestinationHeight;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IPdfPageRenderOptions_adaptor::DestinationWidth)->_get_DestinationWidth(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IPdfPageRenderOptions_adaptor::DestinationWidth)->_put_DestinationWidth(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} DestinationWidth;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPdfPageRenderOptions_adaptor::IsIgnoringHighContrast)->_get_IsIgnoringHighContrast(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IPdfPageRenderOptions_adaptor::IsIgnoringHighContrast)->_put_IsIgnoringHighContrast(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsIgnoringHighContrast;
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&IPdfPageRenderOptions_adaptor::SourceRect)->_get_SourceRect(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
			void put(const Foundation::Rect& value) { hrcheck(enc(&IPdfPageRenderOptions_adaptor::SourceRect)->_put_SourceRect(value)); }
			void operator=(const Foundation::Rect& value) { put(value); }
			void operator()(const Foundation::Rect& value) { put(value); }
		} SourceRect;
	};
	IPdfPageRenderOptions_adaptor() {}
};
template<typename X> struct adapt<IPdfPageRenderOptions, X> : Windows::Data::Pdf::IPdfPageRenderOptions_adaptor<X> { typedef adapt IPdfPageRenderOptions; };
struct IPdfPageRenderOptions : IPdfPageRenderOptions_raw, generate<IPdfPageRenderOptions> {};

// IPdfPage
struct IPdfPage_raw : IInspectable {
	virtual STDMETHODIMP _RenderToStreamAsync(Storage::Streams::IRandomAccessStream* outputStream, Foundation::IAsyncAction* *asyncInfo);
	virtual STDMETHODIMP _RenderWithOptionsToStreamAsync(Storage::Streams::IRandomAccessStream* outputStream, PdfPageRenderOptions* options, Foundation::IAsyncAction* *asyncInfo);
	virtual STDMETHODIMP _PreparePageAsync(Foundation::IAsyncAction* *asyncInfo);
	virtual STDMETHODIMP _get_Index(unsigned *value);
	virtual STDMETHODIMP _get_Size(Foundation::Size *value);
	virtual STDMETHODIMP _get_Dimensions(PdfPageDimensions* *value);
	virtual STDMETHODIMP _get_Rotation(PdfPageRotation *value);
	virtual STDMETHODIMP _get_PreferredZoom(float *value);
};
template<typename X> struct IPdfPage_adaptor : X {
	union {
		struct : property {
			ptr<PdfPageDimensions> get() { PdfPageDimensions* value; hrcheck(enc(&IPdfPage_adaptor::Dimensions)->_get_Dimensions(&value)); return from_abi(value); }
			ptr<PdfPageDimensions> operator()() { return get(); }
			operator ptr<PdfPageDimensions> () { return get(); }
			ptr<PdfPageDimensions> operator->() { return get(); }
		} Dimensions;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IPdfPage_adaptor::Index)->_get_Index(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Index;
		struct : property {
			float get() { float value; hrcheck(enc(&IPdfPage_adaptor::PreferredZoom)->_get_PreferredZoom(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} PreferredZoom;
		struct : property {
			PdfPageRotation get() { PdfPageRotation value; hrcheck(enc(&IPdfPage_adaptor::Rotation)->_get_Rotation(&value)); return value; }
			PdfPageRotation operator()() { return get(); }
			operator PdfPageRotation () { return get(); }
		} Rotation;
		struct : property {
			Foundation::Size get() { Foundation::Size value; hrcheck(enc(&IPdfPage_adaptor::Size)->_get_Size(&value)); return value; }
			Foundation::Size operator()() { return get(); }
			operator Foundation::Size () { return get(); }
		} Size;
	};
	ptr<Foundation::IAsyncAction> RenderToStreamAsync(pptr<Storage::Streams::IRandomAccessStream> outputStream) { Foundation::IAsyncAction* asyncInfo; hrcheck(X::get()->_RenderToStreamAsync(outputStream, &asyncInfo)); return from_abi(asyncInfo); }
	ptr<Foundation::IAsyncAction> RenderToStreamAsync(pptr<Storage::Streams::IRandomAccessStream> outputStream, pptr<PdfPageRenderOptions> options) { Foundation::IAsyncAction* asyncInfo; hrcheck(X::get()->_RenderWithOptionsToStreamAsync(outputStream, options, &asyncInfo)); return from_abi(asyncInfo); }
	ptr<Foundation::IAsyncAction> PreparePageAsync() { Foundation::IAsyncAction* asyncInfo; hrcheck(X::get()->_PreparePageAsync(&asyncInfo)); return from_abi(asyncInfo); }
	IPdfPage_adaptor() {}
};
template<typename X> struct adapt<IPdfPage, X> : Windows::Data::Pdf::IPdfPage_adaptor<X> { typedef adapt IPdfPage; };
struct IPdfPage : IPdfPage_raw, generate<IPdfPage> {};

// PdfPageRenderOptions
template<typename X> struct statics<PdfPageRenderOptions, X> : X {
	typedef typename X::root_type PdfPageRenderOptions;
};
struct PdfPageRenderOptions : generate<PdfPageRenderOptions> {};

// PdfPageDimensions
template<typename X> struct statics<PdfPageDimensions, X> : X {
	typedef typename X::root_type PdfPageDimensions;
};
struct PdfPageDimensions : generate<PdfPageDimensions> {};

// IPdfDocument
struct IPdfDocument_raw : IInspectable {
	virtual STDMETHODIMP _GetPage(unsigned pageIndex, PdfPage* *pdfPage);
	virtual STDMETHODIMP _get_PageCount(unsigned *value);
	virtual STDMETHODIMP _get_IsPasswordProtected(bool *value);
};
template<typename X> struct IPdfDocument_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPdfDocument_adaptor::IsPasswordProtected)->_get_IsPasswordProtected(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsPasswordProtected;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IPdfDocument_adaptor::PageCount)->_get_PageCount(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} PageCount;
	};
	ptr<PdfPage> GetPage(unsigned pageIndex) { PdfPage* pdfPage; hrcheck(X::get()->_GetPage(pageIndex, &pdfPage)); return from_abi(pdfPage); }
	IPdfDocument_adaptor() {}
};
template<typename X> struct adapt<IPdfDocument, X> : Windows::Data::Pdf::IPdfDocument_adaptor<X> { typedef adapt IPdfDocument; };
struct IPdfDocument : IPdfDocument_raw, generate<IPdfDocument> {};

// PdfPage
template<typename X> struct statics<PdfPage, X> : X {
	typedef typename X::root_type PdfPage;
};
struct PdfPage : generate<PdfPage> {
	using IPdfPage::RenderToStreamAsync;
};

// IPdfDocumentStatics
struct IPdfDocumentStatics : IInspectable {
	virtual STDMETHODIMP _LoadFromFileAsync(Storage::IStorageFile* file, Foundation::IAsyncOperation<PdfDocument*>* *asyncInfo);
	virtual STDMETHODIMP _LoadFromFileWithPasswordAsync(Storage::IStorageFile* file, HSTRING password, Foundation::IAsyncOperation<PdfDocument*>* *asyncInfo);
	virtual STDMETHODIMP _LoadFromStreamAsync(Storage::Streams::IRandomAccessStream* inputStream, Foundation::IAsyncOperation<PdfDocument*>* *asyncInfo);
	virtual STDMETHODIMP _LoadFromStreamWithPasswordAsync(Storage::Streams::IRandomAccessStream* inputStream, HSTRING password, Foundation::IAsyncOperation<PdfDocument*>* *asyncInfo);
};

// PdfDocument
template<typename> struct PdfDocument_statics {
	static ptr<Foundation::IAsyncOperation<ptr<PdfDocument>>> LoadFromFileAsync(pptr<Storage::IStorageFile> file) { Foundation::IAsyncOperation<PdfDocument*>* asyncInfo; hrcheck(get_activation_factory<PdfDocument, IPdfDocumentStatics>()->_LoadFromFileAsync(file, &asyncInfo)); return from_abi(asyncInfo); }
	static ptr<Foundation::IAsyncOperation<ptr<PdfDocument>>> LoadFromFileAsync(pptr<Storage::IStorageFile> file, hstring_ref password) { Foundation::IAsyncOperation<PdfDocument*>* asyncInfo; hrcheck(get_activation_factory<PdfDocument, IPdfDocumentStatics>()->_LoadFromFileWithPasswordAsync(file, password, &asyncInfo)); return from_abi(asyncInfo); }
	static ptr<Foundation::IAsyncOperation<ptr<PdfDocument>>> LoadFromStreamAsync(pptr<Storage::Streams::IRandomAccessStream> inputStream) { Foundation::IAsyncOperation<PdfDocument*>* asyncInfo; hrcheck(get_activation_factory<PdfDocument, IPdfDocumentStatics>()->_LoadFromStreamAsync(inputStream, &asyncInfo)); return from_abi(asyncInfo); }
	static ptr<Foundation::IAsyncOperation<ptr<PdfDocument>>> LoadFromStreamAsync(pptr<Storage::Streams::IRandomAccessStream> inputStream, hstring_ref password) { Foundation::IAsyncOperation<PdfDocument*>* asyncInfo; hrcheck(get_activation_factory<PdfDocument, IPdfDocumentStatics>()->_LoadFromStreamWithPasswordAsync(inputStream, password, &asyncInfo)); return from_abi(asyncInfo); }
};

template<typename X> struct statics<PdfDocument, X> : X, Windows::Data::Pdf::PdfDocument_statics<void> {
	typedef typename X::root_type PdfDocument;
};
struct PdfDocument : generate<PdfDocument> {};
}}}
} // namespace iso_winrt
