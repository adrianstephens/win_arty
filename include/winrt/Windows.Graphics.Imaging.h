#pragma once
// generated by isopod tools
// namespaces:
// Windows.Graphics.Imaging

#include "Windows.Graphics.Imaging.0.h"
#include "Windows.Foundation.Collections.h"
#include "Windows.Storage.Streams.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Graphics { namespace DirectX { namespace Direct3D11 {
struct IDirect3DSurface;
}}}}

// defs

template<> struct def<Windows::Graphics::Imaging::BitmapInterpolationMode> : enum_type<int> {};
template<> struct def<Windows::Graphics::Imaging::BitmapFlip> : enum_type<int> {};
template<> struct def<Windows::Graphics::Imaging::BitmapRotation> : enum_type<int> {};
template<> struct def<Windows::Graphics::Imaging::BitmapSize> : value_type<unsigned, unsigned> {};
template<> struct def<Windows::Graphics::Imaging::ColorManagementMode> : enum_type<int> {};
template<> struct def<Windows::Graphics::Imaging::ExifOrientationMode> : enum_type<int> {};
template<> struct def<Windows::Graphics::Imaging::PngFilterMode> : enum_type<int> {};
template<> struct def<Windows::Graphics::Imaging::TiffCompressionMode> : enum_type<int> {};
template<> struct def<Windows::Graphics::Imaging::JpegSubsamplingMode> : enum_type<int> {};
template<> struct def<Windows::Graphics::Imaging::BitmapBounds> : value_type<unsigned, unsigned, unsigned, unsigned> {};
template<> struct def<Windows::Graphics::Imaging::IBitmapTransform> : interface_type<> {};
template<> struct def<Windows::Graphics::Imaging::BitmapTransform> : class_type<Platform::Object, Windows::Graphics::Imaging::IBitmapTransform> {};
template<> struct def<Windows::Graphics::Imaging::IBitmapTypedValue> : interface_type<> {};
template<> struct def<Windows::Graphics::Imaging::IBitmapTypedValueFactory> : interface_type<> {};
template<> struct def<Windows::Graphics::Imaging::BitmapTypedValue> : class_type<Platform::Object, Windows::Graphics::Imaging::IBitmapTypedValue>, custom_activators {};
template<> struct def<Windows::Graphics::Imaging::BitmapPropertySet> : class_type<Platform::Object, Windows::Foundation::Collections::IMap<HSTRING, ptr<Windows::Graphics::Imaging::BitmapTypedValue>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, ptr<Windows::Graphics::Imaging::BitmapTypedValue>>>>> {};
template<> struct def<Windows::Graphics::Imaging::IBitmapPropertiesView> : overridable_type<> {};
template<> struct def<Windows::Graphics::Imaging::IBitmapProperties> : interface_type<Windows::Graphics::Imaging::IBitmapPropertiesView> {};
template<> struct def<Windows::Graphics::Imaging::BitmapPropertiesView> : class_type<Platform::Object, Windows::Graphics::Imaging::IBitmapPropertiesView> {};
template<> struct def<Windows::Graphics::Imaging::BitmapProperties> : class_type<Platform::Object, Windows::Graphics::Imaging::IBitmapProperties> {};
template<> struct def<Windows::Graphics::Imaging::IPixelDataProvider> : interface_type<> {};
template<> struct def<Windows::Graphics::Imaging::PixelDataProvider> : class_type<Platform::Object, Windows::Graphics::Imaging::IPixelDataProvider> {};
template<> struct def<Windows::Graphics::Imaging::ImageStream> : class_type<Platform::Object, Windows::Storage::Streams::IRandomAccessStreamWithContentType, Windows::Storage::Streams::IContentTypeProvider, Windows::Storage::Streams::IRandomAccessStream, Windows::Storage::Streams::IOutputStream, Windows::Foundation::IClosable, Windows::Storage::Streams::IInputStream> {};
template<> struct def<Windows::Graphics::Imaging::BitmapAlphaMode> : enum_type<int> {};
template<> struct def<Windows::Graphics::Imaging::BitmapPixelFormat> : enum_type<int> {};
template<> struct def<Windows::Graphics::Imaging::IBitmapFrame> : overridable_type<> {};
template<> struct def<Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap> : overridable_type<Windows::Graphics::Imaging::IBitmapFrame> {};
template<> struct def<Windows::Graphics::Imaging::BitmapFrame> : class_type<Platform::Object, Windows::Graphics::Imaging::IBitmapFrame, Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap> {};
template<> struct def<Windows::Graphics::Imaging::IBitmapCodecInformation> : interface_type<> {};
template<> struct def<Windows::Graphics::Imaging::BitmapCodecInformation> : class_type<Platform::Object, Windows::Graphics::Imaging::IBitmapCodecInformation> {};
template<> struct def<Windows::Graphics::Imaging::IBitmapDecoderStatics> : interface_type<> {};
template<> struct def<Windows::Graphics::Imaging::IBitmapDecoder> : interface_type<> {};
template<> struct def<Windows::Graphics::Imaging::BitmapDecoder> : class_type<Platform::Object, Windows::Graphics::Imaging::IBitmapDecoder, Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap> {};
template<> struct def<Windows::Graphics::Imaging::IBitmapEncoderStatics> : interface_type<> {};
template<> struct def<Windows::Graphics::Imaging::IBitmapEncoderWithSoftwareBitmap> : interface_type<> {};
template<> struct def<Windows::Graphics::Imaging::IBitmapEncoder> : interface_type<> {};
template<> struct def<Windows::Graphics::Imaging::BitmapEncoder> : class_type<Platform::Object, Windows::Graphics::Imaging::IBitmapEncoder, Windows::Graphics::Imaging::IBitmapEncoderWithSoftwareBitmap> {};
template<> struct def<Windows::Graphics::Imaging::BitmapBufferAccessMode> : enum_type<int> {};
template<> struct def<Windows::Graphics::Imaging::ISoftwareBitmap> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Graphics::Imaging::BitmapPlaneDescription> : value_type<int, int, int, int> {};
template<> struct def<Windows::Graphics::Imaging::IBitmapBuffer> : interface_type<Windows::Foundation::IMemoryBuffer, Windows::Foundation::IClosable> {};
template<> struct def<Windows::Graphics::Imaging::BitmapBuffer> : class_type<Platform::Object, Windows::Graphics::Imaging::IBitmapBuffer> {};
template<> struct def<Windows::Graphics::Imaging::ISoftwareBitmapStatics> : interface_type<> {};
template<> struct def<Windows::Graphics::Imaging::ISoftwareBitmapFactory> : interface_type<> {};
template<> struct def<Windows::Graphics::Imaging::SoftwareBitmap> : class_type<Platform::Object, Windows::Graphics::Imaging::ISoftwareBitmap>, custom_activators {};

// uuids

template<> struct uuid<Windows::Graphics::Imaging::IBitmapTransform> { define_guid(0xAE755344, 0xE268, 0x4D35, 0xAD, 0xCF, 0xE9, 0x95, 0xD3, 0x1A, 0x8D, 0x34);};
template<> struct uuid<Windows::Graphics::Imaging::IBitmapTypedValue> { define_guid(0xCD8044A9, 0x2443, 0x4000, 0xB0, 0xCD, 0x79, 0x31, 0x6C, 0x56, 0xF5, 0x89);};
template<> struct uuid<Windows::Graphics::Imaging::IBitmapTypedValueFactory> { define_guid(0x92DBB599, 0xCE13, 0x46BB, 0x95, 0x45, 0xCB, 0x3A, 0x3F, 0x63, 0xEB, 0x8B);};
template<> struct uuid<Windows::Graphics::Imaging::IBitmapPropertiesView> { define_guid(0x7E0FE87A, 0x3A70, 0x48F8, 0x9C, 0x55, 0x19, 0x6C, 0xF5, 0xA5, 0x45, 0xF5);};
template<> struct uuid<Windows::Graphics::Imaging::IBitmapProperties> { define_guid(0xEA9F4F1B, 0xB505, 0x4450, 0xA4, 0xD1, 0xE8, 0xCA, 0x94, 0x52, 0x9D, 0x8D);};
template<> struct uuid<Windows::Graphics::Imaging::IPixelDataProvider> { define_guid(0xDD831F25, 0x185C, 0x4595, 0x9F, 0xB9, 0xCC, 0xBE, 0x6E, 0xC1, 0x8A, 0x6F);};
template<> struct uuid<Windows::Graphics::Imaging::IBitmapFrame> { define_guid(0x72A49A1C, 0x8081, 0x438D, 0x91, 0xBC, 0x94, 0xEC, 0xFC, 0x81, 0x85, 0xC6);};
template<> struct uuid<Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap> { define_guid(0xFE287C9A, 0x420C, 0x4963, 0x87, 0xAD, 0x69, 0x14, 0x36, 0xE0, 0x83, 0x83);};
template<> struct uuid<Windows::Graphics::Imaging::IBitmapCodecInformation> { define_guid(0x400CAAF2, 0xC4B0, 0x4392, 0xA3, 0xB0, 0x6F, 0x6F, 0x9B, 0xA9, 0x5C, 0xB4);};
template<> struct uuid<Windows::Graphics::Imaging::IBitmapDecoderStatics> { define_guid(0x438CCB26, 0xBCEF, 0x4E95, 0xBA, 0xD6, 0x23, 0xA8, 0x22, 0xE5, 0x8D, 0x1);};
template<> struct uuid<Windows::Graphics::Imaging::IBitmapDecoder> { define_guid(0xACEF22BA, 0x1D74, 0x4C91, 0x9D, 0xFC, 0x96, 0x20, 0x74, 0x52, 0x33, 0xE6);};
template<> struct uuid<Windows::Graphics::Imaging::IBitmapEncoderStatics> { define_guid(0xA74356A7, 0xA4E4, 0x4EB9, 0x8E, 0x40, 0x56, 0x4D, 0xE7, 0xE1, 0xCC, 0xB2);};
template<> struct uuid<Windows::Graphics::Imaging::IBitmapEncoderWithSoftwareBitmap> { define_guid(0x686CD241, 0x4330, 0x4C77, 0xAC, 0xE4, 0x3, 0x34, 0x96, 0x8B, 0x17, 0x68);};
template<> struct uuid<Windows::Graphics::Imaging::IBitmapEncoder> { define_guid(0x2BC468E3, 0xE1F8, 0x4B54, 0x95, 0xE8, 0x32, 0x91, 0x95, 0x51, 0xCE, 0x62);};
template<> struct uuid<Windows::Graphics::Imaging::ISoftwareBitmap> { define_guid(0x689E0708, 0x7EEF, 0x483F, 0x96, 0x3F, 0xDA, 0x93, 0x88, 0x18, 0xE0, 0x73);};
template<> struct uuid<Windows::Graphics::Imaging::IBitmapBuffer> { define_guid(0xA53E04C4, 0x399C, 0x438C, 0xB2, 0x8F, 0xA6, 0x3A, 0x6B, 0x83, 0xD1, 0xA1);};
template<> struct uuid<Windows::Graphics::Imaging::ISoftwareBitmapStatics> { define_guid(0xDF0385DB, 0x672F, 0x4A9D, 0x80, 0x6E, 0xC2, 0x44, 0x2F, 0x34, 0x3E, 0x86);};
template<> struct uuid<Windows::Graphics::Imaging::ISoftwareBitmapFactory> { define_guid(0xC99FEB69, 0x2D62, 0x4D47, 0xA6, 0xB3, 0x4F, 0xDB, 0x6A, 0x7, 0xFD, 0xF8);};

// types

namespace Windows { namespace Graphics { namespace Imaging {

// IBitmapTransform
struct IBitmapTransform_raw : IInspectable {
	virtual STDMETHODIMP _get_ScaledWidth(unsigned *value);
	virtual STDMETHODIMP _put_ScaledWidth(unsigned value);
	virtual STDMETHODIMP _get_ScaledHeight(unsigned *value);
	virtual STDMETHODIMP _put_ScaledHeight(unsigned value);
	virtual STDMETHODIMP _get_InterpolationMode(BitmapInterpolationMode *value);
	virtual STDMETHODIMP _put_InterpolationMode(BitmapInterpolationMode value);
	virtual STDMETHODIMP _get_Flip(BitmapFlip *value);
	virtual STDMETHODIMP _put_Flip(BitmapFlip value);
	virtual STDMETHODIMP _get_Rotation(BitmapRotation *value);
	virtual STDMETHODIMP _put_Rotation(BitmapRotation value);
	virtual STDMETHODIMP _get_Bounds(BitmapBounds *value);
	virtual STDMETHODIMP _put_Bounds(BitmapBounds value);
};
template<typename X> struct IBitmapTransform_adaptor : X {
	union {
		struct : property {
			BitmapBounds get() { BitmapBounds value; hrcheck(enc(&IBitmapTransform_adaptor::Bounds)->_get_Bounds(&value)); return value; }
			BitmapBounds operator()() { return get(); }
			operator BitmapBounds () { return get(); }
			void put(const BitmapBounds& value) { hrcheck(enc(&IBitmapTransform_adaptor::Bounds)->_put_Bounds(value)); }
			void operator=(const BitmapBounds& value) { put(value); }
			void operator()(const BitmapBounds& value) { put(value); }
		} Bounds;
		struct : property {
			BitmapFlip get() { BitmapFlip value; hrcheck(enc(&IBitmapTransform_adaptor::Flip)->_get_Flip(&value)); return value; }
			BitmapFlip operator()() { return get(); }
			operator BitmapFlip () { return get(); }
			void put(BitmapFlip value) { hrcheck(enc(&IBitmapTransform_adaptor::Flip)->_put_Flip(value)); }
			void operator=(BitmapFlip value) { put(value); }
			void operator()(BitmapFlip value) { put(value); }
		} Flip;
		struct : property {
			BitmapInterpolationMode get() { BitmapInterpolationMode value; hrcheck(enc(&IBitmapTransform_adaptor::InterpolationMode)->_get_InterpolationMode(&value)); return value; }
			BitmapInterpolationMode operator()() { return get(); }
			operator BitmapInterpolationMode () { return get(); }
			void put(BitmapInterpolationMode value) { hrcheck(enc(&IBitmapTransform_adaptor::InterpolationMode)->_put_InterpolationMode(value)); }
			void operator=(BitmapInterpolationMode value) { put(value); }
			void operator()(BitmapInterpolationMode value) { put(value); }
		} InterpolationMode;
		struct : property {
			BitmapRotation get() { BitmapRotation value; hrcheck(enc(&IBitmapTransform_adaptor::Rotation)->_get_Rotation(&value)); return value; }
			BitmapRotation operator()() { return get(); }
			operator BitmapRotation () { return get(); }
			void put(BitmapRotation value) { hrcheck(enc(&IBitmapTransform_adaptor::Rotation)->_put_Rotation(value)); }
			void operator=(BitmapRotation value) { put(value); }
			void operator()(BitmapRotation value) { put(value); }
		} Rotation;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IBitmapTransform_adaptor::ScaledHeight)->_get_ScaledHeight(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IBitmapTransform_adaptor::ScaledHeight)->_put_ScaledHeight(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} ScaledHeight;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IBitmapTransform_adaptor::ScaledWidth)->_get_ScaledWidth(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IBitmapTransform_adaptor::ScaledWidth)->_put_ScaledWidth(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} ScaledWidth;
	};
	IBitmapTransform_adaptor() {}
};
template<typename X> struct adapt<IBitmapTransform, X> : Windows::Graphics::Imaging::IBitmapTransform_adaptor<X> { typedef adapt IBitmapTransform; };
struct IBitmapTransform : IBitmapTransform_raw, generate<IBitmapTransform> {};

// BitmapTransform
template<typename X> struct statics<BitmapTransform, X> : X {
	typedef typename X::root_type BitmapTransform;
};
struct BitmapTransform : generate<BitmapTransform> {};

// IBitmapTypedValue
struct IBitmapTypedValue_raw : IInspectable {
	virtual STDMETHODIMP _get_Value(IInspectable* *value);
	virtual STDMETHODIMP _get_Type(Foundation::PropertyType *value);
};
template<typename X> struct IBitmapTypedValue_adaptor : X {
	union {
		struct : property {
			Foundation::PropertyType get() { Foundation::PropertyType value; hrcheck(enc(&IBitmapTypedValue_adaptor::Type)->_get_Type(&value)); return value; }
			Foundation::PropertyType operator()() { return get(); }
			operator Foundation::PropertyType () { return get(); }
		} Type;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IBitmapTypedValue_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} Value;
	};
	IBitmapTypedValue_adaptor() {}
};
template<typename X> struct adapt<IBitmapTypedValue, X> : Windows::Graphics::Imaging::IBitmapTypedValue_adaptor<X> { typedef adapt IBitmapTypedValue; };
struct IBitmapTypedValue : IBitmapTypedValue_raw, generate<IBitmapTypedValue> {};

// IBitmapTypedValueFactory
struct IBitmapTypedValueFactory : IInspectable {
	virtual STDMETHODIMP _Create(IInspectable* value, Foundation::PropertyType type, BitmapTypedValue* *bitmapTypedValue);
};

// BitmapTypedValue
template<typename> struct BitmapTypedValue_statics {
	static BitmapTypedValue *activate(object_ref value, Foundation::PropertyType type) { BitmapTypedValue *bitmapTypedValue; hrcheck(get_activation_factory<BitmapTypedValue, IBitmapTypedValueFactory>()->_Create(value, type, &bitmapTypedValue)); return bitmapTypedValue; }
};

template<typename X> struct statics<BitmapTypedValue, X> : X, Windows::Graphics::Imaging::BitmapTypedValue_statics<void> {
	using Windows::Graphics::Imaging::BitmapTypedValue_statics<void>::activate;
	typedef typename X::root_type BitmapTypedValue;
};
struct BitmapTypedValue : generate<BitmapTypedValue> {};

// BitmapPropertySet
template<typename X> struct statics<BitmapPropertySet, X> : X {
	typedef typename X::root_type BitmapPropertySet;
};
struct BitmapPropertySet : generate<BitmapPropertySet> {};

// IBitmapPropertiesView
struct IBitmapPropertiesView_raw : IInspectable {
	virtual STDMETHODIMP _GetPropertiesAsync(Foundation::Collections::IIterable<HSTRING>* propertiesToRetrieve, Foundation::IAsyncOperation<BitmapPropertySet*>* *asyncInfo) = 0;
};
template<typename X> struct IBitmapPropertiesView_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<BitmapPropertySet>>> GetPropertiesAsync(pptr<Foundation::Collections::IIterable<hstring>> propertiesToRetrieve) { Foundation::IAsyncOperation<BitmapPropertySet*>* asyncInfo; hrcheck(X::get()->_GetPropertiesAsync(to_abi(propertiesToRetrieve), &asyncInfo)); return from_abi(asyncInfo); }
};
template<typename X> struct adapt<IBitmapPropertiesView, X> : Windows::Graphics::Imaging::IBitmapPropertiesView_adaptor<X> { typedef adapt IBitmapPropertiesView; };
template<typename X> struct IBitmapPropertiesView_unadaptor : X {
	STDMETHODIMP _GetPropertiesAsync(Foundation::Collections::IIterable<HSTRING>* propertiesToRetrieve, Foundation::IAsyncOperation<BitmapPropertySet*>* *asyncInfo) { return hrtry([&, this] { *asyncInfo = to_abi(X::get()->GetPropertiesAsync(propertiesToRetrieve)); }); }
};
template<typename X> struct unadapt<IBitmapPropertiesView, X> : Windows::Graphics::Imaging::IBitmapPropertiesView_unadaptor<X> {};
struct IBitmapPropertiesView : IBitmapPropertiesView_raw, generate<IBitmapPropertiesView> {};

// IBitmapProperties
struct IBitmapProperties_raw : IInspectable {
	virtual STDMETHODIMP _SetPropertiesAsync(Foundation::Collections::IIterable<Foundation::Collections::IKeyValuePair<HSTRING, BitmapTypedValue*>*>* propertiesToSet, Foundation::IAsyncAction* *asyncInfo);
};
template<typename X> struct IBitmapProperties_adaptor : X {
	ptr<Foundation::IAsyncAction> SetPropertiesAsync(pptr<Foundation::Collections::IIterable<ptr<Foundation::Collections::IKeyValuePair<hstring, ptr<BitmapTypedValue>>>>> propertiesToSet) { Foundation::IAsyncAction* asyncInfo; hrcheck(X::get()->_SetPropertiesAsync(to_abi(propertiesToSet), &asyncInfo)); return from_abi(asyncInfo); }
};
template<typename X> struct adapt<IBitmapProperties, X> : Windows::Graphics::Imaging::IBitmapProperties_adaptor<X> { typedef adapt IBitmapProperties; };
struct IBitmapProperties : IBitmapProperties_raw, generate<IBitmapProperties> {};

// BitmapPropertiesView
template<typename X> struct statics<BitmapPropertiesView, X> : X {
	typedef typename X::root_type BitmapPropertiesView;
};
struct BitmapPropertiesView : generate<BitmapPropertiesView> {};

// BitmapProperties
template<typename X> struct statics<BitmapProperties, X> : X {
	typedef typename X::root_type BitmapProperties;
};
struct BitmapProperties : generate<BitmapProperties> {};

// IPixelDataProvider
struct IPixelDataProvider_raw : IInspectable {
	virtual STDMETHODIMP _DetachPixelData(unsigned *pixelDataSize, unsigned char **pixelData);
};
template<typename X> struct IPixelDataProvider_adaptor : X {
	szarray<unsigned char> DetachPixelData() { szarray<unsigned char> pixelData; hrcheck(X::get()->_DetachPixelData(&pixelData.size, &pixelData.p)); return pixelData; }
};
template<typename X> struct adapt<IPixelDataProvider, X> : Windows::Graphics::Imaging::IPixelDataProvider_adaptor<X> { typedef adapt IPixelDataProvider; };
struct IPixelDataProvider : IPixelDataProvider_raw, generate<IPixelDataProvider> {};

// PixelDataProvider
template<typename X> struct statics<PixelDataProvider, X> : X {
	typedef typename X::root_type PixelDataProvider;
};
struct PixelDataProvider : generate<PixelDataProvider> {};

// ImageStream
template<typename X> struct statics<ImageStream, X> : X {
	typedef typename X::root_type ImageStream;
};
struct ImageStream : generate<ImageStream> {};

// IBitmapFrame
struct IBitmapFrame_raw : IInspectable {
	virtual STDMETHODIMP _GetThumbnailAsync(Foundation::IAsyncOperation<ImageStream*>* *asyncInfo) = 0;
	virtual STDMETHODIMP _get_BitmapProperties(BitmapPropertiesView* *value) = 0;
	virtual STDMETHODIMP _get_BitmapPixelFormat(Imaging::BitmapPixelFormat *value) = 0;
	virtual STDMETHODIMP _get_BitmapAlphaMode(Imaging::BitmapAlphaMode *value) = 0;
	virtual STDMETHODIMP _get_DpiX(double *value) = 0;
	virtual STDMETHODIMP _get_DpiY(double *value) = 0;
	virtual STDMETHODIMP _get_PixelWidth(unsigned *value) = 0;
	virtual STDMETHODIMP _get_PixelHeight(unsigned *value) = 0;
	virtual STDMETHODIMP _get_OrientedPixelWidth(unsigned *value) = 0;
	virtual STDMETHODIMP _get_OrientedPixelHeight(unsigned *value) = 0;
	virtual STDMETHODIMP _GetPixelDataAsync(Foundation::IAsyncOperation<PixelDataProvider*>* *asyncInfo) = 0;
	virtual STDMETHODIMP _GetPixelDataTransformedAsync(Imaging::BitmapPixelFormat pixelFormat, Imaging::BitmapAlphaMode alphaMode, BitmapTransform* transform, ExifOrientationMode exifOrientationMode, ColorManagementMode colorManagementMode, Foundation::IAsyncOperation<PixelDataProvider*>* *asyncInfo) = 0;
};
template<typename X> struct IBitmapFrame_adaptor : X {
	union {
		struct : property {
			Imaging::BitmapAlphaMode get() { Imaging::BitmapAlphaMode value; hrcheck(enc(&IBitmapFrame_adaptor::BitmapAlphaMode)->_get_BitmapAlphaMode(&value)); return value; }
			Imaging::BitmapAlphaMode operator()() { return get(); }
			operator Imaging::BitmapAlphaMode () { return get(); }
		} BitmapAlphaMode;
		struct : property {
			Imaging::BitmapPixelFormat get() { Imaging::BitmapPixelFormat value; hrcheck(enc(&IBitmapFrame_adaptor::BitmapPixelFormat)->_get_BitmapPixelFormat(&value)); return value; }
			Imaging::BitmapPixelFormat operator()() { return get(); }
			operator Imaging::BitmapPixelFormat () { return get(); }
		} BitmapPixelFormat;
		struct : property {
			ptr<BitmapPropertiesView> get() { BitmapPropertiesView* value; hrcheck(enc(&IBitmapFrame_adaptor::BitmapProperties)->_get_BitmapProperties(&value)); return from_abi(value); }
			ptr<BitmapPropertiesView> operator()() { return get(); }
			operator ptr<BitmapPropertiesView> () { return get(); }
			ptr<BitmapPropertiesView> operator->() { return get(); }
		} BitmapProperties;
		struct : property {
			double get() { double value; hrcheck(enc(&IBitmapFrame_adaptor::DpiX)->_get_DpiX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} DpiX;
		struct : property {
			double get() { double value; hrcheck(enc(&IBitmapFrame_adaptor::DpiY)->_get_DpiY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} DpiY;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IBitmapFrame_adaptor::OrientedPixelHeight)->_get_OrientedPixelHeight(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} OrientedPixelHeight;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IBitmapFrame_adaptor::OrientedPixelWidth)->_get_OrientedPixelWidth(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} OrientedPixelWidth;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IBitmapFrame_adaptor::PixelHeight)->_get_PixelHeight(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} PixelHeight;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IBitmapFrame_adaptor::PixelWidth)->_get_PixelWidth(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} PixelWidth;
	};
	ptr<Foundation::IAsyncOperation<ptr<ImageStream>>> GetThumbnailAsync() { Foundation::IAsyncOperation<ImageStream*>* asyncInfo; hrcheck(X::get()->_GetThumbnailAsync(&asyncInfo)); return from_abi(asyncInfo); }
	ptr<Foundation::IAsyncOperation<ptr<PixelDataProvider>>> GetPixelDataAsync() { Foundation::IAsyncOperation<PixelDataProvider*>* asyncInfo; hrcheck(X::get()->_GetPixelDataAsync(&asyncInfo)); return from_abi(asyncInfo); }
	ptr<Foundation::IAsyncOperation<ptr<PixelDataProvider>>> GetPixelDataAsync(Imaging::BitmapPixelFormat pixelFormat, Imaging::BitmapAlphaMode alphaMode, pptr<BitmapTransform> transform, ExifOrientationMode exifOrientationMode, ColorManagementMode colorManagementMode) { Foundation::IAsyncOperation<PixelDataProvider*>* asyncInfo; hrcheck(X::get()->_GetPixelDataTransformedAsync(pixelFormat, alphaMode, transform, exifOrientationMode, colorManagementMode, &asyncInfo)); return from_abi(asyncInfo); }
	IBitmapFrame_adaptor() {}
};
template<typename X> struct adapt<IBitmapFrame, X> : Windows::Graphics::Imaging::IBitmapFrame_adaptor<X> { typedef adapt IBitmapFrame; };
template<typename X> struct IBitmapFrame_unadaptor : X {
	STDMETHODIMP _GetThumbnailAsync(Foundation::IAsyncOperation<ImageStream*>* *asyncInfo) { return hrtry([&, this] { *asyncInfo = to_abi(X::get()->GetThumbnailAsync()); }); }
	STDMETHODIMP _get_BitmapProperties(BitmapPropertiesView* *value) { return hrtry([&, this] { get_prop(value, BitmapProperties); }); }
	STDMETHODIMP _get_BitmapPixelFormat(Imaging::BitmapPixelFormat *value) { return hrtry([&, this] { get_prop(value, BitmapPixelFormat); }); }
	STDMETHODIMP _get_BitmapAlphaMode(Imaging::BitmapAlphaMode *value) { return hrtry([&, this] { get_prop(value, BitmapAlphaMode); }); }
	STDMETHODIMP _get_DpiX(double *value) { return hrtry([&, this] { get_prop(value, DpiX); }); }
	STDMETHODIMP _get_DpiY(double *value) { return hrtry([&, this] { get_prop(value, DpiY); }); }
	STDMETHODIMP _get_PixelWidth(unsigned *value) { return hrtry([&, this] { get_prop(value, PixelWidth); }); }
	STDMETHODIMP _get_PixelHeight(unsigned *value) { return hrtry([&, this] { get_prop(value, PixelHeight); }); }
	STDMETHODIMP _get_OrientedPixelWidth(unsigned *value) { return hrtry([&, this] { get_prop(value, OrientedPixelWidth); }); }
	STDMETHODIMP _get_OrientedPixelHeight(unsigned *value) { return hrtry([&, this] { get_prop(value, OrientedPixelHeight); }); }
	STDMETHODIMP _GetPixelDataAsync(Foundation::IAsyncOperation<PixelDataProvider*>* *asyncInfo) { return hrtry([&, this] { *asyncInfo = to_abi(X::get()->GetPixelDataAsync()); }); }
	STDMETHODIMP _GetPixelDataTransformedAsync(Imaging::BitmapPixelFormat pixelFormat, Imaging::BitmapAlphaMode alphaMode, BitmapTransform* transform, ExifOrientationMode exifOrientationMode, ColorManagementMode colorManagementMode, Foundation::IAsyncOperation<PixelDataProvider*>* *asyncInfo) { return hrtry([&, this] { *asyncInfo = to_abi(X::get()->GetPixelDataAsync(pixelFormat, alphaMode, transform, exifOrientationMode, colorManagementMode)); }); }
};
template<typename X> struct unadapt<IBitmapFrame, X> : Windows::Graphics::Imaging::IBitmapFrame_unadaptor<X> {};
struct IBitmapFrame : IBitmapFrame_raw, generate<IBitmapFrame> {};

// IBitmapFrameWithSoftwareBitmap
struct IBitmapFrameWithSoftwareBitmap_raw : IInspectable {
	virtual STDMETHODIMP _GetSoftwareBitmapAsync(Foundation::IAsyncOperation<SoftwareBitmap*>* *value) = 0;
	virtual STDMETHODIMP _GetSoftwareBitmapConvertedAsync(Imaging::BitmapPixelFormat pixelFormat, Imaging::BitmapAlphaMode alphaMode, Foundation::IAsyncOperation<SoftwareBitmap*>* *value) = 0;
	virtual STDMETHODIMP _GetSoftwareBitmapTransformedAsync(Imaging::BitmapPixelFormat pixelFormat, Imaging::BitmapAlphaMode alphaMode, BitmapTransform* transform, ExifOrientationMode exifOrientationMode, ColorManagementMode colorManagementMode, Foundation::IAsyncOperation<SoftwareBitmap*>* *value) = 0;
};
template<typename X> struct IBitmapFrameWithSoftwareBitmap_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<SoftwareBitmap>>> GetSoftwareBitmapAsync() { Foundation::IAsyncOperation<SoftwareBitmap*>* value; hrcheck(X::get()->_GetSoftwareBitmapAsync(&value)); return from_abi(value); }
	ptr<Foundation::IAsyncOperation<ptr<SoftwareBitmap>>> GetSoftwareBitmapAsync(Imaging::BitmapPixelFormat pixelFormat, Imaging::BitmapAlphaMode alphaMode) { Foundation::IAsyncOperation<SoftwareBitmap*>* value; hrcheck(X::get()->_GetSoftwareBitmapConvertedAsync(pixelFormat, alphaMode, &value)); return from_abi(value); }
	ptr<Foundation::IAsyncOperation<ptr<SoftwareBitmap>>> GetSoftwareBitmapAsync(Imaging::BitmapPixelFormat pixelFormat, Imaging::BitmapAlphaMode alphaMode, pptr<BitmapTransform> transform, ExifOrientationMode exifOrientationMode, ColorManagementMode colorManagementMode) { Foundation::IAsyncOperation<SoftwareBitmap*>* value; hrcheck(X::get()->_GetSoftwareBitmapTransformedAsync(pixelFormat, alphaMode, transform, exifOrientationMode, colorManagementMode, &value)); return from_abi(value); }
};
template<typename X> struct adapt<IBitmapFrameWithSoftwareBitmap, X> : Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap_adaptor<X> { typedef adapt IBitmapFrameWithSoftwareBitmap; };
template<typename X> struct IBitmapFrameWithSoftwareBitmap_unadaptor : X {
	STDMETHODIMP _GetSoftwareBitmapAsync(Foundation::IAsyncOperation<SoftwareBitmap*>* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetSoftwareBitmapAsync()); }); }
	STDMETHODIMP _GetSoftwareBitmapConvertedAsync(Imaging::BitmapPixelFormat pixelFormat, Imaging::BitmapAlphaMode alphaMode, Foundation::IAsyncOperation<SoftwareBitmap*>* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetSoftwareBitmapAsync(pixelFormat, alphaMode)); }); }
	STDMETHODIMP _GetSoftwareBitmapTransformedAsync(Imaging::BitmapPixelFormat pixelFormat, Imaging::BitmapAlphaMode alphaMode, BitmapTransform* transform, ExifOrientationMode exifOrientationMode, ColorManagementMode colorManagementMode, Foundation::IAsyncOperation<SoftwareBitmap*>* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetSoftwareBitmapAsync(pixelFormat, alphaMode, transform, exifOrientationMode, colorManagementMode)); }); }
};
template<typename X> struct unadapt<IBitmapFrameWithSoftwareBitmap, X> : Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap_unadaptor<X> {};
struct IBitmapFrameWithSoftwareBitmap : IBitmapFrameWithSoftwareBitmap_raw, generate<IBitmapFrameWithSoftwareBitmap> {};

// BitmapFrame
template<typename X> struct statics<BitmapFrame, X> : X {
	typedef typename X::root_type BitmapFrame;
};
struct BitmapFrame : generate<BitmapFrame> {
	using IBitmapFrame::GetPixelDataAsync;
	using IBitmapFrameWithSoftwareBitmap::GetSoftwareBitmapAsync;
};

// IBitmapCodecInformation
struct IBitmapCodecInformation_raw : IInspectable {
	virtual STDMETHODIMP _get_CodecId(Platform::Guid *value);
	virtual STDMETHODIMP _get_FileExtensions(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _get_FriendlyName(HSTRING *value);
	virtual STDMETHODIMP _get_MimeTypes(Foundation::Collections::IVectorView<HSTRING>* *value);
};
template<typename X> struct IBitmapCodecInformation_adaptor : X {
	union {
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IBitmapCodecInformation_adaptor::CodecId)->_get_CodecId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} CodecId;
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&IBitmapCodecInformation_adaptor::FileExtensions)->_get_FileExtensions(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} FileExtensions;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IBitmapCodecInformation_adaptor::FriendlyName)->_get_FriendlyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} FriendlyName;
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&IBitmapCodecInformation_adaptor::MimeTypes)->_get_MimeTypes(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} MimeTypes;
	};
	IBitmapCodecInformation_adaptor() {}
};
template<typename X> struct adapt<IBitmapCodecInformation, X> : Windows::Graphics::Imaging::IBitmapCodecInformation_adaptor<X> { typedef adapt IBitmapCodecInformation; };
struct IBitmapCodecInformation : IBitmapCodecInformation_raw, generate<IBitmapCodecInformation> {};

// BitmapCodecInformation
template<typename X> struct statics<BitmapCodecInformation, X> : X {
	typedef typename X::root_type BitmapCodecInformation;
};
struct BitmapCodecInformation : generate<BitmapCodecInformation> {};

// IBitmapDecoderStatics
struct IBitmapDecoderStatics : IInspectable {
	virtual STDMETHODIMP _get_BmpDecoderId(Platform::Guid *value);
	virtual STDMETHODIMP _get_JpegDecoderId(Platform::Guid *value);
	virtual STDMETHODIMP _get_PngDecoderId(Platform::Guid *value);
	virtual STDMETHODIMP _get_TiffDecoderId(Platform::Guid *value);
	virtual STDMETHODIMP _get_GifDecoderId(Platform::Guid *value);
	virtual STDMETHODIMP _get_JpegXRDecoderId(Platform::Guid *value);
	virtual STDMETHODIMP _get_IcoDecoderId(Platform::Guid *value);
	virtual STDMETHODIMP _GetDecoderInformationEnumerator(Foundation::Collections::IVectorView<BitmapCodecInformation*>* *decoderInformationEnumerator);
	virtual STDMETHODIMP _CreateAsync(Storage::Streams::IRandomAccessStream* stream, Foundation::IAsyncOperation<BitmapDecoder*>* *asyncInfo);
	virtual STDMETHODIMP _CreateWithIdAsync(Platform::Guid decoderId, Storage::Streams::IRandomAccessStream* stream, Foundation::IAsyncOperation<BitmapDecoder*>* *asyncInfo);
};

// IBitmapDecoder
struct IBitmapDecoder_raw : IInspectable {
	virtual STDMETHODIMP _get_BitmapContainerProperties(BitmapPropertiesView* *value);
	virtual STDMETHODIMP _get_DecoderInformation(BitmapCodecInformation* *value);
	virtual STDMETHODIMP _get_FrameCount(unsigned *value);
	virtual STDMETHODIMP _GetPreviewAsync(Foundation::IAsyncOperation<ImageStream*>* *asyncInfo);
	virtual STDMETHODIMP _GetFrameAsync(unsigned frameIndex, Foundation::IAsyncOperation<BitmapFrame*>* *asyncInfo);
};
template<typename X> struct IBitmapDecoder_adaptor : X {
	union {
		struct : property {
			ptr<BitmapPropertiesView> get() { BitmapPropertiesView* value; hrcheck(enc(&IBitmapDecoder_adaptor::BitmapContainerProperties)->_get_BitmapContainerProperties(&value)); return from_abi(value); }
			ptr<BitmapPropertiesView> operator()() { return get(); }
			operator ptr<BitmapPropertiesView> () { return get(); }
			ptr<BitmapPropertiesView> operator->() { return get(); }
		} BitmapContainerProperties;
		struct : property {
			ptr<BitmapCodecInformation> get() { BitmapCodecInformation* value; hrcheck(enc(&IBitmapDecoder_adaptor::DecoderInformation)->_get_DecoderInformation(&value)); return from_abi(value); }
			ptr<BitmapCodecInformation> operator()() { return get(); }
			operator ptr<BitmapCodecInformation> () { return get(); }
			ptr<BitmapCodecInformation> operator->() { return get(); }
		} DecoderInformation;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IBitmapDecoder_adaptor::FrameCount)->_get_FrameCount(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} FrameCount;
	};
	ptr<Foundation::IAsyncOperation<ptr<ImageStream>>> GetPreviewAsync() { Foundation::IAsyncOperation<ImageStream*>* asyncInfo; hrcheck(X::get()->_GetPreviewAsync(&asyncInfo)); return from_abi(asyncInfo); }
	ptr<Foundation::IAsyncOperation<ptr<BitmapFrame>>> GetFrameAsync(unsigned frameIndex) { Foundation::IAsyncOperation<BitmapFrame*>* asyncInfo; hrcheck(X::get()->_GetFrameAsync(frameIndex, &asyncInfo)); return from_abi(asyncInfo); }
	IBitmapDecoder_adaptor() {}
};
template<typename X> struct adapt<IBitmapDecoder, X> : Windows::Graphics::Imaging::IBitmapDecoder_adaptor<X> { typedef adapt IBitmapDecoder; };
struct IBitmapDecoder : IBitmapDecoder_raw, generate<IBitmapDecoder> {};

// BitmapDecoder
template<typename> struct BitmapDecoder_statics {
	static struct _BmpDecoderId : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<BitmapDecoder, IBitmapDecoderStatics>()->_get_BmpDecoderId(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} BmpDecoderId;
	static struct _GifDecoderId : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<BitmapDecoder, IBitmapDecoderStatics>()->_get_GifDecoderId(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} GifDecoderId;
	static struct _IcoDecoderId : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<BitmapDecoder, IBitmapDecoderStatics>()->_get_IcoDecoderId(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} IcoDecoderId;
	static struct _JpegDecoderId : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<BitmapDecoder, IBitmapDecoderStatics>()->_get_JpegDecoderId(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} JpegDecoderId;
	static struct _JpegXRDecoderId : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<BitmapDecoder, IBitmapDecoderStatics>()->_get_JpegXRDecoderId(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} JpegXRDecoderId;
	static struct _PngDecoderId : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<BitmapDecoder, IBitmapDecoderStatics>()->_get_PngDecoderId(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} PngDecoderId;
	static struct _TiffDecoderId : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<BitmapDecoder, IBitmapDecoderStatics>()->_get_TiffDecoderId(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} TiffDecoderId;
	static ptr<Foundation::Collections::IVectorView<ptr<BitmapCodecInformation>>> GetDecoderInformationEnumerator() { Foundation::Collections::IVectorView<BitmapCodecInformation*>* decoderInformationEnumerator; hrcheck(get_activation_factory<BitmapDecoder, IBitmapDecoderStatics>()->_GetDecoderInformationEnumerator(&decoderInformationEnumerator)); return from_abi(decoderInformationEnumerator); }
	static ptr<Foundation::IAsyncOperation<ptr<BitmapDecoder>>> CreateAsync(pptr<Storage::Streams::IRandomAccessStream> stream) { Foundation::IAsyncOperation<BitmapDecoder*>* asyncInfo; hrcheck(get_activation_factory<BitmapDecoder, IBitmapDecoderStatics>()->_CreateAsync(stream, &asyncInfo)); return from_abi(asyncInfo); }
	static ptr<Foundation::IAsyncOperation<ptr<BitmapDecoder>>> CreateAsync(const Platform::Guid& decoderId, pptr<Storage::Streams::IRandomAccessStream> stream) { Foundation::IAsyncOperation<BitmapDecoder*>* asyncInfo; hrcheck(get_activation_factory<BitmapDecoder, IBitmapDecoderStatics>()->_CreateWithIdAsync(decoderId, stream, &asyncInfo)); return from_abi(asyncInfo); }
};
template<typename X> typename BitmapDecoder_statics<X>::_BmpDecoderId BitmapDecoder_statics<X>::BmpDecoderId;
template<typename X> typename BitmapDecoder_statics<X>::_GifDecoderId BitmapDecoder_statics<X>::GifDecoderId;
template<typename X> typename BitmapDecoder_statics<X>::_IcoDecoderId BitmapDecoder_statics<X>::IcoDecoderId;
template<typename X> typename BitmapDecoder_statics<X>::_JpegDecoderId BitmapDecoder_statics<X>::JpegDecoderId;
template<typename X> typename BitmapDecoder_statics<X>::_JpegXRDecoderId BitmapDecoder_statics<X>::JpegXRDecoderId;
template<typename X> typename BitmapDecoder_statics<X>::_PngDecoderId BitmapDecoder_statics<X>::PngDecoderId;
template<typename X> typename BitmapDecoder_statics<X>::_TiffDecoderId BitmapDecoder_statics<X>::TiffDecoderId;

template<typename X> struct statics<BitmapDecoder, X> : X, Windows::Graphics::Imaging::BitmapDecoder_statics<void> {
	typedef typename X::root_type BitmapDecoder;
};
struct BitmapDecoder : generate<BitmapDecoder> {
	using IBitmapFrame::GetPixelDataAsync;
	using IBitmapFrameWithSoftwareBitmap::GetSoftwareBitmapAsync;
};

// IBitmapEncoderStatics
struct IBitmapEncoderStatics : IInspectable {
	virtual STDMETHODIMP _get_BmpEncoderId(Platform::Guid *value);
	virtual STDMETHODIMP _get_JpegEncoderId(Platform::Guid *value);
	virtual STDMETHODIMP _get_PngEncoderId(Platform::Guid *value);
	virtual STDMETHODIMP _get_TiffEncoderId(Platform::Guid *value);
	virtual STDMETHODIMP _get_GifEncoderId(Platform::Guid *value);
	virtual STDMETHODIMP _get_JpegXREncoderId(Platform::Guid *value);
	virtual STDMETHODIMP _GetEncoderInformationEnumerator(Foundation::Collections::IVectorView<BitmapCodecInformation*>* *encoderInformationEnumerator);
	virtual STDMETHODIMP _CreateAsync(Platform::Guid encoderId, Storage::Streams::IRandomAccessStream* stream, Foundation::IAsyncOperation<BitmapEncoder*>* *asyncInfo);
	virtual STDMETHODIMP _CreateWithEncodingOptionsAsync(Platform::Guid encoderId, Storage::Streams::IRandomAccessStream* stream, Foundation::Collections::IIterable<Foundation::Collections::IKeyValuePair<HSTRING, BitmapTypedValue*>*>* encodingOptions, Foundation::IAsyncOperation<BitmapEncoder*>* *asyncInfo);
	virtual STDMETHODIMP _CreateForTranscodingAsync(Storage::Streams::IRandomAccessStream* stream, BitmapDecoder* bitmapDecoder, Foundation::IAsyncOperation<BitmapEncoder*>* *asyncInfo);
	virtual STDMETHODIMP _CreateForInPlacePropertyEncodingAsync(BitmapDecoder* bitmapDecoder, Foundation::IAsyncOperation<BitmapEncoder*>* *asyncInfo);
};

// IBitmapEncoderWithSoftwareBitmap
struct IBitmapEncoderWithSoftwareBitmap_raw : IInspectable {
	virtual STDMETHODIMP _SetSoftwareBitmap(SoftwareBitmap* bitmap);
};
template<typename X> struct IBitmapEncoderWithSoftwareBitmap_adaptor : X {
	void SetSoftwareBitmap(pptr<SoftwareBitmap> bitmap) { hrcheck(X::get()->_SetSoftwareBitmap(bitmap)); }
};
template<typename X> struct adapt<IBitmapEncoderWithSoftwareBitmap, X> : Windows::Graphics::Imaging::IBitmapEncoderWithSoftwareBitmap_adaptor<X> { typedef adapt IBitmapEncoderWithSoftwareBitmap; };
struct IBitmapEncoderWithSoftwareBitmap : IBitmapEncoderWithSoftwareBitmap_raw, generate<IBitmapEncoderWithSoftwareBitmap> {};

// IBitmapEncoder
struct IBitmapEncoder_raw : IInspectable {
	virtual STDMETHODIMP _get_EncoderInformation(BitmapCodecInformation* *value);
	virtual STDMETHODIMP _get_BitmapProperties(Imaging::BitmapProperties* *value);
	virtual STDMETHODIMP _get_BitmapContainerProperties(Imaging::BitmapProperties* *value);
	virtual STDMETHODIMP _get_IsThumbnailGenerated(bool *value);
	virtual STDMETHODIMP _put_IsThumbnailGenerated(bool value);
	virtual STDMETHODIMP _get_GeneratedThumbnailWidth(unsigned *value);
	virtual STDMETHODIMP _put_GeneratedThumbnailWidth(unsigned value);
	virtual STDMETHODIMP _get_GeneratedThumbnailHeight(unsigned *value);
	virtual STDMETHODIMP _put_GeneratedThumbnailHeight(unsigned value);
	virtual STDMETHODIMP _get_BitmapTransform(Imaging::BitmapTransform* *value);
	virtual STDMETHODIMP _SetPixelData(BitmapPixelFormat pixelFormat, BitmapAlphaMode alphaMode, unsigned width, unsigned height, double dpiX, double dpiY, unsigned pixelsSize, unsigned char *pixels);
	virtual STDMETHODIMP _GoToNextFrameAsync(Foundation::IAsyncAction* *asyncInfo);
	virtual STDMETHODIMP _GoToNextFrameWithEncodingOptionsAsync(Foundation::Collections::IIterable<Foundation::Collections::IKeyValuePair<HSTRING, BitmapTypedValue*>*>* encodingOptions, Foundation::IAsyncAction* *asyncInfo);
	virtual STDMETHODIMP _FlushAsync(Foundation::IAsyncAction* *asyncInfo);
};
template<typename X> struct IBitmapEncoder_adaptor : X {
	union {
		struct : property {
			ptr<Imaging::BitmapProperties> get() { Imaging::BitmapProperties* value; hrcheck(enc(&IBitmapEncoder_adaptor::BitmapContainerProperties)->_get_BitmapContainerProperties(&value)); return from_abi(value); }
			ptr<Imaging::BitmapProperties> operator()() { return get(); }
			operator ptr<Imaging::BitmapProperties> () { return get(); }
			ptr<Imaging::BitmapProperties> operator->() { return get(); }
		} BitmapContainerProperties;
		struct : property {
			ptr<Imaging::BitmapProperties> get() { Imaging::BitmapProperties* value; hrcheck(enc(&IBitmapEncoder_adaptor::BitmapProperties)->_get_BitmapProperties(&value)); return from_abi(value); }
			ptr<Imaging::BitmapProperties> operator()() { return get(); }
			operator ptr<Imaging::BitmapProperties> () { return get(); }
			ptr<Imaging::BitmapProperties> operator->() { return get(); }
		} BitmapProperties;
		struct : property {
			ptr<Imaging::BitmapTransform> get() { Imaging::BitmapTransform* value; hrcheck(enc(&IBitmapEncoder_adaptor::BitmapTransform)->_get_BitmapTransform(&value)); return from_abi(value); }
			ptr<Imaging::BitmapTransform> operator()() { return get(); }
			operator ptr<Imaging::BitmapTransform> () { return get(); }
			ptr<Imaging::BitmapTransform> operator->() { return get(); }
		} BitmapTransform;
		struct : property {
			ptr<BitmapCodecInformation> get() { BitmapCodecInformation* value; hrcheck(enc(&IBitmapEncoder_adaptor::EncoderInformation)->_get_EncoderInformation(&value)); return from_abi(value); }
			ptr<BitmapCodecInformation> operator()() { return get(); }
			operator ptr<BitmapCodecInformation> () { return get(); }
			ptr<BitmapCodecInformation> operator->() { return get(); }
		} EncoderInformation;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IBitmapEncoder_adaptor::GeneratedThumbnailHeight)->_get_GeneratedThumbnailHeight(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IBitmapEncoder_adaptor::GeneratedThumbnailHeight)->_put_GeneratedThumbnailHeight(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} GeneratedThumbnailHeight;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IBitmapEncoder_adaptor::GeneratedThumbnailWidth)->_get_GeneratedThumbnailWidth(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IBitmapEncoder_adaptor::GeneratedThumbnailWidth)->_put_GeneratedThumbnailWidth(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} GeneratedThumbnailWidth;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBitmapEncoder_adaptor::IsThumbnailGenerated)->_get_IsThumbnailGenerated(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IBitmapEncoder_adaptor::IsThumbnailGenerated)->_put_IsThumbnailGenerated(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsThumbnailGenerated;
	};
	void SetPixelData(BitmapPixelFormat pixelFormat, BitmapAlphaMode alphaMode, unsigned width, unsigned height, double dpiX, double dpiY, const szarray<unsigned char>& pixels) { hrcheck(X::get()->_SetPixelData(pixelFormat, alphaMode, width, height, dpiX, dpiY, pixels.size, to_abi(pixels.p))); }
	ptr<Foundation::IAsyncAction> GoToNextFrameAsync() { Foundation::IAsyncAction* asyncInfo; hrcheck(X::get()->_GoToNextFrameAsync(&asyncInfo)); return from_abi(asyncInfo); }
	ptr<Foundation::IAsyncAction> GoToNextFrameAsync(pptr<Foundation::Collections::IIterable<ptr<Foundation::Collections::IKeyValuePair<hstring, ptr<BitmapTypedValue>>>>> encodingOptions) { Foundation::IAsyncAction* asyncInfo; hrcheck(X::get()->_GoToNextFrameWithEncodingOptionsAsync(to_abi(encodingOptions), &asyncInfo)); return from_abi(asyncInfo); }
	ptr<Foundation::IAsyncAction> FlushAsync() { Foundation::IAsyncAction* asyncInfo; hrcheck(X::get()->_FlushAsync(&asyncInfo)); return from_abi(asyncInfo); }
	IBitmapEncoder_adaptor() {}
};
template<typename X> struct adapt<IBitmapEncoder, X> : Windows::Graphics::Imaging::IBitmapEncoder_adaptor<X> { typedef adapt IBitmapEncoder; };
struct IBitmapEncoder : IBitmapEncoder_raw, generate<IBitmapEncoder> {};

// BitmapEncoder
template<typename> struct BitmapEncoder_statics {
	static struct _BmpEncoderId : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<BitmapEncoder, IBitmapEncoderStatics>()->_get_BmpEncoderId(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} BmpEncoderId;
	static struct _GifEncoderId : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<BitmapEncoder, IBitmapEncoderStatics>()->_get_GifEncoderId(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} GifEncoderId;
	static struct _JpegEncoderId : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<BitmapEncoder, IBitmapEncoderStatics>()->_get_JpegEncoderId(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} JpegEncoderId;
	static struct _JpegXREncoderId : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<BitmapEncoder, IBitmapEncoderStatics>()->_get_JpegXREncoderId(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} JpegXREncoderId;
	static struct _PngEncoderId : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<BitmapEncoder, IBitmapEncoderStatics>()->_get_PngEncoderId(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} PngEncoderId;
	static struct _TiffEncoderId : property {
		Platform::Guid get() { Platform::Guid value; hrcheck(get_activation_factory<BitmapEncoder, IBitmapEncoderStatics>()->_get_TiffEncoderId(&value)); return value; }
		Platform::Guid operator()() { return get(); }
		operator Platform::Guid () { return get(); }
	} TiffEncoderId;
	static ptr<Foundation::Collections::IVectorView<ptr<BitmapCodecInformation>>> GetEncoderInformationEnumerator() { Foundation::Collections::IVectorView<BitmapCodecInformation*>* encoderInformationEnumerator; hrcheck(get_activation_factory<BitmapEncoder, IBitmapEncoderStatics>()->_GetEncoderInformationEnumerator(&encoderInformationEnumerator)); return from_abi(encoderInformationEnumerator); }
	static ptr<Foundation::IAsyncOperation<ptr<BitmapEncoder>>> CreateAsync(const Platform::Guid& encoderId, pptr<Storage::Streams::IRandomAccessStream> stream) { Foundation::IAsyncOperation<BitmapEncoder*>* asyncInfo; hrcheck(get_activation_factory<BitmapEncoder, IBitmapEncoderStatics>()->_CreateAsync(encoderId, stream, &asyncInfo)); return from_abi(asyncInfo); }
	static ptr<Foundation::IAsyncOperation<ptr<BitmapEncoder>>> CreateAsync(const Platform::Guid& encoderId, pptr<Storage::Streams::IRandomAccessStream> stream, pptr<Foundation::Collections::IIterable<ptr<Foundation::Collections::IKeyValuePair<hstring, ptr<BitmapTypedValue>>>>> encodingOptions) { Foundation::IAsyncOperation<BitmapEncoder*>* asyncInfo; hrcheck(get_activation_factory<BitmapEncoder, IBitmapEncoderStatics>()->_CreateWithEncodingOptionsAsync(encoderId, stream, to_abi(encodingOptions), &asyncInfo)); return from_abi(asyncInfo); }
	static ptr<Foundation::IAsyncOperation<ptr<BitmapEncoder>>> CreateForTranscodingAsync(pptr<Storage::Streams::IRandomAccessStream> stream, pptr<BitmapDecoder> bitmapDecoder) { Foundation::IAsyncOperation<BitmapEncoder*>* asyncInfo; hrcheck(get_activation_factory<BitmapEncoder, IBitmapEncoderStatics>()->_CreateForTranscodingAsync(stream, bitmapDecoder, &asyncInfo)); return from_abi(asyncInfo); }
	static ptr<Foundation::IAsyncOperation<ptr<BitmapEncoder>>> CreateForInPlacePropertyEncodingAsync(pptr<BitmapDecoder> bitmapDecoder) { Foundation::IAsyncOperation<BitmapEncoder*>* asyncInfo; hrcheck(get_activation_factory<BitmapEncoder, IBitmapEncoderStatics>()->_CreateForInPlacePropertyEncodingAsync(bitmapDecoder, &asyncInfo)); return from_abi(asyncInfo); }
};
template<typename X> typename BitmapEncoder_statics<X>::_BmpEncoderId BitmapEncoder_statics<X>::BmpEncoderId;
template<typename X> typename BitmapEncoder_statics<X>::_GifEncoderId BitmapEncoder_statics<X>::GifEncoderId;
template<typename X> typename BitmapEncoder_statics<X>::_JpegEncoderId BitmapEncoder_statics<X>::JpegEncoderId;
template<typename X> typename BitmapEncoder_statics<X>::_JpegXREncoderId BitmapEncoder_statics<X>::JpegXREncoderId;
template<typename X> typename BitmapEncoder_statics<X>::_PngEncoderId BitmapEncoder_statics<X>::PngEncoderId;
template<typename X> typename BitmapEncoder_statics<X>::_TiffEncoderId BitmapEncoder_statics<X>::TiffEncoderId;

template<typename X> struct statics<BitmapEncoder, X> : X, Windows::Graphics::Imaging::BitmapEncoder_statics<void> {
	typedef typename X::root_type BitmapEncoder;
};
struct BitmapEncoder : generate<BitmapEncoder> {
	using IBitmapEncoder::GoToNextFrameAsync;
};

// ISoftwareBitmap
struct ISoftwareBitmap_raw : IInspectable {
	virtual STDMETHODIMP _get_BitmapPixelFormat(Imaging::BitmapPixelFormat *value);
	virtual STDMETHODIMP _get_BitmapAlphaMode(Imaging::BitmapAlphaMode *value);
	virtual STDMETHODIMP _get_PixelWidth(int *value);
	virtual STDMETHODIMP _get_PixelHeight(int *value);
	virtual STDMETHODIMP _get_IsReadOnly(bool *value);
	virtual STDMETHODIMP _put_DpiX(double value);
	virtual STDMETHODIMP _get_DpiX(double *value);
	virtual STDMETHODIMP _put_DpiY(double value);
	virtual STDMETHODIMP _get_DpiY(double *value);
	virtual STDMETHODIMP _LockBuffer(BitmapBufferAccessMode mode, BitmapBuffer* *value);
	virtual STDMETHODIMP _CopyTo(SoftwareBitmap* bitmap);
	virtual STDMETHODIMP _CopyFromBuffer(Storage::Streams::IBuffer* buffer);
	virtual STDMETHODIMP _CopyToBuffer(Storage::Streams::IBuffer* buffer);
	virtual STDMETHODIMP _GetReadOnlyView(SoftwareBitmap* *value);
};
template<typename X> struct ISoftwareBitmap_adaptor : X {
	union {
		struct : property {
			Imaging::BitmapAlphaMode get() { Imaging::BitmapAlphaMode value; hrcheck(enc(&ISoftwareBitmap_adaptor::BitmapAlphaMode)->_get_BitmapAlphaMode(&value)); return value; }
			Imaging::BitmapAlphaMode operator()() { return get(); }
			operator Imaging::BitmapAlphaMode () { return get(); }
		} BitmapAlphaMode;
		struct : property {
			Imaging::BitmapPixelFormat get() { Imaging::BitmapPixelFormat value; hrcheck(enc(&ISoftwareBitmap_adaptor::BitmapPixelFormat)->_get_BitmapPixelFormat(&value)); return value; }
			Imaging::BitmapPixelFormat operator()() { return get(); }
			operator Imaging::BitmapPixelFormat () { return get(); }
		} BitmapPixelFormat;
		struct : property {
			double get() { double value; hrcheck(enc(&ISoftwareBitmap_adaptor::DpiX)->_get_DpiX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISoftwareBitmap_adaptor::DpiX)->_put_DpiX(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DpiX;
		struct : property {
			double get() { double value; hrcheck(enc(&ISoftwareBitmap_adaptor::DpiY)->_get_DpiY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISoftwareBitmap_adaptor::DpiY)->_put_DpiY(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DpiY;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISoftwareBitmap_adaptor::IsReadOnly)->_get_IsReadOnly(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsReadOnly;
		struct : property {
			int get() { int value; hrcheck(enc(&ISoftwareBitmap_adaptor::PixelHeight)->_get_PixelHeight(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} PixelHeight;
		struct : property {
			int get() { int value; hrcheck(enc(&ISoftwareBitmap_adaptor::PixelWidth)->_get_PixelWidth(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} PixelWidth;
	};
	ptr<BitmapBuffer> LockBuffer(BitmapBufferAccessMode mode) { BitmapBuffer* value; hrcheck(X::get()->_LockBuffer(mode, &value)); return from_abi(value); }
	void CopyTo(pptr<SoftwareBitmap> bitmap) { hrcheck(X::get()->_CopyTo(bitmap)); }
	void CopyFromBuffer(pptr<Storage::Streams::IBuffer> buffer) { hrcheck(X::get()->_CopyFromBuffer(buffer)); }
	void CopyToBuffer(pptr<Storage::Streams::IBuffer> buffer) { hrcheck(X::get()->_CopyToBuffer(buffer)); }
	ptr<SoftwareBitmap> GetReadOnlyView() { SoftwareBitmap* value; hrcheck(X::get()->_GetReadOnlyView(&value)); return from_abi(value); }
	ISoftwareBitmap_adaptor() {}
};
template<typename X> struct adapt<ISoftwareBitmap, X> : Windows::Graphics::Imaging::ISoftwareBitmap_adaptor<X> { typedef adapt ISoftwareBitmap; };
struct ISoftwareBitmap : ISoftwareBitmap_raw, generate<ISoftwareBitmap> {};

// IBitmapBuffer
struct IBitmapBuffer_raw : IInspectable {
	virtual STDMETHODIMP _GetPlaneCount(int *value);
	virtual STDMETHODIMP _GetPlaneDescription(int index, BitmapPlaneDescription *value);
};
template<typename X> struct IBitmapBuffer_adaptor : X {
	int GetPlaneCount() { int value; hrcheck(X::get()->_GetPlaneCount(&value)); return value; }
	BitmapPlaneDescription GetPlaneDescription(int index) { BitmapPlaneDescription value; hrcheck(X::get()->_GetPlaneDescription(index, &value)); return value; }
};
template<typename X> struct adapt<IBitmapBuffer, X> : Windows::Graphics::Imaging::IBitmapBuffer_adaptor<X> { typedef adapt IBitmapBuffer; };
struct IBitmapBuffer : IBitmapBuffer_raw, generate<IBitmapBuffer> {};

// BitmapBuffer
template<typename X> struct statics<BitmapBuffer, X> : X {
	typedef typename X::root_type BitmapBuffer;
};
struct BitmapBuffer : generate<BitmapBuffer> {};

// ISoftwareBitmapStatics
struct ISoftwareBitmapStatics : IInspectable {
	virtual STDMETHODIMP _Copy(SoftwareBitmap* source, SoftwareBitmap* *value);
	virtual STDMETHODIMP _Convert(SoftwareBitmap* source, BitmapPixelFormat format, SoftwareBitmap* *value);
	virtual STDMETHODIMP _ConvertWithAlpha(SoftwareBitmap* source, BitmapPixelFormat format, BitmapAlphaMode alpha, SoftwareBitmap* *value);
	virtual STDMETHODIMP _CreateCopyFromBuffer(Storage::Streams::IBuffer* source, BitmapPixelFormat format, int width, int height, SoftwareBitmap* *value);
	virtual STDMETHODIMP _CreateCopyWithAlphaFromBuffer(Storage::Streams::IBuffer* source, BitmapPixelFormat format, int width, int height, BitmapAlphaMode alpha, SoftwareBitmap* *value);
	virtual STDMETHODIMP _CreateCopyFromSurfaceAsync(DirectX::Direct3D11::IDirect3DSurface* surface, Foundation::IAsyncOperation<SoftwareBitmap*>* *value);
	virtual STDMETHODIMP _CreateCopyWithAlphaFromSurfaceAsync(DirectX::Direct3D11::IDirect3DSurface* surface, BitmapAlphaMode alpha, Foundation::IAsyncOperation<SoftwareBitmap*>* *value);
};

// ISoftwareBitmapFactory
struct ISoftwareBitmapFactory : IInspectable {
	virtual STDMETHODIMP _Create(BitmapPixelFormat format, int width, int height, SoftwareBitmap* *value);
	virtual STDMETHODIMP _CreateWithAlpha(BitmapPixelFormat format, int width, int height, BitmapAlphaMode alpha, SoftwareBitmap* *value);
};

// SoftwareBitmap
template<typename> struct SoftwareBitmap_statics {
	static ptr<SoftwareBitmap> Copy(pptr<SoftwareBitmap> source) { SoftwareBitmap* value; hrcheck(get_activation_factory<SoftwareBitmap, ISoftwareBitmapStatics>()->_Copy(source, &value)); return from_abi(value); }
	static ptr<SoftwareBitmap> Convert(pptr<SoftwareBitmap> source, Imaging::BitmapPixelFormat format) { SoftwareBitmap* value; hrcheck(get_activation_factory<SoftwareBitmap, ISoftwareBitmapStatics>()->_Convert(source, format, &value)); return from_abi(value); }
	static ptr<SoftwareBitmap> Convert(pptr<SoftwareBitmap> source, Imaging::BitmapPixelFormat format, Imaging::BitmapAlphaMode alpha) { SoftwareBitmap* value; hrcheck(get_activation_factory<SoftwareBitmap, ISoftwareBitmapStatics>()->_ConvertWithAlpha(source, format, alpha, &value)); return from_abi(value); }
	static ptr<SoftwareBitmap> CreateCopyFromBuffer(pptr<Storage::Streams::IBuffer> source, Imaging::BitmapPixelFormat format, int width, int height) { SoftwareBitmap* value; hrcheck(get_activation_factory<SoftwareBitmap, ISoftwareBitmapStatics>()->_CreateCopyFromBuffer(source, format, width, height, &value)); return from_abi(value); }
	static ptr<SoftwareBitmap> CreateCopyFromBuffer(pptr<Storage::Streams::IBuffer> source, Imaging::BitmapPixelFormat format, int width, int height, Imaging::BitmapAlphaMode alpha) { SoftwareBitmap* value; hrcheck(get_activation_factory<SoftwareBitmap, ISoftwareBitmapStatics>()->_CreateCopyWithAlphaFromBuffer(source, format, width, height, alpha, &value)); return from_abi(value); }
	static ptr<Foundation::IAsyncOperation<ptr<SoftwareBitmap>>> CreateCopyFromSurfaceAsync(pptr<DirectX::Direct3D11::IDirect3DSurface> surface) { Foundation::IAsyncOperation<SoftwareBitmap*>* value; hrcheck(get_activation_factory<SoftwareBitmap, ISoftwareBitmapStatics>()->_CreateCopyFromSurfaceAsync(surface, &value)); return from_abi(value); }
	static ptr<Foundation::IAsyncOperation<ptr<SoftwareBitmap>>> CreateCopyFromSurfaceAsync(pptr<DirectX::Direct3D11::IDirect3DSurface> surface, Imaging::BitmapAlphaMode alpha) { Foundation::IAsyncOperation<SoftwareBitmap*>* value; hrcheck(get_activation_factory<SoftwareBitmap, ISoftwareBitmapStatics>()->_CreateCopyWithAlphaFromSurfaceAsync(surface, alpha, &value)); return from_abi(value); }
	static SoftwareBitmap *activate(Imaging::BitmapPixelFormat format, int width, int height) { SoftwareBitmap *value; hrcheck(get_activation_factory<SoftwareBitmap, ISoftwareBitmapFactory>()->_Create(format, width, height, &value)); return value; }
	static SoftwareBitmap *activate(Imaging::BitmapPixelFormat format, int width, int height, Imaging::BitmapAlphaMode alpha) { SoftwareBitmap *value; hrcheck(get_activation_factory<SoftwareBitmap, ISoftwareBitmapFactory>()->_CreateWithAlpha(format, width, height, alpha, &value)); return value; }
};

template<typename X> struct statics<SoftwareBitmap, X> : X, Windows::Graphics::Imaging::SoftwareBitmap_statics<void> {
	using Windows::Graphics::Imaging::SoftwareBitmap_statics<void>::activate;
	typedef typename X::root_type SoftwareBitmap;
};
struct SoftwareBitmap : generate<SoftwareBitmap> {};
}}}
} // namespace iso_winrt
