#pragma once
// generated by isopod tools
// namespaces:
// Windows.Networking.Vpn

#include "Windows.Networking.Vpn.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.Networking.Sockets.0.h"
#include "Windows.Foundation.Collections.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Networking {
struct HostName;
}
namespace Security { namespace Credentials {
struct PasswordCredential;
}
namespace Cryptography { namespace Certificates {
struct Certificate;
}}}
namespace Storage { namespace Streams {
struct Buffer;
}}}

// defs

template<> struct def<Windows::Networking::Vpn::IVpnPlugIn> : overridable_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnDataPathType> : enum_type<int> {};
template<> struct def<Windows::Networking::Vpn::VpnChannelActivityEventType> : enum_type<int> {};
template<> struct def<Windows::Networking::Vpn::VpnCredentialType> : enum_type<int> {};
template<> struct def<Windows::Networking::Vpn::VpnPacketBufferStatus> : enum_type<int> {};
template<> struct def<Windows::Networking::Vpn::VpnChannelRequestCredentialsOptions> : enum_type<unsigned> {};
template<> struct def<Windows::Networking::Vpn::VpnDomainNameType> : enum_type<int> {};
template<> struct def<Windows::Networking::Vpn::IVpnCustomPrompt> : overridable_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnCustomEditBox> : interface_type<Windows::Networking::Vpn::IVpnCustomPrompt> {};
template<> struct def<Windows::Networking::Vpn::IVpnCustomComboBox> : interface_type<Windows::Networking::Vpn::IVpnCustomPrompt> {};
template<> struct def<Windows::Networking::Vpn::IVpnCustomTextBox> : interface_type<Windows::Networking::Vpn::IVpnCustomPrompt> {};
template<> struct def<Windows::Networking::Vpn::IVpnCustomCheckBox> : interface_type<Windows::Networking::Vpn::IVpnCustomPrompt> {};
template<> struct def<Windows::Networking::Vpn::IVpnCustomErrorBox> : interface_type<Windows::Networking::Vpn::IVpnCustomPrompt> {};
template<> struct def<Windows::Networking::Vpn::IVpnRouteFactory> : overridable_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnRoute> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnRoute> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnRoute>, custom_activators {};
template<> struct def<Windows::Networking::Vpn::IVpnRouteAssignment> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnNamespaceInfoFactory> : overridable_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnNamespaceInfo> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnNamespaceInfo> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnNamespaceInfo>, custom_activators {};
template<> struct def<Windows::Networking::Vpn::IVpnNamespaceAssignment> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnInterfaceIdFactory> : overridable_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnInterfaceId> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnInterfaceId> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnInterfaceId>, custom_activators {};
template<> struct def<Windows::Networking::Vpn::IVpnPickedCredential> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnCredential> : overridable_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnSystemHealth> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnChannelConfiguration> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnChannelConfiguration2> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnChannelActivityEventArgs> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnChannel> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnRouteAssignment> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnRouteAssignment> {};
template<> struct def<Windows::Networking::Vpn::VpnNamespaceAssignment> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnNamespaceAssignment> {};
template<> struct def<Windows::Networking::Vpn::VpnPickedCredential> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnPickedCredential> {};
template<> struct def<Windows::Networking::Vpn::IVpnPacketBufferFactory> : overridable_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnPacketBuffer3> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnPacketBuffer2> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnPacketBuffer> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnPacketBuffer> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnPacketBuffer, Windows::Networking::Vpn::IVpnPacketBuffer2, Windows::Networking::Vpn::IVpnPacketBuffer3>, custom_activators {};
template<> struct def<Windows::Networking::Vpn::VpnChannelConfiguration> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnChannelConfiguration, Windows::Networking::Vpn::IVpnChannelConfiguration2> {};
template<> struct def<Windows::Networking::Vpn::IVpnChannel4> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnChannel2> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnChannel> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnChannel, Windows::Networking::Vpn::IVpnChannel2, Windows::Networking::Vpn::IVpnChannel4> {};
template<> struct def<Windows::Networking::Vpn::VpnChannelActivityEventArgs> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnChannelActivityEventArgs> {};
template<> struct def<Windows::Networking::Vpn::VpnSystemHealth> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnSystemHealth> {};
template<> struct def<Windows::Networking::Vpn::IVpnDomainNameAssignment> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnDomainNameAssignment> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnDomainNameAssignment> {};
template<> struct def<Windows::Networking::Vpn::IVpnChannelActivityStateChangedArgs> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnChannelActivityStateChangedArgs> {};
template<> struct def<Windows::Networking::Vpn::IVpnCustomPromptElement> : overridable_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnCredential> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnCredential> {};
template<> struct def<Windows::Networking::Vpn::IVpnTrafficFilterAssignment> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnTrafficFilterAssignment> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnTrafficFilterAssignment> {};
template<> struct def<Windows::Networking::Vpn::IVpnChannelStatics> : overridable_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnAppIdType> : enum_type<int> {};
template<> struct def<Windows::Networking::Vpn::IVpnAppIdFactory> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnAppId> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnAppId> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnAppId>, custom_activators {};
template<> struct def<Windows::Networking::Vpn::IVpnPacketBufferList> : interface_type<Windows::Foundation::Collections::IIterable<ptr<Windows::Networking::Vpn::VpnPacketBuffer>>> {};
template<> struct def<Windows::Networking::Vpn::IVpnPacketBufferList2> : interface_type<Windows::Foundation::Collections::IIterable<ptr<Windows::Networking::Vpn::VpnPacketBuffer>>> {};
template<> struct def<Windows::Networking::Vpn::IVpnCustomPromptTextInput> : interface_type<Windows::Networking::Vpn::IVpnCustomPromptElement> {};
template<> struct def<Windows::Networking::Vpn::IVpnCustomPromptOptionSelector> : interface_type<Windows::Networking::Vpn::IVpnCustomPromptElement> {};
template<> struct def<Windows::Networking::Vpn::IVpnCustomPromptBooleanInput> : interface_type<Windows::Networking::Vpn::IVpnCustomPromptElement> {};
template<> struct def<Windows::Networking::Vpn::IVpnCustomPromptText> : interface_type<Windows::Networking::Vpn::IVpnCustomPromptElement> {};
template<> struct def<Windows::Networking::Vpn::IVpnDomainNameInfoFactory> : overridable_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnDomainNameInfo2> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnDomainNameInfo> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnDomainNameInfo> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnDomainNameInfo, Windows::Networking::Vpn::IVpnDomainNameInfo2>, custom_activators {};
template<> struct def<Windows::Networking::Vpn::IVpnTrafficFilterFactory> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnRoutingPolicyType> : enum_type<int> {};
template<> struct def<Windows::Networking::Vpn::VpnIPProtocol> : enum_type<int> {};
template<> struct def<Windows::Networking::Vpn::IVpnTrafficFilter> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnTrafficFilter> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnTrafficFilter>, custom_activators {};
template<> struct def<Windows::Networking::Vpn::IVpnProfile> : overridable_type<> {};
template<> struct def<Windows::Networking::Vpn::IVpnPlugInProfile> : interface_type<Windows::Networking::Vpn::IVpnProfile> {};
template<> struct def<Windows::Networking::Vpn::VpnManagementConnectionStatus> : enum_type<int> {};
template<> struct def<Windows::Networking::Vpn::IVpnPlugInProfile2> : interface_type<Windows::Networking::Vpn::IVpnProfile> {};
template<> struct def<Windows::Networking::Vpn::VpnNativeProtocolType> : enum_type<int> {};
template<> struct def<Windows::Networking::Vpn::VpnAuthenticationMethod> : enum_type<int> {};
template<> struct def<Windows::Networking::Vpn::IVpnNativeProfile> : interface_type<Windows::Networking::Vpn::IVpnProfile> {};
template<> struct def<Windows::Networking::Vpn::IVpnNativeProfile2> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnManagementErrorStatus> : enum_type<int> {};
template<> struct def<Windows::Networking::Vpn::IVpnManagementAgent> : interface_type<> {};
template<> struct def<Windows::Networking::Vpn::VpnPacketBufferList> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnPacketBufferList> {};
template<> struct def<Windows::Networking::Vpn::VpnCustomEditBox> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnCustomEditBox> {};
template<> struct def<Windows::Networking::Vpn::VpnCustomPromptTextInput> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnCustomPromptTextInput> {};
template<> struct def<Windows::Networking::Vpn::VpnCustomComboBox> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnCustomComboBox> {};
template<> struct def<Windows::Networking::Vpn::VpnCustomPromptOptionSelector> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnCustomPromptOptionSelector> {};
template<> struct def<Windows::Networking::Vpn::VpnCustomTextBox> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnCustomTextBox> {};
template<> struct def<Windows::Networking::Vpn::VpnCustomPromptText> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnCustomPromptText> {};
template<> struct def<Windows::Networking::Vpn::VpnCustomCheckBox> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnCustomCheckBox> {};
template<> struct def<Windows::Networking::Vpn::VpnCustomPromptBooleanInput> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnCustomPromptBooleanInput> {};
template<> struct def<Windows::Networking::Vpn::VpnCustomErrorBox> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnCustomErrorBox> {};
template<> struct def<Windows::Networking::Vpn::VpnPlugInProfile> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnPlugInProfile, Windows::Networking::Vpn::IVpnPlugInProfile2> {};
template<> struct def<Windows::Networking::Vpn::VpnNativeProfile> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnNativeProfile, Windows::Networking::Vpn::IVpnNativeProfile2> {};
template<> struct def<Windows::Networking::Vpn::VpnManagementAgent> : class_type<Platform::Object, Windows::Networking::Vpn::IVpnManagementAgent> {};

// uuids

template<> struct uuid<Windows::Networking::Vpn::IVpnPlugIn> { define_guid(0xCEB78D07, 0xD0A8, 0x4703, 0xA0, 0x91, 0xC8, 0xC2, 0xC0, 0x91, 0x5B, 0xC4);};
template<> struct uuid<Windows::Networking::Vpn::IVpnCustomPrompt> { define_guid(0x9B2EBE7B, 0x87D5, 0x433C, 0xB4, 0xF6, 0xEE, 0xE6, 0xAA, 0x68, 0xA2, 0x44);};
template<> struct uuid<Windows::Networking::Vpn::IVpnCustomEditBox> { define_guid(0x3002D9A0, 0xCFBF, 0x4C0B, 0x8F, 0x3C, 0x66, 0xF5, 0x3, 0xC2, 0xB, 0x39);};
template<> struct uuid<Windows::Networking::Vpn::IVpnCustomComboBox> { define_guid(0x9A24158E, 0xDBA1, 0x4C6F, 0x82, 0x70, 0xDC, 0xF3, 0xC9, 0x76, 0x1C, 0x4C);};
template<> struct uuid<Windows::Networking::Vpn::IVpnCustomTextBox> { define_guid(0xDAA4C3CA, 0x8F23, 0x4D36, 0x91, 0xF1, 0x76, 0xD9, 0x37, 0x82, 0x79, 0x42);};
template<> struct uuid<Windows::Networking::Vpn::IVpnCustomCheckBox> { define_guid(0x43878753, 0x3C5, 0x4E61, 0x93, 0xD7, 0xA9, 0x57, 0x71, 0x4C, 0x42, 0x82);};
template<> struct uuid<Windows::Networking::Vpn::IVpnCustomErrorBox> { define_guid(0x9EC4EFB2, 0xC942, 0x42AF, 0xB2, 0x23, 0x58, 0x8B, 0x48, 0x32, 0x87, 0x21);};
template<> struct uuid<Windows::Networking::Vpn::IVpnRouteFactory> { define_guid(0xBDEAB5FF, 0x45CF, 0x4B99, 0x83, 0xFB, 0xDB, 0x3B, 0xC2, 0x67, 0x2B, 0x2);};
template<> struct uuid<Windows::Networking::Vpn::IVpnRoute> { define_guid(0xB5731B83, 0x969, 0x4699, 0x93, 0x8E, 0x77, 0x76, 0xDB, 0x29, 0xCF, 0xB3);};
template<> struct uuid<Windows::Networking::Vpn::IVpnRouteAssignment> { define_guid(0xDB64DE22, 0xCE39, 0x4A76, 0x95, 0x50, 0xF6, 0x10, 0x39, 0xF8, 0xE, 0x48);};
template<> struct uuid<Windows::Networking::Vpn::IVpnNamespaceInfoFactory> { define_guid(0xCB3E951A, 0xB0CE, 0x442B, 0xAC, 0xBB, 0x5F, 0x99, 0xB2, 0x2, 0xC3, 0x1C);};
template<> struct uuid<Windows::Networking::Vpn::IVpnNamespaceInfo> { define_guid(0x30EDFB43, 0x444F, 0x44C5, 0x81, 0x67, 0xA3, 0x5A, 0x91, 0xF1, 0xAF, 0x94);};
template<> struct uuid<Windows::Networking::Vpn::IVpnNamespaceAssignment> { define_guid(0xD7F7DB18, 0x307D, 0x4C0E, 0xBD, 0x62, 0x8F, 0xA2, 0x70, 0xBB, 0xAD, 0xD6);};
template<> struct uuid<Windows::Networking::Vpn::IVpnInterfaceIdFactory> { define_guid(0x9E2DDCA2, 0x1712, 0x4CE4, 0xB1, 0x79, 0x8C, 0x65, 0x2C, 0x6D, 0x10, 0x0);};
template<> struct uuid<Windows::Networking::Vpn::IVpnInterfaceId> { define_guid(0x9E2DDCA2, 0x1712, 0x4CE4, 0xB1, 0x79, 0x8C, 0x65, 0x2C, 0x6D, 0x10, 0x11);};
template<> struct uuid<Windows::Networking::Vpn::IVpnPickedCredential> { define_guid(0x9A793AC7, 0x8854, 0x4E52, 0xAD, 0x97, 0x24, 0xDD, 0x9A, 0x84, 0x2B, 0xCE);};
template<> struct uuid<Windows::Networking::Vpn::IVpnCredential> { define_guid(0xB7E78AF3, 0xA46D, 0x404B, 0x87, 0x29, 0x18, 0x32, 0x52, 0x28, 0x53, 0xAC);};
template<> struct uuid<Windows::Networking::Vpn::IVpnSystemHealth> { define_guid(0x99A8F8AF, 0xC0EE, 0x4E75, 0x81, 0x7A, 0xF2, 0x31, 0xAE, 0xE5, 0x12, 0x3D);};
template<> struct uuid<Windows::Networking::Vpn::IVpnChannelConfiguration> { define_guid(0xE2DDCA2, 0x2012, 0x4FE4, 0xB1, 0x79, 0x8C, 0x65, 0x2C, 0x6D, 0x10, 0x7E);};
template<> struct uuid<Windows::Networking::Vpn::IVpnChannelConfiguration2> { define_guid(0xF30B574C, 0x7824, 0x471C, 0xA1, 0x18, 0x63, 0xDB, 0xC9, 0x3A, 0xE4, 0xC7);};
template<> struct uuid<Windows::Networking::Vpn::IVpnChannelActivityEventArgs> { define_guid(0xA36C88F2, 0xAFDC, 0x4775, 0x85, 0x5D, 0xD4, 0xAC, 0xA, 0x35, 0xFC, 0x55);};
template<> struct uuid<Windows::Networking::Vpn::IVpnChannel> { define_guid(0x4AC78D07, 0xD1A8, 0x4303, 0xA0, 0x91, 0xC8, 0xD2, 0xE0, 0x91, 0x5B, 0xC3);};
template<> struct uuid<Windows::Networking::Vpn::IVpnPacketBufferFactory> { define_guid(0x9E2DDCA2, 0x1712, 0x4CE4, 0xB1, 0x79, 0x8C, 0x65, 0x2C, 0x6D, 0x99, 0x99);};
template<> struct uuid<Windows::Networking::Vpn::IVpnPacketBuffer3> { define_guid(0xE256072F, 0x107B, 0x4C40, 0xB1, 0x27, 0x5B, 0xC5, 0x3E, 0xA, 0xD9, 0x60);};
template<> struct uuid<Windows::Networking::Vpn::IVpnPacketBuffer2> { define_guid(0x665E91F0, 0x8805, 0x4BF5, 0xA6, 0x19, 0x2E, 0x84, 0x88, 0x2E, 0x6B, 0x4F);};
template<> struct uuid<Windows::Networking::Vpn::IVpnPacketBuffer> { define_guid(0xC2F891FC, 0x4D5C, 0x4A63, 0xB7, 0xD, 0x4E, 0x30, 0x7E, 0xAC, 0xCE, 0x55);};
template<> struct uuid<Windows::Networking::Vpn::IVpnChannel4> { define_guid(0xD7266EDE, 0x2937, 0x419D, 0x95, 0x70, 0x48, 0x6A, 0xEB, 0xB8, 0x18, 0x3);};
template<> struct uuid<Windows::Networking::Vpn::IVpnChannel2> { define_guid(0x2255D165, 0x993B, 0x4629, 0xAD, 0x60, 0xF1, 0xC3, 0xF3, 0x53, 0x7F, 0x50);};
template<> struct uuid<Windows::Networking::Vpn::IVpnDomainNameAssignment> { define_guid(0x4135B141, 0xCCDB, 0x49B5, 0x94, 0x1, 0x3, 0x9A, 0x8A, 0xE7, 0x67, 0xE9);};
template<> struct uuid<Windows::Networking::Vpn::IVpnChannelActivityStateChangedArgs> { define_guid(0x3D750565, 0xFDC0, 0x4BBE, 0xA2, 0x3B, 0x45, 0xFF, 0xFC, 0x6D, 0x97, 0xA1);};
template<> struct uuid<Windows::Networking::Vpn::IVpnCustomPromptElement> { define_guid(0x73BD5638, 0x6F04, 0x404D, 0x93, 0xDD, 0x50, 0xA4, 0x49, 0x24, 0xA3, 0x8B);};
template<> struct uuid<Windows::Networking::Vpn::IVpnTrafficFilterAssignment> { define_guid(0x56CCD45C, 0xE664, 0x471E, 0x89, 0xCD, 0x60, 0x16, 0x3, 0xB9, 0xE0, 0xF3);};
template<> struct uuid<Windows::Networking::Vpn::IVpnChannelStatics> { define_guid(0x88EB062D, 0xE818, 0x4FFD, 0x98, 0xA6, 0x36, 0x3E, 0x37, 0x36, 0xC9, 0x5D);};
template<> struct uuid<Windows::Networking::Vpn::IVpnAppIdFactory> { define_guid(0x46ADFD2A, 0xAAB, 0x4FDB, 0x82, 0x1D, 0xD3, 0xDD, 0xC9, 0x19, 0x78, 0x8B);};
template<> struct uuid<Windows::Networking::Vpn::IVpnAppId> { define_guid(0x7B06A635, 0x5C58, 0x41D9, 0x94, 0xA7, 0xBF, 0xBC, 0xF1, 0xD8, 0xCA, 0x54);};
template<> struct uuid<Windows::Networking::Vpn::IVpnPacketBufferList> { define_guid(0xC2F891FC, 0x4D5C, 0x4A63, 0xB7, 0xD, 0x4E, 0x30, 0x7E, 0xAC, 0xCE, 0x77);};
template<> struct uuid<Windows::Networking::Vpn::IVpnPacketBufferList2> { define_guid(0x3E7ACFE5, 0xEA1E, 0x482A, 0x8D, 0x98, 0xC0, 0x65, 0xF5, 0x7D, 0x89, 0xEA);};
template<> struct uuid<Windows::Networking::Vpn::IVpnCustomPromptTextInput> { define_guid(0xC9DA9C75, 0x913C, 0x47D5, 0x88, 0xBA, 0x48, 0xFC, 0x48, 0x93, 0x2, 0x35);};
template<> struct uuid<Windows::Networking::Vpn::IVpnCustomPromptOptionSelector> { define_guid(0x3B8F34D9, 0x8EC1, 0x4E95, 0x9A, 0x4E, 0x7B, 0xA6, 0x4D, 0x38, 0xF3, 0x30);};
template<> struct uuid<Windows::Networking::Vpn::IVpnCustomPromptBooleanInput> { define_guid(0xC4C9A69E, 0xFF47, 0x4527, 0x9F, 0x27, 0xA4, 0x92, 0x92, 0x1, 0x99, 0x79);};
template<> struct uuid<Windows::Networking::Vpn::IVpnCustomPromptText> { define_guid(0x3BC8BDEE, 0x3A42, 0x49A3, 0xAB, 0xDD, 0x7, 0xB2, 0xED, 0xEA, 0x75, 0x2D);};
template<> struct uuid<Windows::Networking::Vpn::IVpnDomainNameInfoFactory> { define_guid(0x2507BB75, 0x28F, 0x4688, 0x8D, 0x3A, 0xC4, 0x53, 0x1D, 0xF3, 0x7D, 0xA8);};
template<> struct uuid<Windows::Networking::Vpn::IVpnDomainNameInfo2> { define_guid(0xAB871151, 0x6C53, 0x4828, 0x98, 0x83, 0xD8, 0x86, 0xDE, 0x10, 0x44, 0x7);};
template<> struct uuid<Windows::Networking::Vpn::IVpnDomainNameInfo> { define_guid(0xAD2EB82F, 0xEA8E, 0x4F7A, 0x84, 0x3E, 0x1A, 0x87, 0xE3, 0x2E, 0x1B, 0x9A);};
template<> struct uuid<Windows::Networking::Vpn::IVpnTrafficFilterFactory> { define_guid(0x480D41D5, 0x7F99, 0x474C, 0x86, 0xEE, 0x96, 0xDF, 0x16, 0x83, 0x18, 0xF1);};
template<> struct uuid<Windows::Networking::Vpn::IVpnTrafficFilter> { define_guid(0x2F691B60, 0x6C9F, 0x47F5, 0xAC, 0x36, 0xBB, 0x1B, 0x4, 0x2E, 0x2C, 0x50);};
template<> struct uuid<Windows::Networking::Vpn::IVpnProfile> { define_guid(0x7875B751, 0xB0D7, 0x43DB, 0x8A, 0x93, 0xD3, 0xFE, 0x24, 0x79, 0xE5, 0x6A);};
template<> struct uuid<Windows::Networking::Vpn::IVpnPlugInProfile> { define_guid(0xEDF0DA4, 0x4F00, 0x4589, 0x8D, 0x7B, 0x4B, 0xF9, 0x88, 0xF6, 0x54, 0x2C);};
template<> struct uuid<Windows::Networking::Vpn::IVpnPlugInProfile2> { define_guid(0x611C4892, 0xCF94, 0x4AD6, 0xBA, 0x99, 0x0, 0xF4, 0xFF, 0x34, 0x56, 0x5E);};
template<> struct uuid<Windows::Networking::Vpn::IVpnNativeProfile> { define_guid(0xA4AEE29E, 0x6417, 0x4333, 0x98, 0x42, 0xF0, 0xA6, 0x6D, 0xB6, 0x98, 0x2);};
template<> struct uuid<Windows::Networking::Vpn::IVpnNativeProfile2> { define_guid(0xFEC2467, 0xCDB5, 0x4AC7, 0xB5, 0xA3, 0xA, 0xFB, 0x5E, 0xC4, 0x76, 0x82);};
template<> struct uuid<Windows::Networking::Vpn::IVpnManagementAgent> { define_guid(0x193696CD, 0xA5C4, 0x4ABE, 0x85, 0x2B, 0x78, 0x5B, 0xE4, 0xCB, 0x3E, 0x34);};

// types

namespace Windows { namespace Networking { namespace Vpn {

// IVpnPlugIn
struct IVpnPlugIn_raw : IInspectable {
	virtual STDMETHODIMP _Connect(VpnChannel* channel) = 0;
	virtual STDMETHODIMP _Disconnect(VpnChannel* channel) = 0;
	virtual STDMETHODIMP _GetKeepAlivePayload(VpnChannel* channel, VpnPacketBuffer* *keepAlivePacket) = 0;
	virtual STDMETHODIMP _Encapsulate(VpnChannel* channel, VpnPacketBufferList* packets, VpnPacketBufferList* encapulatedPackets) = 0;
	virtual STDMETHODIMP _Decapsulate(VpnChannel* channel, VpnPacketBuffer* encapBuffer, VpnPacketBufferList* decapsulatedPackets, VpnPacketBufferList* controlPacketsToSend) = 0;
};
template<typename X> struct IVpnPlugIn_adaptor : X {
	void Connect(pptr<VpnChannel> channel) { hrcheck(X::get()->_Connect(channel)); }
	void Disconnect(pptr<VpnChannel> channel) { hrcheck(X::get()->_Disconnect(channel)); }
	ptr<VpnPacketBuffer> GetKeepAlivePayload(pptr<VpnChannel> channel) { VpnPacketBuffer* keepAlivePacket; hrcheck(X::get()->_GetKeepAlivePayload(channel, &keepAlivePacket)); return from_abi(keepAlivePacket); }
	void Encapsulate(pptr<VpnChannel> channel, pptr<VpnPacketBufferList> packets, pptr<VpnPacketBufferList> encapulatedPackets) { hrcheck(X::get()->_Encapsulate(channel, packets, encapulatedPackets)); }
	void Decapsulate(pptr<VpnChannel> channel, pptr<VpnPacketBuffer> encapBuffer, pptr<VpnPacketBufferList> decapsulatedPackets, pptr<VpnPacketBufferList> controlPacketsToSend) { hrcheck(X::get()->_Decapsulate(channel, encapBuffer, decapsulatedPackets, controlPacketsToSend)); }
};
template<typename X> struct adapt<IVpnPlugIn, X> : Windows::Networking::Vpn::IVpnPlugIn_adaptor<X> { typedef adapt IVpnPlugIn; };
template<typename X> struct IVpnPlugIn_unadaptor : X {
	STDMETHODIMP _Connect(VpnChannel* channel) { return hrtry([&, this] { X::get()->Connect(channel); }); }
	STDMETHODIMP _Disconnect(VpnChannel* channel) { return hrtry([&, this] { X::get()->Disconnect(channel); }); }
	STDMETHODIMP _GetKeepAlivePayload(VpnChannel* channel, VpnPacketBuffer* *keepAlivePacket) { return hrtry([&, this] { *keepAlivePacket = to_abi(X::get()->GetKeepAlivePayload(channel, )); }); }
	STDMETHODIMP _Encapsulate(VpnChannel* channel, VpnPacketBufferList* packets, VpnPacketBufferList* encapulatedPackets) { return hrtry([&, this] { X::get()->Encapsulate(channel, packets, encapulatedPackets); }); }
	STDMETHODIMP _Decapsulate(VpnChannel* channel, VpnPacketBuffer* encapBuffer, VpnPacketBufferList* decapsulatedPackets, VpnPacketBufferList* controlPacketsToSend) { return hrtry([&, this] { X::get()->Decapsulate(channel, encapBuffer, decapsulatedPackets, controlPacketsToSend); }); }
};
template<typename X> struct unadapt<IVpnPlugIn, X> : Windows::Networking::Vpn::IVpnPlugIn_unadaptor<X> {};
struct IVpnPlugIn : IVpnPlugIn_raw, generate<IVpnPlugIn> {};

// IVpnCustomPrompt
struct IVpnCustomPrompt_raw : IInspectable {
	virtual STDMETHODIMP _put_Label(HSTRING value) = 0;
	virtual STDMETHODIMP _get_Label(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_Compulsory(bool value) = 0;
	virtual STDMETHODIMP _get_Compulsory(bool *value) = 0;
	virtual STDMETHODIMP _put_Bordered(bool value) = 0;
	virtual STDMETHODIMP _get_Bordered(bool *value) = 0;
};
template<typename X> struct IVpnCustomPrompt_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnCustomPrompt_adaptor::Bordered)->_get_Bordered(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVpnCustomPrompt_adaptor::Bordered)->_put_Bordered(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Bordered;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnCustomPrompt_adaptor::Compulsory)->_get_Compulsory(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVpnCustomPrompt_adaptor::Compulsory)->_put_Compulsory(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Compulsory;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnCustomPrompt_adaptor::Label)->_get_Label(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVpnCustomPrompt_adaptor::Label)->_put_Label(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Label;
	};
	IVpnCustomPrompt_adaptor() {}
};
template<typename X> struct adapt<IVpnCustomPrompt, X> : Windows::Networking::Vpn::IVpnCustomPrompt_adaptor<X> { typedef adapt IVpnCustomPrompt; };
template<typename X> struct IVpnCustomPrompt_unadaptor : X {
	STDMETHODIMP _put_Label(HSTRING value) { return hrtry([&, this] { put_prop(value, Label); }); }
	STDMETHODIMP _get_Label(HSTRING *value) { return hrtry([&, this] { get_prop(value, Label); }); }
	STDMETHODIMP _put_Compulsory(bool value) { return hrtry([&, this] { put_prop(value, Compulsory); }); }
	STDMETHODIMP _get_Compulsory(bool *value) { return hrtry([&, this] { get_prop(value, Compulsory); }); }
	STDMETHODIMP _put_Bordered(bool value) { return hrtry([&, this] { put_prop(value, Bordered); }); }
	STDMETHODIMP _get_Bordered(bool *value) { return hrtry([&, this] { get_prop(value, Bordered); }); }
};
template<typename X> struct unadapt<IVpnCustomPrompt, X> : Windows::Networking::Vpn::IVpnCustomPrompt_unadaptor<X> {};
struct IVpnCustomPrompt : IVpnCustomPrompt_raw, generate<IVpnCustomPrompt> {};

// IVpnCustomEditBox
struct IVpnCustomEditBox_raw : IInspectable {
	virtual STDMETHODIMP _put_DefaultText(HSTRING value);
	virtual STDMETHODIMP _get_DefaultText(HSTRING *value);
	virtual STDMETHODIMP _put_NoEcho(bool value);
	virtual STDMETHODIMP _get_NoEcho(bool *value);
	virtual STDMETHODIMP _get_Text(HSTRING *value);
};
template<typename X> struct IVpnCustomEditBox_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnCustomEditBox_adaptor::DefaultText)->_get_DefaultText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVpnCustomEditBox_adaptor::DefaultText)->_put_DefaultText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DefaultText;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnCustomEditBox_adaptor::NoEcho)->_get_NoEcho(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVpnCustomEditBox_adaptor::NoEcho)->_put_NoEcho(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} NoEcho;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnCustomEditBox_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Text;
	};
	IVpnCustomEditBox_adaptor() {}
};
template<typename X> struct adapt<IVpnCustomEditBox, X> : Windows::Networking::Vpn::IVpnCustomEditBox_adaptor<X> { typedef adapt IVpnCustomEditBox; };
struct IVpnCustomEditBox : IVpnCustomEditBox_raw, generate<IVpnCustomEditBox> {};

// IVpnCustomComboBox
struct IVpnCustomComboBox_raw : IInspectable {
	virtual STDMETHODIMP _put_OptionsText(Foundation::Collections::IVectorView<HSTRING>* value);
	virtual STDMETHODIMP _get_OptionsText(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _get_Selected(unsigned *value);
};
template<typename X> struct IVpnCustomComboBox_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&IVpnCustomComboBox_adaptor::OptionsText)->_get_OptionsText(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
			void put(pptr<Foundation::Collections::IVectorView<hstring>> value) { hrcheck(enc(&IVpnCustomComboBox_adaptor::OptionsText)->_put_OptionsText(to_abi(value))); }
			void operator=(pptr<Foundation::Collections::IVectorView<hstring>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::Collections::IVectorView<hstring>> value) { put(to_abi(value)); }
		} OptionsText;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IVpnCustomComboBox_adaptor::Selected)->_get_Selected(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Selected;
	};
	IVpnCustomComboBox_adaptor() {}
};
template<typename X> struct adapt<IVpnCustomComboBox, X> : Windows::Networking::Vpn::IVpnCustomComboBox_adaptor<X> { typedef adapt IVpnCustomComboBox; };
struct IVpnCustomComboBox : IVpnCustomComboBox_raw, generate<IVpnCustomComboBox> {};

// IVpnCustomTextBox
struct IVpnCustomTextBox_raw : IInspectable {
	virtual STDMETHODIMP _put_DisplayText(HSTRING value);
	virtual STDMETHODIMP _get_DisplayText(HSTRING *value);
};
template<typename X> struct IVpnCustomTextBox_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnCustomTextBox_adaptor::DisplayText)->_get_DisplayText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVpnCustomTextBox_adaptor::DisplayText)->_put_DisplayText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DisplayText;
	};
	IVpnCustomTextBox_adaptor() {}
};
template<typename X> struct adapt<IVpnCustomTextBox, X> : Windows::Networking::Vpn::IVpnCustomTextBox_adaptor<X> { typedef adapt IVpnCustomTextBox; };
struct IVpnCustomTextBox : IVpnCustomTextBox_raw, generate<IVpnCustomTextBox> {};

// IVpnCustomCheckBox
struct IVpnCustomCheckBox_raw : IInspectable {
	virtual STDMETHODIMP _put_InitialCheckState(bool value);
	virtual STDMETHODIMP _get_InitialCheckState(bool *value);
	virtual STDMETHODIMP _get_Checked(bool *value);
};
template<typename X> struct IVpnCustomCheckBox_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnCustomCheckBox_adaptor::Checked)->_get_Checked(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Checked;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnCustomCheckBox_adaptor::InitialCheckState)->_get_InitialCheckState(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVpnCustomCheckBox_adaptor::InitialCheckState)->_put_InitialCheckState(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} InitialCheckState;
	};
	IVpnCustomCheckBox_adaptor() {}
};
template<typename X> struct adapt<IVpnCustomCheckBox, X> : Windows::Networking::Vpn::IVpnCustomCheckBox_adaptor<X> { typedef adapt IVpnCustomCheckBox; };
struct IVpnCustomCheckBox : IVpnCustomCheckBox_raw, generate<IVpnCustomCheckBox> {};

// IVpnCustomErrorBox
struct IVpnCustomErrorBox : IInspectable, generate<IVpnCustomErrorBox> {};

// IVpnRouteFactory
struct IVpnRouteFactory_raw : IInspectable {
	virtual STDMETHODIMP _CreateVpnRoute(HostName* address, unsigned char prefixSize, VpnRoute* *route) = 0;
};
template<typename X> struct IVpnRouteFactory_adaptor : X {
	ptr<VpnRoute> CreateVpnRoute(pptr<HostName> address, unsigned char prefixSize) { VpnRoute* route; hrcheck(X::get()->_CreateVpnRoute(address, prefixSize, &route)); return from_abi(route); }
};
template<typename X> struct adapt<IVpnRouteFactory, X> : Windows::Networking::Vpn::IVpnRouteFactory_adaptor<X> { typedef adapt IVpnRouteFactory; };
template<typename X> struct IVpnRouteFactory_unadaptor : X {
	STDMETHODIMP _CreateVpnRoute(HostName* address, unsigned char prefixSize, VpnRoute* *route) { return hrtry([&, this] { *route = to_abi(X::get()->CreateVpnRoute(address, prefixSize)); }); }
};
template<typename X> struct unadapt<IVpnRouteFactory, X> : Windows::Networking::Vpn::IVpnRouteFactory_unadaptor<X> {};
struct IVpnRouteFactory : IVpnRouteFactory_raw, generate<IVpnRouteFactory> {};

// IVpnRoute
struct IVpnRoute_raw : IInspectable {
	virtual STDMETHODIMP _put_Address(HostName* value);
	virtual STDMETHODIMP _get_Address(HostName* *value);
	virtual STDMETHODIMP _put_PrefixSize(unsigned char value);
	virtual STDMETHODIMP _get_PrefixSize(unsigned char *value);
};
template<typename X> struct IVpnRoute_adaptor : X {
	union {
		struct : property {
			ptr<HostName> get() { HostName* value; hrcheck(enc(&IVpnRoute_adaptor::Address)->_get_Address(&value)); return from_abi(value); }
			ptr<HostName> operator()() { return get(); }
			operator ptr<HostName> () { return get(); }
			ptr<HostName> operator->() { return get(); }
			void put(pptr<HostName> value) { hrcheck(enc(&IVpnRoute_adaptor::Address)->_put_Address(value)); }
			void operator=(pptr<HostName> value) { put(value); }
			void operator()(pptr<HostName> value) { put(value); }
		} Address;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IVpnRoute_adaptor::PrefixSize)->_get_PrefixSize(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IVpnRoute_adaptor::PrefixSize)->_put_PrefixSize(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} PrefixSize;
	};
	IVpnRoute_adaptor() {}
};
template<typename X> struct adapt<IVpnRoute, X> : Windows::Networking::Vpn::IVpnRoute_adaptor<X> { typedef adapt IVpnRoute; };
struct IVpnRoute : IVpnRoute_raw, generate<IVpnRoute> {};

// VpnRoute
template<typename> struct VpnRoute_statics {
	static VpnRoute *activate(pptr<HostName> address, unsigned char prefixSize) { VpnRoute *route; hrcheck(get_activation_factory<VpnRoute, IVpnRouteFactory>()->_CreateVpnRoute(address, prefixSize, &route)); return route; }
};

template<typename X> struct statics<VpnRoute, X> : X, Windows::Networking::Vpn::VpnRoute_statics<void> {
	using Windows::Networking::Vpn::VpnRoute_statics<void>::activate;
	typedef typename X::root_type VpnRoute;
};
struct VpnRoute : generate<VpnRoute> {};

// IVpnRouteAssignment
struct IVpnRouteAssignment_raw : IInspectable {
	virtual STDMETHODIMP _put_Ipv4InclusionRoutes(Foundation::Collections::IVector<VpnRoute*>* value);
	virtual STDMETHODIMP _put_Ipv6InclusionRoutes(Foundation::Collections::IVector<VpnRoute*>* value);
	virtual STDMETHODIMP _get_Ipv4InclusionRoutes(Foundation::Collections::IVector<VpnRoute*>* *value);
	virtual STDMETHODIMP _get_Ipv6InclusionRoutes(Foundation::Collections::IVector<VpnRoute*>* *value);
	virtual STDMETHODIMP _put_Ipv4ExclusionRoutes(Foundation::Collections::IVector<VpnRoute*>* value);
	virtual STDMETHODIMP _put_Ipv6ExclusionRoutes(Foundation::Collections::IVector<VpnRoute*>* value);
	virtual STDMETHODIMP _get_Ipv4ExclusionRoutes(Foundation::Collections::IVector<VpnRoute*>* *value);
	virtual STDMETHODIMP _get_Ipv6ExclusionRoutes(Foundation::Collections::IVector<VpnRoute*>* *value);
	virtual STDMETHODIMP _put_ExcludeLocalSubnets(bool value);
	virtual STDMETHODIMP _get_ExcludeLocalSubnets(bool *value);
};
template<typename X> struct IVpnRouteAssignment_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnRouteAssignment_adaptor::ExcludeLocalSubnets)->_get_ExcludeLocalSubnets(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVpnRouteAssignment_adaptor::ExcludeLocalSubnets)->_put_ExcludeLocalSubnets(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ExcludeLocalSubnets;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> get() { Foundation::Collections::IVector<VpnRoute*>* value; hrcheck(enc(&IVpnRouteAssignment_adaptor::Ipv4ExclusionRoutes)->_get_Ipv4ExclusionRoutes(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> operator->() { return get(); }
			void put(pptr<Foundation::Collections::IVector<ptr<VpnRoute>>> value) { hrcheck(enc(&IVpnRouteAssignment_adaptor::Ipv4ExclusionRoutes)->_put_Ipv4ExclusionRoutes(to_abi(value))); }
			void operator=(pptr<Foundation::Collections::IVector<ptr<VpnRoute>>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::Collections::IVector<ptr<VpnRoute>>> value) { put(to_abi(value)); }
		} Ipv4ExclusionRoutes;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> get() { Foundation::Collections::IVector<VpnRoute*>* value; hrcheck(enc(&IVpnRouteAssignment_adaptor::Ipv4InclusionRoutes)->_get_Ipv4InclusionRoutes(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> operator->() { return get(); }
			void put(pptr<Foundation::Collections::IVector<ptr<VpnRoute>>> value) { hrcheck(enc(&IVpnRouteAssignment_adaptor::Ipv4InclusionRoutes)->_put_Ipv4InclusionRoutes(to_abi(value))); }
			void operator=(pptr<Foundation::Collections::IVector<ptr<VpnRoute>>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::Collections::IVector<ptr<VpnRoute>>> value) { put(to_abi(value)); }
		} Ipv4InclusionRoutes;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> get() { Foundation::Collections::IVector<VpnRoute*>* value; hrcheck(enc(&IVpnRouteAssignment_adaptor::Ipv6ExclusionRoutes)->_get_Ipv6ExclusionRoutes(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> operator->() { return get(); }
			void put(pptr<Foundation::Collections::IVector<ptr<VpnRoute>>> value) { hrcheck(enc(&IVpnRouteAssignment_adaptor::Ipv6ExclusionRoutes)->_put_Ipv6ExclusionRoutes(to_abi(value))); }
			void operator=(pptr<Foundation::Collections::IVector<ptr<VpnRoute>>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::Collections::IVector<ptr<VpnRoute>>> value) { put(to_abi(value)); }
		} Ipv6ExclusionRoutes;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> get() { Foundation::Collections::IVector<VpnRoute*>* value; hrcheck(enc(&IVpnRouteAssignment_adaptor::Ipv6InclusionRoutes)->_get_Ipv6InclusionRoutes(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> operator->() { return get(); }
			void put(pptr<Foundation::Collections::IVector<ptr<VpnRoute>>> value) { hrcheck(enc(&IVpnRouteAssignment_adaptor::Ipv6InclusionRoutes)->_put_Ipv6InclusionRoutes(to_abi(value))); }
			void operator=(pptr<Foundation::Collections::IVector<ptr<VpnRoute>>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::Collections::IVector<ptr<VpnRoute>>> value) { put(to_abi(value)); }
		} Ipv6InclusionRoutes;
	};
	IVpnRouteAssignment_adaptor() {}
};
template<typename X> struct adapt<IVpnRouteAssignment, X> : Windows::Networking::Vpn::IVpnRouteAssignment_adaptor<X> { typedef adapt IVpnRouteAssignment; };
struct IVpnRouteAssignment : IVpnRouteAssignment_raw, generate<IVpnRouteAssignment> {};

// IVpnNamespaceInfoFactory
struct IVpnNamespaceInfoFactory_raw : IInspectable {
	virtual STDMETHODIMP _CreateVpnNamespaceInfo(HSTRING name, Foundation::Collections::IVector<HostName*>* dnsServerList, Foundation::Collections::IVector<HostName*>* proxyServerList, VpnNamespaceInfo* *namespaceInfo) = 0;
};
template<typename X> struct IVpnNamespaceInfoFactory_adaptor : X {
	ptr<VpnNamespaceInfo> CreateVpnNamespaceInfo(hstring_ref name, pptr<Foundation::Collections::IVector<ptr<HostName>>> dnsServerList, pptr<Foundation::Collections::IVector<ptr<HostName>>> proxyServerList) { VpnNamespaceInfo* namespaceInfo; hrcheck(X::get()->_CreateVpnNamespaceInfo(name, to_abi(dnsServerList), to_abi(proxyServerList), &namespaceInfo)); return from_abi(namespaceInfo); }
};
template<typename X> struct adapt<IVpnNamespaceInfoFactory, X> : Windows::Networking::Vpn::IVpnNamespaceInfoFactory_adaptor<X> { typedef adapt IVpnNamespaceInfoFactory; };
template<typename X> struct IVpnNamespaceInfoFactory_unadaptor : X {
	STDMETHODIMP _CreateVpnNamespaceInfo(HSTRING name, Foundation::Collections::IVector<HostName*>* dnsServerList, Foundation::Collections::IVector<HostName*>* proxyServerList, VpnNamespaceInfo* *namespaceInfo) { return hrtry([&, this] { *namespaceInfo = to_abi(X::get()->CreateVpnNamespaceInfo(name, dnsServerList, proxyServerList)); }); }
};
template<typename X> struct unadapt<IVpnNamespaceInfoFactory, X> : Windows::Networking::Vpn::IVpnNamespaceInfoFactory_unadaptor<X> {};
struct IVpnNamespaceInfoFactory : IVpnNamespaceInfoFactory_raw, generate<IVpnNamespaceInfoFactory> {};

// IVpnNamespaceInfo
struct IVpnNamespaceInfo_raw : IInspectable {
	virtual STDMETHODIMP _put_Namespace(HSTRING value);
	virtual STDMETHODIMP _get_Namespace(HSTRING *value);
	virtual STDMETHODIMP _put_DnsServers(Foundation::Collections::IVector<HostName*>* value);
	virtual STDMETHODIMP _get_DnsServers(Foundation::Collections::IVector<HostName*>* *value);
	virtual STDMETHODIMP _put_WebProxyServers(Foundation::Collections::IVector<HostName*>* value);
	virtual STDMETHODIMP _get_WebProxyServers(Foundation::Collections::IVector<HostName*>* *value);
};
template<typename X> struct IVpnNamespaceInfo_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<HostName>>> get() { Foundation::Collections::IVector<HostName*>* value; hrcheck(enc(&IVpnNamespaceInfo_adaptor::DnsServers)->_get_DnsServers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<HostName>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<HostName>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<HostName>>> operator->() { return get(); }
			void put(pptr<Foundation::Collections::IVector<ptr<HostName>>> value) { hrcheck(enc(&IVpnNamespaceInfo_adaptor::DnsServers)->_put_DnsServers(to_abi(value))); }
			void operator=(pptr<Foundation::Collections::IVector<ptr<HostName>>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::Collections::IVector<ptr<HostName>>> value) { put(to_abi(value)); }
		} DnsServers;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnNamespaceInfo_adaptor::Namespace)->_get_Namespace(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVpnNamespaceInfo_adaptor::Namespace)->_put_Namespace(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Namespace;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<HostName>>> get() { Foundation::Collections::IVector<HostName*>* value; hrcheck(enc(&IVpnNamespaceInfo_adaptor::WebProxyServers)->_get_WebProxyServers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<HostName>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<HostName>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<HostName>>> operator->() { return get(); }
			void put(pptr<Foundation::Collections::IVector<ptr<HostName>>> value) { hrcheck(enc(&IVpnNamespaceInfo_adaptor::WebProxyServers)->_put_WebProxyServers(to_abi(value))); }
			void operator=(pptr<Foundation::Collections::IVector<ptr<HostName>>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::Collections::IVector<ptr<HostName>>> value) { put(to_abi(value)); }
		} WebProxyServers;
	};
	IVpnNamespaceInfo_adaptor() {}
};
template<typename X> struct adapt<IVpnNamespaceInfo, X> : Windows::Networking::Vpn::IVpnNamespaceInfo_adaptor<X> { typedef adapt IVpnNamespaceInfo; };
struct IVpnNamespaceInfo : IVpnNamespaceInfo_raw, generate<IVpnNamespaceInfo> {};

// VpnNamespaceInfo
template<typename> struct VpnNamespaceInfo_statics {
	static VpnNamespaceInfo *activate(hstring_ref name, pptr<Foundation::Collections::IVector<ptr<HostName>>> dnsServerList, pptr<Foundation::Collections::IVector<ptr<HostName>>> proxyServerList) { VpnNamespaceInfo *namespaceInfo; hrcheck(get_activation_factory<VpnNamespaceInfo, IVpnNamespaceInfoFactory>()->_CreateVpnNamespaceInfo(name, to_abi(dnsServerList), to_abi(proxyServerList), &namespaceInfo)); return namespaceInfo; }
};

template<typename X> struct statics<VpnNamespaceInfo, X> : X, Windows::Networking::Vpn::VpnNamespaceInfo_statics<void> {
	using Windows::Networking::Vpn::VpnNamespaceInfo_statics<void>::activate;
	typedef typename X::root_type VpnNamespaceInfo;
};
struct VpnNamespaceInfo : generate<VpnNamespaceInfo> {};

// IVpnNamespaceAssignment
struct IVpnNamespaceAssignment_raw : IInspectable {
	virtual STDMETHODIMP _put_NamespaceList(Foundation::Collections::IVector<VpnNamespaceInfo*>* value);
	virtual STDMETHODIMP _get_NamespaceList(Foundation::Collections::IVector<VpnNamespaceInfo*>* *value);
	virtual STDMETHODIMP _put_ProxyAutoConfigUri(Foundation::Uri* value);
	virtual STDMETHODIMP _get_ProxyAutoConfigUri(Foundation::Uri* *value);
};
template<typename X> struct IVpnNamespaceAssignment_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<VpnNamespaceInfo>>> get() { Foundation::Collections::IVector<VpnNamespaceInfo*>* value; hrcheck(enc(&IVpnNamespaceAssignment_adaptor::NamespaceList)->_get_NamespaceList(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<VpnNamespaceInfo>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<VpnNamespaceInfo>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<VpnNamespaceInfo>>> operator->() { return get(); }
			void put(pptr<Foundation::Collections::IVector<ptr<VpnNamespaceInfo>>> value) { hrcheck(enc(&IVpnNamespaceAssignment_adaptor::NamespaceList)->_put_NamespaceList(to_abi(value))); }
			void operator=(pptr<Foundation::Collections::IVector<ptr<VpnNamespaceInfo>>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::Collections::IVector<ptr<VpnNamespaceInfo>>> value) { put(to_abi(value)); }
		} NamespaceList;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IVpnNamespaceAssignment_adaptor::ProxyAutoConfigUri)->_get_ProxyAutoConfigUri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IVpnNamespaceAssignment_adaptor::ProxyAutoConfigUri)->_put_ProxyAutoConfigUri(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} ProxyAutoConfigUri;
	};
	IVpnNamespaceAssignment_adaptor() {}
};
template<typename X> struct adapt<IVpnNamespaceAssignment, X> : Windows::Networking::Vpn::IVpnNamespaceAssignment_adaptor<X> { typedef adapt IVpnNamespaceAssignment; };
struct IVpnNamespaceAssignment : IVpnNamespaceAssignment_raw, generate<IVpnNamespaceAssignment> {};

// IVpnInterfaceIdFactory
struct IVpnInterfaceIdFactory_raw : IInspectable {
	virtual STDMETHODIMP _CreateVpnInterfaceId(unsigned addressSize, unsigned char *address, VpnInterfaceId* *vpnInterfaceId) = 0;
};
template<typename X> struct IVpnInterfaceIdFactory_adaptor : X {
	ptr<VpnInterfaceId> CreateVpnInterfaceId(const szarray<unsigned char>& address) { VpnInterfaceId* vpnInterfaceId; hrcheck(X::get()->_CreateVpnInterfaceId(address.size, to_abi(address.p), &vpnInterfaceId)); return from_abi(vpnInterfaceId); }
};
template<typename X> struct adapt<IVpnInterfaceIdFactory, X> : Windows::Networking::Vpn::IVpnInterfaceIdFactory_adaptor<X> { typedef adapt IVpnInterfaceIdFactory; };
template<typename X> struct IVpnInterfaceIdFactory_unadaptor : X {
	STDMETHODIMP _CreateVpnInterfaceId(unsigned addressSize, unsigned char *address, VpnInterfaceId* *vpnInterfaceId) { return hrtry([&, this] { *vpnInterfaceId = to_abi(X::get()->CreateVpnInterfaceId({(unsigned char*)address, addressSize})); }); }
};
template<typename X> struct unadapt<IVpnInterfaceIdFactory, X> : Windows::Networking::Vpn::IVpnInterfaceIdFactory_unadaptor<X> {};
struct IVpnInterfaceIdFactory : IVpnInterfaceIdFactory_raw, generate<IVpnInterfaceIdFactory> {};

// IVpnInterfaceId
struct IVpnInterfaceId_raw : IInspectable {
	virtual STDMETHODIMP _GetAddressInfo(unsigned *idSize, unsigned char **id);
};
template<typename X> struct IVpnInterfaceId_adaptor : X {
	szarray<unsigned char> GetAddressInfo() { szarray<unsigned char> id; hrcheck(X::get()->_GetAddressInfo(&id.size, &id.p)); return id; }
};
template<typename X> struct adapt<IVpnInterfaceId, X> : Windows::Networking::Vpn::IVpnInterfaceId_adaptor<X> { typedef adapt IVpnInterfaceId; };
struct IVpnInterfaceId : IVpnInterfaceId_raw, generate<IVpnInterfaceId> {};

// VpnInterfaceId
template<typename> struct VpnInterfaceId_statics {
	static VpnInterfaceId *activate(const szarray<unsigned char>& address) { VpnInterfaceId *vpnInterfaceId; hrcheck(get_activation_factory<VpnInterfaceId, IVpnInterfaceIdFactory>()->_CreateVpnInterfaceId(address.size, to_abi(address.p), &vpnInterfaceId)); return vpnInterfaceId; }
};

template<typename X> struct statics<VpnInterfaceId, X> : X, Windows::Networking::Vpn::VpnInterfaceId_statics<void> {
	using Windows::Networking::Vpn::VpnInterfaceId_statics<void>::activate;
	typedef typename X::root_type VpnInterfaceId;
};
struct VpnInterfaceId : generate<VpnInterfaceId> {};

// IVpnPickedCredential
struct IVpnPickedCredential_raw : IInspectable {
	virtual STDMETHODIMP _get_PasskeyCredential(Security::Credentials::PasswordCredential* *value);
	virtual STDMETHODIMP _get_AdditionalPin(HSTRING *value);
	virtual STDMETHODIMP _get_OldPasswordCredential(Security::Credentials::PasswordCredential* *value);
};
template<typename X> struct IVpnPickedCredential_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnPickedCredential_adaptor::AdditionalPin)->_get_AdditionalPin(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} AdditionalPin;
		struct : property {
			ptr<Security::Credentials::PasswordCredential> get() { Security::Credentials::PasswordCredential* value; hrcheck(enc(&IVpnPickedCredential_adaptor::OldPasswordCredential)->_get_OldPasswordCredential(&value)); return from_abi(value); }
			ptr<Security::Credentials::PasswordCredential> operator()() { return get(); }
			operator ptr<Security::Credentials::PasswordCredential> () { return get(); }
			ptr<Security::Credentials::PasswordCredential> operator->() { return get(); }
		} OldPasswordCredential;
		struct : property {
			ptr<Security::Credentials::PasswordCredential> get() { Security::Credentials::PasswordCredential* value; hrcheck(enc(&IVpnPickedCredential_adaptor::PasskeyCredential)->_get_PasskeyCredential(&value)); return from_abi(value); }
			ptr<Security::Credentials::PasswordCredential> operator()() { return get(); }
			operator ptr<Security::Credentials::PasswordCredential> () { return get(); }
			ptr<Security::Credentials::PasswordCredential> operator->() { return get(); }
		} PasskeyCredential;
	};
	IVpnPickedCredential_adaptor() {}
};
template<typename X> struct adapt<IVpnPickedCredential, X> : Windows::Networking::Vpn::IVpnPickedCredential_adaptor<X> { typedef adapt IVpnPickedCredential; };
struct IVpnPickedCredential : IVpnPickedCredential_raw, generate<IVpnPickedCredential> {};

// IVpnCredential
struct IVpnCredential_raw : IInspectable {
	virtual STDMETHODIMP _get_PasskeyCredential(Security::Credentials::PasswordCredential* *value) = 0;
	virtual STDMETHODIMP _get_CertificateCredential(Security::Cryptography::Certificates::Certificate* *value) = 0;
	virtual STDMETHODIMP _get_AdditionalPin(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_OldPasswordCredential(Security::Credentials::PasswordCredential* *value) = 0;
};
template<typename X> struct IVpnCredential_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnCredential_adaptor::AdditionalPin)->_get_AdditionalPin(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} AdditionalPin;
		struct : property {
			ptr<Security::Cryptography::Certificates::Certificate> get() { Security::Cryptography::Certificates::Certificate* value; hrcheck(enc(&IVpnCredential_adaptor::CertificateCredential)->_get_CertificateCredential(&value)); return from_abi(value); }
			ptr<Security::Cryptography::Certificates::Certificate> operator()() { return get(); }
			operator ptr<Security::Cryptography::Certificates::Certificate> () { return get(); }
			ptr<Security::Cryptography::Certificates::Certificate> operator->() { return get(); }
		} CertificateCredential;
		struct : property {
			ptr<Security::Credentials::PasswordCredential> get() { Security::Credentials::PasswordCredential* value; hrcheck(enc(&IVpnCredential_adaptor::OldPasswordCredential)->_get_OldPasswordCredential(&value)); return from_abi(value); }
			ptr<Security::Credentials::PasswordCredential> operator()() { return get(); }
			operator ptr<Security::Credentials::PasswordCredential> () { return get(); }
			ptr<Security::Credentials::PasswordCredential> operator->() { return get(); }
		} OldPasswordCredential;
		struct : property {
			ptr<Security::Credentials::PasswordCredential> get() { Security::Credentials::PasswordCredential* value; hrcheck(enc(&IVpnCredential_adaptor::PasskeyCredential)->_get_PasskeyCredential(&value)); return from_abi(value); }
			ptr<Security::Credentials::PasswordCredential> operator()() { return get(); }
			operator ptr<Security::Credentials::PasswordCredential> () { return get(); }
			ptr<Security::Credentials::PasswordCredential> operator->() { return get(); }
		} PasskeyCredential;
	};
	IVpnCredential_adaptor() {}
};
template<typename X> struct adapt<IVpnCredential, X> : Windows::Networking::Vpn::IVpnCredential_adaptor<X> { typedef adapt IVpnCredential; };
template<typename X> struct IVpnCredential_unadaptor : X {
	STDMETHODIMP _get_PasskeyCredential(Security::Credentials::PasswordCredential* *value) { return hrtry([&, this] { get_prop(value, PasskeyCredential); }); }
	STDMETHODIMP _get_CertificateCredential(Security::Cryptography::Certificates::Certificate* *value) { return hrtry([&, this] { get_prop(value, CertificateCredential); }); }
	STDMETHODIMP _get_AdditionalPin(HSTRING *value) { return hrtry([&, this] { get_prop(value, AdditionalPin); }); }
	STDMETHODIMP _get_OldPasswordCredential(Security::Credentials::PasswordCredential* *value) { return hrtry([&, this] { get_prop(value, OldPasswordCredential); }); }
};
template<typename X> struct unadapt<IVpnCredential, X> : Windows::Networking::Vpn::IVpnCredential_unadaptor<X> {};
struct IVpnCredential : IVpnCredential_raw, generate<IVpnCredential> {};

// IVpnSystemHealth
struct IVpnSystemHealth_raw : IInspectable {
	virtual STDMETHODIMP _get_StatementOfHealth(Storage::Streams::Buffer* *value);
};
template<typename X> struct IVpnSystemHealth_adaptor : X {
	union {
		struct : property {
			ptr<Storage::Streams::Buffer> get() { Storage::Streams::Buffer* value; hrcheck(enc(&IVpnSystemHealth_adaptor::StatementOfHealth)->_get_StatementOfHealth(&value)); return from_abi(value); }
			ptr<Storage::Streams::Buffer> operator()() { return get(); }
			operator ptr<Storage::Streams::Buffer> () { return get(); }
			ptr<Storage::Streams::Buffer> operator->() { return get(); }
		} StatementOfHealth;
	};
	IVpnSystemHealth_adaptor() {}
};
template<typename X> struct adapt<IVpnSystemHealth, X> : Windows::Networking::Vpn::IVpnSystemHealth_adaptor<X> { typedef adapt IVpnSystemHealth; };
struct IVpnSystemHealth : IVpnSystemHealth_raw, generate<IVpnSystemHealth> {};

// IVpnChannelConfiguration
struct IVpnChannelConfiguration_raw : IInspectable {
	virtual STDMETHODIMP _get_ServerServiceName(HSTRING *value);
	virtual STDMETHODIMP _get_ServerHostNameList(Foundation::Collections::IVectorView<HostName*>* *value);
	virtual STDMETHODIMP _get_CustomField(HSTRING *value);
};
template<typename X> struct IVpnChannelConfiguration_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnChannelConfiguration_adaptor::CustomField)->_get_CustomField(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} CustomField;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<HostName>>> get() { Foundation::Collections::IVectorView<HostName*>* value; hrcheck(enc(&IVpnChannelConfiguration_adaptor::ServerHostNameList)->_get_ServerHostNameList(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<HostName>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<HostName>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<HostName>>> operator->() { return get(); }
		} ServerHostNameList;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnChannelConfiguration_adaptor::ServerServiceName)->_get_ServerServiceName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ServerServiceName;
	};
	IVpnChannelConfiguration_adaptor() {}
};
template<typename X> struct adapt<IVpnChannelConfiguration, X> : Windows::Networking::Vpn::IVpnChannelConfiguration_adaptor<X> { typedef adapt IVpnChannelConfiguration; };
struct IVpnChannelConfiguration : IVpnChannelConfiguration_raw, generate<IVpnChannelConfiguration> {};

// IVpnChannelConfiguration2
struct IVpnChannelConfiguration2_raw : IInspectable {
	virtual STDMETHODIMP _get_ServerUris(Foundation::Collections::IVectorView<Foundation::Uri*>* *value);
};
template<typename X> struct IVpnChannelConfiguration2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Foundation::Uri>>> get() { Foundation::Collections::IVectorView<Foundation::Uri*>* value; hrcheck(enc(&IVpnChannelConfiguration2_adaptor::ServerUris)->_get_ServerUris(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Foundation::Uri>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Foundation::Uri>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Foundation::Uri>>> operator->() { return get(); }
		} ServerUris;
	};
	IVpnChannelConfiguration2_adaptor() {}
};
template<typename X> struct adapt<IVpnChannelConfiguration2, X> : Windows::Networking::Vpn::IVpnChannelConfiguration2_adaptor<X> { typedef adapt IVpnChannelConfiguration2; };
struct IVpnChannelConfiguration2 : IVpnChannelConfiguration2_raw, generate<IVpnChannelConfiguration2> {};

// IVpnChannelActivityEventArgs
struct IVpnChannelActivityEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Type(VpnChannelActivityEventType *value);
};
template<typename X> struct IVpnChannelActivityEventArgs_adaptor : X {
	union {
		struct : property {
			VpnChannelActivityEventType get() { VpnChannelActivityEventType value; hrcheck(enc(&IVpnChannelActivityEventArgs_adaptor::Type)->_get_Type(&value)); return value; }
			VpnChannelActivityEventType operator()() { return get(); }
			operator VpnChannelActivityEventType () { return get(); }
		} Type;
	};
	IVpnChannelActivityEventArgs_adaptor() {}
};
template<typename X> struct adapt<IVpnChannelActivityEventArgs, X> : Windows::Networking::Vpn::IVpnChannelActivityEventArgs_adaptor<X> { typedef adapt IVpnChannelActivityEventArgs; };
struct IVpnChannelActivityEventArgs : IVpnChannelActivityEventArgs_raw, generate<IVpnChannelActivityEventArgs> {};

// IVpnChannel
struct IVpnChannel_raw : IInspectable {
	virtual STDMETHODIMP _AssociateTransport(IInspectable* mainOuterTunnelTransport, IInspectable* optionalOuterTunnelTransport);
	virtual STDMETHODIMP _Start(Foundation::Collections::IVectorView<HostName*>* assignedClientIPv4list, Foundation::Collections::IVectorView<HostName*>* assignedClientIPv6list, VpnInterfaceId* vpnInterfaceId, VpnRouteAssignment* routeScope, VpnNamespaceAssignment* namespaceScope, unsigned mtuSize, unsigned maxFrameSize, bool optimizeForLowCostNetwork, IInspectable* mainOuterTunnelTransport, IInspectable* optionalOuterTunnelTransport);
	virtual STDMETHODIMP _Stop();
	virtual STDMETHODIMP _RequestCredentials(VpnCredentialType credType, bool isRetry, bool isSingleSignOnCredential, Security::Cryptography::Certificates::Certificate* certificate, VpnPickedCredential* *credential);
	virtual STDMETHODIMP _RequestVpnPacketBuffer(VpnDataPathType type, VpnPacketBuffer* *vpnPacketBuffer);
	virtual STDMETHODIMP _LogDiagnosticMessage(HSTRING message);
	virtual STDMETHODIMP _get_Id(unsigned *value);
	virtual STDMETHODIMP _get_Configuration(VpnChannelConfiguration* *value);
	virtual STDMETHODIMP _add_ActivityChange(Foundation::TypedEventHandler<VpnChannel*, VpnChannelActivityEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ActivityChange(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _put_PlugInContext(IInspectable* value);
	virtual STDMETHODIMP _get_PlugInContext(IInspectable* *value);
	virtual STDMETHODIMP _get_SystemHealth(VpnSystemHealth* *value);
	virtual STDMETHODIMP _RequestCustomPrompt(Foundation::Collections::IVectorView<IVpnCustomPrompt*>* customPrompt);
	virtual STDMETHODIMP _SetErrorMessage(HSTRING message);
	virtual STDMETHODIMP _SetAllowedSslTlsVersions(IInspectable* tunnelTransport, bool useTls12);
};
template<typename X> struct IVpnChannel_adaptor : X {
	union {
		struct : property {
			ptr<VpnChannelConfiguration> get() { VpnChannelConfiguration* value; hrcheck(enc(&IVpnChannel_adaptor::Configuration)->_get_Configuration(&value)); return from_abi(value); }
			ptr<VpnChannelConfiguration> operator()() { return get(); }
			operator ptr<VpnChannelConfiguration> () { return get(); }
			ptr<VpnChannelConfiguration> operator->() { return get(); }
		} Configuration;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IVpnChannel_adaptor::Id)->_get_Id(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Id;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IVpnChannel_adaptor::PlugInContext)->_get_PlugInContext(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IVpnChannel_adaptor::PlugInContext)->_put_PlugInContext(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} PlugInContext;
		struct : property {
			ptr<VpnSystemHealth> get() { VpnSystemHealth* value; hrcheck(enc(&IVpnChannel_adaptor::SystemHealth)->_get_SystemHealth(&value)); return from_abi(value); }
			ptr<VpnSystemHealth> operator()() { return get(); }
			operator ptr<VpnSystemHealth> () { return get(); }
			ptr<VpnSystemHealth> operator->() { return get(); }
		} SystemHealth;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<VpnChannel>, ptr<VpnChannelActivityEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IVpnChannel_adaptor::ActivityChange)->_add_ActivityChange(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IVpnChannel_adaptor::ActivityChange)->_remove_ActivityChange(token)); }
		} ActivityChange;
	};
	void AssociateTransport(object_ref mainOuterTunnelTransport, object_ref optionalOuterTunnelTransport) { hrcheck(X::get()->_AssociateTransport(mainOuterTunnelTransport, optionalOuterTunnelTransport)); }
	void Start(pptr<Foundation::Collections::IVectorView<ptr<HostName>>> assignedClientIPv4list, pptr<Foundation::Collections::IVectorView<ptr<HostName>>> assignedClientIPv6list, pptr<VpnInterfaceId> vpnInterfaceId, pptr<VpnRouteAssignment> routeScope, pptr<VpnNamespaceAssignment> namespaceScope, unsigned mtuSize, unsigned maxFrameSize, bool optimizeForLowCostNetwork, object_ref mainOuterTunnelTransport, object_ref optionalOuterTunnelTransport) { hrcheck(X::get()->_Start(to_abi(assignedClientIPv4list), to_abi(assignedClientIPv6list), vpnInterfaceId, routeScope, namespaceScope, mtuSize, maxFrameSize, optimizeForLowCostNetwork, mainOuterTunnelTransport, optionalOuterTunnelTransport)); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	ptr<VpnPickedCredential> RequestCredentials(VpnCredentialType credType, bool isRetry, bool isSingleSignOnCredential, pptr<Security::Cryptography::Certificates::Certificate> certificate) { VpnPickedCredential* credential; hrcheck(X::get()->_RequestCredentials(credType, isRetry, isSingleSignOnCredential, certificate, &credential)); return from_abi(credential); }
	ptr<VpnPacketBuffer> RequestVpnPacketBuffer(VpnDataPathType type) { VpnPacketBuffer* vpnPacketBuffer; hrcheck(X::get()->_RequestVpnPacketBuffer(type, &vpnPacketBuffer)); return from_abi(vpnPacketBuffer); }
	void LogDiagnosticMessage(hstring_ref message) { hrcheck(X::get()->_LogDiagnosticMessage(message)); }
	void RequestCustomPrompt(pptr<Foundation::Collections::IVectorView<ptr<IVpnCustomPrompt>>> customPrompt) { hrcheck(X::get()->_RequestCustomPrompt(to_abi(customPrompt))); }
	void SetErrorMessage(hstring_ref message) { hrcheck(X::get()->_SetErrorMessage(message)); }
	void SetAllowedSslTlsVersions(object_ref tunnelTransport, bool useTls12) { hrcheck(X::get()->_SetAllowedSslTlsVersions(tunnelTransport, useTls12)); }
	IVpnChannel_adaptor() {}
};
template<typename X> struct adapt<IVpnChannel, X> : Windows::Networking::Vpn::IVpnChannel_adaptor<X> { typedef adapt IVpnChannel; };
struct IVpnChannel : IVpnChannel_raw, generate<IVpnChannel> {};

// VpnRouteAssignment
template<typename X> struct statics<VpnRouteAssignment, X> : X {
	typedef typename X::root_type VpnRouteAssignment;
};
struct VpnRouteAssignment : generate<VpnRouteAssignment> {};

// VpnNamespaceAssignment
template<typename X> struct statics<VpnNamespaceAssignment, X> : X {
	typedef typename X::root_type VpnNamespaceAssignment;
};
struct VpnNamespaceAssignment : generate<VpnNamespaceAssignment> {};

// VpnPickedCredential
template<typename X> struct statics<VpnPickedCredential, X> : X {
	typedef typename X::root_type VpnPickedCredential;
};
struct VpnPickedCredential : generate<VpnPickedCredential> {};

// IVpnPacketBufferFactory
struct IVpnPacketBufferFactory_raw : IInspectable {
	virtual STDMETHODIMP _CreateVpnPacketBuffer(VpnPacketBuffer* parentBuffer, unsigned offset, unsigned length, VpnPacketBuffer* *vpnPacketBuffer) = 0;
};
template<typename X> struct IVpnPacketBufferFactory_adaptor : X {
	ptr<VpnPacketBuffer> CreateVpnPacketBuffer(pptr<VpnPacketBuffer> parentBuffer, unsigned offset, unsigned length) { VpnPacketBuffer* vpnPacketBuffer; hrcheck(X::get()->_CreateVpnPacketBuffer(parentBuffer, offset, length, &vpnPacketBuffer)); return from_abi(vpnPacketBuffer); }
};
template<typename X> struct adapt<IVpnPacketBufferFactory, X> : Windows::Networking::Vpn::IVpnPacketBufferFactory_adaptor<X> { typedef adapt IVpnPacketBufferFactory; };
template<typename X> struct IVpnPacketBufferFactory_unadaptor : X {
	STDMETHODIMP _CreateVpnPacketBuffer(VpnPacketBuffer* parentBuffer, unsigned offset, unsigned length, VpnPacketBuffer* *vpnPacketBuffer) { return hrtry([&, this] { *vpnPacketBuffer = to_abi(X::get()->CreateVpnPacketBuffer(parentBuffer, offset, length)); }); }
};
template<typename X> struct unadapt<IVpnPacketBufferFactory, X> : Windows::Networking::Vpn::IVpnPacketBufferFactory_unadaptor<X> {};
struct IVpnPacketBufferFactory : IVpnPacketBufferFactory_raw, generate<IVpnPacketBufferFactory> {};

// IVpnPacketBuffer3
struct IVpnPacketBuffer3_raw : IInspectable {
	virtual STDMETHODIMP _put_TransportContext(IInspectable* value);
	virtual STDMETHODIMP _get_TransportContext(IInspectable* *value);
};
template<typename X> struct IVpnPacketBuffer3_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IVpnPacketBuffer3_adaptor::TransportContext)->_get_TransportContext(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IVpnPacketBuffer3_adaptor::TransportContext)->_put_TransportContext(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} TransportContext;
	};
	IVpnPacketBuffer3_adaptor() {}
};
template<typename X> struct adapt<IVpnPacketBuffer3, X> : Windows::Networking::Vpn::IVpnPacketBuffer3_adaptor<X> { typedef adapt IVpnPacketBuffer3; };
struct IVpnPacketBuffer3 : IVpnPacketBuffer3_raw, generate<IVpnPacketBuffer3> {};

// IVpnPacketBuffer2
struct IVpnPacketBuffer2_raw : IInspectable {
	virtual STDMETHODIMP _get_AppId(VpnAppId* *value);
};
template<typename X> struct IVpnPacketBuffer2_adaptor : X {
	union {
		struct : property {
			ptr<VpnAppId> get() { VpnAppId* value; hrcheck(enc(&IVpnPacketBuffer2_adaptor::AppId)->_get_AppId(&value)); return from_abi(value); }
			ptr<VpnAppId> operator()() { return get(); }
			operator ptr<VpnAppId> () { return get(); }
			ptr<VpnAppId> operator->() { return get(); }
		} AppId;
	};
	IVpnPacketBuffer2_adaptor() {}
};
template<typename X> struct adapt<IVpnPacketBuffer2, X> : Windows::Networking::Vpn::IVpnPacketBuffer2_adaptor<X> { typedef adapt IVpnPacketBuffer2; };
struct IVpnPacketBuffer2 : IVpnPacketBuffer2_raw, generate<IVpnPacketBuffer2> {};

// IVpnPacketBuffer
struct IVpnPacketBuffer_raw : IInspectable {
	virtual STDMETHODIMP _get_Buffer(Storage::Streams::Buffer* *value);
	virtual STDMETHODIMP _put_Status(VpnPacketBufferStatus value);
	virtual STDMETHODIMP _get_Status(VpnPacketBufferStatus *value);
	virtual STDMETHODIMP _put_TransportAffinity(unsigned value);
	virtual STDMETHODIMP _get_TransportAffinity(unsigned *value);
};
template<typename X> struct IVpnPacketBuffer_adaptor : X {
	union {
		struct : property {
			ptr<Storage::Streams::Buffer> get() { Storage::Streams::Buffer* value; hrcheck(enc(&IVpnPacketBuffer_adaptor::Buffer)->_get_Buffer(&value)); return from_abi(value); }
			ptr<Storage::Streams::Buffer> operator()() { return get(); }
			operator ptr<Storage::Streams::Buffer> () { return get(); }
			ptr<Storage::Streams::Buffer> operator->() { return get(); }
		} Buffer;
		struct : property {
			VpnPacketBufferStatus get() { VpnPacketBufferStatus value; hrcheck(enc(&IVpnPacketBuffer_adaptor::Status)->_get_Status(&value)); return value; }
			VpnPacketBufferStatus operator()() { return get(); }
			operator VpnPacketBufferStatus () { return get(); }
			void put(VpnPacketBufferStatus value) { hrcheck(enc(&IVpnPacketBuffer_adaptor::Status)->_put_Status(value)); }
			void operator=(VpnPacketBufferStatus value) { put(value); }
			void operator()(VpnPacketBufferStatus value) { put(value); }
		} Status;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IVpnPacketBuffer_adaptor::TransportAffinity)->_get_TransportAffinity(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IVpnPacketBuffer_adaptor::TransportAffinity)->_put_TransportAffinity(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} TransportAffinity;
	};
	IVpnPacketBuffer_adaptor() {}
};
template<typename X> struct adapt<IVpnPacketBuffer, X> : Windows::Networking::Vpn::IVpnPacketBuffer_adaptor<X> { typedef adapt IVpnPacketBuffer; };
struct IVpnPacketBuffer : IVpnPacketBuffer_raw, generate<IVpnPacketBuffer> {};

// VpnPacketBuffer
template<typename> struct VpnPacketBuffer_statics {
	static VpnPacketBuffer *activate(pptr<VpnPacketBuffer> parentBuffer, unsigned offset, unsigned length) { VpnPacketBuffer *vpnPacketBuffer; hrcheck(get_activation_factory<VpnPacketBuffer, IVpnPacketBufferFactory>()->_CreateVpnPacketBuffer(parentBuffer, offset, length, &vpnPacketBuffer)); return vpnPacketBuffer; }
};

template<typename X> struct statics<VpnPacketBuffer, X> : X, Windows::Networking::Vpn::VpnPacketBuffer_statics<void> {
	using Windows::Networking::Vpn::VpnPacketBuffer_statics<void>::activate;
	typedef typename X::root_type VpnPacketBuffer;
};
struct VpnPacketBuffer : generate<VpnPacketBuffer> {};

// VpnChannelConfiguration
template<typename X> struct statics<VpnChannelConfiguration, X> : X {
	typedef typename X::root_type VpnChannelConfiguration;
};
struct VpnChannelConfiguration : generate<VpnChannelConfiguration> {};

// IVpnChannel4
struct IVpnChannel4_raw : IInspectable {
	virtual STDMETHODIMP _AddAndAssociateTransport(IInspectable* transport, IInspectable* context);
	virtual STDMETHODIMP _StartWithMultipleTransports(Foundation::Collections::IIterable<HostName*>* assignedClientIpv4Addresses, Foundation::Collections::IIterable<HostName*>* assignedClientIpv6Addresses, VpnInterfaceId* vpninterfaceId, VpnRouteAssignment* assignedRoutes, VpnDomainNameAssignment* assignedNamespace, unsigned mtuSize, unsigned maxFrameSize, bool reserved, Foundation::Collections::IIterable<IInspectable*>* transports, VpnTrafficFilterAssignment* assignedTrafficFilters);
	virtual STDMETHODIMP _ReplaceAndAssociateTransport(IInspectable* transport, IInspectable* context);
	virtual STDMETHODIMP _StartReconnectingTransport(IInspectable* transport, IInspectable* context);
	virtual STDMETHODIMP _GetSlotTypeForTransportContext(IInspectable* context, Sockets::ControlChannelTriggerStatus *slotType);
	virtual STDMETHODIMP _get_CurrentRequestTransportContext(IInspectable* *context);
};
template<typename X> struct IVpnChannel4_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* context; hrcheck(enc(&IVpnChannel4_adaptor::CurrentRequestTransportContext)->_get_CurrentRequestTransportContext(&context)); return from_abi(context); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} CurrentRequestTransportContext;
	};
	void AddAndAssociateTransport(object_ref transport, object_ref context) { hrcheck(X::get()->_AddAndAssociateTransport(transport, context)); }
	void StartWithTrafficFilter(pptr<Foundation::Collections::IIterable<ptr<HostName>>> assignedClientIpv4Addresses, pptr<Foundation::Collections::IIterable<ptr<HostName>>> assignedClientIpv6Addresses, pptr<VpnInterfaceId> vpninterfaceId, pptr<VpnRouteAssignment> assignedRoutes, pptr<VpnDomainNameAssignment> assignedNamespace, unsigned mtuSize, unsigned maxFrameSize, bool reserved, pptr<Foundation::Collections::IIterable<object>> transports, pptr<VpnTrafficFilterAssignment> assignedTrafficFilters) { hrcheck(X::get()->_StartWithMultipleTransports(to_abi(assignedClientIpv4Addresses), to_abi(assignedClientIpv6Addresses), vpninterfaceId, assignedRoutes, assignedNamespace, mtuSize, maxFrameSize, reserved, to_abi(transports), assignedTrafficFilters)); }
	void ReplaceAndAssociateTransport(object_ref transport, object_ref context) { hrcheck(X::get()->_ReplaceAndAssociateTransport(transport, context)); }
	void StartReconnectingTransport(object_ref transport, object_ref context) { hrcheck(X::get()->_StartReconnectingTransport(transport, context)); }
	Sockets::ControlChannelTriggerStatus GetSlotTypeForTransportContext(object_ref context) { Sockets::ControlChannelTriggerStatus slotType; hrcheck(X::get()->_GetSlotTypeForTransportContext(context, &slotType)); return slotType; }
	IVpnChannel4_adaptor() {}
};
template<typename X> struct adapt<IVpnChannel4, X> : Windows::Networking::Vpn::IVpnChannel4_adaptor<X> { typedef adapt IVpnChannel4; };
struct IVpnChannel4 : IVpnChannel4_raw, generate<IVpnChannel4> {};

// IVpnChannel2
struct IVpnChannel2_raw : IInspectable {
	virtual STDMETHODIMP _StartWithMainTransport(Foundation::Collections::IVectorView<HostName*>* assignedClientIPv4list, Foundation::Collections::IVectorView<HostName*>* assignedClientIPv6list, VpnInterfaceId* vpnInterfaceId, VpnRouteAssignment* assignedRoutes, VpnDomainNameAssignment* assignedDomainName, unsigned mtuSize, unsigned maxFrameSize, bool Reserved, IInspectable* mainOuterTunnelTransport);
	virtual STDMETHODIMP _StartExistingTransports(Foundation::Collections::IVectorView<HostName*>* assignedClientIPv4list, Foundation::Collections::IVectorView<HostName*>* assignedClientIPv6list, VpnInterfaceId* vpnInterfaceId, VpnRouteAssignment* assignedRoutes, VpnDomainNameAssignment* assignedDomainName, unsigned mtuSize, unsigned maxFrameSize, bool Reserved);
	virtual STDMETHODIMP _add_ActivityStateChange(Foundation::TypedEventHandler<VpnChannel*, VpnChannelActivityStateChangedArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ActivityStateChange(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _GetVpnSendPacketBuffer(VpnPacketBuffer* *vpnSendPacketBuffer);
	virtual STDMETHODIMP _GetVpnReceivePacketBuffer(VpnPacketBuffer* *vpnReceivePacketBuffer);
	virtual STDMETHODIMP _RequestCustomPromptAsync(Foundation::Collections::IVectorView<IVpnCustomPromptElement*>* customPromptElement, Foundation::IAsyncAction* *action);
	virtual STDMETHODIMP _RequestCredentialsWithCertificateAsync(VpnCredentialType credType, unsigned credOptions, Security::Cryptography::Certificates::Certificate* certificate, Foundation::IAsyncOperation<VpnCredential*>* *credential);
	virtual STDMETHODIMP _RequestCredentialsWithOptionsAsync(VpnCredentialType credType, unsigned credOptions, Foundation::IAsyncOperation<VpnCredential*>* *credential);
	virtual STDMETHODIMP _RequestCredentialsSimpleAsync(VpnCredentialType credType, Foundation::IAsyncOperation<VpnCredential*>* *credential);
	virtual STDMETHODIMP _TerminateConnection(HSTRING message);
	virtual STDMETHODIMP _StartWithTrafficFilter(Foundation::Collections::IVectorView<HostName*>* assignedClientIpv4List, Foundation::Collections::IVectorView<HostName*>* assignedClientIpv6List, VpnInterfaceId* vpnInterfaceId, VpnRouteAssignment* assignedRoutes, VpnDomainNameAssignment* assignedNamespace, unsigned mtuSize, unsigned maxFrameSize, bool reserved, IInspectable* mainOuterTunnelTransport, IInspectable* optionalOuterTunnelTransport, VpnTrafficFilterAssignment* assignedTrafficFilters);
};
template<typename X> struct IVpnChannel2_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<VpnChannel>, ptr<VpnChannelActivityStateChangedArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IVpnChannel2_adaptor::ActivityStateChange)->_add_ActivityStateChange(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IVpnChannel2_adaptor::ActivityStateChange)->_remove_ActivityStateChange(token)); }
		} ActivityStateChange;
	};
	void StartWithMainTransport(pptr<Foundation::Collections::IVectorView<ptr<HostName>>> assignedClientIPv4list, pptr<Foundation::Collections::IVectorView<ptr<HostName>>> assignedClientIPv6list, pptr<VpnInterfaceId> vpnInterfaceId, pptr<VpnRouteAssignment> assignedRoutes, pptr<VpnDomainNameAssignment> assignedDomainName, unsigned mtuSize, unsigned maxFrameSize, bool Reserved, object_ref mainOuterTunnelTransport) { hrcheck(X::get()->_StartWithMainTransport(to_abi(assignedClientIPv4list), to_abi(assignedClientIPv6list), vpnInterfaceId, assignedRoutes, assignedDomainName, mtuSize, maxFrameSize, Reserved, mainOuterTunnelTransport)); }
	void StartExistingTransports(pptr<Foundation::Collections::IVectorView<ptr<HostName>>> assignedClientIPv4list, pptr<Foundation::Collections::IVectorView<ptr<HostName>>> assignedClientIPv6list, pptr<VpnInterfaceId> vpnInterfaceId, pptr<VpnRouteAssignment> assignedRoutes, pptr<VpnDomainNameAssignment> assignedDomainName, unsigned mtuSize, unsigned maxFrameSize, bool Reserved) { hrcheck(X::get()->_StartExistingTransports(to_abi(assignedClientIPv4list), to_abi(assignedClientIPv6list), vpnInterfaceId, assignedRoutes, assignedDomainName, mtuSize, maxFrameSize, Reserved)); }
	ptr<VpnPacketBuffer> GetVpnSendPacketBuffer() { VpnPacketBuffer* vpnSendPacketBuffer; hrcheck(X::get()->_GetVpnSendPacketBuffer(&vpnSendPacketBuffer)); return from_abi(vpnSendPacketBuffer); }
	ptr<VpnPacketBuffer> GetVpnReceivePacketBuffer() { VpnPacketBuffer* vpnReceivePacketBuffer; hrcheck(X::get()->_GetVpnReceivePacketBuffer(&vpnReceivePacketBuffer)); return from_abi(vpnReceivePacketBuffer); }
	ptr<Foundation::IAsyncAction> RequestCustomPromptAsync(pptr<Foundation::Collections::IVectorView<ptr<IVpnCustomPromptElement>>> customPromptElement) { Foundation::IAsyncAction* action; hrcheck(X::get()->_RequestCustomPromptAsync(to_abi(customPromptElement), &action)); return from_abi(action); }
	ptr<Foundation::IAsyncOperation<ptr<VpnCredential>>> RequestCredentialsAsync(VpnCredentialType credType, unsigned credOptions, pptr<Security::Cryptography::Certificates::Certificate> certificate) { Foundation::IAsyncOperation<VpnCredential*>* credential; hrcheck(X::get()->_RequestCredentialsWithCertificateAsync(credType, credOptions, certificate, &credential)); return from_abi(credential); }
	ptr<Foundation::IAsyncOperation<ptr<VpnCredential>>> RequestCredentialsAsync(VpnCredentialType credType, unsigned credOptions) { Foundation::IAsyncOperation<VpnCredential*>* credential; hrcheck(X::get()->_RequestCredentialsWithOptionsAsync(credType, credOptions, &credential)); return from_abi(credential); }
	ptr<Foundation::IAsyncOperation<ptr<VpnCredential>>> RequestCredentialsAsync(VpnCredentialType credType) { Foundation::IAsyncOperation<VpnCredential*>* credential; hrcheck(X::get()->_RequestCredentialsSimpleAsync(credType, &credential)); return from_abi(credential); }
	void TerminateConnection(hstring_ref message) { hrcheck(X::get()->_TerminateConnection(message)); }
	void StartWithTrafficFilter(pptr<Foundation::Collections::IVectorView<ptr<HostName>>> assignedClientIpv4List, pptr<Foundation::Collections::IVectorView<ptr<HostName>>> assignedClientIpv6List, pptr<VpnInterfaceId> vpnInterfaceId, pptr<VpnRouteAssignment> assignedRoutes, pptr<VpnDomainNameAssignment> assignedNamespace, unsigned mtuSize, unsigned maxFrameSize, bool reserved, object_ref mainOuterTunnelTransport, object_ref optionalOuterTunnelTransport, pptr<VpnTrafficFilterAssignment> assignedTrafficFilters) { hrcheck(X::get()->_StartWithTrafficFilter(to_abi(assignedClientIpv4List), to_abi(assignedClientIpv6List), vpnInterfaceId, assignedRoutes, assignedNamespace, mtuSize, maxFrameSize, reserved, mainOuterTunnelTransport, optionalOuterTunnelTransport, assignedTrafficFilters)); }
	IVpnChannel2_adaptor() {}
};
template<typename X> struct adapt<IVpnChannel2, X> : Windows::Networking::Vpn::IVpnChannel2_adaptor<X> { typedef adapt IVpnChannel2; };
struct IVpnChannel2 : IVpnChannel2_raw, generate<IVpnChannel2> {};

// VpnChannel
template<typename> struct VpnChannel_statics {
	static void ProcessEventAsync(object_ref thirdPartyPlugIn, object_ref event);
};

template<typename X> struct statics<VpnChannel, X> : X, Windows::Networking::Vpn::VpnChannel_statics<void> {
	typedef typename X::root_type VpnChannel;
};
struct VpnChannel : generate<VpnChannel> {
	using IVpnChannel2::RequestCredentialsAsync;
	using IVpnChannel4::StartWithTrafficFilter;
	using IVpnChannel2::StartWithTrafficFilter;
};

// VpnChannelActivityEventArgs
template<typename X> struct statics<VpnChannelActivityEventArgs, X> : X {
	typedef typename X::root_type VpnChannelActivityEventArgs;
};
struct VpnChannelActivityEventArgs : generate<VpnChannelActivityEventArgs> {};

// VpnSystemHealth
template<typename X> struct statics<VpnSystemHealth, X> : X {
	typedef typename X::root_type VpnSystemHealth;
};
struct VpnSystemHealth : generate<VpnSystemHealth> {};

// IVpnDomainNameAssignment
struct IVpnDomainNameAssignment_raw : IInspectable {
	virtual STDMETHODIMP _get_DomainNameList(Foundation::Collections::IVector<VpnDomainNameInfo*>* *value);
	virtual STDMETHODIMP _put_ProxyAutoConfigurationUri(Foundation::Uri* value);
	virtual STDMETHODIMP _get_ProxyAutoConfigurationUri(Foundation::Uri* *value);
};
template<typename X> struct IVpnDomainNameAssignment_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<VpnDomainNameInfo>>> get() { Foundation::Collections::IVector<VpnDomainNameInfo*>* value; hrcheck(enc(&IVpnDomainNameAssignment_adaptor::DomainNameList)->_get_DomainNameList(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<VpnDomainNameInfo>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<VpnDomainNameInfo>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<VpnDomainNameInfo>>> operator->() { return get(); }
		} DomainNameList;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IVpnDomainNameAssignment_adaptor::ProxyAutoConfigurationUri)->_get_ProxyAutoConfigurationUri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IVpnDomainNameAssignment_adaptor::ProxyAutoConfigurationUri)->_put_ProxyAutoConfigurationUri(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} ProxyAutoConfigurationUri;
	};
	IVpnDomainNameAssignment_adaptor() {}
};
template<typename X> struct adapt<IVpnDomainNameAssignment, X> : Windows::Networking::Vpn::IVpnDomainNameAssignment_adaptor<X> { typedef adapt IVpnDomainNameAssignment; };
struct IVpnDomainNameAssignment : IVpnDomainNameAssignment_raw, generate<IVpnDomainNameAssignment> {};

// VpnDomainNameAssignment
template<typename X> struct statics<VpnDomainNameAssignment, X> : X {
	typedef typename X::root_type VpnDomainNameAssignment;
};
struct VpnDomainNameAssignment : generate<VpnDomainNameAssignment> {};

// IVpnChannelActivityStateChangedArgs
struct IVpnChannelActivityStateChangedArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ActivityState(VpnChannelActivityEventType *value);
};
template<typename X> struct IVpnChannelActivityStateChangedArgs_adaptor : X {
	union {
		struct : property {
			VpnChannelActivityEventType get() { VpnChannelActivityEventType value; hrcheck(enc(&IVpnChannelActivityStateChangedArgs_adaptor::ActivityState)->_get_ActivityState(&value)); return value; }
			VpnChannelActivityEventType operator()() { return get(); }
			operator VpnChannelActivityEventType () { return get(); }
		} ActivityState;
	};
	IVpnChannelActivityStateChangedArgs_adaptor() {}
};
template<typename X> struct adapt<IVpnChannelActivityStateChangedArgs, X> : Windows::Networking::Vpn::IVpnChannelActivityStateChangedArgs_adaptor<X> { typedef adapt IVpnChannelActivityStateChangedArgs; };
struct IVpnChannelActivityStateChangedArgs : IVpnChannelActivityStateChangedArgs_raw, generate<IVpnChannelActivityStateChangedArgs> {};

// VpnChannelActivityStateChangedArgs
template<typename X> struct statics<VpnChannelActivityStateChangedArgs, X> : X {
	typedef typename X::root_type VpnChannelActivityStateChangedArgs;
};
struct VpnChannelActivityStateChangedArgs : generate<VpnChannelActivityStateChangedArgs> {};

// IVpnCustomPromptElement
struct IVpnCustomPromptElement_raw : IInspectable {
	virtual STDMETHODIMP _put_DisplayName(HSTRING value) = 0;
	virtual STDMETHODIMP _get_DisplayName(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_Compulsory(bool value) = 0;
	virtual STDMETHODIMP _get_Compulsory(bool *value) = 0;
	virtual STDMETHODIMP _put_Emphasized(bool value) = 0;
	virtual STDMETHODIMP _get_Emphasized(bool *value) = 0;
};
template<typename X> struct IVpnCustomPromptElement_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnCustomPromptElement_adaptor::Compulsory)->_get_Compulsory(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVpnCustomPromptElement_adaptor::Compulsory)->_put_Compulsory(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Compulsory;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnCustomPromptElement_adaptor::DisplayName)->_get_DisplayName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVpnCustomPromptElement_adaptor::DisplayName)->_put_DisplayName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DisplayName;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnCustomPromptElement_adaptor::Emphasized)->_get_Emphasized(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVpnCustomPromptElement_adaptor::Emphasized)->_put_Emphasized(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Emphasized;
	};
	IVpnCustomPromptElement_adaptor() {}
};
template<typename X> struct adapt<IVpnCustomPromptElement, X> : Windows::Networking::Vpn::IVpnCustomPromptElement_adaptor<X> { typedef adapt IVpnCustomPromptElement; };
template<typename X> struct IVpnCustomPromptElement_unadaptor : X {
	STDMETHODIMP _put_DisplayName(HSTRING value) { return hrtry([&, this] { put_prop(value, DisplayName); }); }
	STDMETHODIMP _get_DisplayName(HSTRING *value) { return hrtry([&, this] { get_prop(value, DisplayName); }); }
	STDMETHODIMP _put_Compulsory(bool value) { return hrtry([&, this] { put_prop(value, Compulsory); }); }
	STDMETHODIMP _get_Compulsory(bool *value) { return hrtry([&, this] { get_prop(value, Compulsory); }); }
	STDMETHODIMP _put_Emphasized(bool value) { return hrtry([&, this] { put_prop(value, Emphasized); }); }
	STDMETHODIMP _get_Emphasized(bool *value) { return hrtry([&, this] { get_prop(value, Emphasized); }); }
};
template<typename X> struct unadapt<IVpnCustomPromptElement, X> : Windows::Networking::Vpn::IVpnCustomPromptElement_unadaptor<X> {};
struct IVpnCustomPromptElement : IVpnCustomPromptElement_raw, generate<IVpnCustomPromptElement> {};

// VpnCredential
template<typename X> struct statics<VpnCredential, X> : X {
	typedef typename X::root_type VpnCredential;
};
struct VpnCredential : generate<VpnCredential> {};

// IVpnTrafficFilterAssignment
struct IVpnTrafficFilterAssignment_raw : IInspectable {
	virtual STDMETHODIMP _get_TrafficFilterList(Foundation::Collections::IVector<VpnTrafficFilter*>* *value);
	virtual STDMETHODIMP _get_AllowOutbound(bool *value);
	virtual STDMETHODIMP _put_AllowOutbound(bool value);
	virtual STDMETHODIMP _get_AllowInbound(bool *value);
	virtual STDMETHODIMP _put_AllowInbound(bool value);
};
template<typename X> struct IVpnTrafficFilterAssignment_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnTrafficFilterAssignment_adaptor::AllowInbound)->_get_AllowInbound(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVpnTrafficFilterAssignment_adaptor::AllowInbound)->_put_AllowInbound(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AllowInbound;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnTrafficFilterAssignment_adaptor::AllowOutbound)->_get_AllowOutbound(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVpnTrafficFilterAssignment_adaptor::AllowOutbound)->_put_AllowOutbound(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AllowOutbound;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<VpnTrafficFilter>>> get() { Foundation::Collections::IVector<VpnTrafficFilter*>* value; hrcheck(enc(&IVpnTrafficFilterAssignment_adaptor::TrafficFilterList)->_get_TrafficFilterList(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<VpnTrafficFilter>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<VpnTrafficFilter>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<VpnTrafficFilter>>> operator->() { return get(); }
		} TrafficFilterList;
	};
	IVpnTrafficFilterAssignment_adaptor() {}
};
template<typename X> struct adapt<IVpnTrafficFilterAssignment, X> : Windows::Networking::Vpn::IVpnTrafficFilterAssignment_adaptor<X> { typedef adapt IVpnTrafficFilterAssignment; };
struct IVpnTrafficFilterAssignment : IVpnTrafficFilterAssignment_raw, generate<IVpnTrafficFilterAssignment> {};

// VpnTrafficFilterAssignment
template<typename X> struct statics<VpnTrafficFilterAssignment, X> : X {
	typedef typename X::root_type VpnTrafficFilterAssignment;
};
struct VpnTrafficFilterAssignment : generate<VpnTrafficFilterAssignment> {};

// IVpnChannelStatics
struct IVpnChannelStatics_raw : IInspectable {
	virtual STDMETHODIMP _ProcessEventAsync(IInspectable* thirdPartyPlugIn, IInspectable* event) = 0;
};
template<typename X> struct IVpnChannelStatics_adaptor : X {
	void ProcessEventAsync(object_ref thirdPartyPlugIn, object_ref event) { hrcheck(X::get()->_ProcessEventAsync(thirdPartyPlugIn, event)); }
};
template<typename X> struct adapt<IVpnChannelStatics, X> : Windows::Networking::Vpn::IVpnChannelStatics_adaptor<X> { typedef adapt IVpnChannelStatics; };
template<typename X> struct IVpnChannelStatics_unadaptor : X {
	STDMETHODIMP _ProcessEventAsync(IInspectable* thirdPartyPlugIn, IInspectable* event) { return hrtry([&, this] { X::get()->ProcessEventAsync(thirdPartyPlugIn, event); }); }
};
template<typename X> struct unadapt<IVpnChannelStatics, X> : Windows::Networking::Vpn::IVpnChannelStatics_unadaptor<X> {};
struct IVpnChannelStatics : IVpnChannelStatics_raw, generate<IVpnChannelStatics> {};

// IVpnAppIdFactory
struct IVpnAppIdFactory : IInspectable {
	virtual STDMETHODIMP _Create(VpnAppIdType type, HSTRING value, VpnAppId* *result);
};

// IVpnAppId
struct IVpnAppId_raw : IInspectable {
	virtual STDMETHODIMP _get_Type(VpnAppIdType *value);
	virtual STDMETHODIMP _put_Type(VpnAppIdType value);
	virtual STDMETHODIMP _get_Value(HSTRING *value);
	virtual STDMETHODIMP _put_Value(HSTRING value);
};
template<typename X> struct IVpnAppId_adaptor : X {
	union {
		struct : property {
			VpnAppIdType get() { VpnAppIdType value; hrcheck(enc(&IVpnAppId_adaptor::Type)->_get_Type(&value)); return value; }
			VpnAppIdType operator()() { return get(); }
			operator VpnAppIdType () { return get(); }
			void put(VpnAppIdType value) { hrcheck(enc(&IVpnAppId_adaptor::Type)->_put_Type(value)); }
			void operator=(VpnAppIdType value) { put(value); }
			void operator()(VpnAppIdType value) { put(value); }
		} Type;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnAppId_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVpnAppId_adaptor::Value)->_put_Value(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Value;
	};
	IVpnAppId_adaptor() {}
};
template<typename X> struct adapt<IVpnAppId, X> : Windows::Networking::Vpn::IVpnAppId_adaptor<X> { typedef adapt IVpnAppId; };
struct IVpnAppId : IVpnAppId_raw, generate<IVpnAppId> {};

// VpnAppId
template<typename> struct VpnAppId_statics {
	static VpnAppId *activate(VpnAppIdType type, hstring_ref value) { VpnAppId *result; hrcheck(get_activation_factory<VpnAppId, IVpnAppIdFactory>()->_Create(type, value, &result)); return result; }
};

template<typename X> struct statics<VpnAppId, X> : X, Windows::Networking::Vpn::VpnAppId_statics<void> {
	using Windows::Networking::Vpn::VpnAppId_statics<void>::activate;
	typedef typename X::root_type VpnAppId;
};
struct VpnAppId : generate<VpnAppId> {};

// IVpnPacketBufferList
struct IVpnPacketBufferList_raw : IInspectable {
	virtual STDMETHODIMP _Append(VpnPacketBuffer* nextVpnPacketBuffer);
	virtual STDMETHODIMP _AddAtBegin(VpnPacketBuffer* nextVpnPacketBuffer);
	virtual STDMETHODIMP _RemoveAtEnd(VpnPacketBuffer* *nextVpnPacketBuffer);
	virtual STDMETHODIMP _RemoveAtBegin(VpnPacketBuffer* *nextVpnPacketBuffer);
	virtual STDMETHODIMP _Clear();
	virtual STDMETHODIMP _put_Status(VpnPacketBufferStatus value);
	virtual STDMETHODIMP _get_Status(VpnPacketBufferStatus *value);
	virtual STDMETHODIMP _get_Size(unsigned *value);
};
template<typename X> struct IVpnPacketBufferList_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IVpnPacketBufferList_adaptor::Size)->_get_Size(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Size;
		struct : property {
			VpnPacketBufferStatus get() { VpnPacketBufferStatus value; hrcheck(enc(&IVpnPacketBufferList_adaptor::Status)->_get_Status(&value)); return value; }
			VpnPacketBufferStatus operator()() { return get(); }
			operator VpnPacketBufferStatus () { return get(); }
			void put(VpnPacketBufferStatus value) { hrcheck(enc(&IVpnPacketBufferList_adaptor::Status)->_put_Status(value)); }
			void operator=(VpnPacketBufferStatus value) { put(value); }
			void operator()(VpnPacketBufferStatus value) { put(value); }
		} Status;
	};
	void Append(pptr<VpnPacketBuffer> nextVpnPacketBuffer) { hrcheck(X::get()->_Append(nextVpnPacketBuffer)); }
	void AddAtBegin(pptr<VpnPacketBuffer> nextVpnPacketBuffer) { hrcheck(X::get()->_AddAtBegin(nextVpnPacketBuffer)); }
	ptr<VpnPacketBuffer> RemoveAtEnd() { VpnPacketBuffer* nextVpnPacketBuffer; hrcheck(X::get()->_RemoveAtEnd(&nextVpnPacketBuffer)); return from_abi(nextVpnPacketBuffer); }
	ptr<VpnPacketBuffer> RemoveAtBegin() { VpnPacketBuffer* nextVpnPacketBuffer; hrcheck(X::get()->_RemoveAtBegin(&nextVpnPacketBuffer)); return from_abi(nextVpnPacketBuffer); }
	void Clear() { hrcheck(X::get()->_Clear()); }
	IVpnPacketBufferList_adaptor() {}
};
template<typename X> struct adapt<IVpnPacketBufferList, X> : Windows::Networking::Vpn::IVpnPacketBufferList_adaptor<X> { typedef adapt IVpnPacketBufferList; };
struct IVpnPacketBufferList : IVpnPacketBufferList_raw, generate<IVpnPacketBufferList> {};

// IVpnPacketBufferList2
struct IVpnPacketBufferList2 : IInspectable {
	virtual STDMETHODIMP _AddLeadingPacket(VpnPacketBuffer* nextVpnPacketBuffer);
	virtual STDMETHODIMP _RemoveLeadingPacket(VpnPacketBuffer* *nextVpnPacketBuffer);
	virtual STDMETHODIMP _AddTrailingPacket(VpnPacketBuffer* nextVpnPacketBuffer);
	virtual STDMETHODIMP _RemoveTrailingPacket(VpnPacketBuffer* *nextVpnPacketBuffer);
};

// IVpnCustomPromptTextInput
struct IVpnCustomPromptTextInput_raw : IInspectable {
	virtual STDMETHODIMP _put_PlaceholderText(HSTRING value);
	virtual STDMETHODIMP _get_PlaceholderText(HSTRING *value);
	virtual STDMETHODIMP _put_IsTextHidden(bool value);
	virtual STDMETHODIMP _get_IsTextHidden(bool *value);
	virtual STDMETHODIMP _get_Text(HSTRING *value);
};
template<typename X> struct IVpnCustomPromptTextInput_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnCustomPromptTextInput_adaptor::IsTextHidden)->_get_IsTextHidden(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVpnCustomPromptTextInput_adaptor::IsTextHidden)->_put_IsTextHidden(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTextHidden;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnCustomPromptTextInput_adaptor::PlaceholderText)->_get_PlaceholderText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVpnCustomPromptTextInput_adaptor::PlaceholderText)->_put_PlaceholderText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PlaceholderText;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnCustomPromptTextInput_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Text;
	};
	IVpnCustomPromptTextInput_adaptor() {}
};
template<typename X> struct adapt<IVpnCustomPromptTextInput, X> : Windows::Networking::Vpn::IVpnCustomPromptTextInput_adaptor<X> { typedef adapt IVpnCustomPromptTextInput; };
struct IVpnCustomPromptTextInput : IVpnCustomPromptTextInput_raw, generate<IVpnCustomPromptTextInput> {};

// IVpnCustomPromptOptionSelector
struct IVpnCustomPromptOptionSelector_raw : IInspectable {
	virtual STDMETHODIMP _get_Options(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_SelectedIndex(unsigned *value);
};
template<typename X> struct IVpnCustomPromptOptionSelector_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IVpnCustomPromptOptionSelector_adaptor::Options)->_get_Options(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} Options;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IVpnCustomPromptOptionSelector_adaptor::SelectedIndex)->_get_SelectedIndex(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} SelectedIndex;
	};
	IVpnCustomPromptOptionSelector_adaptor() {}
};
template<typename X> struct adapt<IVpnCustomPromptOptionSelector, X> : Windows::Networking::Vpn::IVpnCustomPromptOptionSelector_adaptor<X> { typedef adapt IVpnCustomPromptOptionSelector; };
struct IVpnCustomPromptOptionSelector : IVpnCustomPromptOptionSelector_raw, generate<IVpnCustomPromptOptionSelector> {};

// IVpnCustomPromptBooleanInput
struct IVpnCustomPromptBooleanInput_raw : IInspectable {
	virtual STDMETHODIMP _put_InitialValue(bool value);
	virtual STDMETHODIMP _get_InitialValue(bool *value);
	virtual STDMETHODIMP _get_Value(bool *value);
};
template<typename X> struct IVpnCustomPromptBooleanInput_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnCustomPromptBooleanInput_adaptor::InitialValue)->_get_InitialValue(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVpnCustomPromptBooleanInput_adaptor::InitialValue)->_put_InitialValue(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} InitialValue;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnCustomPromptBooleanInput_adaptor::Value)->_get_Value(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Value;
	};
	IVpnCustomPromptBooleanInput_adaptor() {}
};
template<typename X> struct adapt<IVpnCustomPromptBooleanInput, X> : Windows::Networking::Vpn::IVpnCustomPromptBooleanInput_adaptor<X> { typedef adapt IVpnCustomPromptBooleanInput; };
struct IVpnCustomPromptBooleanInput : IVpnCustomPromptBooleanInput_raw, generate<IVpnCustomPromptBooleanInput> {};

// IVpnCustomPromptText
struct IVpnCustomPromptText_raw : IInspectable {
	virtual STDMETHODIMP _put_Text(HSTRING value);
	virtual STDMETHODIMP _get_Text(HSTRING *value);
};
template<typename X> struct IVpnCustomPromptText_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnCustomPromptText_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVpnCustomPromptText_adaptor::Text)->_put_Text(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Text;
	};
	IVpnCustomPromptText_adaptor() {}
};
template<typename X> struct adapt<IVpnCustomPromptText, X> : Windows::Networking::Vpn::IVpnCustomPromptText_adaptor<X> { typedef adapt IVpnCustomPromptText; };
struct IVpnCustomPromptText : IVpnCustomPromptText_raw, generate<IVpnCustomPromptText> {};

// IVpnDomainNameInfoFactory
struct IVpnDomainNameInfoFactory_raw : IInspectable {
	virtual STDMETHODIMP _CreateVpnDomainNameInfo(HSTRING name, VpnDomainNameType nameType, Foundation::Collections::IIterable<HostName*>* dnsServerList, Foundation::Collections::IIterable<HostName*>* proxyServerList, VpnDomainNameInfo* *domainNameInfo) = 0;
};
template<typename X> struct IVpnDomainNameInfoFactory_adaptor : X {
	ptr<VpnDomainNameInfo> CreateVpnDomainNameInfo(hstring_ref name, VpnDomainNameType nameType, pptr<Foundation::Collections::IIterable<ptr<HostName>>> dnsServerList, pptr<Foundation::Collections::IIterable<ptr<HostName>>> proxyServerList) { VpnDomainNameInfo* domainNameInfo; hrcheck(X::get()->_CreateVpnDomainNameInfo(name, nameType, to_abi(dnsServerList), to_abi(proxyServerList), &domainNameInfo)); return from_abi(domainNameInfo); }
};
template<typename X> struct adapt<IVpnDomainNameInfoFactory, X> : Windows::Networking::Vpn::IVpnDomainNameInfoFactory_adaptor<X> { typedef adapt IVpnDomainNameInfoFactory; };
template<typename X> struct IVpnDomainNameInfoFactory_unadaptor : X {
	STDMETHODIMP _CreateVpnDomainNameInfo(HSTRING name, VpnDomainNameType nameType, Foundation::Collections::IIterable<HostName*>* dnsServerList, Foundation::Collections::IIterable<HostName*>* proxyServerList, VpnDomainNameInfo* *domainNameInfo) { return hrtry([&, this] { *domainNameInfo = to_abi(X::get()->CreateVpnDomainNameInfo(name, nameType, dnsServerList, proxyServerList)); }); }
};
template<typename X> struct unadapt<IVpnDomainNameInfoFactory, X> : Windows::Networking::Vpn::IVpnDomainNameInfoFactory_unadaptor<X> {};
struct IVpnDomainNameInfoFactory : IVpnDomainNameInfoFactory_raw, generate<IVpnDomainNameInfoFactory> {};

// IVpnDomainNameInfo2
struct IVpnDomainNameInfo2_raw : IInspectable {
	virtual STDMETHODIMP _get_WebProxyUris(Foundation::Collections::IVector<Foundation::Uri*>* *value);
};
template<typename X> struct IVpnDomainNameInfo2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> get() { Foundation::Collections::IVector<Foundation::Uri*>* value; hrcheck(enc(&IVpnDomainNameInfo2_adaptor::WebProxyUris)->_get_WebProxyUris(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> operator->() { return get(); }
		} WebProxyUris;
	};
	IVpnDomainNameInfo2_adaptor() {}
};
template<typename X> struct adapt<IVpnDomainNameInfo2, X> : Windows::Networking::Vpn::IVpnDomainNameInfo2_adaptor<X> { typedef adapt IVpnDomainNameInfo2; };
struct IVpnDomainNameInfo2 : IVpnDomainNameInfo2_raw, generate<IVpnDomainNameInfo2> {};

// IVpnDomainNameInfo
struct IVpnDomainNameInfo_raw : IInspectable {
	virtual STDMETHODIMP _put_DomainName(HostName* value);
	virtual STDMETHODIMP _get_DomainName(HostName* *value);
	virtual STDMETHODIMP _put_DomainNameType(VpnDomainNameType value);
	virtual STDMETHODIMP _get_DomainNameType(VpnDomainNameType *value);
	virtual STDMETHODIMP _get_DnsServers(Foundation::Collections::IVector<HostName*>* *value);
	virtual STDMETHODIMP _get_WebProxyServers(Foundation::Collections::IVector<HostName*>* *value);
};
template<typename X> struct IVpnDomainNameInfo_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<HostName>>> get() { Foundation::Collections::IVector<HostName*>* value; hrcheck(enc(&IVpnDomainNameInfo_adaptor::DnsServers)->_get_DnsServers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<HostName>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<HostName>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<HostName>>> operator->() { return get(); }
		} DnsServers;
		struct : property {
			ptr<HostName> get() { HostName* value; hrcheck(enc(&IVpnDomainNameInfo_adaptor::DomainName)->_get_DomainName(&value)); return from_abi(value); }
			ptr<HostName> operator()() { return get(); }
			operator ptr<HostName> () { return get(); }
			ptr<HostName> operator->() { return get(); }
			void put(pptr<HostName> value) { hrcheck(enc(&IVpnDomainNameInfo_adaptor::DomainName)->_put_DomainName(value)); }
			void operator=(pptr<HostName> value) { put(value); }
			void operator()(pptr<HostName> value) { put(value); }
		} DomainName;
		struct : property {
			VpnDomainNameType get() { VpnDomainNameType value; hrcheck(enc(&IVpnDomainNameInfo_adaptor::DomainNameType)->_get_DomainNameType(&value)); return value; }
			VpnDomainNameType operator()() { return get(); }
			operator VpnDomainNameType () { return get(); }
			void put(VpnDomainNameType value) { hrcheck(enc(&IVpnDomainNameInfo_adaptor::DomainNameType)->_put_DomainNameType(value)); }
			void operator=(VpnDomainNameType value) { put(value); }
			void operator()(VpnDomainNameType value) { put(value); }
		} DomainNameType;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<HostName>>> get() { Foundation::Collections::IVector<HostName*>* value; hrcheck(enc(&IVpnDomainNameInfo_adaptor::WebProxyServers)->_get_WebProxyServers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<HostName>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<HostName>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<HostName>>> operator->() { return get(); }
		} WebProxyServers;
	};
	IVpnDomainNameInfo_adaptor() {}
};
template<typename X> struct adapt<IVpnDomainNameInfo, X> : Windows::Networking::Vpn::IVpnDomainNameInfo_adaptor<X> { typedef adapt IVpnDomainNameInfo; };
struct IVpnDomainNameInfo : IVpnDomainNameInfo_raw, generate<IVpnDomainNameInfo> {};

// VpnDomainNameInfo
template<typename> struct VpnDomainNameInfo_statics {
	static VpnDomainNameInfo *activate(hstring_ref name, VpnDomainNameType nameType, pptr<Foundation::Collections::IIterable<ptr<HostName>>> dnsServerList, pptr<Foundation::Collections::IIterable<ptr<HostName>>> proxyServerList) { VpnDomainNameInfo *domainNameInfo; hrcheck(get_activation_factory<VpnDomainNameInfo, IVpnDomainNameInfoFactory>()->_CreateVpnDomainNameInfo(name, nameType, to_abi(dnsServerList), to_abi(proxyServerList), &domainNameInfo)); return domainNameInfo; }
};

template<typename X> struct statics<VpnDomainNameInfo, X> : X, Windows::Networking::Vpn::VpnDomainNameInfo_statics<void> {
	using Windows::Networking::Vpn::VpnDomainNameInfo_statics<void>::activate;
	typedef typename X::root_type VpnDomainNameInfo;
};
struct VpnDomainNameInfo : generate<VpnDomainNameInfo> {};

// IVpnTrafficFilterFactory
struct IVpnTrafficFilterFactory : IInspectable {
	virtual STDMETHODIMP _Create(VpnAppId* appId, VpnTrafficFilter* *result);
};

// IVpnTrafficFilter
struct IVpnTrafficFilter_raw : IInspectable {
	virtual STDMETHODIMP _get_AppId(VpnAppId* *value);
	virtual STDMETHODIMP _put_AppId(VpnAppId* value);
	virtual STDMETHODIMP _get_AppClaims(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_Protocol(VpnIPProtocol *value);
	virtual STDMETHODIMP _put_Protocol(VpnIPProtocol value);
	virtual STDMETHODIMP _get_LocalPortRanges(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_RemotePortRanges(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_LocalAddressRanges(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_RemoteAddressRanges(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_RoutingPolicyType(VpnRoutingPolicyType *value);
	virtual STDMETHODIMP _put_RoutingPolicyType(VpnRoutingPolicyType value);
};
template<typename X> struct IVpnTrafficFilter_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IVpnTrafficFilter_adaptor::AppClaims)->_get_AppClaims(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} AppClaims;
		struct : property {
			ptr<VpnAppId> get() { VpnAppId* value; hrcheck(enc(&IVpnTrafficFilter_adaptor::AppId)->_get_AppId(&value)); return from_abi(value); }
			ptr<VpnAppId> operator()() { return get(); }
			operator ptr<VpnAppId> () { return get(); }
			ptr<VpnAppId> operator->() { return get(); }
			void put(pptr<VpnAppId> value) { hrcheck(enc(&IVpnTrafficFilter_adaptor::AppId)->_put_AppId(value)); }
			void operator=(pptr<VpnAppId> value) { put(value); }
			void operator()(pptr<VpnAppId> value) { put(value); }
		} AppId;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IVpnTrafficFilter_adaptor::LocalAddressRanges)->_get_LocalAddressRanges(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} LocalAddressRanges;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IVpnTrafficFilter_adaptor::LocalPortRanges)->_get_LocalPortRanges(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} LocalPortRanges;
		struct : property {
			VpnIPProtocol get() { VpnIPProtocol value; hrcheck(enc(&IVpnTrafficFilter_adaptor::Protocol)->_get_Protocol(&value)); return value; }
			VpnIPProtocol operator()() { return get(); }
			operator VpnIPProtocol () { return get(); }
			void put(VpnIPProtocol value) { hrcheck(enc(&IVpnTrafficFilter_adaptor::Protocol)->_put_Protocol(value)); }
			void operator=(VpnIPProtocol value) { put(value); }
			void operator()(VpnIPProtocol value) { put(value); }
		} Protocol;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IVpnTrafficFilter_adaptor::RemoteAddressRanges)->_get_RemoteAddressRanges(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} RemoteAddressRanges;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IVpnTrafficFilter_adaptor::RemotePortRanges)->_get_RemotePortRanges(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} RemotePortRanges;
		struct : property {
			VpnRoutingPolicyType get() { VpnRoutingPolicyType value; hrcheck(enc(&IVpnTrafficFilter_adaptor::RoutingPolicyType)->_get_RoutingPolicyType(&value)); return value; }
			VpnRoutingPolicyType operator()() { return get(); }
			operator VpnRoutingPolicyType () { return get(); }
			void put(VpnRoutingPolicyType value) { hrcheck(enc(&IVpnTrafficFilter_adaptor::RoutingPolicyType)->_put_RoutingPolicyType(value)); }
			void operator=(VpnRoutingPolicyType value) { put(value); }
			void operator()(VpnRoutingPolicyType value) { put(value); }
		} RoutingPolicyType;
	};
	IVpnTrafficFilter_adaptor() {}
};
template<typename X> struct adapt<IVpnTrafficFilter, X> : Windows::Networking::Vpn::IVpnTrafficFilter_adaptor<X> { typedef adapt IVpnTrafficFilter; };
struct IVpnTrafficFilter : IVpnTrafficFilter_raw, generate<IVpnTrafficFilter> {};

// VpnTrafficFilter
template<typename> struct VpnTrafficFilter_statics {
	static VpnTrafficFilter *activate(pptr<VpnAppId> appId) { VpnTrafficFilter *result; hrcheck(get_activation_factory<VpnTrafficFilter, IVpnTrafficFilterFactory>()->_Create(appId, &result)); return result; }
};

template<typename X> struct statics<VpnTrafficFilter, X> : X, Windows::Networking::Vpn::VpnTrafficFilter_statics<void> {
	using Windows::Networking::Vpn::VpnTrafficFilter_statics<void>::activate;
	typedef typename X::root_type VpnTrafficFilter;
};
struct VpnTrafficFilter : generate<VpnTrafficFilter> {};

// IVpnProfile
struct IVpnProfile_raw : IInspectable {
	virtual STDMETHODIMP _get_ProfileName(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_ProfileName(HSTRING value) = 0;
	virtual STDMETHODIMP _get_AppTriggers(Foundation::Collections::IVector<VpnAppId*>* *value) = 0;
	virtual STDMETHODIMP _get_Routes(Foundation::Collections::IVector<VpnRoute*>* *value) = 0;
	virtual STDMETHODIMP _get_DomainNameInfoList(Foundation::Collections::IVector<VpnDomainNameInfo*>* *value) = 0;
	virtual STDMETHODIMP _get_TrafficFilters(Foundation::Collections::IVector<VpnTrafficFilter*>* *value) = 0;
	virtual STDMETHODIMP _get_RememberCredentials(bool *value) = 0;
	virtual STDMETHODIMP _put_RememberCredentials(bool value) = 0;
	virtual STDMETHODIMP _get_AlwaysOn(bool *value) = 0;
	virtual STDMETHODIMP _put_AlwaysOn(bool value) = 0;
};
template<typename X> struct IVpnProfile_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnProfile_adaptor::AlwaysOn)->_get_AlwaysOn(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVpnProfile_adaptor::AlwaysOn)->_put_AlwaysOn(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AlwaysOn;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<VpnAppId>>> get() { Foundation::Collections::IVector<VpnAppId*>* value; hrcheck(enc(&IVpnProfile_adaptor::AppTriggers)->_get_AppTriggers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<VpnAppId>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<VpnAppId>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<VpnAppId>>> operator->() { return get(); }
		} AppTriggers;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<VpnDomainNameInfo>>> get() { Foundation::Collections::IVector<VpnDomainNameInfo*>* value; hrcheck(enc(&IVpnProfile_adaptor::DomainNameInfoList)->_get_DomainNameInfoList(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<VpnDomainNameInfo>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<VpnDomainNameInfo>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<VpnDomainNameInfo>>> operator->() { return get(); }
		} DomainNameInfoList;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnProfile_adaptor::ProfileName)->_get_ProfileName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVpnProfile_adaptor::ProfileName)->_put_ProfileName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ProfileName;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnProfile_adaptor::RememberCredentials)->_get_RememberCredentials(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVpnProfile_adaptor::RememberCredentials)->_put_RememberCredentials(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} RememberCredentials;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> get() { Foundation::Collections::IVector<VpnRoute*>* value; hrcheck(enc(&IVpnProfile_adaptor::Routes)->_get_Routes(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<VpnRoute>>> operator->() { return get(); }
		} Routes;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<VpnTrafficFilter>>> get() { Foundation::Collections::IVector<VpnTrafficFilter*>* value; hrcheck(enc(&IVpnProfile_adaptor::TrafficFilters)->_get_TrafficFilters(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<VpnTrafficFilter>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<VpnTrafficFilter>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<VpnTrafficFilter>>> operator->() { return get(); }
		} TrafficFilters;
	};
	IVpnProfile_adaptor() {}
};
template<typename X> struct adapt<IVpnProfile, X> : Windows::Networking::Vpn::IVpnProfile_adaptor<X> { typedef adapt IVpnProfile; };
template<typename X> struct IVpnProfile_unadaptor : X {
	STDMETHODIMP _get_ProfileName(HSTRING *value) { return hrtry([&, this] { get_prop(value, ProfileName); }); }
	STDMETHODIMP _put_ProfileName(HSTRING value) { return hrtry([&, this] { put_prop(value, ProfileName); }); }
	STDMETHODIMP _get_AppTriggers(Foundation::Collections::IVector<VpnAppId*>* *value) { return hrtry([&, this] { get_prop(value, AppTriggers); }); }
	STDMETHODIMP _get_Routes(Foundation::Collections::IVector<VpnRoute*>* *value) { return hrtry([&, this] { get_prop(value, Routes); }); }
	STDMETHODIMP _get_DomainNameInfoList(Foundation::Collections::IVector<VpnDomainNameInfo*>* *value) { return hrtry([&, this] { get_prop(value, DomainNameInfoList); }); }
	STDMETHODIMP _get_TrafficFilters(Foundation::Collections::IVector<VpnTrafficFilter*>* *value) { return hrtry([&, this] { get_prop(value, TrafficFilters); }); }
	STDMETHODIMP _get_RememberCredentials(bool *value) { return hrtry([&, this] { get_prop(value, RememberCredentials); }); }
	STDMETHODIMP _put_RememberCredentials(bool value) { return hrtry([&, this] { put_prop(value, RememberCredentials); }); }
	STDMETHODIMP _get_AlwaysOn(bool *value) { return hrtry([&, this] { get_prop(value, AlwaysOn); }); }
	STDMETHODIMP _put_AlwaysOn(bool value) { return hrtry([&, this] { put_prop(value, AlwaysOn); }); }
};
template<typename X> struct unadapt<IVpnProfile, X> : Windows::Networking::Vpn::IVpnProfile_unadaptor<X> {};
struct IVpnProfile : IVpnProfile_raw, generate<IVpnProfile> {};

// IVpnPlugInProfile
struct IVpnPlugInProfile_raw : IInspectable {
	virtual STDMETHODIMP _get_ServerUris(Foundation::Collections::IVector<Foundation::Uri*>* *value);
	virtual STDMETHODIMP _get_CustomConfiguration(HSTRING *value);
	virtual STDMETHODIMP _put_CustomConfiguration(HSTRING value);
	virtual STDMETHODIMP _get_VpnPluginPackageFamilyName(HSTRING *value);
	virtual STDMETHODIMP _put_VpnPluginPackageFamilyName(HSTRING value);
};
template<typename X> struct IVpnPlugInProfile_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnPlugInProfile_adaptor::CustomConfiguration)->_get_CustomConfiguration(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVpnPlugInProfile_adaptor::CustomConfiguration)->_put_CustomConfiguration(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} CustomConfiguration;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> get() { Foundation::Collections::IVector<Foundation::Uri*>* value; hrcheck(enc(&IVpnPlugInProfile_adaptor::ServerUris)->_get_ServerUris(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> operator->() { return get(); }
		} ServerUris;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVpnPlugInProfile_adaptor::VpnPluginPackageFamilyName)->_get_VpnPluginPackageFamilyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVpnPlugInProfile_adaptor::VpnPluginPackageFamilyName)->_put_VpnPluginPackageFamilyName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} VpnPluginPackageFamilyName;
	};
	IVpnPlugInProfile_adaptor() {}
};
template<typename X> struct adapt<IVpnPlugInProfile, X> : Windows::Networking::Vpn::IVpnPlugInProfile_adaptor<X> { typedef adapt IVpnPlugInProfile; };
struct IVpnPlugInProfile : IVpnPlugInProfile_raw, generate<IVpnPlugInProfile> {};

// IVpnPlugInProfile2
struct IVpnPlugInProfile2_raw : IInspectable {
	virtual STDMETHODIMP _get_RequireVpnClientAppUI(bool *value);
	virtual STDMETHODIMP _put_RequireVpnClientAppUI(bool value);
	virtual STDMETHODIMP _get_ConnectionStatus(VpnManagementConnectionStatus *value);
};
template<typename X> struct IVpnPlugInProfile2_adaptor : X {
	union {
		struct : property {
			VpnManagementConnectionStatus get() { VpnManagementConnectionStatus value; hrcheck(enc(&IVpnPlugInProfile2_adaptor::ConnectionStatus)->_get_ConnectionStatus(&value)); return value; }
			VpnManagementConnectionStatus operator()() { return get(); }
			operator VpnManagementConnectionStatus () { return get(); }
		} ConnectionStatus;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnPlugInProfile2_adaptor::RequireVpnClientAppUI)->_get_RequireVpnClientAppUI(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVpnPlugInProfile2_adaptor::RequireVpnClientAppUI)->_put_RequireVpnClientAppUI(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} RequireVpnClientAppUI;
	};
	IVpnPlugInProfile2_adaptor() {}
};
template<typename X> struct adapt<IVpnPlugInProfile2, X> : Windows::Networking::Vpn::IVpnPlugInProfile2_adaptor<X> { typedef adapt IVpnPlugInProfile2; };
struct IVpnPlugInProfile2 : IVpnPlugInProfile2_raw, generate<IVpnPlugInProfile2> {};

// IVpnNativeProfile
struct IVpnNativeProfile_raw : IInspectable {
	virtual STDMETHODIMP _get_Servers(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_RoutingPolicyType(VpnRoutingPolicyType *value);
	virtual STDMETHODIMP _put_RoutingPolicyType(VpnRoutingPolicyType value);
	virtual STDMETHODIMP _get_NativeProtocolType(VpnNativeProtocolType *value);
	virtual STDMETHODIMP _put_NativeProtocolType(VpnNativeProtocolType value);
	virtual STDMETHODIMP _get_UserAuthenticationMethod(VpnAuthenticationMethod *value);
	virtual STDMETHODIMP _put_UserAuthenticationMethod(VpnAuthenticationMethod value);
	virtual STDMETHODIMP _get_TunnelAuthenticationMethod(VpnAuthenticationMethod *value);
	virtual STDMETHODIMP _put_TunnelAuthenticationMethod(VpnAuthenticationMethod value);
	virtual STDMETHODIMP _get_EapConfiguration(HSTRING *Value);
	virtual STDMETHODIMP _put_EapConfiguration(HSTRING value);
};
template<typename X> struct IVpnNativeProfile_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING Value; hrcheck(enc(&IVpnNativeProfile_adaptor::EapConfiguration)->_get_EapConfiguration(&Value)); return from_abi(Value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IVpnNativeProfile_adaptor::EapConfiguration)->_put_EapConfiguration(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} EapConfiguration;
		struct : property {
			VpnNativeProtocolType get() { VpnNativeProtocolType value; hrcheck(enc(&IVpnNativeProfile_adaptor::NativeProtocolType)->_get_NativeProtocolType(&value)); return value; }
			VpnNativeProtocolType operator()() { return get(); }
			operator VpnNativeProtocolType () { return get(); }
			void put(VpnNativeProtocolType value) { hrcheck(enc(&IVpnNativeProfile_adaptor::NativeProtocolType)->_put_NativeProtocolType(value)); }
			void operator=(VpnNativeProtocolType value) { put(value); }
			void operator()(VpnNativeProtocolType value) { put(value); }
		} NativeProtocolType;
		struct : property {
			VpnRoutingPolicyType get() { VpnRoutingPolicyType value; hrcheck(enc(&IVpnNativeProfile_adaptor::RoutingPolicyType)->_get_RoutingPolicyType(&value)); return value; }
			VpnRoutingPolicyType operator()() { return get(); }
			operator VpnRoutingPolicyType () { return get(); }
			void put(VpnRoutingPolicyType value) { hrcheck(enc(&IVpnNativeProfile_adaptor::RoutingPolicyType)->_put_RoutingPolicyType(value)); }
			void operator=(VpnRoutingPolicyType value) { put(value); }
			void operator()(VpnRoutingPolicyType value) { put(value); }
		} RoutingPolicyType;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IVpnNativeProfile_adaptor::Servers)->_get_Servers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} Servers;
		struct : property {
			VpnAuthenticationMethod get() { VpnAuthenticationMethod value; hrcheck(enc(&IVpnNativeProfile_adaptor::TunnelAuthenticationMethod)->_get_TunnelAuthenticationMethod(&value)); return value; }
			VpnAuthenticationMethod operator()() { return get(); }
			operator VpnAuthenticationMethod () { return get(); }
			void put(VpnAuthenticationMethod value) { hrcheck(enc(&IVpnNativeProfile_adaptor::TunnelAuthenticationMethod)->_put_TunnelAuthenticationMethod(value)); }
			void operator=(VpnAuthenticationMethod value) { put(value); }
			void operator()(VpnAuthenticationMethod value) { put(value); }
		} TunnelAuthenticationMethod;
		struct : property {
			VpnAuthenticationMethod get() { VpnAuthenticationMethod value; hrcheck(enc(&IVpnNativeProfile_adaptor::UserAuthenticationMethod)->_get_UserAuthenticationMethod(&value)); return value; }
			VpnAuthenticationMethod operator()() { return get(); }
			operator VpnAuthenticationMethod () { return get(); }
			void put(VpnAuthenticationMethod value) { hrcheck(enc(&IVpnNativeProfile_adaptor::UserAuthenticationMethod)->_put_UserAuthenticationMethod(value)); }
			void operator=(VpnAuthenticationMethod value) { put(value); }
			void operator()(VpnAuthenticationMethod value) { put(value); }
		} UserAuthenticationMethod;
	};
	IVpnNativeProfile_adaptor() {}
};
template<typename X> struct adapt<IVpnNativeProfile, X> : Windows::Networking::Vpn::IVpnNativeProfile_adaptor<X> { typedef adapt IVpnNativeProfile; };
struct IVpnNativeProfile : IVpnNativeProfile_raw, generate<IVpnNativeProfile> {};

// IVpnNativeProfile2
struct IVpnNativeProfile2_raw : IInspectable {
	virtual STDMETHODIMP _get_RequireVpnClientAppUI(bool *value);
	virtual STDMETHODIMP _put_RequireVpnClientAppUI(bool value);
	virtual STDMETHODIMP _get_ConnectionStatus(VpnManagementConnectionStatus *value);
};
template<typename X> struct IVpnNativeProfile2_adaptor : X {
	union {
		struct : property {
			VpnManagementConnectionStatus get() { VpnManagementConnectionStatus value; hrcheck(enc(&IVpnNativeProfile2_adaptor::ConnectionStatus)->_get_ConnectionStatus(&value)); return value; }
			VpnManagementConnectionStatus operator()() { return get(); }
			operator VpnManagementConnectionStatus () { return get(); }
		} ConnectionStatus;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVpnNativeProfile2_adaptor::RequireVpnClientAppUI)->_get_RequireVpnClientAppUI(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVpnNativeProfile2_adaptor::RequireVpnClientAppUI)->_put_RequireVpnClientAppUI(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} RequireVpnClientAppUI;
	};
	IVpnNativeProfile2_adaptor() {}
};
template<typename X> struct adapt<IVpnNativeProfile2, X> : Windows::Networking::Vpn::IVpnNativeProfile2_adaptor<X> { typedef adapt IVpnNativeProfile2; };
struct IVpnNativeProfile2 : IVpnNativeProfile2_raw, generate<IVpnNativeProfile2> {};

// IVpnManagementAgent
struct IVpnManagementAgent_raw : IInspectable {
	virtual STDMETHODIMP _AddProfileFromXmlAsync(HSTRING xml, Foundation::IAsyncOperation<VpnManagementErrorStatus>* *operation);
	virtual STDMETHODIMP _AddProfileFromObjectAsync(IVpnProfile* profile, Foundation::IAsyncOperation<VpnManagementErrorStatus>* *operation);
	virtual STDMETHODIMP _UpdateProfileFromXmlAsync(HSTRING xml, Foundation::IAsyncOperation<VpnManagementErrorStatus>* *operation);
	virtual STDMETHODIMP _UpdateProfileFromObjectAsync(IVpnProfile* profile, Foundation::IAsyncOperation<VpnManagementErrorStatus>* *operation);
	virtual STDMETHODIMP _GetProfilesAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IVpnProfile*>*>* *operation);
	virtual STDMETHODIMP _DeleteProfileAsync(IVpnProfile* profile, Foundation::IAsyncOperation<VpnManagementErrorStatus>* *operation);
	virtual STDMETHODIMP _ConnectProfileAsync(IVpnProfile* profile, Foundation::IAsyncOperation<VpnManagementErrorStatus>* *operation);
	virtual STDMETHODIMP _ConnectProfileWithPasswordCredentialAsync(IVpnProfile* profile, Security::Credentials::PasswordCredential* passwordCredential, Foundation::IAsyncOperation<VpnManagementErrorStatus>* *operation);
	virtual STDMETHODIMP _DisconnectProfileAsync(IVpnProfile* profile, Foundation::IAsyncOperation<VpnManagementErrorStatus>* *operation);
};
template<typename X> struct IVpnManagementAgent_adaptor : X {
	ptr<Foundation::IAsyncOperation<VpnManagementErrorStatus>> AddProfileFromXmlAsync(hstring_ref xml) { Foundation::IAsyncOperation<VpnManagementErrorStatus>* operation; hrcheck(X::get()->_AddProfileFromXmlAsync(xml, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<VpnManagementErrorStatus>> AddProfileFromObjectAsync(pptr<IVpnProfile> profile) { Foundation::IAsyncOperation<VpnManagementErrorStatus>* operation; hrcheck(X::get()->_AddProfileFromObjectAsync(profile, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<VpnManagementErrorStatus>> UpdateProfileFromXmlAsync(hstring_ref xml) { Foundation::IAsyncOperation<VpnManagementErrorStatus>* operation; hrcheck(X::get()->_UpdateProfileFromXmlAsync(xml, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<VpnManagementErrorStatus>> UpdateProfileFromObjectAsync(pptr<IVpnProfile> profile) { Foundation::IAsyncOperation<VpnManagementErrorStatus>* operation; hrcheck(X::get()->_UpdateProfileFromObjectAsync(profile, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<IVpnProfile>>>>> GetProfilesAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IVpnProfile*>*>* operation; hrcheck(X::get()->_GetProfilesAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<VpnManagementErrorStatus>> DeleteProfileAsync(pptr<IVpnProfile> profile) { Foundation::IAsyncOperation<VpnManagementErrorStatus>* operation; hrcheck(X::get()->_DeleteProfileAsync(profile, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<VpnManagementErrorStatus>> ConnectProfileAsync(pptr<IVpnProfile> profile) { Foundation::IAsyncOperation<VpnManagementErrorStatus>* operation; hrcheck(X::get()->_ConnectProfileAsync(profile, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<VpnManagementErrorStatus>> ConnectProfileWithPasswordCredentialAsync(pptr<IVpnProfile> profile, pptr<Security::Credentials::PasswordCredential> passwordCredential) { Foundation::IAsyncOperation<VpnManagementErrorStatus>* operation; hrcheck(X::get()->_ConnectProfileWithPasswordCredentialAsync(profile, passwordCredential, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<VpnManagementErrorStatus>> DisconnectProfileAsync(pptr<IVpnProfile> profile) { Foundation::IAsyncOperation<VpnManagementErrorStatus>* operation; hrcheck(X::get()->_DisconnectProfileAsync(profile, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IVpnManagementAgent, X> : Windows::Networking::Vpn::IVpnManagementAgent_adaptor<X> { typedef adapt IVpnManagementAgent; };
struct IVpnManagementAgent : IVpnManagementAgent_raw, generate<IVpnManagementAgent> {};

// VpnPacketBufferList
template<typename X> struct statics<VpnPacketBufferList, X> : X {
	typedef typename X::root_type VpnPacketBufferList;
};
struct VpnPacketBufferList : generate<VpnPacketBufferList> {};

// VpnCustomEditBox
template<typename X> struct statics<VpnCustomEditBox, X> : X {
	typedef typename X::root_type VpnCustomEditBox;
};
struct VpnCustomEditBox : generate<VpnCustomEditBox> {};

// VpnCustomPromptTextInput
template<typename X> struct statics<VpnCustomPromptTextInput, X> : X {
	typedef typename X::root_type VpnCustomPromptTextInput;
};
struct VpnCustomPromptTextInput : generate<VpnCustomPromptTextInput> {};

// VpnCustomComboBox
template<typename X> struct statics<VpnCustomComboBox, X> : X {
	typedef typename X::root_type VpnCustomComboBox;
};
struct VpnCustomComboBox : generate<VpnCustomComboBox> {};

// VpnCustomPromptOptionSelector
template<typename X> struct statics<VpnCustomPromptOptionSelector, X> : X {
	typedef typename X::root_type VpnCustomPromptOptionSelector;
};
struct VpnCustomPromptOptionSelector : generate<VpnCustomPromptOptionSelector> {};

// VpnCustomTextBox
template<typename X> struct statics<VpnCustomTextBox, X> : X {
	typedef typename X::root_type VpnCustomTextBox;
};
struct VpnCustomTextBox : generate<VpnCustomTextBox> {};

// VpnCustomPromptText
template<typename X> struct statics<VpnCustomPromptText, X> : X {
	typedef typename X::root_type VpnCustomPromptText;
};
struct VpnCustomPromptText : generate<VpnCustomPromptText> {};

// VpnCustomCheckBox
template<typename X> struct statics<VpnCustomCheckBox, X> : X {
	typedef typename X::root_type VpnCustomCheckBox;
};
struct VpnCustomCheckBox : generate<VpnCustomCheckBox> {};

// VpnCustomPromptBooleanInput
template<typename X> struct statics<VpnCustomPromptBooleanInput, X> : X {
	typedef typename X::root_type VpnCustomPromptBooleanInput;
};
struct VpnCustomPromptBooleanInput : generate<VpnCustomPromptBooleanInput> {};

// VpnCustomErrorBox
template<typename X> struct statics<VpnCustomErrorBox, X> : X {
	typedef typename X::root_type VpnCustomErrorBox;
};
struct VpnCustomErrorBox : generate<VpnCustomErrorBox> {};

// VpnPlugInProfile
template<typename X> struct statics<VpnPlugInProfile, X> : X {
	typedef typename X::root_type VpnPlugInProfile;
};
struct VpnPlugInProfile : generate<VpnPlugInProfile> {};

// VpnNativeProfile
template<typename X> struct statics<VpnNativeProfile, X> : X {
	typedef typename X::root_type VpnNativeProfile;
};
struct VpnNativeProfile : generate<VpnNativeProfile> {};

// VpnManagementAgent
template<typename X> struct statics<VpnManagementAgent, X> : X {
	typedef typename X::root_type VpnManagementAgent;
};
struct VpnManagementAgent : generate<VpnManagementAgent> {};
}}}
} // namespace iso_winrt
