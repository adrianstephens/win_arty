#pragma once
// generated by isopod tools
// namespaces:
// Windows.Media.FaceAnalysis

#include "Windows.Media.FaceAnalysis.0.h"
#include "Windows.Graphics.Imaging.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IVectorView;
template<typename T> struct IVector;
}
template<typename TResult> struct IAsyncOperation;
}
namespace Media {
struct VideoFrame;
}}

// defs

template<> struct def<Windows::Media::FaceAnalysis::IFaceDetector> : interface_type<> {};
template<> struct def<Windows::Media::FaceAnalysis::IDetectedFace> : interface_type<> {};
template<> struct def<Windows::Media::FaceAnalysis::DetectedFace> : class_type<Platform::Object, Windows::Media::FaceAnalysis::IDetectedFace> {};
template<> struct def<Windows::Media::FaceAnalysis::IFaceTrackerStatics> : interface_type<> {};
template<> struct def<Windows::Media::FaceAnalysis::IFaceTracker> : interface_type<> {};
template<> struct def<Windows::Media::FaceAnalysis::FaceTracker> : class_type<Platform::Object, Windows::Media::FaceAnalysis::IFaceTracker> {};
template<> struct def<Windows::Media::FaceAnalysis::IFaceDetectorStatics> : interface_type<> {};
template<> struct def<Windows::Media::FaceAnalysis::FaceDetector> : class_type<Platform::Object, Windows::Media::FaceAnalysis::IFaceDetector> {};

// uuids

template<> struct uuid<Windows::Media::FaceAnalysis::IFaceDetector> { define_guid(0x16B672DC, 0xFE6F, 0x3117, 0x8D, 0x95, 0xC3, 0xF0, 0x4D, 0x51, 0x63, 0xC);};
template<> struct uuid<Windows::Media::FaceAnalysis::IDetectedFace> { define_guid(0x8200D454, 0x66BC, 0x34DF, 0x94, 0x10, 0xE8, 0x94, 0x0, 0x19, 0x54, 0x14);};
template<> struct uuid<Windows::Media::FaceAnalysis::IFaceTrackerStatics> { define_guid(0xE9629198, 0x1801, 0x3FA5, 0x93, 0x2E, 0x31, 0xD7, 0x67, 0xAF, 0x6C, 0x4D);};
template<> struct uuid<Windows::Media::FaceAnalysis::IFaceTracker> { define_guid(0x6BA67D8C, 0xA841, 0x4420, 0x93, 0xE6, 0x24, 0x20, 0xA1, 0x88, 0x4F, 0xCF);};
template<> struct uuid<Windows::Media::FaceAnalysis::IFaceDetectorStatics> { define_guid(0xBC042D67, 0x9047, 0x33F6, 0x88, 0x1B, 0x67, 0x46, 0xC1, 0xB2, 0x18, 0xB8);};

// types

namespace Windows { namespace Media { namespace FaceAnalysis {

// IFaceDetector
struct IFaceDetector_raw : IInspectable {
	virtual STDMETHODIMP _DetectFacesAsync(Graphics::Imaging::SoftwareBitmap* image, Foundation::IAsyncOperation<Foundation::Collections::IVector<DetectedFace*>*>* *returnValue);
	virtual STDMETHODIMP _DetectFacesWithSearchAreaAsync(Graphics::Imaging::SoftwareBitmap* image, Graphics::Imaging::BitmapBounds searchArea, Foundation::IAsyncOperation<Foundation::Collections::IVector<DetectedFace*>*>* *returnValue);
	virtual STDMETHODIMP _get_MinDetectableFaceSize(Graphics::Imaging::BitmapSize *returnValue);
	virtual STDMETHODIMP _put_MinDetectableFaceSize(Graphics::Imaging::BitmapSize value);
	virtual STDMETHODIMP _get_MaxDetectableFaceSize(Graphics::Imaging::BitmapSize *returnValue);
	virtual STDMETHODIMP _put_MaxDetectableFaceSize(Graphics::Imaging::BitmapSize value);
};
template<typename X> struct IFaceDetector_adaptor : X {
	union {
		struct : property {
			Graphics::Imaging::BitmapSize get() { Graphics::Imaging::BitmapSize returnValue; hrcheck(enc(&IFaceDetector_adaptor::MaxDetectableFaceSize)->_get_MaxDetectableFaceSize(&returnValue)); return returnValue; }
			Graphics::Imaging::BitmapSize operator()() { return get(); }
			operator Graphics::Imaging::BitmapSize () { return get(); }
			void put(const Graphics::Imaging::BitmapSize& value) { hrcheck(enc(&IFaceDetector_adaptor::MaxDetectableFaceSize)->_put_MaxDetectableFaceSize(value)); }
			void operator=(const Graphics::Imaging::BitmapSize& value) { put(value); }
			void operator()(const Graphics::Imaging::BitmapSize& value) { put(value); }
		} MaxDetectableFaceSize;
		struct : property {
			Graphics::Imaging::BitmapSize get() { Graphics::Imaging::BitmapSize returnValue; hrcheck(enc(&IFaceDetector_adaptor::MinDetectableFaceSize)->_get_MinDetectableFaceSize(&returnValue)); return returnValue; }
			Graphics::Imaging::BitmapSize operator()() { return get(); }
			operator Graphics::Imaging::BitmapSize () { return get(); }
			void put(const Graphics::Imaging::BitmapSize& value) { hrcheck(enc(&IFaceDetector_adaptor::MinDetectableFaceSize)->_put_MinDetectableFaceSize(value)); }
			void operator=(const Graphics::Imaging::BitmapSize& value) { put(value); }
			void operator()(const Graphics::Imaging::BitmapSize& value) { put(value); }
		} MinDetectableFaceSize;
	};
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVector<ptr<DetectedFace>>>>> DetectFacesAsync(pptr<Graphics::Imaging::SoftwareBitmap> image) { Foundation::IAsyncOperation<Foundation::Collections::IVector<DetectedFace*>*>* returnValue; hrcheck(X::get()->_DetectFacesAsync(image, &returnValue)); return from_abi(returnValue); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVector<ptr<DetectedFace>>>>> DetectFacesAsync(pptr<Graphics::Imaging::SoftwareBitmap> image, const Graphics::Imaging::BitmapBounds& searchArea) { Foundation::IAsyncOperation<Foundation::Collections::IVector<DetectedFace*>*>* returnValue; hrcheck(X::get()->_DetectFacesWithSearchAreaAsync(image, searchArea, &returnValue)); return from_abi(returnValue); }
	IFaceDetector_adaptor() {}
};
template<typename X> struct adapt<IFaceDetector, X> : Windows::Media::FaceAnalysis::IFaceDetector_adaptor<X> { typedef adapt IFaceDetector; };
struct IFaceDetector : IFaceDetector_raw, generate<IFaceDetector> {};

// IDetectedFace
struct IDetectedFace_raw : IInspectable {
	virtual STDMETHODIMP _get_FaceBox(Graphics::Imaging::BitmapBounds *returnValue);
};
template<typename X> struct IDetectedFace_adaptor : X {
	union {
		struct : property {
			Graphics::Imaging::BitmapBounds get() { Graphics::Imaging::BitmapBounds returnValue; hrcheck(enc(&IDetectedFace_adaptor::FaceBox)->_get_FaceBox(&returnValue)); return returnValue; }
			Graphics::Imaging::BitmapBounds operator()() { return get(); }
			operator Graphics::Imaging::BitmapBounds () { return get(); }
		} FaceBox;
	};
	IDetectedFace_adaptor() {}
};
template<typename X> struct adapt<IDetectedFace, X> : Windows::Media::FaceAnalysis::IDetectedFace_adaptor<X> { typedef adapt IDetectedFace; };
struct IDetectedFace : IDetectedFace_raw, generate<IDetectedFace> {};

// DetectedFace
template<typename X> struct statics<DetectedFace, X> : X {
	typedef typename X::root_type DetectedFace;
};
struct DetectedFace : generate<DetectedFace> {};

// IFaceTrackerStatics
struct IFaceTrackerStatics : IInspectable {
	virtual STDMETHODIMP _CreateAsync(Foundation::IAsyncOperation<FaceTracker*>* *returnValue);
	virtual STDMETHODIMP _GetSupportedBitmapPixelFormats(Foundation::Collections::IVectorView<Graphics::Imaging::BitmapPixelFormat>* *result);
	virtual STDMETHODIMP _IsBitmapPixelFormatSupported(Graphics::Imaging::BitmapPixelFormat bitmapPixelFormat, bool *result);
	virtual STDMETHODIMP _get_IsSupported(bool *returnValue);
};

// IFaceTracker
struct IFaceTracker_raw : IInspectable {
	virtual STDMETHODIMP _ProcessNextFrameAsync(VideoFrame* videoFrame, Foundation::IAsyncOperation<Foundation::Collections::IVector<DetectedFace*>*>* *returnValue);
	virtual STDMETHODIMP _get_MinDetectableFaceSize(Graphics::Imaging::BitmapSize *returnValue);
	virtual STDMETHODIMP _put_MinDetectableFaceSize(Graphics::Imaging::BitmapSize value);
	virtual STDMETHODIMP _get_MaxDetectableFaceSize(Graphics::Imaging::BitmapSize *returnValue);
	virtual STDMETHODIMP _put_MaxDetectableFaceSize(Graphics::Imaging::BitmapSize value);
};
template<typename X> struct IFaceTracker_adaptor : X {
	union {
		struct : property {
			Graphics::Imaging::BitmapSize get() { Graphics::Imaging::BitmapSize returnValue; hrcheck(enc(&IFaceTracker_adaptor::MaxDetectableFaceSize)->_get_MaxDetectableFaceSize(&returnValue)); return returnValue; }
			Graphics::Imaging::BitmapSize operator()() { return get(); }
			operator Graphics::Imaging::BitmapSize () { return get(); }
			void put(const Graphics::Imaging::BitmapSize& value) { hrcheck(enc(&IFaceTracker_adaptor::MaxDetectableFaceSize)->_put_MaxDetectableFaceSize(value)); }
			void operator=(const Graphics::Imaging::BitmapSize& value) { put(value); }
			void operator()(const Graphics::Imaging::BitmapSize& value) { put(value); }
		} MaxDetectableFaceSize;
		struct : property {
			Graphics::Imaging::BitmapSize get() { Graphics::Imaging::BitmapSize returnValue; hrcheck(enc(&IFaceTracker_adaptor::MinDetectableFaceSize)->_get_MinDetectableFaceSize(&returnValue)); return returnValue; }
			Graphics::Imaging::BitmapSize operator()() { return get(); }
			operator Graphics::Imaging::BitmapSize () { return get(); }
			void put(const Graphics::Imaging::BitmapSize& value) { hrcheck(enc(&IFaceTracker_adaptor::MinDetectableFaceSize)->_put_MinDetectableFaceSize(value)); }
			void operator=(const Graphics::Imaging::BitmapSize& value) { put(value); }
			void operator()(const Graphics::Imaging::BitmapSize& value) { put(value); }
		} MinDetectableFaceSize;
	};
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVector<ptr<DetectedFace>>>>> ProcessNextFrameAsync(pptr<VideoFrame> videoFrame) { Foundation::IAsyncOperation<Foundation::Collections::IVector<DetectedFace*>*>* returnValue; hrcheck(X::get()->_ProcessNextFrameAsync(videoFrame, &returnValue)); return from_abi(returnValue); }
	IFaceTracker_adaptor() {}
};
template<typename X> struct adapt<IFaceTracker, X> : Windows::Media::FaceAnalysis::IFaceTracker_adaptor<X> { typedef adapt IFaceTracker; };
struct IFaceTracker : IFaceTracker_raw, generate<IFaceTracker> {};

// FaceTracker
template<typename> struct FaceTracker_statics {
	static struct _IsSupported : property {
		bool get() { bool returnValue; hrcheck(get_activation_factory<FaceTracker, IFaceTrackerStatics>()->_get_IsSupported(&returnValue)); return returnValue; }
		bool operator()() { return get(); }
		operator bool () { return get(); }
	} IsSupported;
	static ptr<Foundation::IAsyncOperation<ptr<FaceTracker>>> CreateAsync() { Foundation::IAsyncOperation<FaceTracker*>* returnValue; hrcheck(get_activation_factory<FaceTracker, IFaceTrackerStatics>()->_CreateAsync(&returnValue)); return from_abi(returnValue); }
	static ptr<Foundation::Collections::IVectorView<Graphics::Imaging::BitmapPixelFormat>> GetSupportedBitmapPixelFormats() { Foundation::Collections::IVectorView<Graphics::Imaging::BitmapPixelFormat>* result; hrcheck(get_activation_factory<FaceTracker, IFaceTrackerStatics>()->_GetSupportedBitmapPixelFormats(&result)); return from_abi(result); }
	static bool IsBitmapPixelFormatSupported(Graphics::Imaging::BitmapPixelFormat bitmapPixelFormat) { bool result; hrcheck(get_activation_factory<FaceTracker, IFaceTrackerStatics>()->_IsBitmapPixelFormatSupported(bitmapPixelFormat, &result)); return result; }
};
template<typename X> typename FaceTracker_statics<X>::_IsSupported FaceTracker_statics<X>::IsSupported;

template<typename X> struct statics<FaceTracker, X> : X, Windows::Media::FaceAnalysis::FaceTracker_statics<void> {
	typedef typename X::root_type FaceTracker;
};
struct FaceTracker : generate<FaceTracker> {};

// IFaceDetectorStatics
struct IFaceDetectorStatics : IInspectable {
	virtual STDMETHODIMP _CreateAsync(Foundation::IAsyncOperation<FaceDetector*>* *returnValue);
	virtual STDMETHODIMP _GetSupportedBitmapPixelFormats(Foundation::Collections::IVectorView<Graphics::Imaging::BitmapPixelFormat>* *result);
	virtual STDMETHODIMP _IsBitmapPixelFormatSupported(Graphics::Imaging::BitmapPixelFormat bitmapPixelFormat, bool *result);
	virtual STDMETHODIMP _get_IsSupported(bool *returnValue);
};

// FaceDetector
template<typename> struct FaceDetector_statics {
	static struct _IsSupported : property {
		bool get() { bool returnValue; hrcheck(get_activation_factory<FaceDetector, IFaceDetectorStatics>()->_get_IsSupported(&returnValue)); return returnValue; }
		bool operator()() { return get(); }
		operator bool () { return get(); }
	} IsSupported;
	static ptr<Foundation::IAsyncOperation<ptr<FaceDetector>>> CreateAsync() { Foundation::IAsyncOperation<FaceDetector*>* returnValue; hrcheck(get_activation_factory<FaceDetector, IFaceDetectorStatics>()->_CreateAsync(&returnValue)); return from_abi(returnValue); }
	static ptr<Foundation::Collections::IVectorView<Graphics::Imaging::BitmapPixelFormat>> GetSupportedBitmapPixelFormats() { Foundation::Collections::IVectorView<Graphics::Imaging::BitmapPixelFormat>* result; hrcheck(get_activation_factory<FaceDetector, IFaceDetectorStatics>()->_GetSupportedBitmapPixelFormats(&result)); return from_abi(result); }
	static bool IsBitmapPixelFormatSupported(Graphics::Imaging::BitmapPixelFormat bitmapPixelFormat) { bool result; hrcheck(get_activation_factory<FaceDetector, IFaceDetectorStatics>()->_IsBitmapPixelFormatSupported(bitmapPixelFormat, &result)); return result; }
};
template<typename X> typename FaceDetector_statics<X>::_IsSupported FaceDetector_statics<X>::IsSupported;

template<typename X> struct statics<FaceDetector, X> : X, Windows::Media::FaceAnalysis::FaceDetector_statics<void> {
	typedef typename X::root_type FaceDetector;
};
struct FaceDetector : generate<FaceDetector> {
	using IFaceDetector::DetectFacesAsync;
};
}}}
} // namespace iso_winrt
