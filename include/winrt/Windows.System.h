#pragma once
// generated by isopod tools
// namespaces:
// Windows.System

#include "Windows.System.0.h"
#include "Windows.UI.ViewManagement.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.UI.Popups.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace ApplicationModel {
struct AppInfo;
}
namespace Foundation { namespace Collections {
struct IPropertySet;
template<typename T> struct IVector;
struct ValueSet;
template<typename T> struct IVectorView;
}}
namespace Storage { namespace Search {
struct StorageFileQueryResult;
}
namespace Streams {
struct IInputStream;
struct IOutputStream;
struct IRandomAccessStreamReference;
}
struct IStorageItem;
struct StorageFile;
struct IStorageFolder;
struct IStorageFile;
}
namespace System { namespace Diagnostics {
struct ProcessDiagnosticInfo;
}
namespace RemoteSystems {
struct RemoteSystemConnectionRequest;
}}}

// defs

template<> struct def<Windows::System::ProcessorArchitecture> : enum_type<int> {};
template<> struct def<Windows::System::DispatcherQueuePriority> : enum_type<int> {};
template<> struct def<Windows::System::DispatcherQueueHandler> : delegate_type {};
template<> struct def<Windows::System::IDispatcherQueueShutdownStartingEventArgs> : interface_type<> {};
template<> struct def<Windows::System::IDispatcherQueue> : interface_type<> {};
template<> struct def<Windows::System::IDispatcherQueueTimer> : interface_type<> {};
template<> struct def<Windows::System::DispatcherQueueTimer> : class_type<Platform::Object, Windows::System::IDispatcherQueueTimer> {};
template<> struct def<Windows::System::IDispatcherQueueStatics> : interface_type<> {};
template<> struct def<Windows::System::DispatcherQueue> : class_type<Platform::Object, Windows::System::IDispatcherQueue> {};
template<> struct def<Windows::System::DispatcherQueueShutdownStartingEventArgs> : class_type<Platform::Object, Windows::System::IDispatcherQueueShutdownStartingEventArgs> {};
template<> struct def<Windows::System::IDispatcherQueueController> : interface_type<> {};
template<> struct def<Windows::System::IDispatcherQueueControllerStatics> : interface_type<> {};
template<> struct def<Windows::System::DispatcherQueueController> : class_type<Platform::Object, Windows::System::IDispatcherQueueController> {};
template<> struct def<Windows::System::UserAuthenticationStatus> : enum_type<int> {};
template<> struct def<Windows::System::UserType> : enum_type<int> {};
template<> struct def<Windows::System::UserPictureSize> : enum_type<int> {};
template<> struct def<Windows::System::IUser> : interface_type<> {};
template<> struct def<Windows::System::IUserStatics> : interface_type<> {};
template<> struct def<Windows::System::UserWatcherStatus> : enum_type<int> {};
template<> struct def<Windows::System::IUserWatcher> : interface_type<> {};
template<> struct def<Windows::System::UserWatcher> : class_type<Platform::Object, Windows::System::IUserWatcher> {};
template<> struct def<Windows::System::User> : class_type<Platform::Object, Windows::System::IUser> {};
template<> struct def<Windows::System::IUserChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::System::UserChangedEventArgs> : class_type<Platform::Object, Windows::System::IUserChangedEventArgs> {};
template<> struct def<Windows::System::IUserAuthenticationStatusChangingEventArgs> : interface_type<> {};
template<> struct def<Windows::System::UserAuthenticationStatusChangingEventArgs> : class_type<Platform::Object, Windows::System::IUserAuthenticationStatusChangingEventArgs> {};
template<> struct def<Windows::System::IUserAuthenticationStatusChangeDeferral> : interface_type<> {};
template<> struct def<Windows::System::UserAuthenticationStatusChangeDeferral> : class_type<Platform::Object, Windows::System::IUserAuthenticationStatusChangeDeferral> {};
template<> struct def<Windows::System::IKnownUserPropertiesStatics> : interface_type<> {};
template<> struct def<Windows::System::KnownUserProperties> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::System::IUserPickerStatics> : interface_type<> {};
template<> struct def<Windows::System::IUserPicker> : interface_type<> {};
template<> struct def<Windows::System::UserPicker> : class_type<Platform::Object, Windows::System::IUserPicker> {};
template<> struct def<Windows::System::IUserDeviceAssociationChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::System::IUserDeviceAssociationStatics> : interface_type<> {};
template<> struct def<Windows::System::UserDeviceAssociationChangedEventArgs> : class_type<Platform::Object, Windows::System::IUserDeviceAssociationChangedEventArgs> {};
template<> struct def<Windows::System::UserDeviceAssociation> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::System::IAppMemoryReport> : interface_type<> {};
template<> struct def<Windows::System::IAppMemoryReport2> : interface_type<> {};
template<> struct def<Windows::System::IProcessMemoryReport> : interface_type<> {};
template<> struct def<Windows::System::AppMemoryUsageLevel> : enum_type<int> {};
template<> struct def<Windows::System::IAppMemoryUsageLimitChangingEventArgs> : interface_type<> {};
template<> struct def<Windows::System::AppMemoryUsageLimitChangingEventArgs> : class_type<Platform::Object, Windows::System::IAppMemoryUsageLimitChangingEventArgs> {};
template<> struct def<Windows::System::IMemoryManagerStatics> : interface_type<> {};
template<> struct def<Windows::System::IMemoryManagerStatics2> : interface_type<> {};
template<> struct def<Windows::System::AppMemoryReport> : class_type<Platform::Object, Windows::System::IAppMemoryReport, Windows::System::IAppMemoryReport2> {};
template<> struct def<Windows::System::ProcessMemoryReport> : class_type<Platform::Object, Windows::System::IProcessMemoryReport> {};
template<> struct def<Windows::System::IMemoryManagerStatics3> : interface_type<> {};
template<> struct def<Windows::System::IMemoryManagerStatics4> : interface_type<> {};
template<> struct def<Windows::System::MemoryManager> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::System::IProtocolForResultsOperation> : interface_type<> {};
template<> struct def<Windows::System::ProtocolForResultsOperation> : class_type<Platform::Object, Windows::System::IProtocolForResultsOperation> {};
template<> struct def<Windows::System::IAppDiagnosticInfoStatics> : interface_type<> {};
template<> struct def<Windows::System::DiagnosticAccessStatus> : enum_type<int> {};
template<> struct def<Windows::System::IAppDiagnosticInfoStatics2> : interface_type<> {};
template<> struct def<Windows::System::IAppDiagnosticInfo3> : interface_type<> {};
template<> struct def<Windows::System::IAppDiagnosticInfo2> : interface_type<> {};
template<> struct def<Windows::System::IAppDiagnosticInfo> : interface_type<> {};
template<> struct def<Windows::System::AppDiagnosticInfo> : class_type<Platform::Object, Windows::System::IAppDiagnosticInfo, Windows::System::IAppDiagnosticInfo2, Windows::System::IAppDiagnosticInfo3> {};
template<> struct def<Windows::System::AppDiagnosticInfoWatcherStatus> : enum_type<int> {};
template<> struct def<Windows::System::IAppDiagnosticInfoWatcher> : interface_type<> {};
template<> struct def<Windows::System::AppDiagnosticInfoWatcher> : class_type<Platform::Object, Windows::System::IAppDiagnosticInfoWatcher> {};
template<> struct def<Windows::System::IAppActivationResult> : interface_type<> {};
template<> struct def<Windows::System::IAppResourceGroupInfo2> : interface_type<> {};
template<> struct def<Windows::System::IAppResourceGroupInfo> : interface_type<> {};
template<> struct def<Windows::System::AppResourceGroupInfo> : class_type<Platform::Object, Windows::System::IAppResourceGroupInfo, Windows::System::IAppResourceGroupInfo2> {};
template<> struct def<Windows::System::AppActivationResult> : class_type<Platform::Object, Windows::System::IAppActivationResult> {};
template<> struct def<Windows::System::AppResourceGroupInfoWatcherStatus> : enum_type<int> {};
template<> struct def<Windows::System::IAppResourceGroupInfoWatcher> : interface_type<> {};
template<> struct def<Windows::System::AppResourceGroupInfoWatcher> : class_type<Platform::Object, Windows::System::IAppResourceGroupInfoWatcher> {};
template<> struct def<Windows::System::IAppDiagnosticInfoWatcherEventArgs> : interface_type<> {};
template<> struct def<Windows::System::AppDiagnosticInfoWatcherEventArgs> : class_type<Platform::Object, Windows::System::IAppDiagnosticInfoWatcherEventArgs> {};
template<> struct def<Windows::System::AppResourceGroupExecutionState> : enum_type<int> {};
template<> struct def<Windows::System::IAppExecutionStateChangeResult> : interface_type<> {};
template<> struct def<Windows::System::AppExecutionStateChangeResult> : class_type<Platform::Object, Windows::System::IAppExecutionStateChangeResult> {};
template<> struct def<Windows::System::IAppResourceGroupBackgroundTaskReport> : interface_type<> {};
template<> struct def<Windows::System::AppResourceGroupBackgroundTaskReport> : class_type<Platform::Object, Windows::System::IAppResourceGroupBackgroundTaskReport> {};
template<> struct def<Windows::System::IAppResourceGroupMemoryReport> : interface_type<> {};
template<> struct def<Windows::System::AppResourceGroupMemoryReport> : class_type<Platform::Object, Windows::System::IAppResourceGroupMemoryReport> {};
template<> struct def<Windows::System::AppResourceGroupEnergyQuotaState> : enum_type<int> {};
template<> struct def<Windows::System::IAppResourceGroupStateReport> : interface_type<> {};
template<> struct def<Windows::System::AppResourceGroupStateReport> : class_type<Platform::Object, Windows::System::IAppResourceGroupStateReport> {};
template<> struct def<Windows::System::IAppResourceGroupInfoWatcherEventArgs> : interface_type<> {};
template<> struct def<Windows::System::AppResourceGroupInfoWatcherEventArgs> : class_type<Platform::Object, Windows::System::IAppResourceGroupInfoWatcherEventArgs> {};
template<> struct def<Windows::System::IAppResourceGroupInfoWatcherExecutionStateChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs> : class_type<Platform::Object, Windows::System::IAppResourceGroupInfoWatcherExecutionStateChangedEventArgs> {};
template<> struct def<Windows::System::VirtualKeyModifiers> : enum_type<unsigned> {};
template<> struct def<Windows::System::VirtualKey> : enum_type<int> {};
template<> struct def<Windows::System::LaunchQuerySupportType> : enum_type<int> {};
template<> struct def<Windows::System::LaunchQuerySupportStatus> : enum_type<int> {};
template<> struct def<Windows::System::LaunchUriStatus> : enum_type<int> {};
template<> struct def<Windows::System::LaunchFileStatus> : enum_type<int> {};
template<> struct def<Windows::System::RemoteLaunchUriStatus> : enum_type<int> {};
template<> struct def<Windows::System::ILaunchUriResult> : interface_type<> {};
template<> struct def<Windows::System::LaunchUriResult> : class_type<Platform::Object, Windows::System::ILaunchUriResult> {};
template<> struct def<Windows::System::ILauncherUIOptions> : interface_type<> {};
template<> struct def<Windows::System::LauncherUIOptions> : class_type<Platform::Object, Windows::System::ILauncherUIOptions> {};
template<> struct def<Windows::System::ILauncherOptions> : interface_type<> {};
template<> struct def<Windows::System::ILauncherOptions2> : interface_type<> {};
template<> struct def<Windows::System::ILauncherOptions3> : interface_type<> {};
template<> struct def<Windows::System::ILauncherOptions4> : interface_type<> {};
template<> struct def<Windows::System::ILauncherViewOptions> : overridable_type<> {};
template<> struct def<Windows::System::LauncherOptions> : class_type<Platform::Object, Windows::System::ILauncherOptions, Windows::System::ILauncherViewOptions, Windows::System::ILauncherOptions2, Windows::System::ILauncherOptions3, Windows::System::ILauncherOptions4> {};
template<> struct def<Windows::System::IRemoteLauncherOptions> : interface_type<> {};
template<> struct def<Windows::System::RemoteLauncherOptions> : class_type<Platform::Object, Windows::System::IRemoteLauncherOptions> {};
template<> struct def<Windows::System::IFolderLauncherOptions> : interface_type<> {};
template<> struct def<Windows::System::FolderLauncherOptions> : class_type<Platform::Object, Windows::System::IFolderLauncherOptions, Windows::System::ILauncherViewOptions> {};
template<> struct def<Windows::System::ILauncherStatics> : interface_type<> {};
template<> struct def<Windows::System::ILauncherStatics2> : interface_type<> {};
template<> struct def<Windows::System::ILauncherStatics3> : interface_type<> {};
template<> struct def<Windows::System::ILauncherStatics4> : interface_type<> {};
template<> struct def<Windows::System::Launcher> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::System::IRemoteLauncherStatics> : interface_type<> {};
template<> struct def<Windows::System::RemoteLauncher> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::System::IDateTimeSettingsStatics> : interface_type<> {};
template<> struct def<Windows::System::DateTimeSettings> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::System::IProcessLauncherOptions> : interface_type<> {};
template<> struct def<Windows::System::ProcessLauncherOptions> : class_type<Platform::Object, Windows::System::IProcessLauncherOptions> {};
template<> struct def<Windows::System::IProcessLauncherStatics> : interface_type<> {};
template<> struct def<Windows::System::IProcessLauncherResult> : interface_type<> {};
template<> struct def<Windows::System::ProcessLauncherResult> : class_type<Platform::Object, Windows::System::IProcessLauncherResult> {};
template<> struct def<Windows::System::ProcessLauncher> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::System::ShutdownKind> : enum_type<int> {};
template<> struct def<Windows::System::PowerState> : enum_type<int> {};
template<> struct def<Windows::System::IShutdownManagerStatics> : interface_type<> {};
template<> struct def<Windows::System::IShutdownManagerStatics2> : interface_type<Windows::System::IShutdownManagerStatics> {};
template<> struct def<Windows::System::ShutdownManager> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::System::SystemManagementContract> : value_type<> {};
template<> struct def<Windows::System::AutoUpdateTimeZoneStatus> : enum_type<int> {};
template<> struct def<Windows::System::ITimeZoneSettingsStatics> : interface_type<> {};
template<> struct def<Windows::System::ITimeZoneSettingsStatics2> : interface_type<> {};
template<> struct def<Windows::System::TimeZoneSettings> : class_type<Platform::Object, Platform::Object> {};

// uuids

template<> struct uuid<Windows::System::DispatcherQueueHandler> { define_guid(0xDFA2DC9C, 0x1A2D, 0x4917, 0x98, 0xF2, 0x93, 0x9A, 0xF1, 0xD6, 0xE0, 0xC8);};
template<> struct uuid<Windows::System::IDispatcherQueueShutdownStartingEventArgs> { define_guid(0xC4724C4C, 0xFF97, 0x40C0, 0xA2, 0x26, 0xCC, 0xA, 0xAA, 0x54, 0x5E, 0x89);};
template<> struct uuid<Windows::System::IDispatcherQueue> { define_guid(0x603E88E4, 0xA338, 0x4FFE, 0xA4, 0x57, 0xA5, 0xCF, 0xB9, 0xCE, 0xB8, 0x99);};
template<> struct uuid<Windows::System::IDispatcherQueueTimer> { define_guid(0x5FEABB1D, 0xA31C, 0x4727, 0xB1, 0xAC, 0x37, 0x45, 0x46, 0x49, 0xD5, 0x6A);};
template<> struct uuid<Windows::System::IDispatcherQueueStatics> { define_guid(0xA96D83D7, 0x9371, 0x4517, 0x92, 0x45, 0xD0, 0x82, 0x4A, 0xC1, 0x2C, 0x74);};
template<> struct uuid<Windows::System::IDispatcherQueueController> { define_guid(0x22F34E66, 0x50DB, 0x4E36, 0xA9, 0x8D, 0x61, 0xC0, 0x1B, 0x38, 0x4D, 0x20);};
template<> struct uuid<Windows::System::IDispatcherQueueControllerStatics> { define_guid(0xA6C98E0, 0x5198, 0x49A2, 0xA3, 0x13, 0x3F, 0x70, 0xD1, 0xF1, 0x3C, 0x27);};
template<> struct uuid<Windows::System::IUser> { define_guid(0xDF9A26C6, 0xE746, 0x4BCD, 0xB5, 0xD4, 0x12, 0x1, 0x3, 0xC4, 0x20, 0x9B);};
template<> struct uuid<Windows::System::IUserStatics> { define_guid(0x155EB23B, 0x242A, 0x45E0, 0xA2, 0xE9, 0x31, 0x71, 0xFC, 0x6A, 0x7F, 0xDD);};
template<> struct uuid<Windows::System::IUserWatcher> { define_guid(0x155EB23B, 0x242A, 0x45E0, 0xA2, 0xE9, 0x31, 0x71, 0xFC, 0x6A, 0x7F, 0xBB);};
template<> struct uuid<Windows::System::IUserChangedEventArgs> { define_guid(0x86459DC, 0x18C6, 0x48DB, 0xBC, 0x99, 0x72, 0x4F, 0xB9, 0x20, 0x3C, 0xCC);};
template<> struct uuid<Windows::System::IUserAuthenticationStatusChangingEventArgs> { define_guid(0x8C030F28, 0xA711, 0x4C1E, 0xAB, 0x48, 0x4, 0x17, 0x9C, 0x15, 0x93, 0x8F);};
template<> struct uuid<Windows::System::IUserAuthenticationStatusChangeDeferral> { define_guid(0x88B59568, 0xBB30, 0x42FB, 0xA2, 0x70, 0xE9, 0x90, 0x2E, 0x40, 0xEF, 0xA7);};
template<> struct uuid<Windows::System::IKnownUserPropertiesStatics> { define_guid(0x7755911A, 0x70C5, 0x48E5, 0xB6, 0x37, 0x5B, 0xA3, 0x44, 0x1E, 0x4E, 0xE4);};
template<> struct uuid<Windows::System::IUserPickerStatics> { define_guid(0xDE3290DC, 0x7E73, 0x4DF6, 0xA1, 0xAE, 0x4D, 0x7E, 0xCA, 0x82, 0xB4, 0xD);};
template<> struct uuid<Windows::System::IUserPicker> { define_guid(0x7D548008, 0xF1E3, 0x4A6C, 0x8D, 0xDC, 0xA9, 0xBB, 0xF, 0x48, 0x8A, 0xED);};
template<> struct uuid<Windows::System::IUserDeviceAssociationChangedEventArgs> { define_guid(0xBD1F6F6C, 0xBB5D, 0x4D7B, 0xA5, 0xF0, 0xC8, 0xCD, 0x11, 0xA3, 0x8D, 0x42);};
template<> struct uuid<Windows::System::IUserDeviceAssociationStatics> { define_guid(0x7E491E14, 0xF85A, 0x4C07, 0x8D, 0xA9, 0x7F, 0xE3, 0xD0, 0x54, 0x23, 0x43);};
template<> struct uuid<Windows::System::IAppMemoryReport> { define_guid(0x6D65339B, 0x4D6F, 0x45BC, 0x9C, 0x5E, 0xE4, 0x9B, 0x3F, 0xF2, 0x75, 0x8D);};
template<> struct uuid<Windows::System::IAppMemoryReport2> { define_guid(0x5F7F3738, 0x51B7, 0x42DC, 0xB7, 0xED, 0x79, 0xBA, 0x46, 0xD2, 0x88, 0x57);};
template<> struct uuid<Windows::System::IProcessMemoryReport> { define_guid(0x87305A8, 0x9B70, 0x4782, 0x87, 0x41, 0x3A, 0x98, 0x2B, 0x6C, 0xE5, 0xE4);};
template<> struct uuid<Windows::System::IAppMemoryUsageLimitChangingEventArgs> { define_guid(0x79F86664, 0xFECA, 0x4DA5, 0x9E, 0x40, 0x2B, 0xC6, 0x3E, 0xFD, 0xC9, 0x79);};
template<> struct uuid<Windows::System::IMemoryManagerStatics> { define_guid(0x5C6C279C, 0xD7CA, 0x4779, 0x91, 0x88, 0x40, 0x57, 0x21, 0x9C, 0xE6, 0x4C);};
template<> struct uuid<Windows::System::IMemoryManagerStatics2> { define_guid(0x6EEE351F, 0x6D62, 0x423F, 0x94, 0x79, 0xB0, 0x1F, 0x9C, 0x9F, 0x76, 0x69);};
template<> struct uuid<Windows::System::IMemoryManagerStatics3> { define_guid(0x149B59CE, 0x92AD, 0x4E35, 0x89, 0xEB, 0x50, 0xDF, 0xB4, 0xC0, 0xD9, 0x1C);};
template<> struct uuid<Windows::System::IMemoryManagerStatics4> { define_guid(0xC5A94828, 0xE84E, 0x4886, 0x8A, 0xD, 0x44, 0xB3, 0x19, 0xE, 0x3B, 0x72);};
template<> struct uuid<Windows::System::IProtocolForResultsOperation> { define_guid(0xD581293A, 0x6DE9, 0x4D28, 0x93, 0x78, 0xF8, 0x67, 0x82, 0xE1, 0x82, 0xBB);};
template<> struct uuid<Windows::System::IAppDiagnosticInfoStatics> { define_guid(0xCE6925BF, 0x10CA, 0x40C8, 0xA9, 0xCA, 0xC5, 0xC9, 0x65, 0x1, 0x86, 0x6E);};
template<> struct uuid<Windows::System::IAppDiagnosticInfoStatics2> { define_guid(0x5B24B86, 0x1000, 0x4C90, 0xBB, 0x9F, 0x72, 0x35, 0x7, 0x1C, 0x50, 0xFE);};
template<> struct uuid<Windows::System::IAppDiagnosticInfo3> { define_guid(0xC895C63D, 0xDD61, 0x4C65, 0xBA, 0xBD, 0x81, 0xA1, 0xB, 0x4F, 0x98, 0x15);};
template<> struct uuid<Windows::System::IAppDiagnosticInfo2> { define_guid(0xDF46FBD7, 0x191A, 0x446C, 0x94, 0x73, 0x8F, 0xBC, 0x23, 0x74, 0xA3, 0x54);};
template<> struct uuid<Windows::System::IAppDiagnosticInfo> { define_guid(0xE348A69A, 0x8889, 0x4CA3, 0xBE, 0x7, 0xD5, 0xFF, 0xFF, 0x5F, 0x8, 0x4);};
template<> struct uuid<Windows::System::IAppDiagnosticInfoWatcher> { define_guid(0x75575070, 0x1D3, 0x489A, 0x93, 0x25, 0x52, 0xF9, 0xCC, 0x6E, 0xDE, 0xA);};
template<> struct uuid<Windows::System::IAppActivationResult> { define_guid(0x6B528900, 0xF46E, 0x4EB0, 0xAA, 0x6C, 0x38, 0xAF, 0x55, 0x7C, 0xF9, 0xED);};
template<> struct uuid<Windows::System::IAppResourceGroupInfo2> { define_guid(0xEE9B236D, 0xD305, 0x4D6B, 0x92, 0xF7, 0x6A, 0xFD, 0xAD, 0x72, 0xDE, 0xDC);};
template<> struct uuid<Windows::System::IAppResourceGroupInfo> { define_guid(0xB913F77A, 0xE807, 0x49F4, 0x84, 0x5E, 0x7B, 0x8B, 0xDC, 0xFE, 0x8E, 0xE7);};
template<> struct uuid<Windows::System::IAppResourceGroupInfoWatcher> { define_guid(0xD9B0A0FD, 0x6E5A, 0x4C72, 0x8B, 0x17, 0x9, 0xFE, 0xC4, 0xA2, 0x12, 0xBD);};
template<> struct uuid<Windows::System::IAppDiagnosticInfoWatcherEventArgs> { define_guid(0x7017C716, 0xE1DA, 0x4C65, 0x99, 0xDF, 0x4, 0x6D, 0xFF, 0x5B, 0xE7, 0x1A);};
template<> struct uuid<Windows::System::IAppExecutionStateChangeResult> { define_guid(0x6F039BF0, 0xF91B, 0x4DF8, 0xAE, 0x77, 0x30, 0x33, 0xCC, 0xB6, 0x91, 0x14);};
template<> struct uuid<Windows::System::IAppResourceGroupBackgroundTaskReport> { define_guid(0x2566E74E, 0xB05D, 0x40C2, 0x9D, 0xC1, 0x1A, 0x4F, 0x3, 0x9E, 0xA1, 0x20);};
template<> struct uuid<Windows::System::IAppResourceGroupMemoryReport> { define_guid(0x2C8C06B1, 0x7DB1, 0x4C51, 0xA2, 0x25, 0x7F, 0xAE, 0x2D, 0x49, 0xE4, 0x31);};
template<> struct uuid<Windows::System::IAppResourceGroupStateReport> { define_guid(0x52849F18, 0x2F70, 0x4236, 0xAB, 0x40, 0xD0, 0x4D, 0xB0, 0xC7, 0xB9, 0x31);};
template<> struct uuid<Windows::System::IAppResourceGroupInfoWatcherEventArgs> { define_guid(0x7A787637, 0x6302, 0x4D2F, 0xBF, 0x89, 0x1C, 0x12, 0xD0, 0xB2, 0xA6, 0xB9);};
template<> struct uuid<Windows::System::IAppResourceGroupInfoWatcherExecutionStateChangedEventArgs> { define_guid(0x1BDBEDD7, 0xFEE6, 0x4FD4, 0x98, 0xDD, 0xE9, 0x2A, 0x2C, 0xC2, 0x99, 0xF3);};
template<> struct uuid<Windows::System::ILaunchUriResult> { define_guid(0xEC27A8DF, 0xF6D5, 0x45CA, 0x91, 0x3A, 0x70, 0xA4, 0xC, 0x5C, 0x82, 0x21);};
template<> struct uuid<Windows::System::ILauncherUIOptions> { define_guid(0x1B25DA6E, 0x8AA6, 0x41E9, 0x82, 0x51, 0x41, 0x65, 0xF5, 0x98, 0x5F, 0x49);};
template<> struct uuid<Windows::System::ILauncherOptions> { define_guid(0xBAFA21D8, 0xB071, 0x4CD8, 0x85, 0x3E, 0x34, 0x12, 0x3, 0xE5, 0x57, 0xD3);};
template<> struct uuid<Windows::System::ILauncherOptions2> { define_guid(0x3BA08EB4, 0x6E40, 0x4DCE, 0xA1, 0xA3, 0x2F, 0x53, 0x95, 0xA, 0xFB, 0x49);};
template<> struct uuid<Windows::System::ILauncherOptions3> { define_guid(0xF0770655, 0x4B63, 0x4E3A, 0x91, 0x7, 0x4E, 0x68, 0x78, 0x41, 0x92, 0x3A);};
template<> struct uuid<Windows::System::ILauncherOptions4> { define_guid(0xEF6FD10E, 0xE6FB, 0x4814, 0xA4, 0x4E, 0x57, 0xE8, 0xB9, 0xD9, 0xA0, 0x1B);};
template<> struct uuid<Windows::System::ILauncherViewOptions> { define_guid(0x8A9B29F1, 0x7CA7, 0x49DE, 0x9B, 0xD3, 0x3C, 0x5B, 0x71, 0x84, 0xF6, 0x16);};
template<> struct uuid<Windows::System::IRemoteLauncherOptions> { define_guid(0x9E3A2788, 0x2891, 0x4CDF, 0xA2, 0xD6, 0x9D, 0xFF, 0x7D, 0x2, 0xE6, 0x93);};
template<> struct uuid<Windows::System::IFolderLauncherOptions> { define_guid(0xBB91C27D, 0x6B87, 0x432A, 0xBD, 0x4, 0x77, 0x6C, 0x6F, 0x5F, 0xB2, 0xAB);};
template<> struct uuid<Windows::System::ILauncherStatics> { define_guid(0x277151C3, 0x9E3E, 0x42F6, 0x91, 0xA4, 0x5D, 0xFD, 0xEB, 0x23, 0x24, 0x51);};
template<> struct uuid<Windows::System::ILauncherStatics2> { define_guid(0x59BA2FBB, 0x24CB, 0x4C02, 0xA4, 0xC4, 0x82, 0x94, 0x56, 0x9D, 0x54, 0xF1);};
template<> struct uuid<Windows::System::ILauncherStatics3> { define_guid(0x234261A8, 0x9DB3, 0x4683, 0xAA, 0x42, 0xDC, 0x6F, 0x51, 0xD3, 0x38, 0x47);};
template<> struct uuid<Windows::System::ILauncherStatics4> { define_guid(0xB9EC819F, 0xB5A5, 0x41C6, 0xB3, 0xB3, 0xDD, 0x1B, 0x31, 0x78, 0xBC, 0xF2);};
template<> struct uuid<Windows::System::IRemoteLauncherStatics> { define_guid(0xD7DB7A93, 0xA30C, 0x48B7, 0x9F, 0x21, 0x5, 0x10, 0x26, 0xA4, 0xE5, 0x17);};
template<> struct uuid<Windows::System::IDateTimeSettingsStatics> { define_guid(0x5D2150D1, 0x47EE, 0x48AB, 0xA5, 0x2B, 0x9F, 0x19, 0x54, 0x27, 0x8D, 0x82);};
template<> struct uuid<Windows::System::IProcessLauncherOptions> { define_guid(0x3080B9CF, 0xF444, 0x4A83, 0xBE, 0xAF, 0xA5, 0x49, 0xA0, 0xF3, 0x22, 0x9C);};
template<> struct uuid<Windows::System::IProcessLauncherStatics> { define_guid(0x33AB66E7, 0x2D0E, 0x448B, 0xA6, 0xA0, 0xC1, 0x3C, 0x38, 0x36, 0xD0, 0x9C);};
template<> struct uuid<Windows::System::IProcessLauncherResult> { define_guid(0x544C8934, 0x86D8, 0x4991, 0x8E, 0x75, 0xEC, 0xE8, 0xA4, 0x3B, 0x6B, 0x6D);};
template<> struct uuid<Windows::System::IShutdownManagerStatics> { define_guid(0x72E247ED, 0xDD5B, 0x4D6C, 0xB1, 0xD0, 0xC5, 0x7A, 0x7B, 0xBB, 0x5F, 0x94);};
template<> struct uuid<Windows::System::IShutdownManagerStatics2> { define_guid(0xF69A02F, 0x9C34, 0x43C7, 0xA8, 0xC3, 0x70, 0xB3, 0xA, 0x7F, 0x75, 0x4);};
template<> struct uuid<Windows::System::ITimeZoneSettingsStatics> { define_guid(0x9B3B2BEA, 0xA101, 0x41AE, 0x9F, 0xBD, 0x2, 0x87, 0x28, 0xBA, 0xB7, 0x3D);};
template<> struct uuid<Windows::System::ITimeZoneSettingsStatics2> { define_guid(0x555C0DB8, 0x39A8, 0x49FA, 0xB4, 0xF6, 0xA2, 0xC7, 0xFC, 0x28, 0x42, 0xEC);};

// types

namespace Windows { namespace System {

// DispatcherQueueHandler
struct DispatcherQueueHandler : IUnknown {
	virtual STDMETHODIMP _Invoke() = 0;
};

// IDispatcherQueueShutdownStartingEventArgs
struct IDispatcherQueueShutdownStartingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _GetDeferral(Foundation::Deferral* *value);
};
template<typename X> struct IDispatcherQueueShutdownStartingEventArgs_adaptor : X {
	ptr<Foundation::Deferral> GetDeferral() { Foundation::Deferral* value; hrcheck(X::get()->_GetDeferral(&value)); return from_abi(value); }
};
template<typename X> struct adapt<IDispatcherQueueShutdownStartingEventArgs, X> : Windows::System::IDispatcherQueueShutdownStartingEventArgs_adaptor<X> { typedef adapt IDispatcherQueueShutdownStartingEventArgs; };
struct IDispatcherQueueShutdownStartingEventArgs : IDispatcherQueueShutdownStartingEventArgs_raw, generate<IDispatcherQueueShutdownStartingEventArgs> {};

// IDispatcherQueue
struct IDispatcherQueue_raw : IInspectable {
	virtual STDMETHODIMP _CreateTimer(DispatcherQueueTimer* *result);
	virtual STDMETHODIMP _TryEnqueue(DispatcherQueueHandler* callback, bool *result);
	virtual STDMETHODIMP _TryEnqueueWithPriority(DispatcherQueuePriority priority, DispatcherQueueHandler* callback, bool *result);
	virtual STDMETHODIMP _add_ShutdownStarting(Foundation::TypedEventHandler<DispatcherQueue*, DispatcherQueueShutdownStartingEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ShutdownStarting(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ShutdownCompleted(Foundation::TypedEventHandler<DispatcherQueue*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ShutdownCompleted(Foundation::EventRegistrationToken token);
};
template<typename X> struct IDispatcherQueue_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DispatcherQueue>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDispatcherQueue_adaptor::ShutdownCompleted)->_add_ShutdownCompleted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDispatcherQueue_adaptor::ShutdownCompleted)->_remove_ShutdownCompleted(token)); }
		} ShutdownCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DispatcherQueue>, ptr<DispatcherQueueShutdownStartingEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDispatcherQueue_adaptor::ShutdownStarting)->_add_ShutdownStarting(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDispatcherQueue_adaptor::ShutdownStarting)->_remove_ShutdownStarting(token)); }
		} ShutdownStarting;
	};
	ptr<DispatcherQueueTimer> CreateTimer() { DispatcherQueueTimer* result; hrcheck(X::get()->_CreateTimer(&result)); return from_abi(result); }
	bool TryEnqueue(handler_ref<DispatcherQueueHandler> callback) { bool result; hrcheck(X::get()->_TryEnqueue(callback, &result)); return result; }
	bool TryEnqueue(DispatcherQueuePriority priority, handler_ref<DispatcherQueueHandler> callback) { bool result; hrcheck(X::get()->_TryEnqueueWithPriority(priority, callback, &result)); return result; }
	IDispatcherQueue_adaptor() {}
};
template<typename X> struct adapt<IDispatcherQueue, X> : Windows::System::IDispatcherQueue_adaptor<X> { typedef adapt IDispatcherQueue; };
struct IDispatcherQueue : IDispatcherQueue_raw, generate<IDispatcherQueue> {};

// IDispatcherQueueTimer
struct IDispatcherQueueTimer_raw : IInspectable {
	virtual STDMETHODIMP _get_Interval(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_Interval(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_IsRunning(bool *value);
	virtual STDMETHODIMP _get_IsRepeating(bool *value);
	virtual STDMETHODIMP _put_IsRepeating(bool value);
	virtual STDMETHODIMP _Start();
	virtual STDMETHODIMP _Stop();
	virtual STDMETHODIMP _add_Tick(Foundation::TypedEventHandler<DispatcherQueueTimer*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Tick(Foundation::EventRegistrationToken token);
};
template<typename X> struct IDispatcherQueueTimer_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IDispatcherQueueTimer_adaptor::Interval)->_get_Interval(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IDispatcherQueueTimer_adaptor::Interval)->_put_Interval(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Interval;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDispatcherQueueTimer_adaptor::IsRepeating)->_get_IsRepeating(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDispatcherQueueTimer_adaptor::IsRepeating)->_put_IsRepeating(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsRepeating;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDispatcherQueueTimer_adaptor::IsRunning)->_get_IsRunning(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsRunning;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DispatcherQueueTimer>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDispatcherQueueTimer_adaptor::Tick)->_add_Tick(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDispatcherQueueTimer_adaptor::Tick)->_remove_Tick(token)); }
		} Tick;
	};
	void Start() { hrcheck(X::get()->_Start()); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	IDispatcherQueueTimer_adaptor() {}
};
template<typename X> struct adapt<IDispatcherQueueTimer, X> : Windows::System::IDispatcherQueueTimer_adaptor<X> { typedef adapt IDispatcherQueueTimer; };
struct IDispatcherQueueTimer : IDispatcherQueueTimer_raw, generate<IDispatcherQueueTimer> {};

// DispatcherQueueTimer
template<typename X> struct statics<DispatcherQueueTimer, X> : X {
	typedef typename X::root_type DispatcherQueueTimer;
};
struct DispatcherQueueTimer : generate<DispatcherQueueTimer> {};

// IDispatcherQueueStatics
struct IDispatcherQueueStatics : IInspectable {
	virtual STDMETHODIMP _GetForCurrentThread(DispatcherQueue* *result);
};

// DispatcherQueue
template<typename> struct DispatcherQueue_statics {
	static ptr<DispatcherQueue> GetForCurrentThread() { DispatcherQueue* result; hrcheck(get_activation_factory<DispatcherQueue, IDispatcherQueueStatics>()->_GetForCurrentThread(&result)); return from_abi(result); }
};

template<typename X> struct statics<DispatcherQueue, X> : X, Windows::System::DispatcherQueue_statics<void> {
	typedef typename X::root_type DispatcherQueue;
};
struct DispatcherQueue : generate<DispatcherQueue> {
	using IDispatcherQueue::TryEnqueue;
};

// DispatcherQueueShutdownStartingEventArgs
template<typename X> struct statics<DispatcherQueueShutdownStartingEventArgs, X> : X {
	typedef typename X::root_type DispatcherQueueShutdownStartingEventArgs;
};
struct DispatcherQueueShutdownStartingEventArgs : generate<DispatcherQueueShutdownStartingEventArgs> {};

// IDispatcherQueueController
struct IDispatcherQueueController_raw : IInspectable {
	virtual STDMETHODIMP _get_DispatcherQueue(System::DispatcherQueue* *value);
	virtual STDMETHODIMP _ShutdownQueueAsync(Foundation::IAsyncAction* *operation);
};
template<typename X> struct IDispatcherQueueController_adaptor : X {
	union {
		struct : property {
			ptr<System::DispatcherQueue> get() { System::DispatcherQueue* value; hrcheck(enc(&IDispatcherQueueController_adaptor::DispatcherQueue)->_get_DispatcherQueue(&value)); return from_abi(value); }
			ptr<System::DispatcherQueue> operator()() { return get(); }
			operator ptr<System::DispatcherQueue> () { return get(); }
			ptr<System::DispatcherQueue> operator->() { return get(); }
		} DispatcherQueue;
	};
	ptr<Foundation::IAsyncAction> ShutdownQueueAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_ShutdownQueueAsync(&operation)); return from_abi(operation); }
	IDispatcherQueueController_adaptor() {}
};
template<typename X> struct adapt<IDispatcherQueueController, X> : Windows::System::IDispatcherQueueController_adaptor<X> { typedef adapt IDispatcherQueueController; };
struct IDispatcherQueueController : IDispatcherQueueController_raw, generate<IDispatcherQueueController> {};

// IDispatcherQueueControllerStatics
struct IDispatcherQueueControllerStatics : IInspectable {
	virtual STDMETHODIMP _CreateOnDedicatedThread(DispatcherQueueController* *result);
};

// DispatcherQueueController
template<typename> struct DispatcherQueueController_statics {
	static ptr<DispatcherQueueController> CreateOnDedicatedThread() { DispatcherQueueController* result; hrcheck(get_activation_factory<DispatcherQueueController, IDispatcherQueueControllerStatics>()->_CreateOnDedicatedThread(&result)); return from_abi(result); }
};

template<typename X> struct statics<DispatcherQueueController, X> : X, Windows::System::DispatcherQueueController_statics<void> {
	typedef typename X::root_type DispatcherQueueController;
};
struct DispatcherQueueController : generate<DispatcherQueueController> {};

// IUser
struct IUser_raw : IInspectable {
	virtual STDMETHODIMP _get_NonRoamableId(HSTRING *value);
	virtual STDMETHODIMP _get_AuthenticationStatus(UserAuthenticationStatus *value);
	virtual STDMETHODIMP _get_Type(UserType *value);
	virtual STDMETHODIMP _GetPropertyAsync(HSTRING value, Foundation::IAsyncOperation<IInspectable*>* *operation);
	virtual STDMETHODIMP _GetPropertiesAsync(Foundation::Collections::IVectorView<HSTRING>* values, Foundation::IAsyncOperation<Foundation::Collections::IPropertySet*>* *operation);
	virtual STDMETHODIMP _GetPictureAsync(UserPictureSize desiredSize, Foundation::IAsyncOperation<Storage::Streams::IRandomAccessStreamReference*>* *operation);
};
template<typename X> struct IUser_adaptor : X {
	union {
		struct : property {
			UserAuthenticationStatus get() { UserAuthenticationStatus value; hrcheck(enc(&IUser_adaptor::AuthenticationStatus)->_get_AuthenticationStatus(&value)); return value; }
			UserAuthenticationStatus operator()() { return get(); }
			operator UserAuthenticationStatus () { return get(); }
		} AuthenticationStatus;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUser_adaptor::NonRoamableId)->_get_NonRoamableId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} NonRoamableId;
		struct : property {
			UserType get() { UserType value; hrcheck(enc(&IUser_adaptor::Type)->_get_Type(&value)); return value; }
			UserType operator()() { return get(); }
			operator UserType () { return get(); }
		} Type;
	};
	ptr<Foundation::IAsyncOperation<object>> GetPropertyAsync(hstring_ref value) { Foundation::IAsyncOperation<IInspectable*>* operation; hrcheck(X::get()->_GetPropertyAsync(value, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IPropertySet>>> GetPropertiesAsync(pptr<Foundation::Collections::IVectorView<hstring>> values) { Foundation::IAsyncOperation<Foundation::Collections::IPropertySet*>* operation; hrcheck(X::get()->_GetPropertiesAsync(to_abi(values), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Storage::Streams::IRandomAccessStreamReference>>> GetPictureAsync(UserPictureSize desiredSize) { Foundation::IAsyncOperation<Storage::Streams::IRandomAccessStreamReference*>* operation; hrcheck(X::get()->_GetPictureAsync(desiredSize, &operation)); return from_abi(operation); }
	IUser_adaptor() {}
};
template<typename X> struct adapt<IUser, X> : Windows::System::IUser_adaptor<X> { typedef adapt IUser; };
struct IUser : IUser_raw, generate<IUser> {};

// IUserStatics
struct IUserStatics : IInspectable {
	virtual STDMETHODIMP _CreateWatcher(UserWatcher* *watcher);
	virtual STDMETHODIMP _FindAllAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<User*>*>* *operation);
	virtual STDMETHODIMP _FindAllAsyncByType(UserType type, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<User*>*>* *operation);
	virtual STDMETHODIMP _FindAllAsyncByTypeAndStatus(UserType type, UserAuthenticationStatus status, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<User*>*>* *operation);
	virtual STDMETHODIMP _GetFromId(HSTRING nonRoamableId, User* *value);
};

// IUserWatcher
struct IUserWatcher_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(UserWatcherStatus *value);
	virtual STDMETHODIMP _Start();
	virtual STDMETHODIMP _Stop();
	virtual STDMETHODIMP _add_Added(Foundation::TypedEventHandler<UserWatcher*, UserChangedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Added(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Removed(Foundation::TypedEventHandler<UserWatcher*, UserChangedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Removed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Updated(Foundation::TypedEventHandler<UserWatcher*, UserChangedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Updated(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_AuthenticationStatusChanged(Foundation::TypedEventHandler<UserWatcher*, UserChangedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_AuthenticationStatusChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_AuthenticationStatusChanging(Foundation::TypedEventHandler<UserWatcher*, UserAuthenticationStatusChangingEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_AuthenticationStatusChanging(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_EnumerationCompleted(Foundation::TypedEventHandler<UserWatcher*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_EnumerationCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Stopped(Foundation::TypedEventHandler<UserWatcher*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Stopped(Foundation::EventRegistrationToken token);
};
template<typename X> struct IUserWatcher_adaptor : X {
	union {
		struct : property {
			UserWatcherStatus get() { UserWatcherStatus value; hrcheck(enc(&IUserWatcher_adaptor::Status)->_get_Status(&value)); return value; }
			UserWatcherStatus operator()() { return get(); }
			operator UserWatcherStatus () { return get(); }
		} Status;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UserWatcher>, ptr<UserChangedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUserWatcher_adaptor::Added)->_add_Added(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUserWatcher_adaptor::Added)->_remove_Added(token)); }
		} Added;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UserWatcher>, ptr<UserChangedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUserWatcher_adaptor::AuthenticationStatusChanged)->_add_AuthenticationStatusChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUserWatcher_adaptor::AuthenticationStatusChanged)->_remove_AuthenticationStatusChanged(token)); }
		} AuthenticationStatusChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UserWatcher>, ptr<UserAuthenticationStatusChangingEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUserWatcher_adaptor::AuthenticationStatusChanging)->_add_AuthenticationStatusChanging(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUserWatcher_adaptor::AuthenticationStatusChanging)->_remove_AuthenticationStatusChanging(token)); }
		} AuthenticationStatusChanging;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UserWatcher>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUserWatcher_adaptor::EnumerationCompleted)->_add_EnumerationCompleted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUserWatcher_adaptor::EnumerationCompleted)->_remove_EnumerationCompleted(token)); }
		} EnumerationCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UserWatcher>, ptr<UserChangedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUserWatcher_adaptor::Removed)->_add_Removed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUserWatcher_adaptor::Removed)->_remove_Removed(token)); }
		} Removed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UserWatcher>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUserWatcher_adaptor::Stopped)->_add_Stopped(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUserWatcher_adaptor::Stopped)->_remove_Stopped(token)); }
		} Stopped;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<UserWatcher>, ptr<UserChangedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IUserWatcher_adaptor::Updated)->_add_Updated(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IUserWatcher_adaptor::Updated)->_remove_Updated(token)); }
		} Updated;
	};
	void Start() { hrcheck(X::get()->_Start()); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	IUserWatcher_adaptor() {}
};
template<typename X> struct adapt<IUserWatcher, X> : Windows::System::IUserWatcher_adaptor<X> { typedef adapt IUserWatcher; };
struct IUserWatcher : IUserWatcher_raw, generate<IUserWatcher> {};

// UserWatcher
template<typename X> struct statics<UserWatcher, X> : X {
	typedef typename X::root_type UserWatcher;
};
struct UserWatcher : generate<UserWatcher> {};

// User
template<typename> struct User_statics {
	static ptr<UserWatcher> CreateWatcher() { UserWatcher* watcher; hrcheck(get_activation_factory<User, IUserStatics>()->_CreateWatcher(&watcher)); return from_abi(watcher); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<User>>>>> FindAllAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<User*>*>* operation; hrcheck(get_activation_factory<User, IUserStatics>()->_FindAllAsync(&operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<User>>>>> FindAllAsync(UserType type) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<User*>*>* operation; hrcheck(get_activation_factory<User, IUserStatics>()->_FindAllAsyncByType(type, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<User>>>>> FindAllAsync(UserType type, UserAuthenticationStatus status) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<User*>*>* operation; hrcheck(get_activation_factory<User, IUserStatics>()->_FindAllAsyncByTypeAndStatus(type, status, &operation)); return from_abi(operation); }
	static ptr<User> GetFromId(hstring_ref nonRoamableId) { User* value; hrcheck(get_activation_factory<User, IUserStatics>()->_GetFromId(nonRoamableId, &value)); return from_abi(value); }
};

template<typename X> struct statics<User, X> : X, Windows::System::User_statics<void> {
	typedef typename X::root_type User;
};
struct User : generate<User> {};

// IUserChangedEventArgs
struct IUserChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_User(System::User* *value);
};
template<typename X> struct IUserChangedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<System::User> get() { System::User* value; hrcheck(enc(&IUserChangedEventArgs_adaptor::User)->_get_User(&value)); return from_abi(value); }
			ptr<System::User> operator()() { return get(); }
			operator ptr<System::User> () { return get(); }
			ptr<System::User> operator->() { return get(); }
		} User;
	};
	IUserChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IUserChangedEventArgs, X> : Windows::System::IUserChangedEventArgs_adaptor<X> { typedef adapt IUserChangedEventArgs; };
struct IUserChangedEventArgs : IUserChangedEventArgs_raw, generate<IUserChangedEventArgs> {};

// UserChangedEventArgs
template<typename X> struct statics<UserChangedEventArgs, X> : X {
	typedef typename X::root_type UserChangedEventArgs;
};
struct UserChangedEventArgs : generate<UserChangedEventArgs> {};

// IUserAuthenticationStatusChangingEventArgs
struct IUserAuthenticationStatusChangingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _GetDeferral(UserAuthenticationStatusChangeDeferral* *deferral);
	virtual STDMETHODIMP _get_User(System::User* *value);
	virtual STDMETHODIMP _get_NewStatus(UserAuthenticationStatus *value);
	virtual STDMETHODIMP _get_CurrentStatus(UserAuthenticationStatus *value);
};
template<typename X> struct IUserAuthenticationStatusChangingEventArgs_adaptor : X {
	union {
		struct : property {
			UserAuthenticationStatus get() { UserAuthenticationStatus value; hrcheck(enc(&IUserAuthenticationStatusChangingEventArgs_adaptor::CurrentStatus)->_get_CurrentStatus(&value)); return value; }
			UserAuthenticationStatus operator()() { return get(); }
			operator UserAuthenticationStatus () { return get(); }
		} CurrentStatus;
		struct : property {
			UserAuthenticationStatus get() { UserAuthenticationStatus value; hrcheck(enc(&IUserAuthenticationStatusChangingEventArgs_adaptor::NewStatus)->_get_NewStatus(&value)); return value; }
			UserAuthenticationStatus operator()() { return get(); }
			operator UserAuthenticationStatus () { return get(); }
		} NewStatus;
		struct : property {
			ptr<System::User> get() { System::User* value; hrcheck(enc(&IUserAuthenticationStatusChangingEventArgs_adaptor::User)->_get_User(&value)); return from_abi(value); }
			ptr<System::User> operator()() { return get(); }
			operator ptr<System::User> () { return get(); }
			ptr<System::User> operator->() { return get(); }
		} User;
	};
	ptr<UserAuthenticationStatusChangeDeferral> GetDeferral() { UserAuthenticationStatusChangeDeferral* deferral; hrcheck(X::get()->_GetDeferral(&deferral)); return from_abi(deferral); }
	IUserAuthenticationStatusChangingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IUserAuthenticationStatusChangingEventArgs, X> : Windows::System::IUserAuthenticationStatusChangingEventArgs_adaptor<X> { typedef adapt IUserAuthenticationStatusChangingEventArgs; };
struct IUserAuthenticationStatusChangingEventArgs : IUserAuthenticationStatusChangingEventArgs_raw, generate<IUserAuthenticationStatusChangingEventArgs> {};

// UserAuthenticationStatusChangingEventArgs
template<typename X> struct statics<UserAuthenticationStatusChangingEventArgs, X> : X {
	typedef typename X::root_type UserAuthenticationStatusChangingEventArgs;
};
struct UserAuthenticationStatusChangingEventArgs : generate<UserAuthenticationStatusChangingEventArgs> {};

// IUserAuthenticationStatusChangeDeferral
struct IUserAuthenticationStatusChangeDeferral_raw : IInspectable {
	virtual STDMETHODIMP _Complete();
};
template<typename X> struct IUserAuthenticationStatusChangeDeferral_adaptor : X {
	void Complete() { hrcheck(X::get()->_Complete()); }
};
template<typename X> struct adapt<IUserAuthenticationStatusChangeDeferral, X> : Windows::System::IUserAuthenticationStatusChangeDeferral_adaptor<X> { typedef adapt IUserAuthenticationStatusChangeDeferral; };
struct IUserAuthenticationStatusChangeDeferral : IUserAuthenticationStatusChangeDeferral_raw, generate<IUserAuthenticationStatusChangeDeferral> {};

// UserAuthenticationStatusChangeDeferral
template<typename X> struct statics<UserAuthenticationStatusChangeDeferral, X> : X {
	typedef typename X::root_type UserAuthenticationStatusChangeDeferral;
};
struct UserAuthenticationStatusChangeDeferral : generate<UserAuthenticationStatusChangeDeferral> {};

// IKnownUserPropertiesStatics
struct IKnownUserPropertiesStatics : IInspectable {
	virtual STDMETHODIMP _get_DisplayName(HSTRING *value);
	virtual STDMETHODIMP _get_FirstName(HSTRING *value);
	virtual STDMETHODIMP _get_LastName(HSTRING *value);
	virtual STDMETHODIMP _get_ProviderName(HSTRING *value);
	virtual STDMETHODIMP _get_AccountName(HSTRING *value);
	virtual STDMETHODIMP _get_GuestHost(HSTRING *value);
	virtual STDMETHODIMP _get_PrincipalName(HSTRING *value);
	virtual STDMETHODIMP _get_DomainName(HSTRING *value);
	virtual STDMETHODIMP _get_SessionInitiationProtocolUri(HSTRING *value);
};

// KnownUserProperties
template<typename> struct KnownUserProperties_statics {
	static struct _AccountName : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KnownUserProperties, IKnownUserPropertiesStatics>()->_get_AccountName(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AccountName;
	static struct _DisplayName : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KnownUserProperties, IKnownUserPropertiesStatics>()->_get_DisplayName(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} DisplayName;
	static struct _DomainName : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KnownUserProperties, IKnownUserPropertiesStatics>()->_get_DomainName(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} DomainName;
	static struct _FirstName : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KnownUserProperties, IKnownUserPropertiesStatics>()->_get_FirstName(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} FirstName;
	static struct _GuestHost : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KnownUserProperties, IKnownUserPropertiesStatics>()->_get_GuestHost(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} GuestHost;
	static struct _LastName : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KnownUserProperties, IKnownUserPropertiesStatics>()->_get_LastName(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} LastName;
	static struct _PrincipalName : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KnownUserProperties, IKnownUserPropertiesStatics>()->_get_PrincipalName(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} PrincipalName;
	static struct _ProviderName : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KnownUserProperties, IKnownUserPropertiesStatics>()->_get_ProviderName(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} ProviderName;
	static struct _SessionInitiationProtocolUri : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KnownUserProperties, IKnownUserPropertiesStatics>()->_get_SessionInitiationProtocolUri(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} SessionInitiationProtocolUri;
};
template<typename X> typename KnownUserProperties_statics<X>::_AccountName KnownUserProperties_statics<X>::AccountName;
template<typename X> typename KnownUserProperties_statics<X>::_DisplayName KnownUserProperties_statics<X>::DisplayName;
template<typename X> typename KnownUserProperties_statics<X>::_DomainName KnownUserProperties_statics<X>::DomainName;
template<typename X> typename KnownUserProperties_statics<X>::_FirstName KnownUserProperties_statics<X>::FirstName;
template<typename X> typename KnownUserProperties_statics<X>::_GuestHost KnownUserProperties_statics<X>::GuestHost;
template<typename X> typename KnownUserProperties_statics<X>::_LastName KnownUserProperties_statics<X>::LastName;
template<typename X> typename KnownUserProperties_statics<X>::_PrincipalName KnownUserProperties_statics<X>::PrincipalName;
template<typename X> typename KnownUserProperties_statics<X>::_ProviderName KnownUserProperties_statics<X>::ProviderName;
template<typename X> typename KnownUserProperties_statics<X>::_SessionInitiationProtocolUri KnownUserProperties_statics<X>::SessionInitiationProtocolUri;

template<typename X> struct statics<KnownUserProperties, X> : X, Windows::System::KnownUserProperties_statics<void> {
	typedef typename X::root_type KnownUserProperties;
};
struct KnownUserProperties : generate<KnownUserProperties> {};

// IUserPickerStatics
struct IUserPickerStatics : IInspectable {
	virtual STDMETHODIMP _IsSupported(bool *value);
};

// IUserPicker
struct IUserPicker_raw : IInspectable {
	virtual STDMETHODIMP _get_AllowGuestAccounts(bool *value);
	virtual STDMETHODIMP _put_AllowGuestAccounts(bool value);
	virtual STDMETHODIMP _get_SuggestedSelectedUser(User* *value);
	virtual STDMETHODIMP _put_SuggestedSelectedUser(User* value);
	virtual STDMETHODIMP _PickSingleUserAsync(Foundation::IAsyncOperation<User*>* *pickSingleUserOperation);
};
template<typename X> struct IUserPicker_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUserPicker_adaptor::AllowGuestAccounts)->_get_AllowGuestAccounts(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IUserPicker_adaptor::AllowGuestAccounts)->_put_AllowGuestAccounts(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AllowGuestAccounts;
		struct : property {
			ptr<User> get() { User* value; hrcheck(enc(&IUserPicker_adaptor::SuggestedSelectedUser)->_get_SuggestedSelectedUser(&value)); return from_abi(value); }
			ptr<User> operator()() { return get(); }
			operator ptr<User> () { return get(); }
			ptr<User> operator->() { return get(); }
			void put(pptr<User> value) { hrcheck(enc(&IUserPicker_adaptor::SuggestedSelectedUser)->_put_SuggestedSelectedUser(value)); }
			void operator=(pptr<User> value) { put(value); }
			void operator()(pptr<User> value) { put(value); }
		} SuggestedSelectedUser;
	};
	ptr<Foundation::IAsyncOperation<ptr<User>>> PickSingleUserAsync() { Foundation::IAsyncOperation<User*>* pickSingleUserOperation; hrcheck(X::get()->_PickSingleUserAsync(&pickSingleUserOperation)); return from_abi(pickSingleUserOperation); }
	IUserPicker_adaptor() {}
};
template<typename X> struct adapt<IUserPicker, X> : Windows::System::IUserPicker_adaptor<X> { typedef adapt IUserPicker; };
struct IUserPicker : IUserPicker_raw, generate<IUserPicker> {};

// UserPicker
template<typename> struct UserPicker_statics {
	static bool IsSupported() { bool value; hrcheck(get_activation_factory<UserPicker, IUserPickerStatics>()->_IsSupported(&value)); return value; }
};

template<typename X> struct statics<UserPicker, X> : X, Windows::System::UserPicker_statics<void> {
	typedef typename X::root_type UserPicker;
};
struct UserPicker : generate<UserPicker> {};

// IUserDeviceAssociationChangedEventArgs
struct IUserDeviceAssociationChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_DeviceId(HSTRING *value);
	virtual STDMETHODIMP _get_NewUser(User* *value);
	virtual STDMETHODIMP _get_OldUser(User* *value);
};
template<typename X> struct IUserDeviceAssociationChangedEventArgs_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDeviceAssociationChangedEventArgs_adaptor::DeviceId)->_get_DeviceId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DeviceId;
		struct : property {
			ptr<User> get() { User* value; hrcheck(enc(&IUserDeviceAssociationChangedEventArgs_adaptor::NewUser)->_get_NewUser(&value)); return from_abi(value); }
			ptr<User> operator()() { return get(); }
			operator ptr<User> () { return get(); }
			ptr<User> operator->() { return get(); }
		} NewUser;
		struct : property {
			ptr<User> get() { User* value; hrcheck(enc(&IUserDeviceAssociationChangedEventArgs_adaptor::OldUser)->_get_OldUser(&value)); return from_abi(value); }
			ptr<User> operator()() { return get(); }
			operator ptr<User> () { return get(); }
			ptr<User> operator->() { return get(); }
		} OldUser;
	};
	IUserDeviceAssociationChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IUserDeviceAssociationChangedEventArgs, X> : Windows::System::IUserDeviceAssociationChangedEventArgs_adaptor<X> { typedef adapt IUserDeviceAssociationChangedEventArgs; };
struct IUserDeviceAssociationChangedEventArgs : IUserDeviceAssociationChangedEventArgs_raw, generate<IUserDeviceAssociationChangedEventArgs> {};

// IUserDeviceAssociationStatics
struct IUserDeviceAssociationStatics : IInspectable {
	virtual STDMETHODIMP _FindUserFromDeviceId(HSTRING deviceId, User* *user);
	virtual STDMETHODIMP _add_UserDeviceAssociationChanged(Foundation::EventHandler<UserDeviceAssociationChangedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_UserDeviceAssociationChanged(Foundation::EventRegistrationToken token);
};

// UserDeviceAssociationChangedEventArgs
template<typename X> struct statics<UserDeviceAssociationChangedEventArgs, X> : X {
	typedef typename X::root_type UserDeviceAssociationChangedEventArgs;
};
struct UserDeviceAssociationChangedEventArgs : generate<UserDeviceAssociationChangedEventArgs> {};

// UserDeviceAssociation
template<typename> struct UserDeviceAssociation_statics {
	static struct _UserDeviceAssociationChanged : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<UserDeviceAssociationChangedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<UserDeviceAssociation, IUserDeviceAssociationStatics>()->_add_UserDeviceAssociationChanged(to_abi(handler), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<UserDeviceAssociation, IUserDeviceAssociationStatics>()->_remove_UserDeviceAssociationChanged(token)); }
	} UserDeviceAssociationChanged;
	static ptr<User> FindUserFromDeviceId(hstring_ref deviceId) { User* user; hrcheck(get_activation_factory<UserDeviceAssociation, IUserDeviceAssociationStatics>()->_FindUserFromDeviceId(deviceId, &user)); return from_abi(user); }
};
template<typename X> typename UserDeviceAssociation_statics<X>::_UserDeviceAssociationChanged UserDeviceAssociation_statics<X>::UserDeviceAssociationChanged;

template<typename X> struct statics<UserDeviceAssociation, X> : X, Windows::System::UserDeviceAssociation_statics<void> {
	typedef typename X::root_type UserDeviceAssociation;
};
struct UserDeviceAssociation : generate<UserDeviceAssociation> {};

// IAppMemoryReport
struct IAppMemoryReport_raw : IInspectable {
	virtual STDMETHODIMP _get_PrivateCommitUsage(unsigned __int64 *value);
	virtual STDMETHODIMP _get_PeakPrivateCommitUsage(unsigned __int64 *value);
	virtual STDMETHODIMP _get_TotalCommitUsage(unsigned __int64 *value);
	virtual STDMETHODIMP _get_TotalCommitLimit(unsigned __int64 *value);
};
template<typename X> struct IAppMemoryReport_adaptor : X {
	union {
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IAppMemoryReport_adaptor::PeakPrivateCommitUsage)->_get_PeakPrivateCommitUsage(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} PeakPrivateCommitUsage;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IAppMemoryReport_adaptor::PrivateCommitUsage)->_get_PrivateCommitUsage(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} PrivateCommitUsage;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IAppMemoryReport_adaptor::TotalCommitLimit)->_get_TotalCommitLimit(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} TotalCommitLimit;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IAppMemoryReport_adaptor::TotalCommitUsage)->_get_TotalCommitUsage(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} TotalCommitUsage;
	};
	IAppMemoryReport_adaptor() {}
};
template<typename X> struct adapt<IAppMemoryReport, X> : Windows::System::IAppMemoryReport_adaptor<X> { typedef adapt IAppMemoryReport; };
struct IAppMemoryReport : IAppMemoryReport_raw, generate<IAppMemoryReport> {};

// IAppMemoryReport2
struct IAppMemoryReport2_raw : IInspectable {
	virtual STDMETHODIMP _get_ExpectedTotalCommitLimit(unsigned __int64 *value);
};
template<typename X> struct IAppMemoryReport2_adaptor : X {
	union {
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IAppMemoryReport2_adaptor::ExpectedTotalCommitLimit)->_get_ExpectedTotalCommitLimit(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} ExpectedTotalCommitLimit;
	};
	IAppMemoryReport2_adaptor() {}
};
template<typename X> struct adapt<IAppMemoryReport2, X> : Windows::System::IAppMemoryReport2_adaptor<X> { typedef adapt IAppMemoryReport2; };
struct IAppMemoryReport2 : IAppMemoryReport2_raw, generate<IAppMemoryReport2> {};

// IProcessMemoryReport
struct IProcessMemoryReport_raw : IInspectable {
	virtual STDMETHODIMP _get_PrivateWorkingSetUsage(unsigned __int64 *value);
	virtual STDMETHODIMP _get_TotalWorkingSetUsage(unsigned __int64 *value);
};
template<typename X> struct IProcessMemoryReport_adaptor : X {
	union {
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IProcessMemoryReport_adaptor::PrivateWorkingSetUsage)->_get_PrivateWorkingSetUsage(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} PrivateWorkingSetUsage;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IProcessMemoryReport_adaptor::TotalWorkingSetUsage)->_get_TotalWorkingSetUsage(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} TotalWorkingSetUsage;
	};
	IProcessMemoryReport_adaptor() {}
};
template<typename X> struct adapt<IProcessMemoryReport, X> : Windows::System::IProcessMemoryReport_adaptor<X> { typedef adapt IProcessMemoryReport; };
struct IProcessMemoryReport : IProcessMemoryReport_raw, generate<IProcessMemoryReport> {};

// IAppMemoryUsageLimitChangingEventArgs
struct IAppMemoryUsageLimitChangingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_OldLimit(unsigned __int64 *value);
	virtual STDMETHODIMP _get_NewLimit(unsigned __int64 *value);
};
template<typename X> struct IAppMemoryUsageLimitChangingEventArgs_adaptor : X {
	union {
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IAppMemoryUsageLimitChangingEventArgs_adaptor::NewLimit)->_get_NewLimit(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} NewLimit;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IAppMemoryUsageLimitChangingEventArgs_adaptor::OldLimit)->_get_OldLimit(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} OldLimit;
	};
	IAppMemoryUsageLimitChangingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IAppMemoryUsageLimitChangingEventArgs, X> : Windows::System::IAppMemoryUsageLimitChangingEventArgs_adaptor<X> { typedef adapt IAppMemoryUsageLimitChangingEventArgs; };
struct IAppMemoryUsageLimitChangingEventArgs : IAppMemoryUsageLimitChangingEventArgs_raw, generate<IAppMemoryUsageLimitChangingEventArgs> {};

// AppMemoryUsageLimitChangingEventArgs
template<typename X> struct statics<AppMemoryUsageLimitChangingEventArgs, X> : X {
	typedef typename X::root_type AppMemoryUsageLimitChangingEventArgs;
};
struct AppMemoryUsageLimitChangingEventArgs : generate<AppMemoryUsageLimitChangingEventArgs> {};

// IMemoryManagerStatics
struct IMemoryManagerStatics : IInspectable {
	virtual STDMETHODIMP _get_AppMemoryUsage(unsigned __int64 *value);
	virtual STDMETHODIMP _get_AppMemoryUsageLimit(unsigned __int64 *value);
	virtual STDMETHODIMP _get_AppMemoryUsageLevel(System::AppMemoryUsageLevel *value);
	virtual STDMETHODIMP _add_AppMemoryUsageIncreased(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_AppMemoryUsageIncreased(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_AppMemoryUsageDecreased(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_AppMemoryUsageDecreased(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_AppMemoryUsageLimitChanging(Foundation::EventHandler<AppMemoryUsageLimitChangingEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_AppMemoryUsageLimitChanging(Foundation::EventRegistrationToken token);
};

// IMemoryManagerStatics2
struct IMemoryManagerStatics2 : IInspectable {
	virtual STDMETHODIMP _GetAppMemoryReport(AppMemoryReport* *memoryReport);
	virtual STDMETHODIMP _GetProcessMemoryReport(ProcessMemoryReport* *memoryReport);
};

// AppMemoryReport
template<typename X> struct statics<AppMemoryReport, X> : X {
	typedef typename X::root_type AppMemoryReport;
};
struct AppMemoryReport : generate<AppMemoryReport> {};

// ProcessMemoryReport
template<typename X> struct statics<ProcessMemoryReport, X> : X {
	typedef typename X::root_type ProcessMemoryReport;
};
struct ProcessMemoryReport : generate<ProcessMemoryReport> {};

// IMemoryManagerStatics3
struct IMemoryManagerStatics3 : IInspectable {
	virtual STDMETHODIMP _TrySetAppMemoryUsageLimit(unsigned __int64 value, bool *result);
};

// IMemoryManagerStatics4
struct IMemoryManagerStatics4 : IInspectable {
	virtual STDMETHODIMP _get_ExpectedAppMemoryUsageLimit(unsigned __int64 *value);
};

// MemoryManager
template<typename> struct MemoryManager_statics {
	static struct _AppMemoryUsage : property {
		unsigned __int64 get() { unsigned __int64 value; hrcheck(get_activation_factory<MemoryManager, IMemoryManagerStatics>()->_get_AppMemoryUsage(&value)); return value; }
		unsigned __int64 operator()() { return get(); }
		operator unsigned __int64 () { return get(); }
	} AppMemoryUsage;
	static struct _AppMemoryUsageLevel : property {
		System::AppMemoryUsageLevel get() { System::AppMemoryUsageLevel value; hrcheck(get_activation_factory<MemoryManager, IMemoryManagerStatics>()->_get_AppMemoryUsageLevel(&value)); return value; }
		System::AppMemoryUsageLevel operator()() { return get(); }
		operator System::AppMemoryUsageLevel () { return get(); }
	} AppMemoryUsageLevel;
	static struct _AppMemoryUsageLimit : property {
		unsigned __int64 get() { unsigned __int64 value; hrcheck(get_activation_factory<MemoryManager, IMemoryManagerStatics>()->_get_AppMemoryUsageLimit(&value)); return value; }
		unsigned __int64 operator()() { return get(); }
		operator unsigned __int64 () { return get(); }
	} AppMemoryUsageLimit;
	static struct _AppMemoryUsageDecreased : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<MemoryManager, IMemoryManagerStatics>()->_add_AppMemoryUsageDecreased(to_abi(handler), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<MemoryManager, IMemoryManagerStatics>()->_remove_AppMemoryUsageDecreased(token)); }
	} AppMemoryUsageDecreased;
	static struct _AppMemoryUsageIncreased : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<MemoryManager, IMemoryManagerStatics>()->_add_AppMemoryUsageIncreased(to_abi(handler), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<MemoryManager, IMemoryManagerStatics>()->_remove_AppMemoryUsageIncreased(token)); }
	} AppMemoryUsageIncreased;
	static struct _AppMemoryUsageLimitChanging : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<AppMemoryUsageLimitChangingEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<MemoryManager, IMemoryManagerStatics>()->_add_AppMemoryUsageLimitChanging(to_abi(handler), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<MemoryManager, IMemoryManagerStatics>()->_remove_AppMemoryUsageLimitChanging(token)); }
	} AppMemoryUsageLimitChanging;
	static struct _ExpectedAppMemoryUsageLimit : property {
		unsigned __int64 get() { unsigned __int64 value; hrcheck(get_activation_factory<MemoryManager, IMemoryManagerStatics4>()->_get_ExpectedAppMemoryUsageLimit(&value)); return value; }
		unsigned __int64 operator()() { return get(); }
		operator unsigned __int64 () { return get(); }
	} ExpectedAppMemoryUsageLimit;
	static bool TrySetAppMemoryUsageLimit(unsigned __int64 value) { bool result; hrcheck(get_activation_factory<MemoryManager, IMemoryManagerStatics3>()->_TrySetAppMemoryUsageLimit(value, &result)); return result; }
	static ptr<AppMemoryReport> GetAppMemoryReport() { AppMemoryReport* memoryReport; hrcheck(get_activation_factory<MemoryManager, IMemoryManagerStatics2>()->_GetAppMemoryReport(&memoryReport)); return from_abi(memoryReport); }
	static ptr<ProcessMemoryReport> GetProcessMemoryReport() { ProcessMemoryReport* memoryReport; hrcheck(get_activation_factory<MemoryManager, IMemoryManagerStatics2>()->_GetProcessMemoryReport(&memoryReport)); return from_abi(memoryReport); }
};
template<typename X> typename MemoryManager_statics<X>::_AppMemoryUsage MemoryManager_statics<X>::AppMemoryUsage;
template<typename X> typename MemoryManager_statics<X>::_AppMemoryUsageLevel MemoryManager_statics<X>::AppMemoryUsageLevel;
template<typename X> typename MemoryManager_statics<X>::_AppMemoryUsageLimit MemoryManager_statics<X>::AppMemoryUsageLimit;
template<typename X> typename MemoryManager_statics<X>::_AppMemoryUsageDecreased MemoryManager_statics<X>::AppMemoryUsageDecreased;
template<typename X> typename MemoryManager_statics<X>::_AppMemoryUsageIncreased MemoryManager_statics<X>::AppMemoryUsageIncreased;
template<typename X> typename MemoryManager_statics<X>::_AppMemoryUsageLimitChanging MemoryManager_statics<X>::AppMemoryUsageLimitChanging;
template<typename X> typename MemoryManager_statics<X>::_ExpectedAppMemoryUsageLimit MemoryManager_statics<X>::ExpectedAppMemoryUsageLimit;

template<typename X> struct statics<MemoryManager, X> : X, Windows::System::MemoryManager_statics<void> {
	typedef typename X::root_type MemoryManager;
};
struct MemoryManager : generate<MemoryManager> {};

// IProtocolForResultsOperation
struct IProtocolForResultsOperation_raw : IInspectable {
	virtual STDMETHODIMP _ReportCompleted(Foundation::Collections::ValueSet* data);
};
template<typename X> struct IProtocolForResultsOperation_adaptor : X {
	void ReportCompleted(pptr<Foundation::Collections::ValueSet> data) { hrcheck(X::get()->_ReportCompleted(data)); }
};
template<typename X> struct adapt<IProtocolForResultsOperation, X> : Windows::System::IProtocolForResultsOperation_adaptor<X> { typedef adapt IProtocolForResultsOperation; };
struct IProtocolForResultsOperation : IProtocolForResultsOperation_raw, generate<IProtocolForResultsOperation> {};

// ProtocolForResultsOperation
template<typename X> struct statics<ProtocolForResultsOperation, X> : X {
	typedef typename X::root_type ProtocolForResultsOperation;
};
struct ProtocolForResultsOperation : generate<ProtocolForResultsOperation> {};

// IAppDiagnosticInfoStatics
struct IAppDiagnosticInfoStatics : IInspectable {
	virtual STDMETHODIMP _RequestInfoAsync(Foundation::IAsyncOperation<Foundation::Collections::IVector<AppDiagnosticInfo*>*>* *operation);
};

// IAppDiagnosticInfoStatics2
struct IAppDiagnosticInfoStatics2 : IInspectable {
	virtual STDMETHODIMP _CreateWatcher(AppDiagnosticInfoWatcher* *watcher);
	virtual STDMETHODIMP _RequestAccessAsync(Foundation::IAsyncOperation<DiagnosticAccessStatus>* *operation);
	virtual STDMETHODIMP _RequestInfoForPackageAsync(HSTRING packageFamilyName, Foundation::IAsyncOperation<Foundation::Collections::IVector<AppDiagnosticInfo*>*>* *operation);
	virtual STDMETHODIMP _RequestInfoForAppAsync(Foundation::IAsyncOperation<Foundation::Collections::IVector<AppDiagnosticInfo*>*>* *operation);
	virtual STDMETHODIMP _RequestInfoForAppUserModelId(HSTRING appUserModelId, Foundation::IAsyncOperation<Foundation::Collections::IVector<AppDiagnosticInfo*>*>* *operation);
};

// IAppDiagnosticInfo3
struct IAppDiagnosticInfo3_raw : IInspectable {
	virtual STDMETHODIMP _LaunchAsync(Foundation::IAsyncOperation<AppActivationResult*>* *operation);
};
template<typename X> struct IAppDiagnosticInfo3_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<AppActivationResult>>> LaunchAsync() { Foundation::IAsyncOperation<AppActivationResult*>* operation; hrcheck(X::get()->_LaunchAsync(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IAppDiagnosticInfo3, X> : Windows::System::IAppDiagnosticInfo3_adaptor<X> { typedef adapt IAppDiagnosticInfo3; };
struct IAppDiagnosticInfo3 : IAppDiagnosticInfo3_raw, generate<IAppDiagnosticInfo3> {};

// IAppDiagnosticInfo2
struct IAppDiagnosticInfo2_raw : IInspectable {
	virtual STDMETHODIMP _GetResourceGroups(Foundation::Collections::IVector<AppResourceGroupInfo*>* *result);
	virtual STDMETHODIMP _CreateResourceGroupWatcher(AppResourceGroupInfoWatcher* *result);
};
template<typename X> struct IAppDiagnosticInfo2_adaptor : X {
	ptr<Foundation::Collections::IVector<ptr<AppResourceGroupInfo>>> GetResourceGroups() { Foundation::Collections::IVector<AppResourceGroupInfo*>* result; hrcheck(X::get()->_GetResourceGroups(&result)); return from_abi(result); }
	ptr<AppResourceGroupInfoWatcher> CreateResourceGroupWatcher() { AppResourceGroupInfoWatcher* result; hrcheck(X::get()->_CreateResourceGroupWatcher(&result)); return from_abi(result); }
};
template<typename X> struct adapt<IAppDiagnosticInfo2, X> : Windows::System::IAppDiagnosticInfo2_adaptor<X> { typedef adapt IAppDiagnosticInfo2; };
struct IAppDiagnosticInfo2 : IAppDiagnosticInfo2_raw, generate<IAppDiagnosticInfo2> {};

// IAppDiagnosticInfo
struct IAppDiagnosticInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_AppInfo(ApplicationModel::AppInfo* *value);
};
template<typename X> struct IAppDiagnosticInfo_adaptor : X {
	union {
		struct : property {
			ptr<ApplicationModel::AppInfo> get() { ApplicationModel::AppInfo* value; hrcheck(enc(&IAppDiagnosticInfo_adaptor::AppInfo)->_get_AppInfo(&value)); return from_abi(value); }
			ptr<ApplicationModel::AppInfo> operator()() { return get(); }
			operator ptr<ApplicationModel::AppInfo> () { return get(); }
			ptr<ApplicationModel::AppInfo> operator->() { return get(); }
		} AppInfo;
	};
	IAppDiagnosticInfo_adaptor() {}
};
template<typename X> struct adapt<IAppDiagnosticInfo, X> : Windows::System::IAppDiagnosticInfo_adaptor<X> { typedef adapt IAppDiagnosticInfo; };
struct IAppDiagnosticInfo : IAppDiagnosticInfo_raw, generate<IAppDiagnosticInfo> {};

// AppDiagnosticInfo
template<typename> struct AppDiagnosticInfo_statics {
	static ptr<AppDiagnosticInfoWatcher> CreateWatcher() { AppDiagnosticInfoWatcher* watcher; hrcheck(get_activation_factory<AppDiagnosticInfo, IAppDiagnosticInfoStatics2>()->_CreateWatcher(&watcher)); return from_abi(watcher); }
	static ptr<Foundation::IAsyncOperation<DiagnosticAccessStatus>> RequestAccessAsync() { Foundation::IAsyncOperation<DiagnosticAccessStatus>* operation; hrcheck(get_activation_factory<AppDiagnosticInfo, IAppDiagnosticInfoStatics2>()->_RequestAccessAsync(&operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVector<ptr<AppDiagnosticInfo>>>>> RequestInfoForPackageAsync(hstring_ref packageFamilyName) { Foundation::IAsyncOperation<Foundation::Collections::IVector<AppDiagnosticInfo*>*>* operation; hrcheck(get_activation_factory<AppDiagnosticInfo, IAppDiagnosticInfoStatics2>()->_RequestInfoForPackageAsync(packageFamilyName, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVector<ptr<AppDiagnosticInfo>>>>> RequestInfoForAppAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVector<AppDiagnosticInfo*>*>* operation; hrcheck(get_activation_factory<AppDiagnosticInfo, IAppDiagnosticInfoStatics2>()->_RequestInfoForAppAsync(&operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVector<ptr<AppDiagnosticInfo>>>>> RequestInfoForAppAsync(hstring_ref appUserModelId) { Foundation::IAsyncOperation<Foundation::Collections::IVector<AppDiagnosticInfo*>*>* operation; hrcheck(get_activation_factory<AppDiagnosticInfo, IAppDiagnosticInfoStatics2>()->_RequestInfoForAppUserModelId(appUserModelId, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVector<ptr<AppDiagnosticInfo>>>>> RequestInfoAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVector<AppDiagnosticInfo*>*>* operation; hrcheck(get_activation_factory<AppDiagnosticInfo, IAppDiagnosticInfoStatics>()->_RequestInfoAsync(&operation)); return from_abi(operation); }
};

template<typename X> struct statics<AppDiagnosticInfo, X> : X, Windows::System::AppDiagnosticInfo_statics<void> {
	typedef typename X::root_type AppDiagnosticInfo;
};
struct AppDiagnosticInfo : generate<AppDiagnosticInfo> {};

// IAppDiagnosticInfoWatcher
struct IAppDiagnosticInfoWatcher_raw : IInspectable {
	virtual STDMETHODIMP _add_Added(Foundation::TypedEventHandler<AppDiagnosticInfoWatcher*, AppDiagnosticInfoWatcherEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Added(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Removed(Foundation::TypedEventHandler<AppDiagnosticInfoWatcher*, AppDiagnosticInfoWatcherEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Removed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_EnumerationCompleted(Foundation::TypedEventHandler<AppDiagnosticInfoWatcher*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_EnumerationCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Stopped(Foundation::TypedEventHandler<AppDiagnosticInfoWatcher*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Stopped(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_Status(AppDiagnosticInfoWatcherStatus *value);
	virtual STDMETHODIMP _Start();
	virtual STDMETHODIMP _Stop();
};
template<typename X> struct IAppDiagnosticInfoWatcher_adaptor : X {
	union {
		struct : property {
			AppDiagnosticInfoWatcherStatus get() { AppDiagnosticInfoWatcherStatus value; hrcheck(enc(&IAppDiagnosticInfoWatcher_adaptor::Status)->_get_Status(&value)); return value; }
			AppDiagnosticInfoWatcherStatus operator()() { return get(); }
			operator AppDiagnosticInfoWatcherStatus () { return get(); }
		} Status;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AppDiagnosticInfoWatcher>, ptr<AppDiagnosticInfoWatcherEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppDiagnosticInfoWatcher_adaptor::Added)->_add_Added(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppDiagnosticInfoWatcher_adaptor::Added)->_remove_Added(token)); }
		} Added;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AppDiagnosticInfoWatcher>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppDiagnosticInfoWatcher_adaptor::EnumerationCompleted)->_add_EnumerationCompleted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppDiagnosticInfoWatcher_adaptor::EnumerationCompleted)->_remove_EnumerationCompleted(token)); }
		} EnumerationCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AppDiagnosticInfoWatcher>, ptr<AppDiagnosticInfoWatcherEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppDiagnosticInfoWatcher_adaptor::Removed)->_add_Removed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppDiagnosticInfoWatcher_adaptor::Removed)->_remove_Removed(token)); }
		} Removed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AppDiagnosticInfoWatcher>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppDiagnosticInfoWatcher_adaptor::Stopped)->_add_Stopped(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppDiagnosticInfoWatcher_adaptor::Stopped)->_remove_Stopped(token)); }
		} Stopped;
	};
	void Start() { hrcheck(X::get()->_Start()); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	IAppDiagnosticInfoWatcher_adaptor() {}
};
template<typename X> struct adapt<IAppDiagnosticInfoWatcher, X> : Windows::System::IAppDiagnosticInfoWatcher_adaptor<X> { typedef adapt IAppDiagnosticInfoWatcher; };
struct IAppDiagnosticInfoWatcher : IAppDiagnosticInfoWatcher_raw, generate<IAppDiagnosticInfoWatcher> {};

// AppDiagnosticInfoWatcher
template<typename X> struct statics<AppDiagnosticInfoWatcher, X> : X {
	typedef typename X::root_type AppDiagnosticInfoWatcher;
};
struct AppDiagnosticInfoWatcher : generate<AppDiagnosticInfoWatcher> {};

// IAppActivationResult
struct IAppActivationResult_raw : IInspectable {
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
	virtual STDMETHODIMP _get_AppResourceGroupInfo(System::AppResourceGroupInfo* *value);
};
template<typename X> struct IAppActivationResult_adaptor : X {
	union {
		struct : property {
			ptr<System::AppResourceGroupInfo> get() { System::AppResourceGroupInfo* value; hrcheck(enc(&IAppActivationResult_adaptor::AppResourceGroupInfo)->_get_AppResourceGroupInfo(&value)); return from_abi(value); }
			ptr<System::AppResourceGroupInfo> operator()() { return get(); }
			operator ptr<System::AppResourceGroupInfo> () { return get(); }
			ptr<System::AppResourceGroupInfo> operator->() { return get(); }
		} AppResourceGroupInfo;
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IAppActivationResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
	};
	IAppActivationResult_adaptor() {}
};
template<typename X> struct adapt<IAppActivationResult, X> : Windows::System::IAppActivationResult_adaptor<X> { typedef adapt IAppActivationResult; };
struct IAppActivationResult : IAppActivationResult_raw, generate<IAppActivationResult> {};

// IAppResourceGroupInfo2
struct IAppResourceGroupInfo2_raw : IInspectable {
	virtual STDMETHODIMP _StartSuspendAsync(Foundation::IAsyncOperation<AppExecutionStateChangeResult*>* *operation);
	virtual STDMETHODIMP _StartResumeAsync(Foundation::IAsyncOperation<AppExecutionStateChangeResult*>* *operation);
	virtual STDMETHODIMP _StartTerminateAsync(Foundation::IAsyncOperation<AppExecutionStateChangeResult*>* *operation);
};
template<typename X> struct IAppResourceGroupInfo2_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<AppExecutionStateChangeResult>>> StartSuspendAsync() { Foundation::IAsyncOperation<AppExecutionStateChangeResult*>* operation; hrcheck(X::get()->_StartSuspendAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<AppExecutionStateChangeResult>>> StartResumeAsync() { Foundation::IAsyncOperation<AppExecutionStateChangeResult*>* operation; hrcheck(X::get()->_StartResumeAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<AppExecutionStateChangeResult>>> StartTerminateAsync() { Foundation::IAsyncOperation<AppExecutionStateChangeResult*>* operation; hrcheck(X::get()->_StartTerminateAsync(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IAppResourceGroupInfo2, X> : Windows::System::IAppResourceGroupInfo2_adaptor<X> { typedef adapt IAppResourceGroupInfo2; };
struct IAppResourceGroupInfo2 : IAppResourceGroupInfo2_raw, generate<IAppResourceGroupInfo2> {};

// IAppResourceGroupInfo
struct IAppResourceGroupInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_InstanceId(Platform::Guid *value);
	virtual STDMETHODIMP _get_IsShared(bool *value);
	virtual STDMETHODIMP _GetBackgroundTaskReports(Foundation::Collections::IVector<AppResourceGroupBackgroundTaskReport*>* *result);
	virtual STDMETHODIMP _GetMemoryReport(AppResourceGroupMemoryReport* *result);
	virtual STDMETHODIMP _GetProcessDiagnosticInfos(Foundation::Collections::IVector<Diagnostics::ProcessDiagnosticInfo*>* *result);
	virtual STDMETHODIMP _GetStateReport(AppResourceGroupStateReport* *result);
};
template<typename X> struct IAppResourceGroupInfo_adaptor : X {
	union {
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IAppResourceGroupInfo_adaptor::InstanceId)->_get_InstanceId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} InstanceId;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppResourceGroupInfo_adaptor::IsShared)->_get_IsShared(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsShared;
	};
	ptr<Foundation::Collections::IVector<ptr<AppResourceGroupBackgroundTaskReport>>> GetBackgroundTaskReports() { Foundation::Collections::IVector<AppResourceGroupBackgroundTaskReport*>* result; hrcheck(X::get()->_GetBackgroundTaskReports(&result)); return from_abi(result); }
	ptr<AppResourceGroupMemoryReport> GetMemoryReport() { AppResourceGroupMemoryReport* result; hrcheck(X::get()->_GetMemoryReport(&result)); return from_abi(result); }
	ptr<Foundation::Collections::IVector<ptr<Diagnostics::ProcessDiagnosticInfo>>> GetProcessDiagnosticInfos() { Foundation::Collections::IVector<Diagnostics::ProcessDiagnosticInfo*>* result; hrcheck(X::get()->_GetProcessDiagnosticInfos(&result)); return from_abi(result); }
	ptr<AppResourceGroupStateReport> GetStateReport() { AppResourceGroupStateReport* result; hrcheck(X::get()->_GetStateReport(&result)); return from_abi(result); }
	IAppResourceGroupInfo_adaptor() {}
};
template<typename X> struct adapt<IAppResourceGroupInfo, X> : Windows::System::IAppResourceGroupInfo_adaptor<X> { typedef adapt IAppResourceGroupInfo; };
struct IAppResourceGroupInfo : IAppResourceGroupInfo_raw, generate<IAppResourceGroupInfo> {};

// AppResourceGroupInfo
template<typename X> struct statics<AppResourceGroupInfo, X> : X {
	typedef typename X::root_type AppResourceGroupInfo;
};
struct AppResourceGroupInfo : generate<AppResourceGroupInfo> {};

// AppActivationResult
template<typename X> struct statics<AppActivationResult, X> : X {
	typedef typename X::root_type AppActivationResult;
};
struct AppActivationResult : generate<AppActivationResult> {};

// IAppResourceGroupInfoWatcher
struct IAppResourceGroupInfoWatcher_raw : IInspectable {
	virtual STDMETHODIMP _add_Added(Foundation::TypedEventHandler<AppResourceGroupInfoWatcher*, AppResourceGroupInfoWatcherEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Added(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Removed(Foundation::TypedEventHandler<AppResourceGroupInfoWatcher*, AppResourceGroupInfoWatcherEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Removed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_EnumerationCompleted(Foundation::TypedEventHandler<AppResourceGroupInfoWatcher*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_EnumerationCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Stopped(Foundation::TypedEventHandler<AppResourceGroupInfoWatcher*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Stopped(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ExecutionStateChanged(Foundation::TypedEventHandler<AppResourceGroupInfoWatcher*, AppResourceGroupInfoWatcherExecutionStateChangedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ExecutionStateChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_Status(AppResourceGroupInfoWatcherStatus *status);
	virtual STDMETHODIMP _Start();
	virtual STDMETHODIMP _Stop();
};
template<typename X> struct IAppResourceGroupInfoWatcher_adaptor : X {
	union {
		struct : property {
			AppResourceGroupInfoWatcherStatus get() { AppResourceGroupInfoWatcherStatus status; hrcheck(enc(&IAppResourceGroupInfoWatcher_adaptor::Status)->_get_Status(&status)); return status; }
			AppResourceGroupInfoWatcherStatus operator()() { return get(); }
			operator AppResourceGroupInfoWatcherStatus () { return get(); }
		} Status;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AppResourceGroupInfoWatcher>, ptr<AppResourceGroupInfoWatcherEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppResourceGroupInfoWatcher_adaptor::Added)->_add_Added(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppResourceGroupInfoWatcher_adaptor::Added)->_remove_Added(token)); }
		} Added;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AppResourceGroupInfoWatcher>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppResourceGroupInfoWatcher_adaptor::EnumerationCompleted)->_add_EnumerationCompleted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppResourceGroupInfoWatcher_adaptor::EnumerationCompleted)->_remove_EnumerationCompleted(token)); }
		} EnumerationCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AppResourceGroupInfoWatcher>, ptr<AppResourceGroupInfoWatcherExecutionStateChangedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppResourceGroupInfoWatcher_adaptor::ExecutionStateChanged)->_add_ExecutionStateChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppResourceGroupInfoWatcher_adaptor::ExecutionStateChanged)->_remove_ExecutionStateChanged(token)); }
		} ExecutionStateChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AppResourceGroupInfoWatcher>, ptr<AppResourceGroupInfoWatcherEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppResourceGroupInfoWatcher_adaptor::Removed)->_add_Removed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppResourceGroupInfoWatcher_adaptor::Removed)->_remove_Removed(token)); }
		} Removed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AppResourceGroupInfoWatcher>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppResourceGroupInfoWatcher_adaptor::Stopped)->_add_Stopped(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppResourceGroupInfoWatcher_adaptor::Stopped)->_remove_Stopped(token)); }
		} Stopped;
	};
	void Start() { hrcheck(X::get()->_Start()); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	IAppResourceGroupInfoWatcher_adaptor() {}
};
template<typename X> struct adapt<IAppResourceGroupInfoWatcher, X> : Windows::System::IAppResourceGroupInfoWatcher_adaptor<X> { typedef adapt IAppResourceGroupInfoWatcher; };
struct IAppResourceGroupInfoWatcher : IAppResourceGroupInfoWatcher_raw, generate<IAppResourceGroupInfoWatcher> {};

// AppResourceGroupInfoWatcher
template<typename X> struct statics<AppResourceGroupInfoWatcher, X> : X {
	typedef typename X::root_type AppResourceGroupInfoWatcher;
};
struct AppResourceGroupInfoWatcher : generate<AppResourceGroupInfoWatcher> {};

// IAppDiagnosticInfoWatcherEventArgs
struct IAppDiagnosticInfoWatcherEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_AppDiagnosticInfo(System::AppDiagnosticInfo* *value);
};
template<typename X> struct IAppDiagnosticInfoWatcherEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<System::AppDiagnosticInfo> get() { System::AppDiagnosticInfo* value; hrcheck(enc(&IAppDiagnosticInfoWatcherEventArgs_adaptor::AppDiagnosticInfo)->_get_AppDiagnosticInfo(&value)); return from_abi(value); }
			ptr<System::AppDiagnosticInfo> operator()() { return get(); }
			operator ptr<System::AppDiagnosticInfo> () { return get(); }
			ptr<System::AppDiagnosticInfo> operator->() { return get(); }
		} AppDiagnosticInfo;
	};
	IAppDiagnosticInfoWatcherEventArgs_adaptor() {}
};
template<typename X> struct adapt<IAppDiagnosticInfoWatcherEventArgs, X> : Windows::System::IAppDiagnosticInfoWatcherEventArgs_adaptor<X> { typedef adapt IAppDiagnosticInfoWatcherEventArgs; };
struct IAppDiagnosticInfoWatcherEventArgs : IAppDiagnosticInfoWatcherEventArgs_raw, generate<IAppDiagnosticInfoWatcherEventArgs> {};

// AppDiagnosticInfoWatcherEventArgs
template<typename X> struct statics<AppDiagnosticInfoWatcherEventArgs, X> : X {
	typedef typename X::root_type AppDiagnosticInfoWatcherEventArgs;
};
struct AppDiagnosticInfoWatcherEventArgs : generate<AppDiagnosticInfoWatcherEventArgs> {};

// IAppExecutionStateChangeResult
struct IAppExecutionStateChangeResult_raw : IInspectable {
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IAppExecutionStateChangeResult_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IAppExecutionStateChangeResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
	};
	IAppExecutionStateChangeResult_adaptor() {}
};
template<typename X> struct adapt<IAppExecutionStateChangeResult, X> : Windows::System::IAppExecutionStateChangeResult_adaptor<X> { typedef adapt IAppExecutionStateChangeResult; };
struct IAppExecutionStateChangeResult : IAppExecutionStateChangeResult_raw, generate<IAppExecutionStateChangeResult> {};

// AppExecutionStateChangeResult
template<typename X> struct statics<AppExecutionStateChangeResult, X> : X {
	typedef typename X::root_type AppExecutionStateChangeResult;
};
struct AppExecutionStateChangeResult : generate<AppExecutionStateChangeResult> {};

// IAppResourceGroupBackgroundTaskReport
struct IAppResourceGroupBackgroundTaskReport_raw : IInspectable {
	virtual STDMETHODIMP _get_TaskId(Platform::Guid *value);
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_Trigger(HSTRING *value);
	virtual STDMETHODIMP _get_EntryPoint(HSTRING *value);
};
template<typename X> struct IAppResourceGroupBackgroundTaskReport_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppResourceGroupBackgroundTaskReport_adaptor::EntryPoint)->_get_EntryPoint(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} EntryPoint;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppResourceGroupBackgroundTaskReport_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IAppResourceGroupBackgroundTaskReport_adaptor::TaskId)->_get_TaskId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} TaskId;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppResourceGroupBackgroundTaskReport_adaptor::Trigger)->_get_Trigger(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Trigger;
	};
	IAppResourceGroupBackgroundTaskReport_adaptor() {}
};
template<typename X> struct adapt<IAppResourceGroupBackgroundTaskReport, X> : Windows::System::IAppResourceGroupBackgroundTaskReport_adaptor<X> { typedef adapt IAppResourceGroupBackgroundTaskReport; };
struct IAppResourceGroupBackgroundTaskReport : IAppResourceGroupBackgroundTaskReport_raw, generate<IAppResourceGroupBackgroundTaskReport> {};

// AppResourceGroupBackgroundTaskReport
template<typename X> struct statics<AppResourceGroupBackgroundTaskReport, X> : X {
	typedef typename X::root_type AppResourceGroupBackgroundTaskReport;
};
struct AppResourceGroupBackgroundTaskReport : generate<AppResourceGroupBackgroundTaskReport> {};

// IAppResourceGroupMemoryReport
struct IAppResourceGroupMemoryReport_raw : IInspectable {
	virtual STDMETHODIMP _get_CommitUsageLimit(unsigned __int64 *value);
	virtual STDMETHODIMP _get_CommitUsageLevel(AppMemoryUsageLevel *value);
	virtual STDMETHODIMP _get_PrivateCommitUsage(unsigned __int64 *value);
	virtual STDMETHODIMP _get_TotalCommitUsage(unsigned __int64 *value);
};
template<typename X> struct IAppResourceGroupMemoryReport_adaptor : X {
	union {
		struct : property {
			AppMemoryUsageLevel get() { AppMemoryUsageLevel value; hrcheck(enc(&IAppResourceGroupMemoryReport_adaptor::CommitUsageLevel)->_get_CommitUsageLevel(&value)); return value; }
			AppMemoryUsageLevel operator()() { return get(); }
			operator AppMemoryUsageLevel () { return get(); }
		} CommitUsageLevel;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IAppResourceGroupMemoryReport_adaptor::CommitUsageLimit)->_get_CommitUsageLimit(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} CommitUsageLimit;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IAppResourceGroupMemoryReport_adaptor::PrivateCommitUsage)->_get_PrivateCommitUsage(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} PrivateCommitUsage;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IAppResourceGroupMemoryReport_adaptor::TotalCommitUsage)->_get_TotalCommitUsage(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} TotalCommitUsage;
	};
	IAppResourceGroupMemoryReport_adaptor() {}
};
template<typename X> struct adapt<IAppResourceGroupMemoryReport, X> : Windows::System::IAppResourceGroupMemoryReport_adaptor<X> { typedef adapt IAppResourceGroupMemoryReport; };
struct IAppResourceGroupMemoryReport : IAppResourceGroupMemoryReport_raw, generate<IAppResourceGroupMemoryReport> {};

// AppResourceGroupMemoryReport
template<typename X> struct statics<AppResourceGroupMemoryReport, X> : X {
	typedef typename X::root_type AppResourceGroupMemoryReport;
};
struct AppResourceGroupMemoryReport : generate<AppResourceGroupMemoryReport> {};

// IAppResourceGroupStateReport
struct IAppResourceGroupStateReport_raw : IInspectable {
	virtual STDMETHODIMP _get_ExecutionState(AppResourceGroupExecutionState *value);
	virtual STDMETHODIMP _get_EnergyQuotaState(AppResourceGroupEnergyQuotaState *value);
};
template<typename X> struct IAppResourceGroupStateReport_adaptor : X {
	union {
		struct : property {
			AppResourceGroupEnergyQuotaState get() { AppResourceGroupEnergyQuotaState value; hrcheck(enc(&IAppResourceGroupStateReport_adaptor::EnergyQuotaState)->_get_EnergyQuotaState(&value)); return value; }
			AppResourceGroupEnergyQuotaState operator()() { return get(); }
			operator AppResourceGroupEnergyQuotaState () { return get(); }
		} EnergyQuotaState;
		struct : property {
			AppResourceGroupExecutionState get() { AppResourceGroupExecutionState value; hrcheck(enc(&IAppResourceGroupStateReport_adaptor::ExecutionState)->_get_ExecutionState(&value)); return value; }
			AppResourceGroupExecutionState operator()() { return get(); }
			operator AppResourceGroupExecutionState () { return get(); }
		} ExecutionState;
	};
	IAppResourceGroupStateReport_adaptor() {}
};
template<typename X> struct adapt<IAppResourceGroupStateReport, X> : Windows::System::IAppResourceGroupStateReport_adaptor<X> { typedef adapt IAppResourceGroupStateReport; };
struct IAppResourceGroupStateReport : IAppResourceGroupStateReport_raw, generate<IAppResourceGroupStateReport> {};

// AppResourceGroupStateReport
template<typename X> struct statics<AppResourceGroupStateReport, X> : X {
	typedef typename X::root_type AppResourceGroupStateReport;
};
struct AppResourceGroupStateReport : generate<AppResourceGroupStateReport> {};

// IAppResourceGroupInfoWatcherEventArgs
struct IAppResourceGroupInfoWatcherEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_AppDiagnosticInfos(Foundation::Collections::IVectorView<AppDiagnosticInfo*>* *value);
	virtual STDMETHODIMP _get_AppResourceGroupInfo(System::AppResourceGroupInfo* *value);
};
template<typename X> struct IAppResourceGroupInfoWatcherEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<AppDiagnosticInfo>>> get() { Foundation::Collections::IVectorView<AppDiagnosticInfo*>* value; hrcheck(enc(&IAppResourceGroupInfoWatcherEventArgs_adaptor::AppDiagnosticInfos)->_get_AppDiagnosticInfos(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<AppDiagnosticInfo>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<AppDiagnosticInfo>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<AppDiagnosticInfo>>> operator->() { return get(); }
		} AppDiagnosticInfos;
		struct : property {
			ptr<System::AppResourceGroupInfo> get() { System::AppResourceGroupInfo* value; hrcheck(enc(&IAppResourceGroupInfoWatcherEventArgs_adaptor::AppResourceGroupInfo)->_get_AppResourceGroupInfo(&value)); return from_abi(value); }
			ptr<System::AppResourceGroupInfo> operator()() { return get(); }
			operator ptr<System::AppResourceGroupInfo> () { return get(); }
			ptr<System::AppResourceGroupInfo> operator->() { return get(); }
		} AppResourceGroupInfo;
	};
	IAppResourceGroupInfoWatcherEventArgs_adaptor() {}
};
template<typename X> struct adapt<IAppResourceGroupInfoWatcherEventArgs, X> : Windows::System::IAppResourceGroupInfoWatcherEventArgs_adaptor<X> { typedef adapt IAppResourceGroupInfoWatcherEventArgs; };
struct IAppResourceGroupInfoWatcherEventArgs : IAppResourceGroupInfoWatcherEventArgs_raw, generate<IAppResourceGroupInfoWatcherEventArgs> {};

// AppResourceGroupInfoWatcherEventArgs
template<typename X> struct statics<AppResourceGroupInfoWatcherEventArgs, X> : X {
	typedef typename X::root_type AppResourceGroupInfoWatcherEventArgs;
};
struct AppResourceGroupInfoWatcherEventArgs : generate<AppResourceGroupInfoWatcherEventArgs> {};

// IAppResourceGroupInfoWatcherExecutionStateChangedEventArgs
struct IAppResourceGroupInfoWatcherExecutionStateChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_AppDiagnosticInfos(Foundation::Collections::IVectorView<AppDiagnosticInfo*>* *value);
	virtual STDMETHODIMP _get_AppResourceGroupInfo(System::AppResourceGroupInfo* *value);
};
template<typename X> struct IAppResourceGroupInfoWatcherExecutionStateChangedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<AppDiagnosticInfo>>> get() { Foundation::Collections::IVectorView<AppDiagnosticInfo*>* value; hrcheck(enc(&IAppResourceGroupInfoWatcherExecutionStateChangedEventArgs_adaptor::AppDiagnosticInfos)->_get_AppDiagnosticInfos(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<AppDiagnosticInfo>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<AppDiagnosticInfo>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<AppDiagnosticInfo>>> operator->() { return get(); }
		} AppDiagnosticInfos;
		struct : property {
			ptr<System::AppResourceGroupInfo> get() { System::AppResourceGroupInfo* value; hrcheck(enc(&IAppResourceGroupInfoWatcherExecutionStateChangedEventArgs_adaptor::AppResourceGroupInfo)->_get_AppResourceGroupInfo(&value)); return from_abi(value); }
			ptr<System::AppResourceGroupInfo> operator()() { return get(); }
			operator ptr<System::AppResourceGroupInfo> () { return get(); }
			ptr<System::AppResourceGroupInfo> operator->() { return get(); }
		} AppResourceGroupInfo;
	};
	IAppResourceGroupInfoWatcherExecutionStateChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IAppResourceGroupInfoWatcherExecutionStateChangedEventArgs, X> : Windows::System::IAppResourceGroupInfoWatcherExecutionStateChangedEventArgs_adaptor<X> { typedef adapt IAppResourceGroupInfoWatcherExecutionStateChangedEventArgs; };
struct IAppResourceGroupInfoWatcherExecutionStateChangedEventArgs : IAppResourceGroupInfoWatcherExecutionStateChangedEventArgs_raw, generate<IAppResourceGroupInfoWatcherExecutionStateChangedEventArgs> {};

// AppResourceGroupInfoWatcherExecutionStateChangedEventArgs
template<typename X> struct statics<AppResourceGroupInfoWatcherExecutionStateChangedEventArgs, X> : X {
	typedef typename X::root_type AppResourceGroupInfoWatcherExecutionStateChangedEventArgs;
};
struct AppResourceGroupInfoWatcherExecutionStateChangedEventArgs : generate<AppResourceGroupInfoWatcherExecutionStateChangedEventArgs> {};

// ILaunchUriResult
struct ILaunchUriResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(LaunchUriStatus *value);
	virtual STDMETHODIMP _get_Result(Foundation::Collections::ValueSet* *value);
};
template<typename X> struct ILaunchUriResult_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::ValueSet> get() { Foundation::Collections::ValueSet* value; hrcheck(enc(&ILaunchUriResult_adaptor::Result)->_get_Result(&value)); return from_abi(value); }
			ptr<Foundation::Collections::ValueSet> operator()() { return get(); }
			operator ptr<Foundation::Collections::ValueSet> () { return get(); }
			ptr<Foundation::Collections::ValueSet> operator->() { return get(); }
		} Result;
		struct : property {
			LaunchUriStatus get() { LaunchUriStatus value; hrcheck(enc(&ILaunchUriResult_adaptor::Status)->_get_Status(&value)); return value; }
			LaunchUriStatus operator()() { return get(); }
			operator LaunchUriStatus () { return get(); }
		} Status;
	};
	ILaunchUriResult_adaptor() {}
};
template<typename X> struct adapt<ILaunchUriResult, X> : Windows::System::ILaunchUriResult_adaptor<X> { typedef adapt ILaunchUriResult; };
struct ILaunchUriResult : ILaunchUriResult_raw, generate<ILaunchUriResult> {};

// LaunchUriResult
template<typename X> struct statics<LaunchUriResult, X> : X {
	typedef typename X::root_type LaunchUriResult;
};
struct LaunchUriResult : generate<LaunchUriResult> {};

// ILauncherUIOptions
struct ILauncherUIOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_InvocationPoint(Foundation::IReference<Foundation::Point>* *value);
	virtual STDMETHODIMP _put_InvocationPoint(Foundation::IReference<Foundation::Point>* value);
	virtual STDMETHODIMP _get_SelectionRect(Foundation::IReference<Foundation::Rect>* *value);
	virtual STDMETHODIMP _put_SelectionRect(Foundation::IReference<Foundation::Rect>* value);
	virtual STDMETHODIMP _get_PreferredPlacement(UI::Popups::Placement *value);
	virtual STDMETHODIMP _put_PreferredPlacement(UI::Popups::Placement value);
};
template<typename X> struct ILauncherUIOptions_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Foundation::Point>> get() { Foundation::IReference<Foundation::Point>* value; hrcheck(enc(&ILauncherUIOptions_adaptor::InvocationPoint)->_get_InvocationPoint(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::Point>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::Point>> () { return get(); }
			ptr<Foundation::IReference<Foundation::Point>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::Point>> value) { hrcheck(enc(&ILauncherUIOptions_adaptor::InvocationPoint)->_put_InvocationPoint(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::Point>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::Point>> value) { put(to_abi(value)); }
		} InvocationPoint;
		struct : property {
			UI::Popups::Placement get() { UI::Popups::Placement value; hrcheck(enc(&ILauncherUIOptions_adaptor::PreferredPlacement)->_get_PreferredPlacement(&value)); return value; }
			UI::Popups::Placement operator()() { return get(); }
			operator UI::Popups::Placement () { return get(); }
			void put(UI::Popups::Placement value) { hrcheck(enc(&ILauncherUIOptions_adaptor::PreferredPlacement)->_put_PreferredPlacement(value)); }
			void operator=(UI::Popups::Placement value) { put(value); }
			void operator()(UI::Popups::Placement value) { put(value); }
		} PreferredPlacement;
		struct : property {
			ptr<Foundation::IReference<Foundation::Rect>> get() { Foundation::IReference<Foundation::Rect>* value; hrcheck(enc(&ILauncherUIOptions_adaptor::SelectionRect)->_get_SelectionRect(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::Rect>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::Rect>> () { return get(); }
			ptr<Foundation::IReference<Foundation::Rect>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::Rect>> value) { hrcheck(enc(&ILauncherUIOptions_adaptor::SelectionRect)->_put_SelectionRect(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::Rect>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::Rect>> value) { put(to_abi(value)); }
		} SelectionRect;
	};
	ILauncherUIOptions_adaptor() {}
};
template<typename X> struct adapt<ILauncherUIOptions, X> : Windows::System::ILauncherUIOptions_adaptor<X> { typedef adapt ILauncherUIOptions; };
struct ILauncherUIOptions : ILauncherUIOptions_raw, generate<ILauncherUIOptions> {};

// LauncherUIOptions
template<typename X> struct statics<LauncherUIOptions, X> : X {
	typedef typename X::root_type LauncherUIOptions;
};
struct LauncherUIOptions : generate<LauncherUIOptions> {};

// ILauncherOptions
struct ILauncherOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_TreatAsUntrusted(bool *value);
	virtual STDMETHODIMP _put_TreatAsUntrusted(bool value);
	virtual STDMETHODIMP _get_DisplayApplicationPicker(bool *value);
	virtual STDMETHODIMP _put_DisplayApplicationPicker(bool value);
	virtual STDMETHODIMP _get_UI(LauncherUIOptions* *value);
	virtual STDMETHODIMP _get_PreferredApplicationPackageFamilyName(HSTRING *value);
	virtual STDMETHODIMP _put_PreferredApplicationPackageFamilyName(HSTRING value);
	virtual STDMETHODIMP _get_PreferredApplicationDisplayName(HSTRING *value);
	virtual STDMETHODIMP _put_PreferredApplicationDisplayName(HSTRING value);
	virtual STDMETHODIMP _get_FallbackUri(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_FallbackUri(Foundation::Uri* value);
	virtual STDMETHODIMP _get_ContentType(HSTRING *value);
	virtual STDMETHODIMP _put_ContentType(HSTRING value);
};
template<typename X> struct ILauncherOptions_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ILauncherOptions_adaptor::ContentType)->_get_ContentType(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ILauncherOptions_adaptor::ContentType)->_put_ContentType(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ContentType;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILauncherOptions_adaptor::DisplayApplicationPicker)->_get_DisplayApplicationPicker(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ILauncherOptions_adaptor::DisplayApplicationPicker)->_put_DisplayApplicationPicker(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} DisplayApplicationPicker;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&ILauncherOptions_adaptor::FallbackUri)->_get_FallbackUri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&ILauncherOptions_adaptor::FallbackUri)->_put_FallbackUri(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} FallbackUri;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ILauncherOptions_adaptor::PreferredApplicationDisplayName)->_get_PreferredApplicationDisplayName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ILauncherOptions_adaptor::PreferredApplicationDisplayName)->_put_PreferredApplicationDisplayName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PreferredApplicationDisplayName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ILauncherOptions_adaptor::PreferredApplicationPackageFamilyName)->_get_PreferredApplicationPackageFamilyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ILauncherOptions_adaptor::PreferredApplicationPackageFamilyName)->_put_PreferredApplicationPackageFamilyName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PreferredApplicationPackageFamilyName;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILauncherOptions_adaptor::TreatAsUntrusted)->_get_TreatAsUntrusted(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ILauncherOptions_adaptor::TreatAsUntrusted)->_put_TreatAsUntrusted(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} TreatAsUntrusted;
		struct : property {
			ptr<LauncherUIOptions> get() { LauncherUIOptions* value; hrcheck(enc(&ILauncherOptions_adaptor::UI)->_get_UI(&value)); return from_abi(value); }
			ptr<LauncherUIOptions> operator()() { return get(); }
			operator ptr<LauncherUIOptions> () { return get(); }
			ptr<LauncherUIOptions> operator->() { return get(); }
		} UI;
	};
	ILauncherOptions_adaptor() {}
};
template<typename X> struct adapt<ILauncherOptions, X> : Windows::System::ILauncherOptions_adaptor<X> { typedef adapt ILauncherOptions; };
struct ILauncherOptions : ILauncherOptions_raw, generate<ILauncherOptions> {};

// ILauncherOptions2
struct ILauncherOptions2_raw : IInspectable {
	virtual STDMETHODIMP _get_TargetApplicationPackageFamilyName(HSTRING *value);
	virtual STDMETHODIMP _put_TargetApplicationPackageFamilyName(HSTRING value);
	virtual STDMETHODIMP _get_NeighboringFilesQuery(Storage::Search::StorageFileQueryResult* *value);
	virtual STDMETHODIMP _put_NeighboringFilesQuery(Storage::Search::StorageFileQueryResult* value);
};
template<typename X> struct ILauncherOptions2_adaptor : X {
	union {
		struct : property {
			ptr<Storage::Search::StorageFileQueryResult> get() { Storage::Search::StorageFileQueryResult* value; hrcheck(enc(&ILauncherOptions2_adaptor::NeighboringFilesQuery)->_get_NeighboringFilesQuery(&value)); return from_abi(value); }
			ptr<Storage::Search::StorageFileQueryResult> operator()() { return get(); }
			operator ptr<Storage::Search::StorageFileQueryResult> () { return get(); }
			ptr<Storage::Search::StorageFileQueryResult> operator->() { return get(); }
			void put(pptr<Storage::Search::StorageFileQueryResult> value) { hrcheck(enc(&ILauncherOptions2_adaptor::NeighboringFilesQuery)->_put_NeighboringFilesQuery(value)); }
			void operator=(pptr<Storage::Search::StorageFileQueryResult> value) { put(value); }
			void operator()(pptr<Storage::Search::StorageFileQueryResult> value) { put(value); }
		} NeighboringFilesQuery;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ILauncherOptions2_adaptor::TargetApplicationPackageFamilyName)->_get_TargetApplicationPackageFamilyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ILauncherOptions2_adaptor::TargetApplicationPackageFamilyName)->_put_TargetApplicationPackageFamilyName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} TargetApplicationPackageFamilyName;
	};
	ILauncherOptions2_adaptor() {}
};
template<typename X> struct adapt<ILauncherOptions2, X> : Windows::System::ILauncherOptions2_adaptor<X> { typedef adapt ILauncherOptions2; };
struct ILauncherOptions2 : ILauncherOptions2_raw, generate<ILauncherOptions2> {};

// ILauncherOptions3
struct ILauncherOptions3_raw : IInspectable {
	virtual STDMETHODIMP _get_IgnoreAppUriHandlers(bool *value);
	virtual STDMETHODIMP _put_IgnoreAppUriHandlers(bool value);
};
template<typename X> struct ILauncherOptions3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILauncherOptions3_adaptor::IgnoreAppUriHandlers)->_get_IgnoreAppUriHandlers(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ILauncherOptions3_adaptor::IgnoreAppUriHandlers)->_put_IgnoreAppUriHandlers(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IgnoreAppUriHandlers;
	};
	ILauncherOptions3_adaptor() {}
};
template<typename X> struct adapt<ILauncherOptions3, X> : Windows::System::ILauncherOptions3_adaptor<X> { typedef adapt ILauncherOptions3; };
struct ILauncherOptions3 : ILauncherOptions3_raw, generate<ILauncherOptions3> {};

// ILauncherOptions4
struct ILauncherOptions4_raw : IInspectable {
	virtual STDMETHODIMP _get_LimitPickerToCurrentAppAndAppUriHandlers(bool *value);
	virtual STDMETHODIMP _put_LimitPickerToCurrentAppAndAppUriHandlers(bool value);
};
template<typename X> struct ILauncherOptions4_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILauncherOptions4_adaptor::LimitPickerToCurrentAppAndAppUriHandlers)->_get_LimitPickerToCurrentAppAndAppUriHandlers(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ILauncherOptions4_adaptor::LimitPickerToCurrentAppAndAppUriHandlers)->_put_LimitPickerToCurrentAppAndAppUriHandlers(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} LimitPickerToCurrentAppAndAppUriHandlers;
	};
	ILauncherOptions4_adaptor() {}
};
template<typename X> struct adapt<ILauncherOptions4, X> : Windows::System::ILauncherOptions4_adaptor<X> { typedef adapt ILauncherOptions4; };
struct ILauncherOptions4 : ILauncherOptions4_raw, generate<ILauncherOptions4> {};

// ILauncherViewOptions
struct ILauncherViewOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_DesiredRemainingView(UI::ViewManagement::ViewSizePreference *value) = 0;
	virtual STDMETHODIMP _put_DesiredRemainingView(UI::ViewManagement::ViewSizePreference value) = 0;
};
template<typename X> struct ILauncherViewOptions_adaptor : X {
	union {
		struct : property {
			UI::ViewManagement::ViewSizePreference get() { UI::ViewManagement::ViewSizePreference value; hrcheck(enc(&ILauncherViewOptions_adaptor::DesiredRemainingView)->_get_DesiredRemainingView(&value)); return value; }
			UI::ViewManagement::ViewSizePreference operator()() { return get(); }
			operator UI::ViewManagement::ViewSizePreference () { return get(); }
			void put(UI::ViewManagement::ViewSizePreference value) { hrcheck(enc(&ILauncherViewOptions_adaptor::DesiredRemainingView)->_put_DesiredRemainingView(value)); }
			void operator=(UI::ViewManagement::ViewSizePreference value) { put(value); }
			void operator()(UI::ViewManagement::ViewSizePreference value) { put(value); }
		} DesiredRemainingView;
	};
	ILauncherViewOptions_adaptor() {}
};
template<typename X> struct adapt<ILauncherViewOptions, X> : Windows::System::ILauncherViewOptions_adaptor<X> { typedef adapt ILauncherViewOptions; };
template<typename X> struct ILauncherViewOptions_unadaptor : X {
	STDMETHODIMP _get_DesiredRemainingView(UI::ViewManagement::ViewSizePreference *value) { return hrtry([&, this] { get_prop(value, DesiredRemainingView); }); }
	STDMETHODIMP _put_DesiredRemainingView(UI::ViewManagement::ViewSizePreference value) { return hrtry([&, this] { put_prop(value, DesiredRemainingView); }); }
};
template<typename X> struct unadapt<ILauncherViewOptions, X> : Windows::System::ILauncherViewOptions_unadaptor<X> {};
struct ILauncherViewOptions : ILauncherViewOptions_raw, generate<ILauncherViewOptions> {};

// LauncherOptions
template<typename X> struct statics<LauncherOptions, X> : X {
	typedef typename X::root_type LauncherOptions;
};
struct LauncherOptions : generate<LauncherOptions> {};

// IRemoteLauncherOptions
struct IRemoteLauncherOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_FallbackUri(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_FallbackUri(Foundation::Uri* value);
	virtual STDMETHODIMP _get_PreferredAppIds(Foundation::Collections::IVector<HSTRING>* *value);
};
template<typename X> struct IRemoteLauncherOptions_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IRemoteLauncherOptions_adaptor::FallbackUri)->_get_FallbackUri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IRemoteLauncherOptions_adaptor::FallbackUri)->_put_FallbackUri(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} FallbackUri;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IRemoteLauncherOptions_adaptor::PreferredAppIds)->_get_PreferredAppIds(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} PreferredAppIds;
	};
	IRemoteLauncherOptions_adaptor() {}
};
template<typename X> struct adapt<IRemoteLauncherOptions, X> : Windows::System::IRemoteLauncherOptions_adaptor<X> { typedef adapt IRemoteLauncherOptions; };
struct IRemoteLauncherOptions : IRemoteLauncherOptions_raw, generate<IRemoteLauncherOptions> {};

// RemoteLauncherOptions
template<typename X> struct statics<RemoteLauncherOptions, X> : X {
	typedef typename X::root_type RemoteLauncherOptions;
};
struct RemoteLauncherOptions : generate<RemoteLauncherOptions> {};

// IFolderLauncherOptions
struct IFolderLauncherOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_ItemsToSelect(Foundation::Collections::IVector<Storage::IStorageItem*>* *value);
};
template<typename X> struct IFolderLauncherOptions_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Storage::IStorageItem>>> get() { Foundation::Collections::IVector<Storage::IStorageItem*>* value; hrcheck(enc(&IFolderLauncherOptions_adaptor::ItemsToSelect)->_get_ItemsToSelect(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Storage::IStorageItem>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Storage::IStorageItem>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Storage::IStorageItem>>> operator->() { return get(); }
		} ItemsToSelect;
	};
	IFolderLauncherOptions_adaptor() {}
};
template<typename X> struct adapt<IFolderLauncherOptions, X> : Windows::System::IFolderLauncherOptions_adaptor<X> { typedef adapt IFolderLauncherOptions; };
struct IFolderLauncherOptions : IFolderLauncherOptions_raw, generate<IFolderLauncherOptions> {};

// FolderLauncherOptions
template<typename X> struct statics<FolderLauncherOptions, X> : X {
	typedef typename X::root_type FolderLauncherOptions;
};
struct FolderLauncherOptions : generate<FolderLauncherOptions> {};

// ILauncherStatics
struct ILauncherStatics : IInspectable {
	virtual STDMETHODIMP _LaunchFileAsync(Storage::IStorageFile* file, Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _LaunchFileWithOptionsAsync(Storage::IStorageFile* file, LauncherOptions* options, Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _LaunchUriAsync(Foundation::Uri* uri, Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _LaunchUriWithOptionsAsync(Foundation::Uri* uri, LauncherOptions* options, Foundation::IAsyncOperation<bool>* *operation);
};

// ILauncherStatics2
struct ILauncherStatics2 : IInspectable {
	virtual STDMETHODIMP _LaunchUriForResultsAsync(Foundation::Uri* uri, LauncherOptions* options, Foundation::IAsyncOperation<LaunchUriResult*>* *operation);
	virtual STDMETHODIMP _LaunchUriForResultsWithDataAsync(Foundation::Uri* uri, LauncherOptions* options, Foundation::Collections::ValueSet* inputData, Foundation::IAsyncOperation<LaunchUriResult*>* *operation);
	virtual STDMETHODIMP _LaunchUriWithDataAsync(Foundation::Uri* uri, LauncherOptions* options, Foundation::Collections::ValueSet* inputData, Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _QueryUriSupportAsync(Foundation::Uri* uri, LaunchQuerySupportType launchQuerySupportType, Foundation::IAsyncOperation<LaunchQuerySupportStatus>* *operation);
	virtual STDMETHODIMP _QueryUriSupportWithPackageFamilyNameAsync(Foundation::Uri* uri, LaunchQuerySupportType launchQuerySupportType, HSTRING packageFamilyName, Foundation::IAsyncOperation<LaunchQuerySupportStatus>* *operation);
	virtual STDMETHODIMP _QueryFileSupportAsync(Storage::StorageFile* file, Foundation::IAsyncOperation<LaunchQuerySupportStatus>* *operation);
	virtual STDMETHODIMP _QueryFileSupportWithPackageFamilyNameAsync(Storage::StorageFile* file, HSTRING packageFamilyName, Foundation::IAsyncOperation<LaunchQuerySupportStatus>* *operation);
	virtual STDMETHODIMP _FindUriSchemeHandlersAsync(HSTRING scheme, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<ApplicationModel::AppInfo*>*>* *operation);
	virtual STDMETHODIMP _FindUriSchemeHandlersWithLaunchUriTypeAsync(HSTRING scheme, LaunchQuerySupportType launchQuerySupportType, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<ApplicationModel::AppInfo*>*>* *operation);
	virtual STDMETHODIMP _FindFileHandlersAsync(HSTRING extension, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<ApplicationModel::AppInfo*>*>* *operation);
};

// ILauncherStatics3
struct ILauncherStatics3 : IInspectable {
	virtual STDMETHODIMP _LaunchFolderAsync(Storage::IStorageFolder* folder, Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _LaunchFolderWithOptionsAsync(Storage::IStorageFolder* folder, FolderLauncherOptions* options, Foundation::IAsyncOperation<bool>* *operation);
};

// ILauncherStatics4
struct ILauncherStatics4 : IInspectable {
	virtual STDMETHODIMP _QueryAppUriSupportAsync(Foundation::Uri* uri, Foundation::IAsyncOperation<LaunchQuerySupportStatus>* *operation);
	virtual STDMETHODIMP _QueryAppUriSupportWithPackageFamilyNameAsync(Foundation::Uri* uri, HSTRING packageFamilyName, Foundation::IAsyncOperation<LaunchQuerySupportStatus>* *operation);
	virtual STDMETHODIMP _FindAppUriHandlersAsync(Foundation::Uri* uri, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<ApplicationModel::AppInfo*>*>* *operation);
	virtual STDMETHODIMP _LaunchUriForUserAsync(User* user, Foundation::Uri* uri, Foundation::IAsyncOperation<LaunchUriStatus>* *operation);
	virtual STDMETHODIMP _LaunchUriWithOptionsForUserAsync(User* user, Foundation::Uri* uri, LauncherOptions* options, Foundation::IAsyncOperation<LaunchUriStatus>* *operation);
	virtual STDMETHODIMP _LaunchUriWithDataForUserAsync(User* user, Foundation::Uri* uri, LauncherOptions* options, Foundation::Collections::ValueSet* inputData, Foundation::IAsyncOperation<LaunchUriStatus>* *operation);
	virtual STDMETHODIMP _LaunchUriForResultsForUserAsync(User* user, Foundation::Uri* uri, LauncherOptions* options, Foundation::IAsyncOperation<LaunchUriResult*>* *operation);
	virtual STDMETHODIMP _LaunchUriForResultsWithDataForUserAsync(User* user, Foundation::Uri* uri, LauncherOptions* options, Foundation::Collections::ValueSet* inputData, Foundation::IAsyncOperation<LaunchUriResult*>* *operation);
};

// Launcher
template<typename> struct Launcher_statics {
	static ptr<Foundation::IAsyncOperation<LaunchQuerySupportStatus>> QueryAppUriSupportAsync(pptr<Foundation::Uri> uri) { Foundation::IAsyncOperation<LaunchQuerySupportStatus>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics4>()->_QueryAppUriSupportAsync(uri, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<LaunchQuerySupportStatus>> QueryAppUriSupportAsync(pptr<Foundation::Uri> uri, hstring_ref packageFamilyName) { Foundation::IAsyncOperation<LaunchQuerySupportStatus>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics4>()->_QueryAppUriSupportWithPackageFamilyNameAsync(uri, packageFamilyName, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<ApplicationModel::AppInfo>>>>> FindAppUriHandlersAsync(pptr<Foundation::Uri> uri) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<ApplicationModel::AppInfo*>*>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics4>()->_FindAppUriHandlersAsync(uri, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<LaunchUriStatus>> LaunchUriForUserAsync(pptr<User> user, pptr<Foundation::Uri> uri) { Foundation::IAsyncOperation<LaunchUriStatus>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics4>()->_LaunchUriForUserAsync(user, uri, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<LaunchUriStatus>> LaunchUriForUserAsync(pptr<User> user, pptr<Foundation::Uri> uri, pptr<LauncherOptions> options) { Foundation::IAsyncOperation<LaunchUriStatus>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics4>()->_LaunchUriWithOptionsForUserAsync(user, uri, options, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<LaunchUriStatus>> LaunchUriForUserAsync(pptr<User> user, pptr<Foundation::Uri> uri, pptr<LauncherOptions> options, pptr<Foundation::Collections::ValueSet> inputData) { Foundation::IAsyncOperation<LaunchUriStatus>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics4>()->_LaunchUriWithDataForUserAsync(user, uri, options, inputData, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<LaunchUriResult>>> LaunchUriForResultsForUserAsync(pptr<User> user, pptr<Foundation::Uri> uri, pptr<LauncherOptions> options) { Foundation::IAsyncOperation<LaunchUriResult*>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics4>()->_LaunchUriForResultsForUserAsync(user, uri, options, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<LaunchUriResult>>> LaunchUriForResultsForUserAsync(pptr<User> user, pptr<Foundation::Uri> uri, pptr<LauncherOptions> options, pptr<Foundation::Collections::ValueSet> inputData) { Foundation::IAsyncOperation<LaunchUriResult*>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics4>()->_LaunchUriForResultsWithDataForUserAsync(user, uri, options, inputData, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<bool>> LaunchFolderAsync(pptr<Storage::IStorageFolder> folder) { Foundation::IAsyncOperation<bool>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics3>()->_LaunchFolderAsync(folder, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<bool>> LaunchFolderAsync(pptr<Storage::IStorageFolder> folder, pptr<FolderLauncherOptions> options) { Foundation::IAsyncOperation<bool>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics3>()->_LaunchFolderWithOptionsAsync(folder, options, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<LaunchUriResult>>> LaunchUriForResultsAsync(pptr<Foundation::Uri> uri, pptr<LauncherOptions> options) { Foundation::IAsyncOperation<LaunchUriResult*>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics2>()->_LaunchUriForResultsAsync(uri, options, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<LaunchUriResult>>> LaunchUriForResultsAsync(pptr<Foundation::Uri> uri, pptr<LauncherOptions> options, pptr<Foundation::Collections::ValueSet> inputData) { Foundation::IAsyncOperation<LaunchUriResult*>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics2>()->_LaunchUriForResultsWithDataAsync(uri, options, inputData, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<bool>> LaunchUriAsync(pptr<Foundation::Uri> uri, pptr<LauncherOptions> options, pptr<Foundation::Collections::ValueSet> inputData) { Foundation::IAsyncOperation<bool>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics2>()->_LaunchUriWithDataAsync(uri, options, inputData, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<LaunchQuerySupportStatus>> QueryUriSupportAsync(pptr<Foundation::Uri> uri, LaunchQuerySupportType launchQuerySupportType) { Foundation::IAsyncOperation<LaunchQuerySupportStatus>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics2>()->_QueryUriSupportAsync(uri, launchQuerySupportType, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<LaunchQuerySupportStatus>> QueryUriSupportAsync(pptr<Foundation::Uri> uri, LaunchQuerySupportType launchQuerySupportType, hstring_ref packageFamilyName) { Foundation::IAsyncOperation<LaunchQuerySupportStatus>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics2>()->_QueryUriSupportWithPackageFamilyNameAsync(uri, launchQuerySupportType, packageFamilyName, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<LaunchQuerySupportStatus>> QueryFileSupportAsync(pptr<Storage::StorageFile> file) { Foundation::IAsyncOperation<LaunchQuerySupportStatus>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics2>()->_QueryFileSupportAsync(file, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<LaunchQuerySupportStatus>> QueryFileSupportAsync(pptr<Storage::StorageFile> file, hstring_ref packageFamilyName) { Foundation::IAsyncOperation<LaunchQuerySupportStatus>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics2>()->_QueryFileSupportWithPackageFamilyNameAsync(file, packageFamilyName, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<ApplicationModel::AppInfo>>>>> FindUriSchemeHandlersAsync(hstring_ref scheme) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<ApplicationModel::AppInfo*>*>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics2>()->_FindUriSchemeHandlersAsync(scheme, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<ApplicationModel::AppInfo>>>>> FindUriSchemeHandlersAsync(hstring_ref scheme, LaunchQuerySupportType launchQuerySupportType) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<ApplicationModel::AppInfo*>*>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics2>()->_FindUriSchemeHandlersWithLaunchUriTypeAsync(scheme, launchQuerySupportType, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<ApplicationModel::AppInfo>>>>> FindFileHandlersAsync(hstring_ref extension) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<ApplicationModel::AppInfo*>*>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics2>()->_FindFileHandlersAsync(extension, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<bool>> LaunchFileAsync(pptr<Storage::IStorageFile> file) { Foundation::IAsyncOperation<bool>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics>()->_LaunchFileAsync(file, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<bool>> LaunchFileAsync(pptr<Storage::IStorageFile> file, pptr<LauncherOptions> options) { Foundation::IAsyncOperation<bool>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics>()->_LaunchFileWithOptionsAsync(file, options, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<bool>> LaunchUriAsync(pptr<Foundation::Uri> uri) { Foundation::IAsyncOperation<bool>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics>()->_LaunchUriAsync(uri, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<bool>> LaunchUriAsync(pptr<Foundation::Uri> uri, pptr<LauncherOptions> options) { Foundation::IAsyncOperation<bool>* operation; hrcheck(get_activation_factory<Launcher, ILauncherStatics>()->_LaunchUriWithOptionsAsync(uri, options, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<Launcher, X> : X, Windows::System::Launcher_statics<void> {
	typedef typename X::root_type Launcher;
};
struct Launcher : generate<Launcher> {};

// IRemoteLauncherStatics
struct IRemoteLauncherStatics : IInspectable {
	virtual STDMETHODIMP _LaunchUriAsync(RemoteSystems::RemoteSystemConnectionRequest* remoteSystemConnectionRequest, Foundation::Uri* uri, Foundation::IAsyncOperation<RemoteLaunchUriStatus>* *operation);
	virtual STDMETHODIMP _LaunchUriWithOptionsAsync(RemoteSystems::RemoteSystemConnectionRequest* remoteSystemConnectionRequest, Foundation::Uri* uri, RemoteLauncherOptions* options, Foundation::IAsyncOperation<RemoteLaunchUriStatus>* *operation);
	virtual STDMETHODIMP _LaunchUriWithDataAsync(RemoteSystems::RemoteSystemConnectionRequest* remoteSystemConnectionRequest, Foundation::Uri* uri, RemoteLauncherOptions* options, Foundation::Collections::ValueSet* inputData, Foundation::IAsyncOperation<RemoteLaunchUriStatus>* *operation);
};

// RemoteLauncher
template<typename> struct RemoteLauncher_statics {
	static ptr<Foundation::IAsyncOperation<RemoteLaunchUriStatus>> LaunchUriAsync(pptr<RemoteSystems::RemoteSystemConnectionRequest> remoteSystemConnectionRequest, pptr<Foundation::Uri> uri) { Foundation::IAsyncOperation<RemoteLaunchUriStatus>* operation; hrcheck(get_activation_factory<RemoteLauncher, IRemoteLauncherStatics>()->_LaunchUriAsync(remoteSystemConnectionRequest, uri, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<RemoteLaunchUriStatus>> LaunchUriAsync(pptr<RemoteSystems::RemoteSystemConnectionRequest> remoteSystemConnectionRequest, pptr<Foundation::Uri> uri, pptr<RemoteLauncherOptions> options) { Foundation::IAsyncOperation<RemoteLaunchUriStatus>* operation; hrcheck(get_activation_factory<RemoteLauncher, IRemoteLauncherStatics>()->_LaunchUriWithOptionsAsync(remoteSystemConnectionRequest, uri, options, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<RemoteLaunchUriStatus>> LaunchUriAsync(pptr<RemoteSystems::RemoteSystemConnectionRequest> remoteSystemConnectionRequest, pptr<Foundation::Uri> uri, pptr<RemoteLauncherOptions> options, pptr<Foundation::Collections::ValueSet> inputData) { Foundation::IAsyncOperation<RemoteLaunchUriStatus>* operation; hrcheck(get_activation_factory<RemoteLauncher, IRemoteLauncherStatics>()->_LaunchUriWithDataAsync(remoteSystemConnectionRequest, uri, options, inputData, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<RemoteLauncher, X> : X, Windows::System::RemoteLauncher_statics<void> {
	typedef typename X::root_type RemoteLauncher;
};
struct RemoteLauncher : generate<RemoteLauncher> {};

// IDateTimeSettingsStatics
struct IDateTimeSettingsStatics : IInspectable {
	virtual STDMETHODIMP _SetSystemDateTime(Foundation::DateTime utcDateTime);
};

// DateTimeSettings
template<typename> struct DateTimeSettings_statics {
	static void SetSystemDateTime(const Foundation::DateTime& utcDateTime) { hrcheck(get_activation_factory<DateTimeSettings, IDateTimeSettingsStatics>()->_SetSystemDateTime(utcDateTime)); }
};

template<typename X> struct statics<DateTimeSettings, X> : X, Windows::System::DateTimeSettings_statics<void> {
	typedef typename X::root_type DateTimeSettings;
};
struct DateTimeSettings : generate<DateTimeSettings> {};

// IProcessLauncherOptions
struct IProcessLauncherOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_StandardInput(Storage::Streams::IInputStream* *value);
	virtual STDMETHODIMP _put_StandardInput(Storage::Streams::IInputStream* value);
	virtual STDMETHODIMP _get_StandardOutput(Storage::Streams::IOutputStream* *value);
	virtual STDMETHODIMP _put_StandardOutput(Storage::Streams::IOutputStream* value);
	virtual STDMETHODIMP _get_StandardError(Storage::Streams::IOutputStream* *value);
	virtual STDMETHODIMP _put_StandardError(Storage::Streams::IOutputStream* value);
	virtual STDMETHODIMP _get_WorkingDirectory(HSTRING *value);
	virtual STDMETHODIMP _put_WorkingDirectory(HSTRING value);
};
template<typename X> struct IProcessLauncherOptions_adaptor : X {
	union {
		struct : property {
			ptr<Storage::Streams::IOutputStream> get() { Storage::Streams::IOutputStream* value; hrcheck(enc(&IProcessLauncherOptions_adaptor::StandardError)->_get_StandardError(&value)); return from_abi(value); }
			ptr<Storage::Streams::IOutputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IOutputStream> () { return get(); }
			ptr<Storage::Streams::IOutputStream> operator->() { return get(); }
			void put(pptr<Storage::Streams::IOutputStream> value) { hrcheck(enc(&IProcessLauncherOptions_adaptor::StandardError)->_put_StandardError(value)); }
			void operator=(pptr<Storage::Streams::IOutputStream> value) { put(value); }
			void operator()(pptr<Storage::Streams::IOutputStream> value) { put(value); }
		} StandardError;
		struct : property {
			ptr<Storage::Streams::IInputStream> get() { Storage::Streams::IInputStream* value; hrcheck(enc(&IProcessLauncherOptions_adaptor::StandardInput)->_get_StandardInput(&value)); return from_abi(value); }
			ptr<Storage::Streams::IInputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IInputStream> () { return get(); }
			ptr<Storage::Streams::IInputStream> operator->() { return get(); }
			void put(pptr<Storage::Streams::IInputStream> value) { hrcheck(enc(&IProcessLauncherOptions_adaptor::StandardInput)->_put_StandardInput(value)); }
			void operator=(pptr<Storage::Streams::IInputStream> value) { put(value); }
			void operator()(pptr<Storage::Streams::IInputStream> value) { put(value); }
		} StandardInput;
		struct : property {
			ptr<Storage::Streams::IOutputStream> get() { Storage::Streams::IOutputStream* value; hrcheck(enc(&IProcessLauncherOptions_adaptor::StandardOutput)->_get_StandardOutput(&value)); return from_abi(value); }
			ptr<Storage::Streams::IOutputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IOutputStream> () { return get(); }
			ptr<Storage::Streams::IOutputStream> operator->() { return get(); }
			void put(pptr<Storage::Streams::IOutputStream> value) { hrcheck(enc(&IProcessLauncherOptions_adaptor::StandardOutput)->_put_StandardOutput(value)); }
			void operator=(pptr<Storage::Streams::IOutputStream> value) { put(value); }
			void operator()(pptr<Storage::Streams::IOutputStream> value) { put(value); }
		} StandardOutput;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IProcessLauncherOptions_adaptor::WorkingDirectory)->_get_WorkingDirectory(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IProcessLauncherOptions_adaptor::WorkingDirectory)->_put_WorkingDirectory(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} WorkingDirectory;
	};
	IProcessLauncherOptions_adaptor() {}
};
template<typename X> struct adapt<IProcessLauncherOptions, X> : Windows::System::IProcessLauncherOptions_adaptor<X> { typedef adapt IProcessLauncherOptions; };
struct IProcessLauncherOptions : IProcessLauncherOptions_raw, generate<IProcessLauncherOptions> {};

// ProcessLauncherOptions
template<typename X> struct statics<ProcessLauncherOptions, X> : X {
	typedef typename X::root_type ProcessLauncherOptions;
};
struct ProcessLauncherOptions : generate<ProcessLauncherOptions> {};

// IProcessLauncherStatics
struct IProcessLauncherStatics : IInspectable {
	virtual STDMETHODIMP _RunToCompletionAsync(HSTRING fileName, HSTRING args, Foundation::IAsyncOperation<ProcessLauncherResult*>* *asyncOperationResult);
	virtual STDMETHODIMP _RunToCompletionAsyncWithOptions(HSTRING fileName, HSTRING args, ProcessLauncherOptions* options, Foundation::IAsyncOperation<ProcessLauncherResult*>* *asyncOperationResult);
};

// IProcessLauncherResult
struct IProcessLauncherResult_raw : IInspectable {
	virtual STDMETHODIMP _get_ExitCode(unsigned *value);
};
template<typename X> struct IProcessLauncherResult_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IProcessLauncherResult_adaptor::ExitCode)->_get_ExitCode(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} ExitCode;
	};
	IProcessLauncherResult_adaptor() {}
};
template<typename X> struct adapt<IProcessLauncherResult, X> : Windows::System::IProcessLauncherResult_adaptor<X> { typedef adapt IProcessLauncherResult; };
struct IProcessLauncherResult : IProcessLauncherResult_raw, generate<IProcessLauncherResult> {};

// ProcessLauncherResult
template<typename X> struct statics<ProcessLauncherResult, X> : X {
	typedef typename X::root_type ProcessLauncherResult;
};
struct ProcessLauncherResult : generate<ProcessLauncherResult> {};

// ProcessLauncher
template<typename> struct ProcessLauncher_statics {
	static ptr<Foundation::IAsyncOperation<ptr<ProcessLauncherResult>>> RunToCompletionAsync(hstring_ref fileName, hstring_ref args) { Foundation::IAsyncOperation<ProcessLauncherResult*>* asyncOperationResult; hrcheck(get_activation_factory<ProcessLauncher, IProcessLauncherStatics>()->_RunToCompletionAsync(fileName, args, &asyncOperationResult)); return from_abi(asyncOperationResult); }
	static ptr<Foundation::IAsyncOperation<ptr<ProcessLauncherResult>>> RunToCompletionAsync(hstring_ref fileName, hstring_ref args, pptr<ProcessLauncherOptions> options) { Foundation::IAsyncOperation<ProcessLauncherResult*>* asyncOperationResult; hrcheck(get_activation_factory<ProcessLauncher, IProcessLauncherStatics>()->_RunToCompletionAsyncWithOptions(fileName, args, options, &asyncOperationResult)); return from_abi(asyncOperationResult); }
};

template<typename X> struct statics<ProcessLauncher, X> : X, Windows::System::ProcessLauncher_statics<void> {
	typedef typename X::root_type ProcessLauncher;
};
struct ProcessLauncher : generate<ProcessLauncher> {};

// IShutdownManagerStatics
struct IShutdownManagerStatics : IInspectable {
	virtual STDMETHODIMP _BeginShutdown(ShutdownKind shutdownKind, Foundation::TimeSpan timeout);
	virtual STDMETHODIMP _CancelShutdown();
};

// IShutdownManagerStatics2
struct IShutdownManagerStatics2 : IInspectable {
	virtual STDMETHODIMP _IsPowerStateSupported(PowerState powerState, bool *value);
	virtual STDMETHODIMP _EnterPowerState(PowerState powerState);
	virtual STDMETHODIMP _EnterPowerStateWithTimeSpan(PowerState powerState, Foundation::TimeSpan wakeUpAfter);
};

// ShutdownManager
template<typename> struct ShutdownManager_statics {
	static bool IsPowerStateSupported(PowerState powerState) { bool value; hrcheck(get_activation_factory<ShutdownManager, IShutdownManagerStatics2>()->_IsPowerStateSupported(powerState, &value)); return value; }
	static void EnterPowerState(PowerState powerState) { hrcheck(get_activation_factory<ShutdownManager, IShutdownManagerStatics2>()->_EnterPowerState(powerState)); }
	static void EnterPowerState(PowerState powerState, const Foundation::TimeSpan& wakeUpAfter) { hrcheck(get_activation_factory<ShutdownManager, IShutdownManagerStatics2>()->_EnterPowerStateWithTimeSpan(powerState, wakeUpAfter)); }
	static void BeginShutdown(ShutdownKind shutdownKind, const Foundation::TimeSpan& timeout) { hrcheck(get_activation_factory<ShutdownManager, IShutdownManagerStatics>()->_BeginShutdown(shutdownKind, timeout)); }
	static void CancelShutdown() { hrcheck(get_activation_factory<ShutdownManager, IShutdownManagerStatics>()->_CancelShutdown()); }
};

template<typename X> struct statics<ShutdownManager, X> : X, Windows::System::ShutdownManager_statics<void> {
	typedef typename X::root_type ShutdownManager;
};
struct ShutdownManager : generate<ShutdownManager> {};

// ITimeZoneSettingsStatics
struct ITimeZoneSettingsStatics : IInspectable {
	virtual STDMETHODIMP _get_CurrentTimeZoneDisplayName(HSTRING *value);
	virtual STDMETHODIMP _get_SupportedTimeZoneDisplayNames(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _get_CanChangeTimeZone(bool *value);
	virtual STDMETHODIMP _ChangeTimeZoneByDisplayName(HSTRING timeZoneDisplayName);
};

// ITimeZoneSettingsStatics2
struct ITimeZoneSettingsStatics2 : IInspectable {
	virtual STDMETHODIMP _AutoUpdateTimeZoneAsync(Foundation::TimeSpan timeout, Foundation::IAsyncOperation<AutoUpdateTimeZoneStatus>* *operation);
};

// TimeZoneSettings
template<typename> struct TimeZoneSettings_statics {
	static struct _CanChangeTimeZone : property {
		bool get() { bool value; hrcheck(get_activation_factory<TimeZoneSettings, ITimeZoneSettingsStatics>()->_get_CanChangeTimeZone(&value)); return value; }
		bool operator()() { return get(); }
		operator bool () { return get(); }
	} CanChangeTimeZone;
	static struct _CurrentTimeZoneDisplayName : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<TimeZoneSettings, ITimeZoneSettingsStatics>()->_get_CurrentTimeZoneDisplayName(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} CurrentTimeZoneDisplayName;
	static struct _SupportedTimeZoneDisplayNames : property {
		ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(get_activation_factory<TimeZoneSettings, ITimeZoneSettingsStatics>()->_get_SupportedTimeZoneDisplayNames(&value)); return from_abi(value); }
		ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
		operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
		ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
	} SupportedTimeZoneDisplayNames;
	static ptr<Foundation::IAsyncOperation<AutoUpdateTimeZoneStatus>> AutoUpdateTimeZoneAsync(const Foundation::TimeSpan& timeout) { Foundation::IAsyncOperation<AutoUpdateTimeZoneStatus>* operation; hrcheck(get_activation_factory<TimeZoneSettings, ITimeZoneSettingsStatics2>()->_AutoUpdateTimeZoneAsync(timeout, &operation)); return from_abi(operation); }
	static void ChangeTimeZoneByDisplayName(hstring_ref timeZoneDisplayName) { hrcheck(get_activation_factory<TimeZoneSettings, ITimeZoneSettingsStatics>()->_ChangeTimeZoneByDisplayName(timeZoneDisplayName)); }
};
template<typename X> typename TimeZoneSettings_statics<X>::_CanChangeTimeZone TimeZoneSettings_statics<X>::CanChangeTimeZone;
template<typename X> typename TimeZoneSettings_statics<X>::_CurrentTimeZoneDisplayName TimeZoneSettings_statics<X>::CurrentTimeZoneDisplayName;
template<typename X> typename TimeZoneSettings_statics<X>::_SupportedTimeZoneDisplayNames TimeZoneSettings_statics<X>::SupportedTimeZoneDisplayNames;

template<typename X> struct statics<TimeZoneSettings, X> : X, Windows::System::TimeZoneSettings_statics<void> {
	typedef typename X::root_type TimeZoneSettings;
};
struct TimeZoneSettings : generate<TimeZoneSettings> {};
}}
} // namespace iso_winrt
