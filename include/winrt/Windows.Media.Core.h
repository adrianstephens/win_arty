#pragma once
// generated by isopod tools
// namespaces:
// Windows.Media.Core

#include "Windows.Media.Core.0.h"
#include "Windows.Graphics.Imaging.0.h"
#include "Windows.UI.0.h"
#include "Windows.Media.Playback.h"
#include "Windows.Foundation.Collections.h"
#include "Windows.Foundation.h"
#include "Windows.Media.h"
#include "Windows.Media.Effects.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace ApplicationModel { namespace AppService {
struct AppServiceConnection;
}}
namespace Media { namespace Capture { namespace Frames {
struct MediaFrameSource;
}
struct CapturedFrameControlValues;
struct VideoStreamConfiguration;
}
namespace Devices { namespace Core {
struct FrameController;
}
struct VideoDeviceController;
}
namespace FaceAnalysis {
struct DetectedFace;
}
namespace MediaProperties {
struct AudioEncodingProperties;
struct VideoEncodingProperties;
struct TimedMetadataEncodingProperties;
}
namespace Protection {
struct MediaProtectionManager;
}
namespace Streaming { namespace Adaptive {
struct AdaptiveMediaSource;
}}}
namespace Networking { namespace BackgroundTransfer {
struct DownloadOperation;
}}
namespace Storage { namespace FileProperties {
struct MusicProperties;
struct VideoProperties;
}
namespace Streams {
struct IRandomAccessStream;
struct Buffer;
struct IBuffer;
struct IRandomAccessStreamReference;
struct IInputStream;
}
struct IStorageFile;
}}

// defs

template<> struct def<Windows::Media::Core::TimedTextScrollMode> : enum_type<int> {};
template<> struct def<Windows::Media::Core::TimedTextUnit> : enum_type<int> {};
template<> struct def<Windows::Media::Core::TimedTextWritingMode> : enum_type<int> {};
template<> struct def<Windows::Media::Core::TimedTextDisplayAlignment> : enum_type<int> {};
template<> struct def<Windows::Media::Core::TimedTextLineAlignment> : enum_type<int> {};
template<> struct def<Windows::Media::Core::TimedTextWrapping> : enum_type<int> {};
template<> struct def<Windows::Media::Core::TimedTextWeight> : enum_type<int> {};
template<> struct def<Windows::Media::Core::TimedTextFlowDirection> : enum_type<int> {};
template<> struct def<Windows::Media::Core::TimedTextFontStyle> : enum_type<int> {};
template<> struct def<Windows::Media::Core::TimedTextPadding> : value_type<double, double, double, double, Windows::Media::Core::TimedTextUnit> {};
template<> struct def<Windows::Media::Core::TimedTextSize> : value_type<double, double, Windows::Media::Core::TimedTextUnit> {};
template<> struct def<Windows::Media::Core::TimedTextDouble> : value_type<double, Windows::Media::Core::TimedTextUnit> {};
template<> struct def<Windows::Media::Core::TimedTextPoint> : value_type<double, double, Windows::Media::Core::TimedTextUnit> {};
template<> struct def<Windows::Media::Core::IMediaCue> : overridable_type<> {};
template<> struct def<Windows::Media::Core::IDataCue> : interface_type<Windows::Media::Core::IMediaCue> {};
template<> struct def<Windows::Media::Core::IDataCue2> : interface_type<Windows::Media::Core::IDataCue> {};
template<> struct def<Windows::Media::Core::IChapterCue> : interface_type<Windows::Media::Core::IMediaCue> {};
template<> struct def<Windows::Media::Core::IImageCue> : interface_type<Windows::Media::Core::IMediaCue> {};
template<> struct def<Windows::Media::Core::ISpeechCue> : interface_type<Windows::Media::Core::IMediaCue> {};
template<> struct def<Windows::Media::Core::ITimedTextCue> : interface_type<Windows::Media::Core::IMediaCue> {};
template<> struct def<Windows::Media::Core::ITimedTextRegion> : interface_type<> {};
template<> struct def<Windows::Media::Core::TimedTextRegion> : class_type<Platform::Object, Windows::Media::Core::ITimedTextRegion> {};
template<> struct def<Windows::Media::Core::ITimedTextStyle2> : interface_type<> {};
template<> struct def<Windows::Media::Core::ITimedTextStyle> : interface_type<> {};
template<> struct def<Windows::Media::Core::TimedTextStyle> : class_type<Platform::Object, Windows::Media::Core::ITimedTextStyle, Windows::Media::Core::ITimedTextStyle2> {};
template<> struct def<Windows::Media::Core::ITimedTextLine> : interface_type<> {};
template<> struct def<Windows::Media::Core::TimedTextLine> : class_type<Platform::Object, Windows::Media::Core::ITimedTextLine> {};
template<> struct def<Windows::Media::Core::ITimedTextSubformat> : interface_type<> {};
template<> struct def<Windows::Media::Core::TimedTextSubformat> : class_type<Platform::Object, Windows::Media::Core::ITimedTextSubformat> {};
template<> struct def<Windows::Media::Core::TimedTextCue> : class_type<Platform::Object, Windows::Media::Core::ITimedTextCue> {};
template<> struct def<Windows::Media::Core::DataCue> : class_type<Platform::Object, Windows::Media::Core::IDataCue, Windows::Media::Core::IDataCue2> {};
template<> struct def<Windows::Media::Core::ChapterCue> : class_type<Platform::Object, Windows::Media::Core::IChapterCue> {};
template<> struct def<Windows::Media::Core::ImageCue> : class_type<Platform::Object, Windows::Media::Core::IImageCue> {};
template<> struct def<Windows::Media::Core::SpeechCue> : class_type<Platform::Object, Windows::Media::Core::ISpeechCue> {};
template<> struct def<Windows::Media::Core::CodecKind> : enum_type<int> {};
template<> struct def<Windows::Media::Core::CodecCategory> : enum_type<int> {};
template<> struct def<Windows::Media::Core::ICodecInfo> : interface_type<> {};
template<> struct def<Windows::Media::Core::CodecInfo> : class_type<Platform::Object, Windows::Media::Core::ICodecInfo> {};
template<> struct def<Windows::Media::Core::ICodecQuery> : interface_type<> {};
template<> struct def<Windows::Media::Core::CodecQuery> : class_type<Platform::Object, Windows::Media::Core::ICodecQuery> {};
template<> struct def<Windows::Media::Core::ICodecSubtypesStatics> : interface_type<> {};
template<> struct def<Windows::Media::Core::CodecSubtypes> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Media::Core::ILowLightFusionStatics> : interface_type<> {};
template<> struct def<Windows::Media::Core::ILowLightFusionResult> : interface_type<> {};
template<> struct def<Windows::Media::Core::LowLightFusionResult> : class_type<Platform::Object, Windows::Media::Core::ILowLightFusionResult, Windows::Foundation::IClosable> {};
template<> struct def<Windows::Media::Core::LowLightFusion> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Media::Core::IAudioStreamDescriptorFactory> : interface_type<> {};
template<> struct def<Windows::Media::Core::IAudioStreamDescriptor3> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMediaStreamDescriptor> : overridable_type<> {};
template<> struct def<Windows::Media::Core::IMediaStreamDescriptor2> : overridable_type<Windows::Media::Core::IMediaStreamDescriptor> {};
template<> struct def<Windows::Media::Core::IAudioStreamDescriptor2> : interface_type<Windows::Media::Core::IMediaStreamDescriptor> {};
template<> struct def<Windows::Media::Core::IAudioStreamDescriptor> : interface_type<Windows::Media::Core::IMediaStreamDescriptor> {};
template<> struct def<Windows::Media::Core::AudioStreamDescriptor> : class_type<Platform::Object, Windows::Media::Core::IAudioStreamDescriptor, Windows::Media::Core::IAudioStreamDescriptor3, Windows::Media::Core::IAudioStreamDescriptor2, Windows::Media::Core::IMediaStreamDescriptor2>, custom_activators {};
template<> struct def<Windows::Media::Core::IVideoStreamDescriptorFactory> : interface_type<> {};
template<> struct def<Windows::Media::Core::IVideoStreamDescriptor2> : interface_type<> {};
template<> struct def<Windows::Media::Core::IVideoStreamDescriptor> : interface_type<Windows::Media::Core::IMediaStreamDescriptor> {};
template<> struct def<Windows::Media::Core::VideoStreamDescriptor> : class_type<Platform::Object, Windows::Media::Core::IVideoStreamDescriptor, Windows::Media::Core::IVideoStreamDescriptor2, Windows::Media::Core::IMediaStreamDescriptor2>, custom_activators {};
template<> struct def<Windows::Media::Core::ITimedMetadataStreamDescriptorFactory> : interface_type<> {};
template<> struct def<Windows::Media::Core::ITimedMetadataStreamDescriptor> : interface_type<> {};
template<> struct def<Windows::Media::Core::TimedMetadataStreamDescriptor> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamDescriptor, Windows::Media::Core::IMediaStreamDescriptor2, Windows::Media::Core::ITimedMetadataStreamDescriptor>, custom_activators {};
template<> struct def<Windows::Media::Core::MediaStreamSourceClosedReason> : enum_type<int> {};
template<> struct def<Windows::Media::Core::MediaStreamSourceErrorStatus> : enum_type<int> {};
template<> struct def<Windows::Media::Core::IMediaSource> : overridable_type<> {};
template<> struct def<Windows::Media::Core::IMediaStreamSource> : interface_type<Windows::Media::Core::IMediaSource> {};
template<> struct def<Windows::Media::Core::IMediaStreamSourceFactory> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMediaStreamSource4> : interface_type<Windows::Media::Core::IMediaStreamSource> {};
template<> struct def<Windows::Media::Core::IMediaStreamSource3> : interface_type<Windows::Media::Core::IMediaStreamSource> {};
template<> struct def<Windows::Media::Core::IMediaStreamSource2> : interface_type<Windows::Media::Core::IMediaStreamSource> {};
template<> struct def<Windows::Media::Core::MediaStreamSource> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamSource, Windows::Media::Core::IMediaStreamSource4, Windows::Media::Core::IMediaStreamSource2, Windows::Media::Core::IMediaStreamSource3>, custom_activators {};
template<> struct def<Windows::Media::Core::IMediaStreamSourceClosedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaStreamSourceClosedEventArgs> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamSourceClosedEventArgs> {};
template<> struct def<Windows::Media::Core::IMediaStreamSourceStartingEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaStreamSourceStartingEventArgs> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamSourceStartingEventArgs> {};
template<> struct def<Windows::Media::Core::IMediaStreamSourceSampleRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamSourceSampleRequestedEventArgs> {};
template<> struct def<Windows::Media::Core::IMediaStreamSourceSwitchStreamsRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamSourceSwitchStreamsRequestedEventArgs> {};
template<> struct def<Windows::Media::Core::IMediaStreamSourceSampleRenderedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamSourceSampleRenderedEventArgs> {};
template<> struct def<Windows::Media::Core::MediaStreamSamplePropertySet> : class_type<Platform::Object, Windows::Foundation::Collections::IMap<Platform::Guid, object>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<Platform::Guid, object>>>> {};
template<> struct def<Windows::Media::Core::IMediaStreamSample> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMediaStreamSampleStatics> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaStreamSample> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamSample> {};
template<> struct def<Windows::Media::Core::IMediaStreamSampleProtectionProperties> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaStreamSampleProtectionProperties> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamSampleProtectionProperties> {};
template<> struct def<Windows::Media::Core::IMediaStreamSourceClosedRequest> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaStreamSourceClosedRequest> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamSourceClosedRequest> {};
template<> struct def<Windows::Media::Core::IMediaStreamSourceStartingRequestDeferral> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaStreamSourceStartingRequestDeferral> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamSourceStartingRequestDeferral> {};
template<> struct def<Windows::Media::Core::IMediaStreamSourceStartingRequest> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaStreamSourceStartingRequest> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamSourceStartingRequest> {};
template<> struct def<Windows::Media::Core::IMediaStreamSourceSampleRequestDeferral> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaStreamSourceSampleRequestDeferral> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamSourceSampleRequestDeferral> {};
template<> struct def<Windows::Media::Core::IMediaStreamSourceSampleRequest> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaStreamSourceSampleRequest> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamSourceSampleRequest> {};
template<> struct def<Windows::Media::Core::IMediaStreamSourceSwitchStreamsRequestDeferral> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamSourceSwitchStreamsRequestDeferral> {};
template<> struct def<Windows::Media::Core::IMediaStreamSourceSwitchStreamsRequest> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest> : class_type<Platform::Object, Windows::Media::Core::IMediaStreamSourceSwitchStreamsRequest> {};
template<> struct def<Windows::Media::Core::MseTimeRange> : value_type<Windows::Foundation::TimeSpan, Windows::Foundation::TimeSpan> {};
template<> struct def<Windows::Media::Core::MseReadyState> : enum_type<int> {};
template<> struct def<Windows::Media::Core::MseEndOfStreamStatus> : enum_type<int> {};
template<> struct def<Windows::Media::Core::MseAppendMode> : enum_type<int> {};
template<> struct def<Windows::Media::Core::IMseStreamSourceStatics> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMseStreamSource> : interface_type<Windows::Media::Core::IMediaSource> {};
template<> struct def<Windows::Media::Core::IMseStreamSource2> : interface_type<> {};
template<> struct def<Windows::Media::Core::MseStreamSource> : class_type<Platform::Object, Windows::Media::Core::IMseStreamSource, Windows::Media::Core::IMseStreamSource2> {};
template<> struct def<Windows::Media::Core::IMseSourceBufferList> : interface_type<> {};
template<> struct def<Windows::Media::Core::MseSourceBufferList> : class_type<Platform::Object, Windows::Media::Core::IMseSourceBufferList> {};
template<> struct def<Windows::Media::Core::IMseSourceBuffer> : interface_type<> {};
template<> struct def<Windows::Media::Core::MseSourceBuffer> : class_type<Platform::Object, Windows::Media::Core::IMseSourceBuffer> {};
template<> struct def<Windows::Media::Core::IMediaSourceAppServiceConnectionFactory> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMediaSourceAppServiceConnection> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaSourceAppServiceConnection> : class_type<Platform::Object, Windows::Media::Core::IMediaSourceAppServiceConnection>, custom_activators {};
template<> struct def<Windows::Media::Core::IInitializeMediaStreamSourceRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs> : class_type<Platform::Object, Windows::Media::Core::IInitializeMediaStreamSourceRequestedEventArgs> {};
template<> struct def<Windows::Media::Core::IHighDynamicRangeControl> : interface_type<> {};
template<> struct def<Windows::Media::Core::HighDynamicRangeControl> : class_type<Platform::Object, Windows::Media::Core::IHighDynamicRangeControl> {};
template<> struct def<Windows::Media::Core::ISceneAnalysisEffect> : interface_type<Windows::Media::IMediaExtension> {};
template<> struct def<Windows::Media::Core::SceneAnalysisEffect> : class_type<Platform::Object, Windows::Media::Core::ISceneAnalysisEffect> {};
template<> struct def<Windows::Media::Core::ISceneAnalyzedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::SceneAnalyzedEventArgs> : class_type<Platform::Object, Windows::Media::Core::ISceneAnalyzedEventArgs> {};
template<> struct def<Windows::Media::Core::IHighDynamicRangeOutput> : interface_type<> {};
template<> struct def<Windows::Media::Core::HighDynamicRangeOutput> : class_type<Platform::Object, Windows::Media::Core::IHighDynamicRangeOutput> {};
template<> struct def<Windows::Media::Core::SceneAnalysisRecommendation> : enum_type<int> {};
template<> struct def<Windows::Media::Core::ISceneAnalysisEffectFrame> : interface_type<Windows::Media::IMediaFrame, Windows::Foundation::IClosable> {};
template<> struct def<Windows::Media::Core::ISceneAnalysisEffectFrame2> : interface_type<Windows::Media::IMediaFrame, Windows::Foundation::IClosable> {};
template<> struct def<Windows::Media::Core::SceneAnalysisEffectFrame> : class_type<Platform::Object, Windows::Media::Core::ISceneAnalysisEffectFrame, Windows::Media::Core::ISceneAnalysisEffectFrame2> {};
template<> struct def<Windows::Media::Core::SceneAnalysisEffectDefinition> : class_type<Platform::Object, Windows::Media::Effects::IVideoEffectDefinition> {};
template<> struct def<Windows::Media::Core::IFaceDetectionEffectFrame> : interface_type<Windows::Media::IMediaFrame, Windows::Foundation::IClosable> {};
template<> struct def<Windows::Media::Core::FaceDetectionEffectFrame> : class_type<Platform::Object, Windows::Media::Core::IFaceDetectionEffectFrame> {};
template<> struct def<Windows::Media::Core::IFaceDetectedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::FaceDetectedEventArgs> : class_type<Platform::Object, Windows::Media::Core::IFaceDetectedEventArgs> {};
template<> struct def<Windows::Media::Core::IFaceDetectionEffect> : interface_type<Windows::Media::IMediaExtension> {};
template<> struct def<Windows::Media::Core::FaceDetectionEffect> : class_type<Platform::Object, Windows::Media::Core::IFaceDetectionEffect> {};
template<> struct def<Windows::Media::Core::FaceDetectionMode> : enum_type<int> {};
template<> struct def<Windows::Media::Core::IFaceDetectionEffectDefinition> : interface_type<Windows::Media::Effects::IVideoEffectDefinition> {};
template<> struct def<Windows::Media::Core::FaceDetectionEffectDefinition> : class_type<Platform::Object, Windows::Media::Effects::IVideoEffectDefinition, Windows::Media::Core::IFaceDetectionEffectDefinition> {};
template<> struct def<Windows::Media::Core::VideoStabilizationEffectEnabledChangedReason> : enum_type<int> {};
template<> struct def<Windows::Media::Core::IVideoStabilizationEffectEnabledChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs> : class_type<Platform::Object, Windows::Media::Core::IVideoStabilizationEffectEnabledChangedEventArgs> {};
template<> struct def<Windows::Media::Core::IVideoStabilizationEffect> : interface_type<Windows::Media::IMediaExtension> {};
template<> struct def<Windows::Media::Core::VideoStabilizationEffect> : class_type<Platform::Object, Windows::Media::Core::IVideoStabilizationEffect> {};
template<> struct def<Windows::Media::Core::VideoStabilizationEffectDefinition> : class_type<Platform::Object, Windows::Media::Effects::IVideoEffectDefinition> {};
template<> struct def<Windows::Media::Core::MediaTrackKind> : enum_type<int> {};
template<> struct def<Windows::Media::Core::TimedMetadataKind> : enum_type<int> {};
template<> struct def<Windows::Media::Core::TimedMetadataTrackErrorCode> : enum_type<int> {};
template<> struct def<Windows::Media::Core::MediaDecoderStatus> : enum_type<int> {};
template<> struct def<Windows::Media::Core::AudioDecoderDegradation> : enum_type<int> {};
template<> struct def<Windows::Media::Core::AudioDecoderDegradationReason> : enum_type<int> {};
template<> struct def<Windows::Media::Core::MediaSourceStatus> : enum_type<int> {};
template<> struct def<Windows::Media::Core::MediaSourceState> : enum_type<int> {};
template<> struct def<Windows::Media::Core::IMediaSourceError> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMediaSourceOpenOperationCompletedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaSourceError> : class_type<Platform::Object, Windows::Media::Core::IMediaSourceError> {};
template<> struct def<Windows::Media::Core::IMediaSourceStateChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMediaSourceStatics> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMediaSourceStatics4> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMediaSourceStatics3> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMediaSourceStatics2> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMediaSource5> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMediaSource2> : interface_type<Windows::Media::Playback::IMediaPlaybackSource, Windows::Foundation::IClosable> {};
template<> struct def<Windows::Media::Core::IMediaSource3> : interface_type<Windows::Media::Core::IMediaSource2> {};
template<> struct def<Windows::Media::Core::IMediaSource4> : interface_type<Windows::Media::Core::IMediaSource3> {};
template<> struct def<Windows::Media::Core::MediaSource> : class_type<Platform::Object, Windows::Media::Core::IMediaSource2, Windows::Media::Core::IMediaSource5, Windows::Media::Core::IMediaSource4> {};
template<> struct def<Windows::Media::Core::IMediaBinder> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaBinder> : class_type<Platform::Object, Windows::Media::Core::IMediaBinder> {};
template<> struct def<Windows::Media::Core::IMediaBindingEventArgs3> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMediaBindingEventArgs2> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMediaBindingEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::MediaBindingEventArgs> : class_type<Platform::Object, Windows::Media::Core::IMediaBindingEventArgs, Windows::Media::Core::IMediaBindingEventArgs2, Windows::Media::Core::IMediaBindingEventArgs3> {};
template<> struct def<Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs> : class_type<Platform::Object, Windows::Media::Core::IMediaSourceOpenOperationCompletedEventArgs> {};
template<> struct def<Windows::Media::Core::ITimedTextSourceStatics2> : interface_type<> {};
template<> struct def<Windows::Media::Core::ITimedTextSourceStatics> : interface_type<> {};
template<> struct def<Windows::Media::Core::ITimedTextSource> : interface_type<> {};
template<> struct def<Windows::Media::Core::TimedTextSource> : class_type<Platform::Object, Windows::Media::Core::ITimedTextSource> {};
template<> struct def<Windows::Media::Core::ITimedMetadataTrackFactory> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMediaTrack> : overridable_type<> {};
template<> struct def<Windows::Media::Core::ITimedMetadataTrack> : interface_type<Windows::Media::Core::IMediaTrack> {};
template<> struct def<Windows::Media::Core::ITimedMetadataTrack2> : interface_type<Windows::Media::Core::ITimedMetadataTrack> {};
template<> struct def<Windows::Media::Core::TimedMetadataTrack> : class_type<Platform::Object, Windows::Media::Core::ITimedMetadataTrack, Windows::Media::Core::ITimedMetadataTrack2>, custom_activators {};
template<> struct def<Windows::Media::Core::MediaSourceStateChangedEventArgs> : class_type<Platform::Object, Windows::Media::Core::IMediaSourceStateChangedEventArgs> {};
template<> struct def<Windows::Media::Core::ISingleSelectMediaTrackList> : overridable_type<> {};
template<> struct def<Windows::Media::Core::ITimedMetadataTrackError> : interface_type<> {};
template<> struct def<Windows::Media::Core::IMediaCueEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::ITimedMetadataTrackFailedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::TimedMetadataTrackError> : class_type<Platform::Object, Windows::Media::Core::ITimedMetadataTrackError> {};
template<> struct def<Windows::Media::Core::ITimedMetadataTrackProvider> : overridable_type<> {};
template<> struct def<Windows::Media::Core::MediaCueEventArgs> : class_type<Platform::Object, Windows::Media::Core::IMediaCueEventArgs> {};
template<> struct def<Windows::Media::Core::TimedMetadataTrackFailedEventArgs> : class_type<Platform::Object, Windows::Media::Core::ITimedMetadataTrackFailedEventArgs> {};
template<> struct def<Windows::Media::Core::ITimedTextSourceResolveResultEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::TimedTextSourceResolveResultEventArgs> : class_type<Platform::Object, Windows::Media::Core::ITimedTextSourceResolveResultEventArgs> {};
template<> struct def<Windows::Media::Core::IVideoTrackSupportInfo> : interface_type<> {};
template<> struct def<Windows::Media::Core::IAudioTrackSupportInfo> : interface_type<> {};
template<> struct def<Windows::Media::Core::IVideoTrackOpenFailedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::IAudioTrackOpenFailedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Core::IVideoTrack> : interface_type<> {};
template<> struct def<Windows::Media::Core::VideoTrack> : class_type<Platform::Object, Windows::Media::Core::IMediaTrack, Windows::Media::Core::IVideoTrack> {};
template<> struct def<Windows::Media::Core::VideoTrackOpenFailedEventArgs> : class_type<Platform::Object, Windows::Media::Core::IVideoTrackOpenFailedEventArgs> {};
template<> struct def<Windows::Media::Core::VideoTrackSupportInfo> : class_type<Platform::Object, Windows::Media::Core::IVideoTrackSupportInfo> {};
template<> struct def<Windows::Media::Core::IAudioTrack> : interface_type<> {};
template<> struct def<Windows::Media::Core::AudioTrack> : class_type<Platform::Object, Windows::Media::Core::IMediaTrack, Windows::Media::Core::IAudioTrack> {};
template<> struct def<Windows::Media::Core::AudioTrackOpenFailedEventArgs> : class_type<Platform::Object, Windows::Media::Core::IAudioTrackOpenFailedEventArgs> {};
template<> struct def<Windows::Media::Core::AudioTrackSupportInfo> : class_type<Platform::Object, Windows::Media::Core::IAudioTrackSupportInfo> {};

// uuids

template<> struct uuid<Windows::Media::Core::IMediaCue> { define_guid(0xC7D15E5D, 0x59DC, 0x431F, 0xA0, 0xEE, 0x27, 0x74, 0x43, 0x23, 0xB3, 0x6D);};
template<> struct uuid<Windows::Media::Core::IDataCue> { define_guid(0x7C7F676D, 0x1FBC, 0x4E2D, 0x9A, 0x87, 0xEE, 0x38, 0xBD, 0x1D, 0xC6, 0x37);};
template<> struct uuid<Windows::Media::Core::IDataCue2> { define_guid(0xBC561B15, 0x95F2, 0x49E8, 0x96, 0xF1, 0x8D, 0xD5, 0xDA, 0xC6, 0x8D, 0x93);};
template<> struct uuid<Windows::Media::Core::IChapterCue> { define_guid(0x72A98001, 0xD38A, 0x4C0A, 0x8F, 0xA6, 0x75, 0xCD, 0xDA, 0xF4, 0x66, 0x4C);};
template<> struct uuid<Windows::Media::Core::IImageCue> { define_guid(0x52828282, 0x367B, 0x440B, 0x91, 0x16, 0x3C, 0x84, 0x57, 0xD, 0xD2, 0x70);};
template<> struct uuid<Windows::Media::Core::ISpeechCue> { define_guid(0xAEE254DC, 0x1725, 0x4BAD, 0x80, 0x43, 0xA9, 0x84, 0x99, 0xB0, 0x17, 0xA2);};
template<> struct uuid<Windows::Media::Core::ITimedTextCue> { define_guid(0x51C79E51, 0x3B86, 0x494D, 0xB3, 0x59, 0xBB, 0x2E, 0xA7, 0xAC, 0xA9, 0xA9);};
template<> struct uuid<Windows::Media::Core::ITimedTextRegion> { define_guid(0x1ED0881F, 0x8A06, 0x4222, 0x9F, 0x59, 0xB2, 0x1B, 0xF4, 0x1, 0x24, 0xB4);};
template<> struct uuid<Windows::Media::Core::ITimedTextStyle2> { define_guid(0x655F492D, 0x6111, 0x4787, 0x89, 0xCC, 0x68, 0x6F, 0xEC, 0xE5, 0x7E, 0x14);};
template<> struct uuid<Windows::Media::Core::ITimedTextStyle> { define_guid(0x1BB2384D, 0xA825, 0x40C2, 0xA7, 0xF5, 0x28, 0x1E, 0xAE, 0xDF, 0x3B, 0x55);};
template<> struct uuid<Windows::Media::Core::ITimedTextLine> { define_guid(0x978D7CE2, 0x7308, 0x4C66, 0xBE, 0x50, 0x65, 0x77, 0x72, 0x89, 0xF5, 0xDF);};
template<> struct uuid<Windows::Media::Core::ITimedTextSubformat> { define_guid(0xD713502F, 0x3261, 0x4722, 0xA0, 0xC2, 0xB9, 0x37, 0xB2, 0x39, 0xF, 0x14);};
template<> struct uuid<Windows::Media::Core::ICodecInfo> { define_guid(0x51E89F85, 0xEA97, 0x499C, 0x86, 0xAC, 0x4C, 0xE5, 0xE7, 0x3F, 0x3A, 0x42);};
template<> struct uuid<Windows::Media::Core::ICodecQuery> { define_guid(0x222A953A, 0xAF61, 0x4E04, 0x80, 0x8A, 0xA4, 0x63, 0x4E, 0x2F, 0x3A, 0xC4);};
template<> struct uuid<Windows::Media::Core::ICodecSubtypesStatics> { define_guid(0xA66AC4F2, 0x888B, 0x4224, 0x8C, 0xF6, 0x2A, 0x8D, 0x4E, 0xB0, 0x23, 0x82);};
template<> struct uuid<Windows::Media::Core::ILowLightFusionStatics> { define_guid(0x5305016D, 0xC29E, 0x40E2, 0x87, 0xA9, 0x9E, 0x1F, 0xD2, 0xF1, 0x92, 0xF5);};
template<> struct uuid<Windows::Media::Core::ILowLightFusionResult> { define_guid(0x78EDBE35, 0x27A0, 0x42E0, 0x9C, 0xD3, 0x73, 0x8D, 0x20, 0x89, 0xDE, 0x9C);};
template<> struct uuid<Windows::Media::Core::IAudioStreamDescriptorFactory> { define_guid(0x4A86CE9E, 0x4CB1, 0x4380, 0x8E, 0xC, 0x83, 0x50, 0x4B, 0x7F, 0x5B, 0xF3);};
template<> struct uuid<Windows::Media::Core::IAudioStreamDescriptor3> { define_guid(0x4D220DA1, 0x8E83, 0x44EF, 0x89, 0x73, 0x2F, 0x63, 0xE9, 0x93, 0xF3, 0x6B);};
template<> struct uuid<Windows::Media::Core::IMediaStreamDescriptor> { define_guid(0x80F16E6E, 0x92F7, 0x451E, 0x97, 0xD2, 0xAF, 0xD8, 0x7, 0x42, 0xDA, 0x70);};
template<> struct uuid<Windows::Media::Core::IMediaStreamDescriptor2> { define_guid(0x5073010F, 0xE8B2, 0x4071, 0xB0, 0xB, 0xEB, 0xF3, 0x37, 0xA7, 0x6B, 0x58);};
template<> struct uuid<Windows::Media::Core::IAudioStreamDescriptor2> { define_guid(0x2E68F1F6, 0xA448, 0x497B, 0x88, 0x40, 0x85, 0x8, 0x26, 0x65, 0xAC, 0xF9);};
template<> struct uuid<Windows::Media::Core::IAudioStreamDescriptor> { define_guid(0x1E3692E4, 0x4027, 0x4847, 0xA7, 0xB, 0xDF, 0x1D, 0x9A, 0x2A, 0x7B, 0x4);};
template<> struct uuid<Windows::Media::Core::IVideoStreamDescriptorFactory> { define_guid(0x494EF6D1, 0xBB75, 0x43D2, 0x9E, 0x5E, 0x7B, 0x79, 0xA3, 0xAF, 0xCE, 0xD4);};
template<> struct uuid<Windows::Media::Core::IVideoStreamDescriptor2> { define_guid(0x8B306E10, 0x453E, 0x4088, 0x83, 0x2D, 0xC3, 0x6F, 0xA4, 0xF9, 0x4A, 0xF3);};
template<> struct uuid<Windows::Media::Core::IVideoStreamDescriptor> { define_guid(0x12EE0D55, 0x9C2B, 0x4440, 0x80, 0x57, 0x2C, 0x7A, 0x90, 0xF0, 0xCB, 0xEC);};
template<> struct uuid<Windows::Media::Core::ITimedMetadataStreamDescriptorFactory> { define_guid(0xC027DE30, 0x7362, 0x4FF9, 0x98, 0xB1, 0x2D, 0xFD, 0xB, 0x8D, 0x1C, 0xAE);};
template<> struct uuid<Windows::Media::Core::ITimedMetadataStreamDescriptor> { define_guid(0x133336BF, 0x296A, 0x463E, 0x9F, 0xF9, 0x1, 0xCD, 0x25, 0x69, 0x14, 0x8);};
template<> struct uuid<Windows::Media::Core::IMediaSource> { define_guid(0xE7BFB599, 0xA09D, 0x4C21, 0xBC, 0xDF, 0x20, 0xAF, 0x4F, 0x86, 0xB3, 0xD9);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSource> { define_guid(0x3712D543, 0x45EB, 0x4138, 0xAA, 0x62, 0xC0, 0x1E, 0x26, 0xF3, 0x84, 0x3F);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSourceFactory> { define_guid(0xEF77E0D9, 0xD158, 0x4B7A, 0x86, 0x3F, 0x20, 0x33, 0x42, 0xFB, 0xFD, 0x41);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSource4> { define_guid(0x1D0CFCAB, 0x830D, 0x417C, 0xA3, 0xA9, 0x24, 0x54, 0xFD, 0x64, 0x15, 0xC7);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSource3> { define_guid(0x6A2A2746, 0x3DDD, 0x4DDF, 0xA1, 0x21, 0x94, 0x4, 0x5E, 0xCF, 0x94, 0x40);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSource2> { define_guid(0xEC55D0AD, 0x2E6A, 0x4F74, 0xAD, 0xBB, 0xB5, 0x62, 0xD1, 0x53, 0x38, 0x49);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSourceClosedEventArgs> { define_guid(0xCD8C7EB2, 0x4816, 0x4E24, 0x88, 0xF0, 0x49, 0x1E, 0xF7, 0x38, 0x64, 0x6);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSourceStartingEventArgs> { define_guid(0xF41468F2, 0xC274, 0x4940, 0xA5, 0xBB, 0x28, 0xA5, 0x72, 0x45, 0x2F, 0xA7);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSourceSampleRequestedEventArgs> { define_guid(0x10F9BB9E, 0x71C5, 0x492F, 0x84, 0x7F, 0xD, 0xA1, 0xF3, 0x5E, 0x81, 0xF8);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSourceSwitchStreamsRequestedEventArgs> { define_guid(0x42202B72, 0x6EA1, 0x4677, 0x98, 0x1E, 0x35, 0xA, 0xD, 0xA4, 0x12, 0xAA);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSourceSampleRenderedEventArgs> { define_guid(0x9D697B05, 0xD4F2, 0x4C7A, 0x9D, 0xFE, 0x8D, 0x6C, 0xD0, 0xB3, 0xEE, 0x84);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSample> { define_guid(0x5C8DB627, 0x4B80, 0x4361, 0x98, 0x37, 0x6C, 0xB7, 0x48, 0x1A, 0xD9, 0xD6);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSampleStatics> { define_guid(0xDFDF218F, 0xA6CF, 0x4579, 0xBE, 0x41, 0x73, 0xDD, 0x94, 0x1A, 0xD9, 0x72);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSampleProtectionProperties> { define_guid(0x4EB88292, 0xECDF, 0x493E, 0x84, 0x1D, 0xDD, 0x4A, 0xDD, 0x7C, 0xAC, 0xA2);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSourceClosedRequest> { define_guid(0x907C00E9, 0x18A3, 0x4951, 0x88, 0x7A, 0x2C, 0x1E, 0xEB, 0xD5, 0xC6, 0x9E);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSourceStartingRequestDeferral> { define_guid(0x3F1356A5, 0x6340, 0x4DC4, 0x99, 0x10, 0x6, 0x8E, 0xD9, 0xF5, 0x98, 0xF8);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSourceStartingRequest> { define_guid(0x2A9093E4, 0x35C4, 0x4B1B, 0xA7, 0x91, 0xD, 0x99, 0xDB, 0x56, 0xDD, 0x1D);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSourceSampleRequestDeferral> { define_guid(0x7895CC02, 0xF982, 0x43C8, 0x9D, 0x16, 0xC6, 0x2D, 0x99, 0x93, 0x19, 0xBE);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSourceSampleRequest> { define_guid(0x4DB341A9, 0x3501, 0x4D9B, 0x83, 0xF9, 0x8F, 0x23, 0x5C, 0x82, 0x25, 0x32);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSourceSwitchStreamsRequestDeferral> { define_guid(0xBEE3D835, 0xA505, 0x4F9A, 0xB9, 0x43, 0x2B, 0x8C, 0xB1, 0xB4, 0xBB, 0xD9);};
template<> struct uuid<Windows::Media::Core::IMediaStreamSourceSwitchStreamsRequest> { define_guid(0x41B8808E, 0x38A9, 0x4EC3, 0x9B, 0xA0, 0xB6, 0x9B, 0x85, 0x50, 0x1E, 0x90);};
template<> struct uuid<Windows::Media::Core::IMseStreamSourceStatics> { define_guid(0x465C679D, 0xD570, 0x43CE, 0xBA, 0x21, 0xB, 0xFF, 0x5F, 0x3F, 0xBD, 0xA);};
template<> struct uuid<Windows::Media::Core::IMseStreamSource> { define_guid(0xB0B4198D, 0x2F4, 0x4923, 0x88, 0xDD, 0x81, 0xBC, 0x3F, 0x36, 0xF, 0xFA);};
template<> struct uuid<Windows::Media::Core::IMseStreamSource2> { define_guid(0x66F57D37, 0xF9E7, 0x418A, 0x9C, 0xDE, 0xA0, 0x20, 0xE9, 0x56, 0x55, 0x2B);};
template<> struct uuid<Windows::Media::Core::IMseSourceBufferList> { define_guid(0x95FAE8E7, 0xA8E7, 0x4EBF, 0x89, 0x27, 0x14, 0x5E, 0x94, 0xB, 0xA5, 0x11);};
template<> struct uuid<Windows::Media::Core::IMseSourceBuffer> { define_guid(0xC1AA3E3, 0xDF8D, 0x4079, 0xA3, 0xFE, 0x68, 0x49, 0x18, 0x4B, 0x4E, 0x2F);};
template<> struct uuid<Windows::Media::Core::IMediaSourceAppServiceConnectionFactory> { define_guid(0x65B912EB, 0x80B9, 0x44F9, 0x9C, 0x1E, 0xE1, 0x20, 0xF6, 0xD9, 0x28, 0x38);};
template<> struct uuid<Windows::Media::Core::IMediaSourceAppServiceConnection> { define_guid(0x61E1EA97, 0x1916, 0x4810, 0xB7, 0xF4, 0xB6, 0x42, 0xBE, 0x82, 0x95, 0x96);};
template<> struct uuid<Windows::Media::Core::IInitializeMediaStreamSourceRequestedEventArgs> { define_guid(0x25BC45E1, 0x9B08, 0x4C2E, 0xA8, 0x55, 0x45, 0x42, 0xF1, 0xA7, 0x5D, 0xEB);};
template<> struct uuid<Windows::Media::Core::IHighDynamicRangeControl> { define_guid(0x55F1A7AE, 0xD957, 0x4DC9, 0x9D, 0x1C, 0x85, 0x53, 0xA8, 0x2A, 0x7D, 0x99);};
template<> struct uuid<Windows::Media::Core::ISceneAnalysisEffect> { define_guid(0xC04BA319, 0xCA41, 0x4813, 0xBF, 0xFD, 0x7B, 0x8, 0xB0, 0xED, 0x25, 0x57);};
template<> struct uuid<Windows::Media::Core::ISceneAnalyzedEventArgs> { define_guid(0x146B9588, 0x2851, 0x45E4, 0xAD, 0x55, 0x44, 0xCF, 0x8D, 0xF8, 0xDB, 0x4D);};
template<> struct uuid<Windows::Media::Core::IHighDynamicRangeOutput> { define_guid(0xF57806B, 0x253B, 0x4119, 0xBB, 0x40, 0x3A, 0x90, 0xE5, 0x13, 0x84, 0xF7);};
template<> struct uuid<Windows::Media::Core::ISceneAnalysisEffectFrame> { define_guid(0xD8B10E4C, 0x7FD9, 0x42E1, 0x85, 0xEB, 0x65, 0x72, 0xC2, 0x97, 0xC9, 0x87);};
template<> struct uuid<Windows::Media::Core::ISceneAnalysisEffectFrame2> { define_guid(0x2D4E29BE, 0x61F, 0x47AE, 0x99, 0x15, 0x2, 0x52, 0x4B, 0x5F, 0x9A, 0x5F);};
template<> struct uuid<Windows::Media::Core::IFaceDetectionEffectFrame> { define_guid(0x8AB08993, 0x5DC8, 0x447B, 0xA2, 0x47, 0x52, 0x70, 0xBD, 0x80, 0x2E, 0xCE);};
template<> struct uuid<Windows::Media::Core::IFaceDetectedEventArgs> { define_guid(0x19918426, 0xC65B, 0x46BA, 0x85, 0xF8, 0x13, 0x88, 0x5, 0x76, 0xC9, 0xA);};
template<> struct uuid<Windows::Media::Core::IFaceDetectionEffect> { define_guid(0xAE15EBD2, 0x542, 0x42A9, 0xBC, 0x90, 0xF2, 0x83, 0xA2, 0x9F, 0x46, 0xC1);};
template<> struct uuid<Windows::Media::Core::IFaceDetectionEffectDefinition> { define_guid(0x43DCA081, 0xB848, 0x4F33, 0xB7, 0x2, 0x1F, 0xD2, 0x62, 0x4F, 0xB0, 0x16);};
template<> struct uuid<Windows::Media::Core::IVideoStabilizationEffectEnabledChangedEventArgs> { define_guid(0x187EFF28, 0x67BB, 0x4713, 0xB9, 0x0, 0x41, 0x68, 0xDA, 0x16, 0x45, 0x29);};
template<> struct uuid<Windows::Media::Core::IVideoStabilizationEffect> { define_guid(0x808A650, 0x9698, 0x4E57, 0x87, 0x7B, 0xBD, 0x7C, 0xB2, 0xEE, 0xF, 0x8A);};
template<> struct uuid<Windows::Media::Core::IMediaSourceError> { define_guid(0x5C0A8965, 0x37C5, 0x4E9D, 0x8D, 0x21, 0x1C, 0xDE, 0xE9, 0xC, 0xEC, 0xC6);};
template<> struct uuid<Windows::Media::Core::IMediaSourceOpenOperationCompletedEventArgs> { define_guid(0xFC682CEB, 0xE281, 0x477C, 0xA8, 0xE0, 0x1A, 0xCD, 0x65, 0x41, 0x14, 0xC8);};
template<> struct uuid<Windows::Media::Core::IMediaSourceStateChangedEventArgs> { define_guid(0xA30AF82, 0x9071, 0x4BAC, 0xBC, 0x39, 0xCA, 0x2A, 0x93, 0xB7, 0x17, 0xA9);};
template<> struct uuid<Windows::Media::Core::IMediaSourceStatics> { define_guid(0xF77D6FA4, 0x4652, 0x410E, 0xB1, 0xD8, 0xE9, 0xA5, 0xE2, 0x45, 0xA4, 0x5C);};
template<> struct uuid<Windows::Media::Core::IMediaSourceStatics4> { define_guid(0x281B3BFC, 0xE50A, 0x4428, 0xA5, 0x0, 0x9C, 0x4E, 0xD9, 0x18, 0xD3, 0xF0);};
template<> struct uuid<Windows::Media::Core::IMediaSourceStatics3> { define_guid(0x453A30D6, 0x2BEA, 0x4122, 0x9F, 0x73, 0xEA, 0xCE, 0x4, 0x52, 0x6E, 0x35);};
template<> struct uuid<Windows::Media::Core::IMediaSourceStatics2> { define_guid(0xEEE161A4, 0x7F13, 0x4896, 0xB8, 0xCB, 0xDF, 0xD, 0xE5, 0xBC, 0xB9, 0xF1);};
template<> struct uuid<Windows::Media::Core::IMediaSource5> { define_guid(0x331A22AE, 0xED2E, 0x4A22, 0x94, 0xC8, 0xB7, 0x43, 0xA9, 0x2B, 0x30, 0x22);};
template<> struct uuid<Windows::Media::Core::IMediaSource2> { define_guid(0x2EB61048, 0x655F, 0x4C37, 0xB8, 0x13, 0xB4, 0xE4, 0x5D, 0xFA, 0xA, 0xBE);};
template<> struct uuid<Windows::Media::Core::IMediaSource3> { define_guid(0xB59F0D9B, 0x4B6E, 0x41ED, 0xBB, 0xB4, 0x7C, 0x75, 0x9, 0xA9, 0x94, 0xAD);};
template<> struct uuid<Windows::Media::Core::IMediaSource4> { define_guid(0xBDAFAD57, 0x8EFF, 0x4C63, 0x85, 0xA6, 0x84, 0xDE, 0xA, 0xE3, 0xE4, 0xF2);};
template<> struct uuid<Windows::Media::Core::IMediaBinder> { define_guid(0x2B7E40AA, 0xDE07, 0x424F, 0x83, 0xF1, 0xF1, 0xDE, 0x46, 0xC4, 0xFA, 0x2E);};
template<> struct uuid<Windows::Media::Core::IMediaBindingEventArgs3> { define_guid(0xF8EB475E, 0x19BE, 0x44FC, 0xA5, 0xED, 0x7A, 0xBA, 0x31, 0x50, 0x37, 0xF9);};
template<> struct uuid<Windows::Media::Core::IMediaBindingEventArgs2> { define_guid(0x464CCEB, 0xBB5A, 0x482F, 0xB8, 0xBA, 0xF0, 0x28, 0x4C, 0x69, 0x65, 0x67);};
template<> struct uuid<Windows::Media::Core::IMediaBindingEventArgs> { define_guid(0xB61CB25A, 0x1B6D, 0x4630, 0xA8, 0x6D, 0x2F, 0x8, 0x37, 0xF7, 0x12, 0xE5);};
template<> struct uuid<Windows::Media::Core::ITimedTextSourceStatics2> { define_guid(0xB66B7602, 0x923E, 0x43FA, 0x96, 0x33, 0x58, 0x70, 0x75, 0x81, 0x2D, 0xB5);};
template<> struct uuid<Windows::Media::Core::ITimedTextSourceStatics> { define_guid(0x7E311853, 0x9ABA, 0x4AC4, 0xBB, 0x98, 0x2F, 0xB1, 0x76, 0xC3, 0xBF, 0xDD);};
template<> struct uuid<Windows::Media::Core::ITimedTextSource> { define_guid(0xC4ED9BA6, 0x101F, 0x404D, 0xA9, 0x49, 0x82, 0xF3, 0x3F, 0xCD, 0x93, 0xB7);};
template<> struct uuid<Windows::Media::Core::ITimedMetadataTrackFactory> { define_guid(0x8DD57611, 0x97B3, 0x4E1F, 0x85, 0x2C, 0xF, 0x48, 0x2C, 0x81, 0xAD, 0x26);};
template<> struct uuid<Windows::Media::Core::IMediaTrack> { define_guid(0x3E1FAFC, 0xC931, 0x491A, 0xB4, 0x6B, 0xC1, 0xE, 0xE8, 0xC2, 0x56, 0xB7);};
template<> struct uuid<Windows::Media::Core::ITimedMetadataTrack> { define_guid(0x9E6AED9E, 0xF67A, 0x49A9, 0xB3, 0x30, 0xCF, 0x3, 0xB0, 0xE9, 0xCF, 0x7);};
template<> struct uuid<Windows::Media::Core::ITimedMetadataTrack2> { define_guid(0x21B4B648, 0x9F9D, 0x40BA, 0xA8, 0xF3, 0x1A, 0x92, 0x75, 0x3A, 0xEF, 0xB);};
template<> struct uuid<Windows::Media::Core::ISingleSelectMediaTrackList> { define_guid(0x77206F1F, 0xC34F, 0x494F, 0x80, 0x77, 0x2B, 0xAD, 0x9F, 0xF4, 0xEC, 0xF1);};
template<> struct uuid<Windows::Media::Core::ITimedMetadataTrackError> { define_guid(0xB3767915, 0x4114, 0x4819, 0xB9, 0xD9, 0xDD, 0x76, 0x8, 0x9E, 0x72, 0xF8);};
template<> struct uuid<Windows::Media::Core::IMediaCueEventArgs> { define_guid(0xD12F47F7, 0x5FA4, 0x4E68, 0x9F, 0xE5, 0x32, 0x16, 0xD, 0xCE, 0xE5, 0x7E);};
template<> struct uuid<Windows::Media::Core::ITimedMetadataTrackFailedEventArgs> { define_guid(0xA57FC9D1, 0x6789, 0x4D4D, 0xB0, 0x7F, 0x84, 0xB4, 0xF3, 0x1A, 0xCB, 0x70);};
template<> struct uuid<Windows::Media::Core::ITimedMetadataTrackProvider> { define_guid(0x3B7F2024, 0xF74E, 0x4ADE, 0x93, 0xC5, 0x21, 0x9D, 0xA0, 0x5B, 0x68, 0x56);};
template<> struct uuid<Windows::Media::Core::ITimedTextSourceResolveResultEventArgs> { define_guid(0x48907C9C, 0xDCD8, 0x4C33, 0x9A, 0xD3, 0x6C, 0xDC, 0xE7, 0xB1, 0xC5, 0x66);};
template<> struct uuid<Windows::Media::Core::IVideoTrackSupportInfo> { define_guid(0x4BB534A0, 0xFC5F, 0x450D, 0x8F, 0xF0, 0x77, 0x8D, 0x59, 0x4, 0x86, 0xDE);};
template<> struct uuid<Windows::Media::Core::IAudioTrackSupportInfo> { define_guid(0x178BEFF7, 0xCC39, 0x44A6, 0xB9, 0x51, 0x4A, 0x56, 0x53, 0xF0, 0x73, 0xFA);};
template<> struct uuid<Windows::Media::Core::IVideoTrackOpenFailedEventArgs> { define_guid(0x7679E231, 0x4F9, 0x4C82, 0xA4, 0xEE, 0x86, 0x2, 0xC8, 0xBB, 0x47, 0x54);};
template<> struct uuid<Windows::Media::Core::IAudioTrackOpenFailedEventArgs> { define_guid(0xEEDDB9B9, 0xBB7C, 0x4112, 0xBF, 0x76, 0x93, 0x84, 0x67, 0x6F, 0x82, 0x4B);};
template<> struct uuid<Windows::Media::Core::IVideoTrack> { define_guid(0x99F3B7F3, 0xE298, 0x4396, 0xBB, 0x6A, 0xA5, 0x1B, 0xE6, 0xA2, 0xA2, 0xA);};
template<> struct uuid<Windows::Media::Core::IAudioTrack> { define_guid(0xF23B6E77, 0x3EF7, 0x40DE, 0xB9, 0x43, 0x6, 0x8B, 0x13, 0x21, 0x70, 0x1D);};

// types

namespace Windows { namespace Media { namespace Core {

// IMediaCue
struct IMediaCue_raw : IInspectable {
	virtual STDMETHODIMP _put_StartTime(Foundation::TimeSpan value) = 0;
	virtual STDMETHODIMP _get_StartTime(Foundation::TimeSpan *value) = 0;
	virtual STDMETHODIMP _put_Duration(Foundation::TimeSpan value) = 0;
	virtual STDMETHODIMP _get_Duration(Foundation::TimeSpan *value) = 0;
	virtual STDMETHODIMP _put_Id(HSTRING value) = 0;
	virtual STDMETHODIMP _get_Id(HSTRING *value) = 0;
};
template<typename X> struct IMediaCue_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaCue_adaptor::Duration)->_get_Duration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMediaCue_adaptor::Duration)->_put_Duration(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Duration;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMediaCue_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IMediaCue_adaptor::Id)->_put_Id(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Id;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaCue_adaptor::StartTime)->_get_StartTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMediaCue_adaptor::StartTime)->_put_StartTime(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} StartTime;
	};
	IMediaCue_adaptor() {}
};
template<typename X> struct adapt<IMediaCue, X> : Windows::Media::Core::IMediaCue_adaptor<X> { typedef adapt IMediaCue; };
template<typename X> struct IMediaCue_unadaptor : X {
	STDMETHODIMP _put_StartTime(Foundation::TimeSpan value) { return hrtry([&, this] { put_prop(value, StartTime); }); }
	STDMETHODIMP _get_StartTime(Foundation::TimeSpan *value) { return hrtry([&, this] { get_prop(value, StartTime); }); }
	STDMETHODIMP _put_Duration(Foundation::TimeSpan value) { return hrtry([&, this] { put_prop(value, Duration); }); }
	STDMETHODIMP _get_Duration(Foundation::TimeSpan *value) { return hrtry([&, this] { get_prop(value, Duration); }); }
	STDMETHODIMP _put_Id(HSTRING value) { return hrtry([&, this] { put_prop(value, Id); }); }
	STDMETHODIMP _get_Id(HSTRING *value) { return hrtry([&, this] { get_prop(value, Id); }); }
};
template<typename X> struct unadapt<IMediaCue, X> : Windows::Media::Core::IMediaCue_unadaptor<X> {};
struct IMediaCue : IMediaCue_raw, generate<IMediaCue> {};

// IDataCue
struct IDataCue_raw : IInspectable {
	virtual STDMETHODIMP _put_Data(Storage::Streams::IBuffer* value);
	virtual STDMETHODIMP _get_Data(Storage::Streams::IBuffer* *value);
};
template<typename X> struct IDataCue_adaptor : X {
	union {
		struct : property {
			ptr<Storage::Streams::IBuffer> get() { Storage::Streams::IBuffer* value; hrcheck(enc(&IDataCue_adaptor::Data)->_get_Data(&value)); return from_abi(value); }
			ptr<Storage::Streams::IBuffer> operator()() { return get(); }
			operator ptr<Storage::Streams::IBuffer> () { return get(); }
			ptr<Storage::Streams::IBuffer> operator->() { return get(); }
			void put(pptr<Storage::Streams::IBuffer> value) { hrcheck(enc(&IDataCue_adaptor::Data)->_put_Data(value)); }
			void operator=(pptr<Storage::Streams::IBuffer> value) { put(value); }
			void operator()(pptr<Storage::Streams::IBuffer> value) { put(value); }
		} Data;
	};
	IDataCue_adaptor() {}
};
template<typename X> struct adapt<IDataCue, X> : Windows::Media::Core::IDataCue_adaptor<X> { typedef adapt IDataCue; };
struct IDataCue : IDataCue_raw, generate<IDataCue> {};

// IDataCue2
struct IDataCue2_raw : IInspectable {
	virtual STDMETHODIMP _get_Properties(Foundation::Collections::PropertySet* *value);
};
template<typename X> struct IDataCue2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::PropertySet> get() { Foundation::Collections::PropertySet* value; hrcheck(enc(&IDataCue2_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::PropertySet> operator()() { return get(); }
			operator ptr<Foundation::Collections::PropertySet> () { return get(); }
			ptr<Foundation::Collections::PropertySet> operator->() { return get(); }
		} Properties;
	};
	IDataCue2_adaptor() {}
};
template<typename X> struct adapt<IDataCue2, X> : Windows::Media::Core::IDataCue2_adaptor<X> { typedef adapt IDataCue2; };
struct IDataCue2 : IDataCue2_raw, generate<IDataCue2> {};

// IChapterCue
struct IChapterCue_raw : IInspectable {
	virtual STDMETHODIMP _put_Title(HSTRING value);
	virtual STDMETHODIMP _get_Title(HSTRING *value);
};
template<typename X> struct IChapterCue_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IChapterCue_adaptor::Title)->_get_Title(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IChapterCue_adaptor::Title)->_put_Title(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Title;
	};
	IChapterCue_adaptor() {}
};
template<typename X> struct adapt<IChapterCue, X> : Windows::Media::Core::IChapterCue_adaptor<X> { typedef adapt IChapterCue; };
struct IChapterCue : IChapterCue_raw, generate<IChapterCue> {};

// IImageCue
struct IImageCue_raw : IInspectable {
	virtual STDMETHODIMP _get_Position(TimedTextPoint *value);
	virtual STDMETHODIMP _put_Position(TimedTextPoint value);
	virtual STDMETHODIMP _get_Extent(TimedTextSize *value);
	virtual STDMETHODIMP _put_Extent(TimedTextSize value);
	virtual STDMETHODIMP _put_SoftwareBitmap(Graphics::Imaging::SoftwareBitmap* value);
	virtual STDMETHODIMP _get_SoftwareBitmap(Graphics::Imaging::SoftwareBitmap* *value);
};
template<typename X> struct IImageCue_adaptor : X {
	union {
		struct : property {
			TimedTextSize get() { TimedTextSize value; hrcheck(enc(&IImageCue_adaptor::Extent)->_get_Extent(&value)); return value; }
			TimedTextSize operator()() { return get(); }
			operator TimedTextSize () { return get(); }
			void put(const TimedTextSize& value) { hrcheck(enc(&IImageCue_adaptor::Extent)->_put_Extent(value)); }
			void operator=(const TimedTextSize& value) { put(value); }
			void operator()(const TimedTextSize& value) { put(value); }
		} Extent;
		struct : property {
			TimedTextPoint get() { TimedTextPoint value; hrcheck(enc(&IImageCue_adaptor::Position)->_get_Position(&value)); return value; }
			TimedTextPoint operator()() { return get(); }
			operator TimedTextPoint () { return get(); }
			void put(const TimedTextPoint& value) { hrcheck(enc(&IImageCue_adaptor::Position)->_put_Position(value)); }
			void operator=(const TimedTextPoint& value) { put(value); }
			void operator()(const TimedTextPoint& value) { put(value); }
		} Position;
		struct : property {
			ptr<Graphics::Imaging::SoftwareBitmap> get() { Graphics::Imaging::SoftwareBitmap* value; hrcheck(enc(&IImageCue_adaptor::SoftwareBitmap)->_get_SoftwareBitmap(&value)); return from_abi(value); }
			ptr<Graphics::Imaging::SoftwareBitmap> operator()() { return get(); }
			operator ptr<Graphics::Imaging::SoftwareBitmap> () { return get(); }
			ptr<Graphics::Imaging::SoftwareBitmap> operator->() { return get(); }
			void put(pptr<Graphics::Imaging::SoftwareBitmap> value) { hrcheck(enc(&IImageCue_adaptor::SoftwareBitmap)->_put_SoftwareBitmap(value)); }
			void operator=(pptr<Graphics::Imaging::SoftwareBitmap> value) { put(value); }
			void operator()(pptr<Graphics::Imaging::SoftwareBitmap> value) { put(value); }
		} SoftwareBitmap;
	};
	IImageCue_adaptor() {}
};
template<typename X> struct adapt<IImageCue, X> : Windows::Media::Core::IImageCue_adaptor<X> { typedef adapt IImageCue; };
struct IImageCue : IImageCue_raw, generate<IImageCue> {};

// ISpeechCue
struct ISpeechCue_raw : IInspectable {
	virtual STDMETHODIMP _get_Text(HSTRING *value);
	virtual STDMETHODIMP _put_Text(HSTRING value);
	virtual STDMETHODIMP _get_StartPositionInInput(Foundation::IReference<int>* *value);
	virtual STDMETHODIMP _put_StartPositionInInput(Foundation::IReference<int>* value);
	virtual STDMETHODIMP _get_EndPositionInInput(Foundation::IReference<int>* *value);
	virtual STDMETHODIMP _put_EndPositionInInput(Foundation::IReference<int>* value);
};
template<typename X> struct ISpeechCue_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<int>> get() { Foundation::IReference<int>* value; hrcheck(enc(&ISpeechCue_adaptor::EndPositionInInput)->_get_EndPositionInInput(&value)); return from_abi(value); }
			ptr<Foundation::IReference<int>> operator()() { return get(); }
			operator ptr<Foundation::IReference<int>> () { return get(); }
			ptr<Foundation::IReference<int>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<int>> value) { hrcheck(enc(&ISpeechCue_adaptor::EndPositionInInput)->_put_EndPositionInInput(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
		} EndPositionInInput;
		struct : property {
			ptr<Foundation::IReference<int>> get() { Foundation::IReference<int>* value; hrcheck(enc(&ISpeechCue_adaptor::StartPositionInInput)->_get_StartPositionInInput(&value)); return from_abi(value); }
			ptr<Foundation::IReference<int>> operator()() { return get(); }
			operator ptr<Foundation::IReference<int>> () { return get(); }
			ptr<Foundation::IReference<int>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<int>> value) { hrcheck(enc(&ISpeechCue_adaptor::StartPositionInInput)->_put_StartPositionInInput(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
		} StartPositionInInput;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISpeechCue_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISpeechCue_adaptor::Text)->_put_Text(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Text;
	};
	ISpeechCue_adaptor() {}
};
template<typename X> struct adapt<ISpeechCue, X> : Windows::Media::Core::ISpeechCue_adaptor<X> { typedef adapt ISpeechCue; };
struct ISpeechCue : ISpeechCue_raw, generate<ISpeechCue> {};

// ITimedTextCue
struct ITimedTextCue_raw : IInspectable {
	virtual STDMETHODIMP _get_CueRegion(TimedTextRegion* *value);
	virtual STDMETHODIMP _put_CueRegion(TimedTextRegion* value);
	virtual STDMETHODIMP _get_CueStyle(TimedTextStyle* *value);
	virtual STDMETHODIMP _put_CueStyle(TimedTextStyle* value);
	virtual STDMETHODIMP _get_Lines(Foundation::Collections::IVector<TimedTextLine*>* *value);
};
template<typename X> struct ITimedTextCue_adaptor : X {
	union {
		struct : property {
			ptr<TimedTextRegion> get() { TimedTextRegion* value; hrcheck(enc(&ITimedTextCue_adaptor::CueRegion)->_get_CueRegion(&value)); return from_abi(value); }
			ptr<TimedTextRegion> operator()() { return get(); }
			operator ptr<TimedTextRegion> () { return get(); }
			ptr<TimedTextRegion> operator->() { return get(); }
			void put(pptr<TimedTextRegion> value) { hrcheck(enc(&ITimedTextCue_adaptor::CueRegion)->_put_CueRegion(value)); }
			void operator=(pptr<TimedTextRegion> value) { put(value); }
			void operator()(pptr<TimedTextRegion> value) { put(value); }
		} CueRegion;
		struct : property {
			ptr<TimedTextStyle> get() { TimedTextStyle* value; hrcheck(enc(&ITimedTextCue_adaptor::CueStyle)->_get_CueStyle(&value)); return from_abi(value); }
			ptr<TimedTextStyle> operator()() { return get(); }
			operator ptr<TimedTextStyle> () { return get(); }
			ptr<TimedTextStyle> operator->() { return get(); }
			void put(pptr<TimedTextStyle> value) { hrcheck(enc(&ITimedTextCue_adaptor::CueStyle)->_put_CueStyle(value)); }
			void operator=(pptr<TimedTextStyle> value) { put(value); }
			void operator()(pptr<TimedTextStyle> value) { put(value); }
		} CueStyle;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<TimedTextLine>>> get() { Foundation::Collections::IVector<TimedTextLine*>* value; hrcheck(enc(&ITimedTextCue_adaptor::Lines)->_get_Lines(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<TimedTextLine>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<TimedTextLine>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<TimedTextLine>>> operator->() { return get(); }
		} Lines;
	};
	ITimedTextCue_adaptor() {}
};
template<typename X> struct adapt<ITimedTextCue, X> : Windows::Media::Core::ITimedTextCue_adaptor<X> { typedef adapt ITimedTextCue; };
struct ITimedTextCue : ITimedTextCue_raw, generate<ITimedTextCue> {};

// ITimedTextRegion
struct ITimedTextRegion_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _put_Name(HSTRING value);
	virtual STDMETHODIMP _get_Position(TimedTextPoint *value);
	virtual STDMETHODIMP _put_Position(TimedTextPoint value);
	virtual STDMETHODIMP _get_Extent(TimedTextSize *value);
	virtual STDMETHODIMP _put_Extent(TimedTextSize value);
	virtual STDMETHODIMP _get_Background(UI::Color *value);
	virtual STDMETHODIMP _put_Background(UI::Color value);
	virtual STDMETHODIMP _get_WritingMode(TimedTextWritingMode *value);
	virtual STDMETHODIMP _put_WritingMode(TimedTextWritingMode value);
	virtual STDMETHODIMP _get_DisplayAlignment(TimedTextDisplayAlignment *value);
	virtual STDMETHODIMP _put_DisplayAlignment(TimedTextDisplayAlignment value);
	virtual STDMETHODIMP _get_LineHeight(TimedTextDouble *value);
	virtual STDMETHODIMP _put_LineHeight(TimedTextDouble value);
	virtual STDMETHODIMP _get_IsOverflowClipped(bool *value);
	virtual STDMETHODIMP _put_IsOverflowClipped(bool value);
	virtual STDMETHODIMP _get_Padding(TimedTextPadding *value);
	virtual STDMETHODIMP _put_Padding(TimedTextPadding value);
	virtual STDMETHODIMP _get_TextWrapping(TimedTextWrapping *value);
	virtual STDMETHODIMP _put_TextWrapping(TimedTextWrapping value);
	virtual STDMETHODIMP _get_ZIndex(int *value);
	virtual STDMETHODIMP _put_ZIndex(int value);
	virtual STDMETHODIMP _get_ScrollMode(TimedTextScrollMode *value);
	virtual STDMETHODIMP _put_ScrollMode(TimedTextScrollMode value);
};
template<typename X> struct ITimedTextRegion_adaptor : X {
	union {
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&ITimedTextRegion_adaptor::Background)->_get_Background(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&ITimedTextRegion_adaptor::Background)->_put_Background(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} Background;
		struct : property {
			TimedTextDisplayAlignment get() { TimedTextDisplayAlignment value; hrcheck(enc(&ITimedTextRegion_adaptor::DisplayAlignment)->_get_DisplayAlignment(&value)); return value; }
			TimedTextDisplayAlignment operator()() { return get(); }
			operator TimedTextDisplayAlignment () { return get(); }
			void put(TimedTextDisplayAlignment value) { hrcheck(enc(&ITimedTextRegion_adaptor::DisplayAlignment)->_put_DisplayAlignment(value)); }
			void operator=(TimedTextDisplayAlignment value) { put(value); }
			void operator()(TimedTextDisplayAlignment value) { put(value); }
		} DisplayAlignment;
		struct : property {
			TimedTextSize get() { TimedTextSize value; hrcheck(enc(&ITimedTextRegion_adaptor::Extent)->_get_Extent(&value)); return value; }
			TimedTextSize operator()() { return get(); }
			operator TimedTextSize () { return get(); }
			void put(const TimedTextSize& value) { hrcheck(enc(&ITimedTextRegion_adaptor::Extent)->_put_Extent(value)); }
			void operator=(const TimedTextSize& value) { put(value); }
			void operator()(const TimedTextSize& value) { put(value); }
		} Extent;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITimedTextRegion_adaptor::IsOverflowClipped)->_get_IsOverflowClipped(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITimedTextRegion_adaptor::IsOverflowClipped)->_put_IsOverflowClipped(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsOverflowClipped;
		struct : property {
			TimedTextDouble get() { TimedTextDouble value; hrcheck(enc(&ITimedTextRegion_adaptor::LineHeight)->_get_LineHeight(&value)); return value; }
			TimedTextDouble operator()() { return get(); }
			operator TimedTextDouble () { return get(); }
			void put(const TimedTextDouble& value) { hrcheck(enc(&ITimedTextRegion_adaptor::LineHeight)->_put_LineHeight(value)); }
			void operator=(const TimedTextDouble& value) { put(value); }
			void operator()(const TimedTextDouble& value) { put(value); }
		} LineHeight;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITimedTextRegion_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITimedTextRegion_adaptor::Name)->_put_Name(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Name;
		struct : property {
			TimedTextPadding get() { TimedTextPadding value; hrcheck(enc(&ITimedTextRegion_adaptor::Padding)->_get_Padding(&value)); return value; }
			TimedTextPadding operator()() { return get(); }
			operator TimedTextPadding () { return get(); }
			void put(const TimedTextPadding& value) { hrcheck(enc(&ITimedTextRegion_adaptor::Padding)->_put_Padding(value)); }
			void operator=(const TimedTextPadding& value) { put(value); }
			void operator()(const TimedTextPadding& value) { put(value); }
		} Padding;
		struct : property {
			TimedTextPoint get() { TimedTextPoint value; hrcheck(enc(&ITimedTextRegion_adaptor::Position)->_get_Position(&value)); return value; }
			TimedTextPoint operator()() { return get(); }
			operator TimedTextPoint () { return get(); }
			void put(const TimedTextPoint& value) { hrcheck(enc(&ITimedTextRegion_adaptor::Position)->_put_Position(value)); }
			void operator=(const TimedTextPoint& value) { put(value); }
			void operator()(const TimedTextPoint& value) { put(value); }
		} Position;
		struct : property {
			TimedTextScrollMode get() { TimedTextScrollMode value; hrcheck(enc(&ITimedTextRegion_adaptor::ScrollMode)->_get_ScrollMode(&value)); return value; }
			TimedTextScrollMode operator()() { return get(); }
			operator TimedTextScrollMode () { return get(); }
			void put(TimedTextScrollMode value) { hrcheck(enc(&ITimedTextRegion_adaptor::ScrollMode)->_put_ScrollMode(value)); }
			void operator=(TimedTextScrollMode value) { put(value); }
			void operator()(TimedTextScrollMode value) { put(value); }
		} ScrollMode;
		struct : property {
			TimedTextWrapping get() { TimedTextWrapping value; hrcheck(enc(&ITimedTextRegion_adaptor::TextWrapping)->_get_TextWrapping(&value)); return value; }
			TimedTextWrapping operator()() { return get(); }
			operator TimedTextWrapping () { return get(); }
			void put(TimedTextWrapping value) { hrcheck(enc(&ITimedTextRegion_adaptor::TextWrapping)->_put_TextWrapping(value)); }
			void operator=(TimedTextWrapping value) { put(value); }
			void operator()(TimedTextWrapping value) { put(value); }
		} TextWrapping;
		struct : property {
			TimedTextWritingMode get() { TimedTextWritingMode value; hrcheck(enc(&ITimedTextRegion_adaptor::WritingMode)->_get_WritingMode(&value)); return value; }
			TimedTextWritingMode operator()() { return get(); }
			operator TimedTextWritingMode () { return get(); }
			void put(TimedTextWritingMode value) { hrcheck(enc(&ITimedTextRegion_adaptor::WritingMode)->_put_WritingMode(value)); }
			void operator=(TimedTextWritingMode value) { put(value); }
			void operator()(TimedTextWritingMode value) { put(value); }
		} WritingMode;
		struct : property {
			int get() { int value; hrcheck(enc(&ITimedTextRegion_adaptor::ZIndex)->_get_ZIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ITimedTextRegion_adaptor::ZIndex)->_put_ZIndex(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} ZIndex;
	};
	ITimedTextRegion_adaptor() {}
};
template<typename X> struct adapt<ITimedTextRegion, X> : Windows::Media::Core::ITimedTextRegion_adaptor<X> { typedef adapt ITimedTextRegion; };
struct ITimedTextRegion : ITimedTextRegion_raw, generate<ITimedTextRegion> {};

// TimedTextRegion
template<typename X> struct statics<TimedTextRegion, X> : X {
	typedef typename X::root_type TimedTextRegion;
};
struct TimedTextRegion : generate<TimedTextRegion> {};

// ITimedTextStyle2
struct ITimedTextStyle2_raw : IInspectable {
	virtual STDMETHODIMP _get_FontStyle(TimedTextFontStyle *value);
	virtual STDMETHODIMP _put_FontStyle(TimedTextFontStyle value);
	virtual STDMETHODIMP _get_IsUnderlineEnabled(bool *value);
	virtual STDMETHODIMP _put_IsUnderlineEnabled(bool value);
	virtual STDMETHODIMP _get_IsLineThroughEnabled(bool *value);
	virtual STDMETHODIMP _put_IsLineThroughEnabled(bool value);
	virtual STDMETHODIMP _get_IsOverlineEnabled(bool *value);
	virtual STDMETHODIMP _put_IsOverlineEnabled(bool value);
};
template<typename X> struct ITimedTextStyle2_adaptor : X {
	union {
		struct : property {
			TimedTextFontStyle get() { TimedTextFontStyle value; hrcheck(enc(&ITimedTextStyle2_adaptor::FontStyle)->_get_FontStyle(&value)); return value; }
			TimedTextFontStyle operator()() { return get(); }
			operator TimedTextFontStyle () { return get(); }
			void put(TimedTextFontStyle value) { hrcheck(enc(&ITimedTextStyle2_adaptor::FontStyle)->_put_FontStyle(value)); }
			void operator=(TimedTextFontStyle value) { put(value); }
			void operator()(TimedTextFontStyle value) { put(value); }
		} FontStyle;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITimedTextStyle2_adaptor::IsLineThroughEnabled)->_get_IsLineThroughEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITimedTextStyle2_adaptor::IsLineThroughEnabled)->_put_IsLineThroughEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsLineThroughEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITimedTextStyle2_adaptor::IsOverlineEnabled)->_get_IsOverlineEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITimedTextStyle2_adaptor::IsOverlineEnabled)->_put_IsOverlineEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsOverlineEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITimedTextStyle2_adaptor::IsUnderlineEnabled)->_get_IsUnderlineEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITimedTextStyle2_adaptor::IsUnderlineEnabled)->_put_IsUnderlineEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsUnderlineEnabled;
	};
	ITimedTextStyle2_adaptor() {}
};
template<typename X> struct adapt<ITimedTextStyle2, X> : Windows::Media::Core::ITimedTextStyle2_adaptor<X> { typedef adapt ITimedTextStyle2; };
struct ITimedTextStyle2 : ITimedTextStyle2_raw, generate<ITimedTextStyle2> {};

// ITimedTextStyle
struct ITimedTextStyle_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _put_Name(HSTRING value);
	virtual STDMETHODIMP _get_FontFamily(HSTRING *value);
	virtual STDMETHODIMP _put_FontFamily(HSTRING value);
	virtual STDMETHODIMP _get_FontSize(TimedTextDouble *value);
	virtual STDMETHODIMP _put_FontSize(TimedTextDouble value);
	virtual STDMETHODIMP _get_FontWeight(TimedTextWeight *value);
	virtual STDMETHODIMP _put_FontWeight(TimedTextWeight value);
	virtual STDMETHODIMP _get_Foreground(UI::Color *value);
	virtual STDMETHODIMP _put_Foreground(UI::Color value);
	virtual STDMETHODIMP _get_Background(UI::Color *value);
	virtual STDMETHODIMP _put_Background(UI::Color value);
	virtual STDMETHODIMP _get_IsBackgroundAlwaysShown(bool *value);
	virtual STDMETHODIMP _put_IsBackgroundAlwaysShown(bool value);
	virtual STDMETHODIMP _get_FlowDirection(TimedTextFlowDirection *value);
	virtual STDMETHODIMP _put_FlowDirection(TimedTextFlowDirection value);
	virtual STDMETHODIMP _get_LineAlignment(TimedTextLineAlignment *value);
	virtual STDMETHODIMP _put_LineAlignment(TimedTextLineAlignment value);
	virtual STDMETHODIMP _get_OutlineColor(UI::Color *value);
	virtual STDMETHODIMP _put_OutlineColor(UI::Color value);
	virtual STDMETHODIMP _get_OutlineThickness(TimedTextDouble *value);
	virtual STDMETHODIMP _put_OutlineThickness(TimedTextDouble value);
	virtual STDMETHODIMP _get_OutlineRadius(TimedTextDouble *value);
	virtual STDMETHODIMP _put_OutlineRadius(TimedTextDouble value);
};
template<typename X> struct ITimedTextStyle_adaptor : X {
	union {
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&ITimedTextStyle_adaptor::Background)->_get_Background(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&ITimedTextStyle_adaptor::Background)->_put_Background(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} Background;
		struct : property {
			TimedTextFlowDirection get() { TimedTextFlowDirection value; hrcheck(enc(&ITimedTextStyle_adaptor::FlowDirection)->_get_FlowDirection(&value)); return value; }
			TimedTextFlowDirection operator()() { return get(); }
			operator TimedTextFlowDirection () { return get(); }
			void put(TimedTextFlowDirection value) { hrcheck(enc(&ITimedTextStyle_adaptor::FlowDirection)->_put_FlowDirection(value)); }
			void operator=(TimedTextFlowDirection value) { put(value); }
			void operator()(TimedTextFlowDirection value) { put(value); }
		} FlowDirection;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITimedTextStyle_adaptor::FontFamily)->_get_FontFamily(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITimedTextStyle_adaptor::FontFamily)->_put_FontFamily(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} FontFamily;
		struct : property {
			TimedTextDouble get() { TimedTextDouble value; hrcheck(enc(&ITimedTextStyle_adaptor::FontSize)->_get_FontSize(&value)); return value; }
			TimedTextDouble operator()() { return get(); }
			operator TimedTextDouble () { return get(); }
			void put(const TimedTextDouble& value) { hrcheck(enc(&ITimedTextStyle_adaptor::FontSize)->_put_FontSize(value)); }
			void operator=(const TimedTextDouble& value) { put(value); }
			void operator()(const TimedTextDouble& value) { put(value); }
		} FontSize;
		struct : property {
			TimedTextWeight get() { TimedTextWeight value; hrcheck(enc(&ITimedTextStyle_adaptor::FontWeight)->_get_FontWeight(&value)); return value; }
			TimedTextWeight operator()() { return get(); }
			operator TimedTextWeight () { return get(); }
			void put(TimedTextWeight value) { hrcheck(enc(&ITimedTextStyle_adaptor::FontWeight)->_put_FontWeight(value)); }
			void operator=(TimedTextWeight value) { put(value); }
			void operator()(TimedTextWeight value) { put(value); }
		} FontWeight;
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&ITimedTextStyle_adaptor::Foreground)->_get_Foreground(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&ITimedTextStyle_adaptor::Foreground)->_put_Foreground(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} Foreground;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITimedTextStyle_adaptor::IsBackgroundAlwaysShown)->_get_IsBackgroundAlwaysShown(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITimedTextStyle_adaptor::IsBackgroundAlwaysShown)->_put_IsBackgroundAlwaysShown(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsBackgroundAlwaysShown;
		struct : property {
			TimedTextLineAlignment get() { TimedTextLineAlignment value; hrcheck(enc(&ITimedTextStyle_adaptor::LineAlignment)->_get_LineAlignment(&value)); return value; }
			TimedTextLineAlignment operator()() { return get(); }
			operator TimedTextLineAlignment () { return get(); }
			void put(TimedTextLineAlignment value) { hrcheck(enc(&ITimedTextStyle_adaptor::LineAlignment)->_put_LineAlignment(value)); }
			void operator=(TimedTextLineAlignment value) { put(value); }
			void operator()(TimedTextLineAlignment value) { put(value); }
		} LineAlignment;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITimedTextStyle_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITimedTextStyle_adaptor::Name)->_put_Name(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Name;
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&ITimedTextStyle_adaptor::OutlineColor)->_get_OutlineColor(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&ITimedTextStyle_adaptor::OutlineColor)->_put_OutlineColor(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} OutlineColor;
		struct : property {
			TimedTextDouble get() { TimedTextDouble value; hrcheck(enc(&ITimedTextStyle_adaptor::OutlineRadius)->_get_OutlineRadius(&value)); return value; }
			TimedTextDouble operator()() { return get(); }
			operator TimedTextDouble () { return get(); }
			void put(const TimedTextDouble& value) { hrcheck(enc(&ITimedTextStyle_adaptor::OutlineRadius)->_put_OutlineRadius(value)); }
			void operator=(const TimedTextDouble& value) { put(value); }
			void operator()(const TimedTextDouble& value) { put(value); }
		} OutlineRadius;
		struct : property {
			TimedTextDouble get() { TimedTextDouble value; hrcheck(enc(&ITimedTextStyle_adaptor::OutlineThickness)->_get_OutlineThickness(&value)); return value; }
			TimedTextDouble operator()() { return get(); }
			operator TimedTextDouble () { return get(); }
			void put(const TimedTextDouble& value) { hrcheck(enc(&ITimedTextStyle_adaptor::OutlineThickness)->_put_OutlineThickness(value)); }
			void operator=(const TimedTextDouble& value) { put(value); }
			void operator()(const TimedTextDouble& value) { put(value); }
		} OutlineThickness;
	};
	ITimedTextStyle_adaptor() {}
};
template<typename X> struct adapt<ITimedTextStyle, X> : Windows::Media::Core::ITimedTextStyle_adaptor<X> { typedef adapt ITimedTextStyle; };
struct ITimedTextStyle : ITimedTextStyle_raw, generate<ITimedTextStyle> {};

// TimedTextStyle
template<typename X> struct statics<TimedTextStyle, X> : X {
	typedef typename X::root_type TimedTextStyle;
};
struct TimedTextStyle : generate<TimedTextStyle> {};

// ITimedTextLine
struct ITimedTextLine_raw : IInspectable {
	virtual STDMETHODIMP _get_Text(HSTRING *value);
	virtual STDMETHODIMP _put_Text(HSTRING value);
	virtual STDMETHODIMP _get_Subformats(Foundation::Collections::IVector<TimedTextSubformat*>* *value);
};
template<typename X> struct ITimedTextLine_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<TimedTextSubformat>>> get() { Foundation::Collections::IVector<TimedTextSubformat*>* value; hrcheck(enc(&ITimedTextLine_adaptor::Subformats)->_get_Subformats(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<TimedTextSubformat>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<TimedTextSubformat>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<TimedTextSubformat>>> operator->() { return get(); }
		} Subformats;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITimedTextLine_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITimedTextLine_adaptor::Text)->_put_Text(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Text;
	};
	ITimedTextLine_adaptor() {}
};
template<typename X> struct adapt<ITimedTextLine, X> : Windows::Media::Core::ITimedTextLine_adaptor<X> { typedef adapt ITimedTextLine; };
struct ITimedTextLine : ITimedTextLine_raw, generate<ITimedTextLine> {};

// TimedTextLine
template<typename X> struct statics<TimedTextLine, X> : X {
	typedef typename X::root_type TimedTextLine;
};
struct TimedTextLine : generate<TimedTextLine> {};

// ITimedTextSubformat
struct ITimedTextSubformat_raw : IInspectable {
	virtual STDMETHODIMP _get_StartIndex(int *value);
	virtual STDMETHODIMP _put_StartIndex(int value);
	virtual STDMETHODIMP _get_Length(int *value);
	virtual STDMETHODIMP _put_Length(int value);
	virtual STDMETHODIMP _get_SubformatStyle(TimedTextStyle* *value);
	virtual STDMETHODIMP _put_SubformatStyle(TimedTextStyle* value);
};
template<typename X> struct ITimedTextSubformat_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&ITimedTextSubformat_adaptor::Length)->_get_Length(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ITimedTextSubformat_adaptor::Length)->_put_Length(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} Length;
		struct : property {
			int get() { int value; hrcheck(enc(&ITimedTextSubformat_adaptor::StartIndex)->_get_StartIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ITimedTextSubformat_adaptor::StartIndex)->_put_StartIndex(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} StartIndex;
		struct : property {
			ptr<TimedTextStyle> get() { TimedTextStyle* value; hrcheck(enc(&ITimedTextSubformat_adaptor::SubformatStyle)->_get_SubformatStyle(&value)); return from_abi(value); }
			ptr<TimedTextStyle> operator()() { return get(); }
			operator ptr<TimedTextStyle> () { return get(); }
			ptr<TimedTextStyle> operator->() { return get(); }
			void put(pptr<TimedTextStyle> value) { hrcheck(enc(&ITimedTextSubformat_adaptor::SubformatStyle)->_put_SubformatStyle(value)); }
			void operator=(pptr<TimedTextStyle> value) { put(value); }
			void operator()(pptr<TimedTextStyle> value) { put(value); }
		} SubformatStyle;
	};
	ITimedTextSubformat_adaptor() {}
};
template<typename X> struct adapt<ITimedTextSubformat, X> : Windows::Media::Core::ITimedTextSubformat_adaptor<X> { typedef adapt ITimedTextSubformat; };
struct ITimedTextSubformat : ITimedTextSubformat_raw, generate<ITimedTextSubformat> {};

// TimedTextSubformat
template<typename X> struct statics<TimedTextSubformat, X> : X {
	typedef typename X::root_type TimedTextSubformat;
};
struct TimedTextSubformat : generate<TimedTextSubformat> {};

// TimedTextCue
template<typename X> struct statics<TimedTextCue, X> : X {
	typedef typename X::root_type TimedTextCue;
};
struct TimedTextCue : generate<TimedTextCue> {};

// DataCue
template<typename X> struct statics<DataCue, X> : X {
	typedef typename X::root_type DataCue;
};
struct DataCue : generate<DataCue> {};

// ChapterCue
template<typename X> struct statics<ChapterCue, X> : X {
	typedef typename X::root_type ChapterCue;
};
struct ChapterCue : generate<ChapterCue> {};

// ImageCue
template<typename X> struct statics<ImageCue, X> : X {
	typedef typename X::root_type ImageCue;
};
struct ImageCue : generate<ImageCue> {};

// SpeechCue
template<typename X> struct statics<SpeechCue, X> : X {
	typedef typename X::root_type SpeechCue;
};
struct SpeechCue : generate<SpeechCue> {};

// ICodecInfo
struct ICodecInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_Kind(CodecKind *value);
	virtual STDMETHODIMP _get_Category(CodecCategory *value);
	virtual STDMETHODIMP _get_Subtypes(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _get_DisplayName(HSTRING *value);
	virtual STDMETHODIMP _get_IsTrusted(bool *value);
};
template<typename X> struct ICodecInfo_adaptor : X {
	union {
		struct : property {
			CodecCategory get() { CodecCategory value; hrcheck(enc(&ICodecInfo_adaptor::Category)->_get_Category(&value)); return value; }
			CodecCategory operator()() { return get(); }
			operator CodecCategory () { return get(); }
		} Category;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICodecInfo_adaptor::DisplayName)->_get_DisplayName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DisplayName;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICodecInfo_adaptor::IsTrusted)->_get_IsTrusted(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsTrusted;
		struct : property {
			CodecKind get() { CodecKind value; hrcheck(enc(&ICodecInfo_adaptor::Kind)->_get_Kind(&value)); return value; }
			CodecKind operator()() { return get(); }
			operator CodecKind () { return get(); }
		} Kind;
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&ICodecInfo_adaptor::Subtypes)->_get_Subtypes(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} Subtypes;
	};
	ICodecInfo_adaptor() {}
};
template<typename X> struct adapt<ICodecInfo, X> : Windows::Media::Core::ICodecInfo_adaptor<X> { typedef adapt ICodecInfo; };
struct ICodecInfo : ICodecInfo_raw, generate<ICodecInfo> {};

// CodecInfo
template<typename X> struct statics<CodecInfo, X> : X {
	typedef typename X::root_type CodecInfo;
};
struct CodecInfo : generate<CodecInfo> {};

// ICodecQuery
struct ICodecQuery_raw : IInspectable {
	virtual STDMETHODIMP _FindAllAsync(CodecKind kind, CodecCategory category, HSTRING subType, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<CodecInfo*>*>* *value);
};
template<typename X> struct ICodecQuery_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<CodecInfo>>>>> FindAllAsync(CodecKind kind, CodecCategory category, hstring_ref subType) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<CodecInfo*>*>* value; hrcheck(X::get()->_FindAllAsync(kind, category, subType, &value)); return from_abi(value); }
};
template<typename X> struct adapt<ICodecQuery, X> : Windows::Media::Core::ICodecQuery_adaptor<X> { typedef adapt ICodecQuery; };
struct ICodecQuery : ICodecQuery_raw, generate<ICodecQuery> {};

// CodecQuery
template<typename X> struct statics<CodecQuery, X> : X {
	typedef typename X::root_type CodecQuery;
};
struct CodecQuery : generate<CodecQuery> {};

// ICodecSubtypesStatics
struct ICodecSubtypesStatics : IInspectable {
	virtual STDMETHODIMP _get_VideoFormatDV25(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatDV50(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatDvc(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatDvh1(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatDvhD(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatDvsd(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatDvsl(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatH263(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatH264(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatH265(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatH264ES(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatHevc(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatHevcES(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatM4S2(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatMjpg(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatMP43(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatMP4S(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatMP4V(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatMpeg2(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatVP80(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatVP90(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatMpg1(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatMss1(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatMss2(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatWmv1(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatWmv2(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatWmv3(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormatWvc1(HSTRING *value);
	virtual STDMETHODIMP _get_VideoFormat420O(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatAac(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatAdts(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatAlac(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatAmrNB(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatAmrWB(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatAmrWP(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatDolbyAC3(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatDolbyAC3Spdif(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatDolbyDDPlus(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatDrm(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatDts(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatFlac(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatFloat(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatMP3(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatMPeg(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatMsp1(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatOpus(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatPcm(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatWmaSpdif(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatWMAudioLossless(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatWMAudioV8(HSTRING *value);
	virtual STDMETHODIMP _get_AudioFormatWMAudioV9(HSTRING *value);
};

// CodecSubtypes
template<typename> struct CodecSubtypes_statics {
	static struct _AudioFormatAac : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatAac(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatAac;
	static struct _AudioFormatAdts : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatAdts(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatAdts;
	static struct _AudioFormatAlac : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatAlac(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatAlac;
	static struct _AudioFormatAmrNB : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatAmrNB(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatAmrNB;
	static struct _AudioFormatAmrWB : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatAmrWB(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatAmrWB;
	static struct _AudioFormatAmrWP : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatAmrWP(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatAmrWP;
	static struct _AudioFormatDolbyAC3 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatDolbyAC3(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatDolbyAC3;
	static struct _AudioFormatDolbyAC3Spdif : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatDolbyAC3Spdif(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatDolbyAC3Spdif;
	static struct _AudioFormatDolbyDDPlus : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatDolbyDDPlus(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatDolbyDDPlus;
	static struct _AudioFormatDrm : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatDrm(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatDrm;
	static struct _AudioFormatDts : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatDts(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatDts;
	static struct _AudioFormatFlac : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatFlac(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatFlac;
	static struct _AudioFormatFloat : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatFloat(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatFloat;
	static struct _AudioFormatMP3 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatMP3(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatMP3;
	static struct _AudioFormatMPeg : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatMPeg(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatMPeg;
	static struct _AudioFormatMsp1 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatMsp1(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatMsp1;
	static struct _AudioFormatOpus : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatOpus(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatOpus;
	static struct _AudioFormatPcm : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatPcm(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatPcm;
	static struct _AudioFormatWMAudioLossless : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatWMAudioLossless(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatWMAudioLossless;
	static struct _AudioFormatWMAudioV8 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatWMAudioV8(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatWMAudioV8;
	static struct _AudioFormatWMAudioV9 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatWMAudioV9(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatWMAudioV9;
	static struct _AudioFormatWmaSpdif : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_AudioFormatWmaSpdif(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} AudioFormatWmaSpdif;
	static struct _VideoFormat420O : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormat420O(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormat420O;
	static struct _VideoFormatDV25 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatDV25(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatDV25;
	static struct _VideoFormatDV50 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatDV50(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatDV50;
	static struct _VideoFormatDvc : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatDvc(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatDvc;
	static struct _VideoFormatDvh1 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatDvh1(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatDvh1;
	static struct _VideoFormatDvhD : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatDvhD(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatDvhD;
	static struct _VideoFormatDvsd : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatDvsd(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatDvsd;
	static struct _VideoFormatDvsl : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatDvsl(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatDvsl;
	static struct _VideoFormatH263 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatH263(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatH263;
	static struct _VideoFormatH264 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatH264(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatH264;
	static struct _VideoFormatH264ES : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatH264ES(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatH264ES;
	static struct _VideoFormatH265 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatH265(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatH265;
	static struct _VideoFormatHevc : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatHevc(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatHevc;
	static struct _VideoFormatHevcES : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatHevcES(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatHevcES;
	static struct _VideoFormatM4S2 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatM4S2(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatM4S2;
	static struct _VideoFormatMP43 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatMP43(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatMP43;
	static struct _VideoFormatMP4S : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatMP4S(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatMP4S;
	static struct _VideoFormatMP4V : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatMP4V(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatMP4V;
	static struct _VideoFormatMjpg : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatMjpg(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatMjpg;
	static struct _VideoFormatMpeg2 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatMpeg2(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatMpeg2;
	static struct _VideoFormatMpg1 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatMpg1(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatMpg1;
	static struct _VideoFormatMss1 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatMss1(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatMss1;
	static struct _VideoFormatMss2 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatMss2(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatMss2;
	static struct _VideoFormatVP80 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatVP80(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatVP80;
	static struct _VideoFormatVP90 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatVP90(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatVP90;
	static struct _VideoFormatWmv1 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatWmv1(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatWmv1;
	static struct _VideoFormatWmv2 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatWmv2(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatWmv2;
	static struct _VideoFormatWmv3 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatWmv3(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatWmv3;
	static struct _VideoFormatWvc1 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<CodecSubtypes, ICodecSubtypesStatics>()->_get_VideoFormatWvc1(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} VideoFormatWvc1;
};
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatAac CodecSubtypes_statics<X>::AudioFormatAac;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatAdts CodecSubtypes_statics<X>::AudioFormatAdts;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatAlac CodecSubtypes_statics<X>::AudioFormatAlac;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatAmrNB CodecSubtypes_statics<X>::AudioFormatAmrNB;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatAmrWB CodecSubtypes_statics<X>::AudioFormatAmrWB;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatAmrWP CodecSubtypes_statics<X>::AudioFormatAmrWP;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatDolbyAC3 CodecSubtypes_statics<X>::AudioFormatDolbyAC3;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatDolbyAC3Spdif CodecSubtypes_statics<X>::AudioFormatDolbyAC3Spdif;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatDolbyDDPlus CodecSubtypes_statics<X>::AudioFormatDolbyDDPlus;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatDrm CodecSubtypes_statics<X>::AudioFormatDrm;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatDts CodecSubtypes_statics<X>::AudioFormatDts;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatFlac CodecSubtypes_statics<X>::AudioFormatFlac;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatFloat CodecSubtypes_statics<X>::AudioFormatFloat;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatMP3 CodecSubtypes_statics<X>::AudioFormatMP3;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatMPeg CodecSubtypes_statics<X>::AudioFormatMPeg;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatMsp1 CodecSubtypes_statics<X>::AudioFormatMsp1;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatOpus CodecSubtypes_statics<X>::AudioFormatOpus;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatPcm CodecSubtypes_statics<X>::AudioFormatPcm;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatWMAudioLossless CodecSubtypes_statics<X>::AudioFormatWMAudioLossless;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatWMAudioV8 CodecSubtypes_statics<X>::AudioFormatWMAudioV8;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatWMAudioV9 CodecSubtypes_statics<X>::AudioFormatWMAudioV9;
template<typename X> typename CodecSubtypes_statics<X>::_AudioFormatWmaSpdif CodecSubtypes_statics<X>::AudioFormatWmaSpdif;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormat420O CodecSubtypes_statics<X>::VideoFormat420O;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatDV25 CodecSubtypes_statics<X>::VideoFormatDV25;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatDV50 CodecSubtypes_statics<X>::VideoFormatDV50;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatDvc CodecSubtypes_statics<X>::VideoFormatDvc;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatDvh1 CodecSubtypes_statics<X>::VideoFormatDvh1;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatDvhD CodecSubtypes_statics<X>::VideoFormatDvhD;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatDvsd CodecSubtypes_statics<X>::VideoFormatDvsd;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatDvsl CodecSubtypes_statics<X>::VideoFormatDvsl;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatH263 CodecSubtypes_statics<X>::VideoFormatH263;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatH264 CodecSubtypes_statics<X>::VideoFormatH264;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatH264ES CodecSubtypes_statics<X>::VideoFormatH264ES;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatH265 CodecSubtypes_statics<X>::VideoFormatH265;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatHevc CodecSubtypes_statics<X>::VideoFormatHevc;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatHevcES CodecSubtypes_statics<X>::VideoFormatHevcES;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatM4S2 CodecSubtypes_statics<X>::VideoFormatM4S2;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatMP43 CodecSubtypes_statics<X>::VideoFormatMP43;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatMP4S CodecSubtypes_statics<X>::VideoFormatMP4S;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatMP4V CodecSubtypes_statics<X>::VideoFormatMP4V;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatMjpg CodecSubtypes_statics<X>::VideoFormatMjpg;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatMpeg2 CodecSubtypes_statics<X>::VideoFormatMpeg2;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatMpg1 CodecSubtypes_statics<X>::VideoFormatMpg1;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatMss1 CodecSubtypes_statics<X>::VideoFormatMss1;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatMss2 CodecSubtypes_statics<X>::VideoFormatMss2;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatVP80 CodecSubtypes_statics<X>::VideoFormatVP80;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatVP90 CodecSubtypes_statics<X>::VideoFormatVP90;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatWmv1 CodecSubtypes_statics<X>::VideoFormatWmv1;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatWmv2 CodecSubtypes_statics<X>::VideoFormatWmv2;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatWmv3 CodecSubtypes_statics<X>::VideoFormatWmv3;
template<typename X> typename CodecSubtypes_statics<X>::_VideoFormatWvc1 CodecSubtypes_statics<X>::VideoFormatWvc1;

template<typename X> struct statics<CodecSubtypes, X> : X, Windows::Media::Core::CodecSubtypes_statics<void> {
	typedef typename X::root_type CodecSubtypes;
};
struct CodecSubtypes : generate<CodecSubtypes> {};

// ILowLightFusionStatics
struct ILowLightFusionStatics : IInspectable {
	virtual STDMETHODIMP _get_SupportedBitmapPixelFormats(Foundation::Collections::IVectorView<Graphics::Imaging::BitmapPixelFormat>* *value);
	virtual STDMETHODIMP _get_MaxSupportedFrameCount(int *value);
	virtual STDMETHODIMP _FuseAsync(Foundation::Collections::IIterable<Graphics::Imaging::SoftwareBitmap*>* frameSet, Foundation::IAsyncOperationWithProgress<LowLightFusionResult*, double>* *result);
};

// ILowLightFusionResult
struct ILowLightFusionResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Frame(Graphics::Imaging::SoftwareBitmap* *value);
};
template<typename X> struct ILowLightFusionResult_adaptor : X {
	union {
		struct : property {
			ptr<Graphics::Imaging::SoftwareBitmap> get() { Graphics::Imaging::SoftwareBitmap* value; hrcheck(enc(&ILowLightFusionResult_adaptor::Frame)->_get_Frame(&value)); return from_abi(value); }
			ptr<Graphics::Imaging::SoftwareBitmap> operator()() { return get(); }
			operator ptr<Graphics::Imaging::SoftwareBitmap> () { return get(); }
			ptr<Graphics::Imaging::SoftwareBitmap> operator->() { return get(); }
		} Frame;
	};
	ILowLightFusionResult_adaptor() {}
};
template<typename X> struct adapt<ILowLightFusionResult, X> : Windows::Media::Core::ILowLightFusionResult_adaptor<X> { typedef adapt ILowLightFusionResult; };
struct ILowLightFusionResult : ILowLightFusionResult_raw, generate<ILowLightFusionResult> {};

// LowLightFusionResult
template<typename X> struct statics<LowLightFusionResult, X> : X {
	typedef typename X::root_type LowLightFusionResult;
};
struct LowLightFusionResult : generate<LowLightFusionResult> {};

// LowLightFusion
template<typename> struct LowLightFusion_statics {
	static struct _MaxSupportedFrameCount : property {
		int get() { int value; hrcheck(get_activation_factory<LowLightFusion, ILowLightFusionStatics>()->_get_MaxSupportedFrameCount(&value)); return value; }
		int operator()() { return get(); }
		operator int () { return get(); }
	} MaxSupportedFrameCount;
	static struct _SupportedBitmapPixelFormats : property {
		ptr<Foundation::Collections::IVectorView<Graphics::Imaging::BitmapPixelFormat>> get() { Foundation::Collections::IVectorView<Graphics::Imaging::BitmapPixelFormat>* value; hrcheck(get_activation_factory<LowLightFusion, ILowLightFusionStatics>()->_get_SupportedBitmapPixelFormats(&value)); return from_abi(value); }
		ptr<Foundation::Collections::IVectorView<Graphics::Imaging::BitmapPixelFormat>> operator()() { return get(); }
		operator ptr<Foundation::Collections::IVectorView<Graphics::Imaging::BitmapPixelFormat>> () { return get(); }
		ptr<Foundation::Collections::IVectorView<Graphics::Imaging::BitmapPixelFormat>> operator->() { return get(); }
	} SupportedBitmapPixelFormats;
	static ptr<Foundation::IAsyncOperationWithProgress<ptr<LowLightFusionResult>, double>> FuseAsync(pptr<Foundation::Collections::IIterable<ptr<Graphics::Imaging::SoftwareBitmap>>> frameSet) { Foundation::IAsyncOperationWithProgress<LowLightFusionResult*, double>* result; hrcheck(get_activation_factory<LowLightFusion, ILowLightFusionStatics>()->_FuseAsync(to_abi(frameSet), &result)); return from_abi(result); }
};
template<typename X> typename LowLightFusion_statics<X>::_MaxSupportedFrameCount LowLightFusion_statics<X>::MaxSupportedFrameCount;
template<typename X> typename LowLightFusion_statics<X>::_SupportedBitmapPixelFormats LowLightFusion_statics<X>::SupportedBitmapPixelFormats;

template<typename X> struct statics<LowLightFusion, X> : X, Windows::Media::Core::LowLightFusion_statics<void> {
	typedef typename X::root_type LowLightFusion;
};
struct LowLightFusion : generate<LowLightFusion> {};

// IAudioStreamDescriptorFactory
struct IAudioStreamDescriptorFactory : IInspectable {
	virtual STDMETHODIMP _Create(MediaProperties::AudioEncodingProperties* encodingProperties, AudioStreamDescriptor* *result);
};

// IAudioStreamDescriptor3
struct IAudioStreamDescriptor3_raw : IInspectable {
	virtual STDMETHODIMP _Copy(AudioStreamDescriptor* *result);
};
template<typename X> struct IAudioStreamDescriptor3_adaptor : X {
	ptr<AudioStreamDescriptor> Copy() { AudioStreamDescriptor* result; hrcheck(X::get()->_Copy(&result)); return from_abi(result); }
};
template<typename X> struct adapt<IAudioStreamDescriptor3, X> : Windows::Media::Core::IAudioStreamDescriptor3_adaptor<X> { typedef adapt IAudioStreamDescriptor3; };
struct IAudioStreamDescriptor3 : IAudioStreamDescriptor3_raw, generate<IAudioStreamDescriptor3> {};

// IMediaStreamDescriptor
struct IMediaStreamDescriptor_raw : IInspectable {
	virtual STDMETHODIMP _get_IsSelected(bool *selected) = 0;
	virtual STDMETHODIMP _put_Name(HSTRING value) = 0;
	virtual STDMETHODIMP _get_Name(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_Language(HSTRING value) = 0;
	virtual STDMETHODIMP _get_Language(HSTRING *value) = 0;
};
template<typename X> struct IMediaStreamDescriptor_adaptor : X {
	union {
		struct : property {
			bool get() { bool selected; hrcheck(enc(&IMediaStreamDescriptor_adaptor::IsSelected)->_get_IsSelected(&selected)); return selected; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsSelected;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMediaStreamDescriptor_adaptor::Language)->_get_Language(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IMediaStreamDescriptor_adaptor::Language)->_put_Language(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Language;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMediaStreamDescriptor_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IMediaStreamDescriptor_adaptor::Name)->_put_Name(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Name;
	};
	IMediaStreamDescriptor_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamDescriptor, X> : Windows::Media::Core::IMediaStreamDescriptor_adaptor<X> { typedef adapt IMediaStreamDescriptor; };
template<typename X> struct IMediaStreamDescriptor_unadaptor : X {
	STDMETHODIMP _get_IsSelected(bool *selected) { return hrtry([&, this] { get_prop(selected, IsSelected); }); }
	STDMETHODIMP _put_Name(HSTRING value) { return hrtry([&, this] { put_prop(value, Name); }); }
	STDMETHODIMP _get_Name(HSTRING *value) { return hrtry([&, this] { get_prop(value, Name); }); }
	STDMETHODIMP _put_Language(HSTRING value) { return hrtry([&, this] { put_prop(value, Language); }); }
	STDMETHODIMP _get_Language(HSTRING *value) { return hrtry([&, this] { get_prop(value, Language); }); }
};
template<typename X> struct unadapt<IMediaStreamDescriptor, X> : Windows::Media::Core::IMediaStreamDescriptor_unadaptor<X> {};
struct IMediaStreamDescriptor : IMediaStreamDescriptor_raw, generate<IMediaStreamDescriptor> {};

// IMediaStreamDescriptor2
struct IMediaStreamDescriptor2_raw : IInspectable {
	virtual STDMETHODIMP _put_Label(HSTRING value) = 0;
	virtual STDMETHODIMP _get_Label(HSTRING *value) = 0;
};
template<typename X> struct IMediaStreamDescriptor2_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMediaStreamDescriptor2_adaptor::Label)->_get_Label(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IMediaStreamDescriptor2_adaptor::Label)->_put_Label(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Label;
	};
	IMediaStreamDescriptor2_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamDescriptor2, X> : Windows::Media::Core::IMediaStreamDescriptor2_adaptor<X> { typedef adapt IMediaStreamDescriptor2; };
template<typename X> struct IMediaStreamDescriptor2_unadaptor : X {
	STDMETHODIMP _put_Label(HSTRING value) { return hrtry([&, this] { put_prop(value, Label); }); }
	STDMETHODIMP _get_Label(HSTRING *value) { return hrtry([&, this] { get_prop(value, Label); }); }
};
template<typename X> struct unadapt<IMediaStreamDescriptor2, X> : Windows::Media::Core::IMediaStreamDescriptor2_unadaptor<X> {};
struct IMediaStreamDescriptor2 : IMediaStreamDescriptor2_raw, generate<IMediaStreamDescriptor2> {};

// IAudioStreamDescriptor2
struct IAudioStreamDescriptor2_raw : IInspectable {
	virtual STDMETHODIMP _put_LeadingEncoderPadding(Foundation::IReference<unsigned>* value);
	virtual STDMETHODIMP _get_LeadingEncoderPadding(Foundation::IReference<unsigned>* *value);
	virtual STDMETHODIMP _put_TrailingEncoderPadding(Foundation::IReference<unsigned>* value);
	virtual STDMETHODIMP _get_TrailingEncoderPadding(Foundation::IReference<unsigned>* *value);
};
template<typename X> struct IAudioStreamDescriptor2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<unsigned>> get() { Foundation::IReference<unsigned>* value; hrcheck(enc(&IAudioStreamDescriptor2_adaptor::LeadingEncoderPadding)->_get_LeadingEncoderPadding(&value)); return from_abi(value); }
			ptr<Foundation::IReference<unsigned>> operator()() { return get(); }
			operator ptr<Foundation::IReference<unsigned>> () { return get(); }
			ptr<Foundation::IReference<unsigned>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<unsigned>> value) { hrcheck(enc(&IAudioStreamDescriptor2_adaptor::LeadingEncoderPadding)->_put_LeadingEncoderPadding(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<unsigned>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<unsigned>> value) { put(to_abi(value)); }
		} LeadingEncoderPadding;
		struct : property {
			ptr<Foundation::IReference<unsigned>> get() { Foundation::IReference<unsigned>* value; hrcheck(enc(&IAudioStreamDescriptor2_adaptor::TrailingEncoderPadding)->_get_TrailingEncoderPadding(&value)); return from_abi(value); }
			ptr<Foundation::IReference<unsigned>> operator()() { return get(); }
			operator ptr<Foundation::IReference<unsigned>> () { return get(); }
			ptr<Foundation::IReference<unsigned>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<unsigned>> value) { hrcheck(enc(&IAudioStreamDescriptor2_adaptor::TrailingEncoderPadding)->_put_TrailingEncoderPadding(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<unsigned>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<unsigned>> value) { put(to_abi(value)); }
		} TrailingEncoderPadding;
	};
	IAudioStreamDescriptor2_adaptor() {}
};
template<typename X> struct adapt<IAudioStreamDescriptor2, X> : Windows::Media::Core::IAudioStreamDescriptor2_adaptor<X> { typedef adapt IAudioStreamDescriptor2; };
struct IAudioStreamDescriptor2 : IAudioStreamDescriptor2_raw, generate<IAudioStreamDescriptor2> {};

// IAudioStreamDescriptor
struct IAudioStreamDescriptor_raw : IInspectable {
	virtual STDMETHODIMP _get_EncodingProperties(MediaProperties::AudioEncodingProperties* *encodingProperties);
};
template<typename X> struct IAudioStreamDescriptor_adaptor : X {
	union {
		struct : property {
			ptr<MediaProperties::AudioEncodingProperties> get() { MediaProperties::AudioEncodingProperties* encodingProperties; hrcheck(enc(&IAudioStreamDescriptor_adaptor::EncodingProperties)->_get_EncodingProperties(&encodingProperties)); return from_abi(encodingProperties); }
			ptr<MediaProperties::AudioEncodingProperties> operator()() { return get(); }
			operator ptr<MediaProperties::AudioEncodingProperties> () { return get(); }
			ptr<MediaProperties::AudioEncodingProperties> operator->() { return get(); }
		} EncodingProperties;
	};
	IAudioStreamDescriptor_adaptor() {}
};
template<typename X> struct adapt<IAudioStreamDescriptor, X> : Windows::Media::Core::IAudioStreamDescriptor_adaptor<X> { typedef adapt IAudioStreamDescriptor; };
struct IAudioStreamDescriptor : IAudioStreamDescriptor_raw, generate<IAudioStreamDescriptor> {};

// AudioStreamDescriptor
template<typename> struct AudioStreamDescriptor_statics {
	static AudioStreamDescriptor *activate(pptr<MediaProperties::AudioEncodingProperties> encodingProperties) { AudioStreamDescriptor *result; hrcheck(get_activation_factory<AudioStreamDescriptor, IAudioStreamDescriptorFactory>()->_Create(encodingProperties, &result)); return result; }
};

template<typename X> struct statics<AudioStreamDescriptor, X> : X, Windows::Media::Core::AudioStreamDescriptor_statics<void> {
	using Windows::Media::Core::AudioStreamDescriptor_statics<void>::activate;
	typedef typename X::root_type AudioStreamDescriptor;
};
struct AudioStreamDescriptor : generate<AudioStreamDescriptor> {};

// IVideoStreamDescriptorFactory
struct IVideoStreamDescriptorFactory : IInspectable {
	virtual STDMETHODIMP _Create(MediaProperties::VideoEncodingProperties* encodingProperties, VideoStreamDescriptor* *result);
};

// IVideoStreamDescriptor2
struct IVideoStreamDescriptor2_raw : IInspectable {
	virtual STDMETHODIMP _Copy(VideoStreamDescriptor* *result);
};
template<typename X> struct IVideoStreamDescriptor2_adaptor : X {
	ptr<VideoStreamDescriptor> Copy() { VideoStreamDescriptor* result; hrcheck(X::get()->_Copy(&result)); return from_abi(result); }
};
template<typename X> struct adapt<IVideoStreamDescriptor2, X> : Windows::Media::Core::IVideoStreamDescriptor2_adaptor<X> { typedef adapt IVideoStreamDescriptor2; };
struct IVideoStreamDescriptor2 : IVideoStreamDescriptor2_raw, generate<IVideoStreamDescriptor2> {};

// IVideoStreamDescriptor
struct IVideoStreamDescriptor_raw : IInspectable {
	virtual STDMETHODIMP _get_EncodingProperties(MediaProperties::VideoEncodingProperties* *encodingProperties);
};
template<typename X> struct IVideoStreamDescriptor_adaptor : X {
	union {
		struct : property {
			ptr<MediaProperties::VideoEncodingProperties> get() { MediaProperties::VideoEncodingProperties* encodingProperties; hrcheck(enc(&IVideoStreamDescriptor_adaptor::EncodingProperties)->_get_EncodingProperties(&encodingProperties)); return from_abi(encodingProperties); }
			ptr<MediaProperties::VideoEncodingProperties> operator()() { return get(); }
			operator ptr<MediaProperties::VideoEncodingProperties> () { return get(); }
			ptr<MediaProperties::VideoEncodingProperties> operator->() { return get(); }
		} EncodingProperties;
	};
	IVideoStreamDescriptor_adaptor() {}
};
template<typename X> struct adapt<IVideoStreamDescriptor, X> : Windows::Media::Core::IVideoStreamDescriptor_adaptor<X> { typedef adapt IVideoStreamDescriptor; };
struct IVideoStreamDescriptor : IVideoStreamDescriptor_raw, generate<IVideoStreamDescriptor> {};

// VideoStreamDescriptor
template<typename> struct VideoStreamDescriptor_statics {
	static VideoStreamDescriptor *activate(pptr<MediaProperties::VideoEncodingProperties> encodingProperties) { VideoStreamDescriptor *result; hrcheck(get_activation_factory<VideoStreamDescriptor, IVideoStreamDescriptorFactory>()->_Create(encodingProperties, &result)); return result; }
};

template<typename X> struct statics<VideoStreamDescriptor, X> : X, Windows::Media::Core::VideoStreamDescriptor_statics<void> {
	using Windows::Media::Core::VideoStreamDescriptor_statics<void>::activate;
	typedef typename X::root_type VideoStreamDescriptor;
};
struct VideoStreamDescriptor : generate<VideoStreamDescriptor> {};

// ITimedMetadataStreamDescriptorFactory
struct ITimedMetadataStreamDescriptorFactory : IInspectable {
	virtual STDMETHODIMP _Create(MediaProperties::TimedMetadataEncodingProperties* encodingProperties, TimedMetadataStreamDescriptor* *result);
};

// ITimedMetadataStreamDescriptor
struct ITimedMetadataStreamDescriptor_raw : IInspectable {
	virtual STDMETHODIMP _get_EncodingProperties(MediaProperties::TimedMetadataEncodingProperties* *value);
	virtual STDMETHODIMP _Copy(TimedMetadataStreamDescriptor* *result);
};
template<typename X> struct ITimedMetadataStreamDescriptor_adaptor : X {
	union {
		struct : property {
			ptr<MediaProperties::TimedMetadataEncodingProperties> get() { MediaProperties::TimedMetadataEncodingProperties* value; hrcheck(enc(&ITimedMetadataStreamDescriptor_adaptor::EncodingProperties)->_get_EncodingProperties(&value)); return from_abi(value); }
			ptr<MediaProperties::TimedMetadataEncodingProperties> operator()() { return get(); }
			operator ptr<MediaProperties::TimedMetadataEncodingProperties> () { return get(); }
			ptr<MediaProperties::TimedMetadataEncodingProperties> operator->() { return get(); }
		} EncodingProperties;
	};
	ptr<TimedMetadataStreamDescriptor> Copy() { TimedMetadataStreamDescriptor* result; hrcheck(X::get()->_Copy(&result)); return from_abi(result); }
	ITimedMetadataStreamDescriptor_adaptor() {}
};
template<typename X> struct adapt<ITimedMetadataStreamDescriptor, X> : Windows::Media::Core::ITimedMetadataStreamDescriptor_adaptor<X> { typedef adapt ITimedMetadataStreamDescriptor; };
struct ITimedMetadataStreamDescriptor : ITimedMetadataStreamDescriptor_raw, generate<ITimedMetadataStreamDescriptor> {};

// TimedMetadataStreamDescriptor
template<typename> struct TimedMetadataStreamDescriptor_statics {
	static TimedMetadataStreamDescriptor *activate(pptr<MediaProperties::TimedMetadataEncodingProperties> encodingProperties) { TimedMetadataStreamDescriptor *result; hrcheck(get_activation_factory<TimedMetadataStreamDescriptor, ITimedMetadataStreamDescriptorFactory>()->_Create(encodingProperties, &result)); return result; }
};

template<typename X> struct statics<TimedMetadataStreamDescriptor, X> : X, Windows::Media::Core::TimedMetadataStreamDescriptor_statics<void> {
	using Windows::Media::Core::TimedMetadataStreamDescriptor_statics<void>::activate;
	typedef typename X::root_type TimedMetadataStreamDescriptor;
};
struct TimedMetadataStreamDescriptor : generate<TimedMetadataStreamDescriptor> {};

// IMediaSource
struct IMediaSource : IInspectable, generate<IMediaSource> {};

// IMediaStreamSource
struct IMediaStreamSource_raw : IInspectable {
	virtual STDMETHODIMP _add_Closed(Foundation::TypedEventHandler<MediaStreamSource*, MediaStreamSourceClosedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Closed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Starting(Foundation::TypedEventHandler<MediaStreamSource*, MediaStreamSourceStartingEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Starting(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Paused(Foundation::TypedEventHandler<MediaStreamSource*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Paused(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_SampleRequested(Foundation::TypedEventHandler<MediaStreamSource*, MediaStreamSourceSampleRequestedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SampleRequested(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_SwitchStreamsRequested(Foundation::TypedEventHandler<MediaStreamSource*, MediaStreamSourceSwitchStreamsRequestedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SwitchStreamsRequested(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _NotifyError(MediaStreamSourceErrorStatus errorStatus);
	virtual STDMETHODIMP _AddStreamDescriptor(IMediaStreamDescriptor* descriptor);
	virtual STDMETHODIMP _put_MediaProtectionManager(Protection::MediaProtectionManager* value);
	virtual STDMETHODIMP _get_MediaProtectionManager(Protection::MediaProtectionManager* *value);
	virtual STDMETHODIMP _put_Duration(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_Duration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_CanSeek(bool value);
	virtual STDMETHODIMP _get_CanSeek(bool *value);
	virtual STDMETHODIMP _put_BufferTime(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_BufferTime(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _SetBufferedRange(Foundation::TimeSpan startOffset, Foundation::TimeSpan endOffset);
	virtual STDMETHODIMP _get_MusicProperties(Storage::FileProperties::MusicProperties* *value);
	virtual STDMETHODIMP _get_VideoProperties(Storage::FileProperties::VideoProperties* *value);
	virtual STDMETHODIMP _put_Thumbnail(Storage::Streams::IRandomAccessStreamReference* value);
	virtual STDMETHODIMP _get_Thumbnail(Storage::Streams::IRandomAccessStreamReference* *value);
	virtual STDMETHODIMP _AddProtectionKey(IMediaStreamDescriptor* streamDescriptor, unsigned keyIdentifierSize, unsigned char *keyIdentifier, unsigned licenseDataSize, unsigned char *licenseData);
};
template<typename X> struct IMediaStreamSource_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaStreamSource_adaptor::BufferTime)->_get_BufferTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMediaStreamSource_adaptor::BufferTime)->_put_BufferTime(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} BufferTime;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaStreamSource_adaptor::CanSeek)->_get_CanSeek(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaStreamSource_adaptor::CanSeek)->_put_CanSeek(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} CanSeek;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaStreamSource_adaptor::Duration)->_get_Duration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMediaStreamSource_adaptor::Duration)->_put_Duration(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Duration;
		struct : property {
			ptr<Protection::MediaProtectionManager> get() { Protection::MediaProtectionManager* value; hrcheck(enc(&IMediaStreamSource_adaptor::MediaProtectionManager)->_get_MediaProtectionManager(&value)); return from_abi(value); }
			ptr<Protection::MediaProtectionManager> operator()() { return get(); }
			operator ptr<Protection::MediaProtectionManager> () { return get(); }
			ptr<Protection::MediaProtectionManager> operator->() { return get(); }
			void put(pptr<Protection::MediaProtectionManager> value) { hrcheck(enc(&IMediaStreamSource_adaptor::MediaProtectionManager)->_put_MediaProtectionManager(value)); }
			void operator=(pptr<Protection::MediaProtectionManager> value) { put(value); }
			void operator()(pptr<Protection::MediaProtectionManager> value) { put(value); }
		} MediaProtectionManager;
		struct : property {
			ptr<Storage::FileProperties::MusicProperties> get() { Storage::FileProperties::MusicProperties* value; hrcheck(enc(&IMediaStreamSource_adaptor::MusicProperties)->_get_MusicProperties(&value)); return from_abi(value); }
			ptr<Storage::FileProperties::MusicProperties> operator()() { return get(); }
			operator ptr<Storage::FileProperties::MusicProperties> () { return get(); }
			ptr<Storage::FileProperties::MusicProperties> operator->() { return get(); }
		} MusicProperties;
		struct : property {
			ptr<Storage::Streams::IRandomAccessStreamReference> get() { Storage::Streams::IRandomAccessStreamReference* value; hrcheck(enc(&IMediaStreamSource_adaptor::Thumbnail)->_get_Thumbnail(&value)); return from_abi(value); }
			ptr<Storage::Streams::IRandomAccessStreamReference> operator()() { return get(); }
			operator ptr<Storage::Streams::IRandomAccessStreamReference> () { return get(); }
			ptr<Storage::Streams::IRandomAccessStreamReference> operator->() { return get(); }
			void put(pptr<Storage::Streams::IRandomAccessStreamReference> value) { hrcheck(enc(&IMediaStreamSource_adaptor::Thumbnail)->_put_Thumbnail(value)); }
			void operator=(pptr<Storage::Streams::IRandomAccessStreamReference> value) { put(value); }
			void operator()(pptr<Storage::Streams::IRandomAccessStreamReference> value) { put(value); }
		} Thumbnail;
		struct : property {
			ptr<Storage::FileProperties::VideoProperties> get() { Storage::FileProperties::VideoProperties* value; hrcheck(enc(&IMediaStreamSource_adaptor::VideoProperties)->_get_VideoProperties(&value)); return from_abi(value); }
			ptr<Storage::FileProperties::VideoProperties> operator()() { return get(); }
			operator ptr<Storage::FileProperties::VideoProperties> () { return get(); }
			ptr<Storage::FileProperties::VideoProperties> operator->() { return get(); }
		} VideoProperties;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaStreamSource>, ptr<MediaStreamSourceClosedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaStreamSource_adaptor::Closed)->_add_Closed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaStreamSource_adaptor::Closed)->_remove_Closed(token)); }
		} Closed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaStreamSource>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaStreamSource_adaptor::Paused)->_add_Paused(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaStreamSource_adaptor::Paused)->_remove_Paused(token)); }
		} Paused;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaStreamSource>, ptr<MediaStreamSourceSampleRequestedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaStreamSource_adaptor::SampleRequested)->_add_SampleRequested(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaStreamSource_adaptor::SampleRequested)->_remove_SampleRequested(token)); }
		} SampleRequested;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaStreamSource>, ptr<MediaStreamSourceStartingEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaStreamSource_adaptor::Starting)->_add_Starting(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaStreamSource_adaptor::Starting)->_remove_Starting(token)); }
		} Starting;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaStreamSource>, ptr<MediaStreamSourceSwitchStreamsRequestedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaStreamSource_adaptor::SwitchStreamsRequested)->_add_SwitchStreamsRequested(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaStreamSource_adaptor::SwitchStreamsRequested)->_remove_SwitchStreamsRequested(token)); }
		} SwitchStreamsRequested;
	};
	void NotifyError(MediaStreamSourceErrorStatus errorStatus) { hrcheck(X::get()->_NotifyError(errorStatus)); }
	void AddStreamDescriptor(pptr<IMediaStreamDescriptor> descriptor) { hrcheck(X::get()->_AddStreamDescriptor(descriptor)); }
	void SetBufferedRange(const Foundation::TimeSpan& startOffset, const Foundation::TimeSpan& endOffset) { hrcheck(X::get()->_SetBufferedRange(startOffset, endOffset)); }
	void AddProtectionKey(pptr<IMediaStreamDescriptor> streamDescriptor, const szarray<unsigned char>& keyIdentifier, const szarray<unsigned char>& licenseData) { hrcheck(X::get()->_AddProtectionKey(streamDescriptor, keyIdentifier.size, to_abi(keyIdentifier.p), licenseData.size, to_abi(licenseData.p))); }
	IMediaStreamSource_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamSource, X> : Windows::Media::Core::IMediaStreamSource_adaptor<X> { typedef adapt IMediaStreamSource; };
struct IMediaStreamSource : IMediaStreamSource_raw, generate<IMediaStreamSource> {};

// IMediaStreamSourceFactory
struct IMediaStreamSourceFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromDescriptor(IMediaStreamDescriptor* descriptor, MediaStreamSource* *result);
	virtual STDMETHODIMP _CreateFromDescriptors(IMediaStreamDescriptor* descriptor, IMediaStreamDescriptor* descriptor2, MediaStreamSource* *result);
};

// IMediaStreamSource4
struct IMediaStreamSource4_raw : IInspectable {
	virtual STDMETHODIMP _put_IsLive(bool value);
	virtual STDMETHODIMP _get_IsLive(bool *value);
};
template<typename X> struct IMediaStreamSource4_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaStreamSource4_adaptor::IsLive)->_get_IsLive(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaStreamSource4_adaptor::IsLive)->_put_IsLive(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsLive;
	};
	IMediaStreamSource4_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamSource4, X> : Windows::Media::Core::IMediaStreamSource4_adaptor<X> { typedef adapt IMediaStreamSource4; };
struct IMediaStreamSource4 : IMediaStreamSource4_raw, generate<IMediaStreamSource4> {};

// IMediaStreamSource3
struct IMediaStreamSource3_raw : IInspectable {
	virtual STDMETHODIMP _put_MaxSupportedPlaybackRate(Foundation::IReference<double>* value);
	virtual STDMETHODIMP _get_MaxSupportedPlaybackRate(Foundation::IReference<double>* *value);
};
template<typename X> struct IMediaStreamSource3_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<double>> get() { Foundation::IReference<double>* value; hrcheck(enc(&IMediaStreamSource3_adaptor::MaxSupportedPlaybackRate)->_get_MaxSupportedPlaybackRate(&value)); return from_abi(value); }
			ptr<Foundation::IReference<double>> operator()() { return get(); }
			operator ptr<Foundation::IReference<double>> () { return get(); }
			ptr<Foundation::IReference<double>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<double>> value) { hrcheck(enc(&IMediaStreamSource3_adaptor::MaxSupportedPlaybackRate)->_put_MaxSupportedPlaybackRate(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<double>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<double>> value) { put(to_abi(value)); }
		} MaxSupportedPlaybackRate;
	};
	IMediaStreamSource3_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamSource3, X> : Windows::Media::Core::IMediaStreamSource3_adaptor<X> { typedef adapt IMediaStreamSource3; };
struct IMediaStreamSource3 : IMediaStreamSource3_raw, generate<IMediaStreamSource3> {};

// IMediaStreamSource2
struct IMediaStreamSource2_raw : IInspectable {
	virtual STDMETHODIMP _add_SampleRendered(Foundation::TypedEventHandler<MediaStreamSource*, MediaStreamSourceSampleRenderedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SampleRendered(Foundation::EventRegistrationToken token);
};
template<typename X> struct IMediaStreamSource2_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaStreamSource>, ptr<MediaStreamSourceSampleRenderedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaStreamSource2_adaptor::SampleRendered)->_add_SampleRendered(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaStreamSource2_adaptor::SampleRendered)->_remove_SampleRendered(token)); }
		} SampleRendered;
	};
	IMediaStreamSource2_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamSource2, X> : Windows::Media::Core::IMediaStreamSource2_adaptor<X> { typedef adapt IMediaStreamSource2; };
struct IMediaStreamSource2 : IMediaStreamSource2_raw, generate<IMediaStreamSource2> {};

// MediaStreamSource
template<typename> struct MediaStreamSource_statics {
	static MediaStreamSource *activate(pptr<IMediaStreamDescriptor> descriptor) { MediaStreamSource *result; hrcheck(get_activation_factory<MediaStreamSource, IMediaStreamSourceFactory>()->_CreateFromDescriptor(descriptor, &result)); return result; }
	static MediaStreamSource *activate(pptr<IMediaStreamDescriptor> descriptor, pptr<IMediaStreamDescriptor> descriptor2) { MediaStreamSource *result; hrcheck(get_activation_factory<MediaStreamSource, IMediaStreamSourceFactory>()->_CreateFromDescriptors(descriptor, descriptor2, &result)); return result; }
};

template<typename X> struct statics<MediaStreamSource, X> : X, Windows::Media::Core::MediaStreamSource_statics<void> {
	using Windows::Media::Core::MediaStreamSource_statics<void>::activate;
	typedef typename X::root_type MediaStreamSource;
};
struct MediaStreamSource : generate<MediaStreamSource> {};

// IMediaStreamSourceClosedEventArgs
struct IMediaStreamSourceClosedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Request(MediaStreamSourceClosedRequest* *value);
};
template<typename X> struct IMediaStreamSourceClosedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<MediaStreamSourceClosedRequest> get() { MediaStreamSourceClosedRequest* value; hrcheck(enc(&IMediaStreamSourceClosedEventArgs_adaptor::Request)->_get_Request(&value)); return from_abi(value); }
			ptr<MediaStreamSourceClosedRequest> operator()() { return get(); }
			operator ptr<MediaStreamSourceClosedRequest> () { return get(); }
			ptr<MediaStreamSourceClosedRequest> operator->() { return get(); }
		} Request;
	};
	IMediaStreamSourceClosedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamSourceClosedEventArgs, X> : Windows::Media::Core::IMediaStreamSourceClosedEventArgs_adaptor<X> { typedef adapt IMediaStreamSourceClosedEventArgs; };
struct IMediaStreamSourceClosedEventArgs : IMediaStreamSourceClosedEventArgs_raw, generate<IMediaStreamSourceClosedEventArgs> {};

// MediaStreamSourceClosedEventArgs
template<typename X> struct statics<MediaStreamSourceClosedEventArgs, X> : X {
	typedef typename X::root_type MediaStreamSourceClosedEventArgs;
};
struct MediaStreamSourceClosedEventArgs : generate<MediaStreamSourceClosedEventArgs> {};

// IMediaStreamSourceStartingEventArgs
struct IMediaStreamSourceStartingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Request(MediaStreamSourceStartingRequest* *value);
};
template<typename X> struct IMediaStreamSourceStartingEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<MediaStreamSourceStartingRequest> get() { MediaStreamSourceStartingRequest* value; hrcheck(enc(&IMediaStreamSourceStartingEventArgs_adaptor::Request)->_get_Request(&value)); return from_abi(value); }
			ptr<MediaStreamSourceStartingRequest> operator()() { return get(); }
			operator ptr<MediaStreamSourceStartingRequest> () { return get(); }
			ptr<MediaStreamSourceStartingRequest> operator->() { return get(); }
		} Request;
	};
	IMediaStreamSourceStartingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamSourceStartingEventArgs, X> : Windows::Media::Core::IMediaStreamSourceStartingEventArgs_adaptor<X> { typedef adapt IMediaStreamSourceStartingEventArgs; };
struct IMediaStreamSourceStartingEventArgs : IMediaStreamSourceStartingEventArgs_raw, generate<IMediaStreamSourceStartingEventArgs> {};

// MediaStreamSourceStartingEventArgs
template<typename X> struct statics<MediaStreamSourceStartingEventArgs, X> : X {
	typedef typename X::root_type MediaStreamSourceStartingEventArgs;
};
struct MediaStreamSourceStartingEventArgs : generate<MediaStreamSourceStartingEventArgs> {};

// IMediaStreamSourceSampleRequestedEventArgs
struct IMediaStreamSourceSampleRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Request(MediaStreamSourceSampleRequest* *value);
};
template<typename X> struct IMediaStreamSourceSampleRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<MediaStreamSourceSampleRequest> get() { MediaStreamSourceSampleRequest* value; hrcheck(enc(&IMediaStreamSourceSampleRequestedEventArgs_adaptor::Request)->_get_Request(&value)); return from_abi(value); }
			ptr<MediaStreamSourceSampleRequest> operator()() { return get(); }
			operator ptr<MediaStreamSourceSampleRequest> () { return get(); }
			ptr<MediaStreamSourceSampleRequest> operator->() { return get(); }
		} Request;
	};
	IMediaStreamSourceSampleRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamSourceSampleRequestedEventArgs, X> : Windows::Media::Core::IMediaStreamSourceSampleRequestedEventArgs_adaptor<X> { typedef adapt IMediaStreamSourceSampleRequestedEventArgs; };
struct IMediaStreamSourceSampleRequestedEventArgs : IMediaStreamSourceSampleRequestedEventArgs_raw, generate<IMediaStreamSourceSampleRequestedEventArgs> {};

// MediaStreamSourceSampleRequestedEventArgs
template<typename X> struct statics<MediaStreamSourceSampleRequestedEventArgs, X> : X {
	typedef typename X::root_type MediaStreamSourceSampleRequestedEventArgs;
};
struct MediaStreamSourceSampleRequestedEventArgs : generate<MediaStreamSourceSampleRequestedEventArgs> {};

// IMediaStreamSourceSwitchStreamsRequestedEventArgs
struct IMediaStreamSourceSwitchStreamsRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Request(MediaStreamSourceSwitchStreamsRequest* *value);
};
template<typename X> struct IMediaStreamSourceSwitchStreamsRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<MediaStreamSourceSwitchStreamsRequest> get() { MediaStreamSourceSwitchStreamsRequest* value; hrcheck(enc(&IMediaStreamSourceSwitchStreamsRequestedEventArgs_adaptor::Request)->_get_Request(&value)); return from_abi(value); }
			ptr<MediaStreamSourceSwitchStreamsRequest> operator()() { return get(); }
			operator ptr<MediaStreamSourceSwitchStreamsRequest> () { return get(); }
			ptr<MediaStreamSourceSwitchStreamsRequest> operator->() { return get(); }
		} Request;
	};
	IMediaStreamSourceSwitchStreamsRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamSourceSwitchStreamsRequestedEventArgs, X> : Windows::Media::Core::IMediaStreamSourceSwitchStreamsRequestedEventArgs_adaptor<X> { typedef adapt IMediaStreamSourceSwitchStreamsRequestedEventArgs; };
struct IMediaStreamSourceSwitchStreamsRequestedEventArgs : IMediaStreamSourceSwitchStreamsRequestedEventArgs_raw, generate<IMediaStreamSourceSwitchStreamsRequestedEventArgs> {};

// MediaStreamSourceSwitchStreamsRequestedEventArgs
template<typename X> struct statics<MediaStreamSourceSwitchStreamsRequestedEventArgs, X> : X {
	typedef typename X::root_type MediaStreamSourceSwitchStreamsRequestedEventArgs;
};
struct MediaStreamSourceSwitchStreamsRequestedEventArgs : generate<MediaStreamSourceSwitchStreamsRequestedEventArgs> {};

// IMediaStreamSourceSampleRenderedEventArgs
struct IMediaStreamSourceSampleRenderedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_SampleLag(Foundation::TimeSpan *value);
};
template<typename X> struct IMediaStreamSourceSampleRenderedEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaStreamSourceSampleRenderedEventArgs_adaptor::SampleLag)->_get_SampleLag(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} SampleLag;
	};
	IMediaStreamSourceSampleRenderedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamSourceSampleRenderedEventArgs, X> : Windows::Media::Core::IMediaStreamSourceSampleRenderedEventArgs_adaptor<X> { typedef adapt IMediaStreamSourceSampleRenderedEventArgs; };
struct IMediaStreamSourceSampleRenderedEventArgs : IMediaStreamSourceSampleRenderedEventArgs_raw, generate<IMediaStreamSourceSampleRenderedEventArgs> {};

// MediaStreamSourceSampleRenderedEventArgs
template<typename X> struct statics<MediaStreamSourceSampleRenderedEventArgs, X> : X {
	typedef typename X::root_type MediaStreamSourceSampleRenderedEventArgs;
};
struct MediaStreamSourceSampleRenderedEventArgs : generate<MediaStreamSourceSampleRenderedEventArgs> {};

// MediaStreamSamplePropertySet
template<typename X> struct statics<MediaStreamSamplePropertySet, X> : X {
	typedef typename X::root_type MediaStreamSamplePropertySet;
};
struct MediaStreamSamplePropertySet : generate<MediaStreamSamplePropertySet> {};

// IMediaStreamSample
struct IMediaStreamSample_raw : IInspectable {
	virtual STDMETHODIMP _add_Processed(Foundation::TypedEventHandler<MediaStreamSample*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Processed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_Buffer(Storage::Streams::Buffer* *value);
	virtual STDMETHODIMP _get_Timestamp(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_ExtendedProperties(MediaStreamSamplePropertySet* *value);
	virtual STDMETHODIMP _get_Protection(MediaStreamSampleProtectionProperties* *value);
	virtual STDMETHODIMP _put_DecodeTimestamp(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_DecodeTimestamp(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_Duration(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_Duration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_KeyFrame(bool value);
	virtual STDMETHODIMP _get_KeyFrame(bool *value);
	virtual STDMETHODIMP _put_Discontinuous(bool value);
	virtual STDMETHODIMP _get_Discontinuous(bool *value);
};
template<typename X> struct IMediaStreamSample_adaptor : X {
	union {
		struct : property {
			ptr<Storage::Streams::Buffer> get() { Storage::Streams::Buffer* value; hrcheck(enc(&IMediaStreamSample_adaptor::Buffer)->_get_Buffer(&value)); return from_abi(value); }
			ptr<Storage::Streams::Buffer> operator()() { return get(); }
			operator ptr<Storage::Streams::Buffer> () { return get(); }
			ptr<Storage::Streams::Buffer> operator->() { return get(); }
		} Buffer;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaStreamSample_adaptor::DecodeTimestamp)->_get_DecodeTimestamp(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMediaStreamSample_adaptor::DecodeTimestamp)->_put_DecodeTimestamp(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} DecodeTimestamp;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaStreamSample_adaptor::Discontinuous)->_get_Discontinuous(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaStreamSample_adaptor::Discontinuous)->_put_Discontinuous(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Discontinuous;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaStreamSample_adaptor::Duration)->_get_Duration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMediaStreamSample_adaptor::Duration)->_put_Duration(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Duration;
		struct : property {
			ptr<MediaStreamSamplePropertySet> get() { MediaStreamSamplePropertySet* value; hrcheck(enc(&IMediaStreamSample_adaptor::ExtendedProperties)->_get_ExtendedProperties(&value)); return from_abi(value); }
			ptr<MediaStreamSamplePropertySet> operator()() { return get(); }
			operator ptr<MediaStreamSamplePropertySet> () { return get(); }
			ptr<MediaStreamSamplePropertySet> operator->() { return get(); }
		} ExtendedProperties;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaStreamSample_adaptor::KeyFrame)->_get_KeyFrame(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaStreamSample_adaptor::KeyFrame)->_put_KeyFrame(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} KeyFrame;
		struct : property {
			ptr<MediaStreamSampleProtectionProperties> get() { MediaStreamSampleProtectionProperties* value; hrcheck(enc(&IMediaStreamSample_adaptor::Protection)->_get_Protection(&value)); return from_abi(value); }
			ptr<MediaStreamSampleProtectionProperties> operator()() { return get(); }
			operator ptr<MediaStreamSampleProtectionProperties> () { return get(); }
			ptr<MediaStreamSampleProtectionProperties> operator->() { return get(); }
		} Protection;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaStreamSample_adaptor::Timestamp)->_get_Timestamp(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} Timestamp;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaStreamSample>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaStreamSample_adaptor::Processed)->_add_Processed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaStreamSample_adaptor::Processed)->_remove_Processed(token)); }
		} Processed;
	};
	IMediaStreamSample_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamSample, X> : Windows::Media::Core::IMediaStreamSample_adaptor<X> { typedef adapt IMediaStreamSample; };
struct IMediaStreamSample : IMediaStreamSample_raw, generate<IMediaStreamSample> {};

// IMediaStreamSampleStatics
struct IMediaStreamSampleStatics : IInspectable {
	virtual STDMETHODIMP _CreateFromBuffer(Storage::Streams::IBuffer* buffer, Foundation::TimeSpan timestamp, MediaStreamSample* *value);
	virtual STDMETHODIMP _CreateFromStreamAsync(Storage::Streams::IInputStream* stream, unsigned count, Foundation::TimeSpan timestamp, Foundation::IAsyncOperation<MediaStreamSample*>* *value);
};

// MediaStreamSample
template<typename> struct MediaStreamSample_statics {
	static ptr<MediaStreamSample> CreateFromBuffer(pptr<Storage::Streams::IBuffer> buffer, const Foundation::TimeSpan& timestamp) { MediaStreamSample* value; hrcheck(get_activation_factory<MediaStreamSample, IMediaStreamSampleStatics>()->_CreateFromBuffer(buffer, timestamp, &value)); return from_abi(value); }
	static ptr<Foundation::IAsyncOperation<ptr<MediaStreamSample>>> CreateFromStreamAsync(pptr<Storage::Streams::IInputStream> stream, unsigned count, const Foundation::TimeSpan& timestamp) { Foundation::IAsyncOperation<MediaStreamSample*>* value; hrcheck(get_activation_factory<MediaStreamSample, IMediaStreamSampleStatics>()->_CreateFromStreamAsync(stream, count, timestamp, &value)); return from_abi(value); }
};

template<typename X> struct statics<MediaStreamSample, X> : X, Windows::Media::Core::MediaStreamSample_statics<void> {
	typedef typename X::root_type MediaStreamSample;
};
struct MediaStreamSample : generate<MediaStreamSample> {};

// IMediaStreamSampleProtectionProperties
struct IMediaStreamSampleProtectionProperties_raw : IInspectable {
	virtual STDMETHODIMP _SetKeyIdentifier(unsigned valueSize, unsigned char *value);
	virtual STDMETHODIMP _GetKeyIdentifier(unsigned *valueSize, unsigned char **value);
	virtual STDMETHODIMP _SetInitializationVector(unsigned valueSize, unsigned char *value);
	virtual STDMETHODIMP _GetInitializationVector(unsigned *valueSize, unsigned char **value);
	virtual STDMETHODIMP _SetSubSampleMapping(unsigned valueSize, unsigned char *value);
	virtual STDMETHODIMP _GetSubSampleMapping(unsigned *valueSize, unsigned char **value);
};
template<typename X> struct IMediaStreamSampleProtectionProperties_adaptor : X {
	void SetKeyIdentifier(const szarray<unsigned char>& value) { hrcheck(X::get()->_SetKeyIdentifier(value.size, to_abi(value.p))); }
	szarray<unsigned char> GetKeyIdentifier() { szarray<unsigned char> value; hrcheck(X::get()->_GetKeyIdentifier(&value.size, &value.p)); return value; }
	void SetInitializationVector(const szarray<unsigned char>& value) { hrcheck(X::get()->_SetInitializationVector(value.size, to_abi(value.p))); }
	szarray<unsigned char> GetInitializationVector() { szarray<unsigned char> value; hrcheck(X::get()->_GetInitializationVector(&value.size, &value.p)); return value; }
	void SetSubSampleMapping(const szarray<unsigned char>& value) { hrcheck(X::get()->_SetSubSampleMapping(value.size, to_abi(value.p))); }
	szarray<unsigned char> GetSubSampleMapping() { szarray<unsigned char> value; hrcheck(X::get()->_GetSubSampleMapping(&value.size, &value.p)); return value; }
};
template<typename X> struct adapt<IMediaStreamSampleProtectionProperties, X> : Windows::Media::Core::IMediaStreamSampleProtectionProperties_adaptor<X> { typedef adapt IMediaStreamSampleProtectionProperties; };
struct IMediaStreamSampleProtectionProperties : IMediaStreamSampleProtectionProperties_raw, generate<IMediaStreamSampleProtectionProperties> {};

// MediaStreamSampleProtectionProperties
template<typename X> struct statics<MediaStreamSampleProtectionProperties, X> : X {
	typedef typename X::root_type MediaStreamSampleProtectionProperties;
};
struct MediaStreamSampleProtectionProperties : generate<MediaStreamSampleProtectionProperties> {};

// IMediaStreamSourceClosedRequest
struct IMediaStreamSourceClosedRequest_raw : IInspectable {
	virtual STDMETHODIMP _get_Reason(MediaStreamSourceClosedReason *value);
};
template<typename X> struct IMediaStreamSourceClosedRequest_adaptor : X {
	union {
		struct : property {
			MediaStreamSourceClosedReason get() { MediaStreamSourceClosedReason value; hrcheck(enc(&IMediaStreamSourceClosedRequest_adaptor::Reason)->_get_Reason(&value)); return value; }
			MediaStreamSourceClosedReason operator()() { return get(); }
			operator MediaStreamSourceClosedReason () { return get(); }
		} Reason;
	};
	IMediaStreamSourceClosedRequest_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamSourceClosedRequest, X> : Windows::Media::Core::IMediaStreamSourceClosedRequest_adaptor<X> { typedef adapt IMediaStreamSourceClosedRequest; };
struct IMediaStreamSourceClosedRequest : IMediaStreamSourceClosedRequest_raw, generate<IMediaStreamSourceClosedRequest> {};

// MediaStreamSourceClosedRequest
template<typename X> struct statics<MediaStreamSourceClosedRequest, X> : X {
	typedef typename X::root_type MediaStreamSourceClosedRequest;
};
struct MediaStreamSourceClosedRequest : generate<MediaStreamSourceClosedRequest> {};

// IMediaStreamSourceStartingRequestDeferral
struct IMediaStreamSourceStartingRequestDeferral_raw : IInspectable {
	virtual STDMETHODIMP _Complete();
};
template<typename X> struct IMediaStreamSourceStartingRequestDeferral_adaptor : X {
	void Complete() { hrcheck(X::get()->_Complete()); }
};
template<typename X> struct adapt<IMediaStreamSourceStartingRequestDeferral, X> : Windows::Media::Core::IMediaStreamSourceStartingRequestDeferral_adaptor<X> { typedef adapt IMediaStreamSourceStartingRequestDeferral; };
struct IMediaStreamSourceStartingRequestDeferral : IMediaStreamSourceStartingRequestDeferral_raw, generate<IMediaStreamSourceStartingRequestDeferral> {};

// MediaStreamSourceStartingRequestDeferral
template<typename X> struct statics<MediaStreamSourceStartingRequestDeferral, X> : X {
	typedef typename X::root_type MediaStreamSourceStartingRequestDeferral;
};
struct MediaStreamSourceStartingRequestDeferral : generate<MediaStreamSourceStartingRequestDeferral> {};

// IMediaStreamSourceStartingRequest
struct IMediaStreamSourceStartingRequest_raw : IInspectable {
	virtual STDMETHODIMP _get_StartPosition(Foundation::IReference<Foundation::TimeSpan>* *value);
	virtual STDMETHODIMP _GetDeferral(MediaStreamSourceStartingRequestDeferral* *deferral);
	virtual STDMETHODIMP _SetActualStartPosition(Foundation::TimeSpan position);
};
template<typename X> struct IMediaStreamSourceStartingRequest_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IMediaStreamSourceStartingRequest_adaptor::StartPosition)->_get_StartPosition(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
		} StartPosition;
	};
	ptr<MediaStreamSourceStartingRequestDeferral> GetDeferral() { MediaStreamSourceStartingRequestDeferral* deferral; hrcheck(X::get()->_GetDeferral(&deferral)); return from_abi(deferral); }
	void SetActualStartPosition(const Foundation::TimeSpan& position) { hrcheck(X::get()->_SetActualStartPosition(position)); }
	IMediaStreamSourceStartingRequest_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamSourceStartingRequest, X> : Windows::Media::Core::IMediaStreamSourceStartingRequest_adaptor<X> { typedef adapt IMediaStreamSourceStartingRequest; };
struct IMediaStreamSourceStartingRequest : IMediaStreamSourceStartingRequest_raw, generate<IMediaStreamSourceStartingRequest> {};

// MediaStreamSourceStartingRequest
template<typename X> struct statics<MediaStreamSourceStartingRequest, X> : X {
	typedef typename X::root_type MediaStreamSourceStartingRequest;
};
struct MediaStreamSourceStartingRequest : generate<MediaStreamSourceStartingRequest> {};

// IMediaStreamSourceSampleRequestDeferral
struct IMediaStreamSourceSampleRequestDeferral_raw : IInspectable {
	virtual STDMETHODIMP _Complete();
};
template<typename X> struct IMediaStreamSourceSampleRequestDeferral_adaptor : X {
	void Complete() { hrcheck(X::get()->_Complete()); }
};
template<typename X> struct adapt<IMediaStreamSourceSampleRequestDeferral, X> : Windows::Media::Core::IMediaStreamSourceSampleRequestDeferral_adaptor<X> { typedef adapt IMediaStreamSourceSampleRequestDeferral; };
struct IMediaStreamSourceSampleRequestDeferral : IMediaStreamSourceSampleRequestDeferral_raw, generate<IMediaStreamSourceSampleRequestDeferral> {};

// MediaStreamSourceSampleRequestDeferral
template<typename X> struct statics<MediaStreamSourceSampleRequestDeferral, X> : X {
	typedef typename X::root_type MediaStreamSourceSampleRequestDeferral;
};
struct MediaStreamSourceSampleRequestDeferral : generate<MediaStreamSourceSampleRequestDeferral> {};

// IMediaStreamSourceSampleRequest
struct IMediaStreamSourceSampleRequest_raw : IInspectable {
	virtual STDMETHODIMP _get_StreamDescriptor(IMediaStreamDescriptor* *value);
	virtual STDMETHODIMP _GetDeferral(MediaStreamSourceSampleRequestDeferral* *deferral);
	virtual STDMETHODIMP _put_Sample(MediaStreamSample* value);
	virtual STDMETHODIMP _get_Sample(MediaStreamSample* *value);
	virtual STDMETHODIMP _ReportSampleProgress(unsigned progress);
};
template<typename X> struct IMediaStreamSourceSampleRequest_adaptor : X {
	union {
		struct : property {
			ptr<MediaStreamSample> get() { MediaStreamSample* value; hrcheck(enc(&IMediaStreamSourceSampleRequest_adaptor::Sample)->_get_Sample(&value)); return from_abi(value); }
			ptr<MediaStreamSample> operator()() { return get(); }
			operator ptr<MediaStreamSample> () { return get(); }
			ptr<MediaStreamSample> operator->() { return get(); }
			void put(pptr<MediaStreamSample> value) { hrcheck(enc(&IMediaStreamSourceSampleRequest_adaptor::Sample)->_put_Sample(value)); }
			void operator=(pptr<MediaStreamSample> value) { put(value); }
			void operator()(pptr<MediaStreamSample> value) { put(value); }
		} Sample;
		struct : property {
			ptr<IMediaStreamDescriptor> get() { IMediaStreamDescriptor* value; hrcheck(enc(&IMediaStreamSourceSampleRequest_adaptor::StreamDescriptor)->_get_StreamDescriptor(&value)); return from_abi(value); }
			ptr<IMediaStreamDescriptor> operator()() { return get(); }
			operator ptr<IMediaStreamDescriptor> () { return get(); }
			ptr<IMediaStreamDescriptor> operator->() { return get(); }
		} StreamDescriptor;
	};
	ptr<MediaStreamSourceSampleRequestDeferral> GetDeferral() { MediaStreamSourceSampleRequestDeferral* deferral; hrcheck(X::get()->_GetDeferral(&deferral)); return from_abi(deferral); }
	void ReportSampleProgress(unsigned progress) { hrcheck(X::get()->_ReportSampleProgress(progress)); }
	IMediaStreamSourceSampleRequest_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamSourceSampleRequest, X> : Windows::Media::Core::IMediaStreamSourceSampleRequest_adaptor<X> { typedef adapt IMediaStreamSourceSampleRequest; };
struct IMediaStreamSourceSampleRequest : IMediaStreamSourceSampleRequest_raw, generate<IMediaStreamSourceSampleRequest> {};

// MediaStreamSourceSampleRequest
template<typename X> struct statics<MediaStreamSourceSampleRequest, X> : X {
	typedef typename X::root_type MediaStreamSourceSampleRequest;
};
struct MediaStreamSourceSampleRequest : generate<MediaStreamSourceSampleRequest> {};

// IMediaStreamSourceSwitchStreamsRequestDeferral
struct IMediaStreamSourceSwitchStreamsRequestDeferral_raw : IInspectable {
	virtual STDMETHODIMP _Complete();
};
template<typename X> struct IMediaStreamSourceSwitchStreamsRequestDeferral_adaptor : X {
	void Complete() { hrcheck(X::get()->_Complete()); }
};
template<typename X> struct adapt<IMediaStreamSourceSwitchStreamsRequestDeferral, X> : Windows::Media::Core::IMediaStreamSourceSwitchStreamsRequestDeferral_adaptor<X> { typedef adapt IMediaStreamSourceSwitchStreamsRequestDeferral; };
struct IMediaStreamSourceSwitchStreamsRequestDeferral : IMediaStreamSourceSwitchStreamsRequestDeferral_raw, generate<IMediaStreamSourceSwitchStreamsRequestDeferral> {};

// MediaStreamSourceSwitchStreamsRequestDeferral
template<typename X> struct statics<MediaStreamSourceSwitchStreamsRequestDeferral, X> : X {
	typedef typename X::root_type MediaStreamSourceSwitchStreamsRequestDeferral;
};
struct MediaStreamSourceSwitchStreamsRequestDeferral : generate<MediaStreamSourceSwitchStreamsRequestDeferral> {};

// IMediaStreamSourceSwitchStreamsRequest
struct IMediaStreamSourceSwitchStreamsRequest_raw : IInspectable {
	virtual STDMETHODIMP _get_OldStreamDescriptor(IMediaStreamDescriptor* *value);
	virtual STDMETHODIMP _get_NewStreamDescriptor(IMediaStreamDescriptor* *value);
	virtual STDMETHODIMP _GetDeferral(MediaStreamSourceSwitchStreamsRequestDeferral* *deferral);
};
template<typename X> struct IMediaStreamSourceSwitchStreamsRequest_adaptor : X {
	union {
		struct : property {
			ptr<IMediaStreamDescriptor> get() { IMediaStreamDescriptor* value; hrcheck(enc(&IMediaStreamSourceSwitchStreamsRequest_adaptor::NewStreamDescriptor)->_get_NewStreamDescriptor(&value)); return from_abi(value); }
			ptr<IMediaStreamDescriptor> operator()() { return get(); }
			operator ptr<IMediaStreamDescriptor> () { return get(); }
			ptr<IMediaStreamDescriptor> operator->() { return get(); }
		} NewStreamDescriptor;
		struct : property {
			ptr<IMediaStreamDescriptor> get() { IMediaStreamDescriptor* value; hrcheck(enc(&IMediaStreamSourceSwitchStreamsRequest_adaptor::OldStreamDescriptor)->_get_OldStreamDescriptor(&value)); return from_abi(value); }
			ptr<IMediaStreamDescriptor> operator()() { return get(); }
			operator ptr<IMediaStreamDescriptor> () { return get(); }
			ptr<IMediaStreamDescriptor> operator->() { return get(); }
		} OldStreamDescriptor;
	};
	ptr<MediaStreamSourceSwitchStreamsRequestDeferral> GetDeferral() { MediaStreamSourceSwitchStreamsRequestDeferral* deferral; hrcheck(X::get()->_GetDeferral(&deferral)); return from_abi(deferral); }
	IMediaStreamSourceSwitchStreamsRequest_adaptor() {}
};
template<typename X> struct adapt<IMediaStreamSourceSwitchStreamsRequest, X> : Windows::Media::Core::IMediaStreamSourceSwitchStreamsRequest_adaptor<X> { typedef adapt IMediaStreamSourceSwitchStreamsRequest; };
struct IMediaStreamSourceSwitchStreamsRequest : IMediaStreamSourceSwitchStreamsRequest_raw, generate<IMediaStreamSourceSwitchStreamsRequest> {};

// MediaStreamSourceSwitchStreamsRequest
template<typename X> struct statics<MediaStreamSourceSwitchStreamsRequest, X> : X {
	typedef typename X::root_type MediaStreamSourceSwitchStreamsRequest;
};
struct MediaStreamSourceSwitchStreamsRequest : generate<MediaStreamSourceSwitchStreamsRequest> {};

// IMseStreamSourceStatics
struct IMseStreamSourceStatics : IInspectable {
	virtual STDMETHODIMP _IsContentTypeSupported(HSTRING contentType, bool *value);
};

// IMseStreamSource
struct IMseStreamSource_raw : IInspectable {
	virtual STDMETHODIMP _add_Opened(Foundation::TypedEventHandler<MseStreamSource*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Opened(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Ended(Foundation::TypedEventHandler<MseStreamSource*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Ended(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Closed(Foundation::TypedEventHandler<MseStreamSource*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Closed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_SourceBuffers(MseSourceBufferList* *value);
	virtual STDMETHODIMP _get_ActiveSourceBuffers(MseSourceBufferList* *value);
	virtual STDMETHODIMP _get_ReadyState(MseReadyState *value);
	virtual STDMETHODIMP _get_Duration(Foundation::IReference<Foundation::TimeSpan>* *value);
	virtual STDMETHODIMP _put_Duration(Foundation::IReference<Foundation::TimeSpan>* value);
	virtual STDMETHODIMP _AddSourceBuffer(HSTRING mimeType, MseSourceBuffer* *buffer);
	virtual STDMETHODIMP _RemoveSourceBuffer(MseSourceBuffer* buffer);
	virtual STDMETHODIMP _EndOfStream(MseEndOfStreamStatus status);
};
template<typename X> struct IMseStreamSource_adaptor : X {
	union {
		struct : property {
			ptr<MseSourceBufferList> get() { MseSourceBufferList* value; hrcheck(enc(&IMseStreamSource_adaptor::ActiveSourceBuffers)->_get_ActiveSourceBuffers(&value)); return from_abi(value); }
			ptr<MseSourceBufferList> operator()() { return get(); }
			operator ptr<MseSourceBufferList> () { return get(); }
			ptr<MseSourceBufferList> operator->() { return get(); }
		} ActiveSourceBuffers;
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IMseStreamSource_adaptor::Duration)->_get_Duration(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&IMseStreamSource_adaptor::Duration)->_put_Duration(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} Duration;
		struct : property {
			MseReadyState get() { MseReadyState value; hrcheck(enc(&IMseStreamSource_adaptor::ReadyState)->_get_ReadyState(&value)); return value; }
			MseReadyState operator()() { return get(); }
			operator MseReadyState () { return get(); }
		} ReadyState;
		struct : property {
			ptr<MseSourceBufferList> get() { MseSourceBufferList* value; hrcheck(enc(&IMseStreamSource_adaptor::SourceBuffers)->_get_SourceBuffers(&value)); return from_abi(value); }
			ptr<MseSourceBufferList> operator()() { return get(); }
			operator ptr<MseSourceBufferList> () { return get(); }
			ptr<MseSourceBufferList> operator->() { return get(); }
		} SourceBuffers;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MseStreamSource>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMseStreamSource_adaptor::Closed)->_add_Closed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMseStreamSource_adaptor::Closed)->_remove_Closed(token)); }
		} Closed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MseStreamSource>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMseStreamSource_adaptor::Ended)->_add_Ended(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMseStreamSource_adaptor::Ended)->_remove_Ended(token)); }
		} Ended;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MseStreamSource>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMseStreamSource_adaptor::Opened)->_add_Opened(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMseStreamSource_adaptor::Opened)->_remove_Opened(token)); }
		} Opened;
	};
	ptr<MseSourceBuffer> AddSourceBuffer(hstring_ref mimeType) { MseSourceBuffer* buffer; hrcheck(X::get()->_AddSourceBuffer(mimeType, &buffer)); return from_abi(buffer); }
	void RemoveSourceBuffer(pptr<MseSourceBuffer> buffer) { hrcheck(X::get()->_RemoveSourceBuffer(buffer)); }
	void EndOfStream(MseEndOfStreamStatus status) { hrcheck(X::get()->_EndOfStream(status)); }
	IMseStreamSource_adaptor() {}
};
template<typename X> struct adapt<IMseStreamSource, X> : Windows::Media::Core::IMseStreamSource_adaptor<X> { typedef adapt IMseStreamSource; };
struct IMseStreamSource : IMseStreamSource_raw, generate<IMseStreamSource> {};

// IMseStreamSource2
struct IMseStreamSource2_raw : IInspectable {
	virtual STDMETHODIMP _get_LiveSeekableRange(Foundation::IReference<MseTimeRange>* *value);
	virtual STDMETHODIMP _put_LiveSeekableRange(Foundation::IReference<MseTimeRange>* value);
};
template<typename X> struct IMseStreamSource2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<MseTimeRange>> get() { Foundation::IReference<MseTimeRange>* value; hrcheck(enc(&IMseStreamSource2_adaptor::LiveSeekableRange)->_get_LiveSeekableRange(&value)); return from_abi(value); }
			ptr<Foundation::IReference<MseTimeRange>> operator()() { return get(); }
			operator ptr<Foundation::IReference<MseTimeRange>> () { return get(); }
			ptr<Foundation::IReference<MseTimeRange>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<MseTimeRange>> value) { hrcheck(enc(&IMseStreamSource2_adaptor::LiveSeekableRange)->_put_LiveSeekableRange(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<MseTimeRange>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<MseTimeRange>> value) { put(to_abi(value)); }
		} LiveSeekableRange;
	};
	IMseStreamSource2_adaptor() {}
};
template<typename X> struct adapt<IMseStreamSource2, X> : Windows::Media::Core::IMseStreamSource2_adaptor<X> { typedef adapt IMseStreamSource2; };
struct IMseStreamSource2 : IMseStreamSource2_raw, generate<IMseStreamSource2> {};

// MseStreamSource
template<typename> struct MseStreamSource_statics {
	static bool IsContentTypeSupported(hstring_ref contentType) { bool value; hrcheck(get_activation_factory<MseStreamSource, IMseStreamSourceStatics>()->_IsContentTypeSupported(contentType, &value)); return value; }
};

template<typename X> struct statics<MseStreamSource, X> : X, Windows::Media::Core::MseStreamSource_statics<void> {
	typedef typename X::root_type MseStreamSource;
};
struct MseStreamSource : generate<MseStreamSource> {};

// IMseSourceBufferList
struct IMseSourceBufferList_raw : IInspectable {
	virtual STDMETHODIMP _add_SourceBufferAdded(Foundation::TypedEventHandler<MseSourceBufferList*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SourceBufferAdded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_SourceBufferRemoved(Foundation::TypedEventHandler<MseSourceBufferList*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SourceBufferRemoved(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_Buffers(Foundation::Collections::IVectorView<MseSourceBuffer*>* *value);
};
template<typename X> struct IMseSourceBufferList_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<MseSourceBuffer>>> get() { Foundation::Collections::IVectorView<MseSourceBuffer*>* value; hrcheck(enc(&IMseSourceBufferList_adaptor::Buffers)->_get_Buffers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<MseSourceBuffer>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<MseSourceBuffer>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<MseSourceBuffer>>> operator->() { return get(); }
		} Buffers;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MseSourceBufferList>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMseSourceBufferList_adaptor::SourceBufferAdded)->_add_SourceBufferAdded(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMseSourceBufferList_adaptor::SourceBufferAdded)->_remove_SourceBufferAdded(token)); }
		} SourceBufferAdded;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MseSourceBufferList>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMseSourceBufferList_adaptor::SourceBufferRemoved)->_add_SourceBufferRemoved(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMseSourceBufferList_adaptor::SourceBufferRemoved)->_remove_SourceBufferRemoved(token)); }
		} SourceBufferRemoved;
	};
	IMseSourceBufferList_adaptor() {}
};
template<typename X> struct adapt<IMseSourceBufferList, X> : Windows::Media::Core::IMseSourceBufferList_adaptor<X> { typedef adapt IMseSourceBufferList; };
struct IMseSourceBufferList : IMseSourceBufferList_raw, generate<IMseSourceBufferList> {};

// MseSourceBufferList
template<typename X> struct statics<MseSourceBufferList, X> : X {
	typedef typename X::root_type MseSourceBufferList;
};
struct MseSourceBufferList : generate<MseSourceBufferList> {};

// IMseSourceBuffer
struct IMseSourceBuffer_raw : IInspectable {
	virtual STDMETHODIMP _add_UpdateStarting(Foundation::TypedEventHandler<MseSourceBuffer*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_UpdateStarting(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Updated(Foundation::TypedEventHandler<MseSourceBuffer*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Updated(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_UpdateEnded(Foundation::TypedEventHandler<MseSourceBuffer*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_UpdateEnded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ErrorOccurred(Foundation::TypedEventHandler<MseSourceBuffer*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ErrorOccurred(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Aborted(Foundation::TypedEventHandler<MseSourceBuffer*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Aborted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_Mode(MseAppendMode *value);
	virtual STDMETHODIMP _put_Mode(MseAppendMode value);
	virtual STDMETHODIMP _get_IsUpdating(bool *value);
	virtual STDMETHODIMP _get_Buffered(Foundation::Collections::IVectorView<MseTimeRange>* *value);
	virtual STDMETHODIMP _get_TimestampOffset(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_TimestampOffset(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_AppendWindowStart(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_AppendWindowStart(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_AppendWindowEnd(Foundation::IReference<Foundation::TimeSpan>* *value);
	virtual STDMETHODIMP _put_AppendWindowEnd(Foundation::IReference<Foundation::TimeSpan>* value);
	virtual STDMETHODIMP _AppendBuffer(Storage::Streams::IBuffer* buffer);
	virtual STDMETHODIMP _AppendStream(Storage::Streams::IInputStream* stream);
	virtual STDMETHODIMP _AppendStreamMaxSize(Storage::Streams::IInputStream* stream, unsigned __int64 maxSize);
	virtual STDMETHODIMP _Abort();
	virtual STDMETHODIMP _Remove(Foundation::TimeSpan start, Foundation::IReference<Foundation::TimeSpan>* end);
};
template<typename X> struct IMseSourceBuffer_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IMseSourceBuffer_adaptor::AppendWindowEnd)->_get_AppendWindowEnd(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { hrcheck(enc(&IMseSourceBuffer_adaptor::AppendWindowEnd)->_put_AppendWindowEnd(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::TimeSpan>> value) { put(to_abi(value)); }
		} AppendWindowEnd;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMseSourceBuffer_adaptor::AppendWindowStart)->_get_AppendWindowStart(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMseSourceBuffer_adaptor::AppendWindowStart)->_put_AppendWindowStart(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} AppendWindowStart;
		struct : property {
			ptr<Foundation::Collections::IVectorView<MseTimeRange>> get() { Foundation::Collections::IVectorView<MseTimeRange>* value; hrcheck(enc(&IMseSourceBuffer_adaptor::Buffered)->_get_Buffered(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<MseTimeRange>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<MseTimeRange>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<MseTimeRange>> operator->() { return get(); }
		} Buffered;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMseSourceBuffer_adaptor::IsUpdating)->_get_IsUpdating(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsUpdating;
		struct : property {
			MseAppendMode get() { MseAppendMode value; hrcheck(enc(&IMseSourceBuffer_adaptor::Mode)->_get_Mode(&value)); return value; }
			MseAppendMode operator()() { return get(); }
			operator MseAppendMode () { return get(); }
			void put(MseAppendMode value) { hrcheck(enc(&IMseSourceBuffer_adaptor::Mode)->_put_Mode(value)); }
			void operator=(MseAppendMode value) { put(value); }
			void operator()(MseAppendMode value) { put(value); }
		} Mode;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMseSourceBuffer_adaptor::TimestampOffset)->_get_TimestampOffset(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMseSourceBuffer_adaptor::TimestampOffset)->_put_TimestampOffset(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} TimestampOffset;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MseSourceBuffer>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMseSourceBuffer_adaptor::Aborted)->_add_Aborted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMseSourceBuffer_adaptor::Aborted)->_remove_Aborted(token)); }
		} Aborted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MseSourceBuffer>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMseSourceBuffer_adaptor::ErrorOccurred)->_add_ErrorOccurred(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMseSourceBuffer_adaptor::ErrorOccurred)->_remove_ErrorOccurred(token)); }
		} ErrorOccurred;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MseSourceBuffer>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMseSourceBuffer_adaptor::UpdateEnded)->_add_UpdateEnded(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMseSourceBuffer_adaptor::UpdateEnded)->_remove_UpdateEnded(token)); }
		} UpdateEnded;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MseSourceBuffer>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMseSourceBuffer_adaptor::UpdateStarting)->_add_UpdateStarting(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMseSourceBuffer_adaptor::UpdateStarting)->_remove_UpdateStarting(token)); }
		} UpdateStarting;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MseSourceBuffer>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMseSourceBuffer_adaptor::Updated)->_add_Updated(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMseSourceBuffer_adaptor::Updated)->_remove_Updated(token)); }
		} Updated;
	};
	void AppendBuffer(pptr<Storage::Streams::IBuffer> buffer) { hrcheck(X::get()->_AppendBuffer(buffer)); }
	void AppendStream(pptr<Storage::Streams::IInputStream> stream) { hrcheck(X::get()->_AppendStream(stream)); }
	void AppendStream(pptr<Storage::Streams::IInputStream> stream, unsigned __int64 maxSize) { hrcheck(X::get()->_AppendStreamMaxSize(stream, maxSize)); }
	void Abort() { hrcheck(X::get()->_Abort()); }
	void Remove(const Foundation::TimeSpan& start, pptr<Foundation::IReference<Foundation::TimeSpan>> end) { hrcheck(X::get()->_Remove(start, to_abi(end))); }
	IMseSourceBuffer_adaptor() {}
};
template<typename X> struct adapt<IMseSourceBuffer, X> : Windows::Media::Core::IMseSourceBuffer_adaptor<X> { typedef adapt IMseSourceBuffer; };
struct IMseSourceBuffer : IMseSourceBuffer_raw, generate<IMseSourceBuffer> {};

// MseSourceBuffer
template<typename X> struct statics<MseSourceBuffer, X> : X {
	typedef typename X::root_type MseSourceBuffer;
};
struct MseSourceBuffer : generate<MseSourceBuffer> {
	using IMseSourceBuffer::AppendStream;
};

// IMediaSourceAppServiceConnectionFactory
struct IMediaSourceAppServiceConnectionFactory : IInspectable {
	virtual STDMETHODIMP _Create(ApplicationModel::AppService::AppServiceConnection* appServiceConnection, MediaSourceAppServiceConnection* *result);
};

// IMediaSourceAppServiceConnection
struct IMediaSourceAppServiceConnection_raw : IInspectable {
	virtual STDMETHODIMP _add_InitializeMediaStreamSourceRequested(Foundation::TypedEventHandler<MediaSourceAppServiceConnection*, InitializeMediaStreamSourceRequestedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_InitializeMediaStreamSourceRequested(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _Start();
};
template<typename X> struct IMediaSourceAppServiceConnection_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaSourceAppServiceConnection>, ptr<InitializeMediaStreamSourceRequestedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaSourceAppServiceConnection_adaptor::InitializeMediaStreamSourceRequested)->_add_InitializeMediaStreamSourceRequested(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaSourceAppServiceConnection_adaptor::InitializeMediaStreamSourceRequested)->_remove_InitializeMediaStreamSourceRequested(token)); }
		} InitializeMediaStreamSourceRequested;
	};
	void Start() { hrcheck(X::get()->_Start()); }
	IMediaSourceAppServiceConnection_adaptor() {}
};
template<typename X> struct adapt<IMediaSourceAppServiceConnection, X> : Windows::Media::Core::IMediaSourceAppServiceConnection_adaptor<X> { typedef adapt IMediaSourceAppServiceConnection; };
struct IMediaSourceAppServiceConnection : IMediaSourceAppServiceConnection_raw, generate<IMediaSourceAppServiceConnection> {};

// MediaSourceAppServiceConnection
template<typename> struct MediaSourceAppServiceConnection_statics {
	static MediaSourceAppServiceConnection *activate(pptr<ApplicationModel::AppService::AppServiceConnection> appServiceConnection) { MediaSourceAppServiceConnection *result; hrcheck(get_activation_factory<MediaSourceAppServiceConnection, IMediaSourceAppServiceConnectionFactory>()->_Create(appServiceConnection, &result)); return result; }
};

template<typename X> struct statics<MediaSourceAppServiceConnection, X> : X, Windows::Media::Core::MediaSourceAppServiceConnection_statics<void> {
	using Windows::Media::Core::MediaSourceAppServiceConnection_statics<void>::activate;
	typedef typename X::root_type MediaSourceAppServiceConnection;
};
struct MediaSourceAppServiceConnection : generate<MediaSourceAppServiceConnection> {};

// IInitializeMediaStreamSourceRequestedEventArgs
struct IInitializeMediaStreamSourceRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Source(MediaStreamSource* *value);
	virtual STDMETHODIMP _get_RandomAccessStream(Storage::Streams::IRandomAccessStream* *value);
	virtual STDMETHODIMP _GetDeferral(Foundation::Deferral* *result);
};
template<typename X> struct IInitializeMediaStreamSourceRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Storage::Streams::IRandomAccessStream> get() { Storage::Streams::IRandomAccessStream* value; hrcheck(enc(&IInitializeMediaStreamSourceRequestedEventArgs_adaptor::RandomAccessStream)->_get_RandomAccessStream(&value)); return from_abi(value); }
			ptr<Storage::Streams::IRandomAccessStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IRandomAccessStream> () { return get(); }
			ptr<Storage::Streams::IRandomAccessStream> operator->() { return get(); }
		} RandomAccessStream;
		struct : property {
			ptr<MediaStreamSource> get() { MediaStreamSource* value; hrcheck(enc(&IInitializeMediaStreamSourceRequestedEventArgs_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			ptr<MediaStreamSource> operator()() { return get(); }
			operator ptr<MediaStreamSource> () { return get(); }
			ptr<MediaStreamSource> operator->() { return get(); }
		} Source;
	};
	ptr<Foundation::Deferral> GetDeferral() { Foundation::Deferral* result; hrcheck(X::get()->_GetDeferral(&result)); return from_abi(result); }
	IInitializeMediaStreamSourceRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IInitializeMediaStreamSourceRequestedEventArgs, X> : Windows::Media::Core::IInitializeMediaStreamSourceRequestedEventArgs_adaptor<X> { typedef adapt IInitializeMediaStreamSourceRequestedEventArgs; };
struct IInitializeMediaStreamSourceRequestedEventArgs : IInitializeMediaStreamSourceRequestedEventArgs_raw, generate<IInitializeMediaStreamSourceRequestedEventArgs> {};

// InitializeMediaStreamSourceRequestedEventArgs
template<typename X> struct statics<InitializeMediaStreamSourceRequestedEventArgs, X> : X {
	typedef typename X::root_type InitializeMediaStreamSourceRequestedEventArgs;
};
struct InitializeMediaStreamSourceRequestedEventArgs : generate<InitializeMediaStreamSourceRequestedEventArgs> {};

// IHighDynamicRangeControl
struct IHighDynamicRangeControl_raw : IInspectable {
	virtual STDMETHODIMP _put_Enabled(bool value);
	virtual STDMETHODIMP _get_Enabled(bool *value);
};
template<typename X> struct IHighDynamicRangeControl_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IHighDynamicRangeControl_adaptor::Enabled)->_get_Enabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IHighDynamicRangeControl_adaptor::Enabled)->_put_Enabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Enabled;
	};
	IHighDynamicRangeControl_adaptor() {}
};
template<typename X> struct adapt<IHighDynamicRangeControl, X> : Windows::Media::Core::IHighDynamicRangeControl_adaptor<X> { typedef adapt IHighDynamicRangeControl; };
struct IHighDynamicRangeControl : IHighDynamicRangeControl_raw, generate<IHighDynamicRangeControl> {};

// HighDynamicRangeControl
template<typename X> struct statics<HighDynamicRangeControl, X> : X {
	typedef typename X::root_type HighDynamicRangeControl;
};
struct HighDynamicRangeControl : generate<HighDynamicRangeControl> {};

// ISceneAnalysisEffect
struct ISceneAnalysisEffect_raw : IInspectable {
	virtual STDMETHODIMP _get_HighDynamicRangeAnalyzer(HighDynamicRangeControl* *value);
	virtual STDMETHODIMP _put_DesiredAnalysisInterval(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_DesiredAnalysisInterval(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _add_SceneAnalyzed(Foundation::TypedEventHandler<SceneAnalysisEffect*, SceneAnalyzedEventArgs*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_SceneAnalyzed(Foundation::EventRegistrationToken cookie);
};
template<typename X> struct ISceneAnalysisEffect_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ISceneAnalysisEffect_adaptor::DesiredAnalysisInterval)->_get_DesiredAnalysisInterval(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ISceneAnalysisEffect_adaptor::DesiredAnalysisInterval)->_put_DesiredAnalysisInterval(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} DesiredAnalysisInterval;
		struct : property {
			ptr<HighDynamicRangeControl> get() { HighDynamicRangeControl* value; hrcheck(enc(&ISceneAnalysisEffect_adaptor::HighDynamicRangeAnalyzer)->_get_HighDynamicRangeAnalyzer(&value)); return from_abi(value); }
			ptr<HighDynamicRangeControl> operator()() { return get(); }
			operator ptr<HighDynamicRangeControl> () { return get(); }
			ptr<HighDynamicRangeControl> operator->() { return get(); }
		} HighDynamicRangeAnalyzer;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SceneAnalysisEffect>, ptr<SceneAnalyzedEventArgs>>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(enc(&ISceneAnalysisEffect_adaptor::SceneAnalyzed)->_add_SceneAnalyzed(to_abi(handler), &cookie)); return cookie; }
			void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(enc(&ISceneAnalysisEffect_adaptor::SceneAnalyzed)->_remove_SceneAnalyzed(cookie)); }
		} SceneAnalyzed;
	};
	ISceneAnalysisEffect_adaptor() {}
};
template<typename X> struct adapt<ISceneAnalysisEffect, X> : Windows::Media::Core::ISceneAnalysisEffect_adaptor<X> { typedef adapt ISceneAnalysisEffect; };
struct ISceneAnalysisEffect : ISceneAnalysisEffect_raw, generate<ISceneAnalysisEffect> {};

// SceneAnalysisEffect
template<typename X> struct statics<SceneAnalysisEffect, X> : X {
	typedef typename X::root_type SceneAnalysisEffect;
};
struct SceneAnalysisEffect : generate<SceneAnalysisEffect> {};

// ISceneAnalyzedEventArgs
struct ISceneAnalyzedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ResultFrame(SceneAnalysisEffectFrame* *value);
};
template<typename X> struct ISceneAnalyzedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<SceneAnalysisEffectFrame> get() { SceneAnalysisEffectFrame* value; hrcheck(enc(&ISceneAnalyzedEventArgs_adaptor::ResultFrame)->_get_ResultFrame(&value)); return from_abi(value); }
			ptr<SceneAnalysisEffectFrame> operator()() { return get(); }
			operator ptr<SceneAnalysisEffectFrame> () { return get(); }
			ptr<SceneAnalysisEffectFrame> operator->() { return get(); }
		} ResultFrame;
	};
	ISceneAnalyzedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISceneAnalyzedEventArgs, X> : Windows::Media::Core::ISceneAnalyzedEventArgs_adaptor<X> { typedef adapt ISceneAnalyzedEventArgs; };
struct ISceneAnalyzedEventArgs : ISceneAnalyzedEventArgs_raw, generate<ISceneAnalyzedEventArgs> {};

// SceneAnalyzedEventArgs
template<typename X> struct statics<SceneAnalyzedEventArgs, X> : X {
	typedef typename X::root_type SceneAnalyzedEventArgs;
};
struct SceneAnalyzedEventArgs : generate<SceneAnalyzedEventArgs> {};

// IHighDynamicRangeOutput
struct IHighDynamicRangeOutput_raw : IInspectable {
	virtual STDMETHODIMP _get_Certainty(double *value);
	virtual STDMETHODIMP _get_FrameControllers(Foundation::Collections::IVectorView<Devices::Core::FrameController*>* *value);
};
template<typename X> struct IHighDynamicRangeOutput_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IHighDynamicRangeOutput_adaptor::Certainty)->_get_Certainty(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} Certainty;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Devices::Core::FrameController>>> get() { Foundation::Collections::IVectorView<Devices::Core::FrameController*>* value; hrcheck(enc(&IHighDynamicRangeOutput_adaptor::FrameControllers)->_get_FrameControllers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Devices::Core::FrameController>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Devices::Core::FrameController>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Devices::Core::FrameController>>> operator->() { return get(); }
		} FrameControllers;
	};
	IHighDynamicRangeOutput_adaptor() {}
};
template<typename X> struct adapt<IHighDynamicRangeOutput, X> : Windows::Media::Core::IHighDynamicRangeOutput_adaptor<X> { typedef adapt IHighDynamicRangeOutput; };
struct IHighDynamicRangeOutput : IHighDynamicRangeOutput_raw, generate<IHighDynamicRangeOutput> {};

// HighDynamicRangeOutput
template<typename X> struct statics<HighDynamicRangeOutput, X> : X {
	typedef typename X::root_type HighDynamicRangeOutput;
};
struct HighDynamicRangeOutput : generate<HighDynamicRangeOutput> {};

// ISceneAnalysisEffectFrame
struct ISceneAnalysisEffectFrame_raw : IInspectable {
	virtual STDMETHODIMP _get_FrameControlValues(Capture::CapturedFrameControlValues* *value);
	virtual STDMETHODIMP _get_HighDynamicRange(HighDynamicRangeOutput* *value);
};
template<typename X> struct ISceneAnalysisEffectFrame_adaptor : X {
	union {
		struct : property {
			ptr<Capture::CapturedFrameControlValues> get() { Capture::CapturedFrameControlValues* value; hrcheck(enc(&ISceneAnalysisEffectFrame_adaptor::FrameControlValues)->_get_FrameControlValues(&value)); return from_abi(value); }
			ptr<Capture::CapturedFrameControlValues> operator()() { return get(); }
			operator ptr<Capture::CapturedFrameControlValues> () { return get(); }
			ptr<Capture::CapturedFrameControlValues> operator->() { return get(); }
		} FrameControlValues;
		struct : property {
			ptr<HighDynamicRangeOutput> get() { HighDynamicRangeOutput* value; hrcheck(enc(&ISceneAnalysisEffectFrame_adaptor::HighDynamicRange)->_get_HighDynamicRange(&value)); return from_abi(value); }
			ptr<HighDynamicRangeOutput> operator()() { return get(); }
			operator ptr<HighDynamicRangeOutput> () { return get(); }
			ptr<HighDynamicRangeOutput> operator->() { return get(); }
		} HighDynamicRange;
	};
	ISceneAnalysisEffectFrame_adaptor() {}
};
template<typename X> struct adapt<ISceneAnalysisEffectFrame, X> : Windows::Media::Core::ISceneAnalysisEffectFrame_adaptor<X> { typedef adapt ISceneAnalysisEffectFrame; };
struct ISceneAnalysisEffectFrame : ISceneAnalysisEffectFrame_raw, generate<ISceneAnalysisEffectFrame> {};

// ISceneAnalysisEffectFrame2
struct ISceneAnalysisEffectFrame2_raw : IInspectable {
	virtual STDMETHODIMP _get_AnalysisRecommendation(SceneAnalysisRecommendation *value);
};
template<typename X> struct ISceneAnalysisEffectFrame2_adaptor : X {
	union {
		struct : property {
			SceneAnalysisRecommendation get() { SceneAnalysisRecommendation value; hrcheck(enc(&ISceneAnalysisEffectFrame2_adaptor::AnalysisRecommendation)->_get_AnalysisRecommendation(&value)); return value; }
			SceneAnalysisRecommendation operator()() { return get(); }
			operator SceneAnalysisRecommendation () { return get(); }
		} AnalysisRecommendation;
	};
	ISceneAnalysisEffectFrame2_adaptor() {}
};
template<typename X> struct adapt<ISceneAnalysisEffectFrame2, X> : Windows::Media::Core::ISceneAnalysisEffectFrame2_adaptor<X> { typedef adapt ISceneAnalysisEffectFrame2; };
struct ISceneAnalysisEffectFrame2 : ISceneAnalysisEffectFrame2_raw, generate<ISceneAnalysisEffectFrame2> {};

// SceneAnalysisEffectFrame
template<typename X> struct statics<SceneAnalysisEffectFrame, X> : X {
	typedef typename X::root_type SceneAnalysisEffectFrame;
};
struct SceneAnalysisEffectFrame : generate<SceneAnalysisEffectFrame> {};

// SceneAnalysisEffectDefinition
template<typename X> struct statics<SceneAnalysisEffectDefinition, X> : X {
	typedef typename X::root_type SceneAnalysisEffectDefinition;
};
struct SceneAnalysisEffectDefinition : generate<SceneAnalysisEffectDefinition> {};

// IFaceDetectionEffectFrame
struct IFaceDetectionEffectFrame_raw : IInspectable {
	virtual STDMETHODIMP _get_DetectedFaces(Foundation::Collections::IVectorView<FaceAnalysis::DetectedFace*>* *value);
};
template<typename X> struct IFaceDetectionEffectFrame_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<FaceAnalysis::DetectedFace>>> get() { Foundation::Collections::IVectorView<FaceAnalysis::DetectedFace*>* value; hrcheck(enc(&IFaceDetectionEffectFrame_adaptor::DetectedFaces)->_get_DetectedFaces(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<FaceAnalysis::DetectedFace>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<FaceAnalysis::DetectedFace>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<FaceAnalysis::DetectedFace>>> operator->() { return get(); }
		} DetectedFaces;
	};
	IFaceDetectionEffectFrame_adaptor() {}
};
template<typename X> struct adapt<IFaceDetectionEffectFrame, X> : Windows::Media::Core::IFaceDetectionEffectFrame_adaptor<X> { typedef adapt IFaceDetectionEffectFrame; };
struct IFaceDetectionEffectFrame : IFaceDetectionEffectFrame_raw, generate<IFaceDetectionEffectFrame> {};

// FaceDetectionEffectFrame
template<typename X> struct statics<FaceDetectionEffectFrame, X> : X {
	typedef typename X::root_type FaceDetectionEffectFrame;
};
struct FaceDetectionEffectFrame : generate<FaceDetectionEffectFrame> {};

// IFaceDetectedEventArgs
struct IFaceDetectedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ResultFrame(FaceDetectionEffectFrame* *value);
};
template<typename X> struct IFaceDetectedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<FaceDetectionEffectFrame> get() { FaceDetectionEffectFrame* value; hrcheck(enc(&IFaceDetectedEventArgs_adaptor::ResultFrame)->_get_ResultFrame(&value)); return from_abi(value); }
			ptr<FaceDetectionEffectFrame> operator()() { return get(); }
			operator ptr<FaceDetectionEffectFrame> () { return get(); }
			ptr<FaceDetectionEffectFrame> operator->() { return get(); }
		} ResultFrame;
	};
	IFaceDetectedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IFaceDetectedEventArgs, X> : Windows::Media::Core::IFaceDetectedEventArgs_adaptor<X> { typedef adapt IFaceDetectedEventArgs; };
struct IFaceDetectedEventArgs : IFaceDetectedEventArgs_raw, generate<IFaceDetectedEventArgs> {};

// FaceDetectedEventArgs
template<typename X> struct statics<FaceDetectedEventArgs, X> : X {
	typedef typename X::root_type FaceDetectedEventArgs;
};
struct FaceDetectedEventArgs : generate<FaceDetectedEventArgs> {};

// IFaceDetectionEffect
struct IFaceDetectionEffect_raw : IInspectable {
	virtual STDMETHODIMP _put_Enabled(bool value);
	virtual STDMETHODIMP _get_Enabled(bool *value);
	virtual STDMETHODIMP _put_DesiredDetectionInterval(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_DesiredDetectionInterval(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _add_FaceDetected(Foundation::TypedEventHandler<FaceDetectionEffect*, FaceDetectedEventArgs*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_FaceDetected(Foundation::EventRegistrationToken cookie);
};
template<typename X> struct IFaceDetectionEffect_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IFaceDetectionEffect_adaptor::DesiredDetectionInterval)->_get_DesiredDetectionInterval(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IFaceDetectionEffect_adaptor::DesiredDetectionInterval)->_put_DesiredDetectionInterval(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} DesiredDetectionInterval;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFaceDetectionEffect_adaptor::Enabled)->_get_Enabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IFaceDetectionEffect_adaptor::Enabled)->_put_Enabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Enabled;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<FaceDetectionEffect>, ptr<FaceDetectedEventArgs>>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(enc(&IFaceDetectionEffect_adaptor::FaceDetected)->_add_FaceDetected(to_abi(handler), &cookie)); return cookie; }
			void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(enc(&IFaceDetectionEffect_adaptor::FaceDetected)->_remove_FaceDetected(cookie)); }
		} FaceDetected;
	};
	IFaceDetectionEffect_adaptor() {}
};
template<typename X> struct adapt<IFaceDetectionEffect, X> : Windows::Media::Core::IFaceDetectionEffect_adaptor<X> { typedef adapt IFaceDetectionEffect; };
struct IFaceDetectionEffect : IFaceDetectionEffect_raw, generate<IFaceDetectionEffect> {};

// FaceDetectionEffect
template<typename X> struct statics<FaceDetectionEffect, X> : X {
	typedef typename X::root_type FaceDetectionEffect;
};
struct FaceDetectionEffect : generate<FaceDetectionEffect> {};

// IFaceDetectionEffectDefinition
struct IFaceDetectionEffectDefinition_raw : IInspectable {
	virtual STDMETHODIMP _put_DetectionMode(FaceDetectionMode value);
	virtual STDMETHODIMP _get_DetectionMode(FaceDetectionMode *value);
	virtual STDMETHODIMP _put_SynchronousDetectionEnabled(bool value);
	virtual STDMETHODIMP _get_SynchronousDetectionEnabled(bool *value);
};
template<typename X> struct IFaceDetectionEffectDefinition_adaptor : X {
	union {
		struct : property {
			FaceDetectionMode get() { FaceDetectionMode value; hrcheck(enc(&IFaceDetectionEffectDefinition_adaptor::DetectionMode)->_get_DetectionMode(&value)); return value; }
			FaceDetectionMode operator()() { return get(); }
			operator FaceDetectionMode () { return get(); }
			void put(FaceDetectionMode value) { hrcheck(enc(&IFaceDetectionEffectDefinition_adaptor::DetectionMode)->_put_DetectionMode(value)); }
			void operator=(FaceDetectionMode value) { put(value); }
			void operator()(FaceDetectionMode value) { put(value); }
		} DetectionMode;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFaceDetectionEffectDefinition_adaptor::SynchronousDetectionEnabled)->_get_SynchronousDetectionEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IFaceDetectionEffectDefinition_adaptor::SynchronousDetectionEnabled)->_put_SynchronousDetectionEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} SynchronousDetectionEnabled;
	};
	IFaceDetectionEffectDefinition_adaptor() {}
};
template<typename X> struct adapt<IFaceDetectionEffectDefinition, X> : Windows::Media::Core::IFaceDetectionEffectDefinition_adaptor<X> { typedef adapt IFaceDetectionEffectDefinition; };
struct IFaceDetectionEffectDefinition : IFaceDetectionEffectDefinition_raw, generate<IFaceDetectionEffectDefinition> {};

// FaceDetectionEffectDefinition
template<typename X> struct statics<FaceDetectionEffectDefinition, X> : X {
	typedef typename X::root_type FaceDetectionEffectDefinition;
};
struct FaceDetectionEffectDefinition : generate<FaceDetectionEffectDefinition> {};

// IVideoStabilizationEffectEnabledChangedEventArgs
struct IVideoStabilizationEffectEnabledChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Reason(VideoStabilizationEffectEnabledChangedReason *value);
};
template<typename X> struct IVideoStabilizationEffectEnabledChangedEventArgs_adaptor : X {
	union {
		struct : property {
			VideoStabilizationEffectEnabledChangedReason get() { VideoStabilizationEffectEnabledChangedReason value; hrcheck(enc(&IVideoStabilizationEffectEnabledChangedEventArgs_adaptor::Reason)->_get_Reason(&value)); return value; }
			VideoStabilizationEffectEnabledChangedReason operator()() { return get(); }
			operator VideoStabilizationEffectEnabledChangedReason () { return get(); }
		} Reason;
	};
	IVideoStabilizationEffectEnabledChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IVideoStabilizationEffectEnabledChangedEventArgs, X> : Windows::Media::Core::IVideoStabilizationEffectEnabledChangedEventArgs_adaptor<X> { typedef adapt IVideoStabilizationEffectEnabledChangedEventArgs; };
struct IVideoStabilizationEffectEnabledChangedEventArgs : IVideoStabilizationEffectEnabledChangedEventArgs_raw, generate<IVideoStabilizationEffectEnabledChangedEventArgs> {};

// VideoStabilizationEffectEnabledChangedEventArgs
template<typename X> struct statics<VideoStabilizationEffectEnabledChangedEventArgs, X> : X {
	typedef typename X::root_type VideoStabilizationEffectEnabledChangedEventArgs;
};
struct VideoStabilizationEffectEnabledChangedEventArgs : generate<VideoStabilizationEffectEnabledChangedEventArgs> {};

// IVideoStabilizationEffect
struct IVideoStabilizationEffect_raw : IInspectable {
	virtual STDMETHODIMP _put_Enabled(bool value);
	virtual STDMETHODIMP _get_Enabled(bool *value);
	virtual STDMETHODIMP _add_EnabledChanged(Foundation::TypedEventHandler<VideoStabilizationEffect*, VideoStabilizationEffectEnabledChangedEventArgs*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_EnabledChanged(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _GetRecommendedStreamConfiguration(Devices::VideoDeviceController* controller, MediaProperties::VideoEncodingProperties* desiredProperties, Capture::VideoStreamConfiguration* *value);
};
template<typename X> struct IVideoStabilizationEffect_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVideoStabilizationEffect_adaptor::Enabled)->_get_Enabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVideoStabilizationEffect_adaptor::Enabled)->_put_Enabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Enabled;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<VideoStabilizationEffect>, ptr<VideoStabilizationEffectEnabledChangedEventArgs>>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(enc(&IVideoStabilizationEffect_adaptor::EnabledChanged)->_add_EnabledChanged(to_abi(handler), &cookie)); return cookie; }
			void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(enc(&IVideoStabilizationEffect_adaptor::EnabledChanged)->_remove_EnabledChanged(cookie)); }
		} EnabledChanged;
	};
	ptr<Capture::VideoStreamConfiguration> GetRecommendedStreamConfiguration(pptr<Devices::VideoDeviceController> controller, pptr<MediaProperties::VideoEncodingProperties> desiredProperties) { Capture::VideoStreamConfiguration* value; hrcheck(X::get()->_GetRecommendedStreamConfiguration(controller, desiredProperties, &value)); return from_abi(value); }
	IVideoStabilizationEffect_adaptor() {}
};
template<typename X> struct adapt<IVideoStabilizationEffect, X> : Windows::Media::Core::IVideoStabilizationEffect_adaptor<X> { typedef adapt IVideoStabilizationEffect; };
struct IVideoStabilizationEffect : IVideoStabilizationEffect_raw, generate<IVideoStabilizationEffect> {};

// VideoStabilizationEffect
template<typename X> struct statics<VideoStabilizationEffect, X> : X {
	typedef typename X::root_type VideoStabilizationEffect;
};
struct VideoStabilizationEffect : generate<VideoStabilizationEffect> {};

// VideoStabilizationEffectDefinition
template<typename X> struct statics<VideoStabilizationEffectDefinition, X> : X {
	typedef typename X::root_type VideoStabilizationEffectDefinition;
};
struct VideoStabilizationEffectDefinition : generate<VideoStabilizationEffectDefinition> {};

// IMediaSourceError
struct IMediaSourceError_raw : IInspectable {
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IMediaSourceError_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IMediaSourceError_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
	};
	IMediaSourceError_adaptor() {}
};
template<typename X> struct adapt<IMediaSourceError, X> : Windows::Media::Core::IMediaSourceError_adaptor<X> { typedef adapt IMediaSourceError; };
struct IMediaSourceError : IMediaSourceError_raw, generate<IMediaSourceError> {};

// IMediaSourceOpenOperationCompletedEventArgs
struct IMediaSourceOpenOperationCompletedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Error(MediaSourceError* *value);
};
template<typename X> struct IMediaSourceOpenOperationCompletedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<MediaSourceError> get() { MediaSourceError* value; hrcheck(enc(&IMediaSourceOpenOperationCompletedEventArgs_adaptor::Error)->_get_Error(&value)); return from_abi(value); }
			ptr<MediaSourceError> operator()() { return get(); }
			operator ptr<MediaSourceError> () { return get(); }
			ptr<MediaSourceError> operator->() { return get(); }
		} Error;
	};
	IMediaSourceOpenOperationCompletedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IMediaSourceOpenOperationCompletedEventArgs, X> : Windows::Media::Core::IMediaSourceOpenOperationCompletedEventArgs_adaptor<X> { typedef adapt IMediaSourceOpenOperationCompletedEventArgs; };
struct IMediaSourceOpenOperationCompletedEventArgs : IMediaSourceOpenOperationCompletedEventArgs_raw, generate<IMediaSourceOpenOperationCompletedEventArgs> {};

// MediaSourceError
template<typename X> struct statics<MediaSourceError, X> : X {
	typedef typename X::root_type MediaSourceError;
};
struct MediaSourceError : generate<MediaSourceError> {};

// IMediaSourceStateChangedEventArgs
struct IMediaSourceStateChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_OldState(MediaSourceState *value);
	virtual STDMETHODIMP _get_NewState(MediaSourceState *value);
};
template<typename X> struct IMediaSourceStateChangedEventArgs_adaptor : X {
	union {
		struct : property {
			MediaSourceState get() { MediaSourceState value; hrcheck(enc(&IMediaSourceStateChangedEventArgs_adaptor::NewState)->_get_NewState(&value)); return value; }
			MediaSourceState operator()() { return get(); }
			operator MediaSourceState () { return get(); }
		} NewState;
		struct : property {
			MediaSourceState get() { MediaSourceState value; hrcheck(enc(&IMediaSourceStateChangedEventArgs_adaptor::OldState)->_get_OldState(&value)); return value; }
			MediaSourceState operator()() { return get(); }
			operator MediaSourceState () { return get(); }
		} OldState;
	};
	IMediaSourceStateChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IMediaSourceStateChangedEventArgs, X> : Windows::Media::Core::IMediaSourceStateChangedEventArgs_adaptor<X> { typedef adapt IMediaSourceStateChangedEventArgs; };
struct IMediaSourceStateChangedEventArgs : IMediaSourceStateChangedEventArgs_raw, generate<IMediaSourceStateChangedEventArgs> {};

// IMediaSourceStatics
struct IMediaSourceStatics : IInspectable {
	virtual STDMETHODIMP _CreateFromAdaptiveMediaSource(Streaming::Adaptive::AdaptiveMediaSource* mediaSource, MediaSource* *result);
	virtual STDMETHODIMP _CreateFromMediaStreamSource(MediaStreamSource* mediaSource, MediaSource* *result);
	virtual STDMETHODIMP _CreateFromMseStreamSource(MseStreamSource* mediaSource, MediaSource* *result);
	virtual STDMETHODIMP _CreateFromIMediaSource(IMediaSource* mediaSource, MediaSource* *result);
	virtual STDMETHODIMP _CreateFromStorageFile(Storage::IStorageFile* file, MediaSource* *result);
	virtual STDMETHODIMP _CreateFromStream(Storage::Streams::IRandomAccessStream* stream, HSTRING contentType, MediaSource* *result);
	virtual STDMETHODIMP _CreateFromStreamReference(Storage::Streams::IRandomAccessStreamReference* stream, HSTRING contentType, MediaSource* *result);
	virtual STDMETHODIMP _CreateFromUri(Foundation::Uri* uri, MediaSource* *result);
};

// IMediaSourceStatics4
struct IMediaSourceStatics4 : IInspectable {
	virtual STDMETHODIMP _CreateFromDownloadOperation(Networking::BackgroundTransfer::DownloadOperation* downloadOperation, MediaSource* *result);
};

// IMediaSourceStatics3
struct IMediaSourceStatics3 : IInspectable {
	virtual STDMETHODIMP _CreateFromMediaFrameSource(Capture::Frames::MediaFrameSource* frameSource, MediaSource* *result);
};

// IMediaSourceStatics2
struct IMediaSourceStatics2 : IInspectable {
	virtual STDMETHODIMP _CreateFromMediaBinder(MediaBinder* binder, MediaSource* *result);
};

// IMediaSource5
struct IMediaSource5_raw : IInspectable {
	virtual STDMETHODIMP _get_DownloadOperation(Networking::BackgroundTransfer::DownloadOperation* *value);
};
template<typename X> struct IMediaSource5_adaptor : X {
	union {
		struct : property {
			ptr<Networking::BackgroundTransfer::DownloadOperation> get() { Networking::BackgroundTransfer::DownloadOperation* value; hrcheck(enc(&IMediaSource5_adaptor::DownloadOperation)->_get_DownloadOperation(&value)); return from_abi(value); }
			ptr<Networking::BackgroundTransfer::DownloadOperation> operator()() { return get(); }
			operator ptr<Networking::BackgroundTransfer::DownloadOperation> () { return get(); }
			ptr<Networking::BackgroundTransfer::DownloadOperation> operator->() { return get(); }
		} DownloadOperation;
	};
	IMediaSource5_adaptor() {}
};
template<typename X> struct adapt<IMediaSource5, X> : Windows::Media::Core::IMediaSource5_adaptor<X> { typedef adapt IMediaSource5; };
struct IMediaSource5 : IMediaSource5_raw, generate<IMediaSource5> {};

// IMediaSource2
struct IMediaSource2_raw : IInspectable {
	virtual STDMETHODIMP _add_OpenOperationCompleted(Foundation::TypedEventHandler<MediaSource*, MediaSourceOpenOperationCompletedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_OpenOperationCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_CustomProperties(Foundation::Collections::ValueSet* *value);
	virtual STDMETHODIMP _get_Duration(Foundation::IReference<Foundation::TimeSpan>* *value);
	virtual STDMETHODIMP _get_IsOpen(bool *value);
	virtual STDMETHODIMP _get_ExternalTimedTextSources(Foundation::Collections::IObservableVector<TimedTextSource*>* *value);
	virtual STDMETHODIMP _get_ExternalTimedMetadataTracks(Foundation::Collections::IObservableVector<TimedMetadataTrack*>* *value);
};
template<typename X> struct IMediaSource2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::ValueSet> get() { Foundation::Collections::ValueSet* value; hrcheck(enc(&IMediaSource2_adaptor::CustomProperties)->_get_CustomProperties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::ValueSet> operator()() { return get(); }
			operator ptr<Foundation::Collections::ValueSet> () { return get(); }
			ptr<Foundation::Collections::ValueSet> operator->() { return get(); }
		} CustomProperties;
		struct : property {
			ptr<Foundation::IReference<Foundation::TimeSpan>> get() { Foundation::IReference<Foundation::TimeSpan>* value; hrcheck(enc(&IMediaSource2_adaptor::Duration)->_get_Duration(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::TimeSpan>> () { return get(); }
			ptr<Foundation::IReference<Foundation::TimeSpan>> operator->() { return get(); }
		} Duration;
		struct : property {
			ptr<Foundation::Collections::IObservableVector<ptr<TimedMetadataTrack>>> get() { Foundation::Collections::IObservableVector<TimedMetadataTrack*>* value; hrcheck(enc(&IMediaSource2_adaptor::ExternalTimedMetadataTracks)->_get_ExternalTimedMetadataTracks(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IObservableVector<ptr<TimedMetadataTrack>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IObservableVector<ptr<TimedMetadataTrack>>> () { return get(); }
			ptr<Foundation::Collections::IObservableVector<ptr<TimedMetadataTrack>>> operator->() { return get(); }
		} ExternalTimedMetadataTracks;
		struct : property {
			ptr<Foundation::Collections::IObservableVector<ptr<TimedTextSource>>> get() { Foundation::Collections::IObservableVector<TimedTextSource*>* value; hrcheck(enc(&IMediaSource2_adaptor::ExternalTimedTextSources)->_get_ExternalTimedTextSources(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IObservableVector<ptr<TimedTextSource>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IObservableVector<ptr<TimedTextSource>>> () { return get(); }
			ptr<Foundation::Collections::IObservableVector<ptr<TimedTextSource>>> operator->() { return get(); }
		} ExternalTimedTextSources;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaSource2_adaptor::IsOpen)->_get_IsOpen(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsOpen;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaSource>, ptr<MediaSourceOpenOperationCompletedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaSource2_adaptor::OpenOperationCompleted)->_add_OpenOperationCompleted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaSource2_adaptor::OpenOperationCompleted)->_remove_OpenOperationCompleted(token)); }
		} OpenOperationCompleted;
	};
	IMediaSource2_adaptor() {}
};
template<typename X> struct adapt<IMediaSource2, X> : Windows::Media::Core::IMediaSource2_adaptor<X> { typedef adapt IMediaSource2; };
struct IMediaSource2 : IMediaSource2_raw, generate<IMediaSource2> {};

// IMediaSource3
struct IMediaSource3_raw : IInspectable {
	virtual STDMETHODIMP _add_StateChanged(Foundation::TypedEventHandler<MediaSource*, MediaSourceStateChangedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_StateChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_State(MediaSourceState *value);
	virtual STDMETHODIMP _Reset();
};
template<typename X> struct IMediaSource3_adaptor : X {
	union {
		struct : property {
			MediaSourceState get() { MediaSourceState value; hrcheck(enc(&IMediaSource3_adaptor::State)->_get_State(&value)); return value; }
			MediaSourceState operator()() { return get(); }
			operator MediaSourceState () { return get(); }
		} State;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaSource>, ptr<MediaSourceStateChangedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaSource3_adaptor::StateChanged)->_add_StateChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaSource3_adaptor::StateChanged)->_remove_StateChanged(token)); }
		} StateChanged;
	};
	void Reset() { hrcheck(X::get()->_Reset()); }
	IMediaSource3_adaptor() {}
};
template<typename X> struct adapt<IMediaSource3, X> : Windows::Media::Core::IMediaSource3_adaptor<X> { typedef adapt IMediaSource3; };
struct IMediaSource3 : IMediaSource3_raw, generate<IMediaSource3> {};

// IMediaSource4
struct IMediaSource4_raw : IInspectable {
	virtual STDMETHODIMP _get_AdaptiveMediaSource(Streaming::Adaptive::AdaptiveMediaSource* *value);
	virtual STDMETHODIMP _get_MediaStreamSource(Core::MediaStreamSource* *value);
	virtual STDMETHODIMP _get_MseStreamSource(Core::MseStreamSource* *value);
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value);
	virtual STDMETHODIMP _OpenAsync(Foundation::IAsyncAction* *operation);
};
template<typename X> struct IMediaSource4_adaptor : X {
	union {
		struct : property {
			ptr<Streaming::Adaptive::AdaptiveMediaSource> get() { Streaming::Adaptive::AdaptiveMediaSource* value; hrcheck(enc(&IMediaSource4_adaptor::AdaptiveMediaSource)->_get_AdaptiveMediaSource(&value)); return from_abi(value); }
			ptr<Streaming::Adaptive::AdaptiveMediaSource> operator()() { return get(); }
			operator ptr<Streaming::Adaptive::AdaptiveMediaSource> () { return get(); }
			ptr<Streaming::Adaptive::AdaptiveMediaSource> operator->() { return get(); }
		} AdaptiveMediaSource;
		struct : property {
			ptr<Core::MediaStreamSource> get() { Core::MediaStreamSource* value; hrcheck(enc(&IMediaSource4_adaptor::MediaStreamSource)->_get_MediaStreamSource(&value)); return from_abi(value); }
			ptr<Core::MediaStreamSource> operator()() { return get(); }
			operator ptr<Core::MediaStreamSource> () { return get(); }
			ptr<Core::MediaStreamSource> operator->() { return get(); }
		} MediaStreamSource;
		struct : property {
			ptr<Core::MseStreamSource> get() { Core::MseStreamSource* value; hrcheck(enc(&IMediaSource4_adaptor::MseStreamSource)->_get_MseStreamSource(&value)); return from_abi(value); }
			ptr<Core::MseStreamSource> operator()() { return get(); }
			operator ptr<Core::MseStreamSource> () { return get(); }
			ptr<Core::MseStreamSource> operator->() { return get(); }
		} MseStreamSource;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IMediaSource4_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
	};
	ptr<Foundation::IAsyncAction> OpenAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_OpenAsync(&operation)); return from_abi(operation); }
	IMediaSource4_adaptor() {}
};
template<typename X> struct adapt<IMediaSource4, X> : Windows::Media::Core::IMediaSource4_adaptor<X> { typedef adapt IMediaSource4; };
struct IMediaSource4 : IMediaSource4_raw, generate<IMediaSource4> {};

// MediaSource
template<typename> struct MediaSource_statics {
	static ptr<MediaSource> CreateFromDownloadOperation(pptr<Networking::BackgroundTransfer::DownloadOperation> downloadOperation) { MediaSource* result; hrcheck(get_activation_factory<MediaSource, IMediaSourceStatics4>()->_CreateFromDownloadOperation(downloadOperation, &result)); return from_abi(result); }
	static ptr<MediaSource> CreateFromMediaFrameSource(pptr<Capture::Frames::MediaFrameSource> frameSource) { MediaSource* result; hrcheck(get_activation_factory<MediaSource, IMediaSourceStatics3>()->_CreateFromMediaFrameSource(frameSource, &result)); return from_abi(result); }
	static ptr<MediaSource> CreateFromMediaBinder(pptr<MediaBinder> binder) { MediaSource* result; hrcheck(get_activation_factory<MediaSource, IMediaSourceStatics2>()->_CreateFromMediaBinder(binder, &result)); return from_abi(result); }
	static ptr<MediaSource> CreateFromAdaptiveMediaSource(pptr<Streaming::Adaptive::AdaptiveMediaSource> mediaSource) { MediaSource* result; hrcheck(get_activation_factory<MediaSource, IMediaSourceStatics>()->_CreateFromAdaptiveMediaSource(mediaSource, &result)); return from_abi(result); }
	static ptr<MediaSource> CreateFromMediaStreamSource(pptr<Core::MediaStreamSource> mediaSource) { MediaSource* result; hrcheck(get_activation_factory<MediaSource, IMediaSourceStatics>()->_CreateFromMediaStreamSource(mediaSource, &result)); return from_abi(result); }
	static ptr<MediaSource> CreateFromMseStreamSource(pptr<Core::MseStreamSource> mediaSource) { MediaSource* result; hrcheck(get_activation_factory<MediaSource, IMediaSourceStatics>()->_CreateFromMseStreamSource(mediaSource, &result)); return from_abi(result); }
	static ptr<MediaSource> CreateFromIMediaSource(pptr<IMediaSource> mediaSource) { MediaSource* result; hrcheck(get_activation_factory<MediaSource, IMediaSourceStatics>()->_CreateFromIMediaSource(mediaSource, &result)); return from_abi(result); }
	static ptr<MediaSource> CreateFromStorageFile(pptr<Storage::IStorageFile> file) { MediaSource* result; hrcheck(get_activation_factory<MediaSource, IMediaSourceStatics>()->_CreateFromStorageFile(file, &result)); return from_abi(result); }
	static ptr<MediaSource> CreateFromStream(pptr<Storage::Streams::IRandomAccessStream> stream, hstring_ref contentType) { MediaSource* result; hrcheck(get_activation_factory<MediaSource, IMediaSourceStatics>()->_CreateFromStream(stream, contentType, &result)); return from_abi(result); }
	static ptr<MediaSource> CreateFromStreamReference(pptr<Storage::Streams::IRandomAccessStreamReference> stream, hstring_ref contentType) { MediaSource* result; hrcheck(get_activation_factory<MediaSource, IMediaSourceStatics>()->_CreateFromStreamReference(stream, contentType, &result)); return from_abi(result); }
	static ptr<MediaSource> CreateFromUri(pptr<Foundation::Uri> uri) { MediaSource* result; hrcheck(get_activation_factory<MediaSource, IMediaSourceStatics>()->_CreateFromUri(uri, &result)); return from_abi(result); }
};

template<typename X> struct statics<MediaSource, X> : X, Windows::Media::Core::MediaSource_statics<void> {
	typedef typename X::root_type MediaSource;
};
struct MediaSource : generate<MediaSource> {};

// IMediaBinder
struct IMediaBinder_raw : IInspectable {
	virtual STDMETHODIMP _add_Binding(Foundation::TypedEventHandler<MediaBinder*, MediaBindingEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Binding(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_Token(HSTRING *value);
	virtual STDMETHODIMP _put_Token(HSTRING value);
	virtual STDMETHODIMP _get_Source(MediaSource* *value);
};
template<typename X> struct IMediaBinder_adaptor : X {
	union {
		struct : property {
			ptr<MediaSource> get() { MediaSource* value; hrcheck(enc(&IMediaBinder_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			ptr<MediaSource> operator()() { return get(); }
			operator ptr<MediaSource> () { return get(); }
			ptr<MediaSource> operator->() { return get(); }
		} Source;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMediaBinder_adaptor::Token)->_get_Token(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IMediaBinder_adaptor::Token)->_put_Token(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Token;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaBinder>, ptr<MediaBindingEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaBinder_adaptor::Binding)->_add_Binding(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaBinder_adaptor::Binding)->_remove_Binding(token)); }
		} Binding;
	};
	IMediaBinder_adaptor() {}
};
template<typename X> struct adapt<IMediaBinder, X> : Windows::Media::Core::IMediaBinder_adaptor<X> { typedef adapt IMediaBinder; };
struct IMediaBinder : IMediaBinder_raw, generate<IMediaBinder> {};

// MediaBinder
template<typename X> struct statics<MediaBinder, X> : X {
	typedef typename X::root_type MediaBinder;
};
struct MediaBinder : generate<MediaBinder> {};

// IMediaBindingEventArgs3
struct IMediaBindingEventArgs3_raw : IInspectable {
	virtual STDMETHODIMP _SetDownloadOperation(Networking::BackgroundTransfer::DownloadOperation* downloadOperation);
};
template<typename X> struct IMediaBindingEventArgs3_adaptor : X {
	void SetDownloadOperation(pptr<Networking::BackgroundTransfer::DownloadOperation> downloadOperation) { hrcheck(X::get()->_SetDownloadOperation(downloadOperation)); }
};
template<typename X> struct adapt<IMediaBindingEventArgs3, X> : Windows::Media::Core::IMediaBindingEventArgs3_adaptor<X> { typedef adapt IMediaBindingEventArgs3; };
struct IMediaBindingEventArgs3 : IMediaBindingEventArgs3_raw, generate<IMediaBindingEventArgs3> {};

// IMediaBindingEventArgs2
struct IMediaBindingEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _SetAdaptiveMediaSource(Streaming::Adaptive::AdaptiveMediaSource* mediaSource);
	virtual STDMETHODIMP _SetStorageFile(Storage::IStorageFile* file);
};
template<typename X> struct IMediaBindingEventArgs2_adaptor : X {
	void SetAdaptiveMediaSource(pptr<Streaming::Adaptive::AdaptiveMediaSource> mediaSource) { hrcheck(X::get()->_SetAdaptiveMediaSource(mediaSource)); }
	void SetStorageFile(pptr<Storage::IStorageFile> file) { hrcheck(X::get()->_SetStorageFile(file)); }
};
template<typename X> struct adapt<IMediaBindingEventArgs2, X> : Windows::Media::Core::IMediaBindingEventArgs2_adaptor<X> { typedef adapt IMediaBindingEventArgs2; };
struct IMediaBindingEventArgs2 : IMediaBindingEventArgs2_raw, generate<IMediaBindingEventArgs2> {};

// IMediaBindingEventArgs
struct IMediaBindingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _add_Canceled(Foundation::TypedEventHandler<MediaBindingEventArgs*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Canceled(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_MediaBinder(Core::MediaBinder* *value);
	virtual STDMETHODIMP _GetDeferral(Foundation::Deferral* *deferral);
	virtual STDMETHODIMP _SetUri(Foundation::Uri* uri);
	virtual STDMETHODIMP _SetStream(Storage::Streams::IRandomAccessStream* stream, HSTRING contentType);
	virtual STDMETHODIMP _SetStreamReference(Storage::Streams::IRandomAccessStreamReference* stream, HSTRING contentType);
};
template<typename X> struct IMediaBindingEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Core::MediaBinder> get() { Core::MediaBinder* value; hrcheck(enc(&IMediaBindingEventArgs_adaptor::MediaBinder)->_get_MediaBinder(&value)); return from_abi(value); }
			ptr<Core::MediaBinder> operator()() { return get(); }
			operator ptr<Core::MediaBinder> () { return get(); }
			ptr<Core::MediaBinder> operator->() { return get(); }
		} MediaBinder;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaBindingEventArgs>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaBindingEventArgs_adaptor::Canceled)->_add_Canceled(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaBindingEventArgs_adaptor::Canceled)->_remove_Canceled(token)); }
		} Canceled;
	};
	ptr<Foundation::Deferral> GetDeferral() { Foundation::Deferral* deferral; hrcheck(X::get()->_GetDeferral(&deferral)); return from_abi(deferral); }
	void SetUri(pptr<Foundation::Uri> uri) { hrcheck(X::get()->_SetUri(uri)); }
	void SetStream(pptr<Storage::Streams::IRandomAccessStream> stream, hstring_ref contentType) { hrcheck(X::get()->_SetStream(stream, contentType)); }
	void SetStreamReference(pptr<Storage::Streams::IRandomAccessStreamReference> stream, hstring_ref contentType) { hrcheck(X::get()->_SetStreamReference(stream, contentType)); }
	IMediaBindingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IMediaBindingEventArgs, X> : Windows::Media::Core::IMediaBindingEventArgs_adaptor<X> { typedef adapt IMediaBindingEventArgs; };
struct IMediaBindingEventArgs : IMediaBindingEventArgs_raw, generate<IMediaBindingEventArgs> {};

// MediaBindingEventArgs
template<typename X> struct statics<MediaBindingEventArgs, X> : X {
	typedef typename X::root_type MediaBindingEventArgs;
};
struct MediaBindingEventArgs : generate<MediaBindingEventArgs> {};

// MediaSourceOpenOperationCompletedEventArgs
template<typename X> struct statics<MediaSourceOpenOperationCompletedEventArgs, X> : X {
	typedef typename X::root_type MediaSourceOpenOperationCompletedEventArgs;
};
struct MediaSourceOpenOperationCompletedEventArgs : generate<MediaSourceOpenOperationCompletedEventArgs> {};

// ITimedTextSourceStatics2
struct ITimedTextSourceStatics2 : IInspectable {
	virtual STDMETHODIMP _CreateFromStreamWithIndex(Storage::Streams::IRandomAccessStream* stream, Storage::Streams::IRandomAccessStream* indexStream, TimedTextSource* *result);
	virtual STDMETHODIMP _CreateFromUriWithIndex(Foundation::Uri* uri, Foundation::Uri* indexUri, TimedTextSource* *result);
	virtual STDMETHODIMP _CreateFromStreamWithIndexAndLanguage(Storage::Streams::IRandomAccessStream* stream, Storage::Streams::IRandomAccessStream* indexStream, HSTRING defaultLanguage, TimedTextSource* *result);
	virtual STDMETHODIMP _CreateFromUriWithIndexAndLanguage(Foundation::Uri* uri, Foundation::Uri* indexUri, HSTRING defaultLanguage, TimedTextSource* *result);
};

// ITimedTextSourceStatics
struct ITimedTextSourceStatics : IInspectable {
	virtual STDMETHODIMP _CreateFromStream(Storage::Streams::IRandomAccessStream* stream, TimedTextSource* *value);
	virtual STDMETHODIMP _CreateFromUri(Foundation::Uri* uri, TimedTextSource* *value);
	virtual STDMETHODIMP _CreateFromStreamWithLanguage(Storage::Streams::IRandomAccessStream* stream, HSTRING defaultLanguage, TimedTextSource* *value);
	virtual STDMETHODIMP _CreateFromUriWithLanguage(Foundation::Uri* uri, HSTRING defaultLanguage, TimedTextSource* *value);
};

// ITimedTextSource
struct ITimedTextSource_raw : IInspectable {
	virtual STDMETHODIMP _add_Resolved(Foundation::TypedEventHandler<TimedTextSource*, TimedTextSourceResolveResultEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Resolved(Foundation::EventRegistrationToken token);
};
template<typename X> struct ITimedTextSource_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TimedTextSource>, ptr<TimedTextSourceResolveResultEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITimedTextSource_adaptor::Resolved)->_add_Resolved(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITimedTextSource_adaptor::Resolved)->_remove_Resolved(token)); }
		} Resolved;
	};
	ITimedTextSource_adaptor() {}
};
template<typename X> struct adapt<ITimedTextSource, X> : Windows::Media::Core::ITimedTextSource_adaptor<X> { typedef adapt ITimedTextSource; };
struct ITimedTextSource : ITimedTextSource_raw, generate<ITimedTextSource> {};

// TimedTextSource
template<typename> struct TimedTextSource_statics {
	static ptr<TimedTextSource> CreateFromStreamWithIndex(pptr<Storage::Streams::IRandomAccessStream> stream, pptr<Storage::Streams::IRandomAccessStream> indexStream) { TimedTextSource* result; hrcheck(get_activation_factory<TimedTextSource, ITimedTextSourceStatics2>()->_CreateFromStreamWithIndex(stream, indexStream, &result)); return from_abi(result); }
	static ptr<TimedTextSource> CreateFromUriWithIndex(pptr<Foundation::Uri> uri, pptr<Foundation::Uri> indexUri) { TimedTextSource* result; hrcheck(get_activation_factory<TimedTextSource, ITimedTextSourceStatics2>()->_CreateFromUriWithIndex(uri, indexUri, &result)); return from_abi(result); }
	static ptr<TimedTextSource> CreateFromStreamWithIndex(pptr<Storage::Streams::IRandomAccessStream> stream, pptr<Storage::Streams::IRandomAccessStream> indexStream, hstring_ref defaultLanguage) { TimedTextSource* result; hrcheck(get_activation_factory<TimedTextSource, ITimedTextSourceStatics2>()->_CreateFromStreamWithIndexAndLanguage(stream, indexStream, defaultLanguage, &result)); return from_abi(result); }
	static ptr<TimedTextSource> CreateFromUriWithIndex(pptr<Foundation::Uri> uri, pptr<Foundation::Uri> indexUri, hstring_ref defaultLanguage) { TimedTextSource* result; hrcheck(get_activation_factory<TimedTextSource, ITimedTextSourceStatics2>()->_CreateFromUriWithIndexAndLanguage(uri, indexUri, defaultLanguage, &result)); return from_abi(result); }
	static ptr<TimedTextSource> CreateFromStream(pptr<Storage::Streams::IRandomAccessStream> stream) { TimedTextSource* value; hrcheck(get_activation_factory<TimedTextSource, ITimedTextSourceStatics>()->_CreateFromStream(stream, &value)); return from_abi(value); }
	static ptr<TimedTextSource> CreateFromUri(pptr<Foundation::Uri> uri) { TimedTextSource* value; hrcheck(get_activation_factory<TimedTextSource, ITimedTextSourceStatics>()->_CreateFromUri(uri, &value)); return from_abi(value); }
	static ptr<TimedTextSource> CreateFromStream(pptr<Storage::Streams::IRandomAccessStream> stream, hstring_ref defaultLanguage) { TimedTextSource* value; hrcheck(get_activation_factory<TimedTextSource, ITimedTextSourceStatics>()->_CreateFromStreamWithLanguage(stream, defaultLanguage, &value)); return from_abi(value); }
	static ptr<TimedTextSource> CreateFromUri(pptr<Foundation::Uri> uri, hstring_ref defaultLanguage) { TimedTextSource* value; hrcheck(get_activation_factory<TimedTextSource, ITimedTextSourceStatics>()->_CreateFromUriWithLanguage(uri, defaultLanguage, &value)); return from_abi(value); }
};

template<typename X> struct statics<TimedTextSource, X> : X, Windows::Media::Core::TimedTextSource_statics<void> {
	typedef typename X::root_type TimedTextSource;
};
struct TimedTextSource : generate<TimedTextSource> {};

// ITimedMetadataTrackFactory
struct ITimedMetadataTrackFactory : IInspectable {
	virtual STDMETHODIMP _Create(HSTRING id, HSTRING language, TimedMetadataKind kind, TimedMetadataTrack* *value);
};

// IMediaTrack
struct IMediaTrack_raw : IInspectable {
	virtual STDMETHODIMP _get_Id(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_Language(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_TrackKind(MediaTrackKind *value) = 0;
	virtual STDMETHODIMP _put_Label(HSTRING value) = 0;
	virtual STDMETHODIMP _get_Label(HSTRING *value) = 0;
};
template<typename X> struct IMediaTrack_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMediaTrack_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMediaTrack_adaptor::Label)->_get_Label(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IMediaTrack_adaptor::Label)->_put_Label(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Label;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMediaTrack_adaptor::Language)->_get_Language(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Language;
		struct : property {
			MediaTrackKind get() { MediaTrackKind value; hrcheck(enc(&IMediaTrack_adaptor::TrackKind)->_get_TrackKind(&value)); return value; }
			MediaTrackKind operator()() { return get(); }
			operator MediaTrackKind () { return get(); }
		} TrackKind;
	};
	IMediaTrack_adaptor() {}
};
template<typename X> struct adapt<IMediaTrack, X> : Windows::Media::Core::IMediaTrack_adaptor<X> { typedef adapt IMediaTrack; };
template<typename X> struct IMediaTrack_unadaptor : X {
	STDMETHODIMP _get_Id(HSTRING *value) { return hrtry([&, this] { get_prop(value, Id); }); }
	STDMETHODIMP _get_Language(HSTRING *value) { return hrtry([&, this] { get_prop(value, Language); }); }
	STDMETHODIMP _get_TrackKind(MediaTrackKind *value) { return hrtry([&, this] { get_prop(value, TrackKind); }); }
	STDMETHODIMP _put_Label(HSTRING value) { return hrtry([&, this] { put_prop(value, Label); }); }
	STDMETHODIMP _get_Label(HSTRING *value) { return hrtry([&, this] { get_prop(value, Label); }); }
};
template<typename X> struct unadapt<IMediaTrack, X> : Windows::Media::Core::IMediaTrack_unadaptor<X> {};
struct IMediaTrack : IMediaTrack_raw, generate<IMediaTrack> {};

// ITimedMetadataTrack
struct ITimedMetadataTrack_raw : IInspectable {
	virtual STDMETHODIMP _add_CueEntered(Foundation::TypedEventHandler<TimedMetadataTrack*, MediaCueEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CueEntered(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_CueExited(Foundation::TypedEventHandler<TimedMetadataTrack*, MediaCueEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CueExited(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_TrackFailed(Foundation::TypedEventHandler<TimedMetadataTrack*, TimedMetadataTrackFailedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_TrackFailed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_Cues(Foundation::Collections::IVectorView<IMediaCue*>* *value);
	virtual STDMETHODIMP _get_ActiveCues(Foundation::Collections::IVectorView<IMediaCue*>* *value);
	virtual STDMETHODIMP _get_TimedMetadataKind(Core::TimedMetadataKind *value);
	virtual STDMETHODIMP _get_DispatchType(HSTRING *value);
	virtual STDMETHODIMP _AddCue(IMediaCue* cue);
	virtual STDMETHODIMP _RemoveCue(IMediaCue* cue);
};
template<typename X> struct ITimedMetadataTrack_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<IMediaCue>>> get() { Foundation::Collections::IVectorView<IMediaCue*>* value; hrcheck(enc(&ITimedMetadataTrack_adaptor::ActiveCues)->_get_ActiveCues(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<IMediaCue>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<IMediaCue>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<IMediaCue>>> operator->() { return get(); }
		} ActiveCues;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<IMediaCue>>> get() { Foundation::Collections::IVectorView<IMediaCue*>* value; hrcheck(enc(&ITimedMetadataTrack_adaptor::Cues)->_get_Cues(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<IMediaCue>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<IMediaCue>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<IMediaCue>>> operator->() { return get(); }
		} Cues;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITimedMetadataTrack_adaptor::DispatchType)->_get_DispatchType(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DispatchType;
		struct : property {
			Core::TimedMetadataKind get() { Core::TimedMetadataKind value; hrcheck(enc(&ITimedMetadataTrack_adaptor::TimedMetadataKind)->_get_TimedMetadataKind(&value)); return value; }
			Core::TimedMetadataKind operator()() { return get(); }
			operator Core::TimedMetadataKind () { return get(); }
		} TimedMetadataKind;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TimedMetadataTrack>, ptr<MediaCueEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITimedMetadataTrack_adaptor::CueEntered)->_add_CueEntered(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITimedMetadataTrack_adaptor::CueEntered)->_remove_CueEntered(token)); }
		} CueEntered;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TimedMetadataTrack>, ptr<MediaCueEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITimedMetadataTrack_adaptor::CueExited)->_add_CueExited(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITimedMetadataTrack_adaptor::CueExited)->_remove_CueExited(token)); }
		} CueExited;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TimedMetadataTrack>, ptr<TimedMetadataTrackFailedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITimedMetadataTrack_adaptor::TrackFailed)->_add_TrackFailed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITimedMetadataTrack_adaptor::TrackFailed)->_remove_TrackFailed(token)); }
		} TrackFailed;
	};
	void AddCue(pptr<IMediaCue> cue) { hrcheck(X::get()->_AddCue(cue)); }
	void RemoveCue(pptr<IMediaCue> cue) { hrcheck(X::get()->_RemoveCue(cue)); }
	ITimedMetadataTrack_adaptor() {}
};
template<typename X> struct adapt<ITimedMetadataTrack, X> : Windows::Media::Core::ITimedMetadataTrack_adaptor<X> { typedef adapt ITimedMetadataTrack; };
struct ITimedMetadataTrack : ITimedMetadataTrack_raw, generate<ITimedMetadataTrack> {};

// ITimedMetadataTrack2
struct ITimedMetadataTrack2_raw : IInspectable {
	virtual STDMETHODIMP _get_PlaybackItem(Playback::MediaPlaybackItem* *value);
	virtual STDMETHODIMP _get_Name(HSTRING *value);
};
template<typename X> struct ITimedMetadataTrack2_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITimedMetadataTrack2_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			ptr<Playback::MediaPlaybackItem> get() { Playback::MediaPlaybackItem* value; hrcheck(enc(&ITimedMetadataTrack2_adaptor::PlaybackItem)->_get_PlaybackItem(&value)); return from_abi(value); }
			ptr<Playback::MediaPlaybackItem> operator()() { return get(); }
			operator ptr<Playback::MediaPlaybackItem> () { return get(); }
			ptr<Playback::MediaPlaybackItem> operator->() { return get(); }
		} PlaybackItem;
	};
	ITimedMetadataTrack2_adaptor() {}
};
template<typename X> struct adapt<ITimedMetadataTrack2, X> : Windows::Media::Core::ITimedMetadataTrack2_adaptor<X> { typedef adapt ITimedMetadataTrack2; };
struct ITimedMetadataTrack2 : ITimedMetadataTrack2_raw, generate<ITimedMetadataTrack2> {};

// TimedMetadataTrack
template<typename> struct TimedMetadataTrack_statics {
	static TimedMetadataTrack *activate(hstring_ref id, hstring_ref language, Core::TimedMetadataKind kind) { TimedMetadataTrack *value; hrcheck(get_activation_factory<TimedMetadataTrack, ITimedMetadataTrackFactory>()->_Create(id, language, kind, &value)); return value; }
};

template<typename X> struct statics<TimedMetadataTrack, X> : X, Windows::Media::Core::TimedMetadataTrack_statics<void> {
	using Windows::Media::Core::TimedMetadataTrack_statics<void>::activate;
	typedef typename X::root_type TimedMetadataTrack;
};
struct TimedMetadataTrack : generate<TimedMetadataTrack> {};

// MediaSourceStateChangedEventArgs
template<typename X> struct statics<MediaSourceStateChangedEventArgs, X> : X {
	typedef typename X::root_type MediaSourceStateChangedEventArgs;
};
struct MediaSourceStateChangedEventArgs : generate<MediaSourceStateChangedEventArgs> {};

// ISingleSelectMediaTrackList
struct ISingleSelectMediaTrackList_raw : IInspectable {
	virtual STDMETHODIMP _add_SelectedIndexChanged(Foundation::TypedEventHandler<ISingleSelectMediaTrackList*, IInspectable*>* handler, Foundation::EventRegistrationToken *token) = 0;
	virtual STDMETHODIMP _remove_SelectedIndexChanged(Foundation::EventRegistrationToken token) = 0;
	virtual STDMETHODIMP _put_SelectedIndex(int value) = 0;
	virtual STDMETHODIMP _get_SelectedIndex(int *value) = 0;
};
template<typename X> struct ISingleSelectMediaTrackList_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&ISingleSelectMediaTrackList_adaptor::SelectedIndex)->_get_SelectedIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ISingleSelectMediaTrackList_adaptor::SelectedIndex)->_put_SelectedIndex(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} SelectedIndex;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ISingleSelectMediaTrackList>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISingleSelectMediaTrackList_adaptor::SelectedIndexChanged)->_add_SelectedIndexChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISingleSelectMediaTrackList_adaptor::SelectedIndexChanged)->_remove_SelectedIndexChanged(token)); }
		} SelectedIndexChanged;
	};
	ISingleSelectMediaTrackList_adaptor() {}
};
template<typename X> struct adapt<ISingleSelectMediaTrackList, X> : Windows::Media::Core::ISingleSelectMediaTrackList_adaptor<X> { typedef adapt ISingleSelectMediaTrackList; };
template<typename X> struct ISingleSelectMediaTrackList_unadaptor : X {
	STDMETHODIMP _add_SelectedIndexChanged(Foundation::TypedEventHandler<ISingleSelectMediaTrackList*, IInspectable*>* handler, Foundation::EventRegistrationToken *token) { return hrtry([&, this] { *token = X::get()->SelectedIndexChanged+=handler; }); }
	STDMETHODIMP _remove_SelectedIndexChanged(Foundation::EventRegistrationToken token) { return hrtry([&, this] { X::get()->SelectedIndexChanged-=token; }); }
	STDMETHODIMP _put_SelectedIndex(int value) { return hrtry([&, this] { put_prop(value, SelectedIndex); }); }
	STDMETHODIMP _get_SelectedIndex(int *value) { return hrtry([&, this] { get_prop(value, SelectedIndex); }); }
};
template<typename X> struct unadapt<ISingleSelectMediaTrackList, X> : Windows::Media::Core::ISingleSelectMediaTrackList_unadaptor<X> {};
struct ISingleSelectMediaTrackList : ISingleSelectMediaTrackList_raw, generate<ISingleSelectMediaTrackList> {};

// ITimedMetadataTrackError
struct ITimedMetadataTrackError_raw : IInspectable {
	virtual STDMETHODIMP _get_ErrorCode(TimedMetadataTrackErrorCode *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct ITimedMetadataTrackError_adaptor : X {
	union {
		struct : property {
			TimedMetadataTrackErrorCode get() { TimedMetadataTrackErrorCode value; hrcheck(enc(&ITimedMetadataTrackError_adaptor::ErrorCode)->_get_ErrorCode(&value)); return value; }
			TimedMetadataTrackErrorCode operator()() { return get(); }
			operator TimedMetadataTrackErrorCode () { return get(); }
		} ErrorCode;
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&ITimedMetadataTrackError_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
	};
	ITimedMetadataTrackError_adaptor() {}
};
template<typename X> struct adapt<ITimedMetadataTrackError, X> : Windows::Media::Core::ITimedMetadataTrackError_adaptor<X> { typedef adapt ITimedMetadataTrackError; };
struct ITimedMetadataTrackError : ITimedMetadataTrackError_raw, generate<ITimedMetadataTrackError> {};

// IMediaCueEventArgs
struct IMediaCueEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Cue(IMediaCue* *value);
};
template<typename X> struct IMediaCueEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<IMediaCue> get() { IMediaCue* value; hrcheck(enc(&IMediaCueEventArgs_adaptor::Cue)->_get_Cue(&value)); return from_abi(value); }
			ptr<IMediaCue> operator()() { return get(); }
			operator ptr<IMediaCue> () { return get(); }
			ptr<IMediaCue> operator->() { return get(); }
		} Cue;
	};
	IMediaCueEventArgs_adaptor() {}
};
template<typename X> struct adapt<IMediaCueEventArgs, X> : Windows::Media::Core::IMediaCueEventArgs_adaptor<X> { typedef adapt IMediaCueEventArgs; };
struct IMediaCueEventArgs : IMediaCueEventArgs_raw, generate<IMediaCueEventArgs> {};

// ITimedMetadataTrackFailedEventArgs
struct ITimedMetadataTrackFailedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Error(TimedMetadataTrackError* *value);
};
template<typename X> struct ITimedMetadataTrackFailedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<TimedMetadataTrackError> get() { TimedMetadataTrackError* value; hrcheck(enc(&ITimedMetadataTrackFailedEventArgs_adaptor::Error)->_get_Error(&value)); return from_abi(value); }
			ptr<TimedMetadataTrackError> operator()() { return get(); }
			operator ptr<TimedMetadataTrackError> () { return get(); }
			ptr<TimedMetadataTrackError> operator->() { return get(); }
		} Error;
	};
	ITimedMetadataTrackFailedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITimedMetadataTrackFailedEventArgs, X> : Windows::Media::Core::ITimedMetadataTrackFailedEventArgs_adaptor<X> { typedef adapt ITimedMetadataTrackFailedEventArgs; };
struct ITimedMetadataTrackFailedEventArgs : ITimedMetadataTrackFailedEventArgs_raw, generate<ITimedMetadataTrackFailedEventArgs> {};

// TimedMetadataTrackError
template<typename X> struct statics<TimedMetadataTrackError, X> : X {
	typedef typename X::root_type TimedMetadataTrackError;
};
struct TimedMetadataTrackError : generate<TimedMetadataTrackError> {};

// ITimedMetadataTrackProvider
struct ITimedMetadataTrackProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_TimedMetadataTracks(Foundation::Collections::IVectorView<TimedMetadataTrack*>* *value) = 0;
};
template<typename X> struct ITimedMetadataTrackProvider_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<TimedMetadataTrack>>> get() { Foundation::Collections::IVectorView<TimedMetadataTrack*>* value; hrcheck(enc(&ITimedMetadataTrackProvider_adaptor::TimedMetadataTracks)->_get_TimedMetadataTracks(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<TimedMetadataTrack>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<TimedMetadataTrack>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<TimedMetadataTrack>>> operator->() { return get(); }
		} TimedMetadataTracks;
	};
	ITimedMetadataTrackProvider_adaptor() {}
};
template<typename X> struct adapt<ITimedMetadataTrackProvider, X> : Windows::Media::Core::ITimedMetadataTrackProvider_adaptor<X> { typedef adapt ITimedMetadataTrackProvider; };
template<typename X> struct ITimedMetadataTrackProvider_unadaptor : X {
	STDMETHODIMP _get_TimedMetadataTracks(Foundation::Collections::IVectorView<TimedMetadataTrack*>* *value) { return hrtry([&, this] { get_prop(value, TimedMetadataTracks); }); }
};
template<typename X> struct unadapt<ITimedMetadataTrackProvider, X> : Windows::Media::Core::ITimedMetadataTrackProvider_unadaptor<X> {};
struct ITimedMetadataTrackProvider : ITimedMetadataTrackProvider_raw, generate<ITimedMetadataTrackProvider> {};

// MediaCueEventArgs
template<typename X> struct statics<MediaCueEventArgs, X> : X {
	typedef typename X::root_type MediaCueEventArgs;
};
struct MediaCueEventArgs : generate<MediaCueEventArgs> {};

// TimedMetadataTrackFailedEventArgs
template<typename X> struct statics<TimedMetadataTrackFailedEventArgs, X> : X {
	typedef typename X::root_type TimedMetadataTrackFailedEventArgs;
};
struct TimedMetadataTrackFailedEventArgs : generate<TimedMetadataTrackFailedEventArgs> {};

// ITimedTextSourceResolveResultEventArgs
struct ITimedTextSourceResolveResultEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Error(TimedMetadataTrackError* *value);
	virtual STDMETHODIMP _get_Tracks(Foundation::Collections::IVectorView<TimedMetadataTrack*>* *value);
};
template<typename X> struct ITimedTextSourceResolveResultEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<TimedMetadataTrackError> get() { TimedMetadataTrackError* value; hrcheck(enc(&ITimedTextSourceResolveResultEventArgs_adaptor::Error)->_get_Error(&value)); return from_abi(value); }
			ptr<TimedMetadataTrackError> operator()() { return get(); }
			operator ptr<TimedMetadataTrackError> () { return get(); }
			ptr<TimedMetadataTrackError> operator->() { return get(); }
		} Error;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<TimedMetadataTrack>>> get() { Foundation::Collections::IVectorView<TimedMetadataTrack*>* value; hrcheck(enc(&ITimedTextSourceResolveResultEventArgs_adaptor::Tracks)->_get_Tracks(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<TimedMetadataTrack>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<TimedMetadataTrack>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<TimedMetadataTrack>>> operator->() { return get(); }
		} Tracks;
	};
	ITimedTextSourceResolveResultEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITimedTextSourceResolveResultEventArgs, X> : Windows::Media::Core::ITimedTextSourceResolveResultEventArgs_adaptor<X> { typedef adapt ITimedTextSourceResolveResultEventArgs; };
struct ITimedTextSourceResolveResultEventArgs : ITimedTextSourceResolveResultEventArgs_raw, generate<ITimedTextSourceResolveResultEventArgs> {};

// TimedTextSourceResolveResultEventArgs
template<typename X> struct statics<TimedTextSourceResolveResultEventArgs, X> : X {
	typedef typename X::root_type TimedTextSourceResolveResultEventArgs;
};
struct TimedTextSourceResolveResultEventArgs : generate<TimedTextSourceResolveResultEventArgs> {};

// IVideoTrackSupportInfo
struct IVideoTrackSupportInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_DecoderStatus(MediaDecoderStatus *value);
	virtual STDMETHODIMP _get_MediaSourceStatus(Core::MediaSourceStatus *value);
};
template<typename X> struct IVideoTrackSupportInfo_adaptor : X {
	union {
		struct : property {
			MediaDecoderStatus get() { MediaDecoderStatus value; hrcheck(enc(&IVideoTrackSupportInfo_adaptor::DecoderStatus)->_get_DecoderStatus(&value)); return value; }
			MediaDecoderStatus operator()() { return get(); }
			operator MediaDecoderStatus () { return get(); }
		} DecoderStatus;
		struct : property {
			Core::MediaSourceStatus get() { Core::MediaSourceStatus value; hrcheck(enc(&IVideoTrackSupportInfo_adaptor::MediaSourceStatus)->_get_MediaSourceStatus(&value)); return value; }
			Core::MediaSourceStatus operator()() { return get(); }
			operator Core::MediaSourceStatus () { return get(); }
		} MediaSourceStatus;
	};
	IVideoTrackSupportInfo_adaptor() {}
};
template<typename X> struct adapt<IVideoTrackSupportInfo, X> : Windows::Media::Core::IVideoTrackSupportInfo_adaptor<X> { typedef adapt IVideoTrackSupportInfo; };
struct IVideoTrackSupportInfo : IVideoTrackSupportInfo_raw, generate<IVideoTrackSupportInfo> {};

// IAudioTrackSupportInfo
struct IAudioTrackSupportInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_DecoderStatus(MediaDecoderStatus *value);
	virtual STDMETHODIMP _get_Degradation(AudioDecoderDegradation *value);
	virtual STDMETHODIMP _get_DegradationReason(AudioDecoderDegradationReason *value);
	virtual STDMETHODIMP _get_MediaSourceStatus(Core::MediaSourceStatus *value);
};
template<typename X> struct IAudioTrackSupportInfo_adaptor : X {
	union {
		struct : property {
			MediaDecoderStatus get() { MediaDecoderStatus value; hrcheck(enc(&IAudioTrackSupportInfo_adaptor::DecoderStatus)->_get_DecoderStatus(&value)); return value; }
			MediaDecoderStatus operator()() { return get(); }
			operator MediaDecoderStatus () { return get(); }
		} DecoderStatus;
		struct : property {
			AudioDecoderDegradation get() { AudioDecoderDegradation value; hrcheck(enc(&IAudioTrackSupportInfo_adaptor::Degradation)->_get_Degradation(&value)); return value; }
			AudioDecoderDegradation operator()() { return get(); }
			operator AudioDecoderDegradation () { return get(); }
		} Degradation;
		struct : property {
			AudioDecoderDegradationReason get() { AudioDecoderDegradationReason value; hrcheck(enc(&IAudioTrackSupportInfo_adaptor::DegradationReason)->_get_DegradationReason(&value)); return value; }
			AudioDecoderDegradationReason operator()() { return get(); }
			operator AudioDecoderDegradationReason () { return get(); }
		} DegradationReason;
		struct : property {
			Core::MediaSourceStatus get() { Core::MediaSourceStatus value; hrcheck(enc(&IAudioTrackSupportInfo_adaptor::MediaSourceStatus)->_get_MediaSourceStatus(&value)); return value; }
			Core::MediaSourceStatus operator()() { return get(); }
			operator Core::MediaSourceStatus () { return get(); }
		} MediaSourceStatus;
	};
	IAudioTrackSupportInfo_adaptor() {}
};
template<typename X> struct adapt<IAudioTrackSupportInfo, X> : Windows::Media::Core::IAudioTrackSupportInfo_adaptor<X> { typedef adapt IAudioTrackSupportInfo; };
struct IAudioTrackSupportInfo : IAudioTrackSupportInfo_raw, generate<IAudioTrackSupportInfo> {};

// IVideoTrackOpenFailedEventArgs
struct IVideoTrackOpenFailedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IVideoTrackOpenFailedEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IVideoTrackOpenFailedEventArgs_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
	};
	IVideoTrackOpenFailedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IVideoTrackOpenFailedEventArgs, X> : Windows::Media::Core::IVideoTrackOpenFailedEventArgs_adaptor<X> { typedef adapt IVideoTrackOpenFailedEventArgs; };
struct IVideoTrackOpenFailedEventArgs : IVideoTrackOpenFailedEventArgs_raw, generate<IVideoTrackOpenFailedEventArgs> {};

// IAudioTrackOpenFailedEventArgs
struct IAudioTrackOpenFailedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IAudioTrackOpenFailedEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IAudioTrackOpenFailedEventArgs_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
	};
	IAudioTrackOpenFailedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IAudioTrackOpenFailedEventArgs, X> : Windows::Media::Core::IAudioTrackOpenFailedEventArgs_adaptor<X> { typedef adapt IAudioTrackOpenFailedEventArgs; };
struct IAudioTrackOpenFailedEventArgs : IAudioTrackOpenFailedEventArgs_raw, generate<IAudioTrackOpenFailedEventArgs> {};

// IVideoTrack
struct IVideoTrack_raw : IInspectable {
	virtual STDMETHODIMP _add_OpenFailed(Foundation::TypedEventHandler<VideoTrack*, VideoTrackOpenFailedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_OpenFailed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _GetEncodingProperties(MediaProperties::VideoEncodingProperties* *value);
	virtual STDMETHODIMP _get_PlaybackItem(Playback::MediaPlaybackItem* *value);
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_SupportInfo(VideoTrackSupportInfo* *value);
};
template<typename X> struct IVideoTrack_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVideoTrack_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			ptr<Playback::MediaPlaybackItem> get() { Playback::MediaPlaybackItem* value; hrcheck(enc(&IVideoTrack_adaptor::PlaybackItem)->_get_PlaybackItem(&value)); return from_abi(value); }
			ptr<Playback::MediaPlaybackItem> operator()() { return get(); }
			operator ptr<Playback::MediaPlaybackItem> () { return get(); }
			ptr<Playback::MediaPlaybackItem> operator->() { return get(); }
		} PlaybackItem;
		struct : property {
			ptr<VideoTrackSupportInfo> get() { VideoTrackSupportInfo* value; hrcheck(enc(&IVideoTrack_adaptor::SupportInfo)->_get_SupportInfo(&value)); return from_abi(value); }
			ptr<VideoTrackSupportInfo> operator()() { return get(); }
			operator ptr<VideoTrackSupportInfo> () { return get(); }
			ptr<VideoTrackSupportInfo> operator->() { return get(); }
		} SupportInfo;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<VideoTrack>, ptr<VideoTrackOpenFailedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IVideoTrack_adaptor::OpenFailed)->_add_OpenFailed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IVideoTrack_adaptor::OpenFailed)->_remove_OpenFailed(token)); }
		} OpenFailed;
	};
	ptr<MediaProperties::VideoEncodingProperties> GetEncodingProperties() { MediaProperties::VideoEncodingProperties* value; hrcheck(X::get()->_GetEncodingProperties(&value)); return from_abi(value); }
	IVideoTrack_adaptor() {}
};
template<typename X> struct adapt<IVideoTrack, X> : Windows::Media::Core::IVideoTrack_adaptor<X> { typedef adapt IVideoTrack; };
struct IVideoTrack : IVideoTrack_raw, generate<IVideoTrack> {};

// VideoTrack
template<typename X> struct statics<VideoTrack, X> : X {
	typedef typename X::root_type VideoTrack;
};
struct VideoTrack : generate<VideoTrack> {};

// VideoTrackOpenFailedEventArgs
template<typename X> struct statics<VideoTrackOpenFailedEventArgs, X> : X {
	typedef typename X::root_type VideoTrackOpenFailedEventArgs;
};
struct VideoTrackOpenFailedEventArgs : generate<VideoTrackOpenFailedEventArgs> {};

// VideoTrackSupportInfo
template<typename X> struct statics<VideoTrackSupportInfo, X> : X {
	typedef typename X::root_type VideoTrackSupportInfo;
};
struct VideoTrackSupportInfo : generate<VideoTrackSupportInfo> {};

// IAudioTrack
struct IAudioTrack_raw : IInspectable {
	virtual STDMETHODIMP _add_OpenFailed(Foundation::TypedEventHandler<AudioTrack*, AudioTrackOpenFailedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_OpenFailed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _GetEncodingProperties(MediaProperties::AudioEncodingProperties* *value);
	virtual STDMETHODIMP _get_PlaybackItem(Playback::MediaPlaybackItem* *value);
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_SupportInfo(AudioTrackSupportInfo* *value);
};
template<typename X> struct IAudioTrack_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAudioTrack_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			ptr<Playback::MediaPlaybackItem> get() { Playback::MediaPlaybackItem* value; hrcheck(enc(&IAudioTrack_adaptor::PlaybackItem)->_get_PlaybackItem(&value)); return from_abi(value); }
			ptr<Playback::MediaPlaybackItem> operator()() { return get(); }
			operator ptr<Playback::MediaPlaybackItem> () { return get(); }
			ptr<Playback::MediaPlaybackItem> operator->() { return get(); }
		} PlaybackItem;
		struct : property {
			ptr<AudioTrackSupportInfo> get() { AudioTrackSupportInfo* value; hrcheck(enc(&IAudioTrack_adaptor::SupportInfo)->_get_SupportInfo(&value)); return from_abi(value); }
			ptr<AudioTrackSupportInfo> operator()() { return get(); }
			operator ptr<AudioTrackSupportInfo> () { return get(); }
			ptr<AudioTrackSupportInfo> operator->() { return get(); }
		} SupportInfo;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AudioTrack>, ptr<AudioTrackOpenFailedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAudioTrack_adaptor::OpenFailed)->_add_OpenFailed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAudioTrack_adaptor::OpenFailed)->_remove_OpenFailed(token)); }
		} OpenFailed;
	};
	ptr<MediaProperties::AudioEncodingProperties> GetEncodingProperties() { MediaProperties::AudioEncodingProperties* value; hrcheck(X::get()->_GetEncodingProperties(&value)); return from_abi(value); }
	IAudioTrack_adaptor() {}
};
template<typename X> struct adapt<IAudioTrack, X> : Windows::Media::Core::IAudioTrack_adaptor<X> { typedef adapt IAudioTrack; };
struct IAudioTrack : IAudioTrack_raw, generate<IAudioTrack> {};

// AudioTrack
template<typename X> struct statics<AudioTrack, X> : X {
	typedef typename X::root_type AudioTrack;
};
struct AudioTrack : generate<AudioTrack> {};

// AudioTrackOpenFailedEventArgs
template<typename X> struct statics<AudioTrackOpenFailedEventArgs, X> : X {
	typedef typename X::root_type AudioTrackOpenFailedEventArgs;
};
struct AudioTrackOpenFailedEventArgs : generate<AudioTrackOpenFailedEventArgs> {};

// AudioTrackSupportInfo
template<typename X> struct statics<AudioTrackSupportInfo, X> : X {
	typedef typename X::root_type AudioTrackSupportInfo;
};
struct AudioTrackSupportInfo : generate<AudioTrackSupportInfo> {};
}}}
} // namespace iso_winrt
