#pragma once
// generated by isopod tools
// namespaces:
// Windows.Media.Editing

#include "Windows.Media.Editing.0.h"
#include "Windows.Media.Transcoding.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.UI.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename K, typename V> struct IMap;
template<typename T> struct IIterable;
template<typename T> struct IVector;
template<typename T> struct IVectorView;
}}
namespace Graphics { namespace DirectX { namespace Direct3D11 {
struct IDirect3DSurface;
}}
namespace Imaging {
struct ImageStream;
}}
namespace Media { namespace Core {
struct MediaStreamSource;
}
namespace Effects {
struct IVideoCompositorDefinition;
struct IAudioEffectDefinition;
struct IVideoEffectDefinition;
}
namespace MediaProperties {
struct MediaEncodingProfile;
struct AudioEncodingProperties;
struct VideoEncodingProperties;
}}
namespace Storage {
struct StorageFile;
struct IStorageFile;
}}

// defs

template<> struct def<Windows::Media::Editing::IMediaOverlayFactory> : interface_type<> {};
template<> struct def<Windows::Media::Editing::IMediaOverlay> : interface_type<> {};
template<> struct def<Windows::Media::Editing::MediaOverlay> : class_type<Platform::Object, Windows::Media::Editing::IMediaOverlay>, custom_activators {};
template<> struct def<Windows::Media::Editing::VideoFramePrecision> : enum_type<int> {};
template<> struct def<Windows::Media::Editing::MediaTrimmingPreference> : enum_type<int> {};
template<> struct def<Windows::Media::Editing::IMediaClip> : interface_type<> {};
template<> struct def<Windows::Media::Editing::IMediaClipStatics2> : interface_type<> {};
template<> struct def<Windows::Media::Editing::IMediaClipStatics> : interface_type<> {};
template<> struct def<Windows::Media::Editing::MediaClip> : class_type<Platform::Object, Windows::Media::Editing::IMediaClip> {};
template<> struct def<Windows::Media::Editing::IEmbeddedAudioTrack> : interface_type<> {};
template<> struct def<Windows::Media::Editing::EmbeddedAudioTrack> : class_type<Platform::Object, Windows::Media::Editing::IEmbeddedAudioTrack> {};
template<> struct def<Windows::Media::Editing::IMediaComposition> : interface_type<> {};
template<> struct def<Windows::Media::Editing::IBackgroundAudioTrackStatics> : interface_type<> {};
template<> struct def<Windows::Media::Editing::IBackgroundAudioTrack> : interface_type<> {};
template<> struct def<Windows::Media::Editing::BackgroundAudioTrack> : class_type<Platform::Object, Windows::Media::Editing::IBackgroundAudioTrack> {};
template<> struct def<Windows::Media::Editing::IMediaCompositionStatics> : interface_type<> {};
template<> struct def<Windows::Media::Editing::IMediaComposition2> : interface_type<> {};
template<> struct def<Windows::Media::Editing::MediaComposition> : class_type<Platform::Object, Windows::Media::Editing::IMediaComposition, Windows::Media::Editing::IMediaComposition2> {};
template<> struct def<Windows::Media::Editing::IMediaOverlayLayerFactory> : interface_type<> {};
template<> struct def<Windows::Media::Editing::IMediaOverlayLayer> : interface_type<> {};
template<> struct def<Windows::Media::Editing::MediaOverlayLayer> : class_type<Platform::Object, Windows::Media::Editing::IMediaOverlayLayer>, custom_activators {};

// uuids

template<> struct uuid<Windows::Media::Editing::IMediaOverlayFactory> { define_guid(0xB584828A, 0x6188, 0x4F8F, 0xA2, 0xE0, 0xAA, 0x55, 0x2D, 0x59, 0x8E, 0x18);};
template<> struct uuid<Windows::Media::Editing::IMediaOverlay> { define_guid(0xA902AE5D, 0x7869, 0x4830, 0x8A, 0xB1, 0x94, 0xDC, 0x1, 0xC0, 0x5F, 0xA4);};
template<> struct uuid<Windows::Media::Editing::IMediaClip> { define_guid(0x53F25366, 0x5FBA, 0x3EA4, 0x86, 0x93, 0x24, 0x76, 0x18, 0x11, 0x14, 0xA);};
template<> struct uuid<Windows::Media::Editing::IMediaClipStatics2> { define_guid(0x5B1DD7B3, 0x854E, 0x4D9B, 0x87, 0x7D, 0x47, 0x74, 0xA5, 0x56, 0xCD, 0x12);};
template<> struct uuid<Windows::Media::Editing::IMediaClipStatics> { define_guid(0xFA402B68, 0x928F, 0x43C4, 0xBC, 0x6E, 0x78, 0x3A, 0x1A, 0x35, 0x96, 0x56);};
template<> struct uuid<Windows::Media::Editing::IEmbeddedAudioTrack> { define_guid(0x55EE5A7A, 0x2D30, 0x3FBA, 0xA1, 0x90, 0x4F, 0x1A, 0x64, 0x54, 0xF8, 0x8F);};
template<> struct uuid<Windows::Media::Editing::IMediaComposition> { define_guid(0x2E06E605, 0xDC71, 0x41D6, 0xB8, 0x37, 0x2D, 0x2B, 0xC1, 0x4A, 0x29, 0x47);};
template<> struct uuid<Windows::Media::Editing::IBackgroundAudioTrackStatics> { define_guid(0xD9B1C0D7, 0xD018, 0x42A8, 0xA5, 0x59, 0xCB, 0x4D, 0x9E, 0x97, 0xE6, 0x64);};
template<> struct uuid<Windows::Media::Editing::IBackgroundAudioTrack> { define_guid(0x4B91B3BD, 0x9E21, 0x4266, 0xA9, 0xC2, 0x67, 0xDD, 0x1, 0x1A, 0x23, 0x57);};
template<> struct uuid<Windows::Media::Editing::IMediaCompositionStatics> { define_guid(0x87A08F04, 0xE32A, 0x45CE, 0x8F, 0x66, 0xA3, 0xD, 0xF0, 0x76, 0x62, 0x24);};
template<> struct uuid<Windows::Media::Editing::IMediaComposition2> { define_guid(0xA59E5372, 0x2366, 0x492C, 0xBE, 0xC8, 0xE6, 0xDF, 0xBA, 0x6D, 0x2, 0x81);};
template<> struct uuid<Windows::Media::Editing::IMediaOverlayLayerFactory> { define_guid(0x947CB473, 0xA39E, 0x4362, 0xAB, 0xBF, 0x9F, 0x8B, 0x50, 0x70, 0xA0, 0x62);};
template<> struct uuid<Windows::Media::Editing::IMediaOverlayLayer> { define_guid(0xA6D9BA57, 0xEEDA, 0x46C6, 0xBB, 0xE5, 0xE3, 0x98, 0xC8, 0x41, 0x68, 0xAC);};

// types

namespace Windows { namespace Media { namespace Editing {

// IMediaOverlayFactory
struct IMediaOverlayFactory : IInspectable {
	virtual STDMETHODIMP _Create(MediaClip* clip, MediaOverlay* *mediaOverlay);
	virtual STDMETHODIMP _CreateWithPositionAndOpacity(MediaClip* clip, Foundation::Rect position, double opacity, MediaOverlay* *mediaOverlay);
};

// IMediaOverlay
struct IMediaOverlay_raw : IInspectable {
	virtual STDMETHODIMP _get_Position(Foundation::Rect *value);
	virtual STDMETHODIMP _put_Position(Foundation::Rect value);
	virtual STDMETHODIMP _put_Delay(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_Delay(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_Opacity(double *value);
	virtual STDMETHODIMP _put_Opacity(double value);
	virtual STDMETHODIMP _Clone(MediaOverlay* *result);
	virtual STDMETHODIMP _get_Clip(MediaClip* *value);
	virtual STDMETHODIMP _get_AudioEnabled(bool *value);
	virtual STDMETHODIMP _put_AudioEnabled(bool value);
};
template<typename X> struct IMediaOverlay_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaOverlay_adaptor::AudioEnabled)->_get_AudioEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaOverlay_adaptor::AudioEnabled)->_put_AudioEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AudioEnabled;
		struct : property {
			ptr<MediaClip> get() { MediaClip* value; hrcheck(enc(&IMediaOverlay_adaptor::Clip)->_get_Clip(&value)); return from_abi(value); }
			ptr<MediaClip> operator()() { return get(); }
			operator ptr<MediaClip> () { return get(); }
			ptr<MediaClip> operator->() { return get(); }
		} Clip;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaOverlay_adaptor::Delay)->_get_Delay(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMediaOverlay_adaptor::Delay)->_put_Delay(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Delay;
		struct : property {
			double get() { double value; hrcheck(enc(&IMediaOverlay_adaptor::Opacity)->_get_Opacity(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IMediaOverlay_adaptor::Opacity)->_put_Opacity(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Opacity;
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&IMediaOverlay_adaptor::Position)->_get_Position(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
			void put(const Foundation::Rect& value) { hrcheck(enc(&IMediaOverlay_adaptor::Position)->_put_Position(value)); }
			void operator=(const Foundation::Rect& value) { put(value); }
			void operator()(const Foundation::Rect& value) { put(value); }
		} Position;
	};
	ptr<MediaOverlay> Clone() { MediaOverlay* result; hrcheck(X::get()->_Clone(&result)); return from_abi(result); }
	IMediaOverlay_adaptor() {}
};
template<typename X> struct adapt<IMediaOverlay, X> : Windows::Media::Editing::IMediaOverlay_adaptor<X> { typedef adapt IMediaOverlay; };
struct IMediaOverlay : IMediaOverlay_raw, generate<IMediaOverlay> {};

// MediaOverlay
template<typename> struct MediaOverlay_statics {
	static MediaOverlay *activate(pptr<MediaClip> clip) { MediaOverlay *mediaOverlay; hrcheck(get_activation_factory<MediaOverlay, IMediaOverlayFactory>()->_Create(clip, &mediaOverlay)); return mediaOverlay; }
	static MediaOverlay *activate(pptr<MediaClip> clip, const Foundation::Rect& position, double opacity) { MediaOverlay *mediaOverlay; hrcheck(get_activation_factory<MediaOverlay, IMediaOverlayFactory>()->_CreateWithPositionAndOpacity(clip, position, opacity, &mediaOverlay)); return mediaOverlay; }
};

template<typename X> struct statics<MediaOverlay, X> : X, Windows::Media::Editing::MediaOverlay_statics<void> {
	using Windows::Media::Editing::MediaOverlay_statics<void>::activate;
	typedef typename X::root_type MediaOverlay;
};
struct MediaOverlay : generate<MediaOverlay> {};

// IMediaClip
struct IMediaClip_raw : IInspectable {
	virtual STDMETHODIMP _get_TrimTimeFromStart(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_TrimTimeFromStart(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_TrimTimeFromEnd(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_TrimTimeFromEnd(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_OriginalDuration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_TrimmedDuration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_UserData(Foundation::Collections::IMap<HSTRING, HSTRING>* *value);
	virtual STDMETHODIMP _Clone(MediaClip* *result);
	virtual STDMETHODIMP _get_StartTimeInComposition(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_EndTimeInComposition(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_EmbeddedAudioTracks(Foundation::Collections::IVectorView<EmbeddedAudioTrack*>* *value);
	virtual STDMETHODIMP _get_SelectedEmbeddedAudioTrackIndex(unsigned *value);
	virtual STDMETHODIMP _put_SelectedEmbeddedAudioTrackIndex(unsigned value);
	virtual STDMETHODIMP _put_Volume(double value);
	virtual STDMETHODIMP _get_Volume(double *value);
	virtual STDMETHODIMP _GetVideoEncodingProperties(MediaProperties::VideoEncodingProperties* *value);
	virtual STDMETHODIMP _get_AudioEffectDefinitions(Foundation::Collections::IVector<Effects::IAudioEffectDefinition*>* *value);
	virtual STDMETHODIMP _get_VideoEffectDefinitions(Foundation::Collections::IVector<Effects::IVideoEffectDefinition*>* *value);
};
template<typename X> struct IMediaClip_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Effects::IAudioEffectDefinition>>> get() { Foundation::Collections::IVector<Effects::IAudioEffectDefinition*>* value; hrcheck(enc(&IMediaClip_adaptor::AudioEffectDefinitions)->_get_AudioEffectDefinitions(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Effects::IAudioEffectDefinition>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Effects::IAudioEffectDefinition>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Effects::IAudioEffectDefinition>>> operator->() { return get(); }
		} AudioEffectDefinitions;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<EmbeddedAudioTrack>>> get() { Foundation::Collections::IVectorView<EmbeddedAudioTrack*>* value; hrcheck(enc(&IMediaClip_adaptor::EmbeddedAudioTracks)->_get_EmbeddedAudioTracks(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<EmbeddedAudioTrack>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<EmbeddedAudioTrack>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<EmbeddedAudioTrack>>> operator->() { return get(); }
		} EmbeddedAudioTracks;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaClip_adaptor::EndTimeInComposition)->_get_EndTimeInComposition(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} EndTimeInComposition;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaClip_adaptor::OriginalDuration)->_get_OriginalDuration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} OriginalDuration;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IMediaClip_adaptor::SelectedEmbeddedAudioTrackIndex)->_get_SelectedEmbeddedAudioTrackIndex(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IMediaClip_adaptor::SelectedEmbeddedAudioTrackIndex)->_put_SelectedEmbeddedAudioTrackIndex(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} SelectedEmbeddedAudioTrackIndex;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaClip_adaptor::StartTimeInComposition)->_get_StartTimeInComposition(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} StartTimeInComposition;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaClip_adaptor::TrimTimeFromEnd)->_get_TrimTimeFromEnd(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMediaClip_adaptor::TrimTimeFromEnd)->_put_TrimTimeFromEnd(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} TrimTimeFromEnd;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaClip_adaptor::TrimTimeFromStart)->_get_TrimTimeFromStart(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMediaClip_adaptor::TrimTimeFromStart)->_put_TrimTimeFromStart(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} TrimTimeFromStart;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaClip_adaptor::TrimmedDuration)->_get_TrimmedDuration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} TrimmedDuration;
		struct : property {
			ptr<Foundation::Collections::IMap<hstring, hstring>> get() { Foundation::Collections::IMap<HSTRING, HSTRING>* value; hrcheck(enc(&IMediaClip_adaptor::UserData)->_get_UserData(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMap<hstring, hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMap<hstring, hstring>> () { return get(); }
			ptr<Foundation::Collections::IMap<hstring, hstring>> operator->() { return get(); }
		} UserData;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Effects::IVideoEffectDefinition>>> get() { Foundation::Collections::IVector<Effects::IVideoEffectDefinition*>* value; hrcheck(enc(&IMediaClip_adaptor::VideoEffectDefinitions)->_get_VideoEffectDefinitions(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Effects::IVideoEffectDefinition>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Effects::IVideoEffectDefinition>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Effects::IVideoEffectDefinition>>> operator->() { return get(); }
		} VideoEffectDefinitions;
		struct : property {
			double get() { double value; hrcheck(enc(&IMediaClip_adaptor::Volume)->_get_Volume(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IMediaClip_adaptor::Volume)->_put_Volume(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Volume;
	};
	ptr<MediaClip> Clone() { MediaClip* result; hrcheck(X::get()->_Clone(&result)); return from_abi(result); }
	ptr<MediaProperties::VideoEncodingProperties> GetVideoEncodingProperties() { MediaProperties::VideoEncodingProperties* value; hrcheck(X::get()->_GetVideoEncodingProperties(&value)); return from_abi(value); }
	IMediaClip_adaptor() {}
};
template<typename X> struct adapt<IMediaClip, X> : Windows::Media::Editing::IMediaClip_adaptor<X> { typedef adapt IMediaClip; };
struct IMediaClip : IMediaClip_raw, generate<IMediaClip> {};

// IMediaClipStatics2
struct IMediaClipStatics2 : IInspectable {
	virtual STDMETHODIMP _CreateFromSurface(Graphics::DirectX::Direct3D11::IDirect3DSurface* surface, Foundation::TimeSpan originalDuration, MediaClip* *value);
};

// IMediaClipStatics
struct IMediaClipStatics : IInspectable {
	virtual STDMETHODIMP _CreateFromColor(UI::Color color, Foundation::TimeSpan originalDuration, MediaClip* *value);
	virtual STDMETHODIMP _CreateFromFileAsync(Storage::IStorageFile* file, Foundation::IAsyncOperation<MediaClip*>* *operation);
	virtual STDMETHODIMP _CreateFromImageFileAsync(Storage::IStorageFile* file, Foundation::TimeSpan originalDuration, Foundation::IAsyncOperation<MediaClip*>* *operation);
};

// MediaClip
template<typename> struct MediaClip_statics {
	static ptr<MediaClip> CreateFromSurface(pptr<Graphics::DirectX::Direct3D11::IDirect3DSurface> surface, const Foundation::TimeSpan& originalDuration) { MediaClip* value; hrcheck(get_activation_factory<MediaClip, IMediaClipStatics2>()->_CreateFromSurface(surface, originalDuration, &value)); return from_abi(value); }
	static ptr<MediaClip> CreateFromColor(const UI::Color& color, const Foundation::TimeSpan& originalDuration) { MediaClip* value; hrcheck(get_activation_factory<MediaClip, IMediaClipStatics>()->_CreateFromColor(color, originalDuration, &value)); return from_abi(value); }
	static ptr<Foundation::IAsyncOperation<ptr<MediaClip>>> CreateFromFileAsync(pptr<Storage::IStorageFile> file) { Foundation::IAsyncOperation<MediaClip*>* operation; hrcheck(get_activation_factory<MediaClip, IMediaClipStatics>()->_CreateFromFileAsync(file, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<MediaClip>>> CreateFromImageFileAsync(pptr<Storage::IStorageFile> file, const Foundation::TimeSpan& originalDuration) { Foundation::IAsyncOperation<MediaClip*>* operation; hrcheck(get_activation_factory<MediaClip, IMediaClipStatics>()->_CreateFromImageFileAsync(file, originalDuration, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<MediaClip, X> : X, Windows::Media::Editing::MediaClip_statics<void> {
	typedef typename X::root_type MediaClip;
};
struct MediaClip : generate<MediaClip> {};

// IEmbeddedAudioTrack
struct IEmbeddedAudioTrack_raw : IInspectable {
	virtual STDMETHODIMP _GetAudioEncodingProperties(MediaProperties::AudioEncodingProperties* *value);
};
template<typename X> struct IEmbeddedAudioTrack_adaptor : X {
	ptr<MediaProperties::AudioEncodingProperties> GetAudioEncodingProperties() { MediaProperties::AudioEncodingProperties* value; hrcheck(X::get()->_GetAudioEncodingProperties(&value)); return from_abi(value); }
};
template<typename X> struct adapt<IEmbeddedAudioTrack, X> : Windows::Media::Editing::IEmbeddedAudioTrack_adaptor<X> { typedef adapt IEmbeddedAudioTrack; };
struct IEmbeddedAudioTrack : IEmbeddedAudioTrack_raw, generate<IEmbeddedAudioTrack> {};

// EmbeddedAudioTrack
template<typename X> struct statics<EmbeddedAudioTrack, X> : X {
	typedef typename X::root_type EmbeddedAudioTrack;
};
struct EmbeddedAudioTrack : generate<EmbeddedAudioTrack> {};

// IMediaComposition
struct IMediaComposition_raw : IInspectable {
	virtual STDMETHODIMP _get_Duration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_Clips(Foundation::Collections::IVector<MediaClip*>* *value);
	virtual STDMETHODIMP _get_BackgroundAudioTracks(Foundation::Collections::IVector<BackgroundAudioTrack*>* *value);
	virtual STDMETHODIMP _get_UserData(Foundation::Collections::IMap<HSTRING, HSTRING>* *value);
	virtual STDMETHODIMP _Clone(MediaComposition* *result);
	virtual STDMETHODIMP _SaveAsync(Storage::IStorageFile* file, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _GetThumbnailAsync(Foundation::TimeSpan timeFromStart, int scaledWidth, int scaledHeight, VideoFramePrecision framePrecision, Foundation::IAsyncOperation<Graphics::Imaging::ImageStream*>* *operation);
	virtual STDMETHODIMP _GetThumbnailsAsync(Foundation::Collections::IIterable<Foundation::TimeSpan>* timesFromStart, int scaledWidth, int scaledHeight, VideoFramePrecision framePrecision, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Graphics::Imaging::ImageStream*>*>* *operation);
	virtual STDMETHODIMP _RenderToFileAsync(Storage::IStorageFile* destination, Foundation::IAsyncOperationWithProgress<Transcoding::TranscodeFailureReason, double>* *operation);
	virtual STDMETHODIMP _RenderToFileWithTrimmingPreferenceAsync(Storage::IStorageFile* destination, MediaTrimmingPreference trimmingPreference, Foundation::IAsyncOperationWithProgress<Transcoding::TranscodeFailureReason, double>* *operation);
	virtual STDMETHODIMP _RenderToFileWithProfileAsync(Storage::IStorageFile* destination, MediaTrimmingPreference trimmingPreference, MediaProperties::MediaEncodingProfile* encodingProfile, Foundation::IAsyncOperationWithProgress<Transcoding::TranscodeFailureReason, double>* *operation);
	virtual STDMETHODIMP _CreateDefaultEncodingProfile(MediaProperties::MediaEncodingProfile* *value);
	virtual STDMETHODIMP _GenerateMediaStreamSource(Core::MediaStreamSource* *value);
	virtual STDMETHODIMP _GenerateMediaStreamSourceWithProfile(MediaProperties::MediaEncodingProfile* encodingProfile, Core::MediaStreamSource* *value);
	virtual STDMETHODIMP _GeneratePreviewMediaStreamSource(int scaledWidth, int scaledHeight, Core::MediaStreamSource* *value);
};
template<typename X> struct IMediaComposition_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<BackgroundAudioTrack>>> get() { Foundation::Collections::IVector<BackgroundAudioTrack*>* value; hrcheck(enc(&IMediaComposition_adaptor::BackgroundAudioTracks)->_get_BackgroundAudioTracks(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<BackgroundAudioTrack>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<BackgroundAudioTrack>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<BackgroundAudioTrack>>> operator->() { return get(); }
		} BackgroundAudioTracks;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<MediaClip>>> get() { Foundation::Collections::IVector<MediaClip*>* value; hrcheck(enc(&IMediaComposition_adaptor::Clips)->_get_Clips(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<MediaClip>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<MediaClip>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<MediaClip>>> operator->() { return get(); }
		} Clips;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaComposition_adaptor::Duration)->_get_Duration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} Duration;
		struct : property {
			ptr<Foundation::Collections::IMap<hstring, hstring>> get() { Foundation::Collections::IMap<HSTRING, HSTRING>* value; hrcheck(enc(&IMediaComposition_adaptor::UserData)->_get_UserData(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMap<hstring, hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMap<hstring, hstring>> () { return get(); }
			ptr<Foundation::Collections::IMap<hstring, hstring>> operator->() { return get(); }
		} UserData;
	};
	ptr<MediaComposition> Clone() { MediaComposition* result; hrcheck(X::get()->_Clone(&result)); return from_abi(result); }
	ptr<Foundation::IAsyncAction> SaveAsync(pptr<Storage::IStorageFile> file) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_SaveAsync(file, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Graphics::Imaging::ImageStream>>> GetThumbnailAsync(const Foundation::TimeSpan& timeFromStart, int scaledWidth, int scaledHeight, VideoFramePrecision framePrecision) { Foundation::IAsyncOperation<Graphics::Imaging::ImageStream*>* operation; hrcheck(X::get()->_GetThumbnailAsync(timeFromStart, scaledWidth, scaledHeight, framePrecision, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<Graphics::Imaging::ImageStream>>>>> GetThumbnailsAsync(pptr<Foundation::Collections::IIterable<Foundation::TimeSpan>> timesFromStart, int scaledWidth, int scaledHeight, VideoFramePrecision framePrecision) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Graphics::Imaging::ImageStream*>*>* operation; hrcheck(X::get()->_GetThumbnailsAsync(to_abi(timesFromStart), scaledWidth, scaledHeight, framePrecision, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<Transcoding::TranscodeFailureReason, double>> RenderToFileAsync(pptr<Storage::IStorageFile> destination) { Foundation::IAsyncOperationWithProgress<Transcoding::TranscodeFailureReason, double>* operation; hrcheck(X::get()->_RenderToFileAsync(destination, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<Transcoding::TranscodeFailureReason, double>> RenderToFileAsync(pptr<Storage::IStorageFile> destination, MediaTrimmingPreference trimmingPreference) { Foundation::IAsyncOperationWithProgress<Transcoding::TranscodeFailureReason, double>* operation; hrcheck(X::get()->_RenderToFileWithTrimmingPreferenceAsync(destination, trimmingPreference, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<Transcoding::TranscodeFailureReason, double>> RenderToFileAsync(pptr<Storage::IStorageFile> destination, MediaTrimmingPreference trimmingPreference, pptr<MediaProperties::MediaEncodingProfile> encodingProfile) { Foundation::IAsyncOperationWithProgress<Transcoding::TranscodeFailureReason, double>* operation; hrcheck(X::get()->_RenderToFileWithProfileAsync(destination, trimmingPreference, encodingProfile, &operation)); return from_abi(operation); }
	ptr<MediaProperties::MediaEncodingProfile> CreateDefaultEncodingProfile() { MediaProperties::MediaEncodingProfile* value; hrcheck(X::get()->_CreateDefaultEncodingProfile(&value)); return from_abi(value); }
	ptr<Core::MediaStreamSource> GenerateMediaStreamSource() { Core::MediaStreamSource* value; hrcheck(X::get()->_GenerateMediaStreamSource(&value)); return from_abi(value); }
	ptr<Core::MediaStreamSource> GenerateMediaStreamSource(pptr<MediaProperties::MediaEncodingProfile> encodingProfile) { Core::MediaStreamSource* value; hrcheck(X::get()->_GenerateMediaStreamSourceWithProfile(encodingProfile, &value)); return from_abi(value); }
	ptr<Core::MediaStreamSource> GeneratePreviewMediaStreamSource(int scaledWidth, int scaledHeight) { Core::MediaStreamSource* value; hrcheck(X::get()->_GeneratePreviewMediaStreamSource(scaledWidth, scaledHeight, &value)); return from_abi(value); }
	IMediaComposition_adaptor() {}
};
template<typename X> struct adapt<IMediaComposition, X> : Windows::Media::Editing::IMediaComposition_adaptor<X> { typedef adapt IMediaComposition; };
struct IMediaComposition : IMediaComposition_raw, generate<IMediaComposition> {};

// IBackgroundAudioTrackStatics
struct IBackgroundAudioTrackStatics : IInspectable {
	virtual STDMETHODIMP _CreateFromEmbeddedAudioTrack(EmbeddedAudioTrack* embeddedAudioTrack, BackgroundAudioTrack* *value);
	virtual STDMETHODIMP _CreateFromFileAsync(Storage::IStorageFile* file, Foundation::IAsyncOperation<BackgroundAudioTrack*>* *operation);
};

// IBackgroundAudioTrack
struct IBackgroundAudioTrack_raw : IInspectable {
	virtual STDMETHODIMP _get_TrimTimeFromStart(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_TrimTimeFromStart(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_TrimTimeFromEnd(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_TrimTimeFromEnd(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_OriginalDuration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_TrimmedDuration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_UserData(Foundation::Collections::IMap<HSTRING, HSTRING>* *value);
	virtual STDMETHODIMP _put_Delay(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_Delay(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_Volume(double value);
	virtual STDMETHODIMP _get_Volume(double *value);
	virtual STDMETHODIMP _Clone(BackgroundAudioTrack* *value);
	virtual STDMETHODIMP _GetAudioEncodingProperties(MediaProperties::AudioEncodingProperties* *value);
	virtual STDMETHODIMP _get_AudioEffectDefinitions(Foundation::Collections::IVector<Effects::IAudioEffectDefinition*>* *value);
};
template<typename X> struct IBackgroundAudioTrack_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Effects::IAudioEffectDefinition>>> get() { Foundation::Collections::IVector<Effects::IAudioEffectDefinition*>* value; hrcheck(enc(&IBackgroundAudioTrack_adaptor::AudioEffectDefinitions)->_get_AudioEffectDefinitions(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Effects::IAudioEffectDefinition>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Effects::IAudioEffectDefinition>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Effects::IAudioEffectDefinition>>> operator->() { return get(); }
		} AudioEffectDefinitions;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IBackgroundAudioTrack_adaptor::Delay)->_get_Delay(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IBackgroundAudioTrack_adaptor::Delay)->_put_Delay(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Delay;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IBackgroundAudioTrack_adaptor::OriginalDuration)->_get_OriginalDuration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} OriginalDuration;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IBackgroundAudioTrack_adaptor::TrimTimeFromEnd)->_get_TrimTimeFromEnd(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IBackgroundAudioTrack_adaptor::TrimTimeFromEnd)->_put_TrimTimeFromEnd(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} TrimTimeFromEnd;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IBackgroundAudioTrack_adaptor::TrimTimeFromStart)->_get_TrimTimeFromStart(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IBackgroundAudioTrack_adaptor::TrimTimeFromStart)->_put_TrimTimeFromStart(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} TrimTimeFromStart;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IBackgroundAudioTrack_adaptor::TrimmedDuration)->_get_TrimmedDuration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} TrimmedDuration;
		struct : property {
			ptr<Foundation::Collections::IMap<hstring, hstring>> get() { Foundation::Collections::IMap<HSTRING, HSTRING>* value; hrcheck(enc(&IBackgroundAudioTrack_adaptor::UserData)->_get_UserData(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMap<hstring, hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMap<hstring, hstring>> () { return get(); }
			ptr<Foundation::Collections::IMap<hstring, hstring>> operator->() { return get(); }
		} UserData;
		struct : property {
			double get() { double value; hrcheck(enc(&IBackgroundAudioTrack_adaptor::Volume)->_get_Volume(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IBackgroundAudioTrack_adaptor::Volume)->_put_Volume(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Volume;
	};
	ptr<BackgroundAudioTrack> Clone() { BackgroundAudioTrack* value; hrcheck(X::get()->_Clone(&value)); return from_abi(value); }
	ptr<MediaProperties::AudioEncodingProperties> GetAudioEncodingProperties() { MediaProperties::AudioEncodingProperties* value; hrcheck(X::get()->_GetAudioEncodingProperties(&value)); return from_abi(value); }
	IBackgroundAudioTrack_adaptor() {}
};
template<typename X> struct adapt<IBackgroundAudioTrack, X> : Windows::Media::Editing::IBackgroundAudioTrack_adaptor<X> { typedef adapt IBackgroundAudioTrack; };
struct IBackgroundAudioTrack : IBackgroundAudioTrack_raw, generate<IBackgroundAudioTrack> {};

// BackgroundAudioTrack
template<typename> struct BackgroundAudioTrack_statics {
	static ptr<BackgroundAudioTrack> CreateFromEmbeddedAudioTrack(pptr<EmbeddedAudioTrack> embeddedAudioTrack) { BackgroundAudioTrack* value; hrcheck(get_activation_factory<BackgroundAudioTrack, IBackgroundAudioTrackStatics>()->_CreateFromEmbeddedAudioTrack(embeddedAudioTrack, &value)); return from_abi(value); }
	static ptr<Foundation::IAsyncOperation<ptr<BackgroundAudioTrack>>> CreateFromFileAsync(pptr<Storage::IStorageFile> file) { Foundation::IAsyncOperation<BackgroundAudioTrack*>* operation; hrcheck(get_activation_factory<BackgroundAudioTrack, IBackgroundAudioTrackStatics>()->_CreateFromFileAsync(file, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<BackgroundAudioTrack, X> : X, Windows::Media::Editing::BackgroundAudioTrack_statics<void> {
	typedef typename X::root_type BackgroundAudioTrack;
};
struct BackgroundAudioTrack : generate<BackgroundAudioTrack> {};

// IMediaCompositionStatics
struct IMediaCompositionStatics : IInspectable {
	virtual STDMETHODIMP _LoadAsync(Storage::StorageFile* file, Foundation::IAsyncOperation<MediaComposition*>* *operation);
};

// IMediaComposition2
struct IMediaComposition2_raw : IInspectable {
	virtual STDMETHODIMP _get_OverlayLayers(Foundation::Collections::IVector<MediaOverlayLayer*>* *value);
};
template<typename X> struct IMediaComposition2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<MediaOverlayLayer>>> get() { Foundation::Collections::IVector<MediaOverlayLayer*>* value; hrcheck(enc(&IMediaComposition2_adaptor::OverlayLayers)->_get_OverlayLayers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<MediaOverlayLayer>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<MediaOverlayLayer>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<MediaOverlayLayer>>> operator->() { return get(); }
		} OverlayLayers;
	};
	IMediaComposition2_adaptor() {}
};
template<typename X> struct adapt<IMediaComposition2, X> : Windows::Media::Editing::IMediaComposition2_adaptor<X> { typedef adapt IMediaComposition2; };
struct IMediaComposition2 : IMediaComposition2_raw, generate<IMediaComposition2> {};

// MediaComposition
template<typename> struct MediaComposition_statics {
	static ptr<Foundation::IAsyncOperation<ptr<MediaComposition>>> LoadAsync(pptr<Storage::StorageFile> file) { Foundation::IAsyncOperation<MediaComposition*>* operation; hrcheck(get_activation_factory<MediaComposition, IMediaCompositionStatics>()->_LoadAsync(file, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<MediaComposition, X> : X, Windows::Media::Editing::MediaComposition_statics<void> {
	typedef typename X::root_type MediaComposition;
};
struct MediaComposition : generate<MediaComposition> {
	using IMediaComposition::RenderToFileAsync;
	using IMediaComposition::GenerateMediaStreamSource;
};

// IMediaOverlayLayerFactory
struct IMediaOverlayLayerFactory : IInspectable {
	virtual STDMETHODIMP _CreateWithCompositorDefinition(Effects::IVideoCompositorDefinition* compositorDefinition, MediaOverlayLayer* *mediaOverlayLayer);
};

// IMediaOverlayLayer
struct IMediaOverlayLayer_raw : IInspectable {
	virtual STDMETHODIMP _Clone(MediaOverlayLayer* *result);
	virtual STDMETHODIMP _get_Overlays(Foundation::Collections::IVector<MediaOverlay*>* *value);
	virtual STDMETHODIMP _get_CustomCompositorDefinition(Effects::IVideoCompositorDefinition* *value);
};
template<typename X> struct IMediaOverlayLayer_adaptor : X {
	union {
		struct : property {
			ptr<Effects::IVideoCompositorDefinition> get() { Effects::IVideoCompositorDefinition* value; hrcheck(enc(&IMediaOverlayLayer_adaptor::CustomCompositorDefinition)->_get_CustomCompositorDefinition(&value)); return from_abi(value); }
			ptr<Effects::IVideoCompositorDefinition> operator()() { return get(); }
			operator ptr<Effects::IVideoCompositorDefinition> () { return get(); }
			ptr<Effects::IVideoCompositorDefinition> operator->() { return get(); }
		} CustomCompositorDefinition;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<MediaOverlay>>> get() { Foundation::Collections::IVector<MediaOverlay*>* value; hrcheck(enc(&IMediaOverlayLayer_adaptor::Overlays)->_get_Overlays(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<MediaOverlay>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<MediaOverlay>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<MediaOverlay>>> operator->() { return get(); }
		} Overlays;
	};
	ptr<MediaOverlayLayer> Clone() { MediaOverlayLayer* result; hrcheck(X::get()->_Clone(&result)); return from_abi(result); }
	IMediaOverlayLayer_adaptor() {}
};
template<typename X> struct adapt<IMediaOverlayLayer, X> : Windows::Media::Editing::IMediaOverlayLayer_adaptor<X> { typedef adapt IMediaOverlayLayer; };
struct IMediaOverlayLayer : IMediaOverlayLayer_raw, generate<IMediaOverlayLayer> {};

// MediaOverlayLayer
template<typename> struct MediaOverlayLayer_statics {
	static MediaOverlayLayer *activate() { MediaOverlayLayer *t; get_activation_factory<MediaOverlayLayer>()->ActivateInstance((IInspectable**)&t); return t; }
	static MediaOverlayLayer *activate(pptr<Effects::IVideoCompositorDefinition> compositorDefinition) { MediaOverlayLayer *mediaOverlayLayer; hrcheck(get_activation_factory<MediaOverlayLayer, IMediaOverlayLayerFactory>()->_CreateWithCompositorDefinition(compositorDefinition, &mediaOverlayLayer)); return mediaOverlayLayer; }
};

template<typename X> struct statics<MediaOverlayLayer, X> : X, Windows::Media::Editing::MediaOverlayLayer_statics<void> {
	using Windows::Media::Editing::MediaOverlayLayer_statics<void>::activate;
	typedef typename X::root_type MediaOverlayLayer;
};
struct MediaOverlayLayer : generate<MediaOverlayLayer> {};
}}}
} // namespace iso_winrt
