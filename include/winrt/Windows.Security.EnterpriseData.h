#pragma once
// generated by isopod tools
// namespaces:
// Windows.Security.EnterpriseData

#include "Windows.Security.EnterpriseData.0.h"
#include "Windows.Storage.0.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IVectorView;
template<typename T> struct IIterable;
}}
namespace Networking {
struct HostName;
}
namespace Storage { namespace Streams {
struct IOutputStream;
struct IBuffer;
struct IRandomAccessStream;
struct IInputStream;
}}}

// defs

template<> struct def<Windows::Security::EnterpriseData::ProtectionPolicyEvaluationResult> : enum_type<int> {};
template<> struct def<Windows::Security::EnterpriseData::EnterpriseDataContract> : value_type<> {};
template<> struct def<Windows::Security::EnterpriseData::FileProtectionStatus> : enum_type<int> {};
template<> struct def<Windows::Security::EnterpriseData::ProtectedImportExportStatus> : enum_type<int> {};
template<> struct def<Windows::Security::EnterpriseData::DataProtectionStatus> : enum_type<int> {};
template<> struct def<Windows::Security::EnterpriseData::IFileRevocationManagerStatics> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::IFileProtectionManagerStatics> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::IFileProtectionInfo2> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::IFileProtectionInfo> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::FileProtectionInfo> : class_type<Platform::Object, Windows::Security::EnterpriseData::IFileProtectionInfo, Windows::Security::EnterpriseData::IFileProtectionInfo2> {};
template<> struct def<Windows::Security::EnterpriseData::IProtectedContainerExportResult> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::ProtectedContainerExportResult> : class_type<Platform::Object, Windows::Security::EnterpriseData::IProtectedContainerExportResult> {};
template<> struct def<Windows::Security::EnterpriseData::IProtectedContainerImportResult> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::ProtectedContainerImportResult> : class_type<Platform::Object, Windows::Security::EnterpriseData::IProtectedContainerImportResult> {};
template<> struct def<Windows::Security::EnterpriseData::IProtectedFileCreateResult> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::ProtectedFileCreateResult> : class_type<Platform::Object, Windows::Security::EnterpriseData::IProtectedFileCreateResult> {};
template<> struct def<Windows::Security::EnterpriseData::IFileProtectionManagerStatics2> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::IFileUnprotectOptionsFactory> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::IFileUnprotectOptions> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::FileUnprotectOptions> : class_type<Platform::Object, Windows::Security::EnterpriseData::IFileUnprotectOptions>, custom_activators {};
template<> struct def<Windows::Security::EnterpriseData::IFileProtectionManagerStatics3> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::IDataProtectionManagerStatics> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::IBufferProtectUnprotectResult> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::BufferProtectUnprotectResult> : class_type<Platform::Object, Windows::Security::EnterpriseData::IBufferProtectUnprotectResult> {};
template<> struct def<Windows::Security::EnterpriseData::IDataProtectionInfo> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::DataProtectionInfo> : class_type<Platform::Object, Windows::Security::EnterpriseData::IDataProtectionInfo> {};
template<> struct def<Windows::Security::EnterpriseData::ProtectionPolicyAuditAction> : enum_type<int> {};
template<> struct def<Windows::Security::EnterpriseData::ProtectionPolicyRequestAccessBehavior> : enum_type<int> {};
template<> struct def<Windows::Security::EnterpriseData::IProtectionPolicyAuditInfoFactory> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::IProtectionPolicyAuditInfo> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::ProtectionPolicyAuditInfo> : class_type<Platform::Object, Windows::Security::EnterpriseData::IProtectionPolicyAuditInfo>, custom_activators {};
template<> struct def<Windows::Security::EnterpriseData::IProtectionPolicyManager> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::IProtectionPolicyManager2> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::IProtectionPolicyManagerStatics> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::IThreadNetworkContext> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::ThreadNetworkContext> : class_type<Platform::Object, Windows::Security::EnterpriseData::IThreadNetworkContext, Windows::Foundation::IClosable> {};
template<> struct def<Windows::Security::EnterpriseData::IProtectionPolicyManagerStatics4> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::IProtectionPolicyManagerStatics3> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::EnforcementLevel> : enum_type<int> {};
template<> struct def<Windows::Security::EnterpriseData::IProtectionPolicyManagerStatics2> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::ProtectionPolicyManager> : class_type<Platform::Object, Windows::Security::EnterpriseData::IProtectionPolicyManager, Windows::Security::EnterpriseData::IProtectionPolicyManager2> {};
template<> struct def<Windows::Security::EnterpriseData::IProtectedAccessSuspendingEventArgs> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::ProtectedAccessSuspendingEventArgs> : class_type<Platform::Object, Windows::Security::EnterpriseData::IProtectedAccessSuspendingEventArgs> {};
template<> struct def<Windows::Security::EnterpriseData::IProtectedAccessResumedEventArgs> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::ProtectedAccessResumedEventArgs> : class_type<Platform::Object, Windows::Security::EnterpriseData::IProtectedAccessResumedEventArgs> {};
template<> struct def<Windows::Security::EnterpriseData::IProtectedContentRevokedEventArgs> : interface_type<> {};
template<> struct def<Windows::Security::EnterpriseData::ProtectedContentRevokedEventArgs> : class_type<Platform::Object, Windows::Security::EnterpriseData::IProtectedContentRevokedEventArgs> {};
template<> struct def<Windows::Security::EnterpriseData::FileRevocationManager> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Security::EnterpriseData::FileProtectionManager> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Security::EnterpriseData::DataProtectionManager> : class_type<Platform::Object, Platform::Object> {};

// uuids

template<> struct uuid<Windows::Security::EnterpriseData::IFileRevocationManagerStatics> { define_guid(0x256BBC3D, 0x1C5D, 0x4260, 0x8C, 0x75, 0x91, 0x44, 0xCF, 0xB7, 0x8B, 0xA9);};
template<> struct uuid<Windows::Security::EnterpriseData::IFileProtectionManagerStatics> { define_guid(0x5846FC9B, 0xE613, 0x426B, 0xBB, 0x38, 0x88, 0xCB, 0xA1, 0xDC, 0x9A, 0xDB);};
template<> struct uuid<Windows::Security::EnterpriseData::IFileProtectionInfo2> { define_guid(0x82123A4C, 0x557A, 0x498D, 0x8E, 0x94, 0x94, 0x4C, 0xD5, 0x83, 0x64, 0x32);};
template<> struct uuid<Windows::Security::EnterpriseData::IFileProtectionInfo> { define_guid(0x4EE96486, 0x147E, 0x4DD0, 0x8F, 0xAF, 0x52, 0x53, 0xED, 0x91, 0xAD, 0xC);};
template<> struct uuid<Windows::Security::EnterpriseData::IProtectedContainerExportResult> { define_guid(0x3948EF95, 0xF7FB, 0x4B42, 0xAF, 0xB0, 0xDF, 0x70, 0xB4, 0x15, 0x43, 0xC1);};
template<> struct uuid<Windows::Security::EnterpriseData::IProtectedContainerImportResult> { define_guid(0xCDB780D1, 0xE7BB, 0x4D1A, 0x93, 0x39, 0x34, 0xDC, 0x41, 0x14, 0x9F, 0x9B);};
template<> struct uuid<Windows::Security::EnterpriseData::IProtectedFileCreateResult> { define_guid(0x28E3ED6A, 0xE9E7, 0x4A03, 0x9F, 0x53, 0xBD, 0xB1, 0x61, 0x72, 0x69, 0x9B);};
template<> struct uuid<Windows::Security::EnterpriseData::IFileProtectionManagerStatics2> { define_guid(0x83D2A745, 0x483, 0x41AB, 0xB2, 0xD5, 0xBC, 0x7F, 0x23, 0xD7, 0x4E, 0xBB);};
template<> struct uuid<Windows::Security::EnterpriseData::IFileUnprotectOptionsFactory> { define_guid(0x51AEB39C, 0xDA8C, 0x4C3F, 0x9B, 0xFB, 0xCB, 0x73, 0xA7, 0xCC, 0xE0, 0xDD);};
template<> struct uuid<Windows::Security::EnterpriseData::IFileUnprotectOptions> { define_guid(0x7D1312F1, 0x3B0D, 0x4DD8, 0xA1, 0xF8, 0x1E, 0xC5, 0x38, 0x22, 0xE2, 0xF3);};
template<> struct uuid<Windows::Security::EnterpriseData::IFileProtectionManagerStatics3> { define_guid(0x6918849A, 0x624F, 0x46D6, 0xB2, 0x41, 0xE9, 0xCD, 0x5F, 0xDF, 0x3E, 0x3F);};
template<> struct uuid<Windows::Security::EnterpriseData::IDataProtectionManagerStatics> { define_guid(0xB6149B74, 0x9144, 0x4EE4, 0x8A, 0x8A, 0x30, 0xB5, 0xF3, 0x61, 0x43, 0xE);};
template<> struct uuid<Windows::Security::EnterpriseData::IBufferProtectUnprotectResult> { define_guid(0x47995EDC, 0x6CEC, 0x4E3A, 0xB2, 0x51, 0x9E, 0x74, 0x85, 0xD7, 0x9E, 0x7A);};
template<> struct uuid<Windows::Security::EnterpriseData::IDataProtectionInfo> { define_guid(0x8420B0C1, 0x5E31, 0x4405, 0x95, 0x40, 0x3F, 0x94, 0x3A, 0xF0, 0xCB, 0x26);};
template<> struct uuid<Windows::Security::EnterpriseData::IProtectionPolicyAuditInfoFactory> { define_guid(0x7ED4180B, 0x92E8, 0x42D5, 0x83, 0xD4, 0x25, 0x44, 0xB, 0x42, 0x35, 0x49);};
template<> struct uuid<Windows::Security::EnterpriseData::IProtectionPolicyAuditInfo> { define_guid(0x425AB7E4, 0xFEB7, 0x44FC, 0xB3, 0xBB, 0xC3, 0xC4, 0xD7, 0xEC, 0xBE, 0xBB);};
template<> struct uuid<Windows::Security::EnterpriseData::IProtectionPolicyManager> { define_guid(0xD5703E18, 0xA08D, 0x47E6, 0xA2, 0x40, 0x99, 0x34, 0xD7, 0x16, 0x5E, 0xB5);};
template<> struct uuid<Windows::Security::EnterpriseData::IProtectionPolicyManager2> { define_guid(0xABF7527A, 0x8435, 0x417F, 0x99, 0xB6, 0x51, 0xBE, 0xAF, 0x36, 0x58, 0x88);};
template<> struct uuid<Windows::Security::EnterpriseData::IProtectionPolicyManagerStatics> { define_guid(0xC0BFFC66, 0x8C3D, 0x4D56, 0x88, 0x4, 0xC6, 0x8F, 0xA, 0xD3, 0x2E, 0xC5);};
template<> struct uuid<Windows::Security::EnterpriseData::IThreadNetworkContext> { define_guid(0xFA4EA8E9, 0xEF13, 0x405A, 0xB1, 0x2C, 0xD7, 0x34, 0x8C, 0x6F, 0x41, 0xFC);};
template<> struct uuid<Windows::Security::EnterpriseData::IProtectionPolicyManagerStatics4> { define_guid(0x20B794DB, 0xCCBD, 0x490F, 0x8C, 0x83, 0x49, 0xCC, 0xB7, 0x7A, 0xEA, 0x6C);};
template<> struct uuid<Windows::Security::EnterpriseData::IProtectionPolicyManagerStatics3> { define_guid(0x48FF9E8C, 0x6A6F, 0x4D9F, 0xBC, 0xED, 0x18, 0xAB, 0x53, 0x7A, 0xA0, 0x15);};
template<> struct uuid<Windows::Security::EnterpriseData::IProtectionPolicyManagerStatics2> { define_guid(0xB68F9A8C, 0x39E0, 0x4649, 0xB2, 0xE4, 0x7, 0xA, 0xB8, 0xA5, 0x79, 0xB3);};
template<> struct uuid<Windows::Security::EnterpriseData::IProtectedAccessSuspendingEventArgs> { define_guid(0x75A193E0, 0xA344, 0x429F, 0xB9, 0x75, 0x4, 0xFC, 0x1F, 0x88, 0xC1, 0x85);};
template<> struct uuid<Windows::Security::EnterpriseData::IProtectedAccessResumedEventArgs> { define_guid(0xAC4DCA59, 0x5D80, 0x4E95, 0x8C, 0x5F, 0x85, 0x39, 0x45, 0xE, 0xEB, 0xE0);};
template<> struct uuid<Windows::Security::EnterpriseData::IProtectedContentRevokedEventArgs> { define_guid(0x63686821, 0x58B9, 0x47EE, 0x93, 0xD9, 0xF0, 0xF7, 0x41, 0xCF, 0x43, 0xF0);};

// types

namespace Windows { namespace Security { namespace EnterpriseData {

// IFileRevocationManagerStatics
struct IFileRevocationManagerStatics : IInspectable {
	virtual STDMETHODIMP _ProtectAsync(Storage::IStorageItem* storageItem, HSTRING enterpriseIdentity, Foundation::IAsyncOperation<FileProtectionStatus>* *result);
	virtual STDMETHODIMP _CopyProtectionAsync(Storage::IStorageItem* sourceStorageItem, Storage::IStorageItem* targetStorageItem, Foundation::IAsyncOperation<bool>* *result);
	virtual STDMETHODIMP _Revoke(HSTRING enterpriseIdentity);
	virtual STDMETHODIMP _GetStatusAsync(Storage::IStorageItem* storageItem, Foundation::IAsyncOperation<FileProtectionStatus>* *result);
};

// IFileProtectionManagerStatics
struct IFileProtectionManagerStatics : IInspectable {
	virtual STDMETHODIMP _ProtectAsync(Storage::IStorageItem* target, HSTRING identity, Foundation::IAsyncOperation<FileProtectionInfo*>* *result);
	virtual STDMETHODIMP _CopyProtectionAsync(Storage::IStorageItem* source, Storage::IStorageItem* target, Foundation::IAsyncOperation<bool>* *result);
	virtual STDMETHODIMP _GetProtectionInfoAsync(Storage::IStorageItem* source, Foundation::IAsyncOperation<FileProtectionInfo*>* *result);
	virtual STDMETHODIMP _SaveFileAsContainerAsync(Storage::IStorageFile* protectedFile, Foundation::IAsyncOperation<ProtectedContainerExportResult*>* *result);
	virtual STDMETHODIMP _LoadFileFromContainerAsync(Storage::IStorageFile* containerFile, Foundation::IAsyncOperation<ProtectedContainerImportResult*>* *result);
	virtual STDMETHODIMP _LoadFileFromContainerWithTargetAsync(Storage::IStorageFile* containerFile, Storage::IStorageItem* target, Foundation::IAsyncOperation<ProtectedContainerImportResult*>* *result);
	virtual STDMETHODIMP _CreateProtectedAndOpenAsync(Storage::IStorageFolder* parentFolder, HSTRING desiredName, HSTRING identity, Storage::CreationCollisionOption collisionOption, Foundation::IAsyncOperation<ProtectedFileCreateResult*>* *result);
};

// IFileProtectionInfo2
struct IFileProtectionInfo2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsProtectWhileOpenSupported(bool *value);
};
template<typename X> struct IFileProtectionInfo2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFileProtectionInfo2_adaptor::IsProtectWhileOpenSupported)->_get_IsProtectWhileOpenSupported(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsProtectWhileOpenSupported;
	};
	IFileProtectionInfo2_adaptor() {}
};
template<typename X> struct adapt<IFileProtectionInfo2, X> : Windows::Security::EnterpriseData::IFileProtectionInfo2_adaptor<X> { typedef adapt IFileProtectionInfo2; };
struct IFileProtectionInfo2 : IFileProtectionInfo2_raw, generate<IFileProtectionInfo2> {};

// IFileProtectionInfo
struct IFileProtectionInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(FileProtectionStatus *value);
	virtual STDMETHODIMP _get_IsRoamable(bool *value);
	virtual STDMETHODIMP _get_Identity(HSTRING *value);
};
template<typename X> struct IFileProtectionInfo_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IFileProtectionInfo_adaptor::Identity)->_get_Identity(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Identity;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFileProtectionInfo_adaptor::IsRoamable)->_get_IsRoamable(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsRoamable;
		struct : property {
			FileProtectionStatus get() { FileProtectionStatus value; hrcheck(enc(&IFileProtectionInfo_adaptor::Status)->_get_Status(&value)); return value; }
			FileProtectionStatus operator()() { return get(); }
			operator FileProtectionStatus () { return get(); }
		} Status;
	};
	IFileProtectionInfo_adaptor() {}
};
template<typename X> struct adapt<IFileProtectionInfo, X> : Windows::Security::EnterpriseData::IFileProtectionInfo_adaptor<X> { typedef adapt IFileProtectionInfo; };
struct IFileProtectionInfo : IFileProtectionInfo_raw, generate<IFileProtectionInfo> {};

// FileProtectionInfo
template<typename X> struct statics<FileProtectionInfo, X> : X {
	typedef typename X::root_type FileProtectionInfo;
};
struct FileProtectionInfo : generate<FileProtectionInfo> {};

// IProtectedContainerExportResult
struct IProtectedContainerExportResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(ProtectedImportExportStatus *value);
	virtual STDMETHODIMP _get_File(Storage::StorageFile* *value);
};
template<typename X> struct IProtectedContainerExportResult_adaptor : X {
	union {
		struct : property {
			ptr<Storage::StorageFile> get() { Storage::StorageFile* value; hrcheck(enc(&IProtectedContainerExportResult_adaptor::File)->_get_File(&value)); return from_abi(value); }
			ptr<Storage::StorageFile> operator()() { return get(); }
			operator ptr<Storage::StorageFile> () { return get(); }
			ptr<Storage::StorageFile> operator->() { return get(); }
		} File;
		struct : property {
			ProtectedImportExportStatus get() { ProtectedImportExportStatus value; hrcheck(enc(&IProtectedContainerExportResult_adaptor::Status)->_get_Status(&value)); return value; }
			ProtectedImportExportStatus operator()() { return get(); }
			operator ProtectedImportExportStatus () { return get(); }
		} Status;
	};
	IProtectedContainerExportResult_adaptor() {}
};
template<typename X> struct adapt<IProtectedContainerExportResult, X> : Windows::Security::EnterpriseData::IProtectedContainerExportResult_adaptor<X> { typedef adapt IProtectedContainerExportResult; };
struct IProtectedContainerExportResult : IProtectedContainerExportResult_raw, generate<IProtectedContainerExportResult> {};

// ProtectedContainerExportResult
template<typename X> struct statics<ProtectedContainerExportResult, X> : X {
	typedef typename X::root_type ProtectedContainerExportResult;
};
struct ProtectedContainerExportResult : generate<ProtectedContainerExportResult> {};

// IProtectedContainerImportResult
struct IProtectedContainerImportResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(ProtectedImportExportStatus *value);
	virtual STDMETHODIMP _get_File(Storage::StorageFile* *value);
};
template<typename X> struct IProtectedContainerImportResult_adaptor : X {
	union {
		struct : property {
			ptr<Storage::StorageFile> get() { Storage::StorageFile* value; hrcheck(enc(&IProtectedContainerImportResult_adaptor::File)->_get_File(&value)); return from_abi(value); }
			ptr<Storage::StorageFile> operator()() { return get(); }
			operator ptr<Storage::StorageFile> () { return get(); }
			ptr<Storage::StorageFile> operator->() { return get(); }
		} File;
		struct : property {
			ProtectedImportExportStatus get() { ProtectedImportExportStatus value; hrcheck(enc(&IProtectedContainerImportResult_adaptor::Status)->_get_Status(&value)); return value; }
			ProtectedImportExportStatus operator()() { return get(); }
			operator ProtectedImportExportStatus () { return get(); }
		} Status;
	};
	IProtectedContainerImportResult_adaptor() {}
};
template<typename X> struct adapt<IProtectedContainerImportResult, X> : Windows::Security::EnterpriseData::IProtectedContainerImportResult_adaptor<X> { typedef adapt IProtectedContainerImportResult; };
struct IProtectedContainerImportResult : IProtectedContainerImportResult_raw, generate<IProtectedContainerImportResult> {};

// ProtectedContainerImportResult
template<typename X> struct statics<ProtectedContainerImportResult, X> : X {
	typedef typename X::root_type ProtectedContainerImportResult;
};
struct ProtectedContainerImportResult : generate<ProtectedContainerImportResult> {};

// IProtectedFileCreateResult
struct IProtectedFileCreateResult_raw : IInspectable {
	virtual STDMETHODIMP _get_File(Storage::StorageFile* *value);
	virtual STDMETHODIMP _get_Stream(Storage::Streams::IRandomAccessStream* *value);
	virtual STDMETHODIMP _get_ProtectionInfo(FileProtectionInfo* *value);
};
template<typename X> struct IProtectedFileCreateResult_adaptor : X {
	union {
		struct : property {
			ptr<Storage::StorageFile> get() { Storage::StorageFile* value; hrcheck(enc(&IProtectedFileCreateResult_adaptor::File)->_get_File(&value)); return from_abi(value); }
			ptr<Storage::StorageFile> operator()() { return get(); }
			operator ptr<Storage::StorageFile> () { return get(); }
			ptr<Storage::StorageFile> operator->() { return get(); }
		} File;
		struct : property {
			ptr<FileProtectionInfo> get() { FileProtectionInfo* value; hrcheck(enc(&IProtectedFileCreateResult_adaptor::ProtectionInfo)->_get_ProtectionInfo(&value)); return from_abi(value); }
			ptr<FileProtectionInfo> operator()() { return get(); }
			operator ptr<FileProtectionInfo> () { return get(); }
			ptr<FileProtectionInfo> operator->() { return get(); }
		} ProtectionInfo;
		struct : property {
			ptr<Storage::Streams::IRandomAccessStream> get() { Storage::Streams::IRandomAccessStream* value; hrcheck(enc(&IProtectedFileCreateResult_adaptor::Stream)->_get_Stream(&value)); return from_abi(value); }
			ptr<Storage::Streams::IRandomAccessStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IRandomAccessStream> () { return get(); }
			ptr<Storage::Streams::IRandomAccessStream> operator->() { return get(); }
		} Stream;
	};
	IProtectedFileCreateResult_adaptor() {}
};
template<typename X> struct adapt<IProtectedFileCreateResult, X> : Windows::Security::EnterpriseData::IProtectedFileCreateResult_adaptor<X> { typedef adapt IProtectedFileCreateResult; };
struct IProtectedFileCreateResult : IProtectedFileCreateResult_raw, generate<IProtectedFileCreateResult> {};

// ProtectedFileCreateResult
template<typename X> struct statics<ProtectedFileCreateResult, X> : X {
	typedef typename X::root_type ProtectedFileCreateResult;
};
struct ProtectedFileCreateResult : generate<ProtectedFileCreateResult> {};

// IFileProtectionManagerStatics2
struct IFileProtectionManagerStatics2 : IInspectable {
	virtual STDMETHODIMP _IsContainerAsync(Storage::IStorageFile* file, Foundation::IAsyncOperation<bool>* *result);
	virtual STDMETHODIMP _LoadFileFromContainerWithTargetAndNameCollisionOptionAsync(Storage::IStorageFile* containerFile, Storage::IStorageItem* target, Storage::NameCollisionOption collisionOption, Foundation::IAsyncOperation<ProtectedContainerImportResult*>* *result);
	virtual STDMETHODIMP _SaveFileAsContainerWithSharingAsync(Storage::IStorageFile* protectedFile, Foundation::Collections::IIterable<HSTRING>* sharedWithIdentities, Foundation::IAsyncOperation<ProtectedContainerExportResult*>* *result);
};

// IFileUnprotectOptionsFactory
struct IFileUnprotectOptionsFactory : IInspectable {
	virtual STDMETHODIMP _Create(bool audit, FileUnprotectOptions* *result);
};

// IFileUnprotectOptions
struct IFileUnprotectOptions_raw : IInspectable {
	virtual STDMETHODIMP _put_Audit(bool value);
	virtual STDMETHODIMP _get_Audit(bool *value);
};
template<typename X> struct IFileUnprotectOptions_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFileUnprotectOptions_adaptor::Audit)->_get_Audit(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IFileUnprotectOptions_adaptor::Audit)->_put_Audit(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Audit;
	};
	IFileUnprotectOptions_adaptor() {}
};
template<typename X> struct adapt<IFileUnprotectOptions, X> : Windows::Security::EnterpriseData::IFileUnprotectOptions_adaptor<X> { typedef adapt IFileUnprotectOptions; };
struct IFileUnprotectOptions : IFileUnprotectOptions_raw, generate<IFileUnprotectOptions> {};

// FileUnprotectOptions
template<typename> struct FileUnprotectOptions_statics {
	static FileUnprotectOptions *activate(bool audit) { FileUnprotectOptions *result; hrcheck(get_activation_factory<FileUnprotectOptions, IFileUnprotectOptionsFactory>()->_Create(audit, &result)); return result; }
};

template<typename X> struct statics<FileUnprotectOptions, X> : X, Windows::Security::EnterpriseData::FileUnprotectOptions_statics<void> {
	using Windows::Security::EnterpriseData::FileUnprotectOptions_statics<void>::activate;
	typedef typename X::root_type FileUnprotectOptions;
};
struct FileUnprotectOptions : generate<FileUnprotectOptions> {};

// IFileProtectionManagerStatics3
struct IFileProtectionManagerStatics3 : IInspectable {
	virtual STDMETHODIMP _UnprotectAsync(Storage::IStorageItem* target, Foundation::IAsyncOperation<FileProtectionInfo*>* *result);
	virtual STDMETHODIMP _UnprotectWithOptionsAsync(Storage::IStorageItem* target, FileUnprotectOptions* options, Foundation::IAsyncOperation<FileProtectionInfo*>* *result);
};

// IDataProtectionManagerStatics
struct IDataProtectionManagerStatics : IInspectable {
	virtual STDMETHODIMP _ProtectAsync(Storage::Streams::IBuffer* data, HSTRING identity, Foundation::IAsyncOperation<BufferProtectUnprotectResult*>* *result);
	virtual STDMETHODIMP _UnprotectAsync(Storage::Streams::IBuffer* data, Foundation::IAsyncOperation<BufferProtectUnprotectResult*>* *result);
	virtual STDMETHODIMP _ProtectStreamAsync(Storage::Streams::IInputStream* unprotectedStream, HSTRING identity, Storage::Streams::IOutputStream* protectedStream, Foundation::IAsyncOperation<DataProtectionInfo*>* *result);
	virtual STDMETHODIMP _UnprotectStreamAsync(Storage::Streams::IInputStream* protectedStream, Storage::Streams::IOutputStream* unprotectedStream, Foundation::IAsyncOperation<DataProtectionInfo*>* *result);
	virtual STDMETHODIMP _GetProtectionInfoAsync(Storage::Streams::IBuffer* protectedData, Foundation::IAsyncOperation<DataProtectionInfo*>* *result);
	virtual STDMETHODIMP _GetStreamProtectionInfoAsync(Storage::Streams::IInputStream* protectedStream, Foundation::IAsyncOperation<DataProtectionInfo*>* *result);
};

// IBufferProtectUnprotectResult
struct IBufferProtectUnprotectResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Buffer(Storage::Streams::IBuffer* *value);
	virtual STDMETHODIMP _get_ProtectionInfo(DataProtectionInfo* *value);
};
template<typename X> struct IBufferProtectUnprotectResult_adaptor : X {
	union {
		struct : property {
			ptr<Storage::Streams::IBuffer> get() { Storage::Streams::IBuffer* value; hrcheck(enc(&IBufferProtectUnprotectResult_adaptor::Buffer)->_get_Buffer(&value)); return from_abi(value); }
			ptr<Storage::Streams::IBuffer> operator()() { return get(); }
			operator ptr<Storage::Streams::IBuffer> () { return get(); }
			ptr<Storage::Streams::IBuffer> operator->() { return get(); }
		} Buffer;
		struct : property {
			ptr<DataProtectionInfo> get() { DataProtectionInfo* value; hrcheck(enc(&IBufferProtectUnprotectResult_adaptor::ProtectionInfo)->_get_ProtectionInfo(&value)); return from_abi(value); }
			ptr<DataProtectionInfo> operator()() { return get(); }
			operator ptr<DataProtectionInfo> () { return get(); }
			ptr<DataProtectionInfo> operator->() { return get(); }
		} ProtectionInfo;
	};
	IBufferProtectUnprotectResult_adaptor() {}
};
template<typename X> struct adapt<IBufferProtectUnprotectResult, X> : Windows::Security::EnterpriseData::IBufferProtectUnprotectResult_adaptor<X> { typedef adapt IBufferProtectUnprotectResult; };
struct IBufferProtectUnprotectResult : IBufferProtectUnprotectResult_raw, generate<IBufferProtectUnprotectResult> {};

// BufferProtectUnprotectResult
template<typename X> struct statics<BufferProtectUnprotectResult, X> : X {
	typedef typename X::root_type BufferProtectUnprotectResult;
};
struct BufferProtectUnprotectResult : generate<BufferProtectUnprotectResult> {};

// IDataProtectionInfo
struct IDataProtectionInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(DataProtectionStatus *value);
	virtual STDMETHODIMP _get_Identity(HSTRING *value);
};
template<typename X> struct IDataProtectionInfo_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDataProtectionInfo_adaptor::Identity)->_get_Identity(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Identity;
		struct : property {
			DataProtectionStatus get() { DataProtectionStatus value; hrcheck(enc(&IDataProtectionInfo_adaptor::Status)->_get_Status(&value)); return value; }
			DataProtectionStatus operator()() { return get(); }
			operator DataProtectionStatus () { return get(); }
		} Status;
	};
	IDataProtectionInfo_adaptor() {}
};
template<typename X> struct adapt<IDataProtectionInfo, X> : Windows::Security::EnterpriseData::IDataProtectionInfo_adaptor<X> { typedef adapt IDataProtectionInfo; };
struct IDataProtectionInfo : IDataProtectionInfo_raw, generate<IDataProtectionInfo> {};

// DataProtectionInfo
template<typename X> struct statics<DataProtectionInfo, X> : X {
	typedef typename X::root_type DataProtectionInfo;
};
struct DataProtectionInfo : generate<DataProtectionInfo> {};

// IProtectionPolicyAuditInfoFactory
struct IProtectionPolicyAuditInfoFactory : IInspectable {
	virtual STDMETHODIMP _Create(ProtectionPolicyAuditAction action, HSTRING dataDescription, HSTRING sourceDescription, HSTRING targetDescription, ProtectionPolicyAuditInfo* *result);
	virtual STDMETHODIMP _CreateWithActionAndDataDescription(ProtectionPolicyAuditAction action, HSTRING dataDescription, ProtectionPolicyAuditInfo* *result);
};

// IProtectionPolicyAuditInfo
struct IProtectionPolicyAuditInfo_raw : IInspectable {
	virtual STDMETHODIMP _put_Action(ProtectionPolicyAuditAction value);
	virtual STDMETHODIMP _get_Action(ProtectionPolicyAuditAction *value);
	virtual STDMETHODIMP _put_DataDescription(HSTRING value);
	virtual STDMETHODIMP _get_DataDescription(HSTRING *value);
	virtual STDMETHODIMP _put_SourceDescription(HSTRING value);
	virtual STDMETHODIMP _get_SourceDescription(HSTRING *value);
	virtual STDMETHODIMP _put_TargetDescription(HSTRING value);
	virtual STDMETHODIMP _get_TargetDescription(HSTRING *value);
};
template<typename X> struct IProtectionPolicyAuditInfo_adaptor : X {
	union {
		struct : property {
			ProtectionPolicyAuditAction get() { ProtectionPolicyAuditAction value; hrcheck(enc(&IProtectionPolicyAuditInfo_adaptor::Action)->_get_Action(&value)); return value; }
			ProtectionPolicyAuditAction operator()() { return get(); }
			operator ProtectionPolicyAuditAction () { return get(); }
			void put(ProtectionPolicyAuditAction value) { hrcheck(enc(&IProtectionPolicyAuditInfo_adaptor::Action)->_put_Action(value)); }
			void operator=(ProtectionPolicyAuditAction value) { put(value); }
			void operator()(ProtectionPolicyAuditAction value) { put(value); }
		} Action;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IProtectionPolicyAuditInfo_adaptor::DataDescription)->_get_DataDescription(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IProtectionPolicyAuditInfo_adaptor::DataDescription)->_put_DataDescription(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DataDescription;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IProtectionPolicyAuditInfo_adaptor::SourceDescription)->_get_SourceDescription(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IProtectionPolicyAuditInfo_adaptor::SourceDescription)->_put_SourceDescription(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} SourceDescription;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IProtectionPolicyAuditInfo_adaptor::TargetDescription)->_get_TargetDescription(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IProtectionPolicyAuditInfo_adaptor::TargetDescription)->_put_TargetDescription(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} TargetDescription;
	};
	IProtectionPolicyAuditInfo_adaptor() {}
};
template<typename X> struct adapt<IProtectionPolicyAuditInfo, X> : Windows::Security::EnterpriseData::IProtectionPolicyAuditInfo_adaptor<X> { typedef adapt IProtectionPolicyAuditInfo; };
struct IProtectionPolicyAuditInfo : IProtectionPolicyAuditInfo_raw, generate<IProtectionPolicyAuditInfo> {};

// ProtectionPolicyAuditInfo
template<typename> struct ProtectionPolicyAuditInfo_statics {
	static ProtectionPolicyAuditInfo *activate(ProtectionPolicyAuditAction action, hstring_ref dataDescription, hstring_ref sourceDescription, hstring_ref targetDescription) { ProtectionPolicyAuditInfo *result; hrcheck(get_activation_factory<ProtectionPolicyAuditInfo, IProtectionPolicyAuditInfoFactory>()->_Create(action, dataDescription, sourceDescription, targetDescription, &result)); return result; }
	static ProtectionPolicyAuditInfo *activate(ProtectionPolicyAuditAction action, hstring_ref dataDescription) { ProtectionPolicyAuditInfo *result; hrcheck(get_activation_factory<ProtectionPolicyAuditInfo, IProtectionPolicyAuditInfoFactory>()->_CreateWithActionAndDataDescription(action, dataDescription, &result)); return result; }
};

template<typename X> struct statics<ProtectionPolicyAuditInfo, X> : X, Windows::Security::EnterpriseData::ProtectionPolicyAuditInfo_statics<void> {
	using Windows::Security::EnterpriseData::ProtectionPolicyAuditInfo_statics<void>::activate;
	typedef typename X::root_type ProtectionPolicyAuditInfo;
};
struct ProtectionPolicyAuditInfo : generate<ProtectionPolicyAuditInfo> {};

// IProtectionPolicyManager
struct IProtectionPolicyManager_raw : IInspectable {
	virtual STDMETHODIMP _put_Identity(HSTRING value);
	virtual STDMETHODIMP _get_Identity(HSTRING *value);
};
template<typename X> struct IProtectionPolicyManager_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IProtectionPolicyManager_adaptor::Identity)->_get_Identity(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IProtectionPolicyManager_adaptor::Identity)->_put_Identity(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Identity;
	};
	IProtectionPolicyManager_adaptor() {}
};
template<typename X> struct adapt<IProtectionPolicyManager, X> : Windows::Security::EnterpriseData::IProtectionPolicyManager_adaptor<X> { typedef adapt IProtectionPolicyManager; };
struct IProtectionPolicyManager : IProtectionPolicyManager_raw, generate<IProtectionPolicyManager> {};

// IProtectionPolicyManager2
struct IProtectionPolicyManager2_raw : IInspectable {
	virtual STDMETHODIMP _put_ShowEnterpriseIndicator(bool value);
	virtual STDMETHODIMP _get_ShowEnterpriseIndicator(bool *value);
};
template<typename X> struct IProtectionPolicyManager2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IProtectionPolicyManager2_adaptor::ShowEnterpriseIndicator)->_get_ShowEnterpriseIndicator(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IProtectionPolicyManager2_adaptor::ShowEnterpriseIndicator)->_put_ShowEnterpriseIndicator(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ShowEnterpriseIndicator;
	};
	IProtectionPolicyManager2_adaptor() {}
};
template<typename X> struct adapt<IProtectionPolicyManager2, X> : Windows::Security::EnterpriseData::IProtectionPolicyManager2_adaptor<X> { typedef adapt IProtectionPolicyManager2; };
struct IProtectionPolicyManager2 : IProtectionPolicyManager2_raw, generate<IProtectionPolicyManager2> {};

// IProtectionPolicyManagerStatics
struct IProtectionPolicyManagerStatics : IInspectable {
	virtual STDMETHODIMP _IsIdentityManaged(HSTRING identity, bool *result);
	virtual STDMETHODIMP _TryApplyProcessUIPolicy(HSTRING identity, bool *result);
	virtual STDMETHODIMP _ClearProcessUIPolicy();
	virtual STDMETHODIMP _CreateCurrentThreadNetworkContext(HSTRING identity, ThreadNetworkContext* *result);
	virtual STDMETHODIMP _GetPrimaryManagedIdentityForNetworkEndpointAsync(Networking::HostName* endpointHost, Foundation::IAsyncOperation<HSTRING>* *result);
	virtual STDMETHODIMP _RevokeContent(HSTRING identity);
	virtual STDMETHODIMP _GetForCurrentView(ProtectionPolicyManager* *result);
	virtual STDMETHODIMP _add_ProtectedAccessSuspending(Foundation::EventHandler<ProtectedAccessSuspendingEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ProtectedAccessSuspending(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ProtectedAccessResumed(Foundation::EventHandler<ProtectedAccessResumedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ProtectedAccessResumed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ProtectedContentRevoked(Foundation::EventHandler<ProtectedContentRevokedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ProtectedContentRevoked(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _CheckAccess(HSTRING sourceIdentity, HSTRING targetIdentity, ProtectionPolicyEvaluationResult *result);
	virtual STDMETHODIMP _RequestAccessAsync(HSTRING sourceIdentity, HSTRING targetIdentity, Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* *result);
};

// IThreadNetworkContext
struct IThreadNetworkContext : IInspectable, generate<IThreadNetworkContext> {};

// ThreadNetworkContext
template<typename X> struct statics<ThreadNetworkContext, X> : X {
	typedef typename X::root_type ThreadNetworkContext;
};
struct ThreadNetworkContext : generate<ThreadNetworkContext> {};

// IProtectionPolicyManagerStatics4
struct IProtectionPolicyManagerStatics4 : IInspectable {
	virtual STDMETHODIMP _IsRoamableProtectionEnabled(HSTRING identity, bool *value);
	virtual STDMETHODIMP _RequestAccessWithBehaviorAsync(HSTRING sourceIdentity, HSTRING targetIdentity, ProtectionPolicyAuditInfo* auditInfo, HSTRING messageFromApp, ProtectionPolicyRequestAccessBehavior behavior, Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* *result);
	virtual STDMETHODIMP _RequestAccessForAppWithBehaviorAsync(HSTRING sourceIdentity, HSTRING appPackageFamilyName, ProtectionPolicyAuditInfo* auditInfo, HSTRING messageFromApp, ProtectionPolicyRequestAccessBehavior behavior, Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* *result);
	virtual STDMETHODIMP _RequestAccessToFilesForAppAsync(Foundation::Collections::IIterable<Storage::IStorageItem*>* sourceItemList, HSTRING appPackageFamilyName, ProtectionPolicyAuditInfo* auditInfo, Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* *result);
	virtual STDMETHODIMP _RequestAccessToFilesForAppWithMessageAndBehaviorAsync(Foundation::Collections::IIterable<Storage::IStorageItem*>* sourceItemList, HSTRING appPackageFamilyName, ProtectionPolicyAuditInfo* auditInfo, HSTRING messageFromApp, ProtectionPolicyRequestAccessBehavior behavior, Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* *result);
	virtual STDMETHODIMP _RequestAccessToFilesForProcessAsync(Foundation::Collections::IIterable<Storage::IStorageItem*>* sourceItemList, unsigned processId, ProtectionPolicyAuditInfo* auditInfo, Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* *result);
	virtual STDMETHODIMP _RequestAccessToFilesForProcessWithMessageAndBehaviorAsync(Foundation::Collections::IIterable<Storage::IStorageItem*>* sourceItemList, unsigned processId, ProtectionPolicyAuditInfo* auditInfo, HSTRING messageFromApp, ProtectionPolicyRequestAccessBehavior behavior, Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* *result);
	virtual STDMETHODIMP _IsFileProtectionRequiredAsync(Storage::IStorageItem* target, HSTRING identity, Foundation::IAsyncOperation<bool>* *result);
	virtual STDMETHODIMP _IsFileProtectionRequiredForNewFileAsync(Storage::IStorageFolder* parentFolder, HSTRING identity, HSTRING desiredName, Foundation::IAsyncOperation<bool>* *result);
	virtual STDMETHODIMP _get_PrimaryManagedIdentity(HSTRING *value);
	virtual STDMETHODIMP _GetPrimaryManagedIdentityForIdentity(HSTRING identity, HSTRING *value);
};

// IProtectionPolicyManagerStatics3
struct IProtectionPolicyManagerStatics3 : IInspectable {
	virtual STDMETHODIMP _RequestAccessWithAuditingInfoAsync(HSTRING sourceIdentity, HSTRING targetIdentity, ProtectionPolicyAuditInfo* auditInfo, Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* *result);
	virtual STDMETHODIMP _RequestAccessWithMessageAsync(HSTRING sourceIdentity, HSTRING targetIdentity, ProtectionPolicyAuditInfo* auditInfo, HSTRING messageFromApp, Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* *result);
	virtual STDMETHODIMP _RequestAccessForAppWithAuditingInfoAsync(HSTRING sourceIdentity, HSTRING appPackageFamilyName, ProtectionPolicyAuditInfo* auditInfo, Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* *result);
	virtual STDMETHODIMP _RequestAccessForAppWithMessageAsync(HSTRING sourceIdentity, HSTRING appPackageFamilyName, ProtectionPolicyAuditInfo* auditInfo, HSTRING messageFromApp, Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* *result);
	virtual STDMETHODIMP _LogAuditEvent(HSTRING sourceIdentity, HSTRING targetIdentity, ProtectionPolicyAuditInfo* auditInfo);
};

// IProtectionPolicyManagerStatics2
struct IProtectionPolicyManagerStatics2 : IInspectable {
	virtual STDMETHODIMP _HasContentBeenRevokedSince(HSTRING identity, Foundation::DateTime since, bool *result);
	virtual STDMETHODIMP _CheckAccessForApp(HSTRING sourceIdentity, HSTRING appPackageFamilyName, ProtectionPolicyEvaluationResult *result);
	virtual STDMETHODIMP _RequestAccessForAppAsync(HSTRING sourceIdentity, HSTRING appPackageFamilyName, Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* *result);
	virtual STDMETHODIMP _GetEnforcementLevel(HSTRING identity, EnforcementLevel *value);
	virtual STDMETHODIMP _IsUserDecryptionAllowed(HSTRING identity, bool *value);
	virtual STDMETHODIMP _IsProtectionUnderLockRequired(HSTRING identity, bool *value);
	virtual STDMETHODIMP _add_PolicyChanged(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PolicyChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_IsProtectionEnabled(bool *value);
};

// ProtectionPolicyManager
template<typename> struct ProtectionPolicyManager_statics {
	static struct _ProtectedAccessResumed : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<ProtectedAccessResumedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics>()->_add_ProtectedAccessResumed(to_abi(handler), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics>()->_remove_ProtectedAccessResumed(token)); }
	} ProtectedAccessResumed;
	static struct _ProtectedAccessSuspending : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<ProtectedAccessSuspendingEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics>()->_add_ProtectedAccessSuspending(to_abi(handler), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics>()->_remove_ProtectedAccessSuspending(token)); }
	} ProtectedAccessSuspending;
	static struct _ProtectedContentRevoked : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<ProtectedContentRevokedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics>()->_add_ProtectedContentRevoked(to_abi(handler), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics>()->_remove_ProtectedContentRevoked(token)); }
	} ProtectedContentRevoked;
	static struct _IsProtectionEnabled : property {
		bool get() { bool value; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics2>()->_get_IsProtectionEnabled(&value)); return value; }
		bool operator()() { return get(); }
		operator bool () { return get(); }
	} IsProtectionEnabled;
	static struct _PolicyChanged : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics2>()->_add_PolicyChanged(to_abi(handler), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics2>()->_remove_PolicyChanged(token)); }
	} PolicyChanged;
	static struct _PrimaryManagedIdentity : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics4>()->_get_PrimaryManagedIdentity(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} PrimaryManagedIdentity;
	static bool IsRoamableProtectionEnabled(hstring_ref identity) { bool value; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics4>()->_IsRoamableProtectionEnabled(identity, &value)); return value; }
	static ptr<Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>> RequestAccessAsync(hstring_ref sourceIdentity, hstring_ref targetIdentity, pptr<ProtectionPolicyAuditInfo> auditInfo, hstring_ref messageFromApp, ProtectionPolicyRequestAccessBehavior behavior) { Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics4>()->_RequestAccessWithBehaviorAsync(sourceIdentity, targetIdentity, auditInfo, messageFromApp, behavior, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>> RequestAccessForAppAsync(hstring_ref sourceIdentity, hstring_ref appPackageFamilyName, pptr<ProtectionPolicyAuditInfo> auditInfo, hstring_ref messageFromApp, ProtectionPolicyRequestAccessBehavior behavior) { Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics4>()->_RequestAccessForAppWithBehaviorAsync(sourceIdentity, appPackageFamilyName, auditInfo, messageFromApp, behavior, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>> RequestAccessToFilesForAppAsync(pptr<Foundation::Collections::IIterable<ptr<Storage::IStorageItem>>> sourceItemList, hstring_ref appPackageFamilyName, pptr<ProtectionPolicyAuditInfo> auditInfo) { Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics4>()->_RequestAccessToFilesForAppAsync(to_abi(sourceItemList), appPackageFamilyName, auditInfo, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>> RequestAccessToFilesForAppAsync(pptr<Foundation::Collections::IIterable<ptr<Storage::IStorageItem>>> sourceItemList, hstring_ref appPackageFamilyName, pptr<ProtectionPolicyAuditInfo> auditInfo, hstring_ref messageFromApp, ProtectionPolicyRequestAccessBehavior behavior) { Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics4>()->_RequestAccessToFilesForAppWithMessageAndBehaviorAsync(to_abi(sourceItemList), appPackageFamilyName, auditInfo, messageFromApp, behavior, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>> RequestAccessToFilesForProcessAsync(pptr<Foundation::Collections::IIterable<ptr<Storage::IStorageItem>>> sourceItemList, unsigned processId, pptr<ProtectionPolicyAuditInfo> auditInfo) { Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics4>()->_RequestAccessToFilesForProcessAsync(to_abi(sourceItemList), processId, auditInfo, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>> RequestAccessToFilesForProcessAsync(pptr<Foundation::Collections::IIterable<ptr<Storage::IStorageItem>>> sourceItemList, unsigned processId, pptr<ProtectionPolicyAuditInfo> auditInfo, hstring_ref messageFromApp, ProtectionPolicyRequestAccessBehavior behavior) { Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics4>()->_RequestAccessToFilesForProcessWithMessageAndBehaviorAsync(to_abi(sourceItemList), processId, auditInfo, messageFromApp, behavior, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<bool>> IsFileProtectionRequiredAsync(pptr<Storage::IStorageItem> target, hstring_ref identity) { Foundation::IAsyncOperation<bool>* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics4>()->_IsFileProtectionRequiredAsync(target, identity, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<bool>> IsFileProtectionRequiredForNewFileAsync(pptr<Storage::IStorageFolder> parentFolder, hstring_ref identity, hstring_ref desiredName) { Foundation::IAsyncOperation<bool>* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics4>()->_IsFileProtectionRequiredForNewFileAsync(parentFolder, identity, desiredName, &result)); return from_abi(result); }
	static hstring GetPrimaryManagedIdentityForIdentity(hstring_ref identity) { HSTRING value; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics4>()->_GetPrimaryManagedIdentityForIdentity(identity, &value)); return from_abi(value); }
	static ptr<Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>> RequestAccessAsync(hstring_ref sourceIdentity, hstring_ref targetIdentity, pptr<ProtectionPolicyAuditInfo> auditInfo) { Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics3>()->_RequestAccessWithAuditingInfoAsync(sourceIdentity, targetIdentity, auditInfo, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>> RequestAccessAsync(hstring_ref sourceIdentity, hstring_ref targetIdentity, pptr<ProtectionPolicyAuditInfo> auditInfo, hstring_ref messageFromApp) { Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics3>()->_RequestAccessWithMessageAsync(sourceIdentity, targetIdentity, auditInfo, messageFromApp, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>> RequestAccessForAppAsync(hstring_ref sourceIdentity, hstring_ref appPackageFamilyName, pptr<ProtectionPolicyAuditInfo> auditInfo) { Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics3>()->_RequestAccessForAppWithAuditingInfoAsync(sourceIdentity, appPackageFamilyName, auditInfo, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>> RequestAccessForAppAsync(hstring_ref sourceIdentity, hstring_ref appPackageFamilyName, pptr<ProtectionPolicyAuditInfo> auditInfo, hstring_ref messageFromApp) { Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics3>()->_RequestAccessForAppWithMessageAsync(sourceIdentity, appPackageFamilyName, auditInfo, messageFromApp, &result)); return from_abi(result); }
	static void LogAuditEvent(hstring_ref sourceIdentity, hstring_ref targetIdentity, pptr<ProtectionPolicyAuditInfo> auditInfo) { hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics3>()->_LogAuditEvent(sourceIdentity, targetIdentity, auditInfo)); }
	static bool HasContentBeenRevokedSince(hstring_ref identity, const Foundation::DateTime& since) { bool result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics2>()->_HasContentBeenRevokedSince(identity, since, &result)); return result; }
	static ProtectionPolicyEvaluationResult CheckAccessForApp(hstring_ref sourceIdentity, hstring_ref appPackageFamilyName) { ProtectionPolicyEvaluationResult result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics2>()->_CheckAccessForApp(sourceIdentity, appPackageFamilyName, &result)); return result; }
	static ptr<Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>> RequestAccessForAppAsync(hstring_ref sourceIdentity, hstring_ref appPackageFamilyName) { Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics2>()->_RequestAccessForAppAsync(sourceIdentity, appPackageFamilyName, &result)); return from_abi(result); }
	static EnforcementLevel GetEnforcementLevel(hstring_ref identity) { EnforcementLevel value; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics2>()->_GetEnforcementLevel(identity, &value)); return value; }
	static bool IsUserDecryptionAllowed(hstring_ref identity) { bool value; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics2>()->_IsUserDecryptionAllowed(identity, &value)); return value; }
	static bool IsProtectionUnderLockRequired(hstring_ref identity) { bool value; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics2>()->_IsProtectionUnderLockRequired(identity, &value)); return value; }
	static bool IsIdentityManaged(hstring_ref identity) { bool result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics>()->_IsIdentityManaged(identity, &result)); return result; }
	static bool TryApplyProcessUIPolicy(hstring_ref identity) { bool result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics>()->_TryApplyProcessUIPolicy(identity, &result)); return result; }
	static void ClearProcessUIPolicy() { hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics>()->_ClearProcessUIPolicy()); }
	static ptr<ThreadNetworkContext> CreateCurrentThreadNetworkContext(hstring_ref identity) { ThreadNetworkContext* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics>()->_CreateCurrentThreadNetworkContext(identity, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<hstring>> GetPrimaryManagedIdentityForNetworkEndpointAsync(pptr<Networking::HostName> endpointHost) { Foundation::IAsyncOperation<HSTRING>* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics>()->_GetPrimaryManagedIdentityForNetworkEndpointAsync(endpointHost, &result)); return from_abi(result); }
	static void RevokeContent(hstring_ref identity) { hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics>()->_RevokeContent(identity)); }
	static ptr<ProtectionPolicyManager> GetForCurrentView() { ProtectionPolicyManager* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics>()->_GetForCurrentView(&result)); return from_abi(result); }
	static ProtectionPolicyEvaluationResult CheckAccess(hstring_ref sourceIdentity, hstring_ref targetIdentity) { ProtectionPolicyEvaluationResult result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics>()->_CheckAccess(sourceIdentity, targetIdentity, &result)); return result; }
	static ptr<Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>> RequestAccessAsync(hstring_ref sourceIdentity, hstring_ref targetIdentity) { Foundation::IAsyncOperation<ProtectionPolicyEvaluationResult>* result; hrcheck(get_activation_factory<ProtectionPolicyManager, IProtectionPolicyManagerStatics>()->_RequestAccessAsync(sourceIdentity, targetIdentity, &result)); return from_abi(result); }
};
template<typename X> typename ProtectionPolicyManager_statics<X>::_ProtectedAccessResumed ProtectionPolicyManager_statics<X>::ProtectedAccessResumed;
template<typename X> typename ProtectionPolicyManager_statics<X>::_ProtectedAccessSuspending ProtectionPolicyManager_statics<X>::ProtectedAccessSuspending;
template<typename X> typename ProtectionPolicyManager_statics<X>::_ProtectedContentRevoked ProtectionPolicyManager_statics<X>::ProtectedContentRevoked;
template<typename X> typename ProtectionPolicyManager_statics<X>::_IsProtectionEnabled ProtectionPolicyManager_statics<X>::IsProtectionEnabled;
template<typename X> typename ProtectionPolicyManager_statics<X>::_PolicyChanged ProtectionPolicyManager_statics<X>::PolicyChanged;
template<typename X> typename ProtectionPolicyManager_statics<X>::_PrimaryManagedIdentity ProtectionPolicyManager_statics<X>::PrimaryManagedIdentity;

template<typename X> struct statics<ProtectionPolicyManager, X> : X, Windows::Security::EnterpriseData::ProtectionPolicyManager_statics<void> {
	typedef typename X::root_type ProtectionPolicyManager;
};
struct ProtectionPolicyManager : generate<ProtectionPolicyManager> {};

// IProtectedAccessSuspendingEventArgs
struct IProtectedAccessSuspendingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Identities(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _get_Deadline(Foundation::DateTime *value);
	virtual STDMETHODIMP _GetDeferral(Foundation::Deferral* *result);
};
template<typename X> struct IProtectedAccessSuspendingEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IProtectedAccessSuspendingEventArgs_adaptor::Deadline)->_get_Deadline(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} Deadline;
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&IProtectedAccessSuspendingEventArgs_adaptor::Identities)->_get_Identities(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} Identities;
	};
	ptr<Foundation::Deferral> GetDeferral() { Foundation::Deferral* result; hrcheck(X::get()->_GetDeferral(&result)); return from_abi(result); }
	IProtectedAccessSuspendingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IProtectedAccessSuspendingEventArgs, X> : Windows::Security::EnterpriseData::IProtectedAccessSuspendingEventArgs_adaptor<X> { typedef adapt IProtectedAccessSuspendingEventArgs; };
struct IProtectedAccessSuspendingEventArgs : IProtectedAccessSuspendingEventArgs_raw, generate<IProtectedAccessSuspendingEventArgs> {};

// ProtectedAccessSuspendingEventArgs
template<typename X> struct statics<ProtectedAccessSuspendingEventArgs, X> : X {
	typedef typename X::root_type ProtectedAccessSuspendingEventArgs;
};
struct ProtectedAccessSuspendingEventArgs : generate<ProtectedAccessSuspendingEventArgs> {};

// IProtectedAccessResumedEventArgs
struct IProtectedAccessResumedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Identities(Foundation::Collections::IVectorView<HSTRING>* *value);
};
template<typename X> struct IProtectedAccessResumedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&IProtectedAccessResumedEventArgs_adaptor::Identities)->_get_Identities(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} Identities;
	};
	IProtectedAccessResumedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IProtectedAccessResumedEventArgs, X> : Windows::Security::EnterpriseData::IProtectedAccessResumedEventArgs_adaptor<X> { typedef adapt IProtectedAccessResumedEventArgs; };
struct IProtectedAccessResumedEventArgs : IProtectedAccessResumedEventArgs_raw, generate<IProtectedAccessResumedEventArgs> {};

// ProtectedAccessResumedEventArgs
template<typename X> struct statics<ProtectedAccessResumedEventArgs, X> : X {
	typedef typename X::root_type ProtectedAccessResumedEventArgs;
};
struct ProtectedAccessResumedEventArgs : generate<ProtectedAccessResumedEventArgs> {};

// IProtectedContentRevokedEventArgs
struct IProtectedContentRevokedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Identities(Foundation::Collections::IVectorView<HSTRING>* *value);
};
template<typename X> struct IProtectedContentRevokedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&IProtectedContentRevokedEventArgs_adaptor::Identities)->_get_Identities(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} Identities;
	};
	IProtectedContentRevokedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IProtectedContentRevokedEventArgs, X> : Windows::Security::EnterpriseData::IProtectedContentRevokedEventArgs_adaptor<X> { typedef adapt IProtectedContentRevokedEventArgs; };
struct IProtectedContentRevokedEventArgs : IProtectedContentRevokedEventArgs_raw, generate<IProtectedContentRevokedEventArgs> {};

// ProtectedContentRevokedEventArgs
template<typename X> struct statics<ProtectedContentRevokedEventArgs, X> : X {
	typedef typename X::root_type ProtectedContentRevokedEventArgs;
};
struct ProtectedContentRevokedEventArgs : generate<ProtectedContentRevokedEventArgs> {};

// FileRevocationManager
template<typename> struct FileRevocationManager_statics {
	static ptr<Foundation::IAsyncOperation<FileProtectionStatus>> ProtectAsync(pptr<Storage::IStorageItem> storageItem, hstring_ref enterpriseIdentity) { Foundation::IAsyncOperation<FileProtectionStatus>* result; hrcheck(get_activation_factory<FileRevocationManager, IFileRevocationManagerStatics>()->_ProtectAsync(storageItem, enterpriseIdentity, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<bool>> CopyProtectionAsync(pptr<Storage::IStorageItem> sourceStorageItem, pptr<Storage::IStorageItem> targetStorageItem) { Foundation::IAsyncOperation<bool>* result; hrcheck(get_activation_factory<FileRevocationManager, IFileRevocationManagerStatics>()->_CopyProtectionAsync(sourceStorageItem, targetStorageItem, &result)); return from_abi(result); }
	static void Revoke(hstring_ref enterpriseIdentity) { hrcheck(get_activation_factory<FileRevocationManager, IFileRevocationManagerStatics>()->_Revoke(enterpriseIdentity)); }
	static ptr<Foundation::IAsyncOperation<FileProtectionStatus>> GetStatusAsync(pptr<Storage::IStorageItem> storageItem) { Foundation::IAsyncOperation<FileProtectionStatus>* result; hrcheck(get_activation_factory<FileRevocationManager, IFileRevocationManagerStatics>()->_GetStatusAsync(storageItem, &result)); return from_abi(result); }
};

template<typename X> struct statics<FileRevocationManager, X> : X, Windows::Security::EnterpriseData::FileRevocationManager_statics<void> {
	typedef typename X::root_type FileRevocationManager;
};
struct FileRevocationManager : generate<FileRevocationManager> {};

// FileProtectionManager
template<typename> struct FileProtectionManager_statics {
	static ptr<Foundation::IAsyncOperation<ptr<FileProtectionInfo>>> UnprotectAsync(pptr<Storage::IStorageItem> target) { Foundation::IAsyncOperation<FileProtectionInfo*>* result; hrcheck(get_activation_factory<FileProtectionManager, IFileProtectionManagerStatics3>()->_UnprotectAsync(target, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<FileProtectionInfo>>> UnprotectAsync(pptr<Storage::IStorageItem> target, pptr<FileUnprotectOptions> options) { Foundation::IAsyncOperation<FileProtectionInfo*>* result; hrcheck(get_activation_factory<FileProtectionManager, IFileProtectionManagerStatics3>()->_UnprotectWithOptionsAsync(target, options, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<bool>> IsContainerAsync(pptr<Storage::IStorageFile> file) { Foundation::IAsyncOperation<bool>* result; hrcheck(get_activation_factory<FileProtectionManager, IFileProtectionManagerStatics2>()->_IsContainerAsync(file, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<ProtectedContainerImportResult>>> LoadFileFromContainerAsync(pptr<Storage::IStorageFile> containerFile, pptr<Storage::IStorageItem> target, Storage::NameCollisionOption collisionOption) { Foundation::IAsyncOperation<ProtectedContainerImportResult*>* result; hrcheck(get_activation_factory<FileProtectionManager, IFileProtectionManagerStatics2>()->_LoadFileFromContainerWithTargetAndNameCollisionOptionAsync(containerFile, target, collisionOption, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<ProtectedContainerExportResult>>> SaveFileAsContainerAsync(pptr<Storage::IStorageFile> protectedFile, pptr<Foundation::Collections::IIterable<hstring>> sharedWithIdentities) { Foundation::IAsyncOperation<ProtectedContainerExportResult*>* result; hrcheck(get_activation_factory<FileProtectionManager, IFileProtectionManagerStatics2>()->_SaveFileAsContainerWithSharingAsync(protectedFile, to_abi(sharedWithIdentities), &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<FileProtectionInfo>>> ProtectAsync(pptr<Storage::IStorageItem> target, hstring_ref identity) { Foundation::IAsyncOperation<FileProtectionInfo*>* result; hrcheck(get_activation_factory<FileProtectionManager, IFileProtectionManagerStatics>()->_ProtectAsync(target, identity, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<bool>> CopyProtectionAsync(pptr<Storage::IStorageItem> source, pptr<Storage::IStorageItem> target) { Foundation::IAsyncOperation<bool>* result; hrcheck(get_activation_factory<FileProtectionManager, IFileProtectionManagerStatics>()->_CopyProtectionAsync(source, target, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<FileProtectionInfo>>> GetProtectionInfoAsync(pptr<Storage::IStorageItem> source) { Foundation::IAsyncOperation<FileProtectionInfo*>* result; hrcheck(get_activation_factory<FileProtectionManager, IFileProtectionManagerStatics>()->_GetProtectionInfoAsync(source, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<ProtectedContainerExportResult>>> SaveFileAsContainerAsync(pptr<Storage::IStorageFile> protectedFile) { Foundation::IAsyncOperation<ProtectedContainerExportResult*>* result; hrcheck(get_activation_factory<FileProtectionManager, IFileProtectionManagerStatics>()->_SaveFileAsContainerAsync(protectedFile, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<ProtectedContainerImportResult>>> LoadFileFromContainerAsync(pptr<Storage::IStorageFile> containerFile) { Foundation::IAsyncOperation<ProtectedContainerImportResult*>* result; hrcheck(get_activation_factory<FileProtectionManager, IFileProtectionManagerStatics>()->_LoadFileFromContainerAsync(containerFile, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<ProtectedContainerImportResult>>> LoadFileFromContainerAsync(pptr<Storage::IStorageFile> containerFile, pptr<Storage::IStorageItem> target) { Foundation::IAsyncOperation<ProtectedContainerImportResult*>* result; hrcheck(get_activation_factory<FileProtectionManager, IFileProtectionManagerStatics>()->_LoadFileFromContainerWithTargetAsync(containerFile, target, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<ProtectedFileCreateResult>>> CreateProtectedAndOpenAsync(pptr<Storage::IStorageFolder> parentFolder, hstring_ref desiredName, hstring_ref identity, Storage::CreationCollisionOption collisionOption) { Foundation::IAsyncOperation<ProtectedFileCreateResult*>* result; hrcheck(get_activation_factory<FileProtectionManager, IFileProtectionManagerStatics>()->_CreateProtectedAndOpenAsync(parentFolder, desiredName, identity, collisionOption, &result)); return from_abi(result); }
};

template<typename X> struct statics<FileProtectionManager, X> : X, Windows::Security::EnterpriseData::FileProtectionManager_statics<void> {
	typedef typename X::root_type FileProtectionManager;
};
struct FileProtectionManager : generate<FileProtectionManager> {};

// DataProtectionManager
template<typename> struct DataProtectionManager_statics {
	static ptr<Foundation::IAsyncOperation<ptr<BufferProtectUnprotectResult>>> ProtectAsync(pptr<Storage::Streams::IBuffer> data, hstring_ref identity) { Foundation::IAsyncOperation<BufferProtectUnprotectResult*>* result; hrcheck(get_activation_factory<DataProtectionManager, IDataProtectionManagerStatics>()->_ProtectAsync(data, identity, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<BufferProtectUnprotectResult>>> UnprotectAsync(pptr<Storage::Streams::IBuffer> data) { Foundation::IAsyncOperation<BufferProtectUnprotectResult*>* result; hrcheck(get_activation_factory<DataProtectionManager, IDataProtectionManagerStatics>()->_UnprotectAsync(data, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<DataProtectionInfo>>> ProtectStreamAsync(pptr<Storage::Streams::IInputStream> unprotectedStream, hstring_ref identity, pptr<Storage::Streams::IOutputStream> protectedStream) { Foundation::IAsyncOperation<DataProtectionInfo*>* result; hrcheck(get_activation_factory<DataProtectionManager, IDataProtectionManagerStatics>()->_ProtectStreamAsync(unprotectedStream, identity, protectedStream, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<DataProtectionInfo>>> UnprotectStreamAsync(pptr<Storage::Streams::IInputStream> protectedStream, pptr<Storage::Streams::IOutputStream> unprotectedStream) { Foundation::IAsyncOperation<DataProtectionInfo*>* result; hrcheck(get_activation_factory<DataProtectionManager, IDataProtectionManagerStatics>()->_UnprotectStreamAsync(protectedStream, unprotectedStream, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<DataProtectionInfo>>> GetProtectionInfoAsync(pptr<Storage::Streams::IBuffer> protectedData) { Foundation::IAsyncOperation<DataProtectionInfo*>* result; hrcheck(get_activation_factory<DataProtectionManager, IDataProtectionManagerStatics>()->_GetProtectionInfoAsync(protectedData, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<DataProtectionInfo>>> GetStreamProtectionInfoAsync(pptr<Storage::Streams::IInputStream> protectedStream) { Foundation::IAsyncOperation<DataProtectionInfo*>* result; hrcheck(get_activation_factory<DataProtectionManager, IDataProtectionManagerStatics>()->_GetStreamProtectionInfoAsync(protectedStream, &result)); return from_abi(result); }
};

template<typename X> struct statics<DataProtectionManager, X> : X, Windows::Security::EnterpriseData::DataProtectionManager_statics<void> {
	typedef typename X::root_type DataProtectionManager;
};
struct DataProtectionManager : generate<DataProtectionManager> {};
}}}
} // namespace iso_winrt
