#pragma once
// generated by isopod tools
// namespaces:
// Windows.Storage.AccessCache

#include "Windows.Storage.AccessCache.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.Foundation.Collections.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Storage {
struct IStorageItem;
struct StorageFolder;
struct StorageFile;
}}

// defs

template<> struct def<Windows::Storage::AccessCache::AccessListEntry> : value_type<HSTRING, HSTRING> {};
template<> struct def<Windows::Storage::AccessCache::IItemRemovedEventArgs> : interface_type<> {};
template<> struct def<Windows::Storage::AccessCache::AccessListEntryView> : class_type<Platform::Object, Windows::Foundation::Collections::IVectorView<Windows::Storage::AccessCache::AccessListEntry>, Windows::Foundation::Collections::IIterable<Windows::Storage::AccessCache::AccessListEntry>> {};
template<> struct def<Windows::Storage::AccessCache::AccessCacheOptions> : enum_type<unsigned> {};
template<> struct def<Windows::Storage::AccessCache::IStorageItemAccessList> : overridable_type<> {};
template<> struct def<Windows::Storage::AccessCache::IStorageItemMostRecentlyUsedList> : interface_type<Windows::Storage::AccessCache::IStorageItemAccessList> {};
template<> struct def<Windows::Storage::AccessCache::RecentStorageItemVisibility> : enum_type<int> {};
template<> struct def<Windows::Storage::AccessCache::IStorageItemMostRecentlyUsedList2> : interface_type<Windows::Storage::AccessCache::IStorageItemMostRecentlyUsedList> {};
template<> struct def<Windows::Storage::AccessCache::StorageItemMostRecentlyUsedList> : class_type<Platform::Object, Windows::Storage::AccessCache::IStorageItemMostRecentlyUsedList, Windows::Storage::AccessCache::IStorageItemMostRecentlyUsedList2> {};
template<> struct def<Windows::Storage::AccessCache::ItemRemovedEventArgs> : class_type<Platform::Object, Windows::Storage::AccessCache::IItemRemovedEventArgs> {};
template<> struct def<Windows::Storage::AccessCache::IStorageApplicationPermissionsStatics> : interface_type<> {};
template<> struct def<Windows::Storage::AccessCache::StorageItemAccessList> : class_type<Platform::Object, Windows::Storage::AccessCache::IStorageItemAccessList> {};
template<> struct def<Windows::Storage::AccessCache::StorageApplicationPermissions> : class_type<Platform::Object, Platform::Object> {};

// uuids

template<> struct uuid<Windows::Storage::AccessCache::IItemRemovedEventArgs> { define_guid(0x59677E5C, 0x55BE, 0x4C66, 0xBA, 0x66, 0x5E, 0xAE, 0xA7, 0x9D, 0x26, 0x31);};
template<> struct uuid<Windows::Storage::AccessCache::IStorageItemAccessList> { define_guid(0x2CAFF6AD, 0xDE90, 0x47F5, 0xB2, 0xC3, 0xDD, 0x36, 0xC9, 0xFD, 0xD4, 0x53);};
template<> struct uuid<Windows::Storage::AccessCache::IStorageItemMostRecentlyUsedList> { define_guid(0x16239D5, 0x510D, 0x411E, 0x8C, 0xF1, 0xC3, 0xD1, 0xEF, 0xFA, 0x4C, 0x33);};
template<> struct uuid<Windows::Storage::AccessCache::IStorageItemMostRecentlyUsedList2> { define_guid(0xDA481EA0, 0xED8D, 0x4731, 0xA1, 0xDB, 0xE4, 0x4E, 0xE2, 0x20, 0x40, 0x93);};
template<> struct uuid<Windows::Storage::AccessCache::IStorageApplicationPermissionsStatics> { define_guid(0x4391DFAA, 0xD033, 0x48F9, 0x80, 0x60, 0x3E, 0xC8, 0x47, 0xD2, 0xE3, 0xF1);};

// types

namespace Windows { namespace Storage { namespace AccessCache {

// IItemRemovedEventArgs
struct IItemRemovedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_RemovedEntry(AccessListEntry *value);
};
template<typename X> struct IItemRemovedEventArgs_adaptor : X {
	union {
		struct : property {
			AccessListEntry get() { AccessListEntry value; hrcheck(enc(&IItemRemovedEventArgs_adaptor::RemovedEntry)->_get_RemovedEntry(&value)); return value; }
			AccessListEntry operator()() { return get(); }
			operator AccessListEntry () { return get(); }
		} RemovedEntry;
	};
	IItemRemovedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IItemRemovedEventArgs, X> : Windows::Storage::AccessCache::IItemRemovedEventArgs_adaptor<X> { typedef adapt IItemRemovedEventArgs; };
struct IItemRemovedEventArgs : IItemRemovedEventArgs_raw, generate<IItemRemovedEventArgs> {};

// AccessListEntryView
template<typename X> struct statics<AccessListEntryView, X> : X {
	typedef typename X::root_type AccessListEntryView;
};
struct AccessListEntryView : generate<AccessListEntryView> {};

// IStorageItemAccessList
struct IStorageItemAccessList_raw : IInspectable {
	virtual STDMETHODIMP _AddOverloadDefaultMetadata(IStorageItem* file, HSTRING *token) = 0;
	virtual STDMETHODIMP _Add(IStorageItem* file, HSTRING metadata, HSTRING *token) = 0;
	virtual STDMETHODIMP _AddOrReplaceOverloadDefaultMetadata(HSTRING token, IStorageItem* file) = 0;
	virtual STDMETHODIMP _AddOrReplace(HSTRING token, IStorageItem* file, HSTRING metadata) = 0;
	virtual STDMETHODIMP _GetItemAsync(HSTRING token, Foundation::IAsyncOperation<IStorageItem*>* *operation) = 0;
	virtual STDMETHODIMP _GetFileAsync(HSTRING token, Foundation::IAsyncOperation<StorageFile*>* *operation) = 0;
	virtual STDMETHODIMP _GetFolderAsync(HSTRING token, Foundation::IAsyncOperation<StorageFolder*>* *operation) = 0;
	virtual STDMETHODIMP _GetItemWithOptionsAsync(HSTRING token, AccessCacheOptions options, Foundation::IAsyncOperation<IStorageItem*>* *operation) = 0;
	virtual STDMETHODIMP _GetFileWithOptionsAsync(HSTRING token, AccessCacheOptions options, Foundation::IAsyncOperation<StorageFile*>* *operation) = 0;
	virtual STDMETHODIMP _GetFolderWithOptionsAsync(HSTRING token, AccessCacheOptions options, Foundation::IAsyncOperation<StorageFolder*>* *operation) = 0;
	virtual STDMETHODIMP _Remove(HSTRING token) = 0;
	virtual STDMETHODIMP _ContainsItem(HSTRING token, bool *value) = 0;
	virtual STDMETHODIMP _Clear() = 0;
	virtual STDMETHODIMP _CheckAccess(IStorageItem* file, bool *value) = 0;
	virtual STDMETHODIMP _get_Entries(AccessListEntryView* *entries) = 0;
	virtual STDMETHODIMP _get_MaximumItemsAllowed(unsigned *value) = 0;
};
template<typename X> struct IStorageItemAccessList_adaptor : X {
	union {
		struct : property {
			ptr<AccessListEntryView> get() { AccessListEntryView* entries; hrcheck(enc(&IStorageItemAccessList_adaptor::Entries)->_get_Entries(&entries)); return from_abi(entries); }
			ptr<AccessListEntryView> operator()() { return get(); }
			operator ptr<AccessListEntryView> () { return get(); }
			ptr<AccessListEntryView> operator->() { return get(); }
		} Entries;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IStorageItemAccessList_adaptor::MaximumItemsAllowed)->_get_MaximumItemsAllowed(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} MaximumItemsAllowed;
	};
	hstring Add(pptr<IStorageItem> file) { HSTRING token; hrcheck(X::get()->_AddOverloadDefaultMetadata(file, &token)); return from_abi(token); }
	hstring Add(pptr<IStorageItem> file, hstring_ref metadata) { HSTRING token; hrcheck(X::get()->_Add(file, metadata, &token)); return from_abi(token); }
	void AddOrReplace(hstring_ref token, pptr<IStorageItem> file) { hrcheck(X::get()->_AddOrReplaceOverloadDefaultMetadata(token, file)); }
	void AddOrReplace(hstring_ref token, pptr<IStorageItem> file, hstring_ref metadata) { hrcheck(X::get()->_AddOrReplace(token, file, metadata)); }
	ptr<Foundation::IAsyncOperation<ptr<IStorageItem>>> GetItemAsync(hstring_ref token) { Foundation::IAsyncOperation<IStorageItem*>* operation; hrcheck(X::get()->_GetItemAsync(token, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> GetFileAsync(hstring_ref token) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(X::get()->_GetFileAsync(token, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorageFolder>>> GetFolderAsync(hstring_ref token) { Foundation::IAsyncOperation<StorageFolder*>* operation; hrcheck(X::get()->_GetFolderAsync(token, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<IStorageItem>>> GetItemAsync(hstring_ref token, AccessCacheOptions options) { Foundation::IAsyncOperation<IStorageItem*>* operation; hrcheck(X::get()->_GetItemWithOptionsAsync(token, options, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> GetFileAsync(hstring_ref token, AccessCacheOptions options) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(X::get()->_GetFileWithOptionsAsync(token, options, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorageFolder>>> GetFolderAsync(hstring_ref token, AccessCacheOptions options) { Foundation::IAsyncOperation<StorageFolder*>* operation; hrcheck(X::get()->_GetFolderWithOptionsAsync(token, options, &operation)); return from_abi(operation); }
	void Remove(hstring_ref token) { hrcheck(X::get()->_Remove(token)); }
	bool ContainsItem(hstring_ref token) { bool value; hrcheck(X::get()->_ContainsItem(token, &value)); return value; }
	void Clear() { hrcheck(X::get()->_Clear()); }
	bool CheckAccess(pptr<IStorageItem> file) { bool value; hrcheck(X::get()->_CheckAccess(file, &value)); return value; }
	IStorageItemAccessList_adaptor() {}
};
template<typename X> struct adapt<IStorageItemAccessList, X> : Windows::Storage::AccessCache::IStorageItemAccessList_adaptor<X> { typedef adapt IStorageItemAccessList; };
template<typename X> struct IStorageItemAccessList_unadaptor : X {
	STDMETHODIMP _AddOverloadDefaultMetadata(IStorageItem* file, HSTRING *token) { return hrtry([&, this] { *token = to_abi(X::get()->Add(file)); }); }
	STDMETHODIMP _Add(IStorageItem* file, HSTRING metadata, HSTRING *token) { return hrtry([&, this] { *token = to_abi(X::get()->Add(file, metadata)); }); }
	STDMETHODIMP _AddOrReplaceOverloadDefaultMetadata(HSTRING token, IStorageItem* file) { return hrtry([&, this] { X::get()->AddOrReplace(token, file); }); }
	STDMETHODIMP _AddOrReplace(HSTRING token, IStorageItem* file, HSTRING metadata) { return hrtry([&, this] { X::get()->AddOrReplace(token, file, metadata); }); }
	STDMETHODIMP _GetItemAsync(HSTRING token, Foundation::IAsyncOperation<IStorageItem*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetItemAsync(token)); }); }
	STDMETHODIMP _GetFileAsync(HSTRING token, Foundation::IAsyncOperation<StorageFile*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetFileAsync(token)); }); }
	STDMETHODIMP _GetFolderAsync(HSTRING token, Foundation::IAsyncOperation<StorageFolder*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetFolderAsync(token)); }); }
	STDMETHODIMP _GetItemWithOptionsAsync(HSTRING token, AccessCacheOptions options, Foundation::IAsyncOperation<IStorageItem*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetItemAsync(token, options)); }); }
	STDMETHODIMP _GetFileWithOptionsAsync(HSTRING token, AccessCacheOptions options, Foundation::IAsyncOperation<StorageFile*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetFileAsync(token, options)); }); }
	STDMETHODIMP _GetFolderWithOptionsAsync(HSTRING token, AccessCacheOptions options, Foundation::IAsyncOperation<StorageFolder*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetFolderAsync(token, options)); }); }
	STDMETHODIMP _Remove(HSTRING token) { return hrtry([&, this] { X::get()->Remove(token); }); }
	STDMETHODIMP _ContainsItem(HSTRING token, bool *value) { return hrtry([&, this] { *value = X::get()->ContainsItem(token); }); }
	STDMETHODIMP _Clear() { return hrtry([&, this] { X::get()->Clear(); }); }
	STDMETHODIMP _CheckAccess(IStorageItem* file, bool *value) { return hrtry([&, this] { *value = X::get()->CheckAccess(file); }); }
	STDMETHODIMP _get_Entries(AccessListEntryView* *entries) { return hrtry([&, this] { get_prop(entries, Entries); }); }
	STDMETHODIMP _get_MaximumItemsAllowed(unsigned *value) { return hrtry([&, this] { get_prop(value, MaximumItemsAllowed); }); }
};
template<typename X> struct unadapt<IStorageItemAccessList, X> : Windows::Storage::AccessCache::IStorageItemAccessList_unadaptor<X> {};
struct IStorageItemAccessList : IStorageItemAccessList_raw, generate<IStorageItemAccessList> {};

// IStorageItemMostRecentlyUsedList
struct IStorageItemMostRecentlyUsedList_raw : IInspectable {
	virtual STDMETHODIMP _add_ItemRemoved(Foundation::TypedEventHandler<StorageItemMostRecentlyUsedList*, ItemRemovedEventArgs*>* handler, Foundation::EventRegistrationToken *eventCookie);
	virtual STDMETHODIMP _remove_ItemRemoved(Foundation::EventRegistrationToken eventCookie);
};
template<typename X> struct IStorageItemMostRecentlyUsedList_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<StorageItemMostRecentlyUsedList>, ptr<ItemRemovedEventArgs>>> handler) { Foundation::EventRegistrationToken eventCookie; hrcheck(enc(&IStorageItemMostRecentlyUsedList_adaptor::ItemRemoved)->_add_ItemRemoved(to_abi(handler), &eventCookie)); return eventCookie; }
			void operator-=(const Foundation::EventRegistrationToken& eventCookie) { hrcheck(enc(&IStorageItemMostRecentlyUsedList_adaptor::ItemRemoved)->_remove_ItemRemoved(eventCookie)); }
		} ItemRemoved;
	};
	IStorageItemMostRecentlyUsedList_adaptor() {}
};
template<typename X> struct adapt<IStorageItemMostRecentlyUsedList, X> : Windows::Storage::AccessCache::IStorageItemMostRecentlyUsedList_adaptor<X> { typedef adapt IStorageItemMostRecentlyUsedList; };
struct IStorageItemMostRecentlyUsedList : IStorageItemMostRecentlyUsedList_raw, generate<IStorageItemMostRecentlyUsedList> {};

// IStorageItemMostRecentlyUsedList2
struct IStorageItemMostRecentlyUsedList2_raw : IInspectable {
	virtual STDMETHODIMP _AddWithMetadataAndVisibility(IStorageItem* file, HSTRING metadata, RecentStorageItemVisibility visibility, HSTRING *token);
	virtual STDMETHODIMP _AddOrReplaceWithMetadataAndVisibility(HSTRING token, IStorageItem* file, HSTRING metadata, RecentStorageItemVisibility visibility);
};
template<typename X> struct IStorageItemMostRecentlyUsedList2_adaptor : X {
	hstring Add(pptr<IStorageItem> file, hstring_ref metadata, RecentStorageItemVisibility visibility) { HSTRING token; hrcheck(X::get()->_AddWithMetadataAndVisibility(file, metadata, visibility, &token)); return from_abi(token); }
	void AddOrReplace(hstring_ref token, pptr<IStorageItem> file, hstring_ref metadata, RecentStorageItemVisibility visibility) { hrcheck(X::get()->_AddOrReplaceWithMetadataAndVisibility(token, file, metadata, visibility)); }
};
template<typename X> struct adapt<IStorageItemMostRecentlyUsedList2, X> : Windows::Storage::AccessCache::IStorageItemMostRecentlyUsedList2_adaptor<X> { typedef adapt IStorageItemMostRecentlyUsedList2; };
struct IStorageItemMostRecentlyUsedList2 : IStorageItemMostRecentlyUsedList2_raw, generate<IStorageItemMostRecentlyUsedList2> {};

// StorageItemMostRecentlyUsedList
template<typename X> struct statics<StorageItemMostRecentlyUsedList, X> : X {
	typedef typename X::root_type StorageItemMostRecentlyUsedList;
};
struct StorageItemMostRecentlyUsedList : generate<StorageItemMostRecentlyUsedList> {
	using IStorageItemAccessList::GetItemAsync;
	using IStorageItemAccessList::GetFileAsync;
	using IStorageItemAccessList::GetFolderAsync;
	using IStorageItemMostRecentlyUsedList2::AddOrReplace;
	using IStorageItemAccessList::AddOrReplace;
	using IStorageItemMostRecentlyUsedList2::Add;
	using IStorageItemAccessList::Add;
};

// ItemRemovedEventArgs
template<typename X> struct statics<ItemRemovedEventArgs, X> : X {
	typedef typename X::root_type ItemRemovedEventArgs;
};
struct ItemRemovedEventArgs : generate<ItemRemovedEventArgs> {};

// IStorageApplicationPermissionsStatics
struct IStorageApplicationPermissionsStatics : IInspectable {
	virtual STDMETHODIMP _get_FutureAccessList(StorageItemAccessList* *value);
	virtual STDMETHODIMP _get_MostRecentlyUsedList(StorageItemMostRecentlyUsedList* *value);
};

// StorageItemAccessList
template<typename X> struct statics<StorageItemAccessList, X> : X {
	typedef typename X::root_type StorageItemAccessList;
};
struct StorageItemAccessList : generate<StorageItemAccessList> {
	using IStorageItemAccessList::GetItemAsync;
	using IStorageItemAccessList::GetFileAsync;
	using IStorageItemAccessList::GetFolderAsync;
	using IStorageItemAccessList::AddOrReplace;
	using IStorageItemAccessList::Add;
};

// StorageApplicationPermissions
template<typename> struct StorageApplicationPermissions_statics {
	static struct _FutureAccessList : property {
		ptr<StorageItemAccessList> get() { StorageItemAccessList* value; hrcheck(get_activation_factory<StorageApplicationPermissions, IStorageApplicationPermissionsStatics>()->_get_FutureAccessList(&value)); return from_abi(value); }
		ptr<StorageItemAccessList> operator()() { return get(); }
		operator ptr<StorageItemAccessList> () { return get(); }
		ptr<StorageItemAccessList> operator->() { return get(); }
	} FutureAccessList;
	static struct _MostRecentlyUsedList : property {
		ptr<StorageItemMostRecentlyUsedList> get() { StorageItemMostRecentlyUsedList* value; hrcheck(get_activation_factory<StorageApplicationPermissions, IStorageApplicationPermissionsStatics>()->_get_MostRecentlyUsedList(&value)); return from_abi(value); }
		ptr<StorageItemMostRecentlyUsedList> operator()() { return get(); }
		operator ptr<StorageItemMostRecentlyUsedList> () { return get(); }
		ptr<StorageItemMostRecentlyUsedList> operator->() { return get(); }
	} MostRecentlyUsedList;
};
template<typename X> typename StorageApplicationPermissions_statics<X>::_FutureAccessList StorageApplicationPermissions_statics<X>::FutureAccessList;
template<typename X> typename StorageApplicationPermissions_statics<X>::_MostRecentlyUsedList StorageApplicationPermissions_statics<X>::MostRecentlyUsedList;

template<typename X> struct statics<StorageApplicationPermissions, X> : X, Windows::Storage::AccessCache::StorageApplicationPermissions_statics<void> {
	typedef typename X::root_type StorageApplicationPermissions;
};
struct StorageApplicationPermissions : generate<StorageApplicationPermissions> {};
}}}
} // namespace iso_winrt
