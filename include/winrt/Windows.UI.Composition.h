#pragma once
// generated by isopod tools
// namespaces:
// Windows.UI.Composition

#include "Windows.UI.Composition.0.h"
#include "Windows.Foundation.Numerics.0.h"
#include "Windows.Graphics.DirectX.0.h"
#include "Windows.UI.0.h"
#include "Windows.Foundation.Collections.h"
#include "Windows.Foundation.h"
#include "Windows.Graphics.Effects.h"
#include "Windows.Graphics.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace System {
struct DispatcherQueue;
}
namespace UI { namespace Core {
struct CoreDispatcher;
}}}

// defs

template<> struct def<Windows::UI::Composition::AnimationControllerProgressBehavior> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::AnimationDirection> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::AnimationIterationBehavior> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::AnimationDelayBehavior> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::AnimationStopBehavior> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::CompositionBatchTypes> : enum_type<unsigned> {};
template<> struct def<Windows::UI::Composition::CompositionBackfaceVisibility> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::CompositionBitmapInterpolationMode> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::CompositionBorderMode> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::CompositionColorSpace> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::CompositionCompositeMode> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::CompositionDropShadowSourcePolicy> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::CompositionEffectFactoryLoadStatus> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::CompositionGetValueStatus> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::CompositionGradientExtendMode> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::CompositionStretch> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::CompositionStrokeCap> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::CompositionStrokeLineJoin> : enum_type<int> {};
template<> struct def<Windows::UI::Composition::IAmbientLight> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IAmbientLight2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IAnimationController> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IAnimationControllerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IBounceScalarNaturalMotionAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IBounceVector2NaturalMotionAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IBounceVector3NaturalMotionAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IColorKeyFrameAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionObjectFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionObject4> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionObject3> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionObject2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionObject> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionObject> : class_type<Platform::Object, Windows::UI::Composition::ICompositionObject, Windows::Foundation::IClosable, Windows::UI::Composition::ICompositionObject2, Windows::UI::Composition::ICompositionObject3, Windows::UI::Composition::ICompositionObject4> {};
template<> struct def<Windows::UI::Composition::ICompositionAnimation2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionAnimation3> : interface_type<> {};
template<> struct def<Windows::UI::Composition::InitialValueExpressionCollection> : class_type<Windows::UI::Composition::CompositionObject, Windows::Foundation::Collections::IMap<HSTRING, HSTRING>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, HSTRING>>>> {};
template<> struct def<Windows::UI::Composition::ICompositionAnimationBase> : overridable_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionAnimationFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionAnimation> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionAnimation, Windows::UI::Composition::ICompositionAnimation2, Windows::UI::Composition::ICompositionAnimationBase, Windows::UI::Composition::ICompositionAnimation3> {};
template<> struct def<Windows::UI::Composition::ICompositionAnimationGroup> : interface_type<Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Composition::CompositionAnimation>>> {};
template<> struct def<Windows::UI::Composition::ICompositionBackdropBrush> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionBatchCompletedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionBrush> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionCapabilities> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionCapabilitiesStatics> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionCapabilities> : class_type<Platform::Object, Windows::UI::Composition::ICompositionCapabilities> {};
template<> struct def<Windows::UI::Composition::ICompositionClip> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionClip2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionColorBrush> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionColorGradientStop> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionColorGradientStop> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionColorGradientStop> {};
template<> struct def<Windows::UI::Composition::ICompositionColorGradientStopCollection> : interface_type<Windows::Foundation::Collections::IVector<ptr<Windows::UI::Composition::CompositionColorGradientStop>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Composition::CompositionColorGradientStop>>> {};
template<> struct def<Windows::UI::Composition::ICompositionCommitBatch> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionBatchCompletedEventArgs> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionBatchCompletedEventArgs> {};
template<> struct def<Windows::UI::Composition::ICompositionContainerShape> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionShapeFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionShape> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionShape> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionShape> {};
template<> struct def<Windows::UI::Composition::CompositionShapeCollection> : class_type<Windows::UI::Composition::CompositionObject, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Composition::CompositionShape>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Composition::CompositionShape>>> {};
template<> struct def<Windows::UI::Composition::ICompositionDrawingSurface> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionDrawingSurface2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionEasingFunction> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionEasingFunctionFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionEasingFunction> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionEasingFunction> {};
template<> struct def<Windows::UI::Composition::ICompositionEllipseGeometry> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionEffectBrush> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionBrushFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionBrush> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionBrush> {};
template<> struct def<Windows::UI::Composition::ICompositionEffectFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionEffectBrush> : class_type<Windows::UI::Composition::CompositionBrush, Windows::UI::Composition::ICompositionEffectBrush> {};
template<> struct def<Windows::UI::Composition::ICompositionEffectSourceParameter> : interface_type<Windows::Graphics::Effects::IGraphicsEffectSource> {};
template<> struct def<Windows::UI::Composition::ICompositionEffectSourceParameterFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionEffectSourceParameter> : class_type<Platform::Object, Windows::UI::Composition::ICompositionEffectSourceParameter>, custom_activators {};
template<> struct def<Windows::UI::Composition::ICompositionGeometry> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionGradientBrush> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionColorGradientStopCollection> : class_type<Platform::Object, Windows::UI::Composition::ICompositionColorGradientStopCollection> {};
template<> struct def<Windows::UI::Composition::ICompositionGraphicsDevice> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionGraphicsDevice2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionGraphicsDevice> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionGraphicsDevice, Windows::UI::Composition::ICompositionGraphicsDevice2> {};
template<> struct def<Windows::UI::Composition::ICompositionLight> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionLight2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionLight3> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionLineGeometry> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionLinearGradientBrush> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionMaskBrush> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionNineGridBrush> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositorStatics> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositor5> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositor4> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositor3> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositor2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositor> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Compositor> : class_type<Platform::Object, Windows::UI::Composition::ICompositor, Windows::Foundation::IClosable, Windows::UI::Composition::ICompositor2, Windows::UI::Composition::ICompositor3, Windows::UI::Composition::ICompositor4, Windows::UI::Composition::ICompositor5> {};
template<> struct def<Windows::UI::Composition::AnimationController> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::IAnimationController> {};
template<> struct def<Windows::UI::Composition::ICompositionPath> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionPathGeometry> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionPathFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionPath> : class_type<Platform::Object, Windows::UI::Composition::ICompositionPath, Windows::Graphics::IGeometrySource2D>, custom_activators {};
template<> struct def<Windows::UI::Composition::ICompositionPropertySet> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionPropertySet2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionPropertySet> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionPropertySet, Windows::UI::Composition::ICompositionPropertySet2> {};
template<> struct def<Windows::UI::Composition::ICompositionRectangleGeometry> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionRoundedRectangleGeometry> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionScopedBatch> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionShadow> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionSpriteShape> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionGeometryFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionGeometry> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionGeometry> {};
template<> struct def<Windows::UI::Composition::CompositionStrokeDashArray> : class_type<Windows::UI::Composition::CompositionObject, Windows::Foundation::Collections::IVector<float>, Windows::Foundation::Collections::IIterable<float>> {};
template<> struct def<Windows::UI::Composition::ICompositionSurface> : overridable_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionDrawingSurfaceFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionDrawingSurface> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionDrawingSurface, Windows::UI::Composition::ICompositionSurface, Windows::UI::Composition::ICompositionDrawingSurface2> {};
template<> struct def<Windows::UI::Composition::ICompositionSurfaceBrush> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionSurfaceBrush2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionTarget> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionViewBox> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionVirtualDrawingSurface> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionVirtualDrawingSurfaceFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionVirtualDrawingSurface> : class_type<Windows::UI::Composition::CompositionDrawingSurface, Windows::UI::Composition::ICompositionVirtualDrawingSurface> {};
template<> struct def<Windows::UI::Composition::CompositionColorBrush> : class_type<Windows::UI::Composition::CompositionBrush, Windows::UI::Composition::ICompositionColorBrush> {};
template<> struct def<Windows::UI::Composition::CompositionEffectFactory> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionEffectFactory> {};
template<> struct def<Windows::UI::Composition::CompositionScopedBatch> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionScopedBatch> {};
template<> struct def<Windows::UI::Composition::CompositionSurfaceBrush> : class_type<Windows::UI::Composition::CompositionBrush, Windows::UI::Composition::ICompositionSurfaceBrush, Windows::UI::Composition::ICompositionSurfaceBrush2> {};
template<> struct def<Windows::UI::Composition::ICompositionTargetFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionTarget> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionTarget> {};
template<> struct def<Windows::UI::Composition::CompositionCommitBatch> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionCommitBatch> {};
template<> struct def<Windows::UI::Composition::CompositionAnimationGroup> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionAnimationGroup, Windows::UI::Composition::ICompositionAnimationBase> {};
template<> struct def<Windows::UI::Composition::CompositionBackdropBrush> : class_type<Windows::UI::Composition::CompositionBrush, Windows::UI::Composition::ICompositionBackdropBrush> {};
template<> struct def<Windows::UI::Composition::CompositionMaskBrush> : class_type<Windows::UI::Composition::CompositionBrush, Windows::UI::Composition::ICompositionMaskBrush> {};
template<> struct def<Windows::UI::Composition::CompositionNineGridBrush> : class_type<Windows::UI::Composition::CompositionBrush, Windows::UI::Composition::ICompositionNineGridBrush> {};
template<> struct def<Windows::UI::Composition::CompositionEllipseGeometry> : class_type<Windows::UI::Composition::CompositionGeometry, Windows::UI::Composition::ICompositionEllipseGeometry> {};
template<> struct def<Windows::UI::Composition::CompositionLineGeometry> : class_type<Windows::UI::Composition::CompositionGeometry, Windows::UI::Composition::ICompositionLineGeometry> {};
template<> struct def<Windows::UI::Composition::CompositionPathGeometry> : class_type<Windows::UI::Composition::CompositionGeometry, Windows::UI::Composition::ICompositionPathGeometry> {};
template<> struct def<Windows::UI::Composition::CompositionRectangleGeometry> : class_type<Windows::UI::Composition::CompositionGeometry, Windows::UI::Composition::ICompositionRectangleGeometry> {};
template<> struct def<Windows::UI::Composition::CompositionRoundedRectangleGeometry> : class_type<Windows::UI::Composition::CompositionGeometry, Windows::UI::Composition::ICompositionRoundedRectangleGeometry> {};
template<> struct def<Windows::UI::Composition::CompositionViewBox> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionViewBox> {};
template<> struct def<Windows::UI::Composition::IContainerVisual> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICubicBezierEasingFunction> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CubicBezierEasingFunction> : class_type<Windows::UI::Composition::CompositionEasingFunction, Windows::UI::Composition::ICubicBezierEasingFunction> {};
template<> struct def<Windows::UI::Composition::IDistantLight> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IDistantLight2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IDropShadow> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IDropShadow2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IExpressionAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IImplicitAnimationCollection> : interface_type<Windows::Foundation::Collections::IMap<HSTRING, ptr<Windows::UI::Composition::ICompositionAnimationBase>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, ptr<Windows::UI::Composition::ICompositionAnimationBase>>>>> {};
template<> struct def<Windows::UI::Composition::ImplicitAnimationCollection> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::IImplicitAnimationCollection> {};
template<> struct def<Windows::UI::Composition::IInsetClip> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IKeyFrameAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IKeyFrameAnimation2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IKeyFrameAnimation3> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ILayerVisual> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ILayerVisual2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionShadowFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionShadow> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionShadow> {};
template<> struct def<Windows::UI::Composition::DropShadow> : class_type<Windows::UI::Composition::CompositionShadow, Windows::UI::Composition::IDropShadow, Windows::UI::Composition::IDropShadow2> {};
template<> struct def<Windows::UI::Composition::ILinearEasingFunction> : interface_type<> {};
template<> struct def<Windows::UI::Composition::LinearEasingFunction> : class_type<Windows::UI::Composition::CompositionEasingFunction, Windows::UI::Composition::ILinearEasingFunction> {};
template<> struct def<Windows::UI::Composition::INaturalMotionAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IPathKeyFrameAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IPointLight> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IPointLight2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IPointLight3> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IQuaternionKeyFrameAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IRenderingDeviceReplacedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Composition::RenderingDeviceReplacedEventArgs> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::IRenderingDeviceReplacedEventArgs> {};
template<> struct def<Windows::UI::Composition::IScalarKeyFrameAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IScalarNaturalMotionAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IShapeVisual> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ISpotLight> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ISpotLight2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ISpotLight3> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ISpringScalarNaturalMotionAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ISpringVector2NaturalMotionAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ISpringVector3NaturalMotionAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ISpriteVisual> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ISpriteVisual2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IStepEasingFunction> : interface_type<> {};
template<> struct def<Windows::UI::Composition::StepEasingFunction> : class_type<Windows::UI::Composition::CompositionEasingFunction, Windows::UI::Composition::IStepEasingFunction> {};
template<> struct def<Windows::UI::Composition::IVector2KeyFrameAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IVector2NaturalMotionAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IVector3NaturalMotionAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IVector3KeyFrameAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IVector4KeyFrameAnimation> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IVisual> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ICompositionClipFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionClip> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionClip, Windows::UI::Composition::ICompositionClip2> {};
template<> struct def<Windows::UI::Composition::InsetClip> : class_type<Windows::UI::Composition::CompositionClip, Windows::UI::Composition::IInsetClip> {};
template<> struct def<Windows::UI::Composition::IVisual2> : interface_type<> {};
template<> struct def<Windows::UI::Composition::IVisualFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Visual> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::IVisual, Windows::UI::Composition::IVisual2> {};
template<> struct def<Windows::UI::Composition::IVisualCollection> : interface_type<Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Composition::Visual>>> {};
template<> struct def<Windows::UI::Composition::VisualCollection> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::IVisualCollection> {};
template<> struct def<Windows::UI::Composition::IVisualUnorderedCollection> : interface_type<Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Composition::Visual>>> {};
template<> struct def<Windows::UI::Composition::VisualUnorderedCollection> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::IVisualUnorderedCollection> {};
template<> struct def<Windows::UI::Composition::ExpressionAnimation> : class_type<Windows::UI::Composition::CompositionAnimation, Windows::UI::Composition::IExpressionAnimation> {};
template<> struct def<Windows::UI::Composition::IContainerVisualFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ContainerVisual> : class_type<Windows::UI::Composition::Visual, Windows::UI::Composition::IContainerVisual> {};
template<> struct def<Windows::UI::Composition::SpriteVisual> : class_type<Windows::UI::Composition::ContainerVisual, Windows::UI::Composition::ISpriteVisual, Windows::UI::Composition::ISpriteVisual2> {};
template<> struct def<Windows::UI::Composition::LayerVisual> : class_type<Windows::UI::Composition::ContainerVisual, Windows::UI::Composition::ILayerVisual, Windows::UI::Composition::ILayerVisual2> {};
template<> struct def<Windows::UI::Composition::ShapeVisual> : class_type<Windows::UI::Composition::ContainerVisual, Windows::UI::Composition::IShapeVisual> {};
template<> struct def<Windows::UI::Composition::ICompositionLightFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionLight> : class_type<Windows::UI::Composition::CompositionObject, Windows::UI::Composition::ICompositionLight, Windows::UI::Composition::ICompositionLight2, Windows::UI::Composition::ICompositionLight3> {};
template<> struct def<Windows::UI::Composition::AmbientLight> : class_type<Windows::UI::Composition::CompositionLight, Windows::UI::Composition::IAmbientLight, Windows::UI::Composition::IAmbientLight2> {};
template<> struct def<Windows::UI::Composition::DistantLight> : class_type<Windows::UI::Composition::CompositionLight, Windows::UI::Composition::IDistantLight, Windows::UI::Composition::IDistantLight2> {};
template<> struct def<Windows::UI::Composition::PointLight> : class_type<Windows::UI::Composition::CompositionLight, Windows::UI::Composition::IPointLight, Windows::UI::Composition::IPointLight2, Windows::UI::Composition::IPointLight3> {};
template<> struct def<Windows::UI::Composition::SpotLight> : class_type<Windows::UI::Composition::CompositionLight, Windows::UI::Composition::ISpotLight, Windows::UI::Composition::ISpotLight2, Windows::UI::Composition::ISpotLight3> {};
template<> struct def<Windows::UI::Composition::ICompositionGradientBrushFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::CompositionGradientBrush> : class_type<Windows::UI::Composition::CompositionBrush, Windows::UI::Composition::ICompositionGradientBrush> {};
template<> struct def<Windows::UI::Composition::CompositionLinearGradientBrush> : class_type<Windows::UI::Composition::CompositionGradientBrush, Windows::UI::Composition::ICompositionLinearGradientBrush> {};
template<> struct def<Windows::UI::Composition::CompositionContainerShape> : class_type<Windows::UI::Composition::CompositionShape, Windows::UI::Composition::ICompositionContainerShape> {};
template<> struct def<Windows::UI::Composition::CompositionSpriteShape> : class_type<Windows::UI::Composition::CompositionShape, Windows::UI::Composition::ICompositionSpriteShape> {};
template<> struct def<Windows::UI::Composition::IKeyFrameAnimationFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::KeyFrameAnimation> : class_type<Windows::UI::Composition::CompositionAnimation, Windows::UI::Composition::IKeyFrameAnimation, Windows::UI::Composition::IKeyFrameAnimation2, Windows::UI::Composition::IKeyFrameAnimation3> {};
template<> struct def<Windows::UI::Composition::ColorKeyFrameAnimation> : class_type<Windows::UI::Composition::KeyFrameAnimation, Windows::UI::Composition::IColorKeyFrameAnimation> {};
template<> struct def<Windows::UI::Composition::QuaternionKeyFrameAnimation> : class_type<Windows::UI::Composition::KeyFrameAnimation, Windows::UI::Composition::IQuaternionKeyFrameAnimation> {};
template<> struct def<Windows::UI::Composition::ScalarKeyFrameAnimation> : class_type<Windows::UI::Composition::KeyFrameAnimation, Windows::UI::Composition::IScalarKeyFrameAnimation> {};
template<> struct def<Windows::UI::Composition::Vector2KeyFrameAnimation> : class_type<Windows::UI::Composition::KeyFrameAnimation, Windows::UI::Composition::IVector2KeyFrameAnimation> {};
template<> struct def<Windows::UI::Composition::Vector3KeyFrameAnimation> : class_type<Windows::UI::Composition::KeyFrameAnimation, Windows::UI::Composition::IVector3KeyFrameAnimation> {};
template<> struct def<Windows::UI::Composition::Vector4KeyFrameAnimation> : class_type<Windows::UI::Composition::KeyFrameAnimation, Windows::UI::Composition::IVector4KeyFrameAnimation> {};
template<> struct def<Windows::UI::Composition::PathKeyFrameAnimation> : class_type<Windows::UI::Composition::KeyFrameAnimation, Windows::UI::Composition::IPathKeyFrameAnimation> {};
template<> struct def<Windows::UI::Composition::INaturalMotionAnimationFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::NaturalMotionAnimation> : class_type<Windows::UI::Composition::CompositionAnimation, Windows::UI::Composition::INaturalMotionAnimation> {};
template<> struct def<Windows::UI::Composition::IScalarNaturalMotionAnimationFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::ScalarNaturalMotionAnimation> : class_type<Windows::UI::Composition::NaturalMotionAnimation, Windows::UI::Composition::IScalarNaturalMotionAnimation> {};
template<> struct def<Windows::UI::Composition::SpringScalarNaturalMotionAnimation> : class_type<Windows::UI::Composition::ScalarNaturalMotionAnimation, Windows::UI::Composition::ISpringScalarNaturalMotionAnimation> {};
template<> struct def<Windows::UI::Composition::BounceScalarNaturalMotionAnimation> : class_type<Windows::UI::Composition::ScalarNaturalMotionAnimation, Windows::UI::Composition::IBounceScalarNaturalMotionAnimation> {};
template<> struct def<Windows::UI::Composition::IVector2NaturalMotionAnimationFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Vector2NaturalMotionAnimation> : class_type<Windows::UI::Composition::NaturalMotionAnimation, Windows::UI::Composition::IVector2NaturalMotionAnimation> {};
template<> struct def<Windows::UI::Composition::SpringVector2NaturalMotionAnimation> : class_type<Windows::UI::Composition::Vector2NaturalMotionAnimation, Windows::UI::Composition::ISpringVector2NaturalMotionAnimation> {};
template<> struct def<Windows::UI::Composition::BounceVector2NaturalMotionAnimation> : class_type<Windows::UI::Composition::Vector2NaturalMotionAnimation, Windows::UI::Composition::IBounceVector2NaturalMotionAnimation> {};
template<> struct def<Windows::UI::Composition::IVector3NaturalMotionAnimationFactory> : interface_type<> {};
template<> struct def<Windows::UI::Composition::Vector3NaturalMotionAnimation> : class_type<Windows::UI::Composition::NaturalMotionAnimation, Windows::UI::Composition::IVector3NaturalMotionAnimation> {};
template<> struct def<Windows::UI::Composition::SpringVector3NaturalMotionAnimation> : class_type<Windows::UI::Composition::Vector3NaturalMotionAnimation, Windows::UI::Composition::ISpringVector3NaturalMotionAnimation> {};
template<> struct def<Windows::UI::Composition::BounceVector3NaturalMotionAnimation> : class_type<Windows::UI::Composition::Vector3NaturalMotionAnimation, Windows::UI::Composition::IBounceVector3NaturalMotionAnimation> {};

// uuids

template<> struct uuid<Windows::UI::Composition::IAmbientLight> { define_guid(0xA48130A1, 0xB7C4, 0x46F7, 0xB9, 0xBF, 0xDA, 0xF4, 0x3A, 0x44, 0xE6, 0xEE);};
template<> struct uuid<Windows::UI::Composition::IAmbientLight2> { define_guid(0x3B64A6BF, 0x5F97, 0x4C94, 0x86, 0xE5, 0x4, 0x2D, 0xD3, 0x86, 0xB2, 0x7D);};
template<> struct uuid<Windows::UI::Composition::IAnimationController> { define_guid(0xC934EFD2, 0x722, 0x4F5F, 0xA4, 0xE2, 0x95, 0x10, 0xF3, 0xD4, 0x3B, 0xF7);};
template<> struct uuid<Windows::UI::Composition::IAnimationControllerStatics> { define_guid(0xE71164DF, 0x651B, 0x4800, 0xB9, 0xE5, 0x6A, 0x3B, 0xCF, 0xED, 0x33, 0x65);};
template<> struct uuid<Windows::UI::Composition::IBounceScalarNaturalMotionAnimation> { define_guid(0xBAA30DCC, 0xA633, 0x4618, 0x9B, 0x6, 0x7F, 0x7C, 0x72, 0xC8, 0x7C, 0xFF);};
template<> struct uuid<Windows::UI::Composition::IBounceVector2NaturalMotionAnimation> { define_guid(0xDA344196, 0x2154, 0x4B3C, 0x88, 0xAA, 0x47, 0x36, 0x12, 0x4, 0xEC, 0xCD);};
template<> struct uuid<Windows::UI::Composition::IBounceVector3NaturalMotionAnimation> { define_guid(0x47DABC31, 0x10D3, 0x4518, 0x86, 0xF1, 0x9, 0xCA, 0xF7, 0x42, 0xD1, 0x13);};
template<> struct uuid<Windows::UI::Composition::IColorKeyFrameAnimation> { define_guid(0x93ADB5E9, 0x8E05, 0x4593, 0x84, 0xA3, 0xDC, 0xA1, 0x52, 0x78, 0x1E, 0x56);};
template<> struct uuid<Windows::UI::Composition::ICompositionAnimation> { define_guid(0x464C4C2C, 0x1CAA, 0x4061, 0x9B, 0x40, 0xE1, 0x3F, 0xDE, 0x15, 0x3, 0xCA);};
template<> struct uuid<Windows::UI::Composition::ICompositionObjectFactory> { define_guid(0x51205C5E, 0x558A, 0x4F2A, 0x8D, 0x39, 0x37, 0xBF, 0xE1, 0xE2, 0xD, 0xDD);};
template<> struct uuid<Windows::UI::Composition::ICompositionObject4> { define_guid(0xBB3784C, 0x346B, 0x4A7C, 0x96, 0x6B, 0x73, 0x10, 0x96, 0x65, 0x53, 0xD5);};
template<> struct uuid<Windows::UI::Composition::ICompositionObject3> { define_guid(0x4BC27925, 0xDACD, 0x4CF2, 0x98, 0xB1, 0x98, 0x6B, 0x76, 0xE7, 0xEB, 0xE6);};
template<> struct uuid<Windows::UI::Composition::ICompositionObject2> { define_guid(0xEF874EA1, 0x5CFF, 0x4B68, 0x9E, 0x30, 0xA1, 0x51, 0x9D, 0x8, 0xBA, 0x3);};
template<> struct uuid<Windows::UI::Composition::ICompositionObject> { define_guid(0xBCB4AD45, 0x7609, 0x4550, 0x93, 0x4F, 0x16, 0x0, 0x2A, 0x68, 0xFD, 0xED);};
template<> struct uuid<Windows::UI::Composition::ICompositionAnimation2> { define_guid(0x369B603E, 0xA80F, 0x4948, 0x93, 0xE3, 0xED, 0x23, 0xFB, 0x38, 0xC6, 0xCB);};
template<> struct uuid<Windows::UI::Composition::ICompositionAnimation3> { define_guid(0xD51E030D, 0x7DA4, 0x4BD7, 0xBC, 0x2D, 0xF4, 0x51, 0x75, 0x29, 0xF4, 0x3A);};
template<> struct uuid<Windows::UI::Composition::ICompositionAnimationBase> { define_guid(0x1C2C2999, 0xE818, 0x48D3, 0xA6, 0xDD, 0xD7, 0x8C, 0x82, 0xF8, 0xAC, 0xE9);};
template<> struct uuid<Windows::UI::Composition::ICompositionAnimationFactory> { define_guid(0x10F6C4FB, 0x6E51, 0x4C25, 0xBB, 0xD3, 0x58, 0x6A, 0x9B, 0xEC, 0x3E, 0xF4);};
template<> struct uuid<Windows::UI::Composition::ICompositionAnimationGroup> { define_guid(0x5E7CC90C, 0xCD14, 0x4E07, 0x8A, 0x55, 0xC7, 0x25, 0x27, 0xAA, 0xBD, 0xAC);};
template<> struct uuid<Windows::UI::Composition::ICompositionBackdropBrush> { define_guid(0xC5ACAE58, 0x3898, 0x499E, 0x8D, 0x7F, 0x22, 0x4E, 0x91, 0x28, 0x6A, 0x5D);};
template<> struct uuid<Windows::UI::Composition::ICompositionBatchCompletedEventArgs> { define_guid(0xD00DAD0, 0x9464, 0x450A, 0xA5, 0x62, 0x2E, 0x26, 0x98, 0xB0, 0xA8, 0x12);};
template<> struct uuid<Windows::UI::Composition::ICompositionBrush> { define_guid(0xAB0D7608, 0x30C0, 0x40E9, 0xB5, 0x68, 0xB6, 0xA, 0x6B, 0xD1, 0xFB, 0x46);};
template<> struct uuid<Windows::UI::Composition::ICompositionCapabilities> { define_guid(0x8253353E, 0xB517, 0x48BC, 0xB1, 0xE8, 0x4B, 0x35, 0x61, 0xA2, 0xE1, 0x81);};
template<> struct uuid<Windows::UI::Composition::ICompositionCapabilitiesStatics> { define_guid(0xF7B7A86E, 0x6416, 0x49E5, 0x8D, 0xDF, 0xAF, 0xE9, 0x49, 0xE2, 0x5, 0x62);};
template<> struct uuid<Windows::UI::Composition::ICompositionClip> { define_guid(0x1CCD2A52, 0xCFC7, 0x4ACE, 0x99, 0x83, 0x14, 0x6B, 0xB8, 0xEB, 0x6A, 0x3C);};
template<> struct uuid<Windows::UI::Composition::ICompositionClip2> { define_guid(0x5893E069, 0x3516, 0x40E1, 0x89, 0xE0, 0x5B, 0xA9, 0x24, 0x92, 0x72, 0x35);};
template<> struct uuid<Windows::UI::Composition::ICompositionColorBrush> { define_guid(0x2B264C5E, 0xBF35, 0x4831, 0x86, 0x42, 0xCF, 0x70, 0xC2, 0xF, 0xFF, 0x2F);};
template<> struct uuid<Windows::UI::Composition::ICompositionColorGradientStop> { define_guid(0x6F00CA92, 0xC801, 0x4E41, 0x9A, 0x8F, 0xA5, 0x3E, 0x20, 0xF5, 0x77, 0x78);};
template<> struct uuid<Windows::UI::Composition::ICompositionColorGradientStopCollection> { define_guid(0x9F1D20EC, 0x7B04, 0x4B1D, 0x90, 0xBC, 0x9F, 0xA3, 0x2C, 0xC, 0xFD, 0x26);};
template<> struct uuid<Windows::UI::Composition::ICompositionCommitBatch> { define_guid(0xD00DAD0, 0xCA07, 0x4400, 0x8C, 0x8E, 0xCB, 0x5D, 0xB0, 0x85, 0x59, 0xCC);};
template<> struct uuid<Windows::UI::Composition::ICompositionContainerShape> { define_guid(0x4F5E859B, 0x2E5B, 0x44A8, 0x98, 0x2C, 0xAA, 0xF, 0x69, 0xC1, 0x60, 0x59);};
template<> struct uuid<Windows::UI::Composition::ICompositionShapeFactory> { define_guid(0x1DFC36D0, 0xB05A, 0x44EF, 0x82, 0xB0, 0x12, 0x11, 0x8B, 0xCD, 0x4C, 0xD0);};
template<> struct uuid<Windows::UI::Composition::ICompositionShape> { define_guid(0xB47CE2F7, 0x9A88, 0x42C4, 0x9E, 0x87, 0x2E, 0x50, 0xC, 0xA8, 0x68, 0x8C);};
template<> struct uuid<Windows::UI::Composition::ICompositionDrawingSurface> { define_guid(0xA166C300, 0xFAD0, 0x4D11, 0x9E, 0x67, 0xE4, 0x33, 0x16, 0x2F, 0xF4, 0x9E);};
template<> struct uuid<Windows::UI::Composition::ICompositionDrawingSurface2> { define_guid(0xFAD0E88B, 0xE354, 0x44E8, 0x8E, 0x3D, 0xC4, 0x88, 0xD, 0x5A, 0x21, 0x3F);};
template<> struct uuid<Windows::UI::Composition::ICompositionEasingFunction> { define_guid(0x5145E356, 0xBF79, 0x4EA8, 0x8C, 0xC2, 0x6B, 0x5B, 0x47, 0x2E, 0x6C, 0x9A);};
template<> struct uuid<Windows::UI::Composition::ICompositionEasingFunctionFactory> { define_guid(0x60840774, 0x3DA0, 0x4949, 0x82, 0x0, 0x72, 0x6, 0xC0, 0x1, 0x90, 0xA0);};
template<> struct uuid<Windows::UI::Composition::ICompositionEllipseGeometry> { define_guid(0x4801F884, 0xF6AD, 0x4B93, 0xAF, 0xA9, 0x89, 0x7B, 0x64, 0xE5, 0x7B, 0x1F);};
template<> struct uuid<Windows::UI::Composition::ICompositionEffectBrush> { define_guid(0xBF7F795E, 0x83CC, 0x44BF, 0xA4, 0x47, 0x3E, 0x3C, 0x7, 0x17, 0x89, 0xEC);};
template<> struct uuid<Windows::UI::Composition::ICompositionBrushFactory> { define_guid(0xDA53FB4C, 0x4650, 0x47C4, 0xAD, 0x76, 0x76, 0x53, 0x79, 0x60, 0x7E, 0xD6);};
template<> struct uuid<Windows::UI::Composition::ICompositionEffectFactory> { define_guid(0xBE5624AF, 0xBA7E, 0x4510, 0x98, 0x50, 0x41, 0xC0, 0xB4, 0xFF, 0x74, 0xDF);};
template<> struct uuid<Windows::UI::Composition::ICompositionEffectSourceParameter> { define_guid(0x858AB13A, 0x3292, 0x4E4E, 0xB3, 0xBB, 0x2B, 0x6C, 0x65, 0x44, 0xA6, 0xEE);};
template<> struct uuid<Windows::UI::Composition::ICompositionEffectSourceParameterFactory> { define_guid(0xB3D9F276, 0xABA3, 0x4724, 0xAC, 0xF3, 0xD0, 0x39, 0x74, 0x64, 0xDB, 0x1C);};
template<> struct uuid<Windows::UI::Composition::ICompositionGeometry> { define_guid(0xE985217C, 0x6A17, 0x4207, 0xAB, 0xD8, 0x5F, 0xD3, 0xDD, 0x61, 0x2A, 0x9D);};
template<> struct uuid<Windows::UI::Composition::ICompositionGradientBrush> { define_guid(0x1D9709E0, 0xFFC6, 0x4C0E, 0xA9, 0xAB, 0x34, 0x14, 0x4D, 0x4C, 0x90, 0x98);};
template<> struct uuid<Windows::UI::Composition::ICompositionGraphicsDevice> { define_guid(0xFB22C6E1, 0x80A2, 0x4667, 0x99, 0x36, 0xDB, 0xEA, 0xF6, 0xEE, 0xFE, 0x95);};
template<> struct uuid<Windows::UI::Composition::ICompositionGraphicsDevice2> { define_guid(0xFB8BDF6, 0xC0F0, 0x4BCC, 0x9F, 0xB8, 0x8, 0x49, 0x82, 0x49, 0xD, 0x7D);};
template<> struct uuid<Windows::UI::Composition::ICompositionLight> { define_guid(0x41A6D7C2, 0x2E5D, 0x4BC1, 0xB0, 0x9E, 0x8F, 0xA, 0x3, 0xE3, 0xD8, 0xD3);};
template<> struct uuid<Windows::UI::Composition::ICompositionLight2> { define_guid(0xA7BCDA72, 0xF35D, 0x425D, 0x9B, 0x98, 0x23, 0xF4, 0x20, 0x5F, 0x66, 0x69);};
template<> struct uuid<Windows::UI::Composition::ICompositionLight3> { define_guid(0x4B0B00E4, 0xDF07, 0x4959, 0xB7, 0xA4, 0x4F, 0x7E, 0x42, 0x33, 0xF8, 0x38);};
template<> struct uuid<Windows::UI::Composition::ICompositionLineGeometry> { define_guid(0xDD7615A4, 0xC9A, 0x4B67, 0x8D, 0xCE, 0x44, 0xA, 0x5B, 0xF9, 0xCD, 0xEC);};
template<> struct uuid<Windows::UI::Composition::ICompositionLinearGradientBrush> { define_guid(0x983BC519, 0xA9DB, 0x413C, 0xA2, 0xD8, 0x2A, 0x90, 0x56, 0xFC, 0x52, 0x5E);};
template<> struct uuid<Windows::UI::Composition::ICompositionMaskBrush> { define_guid(0x522CF09E, 0xBE6B, 0x4F41, 0xBE, 0x49, 0xF9, 0x22, 0x6D, 0x47, 0x1B, 0x4A);};
template<> struct uuid<Windows::UI::Composition::ICompositionNineGridBrush> { define_guid(0xF25154E4, 0xBC8C, 0x4BE7, 0xB8, 0xF, 0x86, 0x85, 0xB8, 0x3C, 0x1, 0x86);};
template<> struct uuid<Windows::UI::Composition::ICompositorStatics> { define_guid(0x80DB93E, 0x121E, 0x4D97, 0x8B, 0x74, 0x1D, 0xFC, 0xF9, 0x19, 0x87, 0xEA);};
template<> struct uuid<Windows::UI::Composition::ICompositor5> { define_guid(0x48EA31AD, 0x7FCD, 0x4076, 0xA7, 0x9C, 0x90, 0xCC, 0x4B, 0x85, 0x2C, 0x9B);};
template<> struct uuid<Windows::UI::Composition::ICompositor4> { define_guid(0xAE47E78A, 0x7910, 0x4425, 0xA4, 0x82, 0xA0, 0x5B, 0x75, 0x8A, 0xDC, 0xE9);};
template<> struct uuid<Windows::UI::Composition::ICompositor3> { define_guid(0xC9DD8EF0, 0x6EB1, 0x4E3C, 0xA6, 0x58, 0x67, 0x5D, 0x9C, 0x64, 0xD4, 0xAB);};
template<> struct uuid<Windows::UI::Composition::ICompositor2> { define_guid(0x735081DC, 0x5E24, 0x45DA, 0xA3, 0x8F, 0xE3, 0x2C, 0xC3, 0x49, 0xA9, 0xA0);};
template<> struct uuid<Windows::UI::Composition::ICompositor> { define_guid(0xB403CA50, 0x7F8C, 0x4E83, 0x98, 0x5F, 0xCC, 0x45, 0x6, 0x0, 0x36, 0xD8);};
template<> struct uuid<Windows::UI::Composition::ICompositionPath> { define_guid(0x66DA1D5F, 0x2E10, 0x4F22, 0x8A, 0x6, 0xA, 0x81, 0x51, 0x91, 0x9E, 0x60);};
template<> struct uuid<Windows::UI::Composition::ICompositionPathGeometry> { define_guid(0xB6A417E, 0x2C77, 0x4C23, 0xAF, 0x5E, 0x63, 0x4, 0xC1, 0x47, 0xBB, 0x61);};
template<> struct uuid<Windows::UI::Composition::ICompositionPathFactory> { define_guid(0x9C1E8C6A, 0xF33, 0x4751, 0x94, 0x37, 0xEB, 0x3F, 0xB9, 0xD3, 0xAB, 0x7);};
template<> struct uuid<Windows::UI::Composition::ICompositionPropertySet> { define_guid(0xC9D6D202, 0x5F67, 0x4453, 0x91, 0x17, 0x9E, 0xAD, 0xD4, 0x30, 0xD3, 0xC2);};
template<> struct uuid<Windows::UI::Composition::ICompositionPropertySet2> { define_guid(0xDE80731E, 0xA211, 0x4455, 0x88, 0x80, 0x7D, 0xF, 0x3F, 0x6A, 0x44, 0xFD);};
template<> struct uuid<Windows::UI::Composition::ICompositionRectangleGeometry> { define_guid(0xCD51428, 0x5356, 0x4246, 0xAE, 0xCF, 0x7A, 0xB, 0x76, 0x97, 0x54, 0x0);};
template<> struct uuid<Windows::UI::Composition::ICompositionRoundedRectangleGeometry> { define_guid(0x8770C822, 0x1D50, 0x4B8B, 0xB0, 0x13, 0x7C, 0x9A, 0xE, 0x46, 0x93, 0x5F);};
template<> struct uuid<Windows::UI::Composition::ICompositionScopedBatch> { define_guid(0xD00DAD0, 0xFB07, 0x46FD, 0x8C, 0x72, 0x62, 0x80, 0xD1, 0xA3, 0xD1, 0xDD);};
template<> struct uuid<Windows::UI::Composition::ICompositionShadow> { define_guid(0x329E52E2, 0x4335, 0x49CC, 0xB1, 0x4A, 0x37, 0x78, 0x2D, 0x10, 0xF0, 0xC4);};
template<> struct uuid<Windows::UI::Composition::ICompositionSpriteShape> { define_guid(0x401B61BB, 0x7, 0x4363, 0xB1, 0xF3, 0x6B, 0xCC, 0x0, 0x3F, 0xB8, 0x3E);};
template<> struct uuid<Windows::UI::Composition::ICompositionGeometryFactory> { define_guid(0xBFFEBFE1, 0x8C25, 0x480B, 0x9F, 0x56, 0xFE, 0xD6, 0xB2, 0x88, 0x5, 0x5D);};
template<> struct uuid<Windows::UI::Composition::ICompositionSurface> { define_guid(0x1527540D, 0x42C7, 0x47A6, 0xA4, 0x8, 0x66, 0x8F, 0x79, 0xA9, 0xD, 0xFB);};
template<> struct uuid<Windows::UI::Composition::ICompositionDrawingSurfaceFactory> { define_guid(0x9497B00A, 0x312D, 0x46B9, 0x9D, 0xB3, 0x41, 0x2F, 0xD7, 0x94, 0x64, 0xC8);};
template<> struct uuid<Windows::UI::Composition::ICompositionSurfaceBrush> { define_guid(0xAD016D79, 0x1E4C, 0x4C0D, 0x9C, 0x29, 0x83, 0x33, 0x8C, 0x87, 0xC1, 0x62);};
template<> struct uuid<Windows::UI::Composition::ICompositionSurfaceBrush2> { define_guid(0xD27174D5, 0x64F5, 0x4692, 0x9D, 0xC7, 0x71, 0xB6, 0x1D, 0x7E, 0x58, 0x80);};
template<> struct uuid<Windows::UI::Composition::ICompositionTarget> { define_guid(0xA1BEA8BA, 0xD726, 0x4663, 0x81, 0x29, 0x6B, 0x5E, 0x79, 0x27, 0xFF, 0xA6);};
template<> struct uuid<Windows::UI::Composition::ICompositionViewBox> { define_guid(0xB440BF07, 0x68F, 0x4537, 0x84, 0xC6, 0x4E, 0xCB, 0xE0, 0x19, 0xE1, 0xF4);};
template<> struct uuid<Windows::UI::Composition::ICompositionVirtualDrawingSurface> { define_guid(0xA9C384DB, 0x8740, 0x4F94, 0x8B, 0x9D, 0xB6, 0x85, 0x21, 0xE7, 0x86, 0x3D);};
template<> struct uuid<Windows::UI::Composition::ICompositionVirtualDrawingSurfaceFactory> { define_guid(0x6766106C, 0xD56B, 0x4A49, 0xB1, 0xDF, 0x50, 0x76, 0xA0, 0x62, 0x7, 0x68);};
template<> struct uuid<Windows::UI::Composition::ICompositionTargetFactory> { define_guid(0x93CD9D2B, 0x8516, 0x4B14, 0xA8, 0xCE, 0xF4, 0x9E, 0x21, 0x19, 0xEC, 0x42);};
template<> struct uuid<Windows::UI::Composition::IContainerVisual> { define_guid(0x2F6BC74, 0xED20, 0x4773, 0xAF, 0xE6, 0xD4, 0x9B, 0x4A, 0x93, 0xDB, 0x32);};
template<> struct uuid<Windows::UI::Composition::ICubicBezierEasingFunction> { define_guid(0x32350666, 0xC1E8, 0x44F9, 0x96, 0xB8, 0xC9, 0x8A, 0xCF, 0xA, 0xE6, 0x98);};
template<> struct uuid<Windows::UI::Composition::IDistantLight> { define_guid(0x318CFAFC, 0x5CE3, 0x4B55, 0xAB, 0x5D, 0x7, 0xA0, 0x3, 0x53, 0xAC, 0x99);};
template<> struct uuid<Windows::UI::Composition::IDistantLight2> { define_guid(0xDBCDAA1C, 0x294B, 0x48D7, 0xB6, 0xE, 0x76, 0xDF, 0x64, 0xAA, 0x39, 0x2B);};
template<> struct uuid<Windows::UI::Composition::IDropShadow> { define_guid(0xCB977C07, 0xA154, 0x4851, 0x85, 0xE7, 0xA8, 0x92, 0x4C, 0x84, 0xFA, 0xD8);};
template<> struct uuid<Windows::UI::Composition::IDropShadow2> { define_guid(0x6C4218BC, 0x15B9, 0x4C2D, 0x8D, 0x4A, 0x7, 0x67, 0xDF, 0x11, 0x97, 0x7A);};
template<> struct uuid<Windows::UI::Composition::IExpressionAnimation> { define_guid(0x6ACC5431, 0x7D3D, 0x4BF3, 0xAB, 0xB6, 0xF4, 0x4B, 0xDC, 0x48, 0x88, 0xC1);};
template<> struct uuid<Windows::UI::Composition::IImplicitAnimationCollection> { define_guid(0x598A3FF, 0xA92, 0x4C9D, 0xA4, 0x27, 0xB2, 0x55, 0x19, 0x25, 0xD, 0xBF);};
template<> struct uuid<Windows::UI::Composition::IInsetClip> { define_guid(0x1E73E647, 0x84C7, 0x477A, 0xB4, 0x74, 0x58, 0x80, 0xE0, 0x44, 0x2E, 0x15);};
template<> struct uuid<Windows::UI::Composition::IKeyFrameAnimation> { define_guid(0x126E7F22, 0x3AE9, 0x4540, 0x9A, 0x8A, 0xDE, 0xAE, 0x8A, 0x4A, 0x4A, 0x84);};
template<> struct uuid<Windows::UI::Composition::IKeyFrameAnimation2> { define_guid(0xF4B488BB, 0x2940, 0x4EC0, 0xA4, 0x1A, 0xEB, 0x6D, 0x80, 0x1A, 0x2F, 0x18);};
template<> struct uuid<Windows::UI::Composition::IKeyFrameAnimation3> { define_guid(0x845BF0B4, 0xD8DE, 0x462F, 0x87, 0x53, 0xC8, 0xD, 0x43, 0xC6, 0xFF, 0x5A);};
template<> struct uuid<Windows::UI::Composition::ILayerVisual> { define_guid(0xAF843985, 0x444, 0x4887, 0x8E, 0x83, 0xB4, 0xB, 0x25, 0x3F, 0x82, 0x2C);};
template<> struct uuid<Windows::UI::Composition::ILayerVisual2> { define_guid(0x98F9AEEB, 0x6F23, 0x49F1, 0x90, 0xB1, 0x1F, 0x59, 0xA1, 0x4F, 0xBC, 0xE3);};
template<> struct uuid<Windows::UI::Composition::ICompositionShadowFactory> { define_guid(0x221F492F, 0xDCBA, 0x4B91, 0x99, 0x9E, 0x1D, 0xC2, 0x17, 0xA0, 0x15, 0x30);};
template<> struct uuid<Windows::UI::Composition::ILinearEasingFunction> { define_guid(0x9400975A, 0xC7A6, 0x46B3, 0xAC, 0xF7, 0x1A, 0x26, 0x8A, 0xA, 0x11, 0x7D);};
template<> struct uuid<Windows::UI::Composition::INaturalMotionAnimation> { define_guid(0x438DE12D, 0x769B, 0x4821, 0xA9, 0x49, 0x28, 0x4A, 0x65, 0x47, 0xE8, 0x73);};
template<> struct uuid<Windows::UI::Composition::IPathKeyFrameAnimation> { define_guid(0x9D0D18C9, 0x1576, 0x4B3F, 0xBE, 0x60, 0x1D, 0x50, 0x31, 0xF5, 0xE7, 0x1B);};
template<> struct uuid<Windows::UI::Composition::IPointLight> { define_guid(0xB18545B3, 0xC5A, 0x4AB0, 0xBE, 0xDC, 0x4F, 0x35, 0x46, 0x94, 0x82, 0x72);};
template<> struct uuid<Windows::UI::Composition::IPointLight2> { define_guid(0xEFE98F2C, 0x678, 0x4F69, 0xB1, 0x64, 0xA8, 0x10, 0xD9, 0x95, 0xBC, 0xB7);};
template<> struct uuid<Windows::UI::Composition::IPointLight3> { define_guid(0x4C0A8367, 0xD4E9, 0x468A, 0x87, 0xAE, 0x7B, 0xA4, 0x3A, 0xB2, 0x94, 0x85);};
template<> struct uuid<Windows::UI::Composition::IQuaternionKeyFrameAnimation> { define_guid(0x404E5835, 0xECF6, 0x4240, 0x85, 0x20, 0x67, 0x12, 0x79, 0xCF, 0x36, 0xBC);};
template<> struct uuid<Windows::UI::Composition::IRenderingDeviceReplacedEventArgs> { define_guid(0x3A31AC7D, 0x28BF, 0x4E7A, 0x85, 0x24, 0x71, 0x67, 0x9D, 0x48, 0xF, 0x38);};
template<> struct uuid<Windows::UI::Composition::IScalarKeyFrameAnimation> { define_guid(0xAE288FA9, 0x252C, 0x4B95, 0xA7, 0x25, 0xBF, 0x85, 0xE3, 0x80, 0x0, 0xA1);};
template<> struct uuid<Windows::UI::Composition::IScalarNaturalMotionAnimation> { define_guid(0x94A94581, 0xBF92, 0x495B, 0xB5, 0xBD, 0xD2, 0xC6, 0x59, 0x43, 0x7, 0x37);};
template<> struct uuid<Windows::UI::Composition::IShapeVisual> { define_guid(0xF2BD13C3, 0xBA7E, 0x4B0F, 0x91, 0x26, 0xFF, 0xB7, 0x53, 0x6B, 0x81, 0x76);};
template<> struct uuid<Windows::UI::Composition::ISpotLight> { define_guid(0x5A9FE273, 0x44A1, 0x4F95, 0xA4, 0x22, 0x8F, 0xA5, 0x11, 0x6B, 0xDB, 0x44);};
template<> struct uuid<Windows::UI::Composition::ISpotLight2> { define_guid(0x64EE615E, 0x686, 0x4DEA, 0xA9, 0xE8, 0xBC, 0x3A, 0x8C, 0x70, 0x14, 0x59);};
template<> struct uuid<Windows::UI::Composition::ISpotLight3> { define_guid(0xE4D03EEA, 0x131F, 0x480E, 0x85, 0x9E, 0xB8, 0x27, 0x5, 0xB7, 0x43, 0x60);};
template<> struct uuid<Windows::UI::Composition::ISpringScalarNaturalMotionAnimation> { define_guid(0x572A95F, 0x37F9, 0x4FBE, 0xB8, 0x7B, 0x5C, 0xD0, 0x3A, 0x89, 0x50, 0x1C);};
template<> struct uuid<Windows::UI::Composition::ISpringVector2NaturalMotionAnimation> { define_guid(0x23F494B5, 0xEE73, 0x4F0F, 0xA4, 0x23, 0x40, 0x2B, 0x94, 0x6D, 0xF4, 0xB3);};
template<> struct uuid<Windows::UI::Composition::ISpringVector3NaturalMotionAnimation> { define_guid(0x6C8749DF, 0xD57B, 0x4794, 0x8E, 0x2D, 0xCE, 0xCB, 0x11, 0xE1, 0x94, 0xE5);};
template<> struct uuid<Windows::UI::Composition::ISpriteVisual> { define_guid(0x8E05581, 0x1AD1, 0x4F97, 0x97, 0x57, 0x40, 0x2D, 0x76, 0xE4, 0x23, 0x3B);};
template<> struct uuid<Windows::UI::Composition::ISpriteVisual2> { define_guid(0x588C9664, 0x997A, 0x4850, 0x91, 0xFE, 0x53, 0xCB, 0x58, 0xF8, 0x1C, 0xE9);};
template<> struct uuid<Windows::UI::Composition::IStepEasingFunction> { define_guid(0xD0CAA74B, 0x560C, 0x4A0B, 0xA5, 0xF6, 0x20, 0x6C, 0xA8, 0xC3, 0xEC, 0xD6);};
template<> struct uuid<Windows::UI::Composition::IVector2KeyFrameAnimation> { define_guid(0xDF414515, 0x4E29, 0x4F11, 0xB5, 0x5E, 0xBF, 0x2A, 0x6E, 0xB3, 0x62, 0x94);};
template<> struct uuid<Windows::UI::Composition::IVector2NaturalMotionAnimation> { define_guid(0xF3E0B7D, 0xE512, 0x479D, 0xA0, 0xC, 0x77, 0xC9, 0x3A, 0x30, 0xA3, 0x95);};
template<> struct uuid<Windows::UI::Composition::IVector3NaturalMotionAnimation> { define_guid(0x9C17042C, 0xE2CA, 0x45AD, 0x96, 0x9E, 0x4E, 0x78, 0xB7, 0xB9, 0xAD, 0x41);};
template<> struct uuid<Windows::UI::Composition::IVector3KeyFrameAnimation> { define_guid(0xC8039DAA, 0xA281, 0x43C2, 0xA7, 0x3D, 0xB6, 0x8E, 0x3C, 0x53, 0x3C, 0x40);};
template<> struct uuid<Windows::UI::Composition::IVector4KeyFrameAnimation> { define_guid(0x2457945B, 0xADDD, 0x4385, 0x96, 0x6, 0xB6, 0xA3, 0xD5, 0xE4, 0xE1, 0xB9);};
template<> struct uuid<Windows::UI::Composition::IVisual> { define_guid(0x117E202D, 0xA859, 0x4C89, 0x87, 0x3B, 0xC2, 0xAA, 0x56, 0x67, 0x88, 0xE3);};
template<> struct uuid<Windows::UI::Composition::ICompositionClipFactory> { define_guid(0xB9484CAF, 0x20C7, 0x4AED, 0xAC, 0x4A, 0x9C, 0x78, 0xBA, 0x13, 0x2, 0xCF);};
template<> struct uuid<Windows::UI::Composition::IVisual2> { define_guid(0x3052B611, 0x56C3, 0x4C3E, 0x8B, 0xF3, 0xF6, 0xE1, 0xAD, 0x47, 0x3F, 0x6);};
template<> struct uuid<Windows::UI::Composition::IVisualFactory> { define_guid(0xAD0FF93E, 0xB502, 0x4EB5, 0x87, 0xB4, 0x9A, 0x38, 0xA7, 0x1D, 0x1, 0x37);};
template<> struct uuid<Windows::UI::Composition::IVisualCollection> { define_guid(0x8B745505, 0xFD3E, 0x4A98, 0x84, 0xA8, 0xE9, 0x49, 0x46, 0x8C, 0x6B, 0xCB);};
template<> struct uuid<Windows::UI::Composition::IVisualUnorderedCollection> { define_guid(0x338FAA70, 0x54C8, 0x40A7, 0x80, 0x29, 0xC9, 0xCE, 0xEB, 0xA, 0xA2, 0x50);};
template<> struct uuid<Windows::UI::Composition::IContainerVisualFactory> { define_guid(0x363A65B, 0xC7DA, 0x4D9A, 0x95, 0xF4, 0x69, 0xB5, 0xC8, 0xDF, 0x67, 0xB);};
template<> struct uuid<Windows::UI::Composition::ICompositionLightFactory> { define_guid(0x69CF306, 0xDA3C, 0x4B44, 0x83, 0x8A, 0x5E, 0x3, 0xD5, 0x1A, 0xCE, 0x55);};
template<> struct uuid<Windows::UI::Composition::ICompositionGradientBrushFactory> { define_guid(0x56D765D7, 0xF189, 0x48C9, 0x9C, 0x8D, 0x94, 0xDA, 0xF1, 0xBE, 0xC0, 0x10);};
template<> struct uuid<Windows::UI::Composition::IKeyFrameAnimationFactory> { define_guid(0xBF0803F8, 0x712A, 0x4FC1, 0x8C, 0x87, 0x97, 0x8, 0x59, 0xED, 0x8D, 0x2E);};
template<> struct uuid<Windows::UI::Composition::INaturalMotionAnimationFactory> { define_guid(0xF53ACB06, 0xCF6A, 0x4387, 0xA3, 0xFE, 0x52, 0x21, 0xF3, 0xE7, 0xE0, 0xE0);};
template<> struct uuid<Windows::UI::Composition::IScalarNaturalMotionAnimationFactory> { define_guid(0x835AA4FC, 0x671C, 0x41DD, 0xAF, 0x48, 0xAE, 0x8D, 0xEF, 0x8B, 0x15, 0x29);};
template<> struct uuid<Windows::UI::Composition::IVector2NaturalMotionAnimationFactory> { define_guid(0x8C74FF61, 0x761, 0x48A2, 0xBD, 0xDB, 0x6A, 0xFC, 0xC5, 0x2B, 0x89, 0xD8);};
template<> struct uuid<Windows::UI::Composition::IVector3NaturalMotionAnimationFactory> { define_guid(0x21A81D2F, 0x880, 0x457B, 0xAC, 0x87, 0xB6, 0x9, 0x1, 0x8C, 0x87, 0x6D);};

// types

namespace Windows { namespace UI { namespace Composition {

// IAmbientLight
struct IAmbientLight_raw : IInspectable {
	virtual STDMETHODIMP _get_Color(UI::Color *value);
	virtual STDMETHODIMP _put_Color(UI::Color value);
};
template<typename X> struct IAmbientLight_adaptor : X {
	union {
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&IAmbientLight_adaptor::Color)->_get_Color(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IAmbientLight_adaptor::Color)->_put_Color(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} Color;
	};
	IAmbientLight_adaptor() {}
};
template<typename X> struct adapt<IAmbientLight, X> : Windows::UI::Composition::IAmbientLight_adaptor<X> { typedef adapt IAmbientLight; };
struct IAmbientLight : IAmbientLight_raw, generate<IAmbientLight> {};

// IAmbientLight2
struct IAmbientLight2_raw : IInspectable {
	virtual STDMETHODIMP _get_Intensity(float *value);
	virtual STDMETHODIMP _put_Intensity(float value);
};
template<typename X> struct IAmbientLight2_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&IAmbientLight2_adaptor::Intensity)->_get_Intensity(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IAmbientLight2_adaptor::Intensity)->_put_Intensity(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Intensity;
	};
	IAmbientLight2_adaptor() {}
};
template<typename X> struct adapt<IAmbientLight2, X> : Windows::UI::Composition::IAmbientLight2_adaptor<X> { typedef adapt IAmbientLight2; };
struct IAmbientLight2 : IAmbientLight2_raw, generate<IAmbientLight2> {};

// IAnimationController
struct IAnimationController_raw : IInspectable {
	virtual STDMETHODIMP _get_PlaybackRate(float *value);
	virtual STDMETHODIMP _put_PlaybackRate(float value);
	virtual STDMETHODIMP _get_Progress(float *value);
	virtual STDMETHODIMP _put_Progress(float value);
	virtual STDMETHODIMP _get_ProgressBehavior(AnimationControllerProgressBehavior *value);
	virtual STDMETHODIMP _put_ProgressBehavior(AnimationControllerProgressBehavior value);
	virtual STDMETHODIMP _Pause();
	virtual STDMETHODIMP _Resume();
};
template<typename X> struct IAnimationController_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&IAnimationController_adaptor::PlaybackRate)->_get_PlaybackRate(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IAnimationController_adaptor::PlaybackRate)->_put_PlaybackRate(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} PlaybackRate;
		struct : property {
			float get() { float value; hrcheck(enc(&IAnimationController_adaptor::Progress)->_get_Progress(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IAnimationController_adaptor::Progress)->_put_Progress(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Progress;
		struct : property {
			AnimationControllerProgressBehavior get() { AnimationControllerProgressBehavior value; hrcheck(enc(&IAnimationController_adaptor::ProgressBehavior)->_get_ProgressBehavior(&value)); return value; }
			AnimationControllerProgressBehavior operator()() { return get(); }
			operator AnimationControllerProgressBehavior () { return get(); }
			void put(AnimationControllerProgressBehavior value) { hrcheck(enc(&IAnimationController_adaptor::ProgressBehavior)->_put_ProgressBehavior(value)); }
			void operator=(AnimationControllerProgressBehavior value) { put(value); }
			void operator()(AnimationControllerProgressBehavior value) { put(value); }
		} ProgressBehavior;
	};
	void Pause() { hrcheck(X::get()->_Pause()); }
	void Resume() { hrcheck(X::get()->_Resume()); }
	IAnimationController_adaptor() {}
};
template<typename X> struct adapt<IAnimationController, X> : Windows::UI::Composition::IAnimationController_adaptor<X> { typedef adapt IAnimationController; };
struct IAnimationController : IAnimationController_raw, generate<IAnimationController> {};

// IAnimationControllerStatics
struct IAnimationControllerStatics : IInspectable {
	virtual STDMETHODIMP _get_MaxPlaybackRate(float *value);
	virtual STDMETHODIMP _get_MinPlaybackRate(float *value);
};

// IBounceScalarNaturalMotionAnimation
struct IBounceScalarNaturalMotionAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_Acceleration(float *value);
	virtual STDMETHODIMP _put_Acceleration(float value);
	virtual STDMETHODIMP _get_Restitution(float *value);
	virtual STDMETHODIMP _put_Restitution(float value);
};
template<typename X> struct IBounceScalarNaturalMotionAnimation_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&IBounceScalarNaturalMotionAnimation_adaptor::Acceleration)->_get_Acceleration(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IBounceScalarNaturalMotionAnimation_adaptor::Acceleration)->_put_Acceleration(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Acceleration;
		struct : property {
			float get() { float value; hrcheck(enc(&IBounceScalarNaturalMotionAnimation_adaptor::Restitution)->_get_Restitution(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IBounceScalarNaturalMotionAnimation_adaptor::Restitution)->_put_Restitution(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Restitution;
	};
	IBounceScalarNaturalMotionAnimation_adaptor() {}
};
template<typename X> struct adapt<IBounceScalarNaturalMotionAnimation, X> : Windows::UI::Composition::IBounceScalarNaturalMotionAnimation_adaptor<X> { typedef adapt IBounceScalarNaturalMotionAnimation; };
struct IBounceScalarNaturalMotionAnimation : IBounceScalarNaturalMotionAnimation_raw, generate<IBounceScalarNaturalMotionAnimation> {};

// IBounceVector2NaturalMotionAnimation
struct IBounceVector2NaturalMotionAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_Acceleration(float *value);
	virtual STDMETHODIMP _put_Acceleration(float value);
	virtual STDMETHODIMP _get_Restitution(float *value);
	virtual STDMETHODIMP _put_Restitution(float value);
};
template<typename X> struct IBounceVector2NaturalMotionAnimation_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&IBounceVector2NaturalMotionAnimation_adaptor::Acceleration)->_get_Acceleration(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IBounceVector2NaturalMotionAnimation_adaptor::Acceleration)->_put_Acceleration(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Acceleration;
		struct : property {
			float get() { float value; hrcheck(enc(&IBounceVector2NaturalMotionAnimation_adaptor::Restitution)->_get_Restitution(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IBounceVector2NaturalMotionAnimation_adaptor::Restitution)->_put_Restitution(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Restitution;
	};
	IBounceVector2NaturalMotionAnimation_adaptor() {}
};
template<typename X> struct adapt<IBounceVector2NaturalMotionAnimation, X> : Windows::UI::Composition::IBounceVector2NaturalMotionAnimation_adaptor<X> { typedef adapt IBounceVector2NaturalMotionAnimation; };
struct IBounceVector2NaturalMotionAnimation : IBounceVector2NaturalMotionAnimation_raw, generate<IBounceVector2NaturalMotionAnimation> {};

// IBounceVector3NaturalMotionAnimation
struct IBounceVector3NaturalMotionAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_Acceleration(float *value);
	virtual STDMETHODIMP _put_Acceleration(float value);
	virtual STDMETHODIMP _get_Restitution(float *value);
	virtual STDMETHODIMP _put_Restitution(float value);
};
template<typename X> struct IBounceVector3NaturalMotionAnimation_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&IBounceVector3NaturalMotionAnimation_adaptor::Acceleration)->_get_Acceleration(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IBounceVector3NaturalMotionAnimation_adaptor::Acceleration)->_put_Acceleration(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Acceleration;
		struct : property {
			float get() { float value; hrcheck(enc(&IBounceVector3NaturalMotionAnimation_adaptor::Restitution)->_get_Restitution(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IBounceVector3NaturalMotionAnimation_adaptor::Restitution)->_put_Restitution(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Restitution;
	};
	IBounceVector3NaturalMotionAnimation_adaptor() {}
};
template<typename X> struct adapt<IBounceVector3NaturalMotionAnimation, X> : Windows::UI::Composition::IBounceVector3NaturalMotionAnimation_adaptor<X> { typedef adapt IBounceVector3NaturalMotionAnimation; };
struct IBounceVector3NaturalMotionAnimation : IBounceVector3NaturalMotionAnimation_raw, generate<IBounceVector3NaturalMotionAnimation> {};

// IColorKeyFrameAnimation
struct IColorKeyFrameAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_InterpolationColorSpace(CompositionColorSpace *value);
	virtual STDMETHODIMP _put_InterpolationColorSpace(CompositionColorSpace value);
	virtual STDMETHODIMP _InsertKeyFrame(float normalizedProgressKey, Color value);
	virtual STDMETHODIMP _InsertKeyFrameWithEasingFunction(float normalizedProgressKey, Color value, CompositionEasingFunction* easingFunction);
};
template<typename X> struct IColorKeyFrameAnimation_adaptor : X {
	union {
		struct : property {
			CompositionColorSpace get() { CompositionColorSpace value; hrcheck(enc(&IColorKeyFrameAnimation_adaptor::InterpolationColorSpace)->_get_InterpolationColorSpace(&value)); return value; }
			CompositionColorSpace operator()() { return get(); }
			operator CompositionColorSpace () { return get(); }
			void put(CompositionColorSpace value) { hrcheck(enc(&IColorKeyFrameAnimation_adaptor::InterpolationColorSpace)->_put_InterpolationColorSpace(value)); }
			void operator=(CompositionColorSpace value) { put(value); }
			void operator()(CompositionColorSpace value) { put(value); }
		} InterpolationColorSpace;
	};
	void InsertKeyFrame(float normalizedProgressKey, const Color& value) { hrcheck(X::get()->_InsertKeyFrame(normalizedProgressKey, value)); }
	void InsertKeyFrame(float normalizedProgressKey, const Color& value, pptr<CompositionEasingFunction> easingFunction) { hrcheck(X::get()->_InsertKeyFrameWithEasingFunction(normalizedProgressKey, value, easingFunction)); }
	IColorKeyFrameAnimation_adaptor() {}
};
template<typename X> struct adapt<IColorKeyFrameAnimation, X> : Windows::UI::Composition::IColorKeyFrameAnimation_adaptor<X> { typedef adapt IColorKeyFrameAnimation; };
struct IColorKeyFrameAnimation : IColorKeyFrameAnimation_raw, generate<IColorKeyFrameAnimation> {};

// ICompositionAnimation
struct ICompositionAnimation_raw : IInspectable {
	virtual STDMETHODIMP _ClearAllParameters();
	virtual STDMETHODIMP _ClearParameter(HSTRING key);
	virtual STDMETHODIMP _SetColorParameter(HSTRING key, Color value);
	virtual STDMETHODIMP _SetMatrix3x2Parameter(HSTRING key, Foundation::Numerics::Matrix3x2 value);
	virtual STDMETHODIMP _SetMatrix4x4Parameter(HSTRING key, Foundation::Numerics::Matrix4x4 value);
	virtual STDMETHODIMP _SetQuaternionParameter(HSTRING key, Foundation::Numerics::Quaternion value);
	virtual STDMETHODIMP _SetReferenceParameter(HSTRING key, CompositionObject* compositionObject);
	virtual STDMETHODIMP _SetScalarParameter(HSTRING key, float value);
	virtual STDMETHODIMP _SetVector2Parameter(HSTRING key, Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _SetVector3Parameter(HSTRING key, Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _SetVector4Parameter(HSTRING key, Foundation::Numerics::Vector4 value);
};
template<typename X> struct ICompositionAnimation_adaptor : X {
	void ClearAllParameters() { hrcheck(X::get()->_ClearAllParameters()); }
	void ClearParameter(hstring_ref key) { hrcheck(X::get()->_ClearParameter(key)); }
	void SetColorParameter(hstring_ref key, const Color& value) { hrcheck(X::get()->_SetColorParameter(key, value)); }
	void SetMatrix3x2Parameter(hstring_ref key, const Foundation::Numerics::Matrix3x2& value) { hrcheck(X::get()->_SetMatrix3x2Parameter(key, value)); }
	void SetMatrix4x4Parameter(hstring_ref key, const Foundation::Numerics::Matrix4x4& value) { hrcheck(X::get()->_SetMatrix4x4Parameter(key, value)); }
	void SetQuaternionParameter(hstring_ref key, const Foundation::Numerics::Quaternion& value) { hrcheck(X::get()->_SetQuaternionParameter(key, value)); }
	void SetReferenceParameter(hstring_ref key, pptr<CompositionObject> compositionObject) { hrcheck(X::get()->_SetReferenceParameter(key, compositionObject)); }
	void SetScalarParameter(hstring_ref key, float value) { hrcheck(X::get()->_SetScalarParameter(key, value)); }
	void SetVector2Parameter(hstring_ref key, const Foundation::Numerics::Vector2& value) { hrcheck(X::get()->_SetVector2Parameter(key, value)); }
	void SetVector3Parameter(hstring_ref key, const Foundation::Numerics::Vector3& value) { hrcheck(X::get()->_SetVector3Parameter(key, value)); }
	void SetVector4Parameter(hstring_ref key, const Foundation::Numerics::Vector4& value) { hrcheck(X::get()->_SetVector4Parameter(key, value)); }
};
template<typename X> struct adapt<ICompositionAnimation, X> : Windows::UI::Composition::ICompositionAnimation_adaptor<X> { typedef adapt ICompositionAnimation; };
struct ICompositionAnimation : ICompositionAnimation_raw, generate<ICompositionAnimation> {};

// ICompositionObjectFactory
struct ICompositionObjectFactory : IInspectable, generate<ICompositionObjectFactory> {};

// ICompositionObject4
struct ICompositionObject4_raw : IInspectable {
	virtual STDMETHODIMP _TryGetAnimationController(HSTRING propertyName, AnimationController* *animationController);
};
template<typename X> struct ICompositionObject4_adaptor : X {
	ptr<AnimationController> TryGetAnimationController(hstring_ref propertyName) { AnimationController* animationController; hrcheck(X::get()->_TryGetAnimationController(propertyName, &animationController)); return from_abi(animationController); }
};
template<typename X> struct adapt<ICompositionObject4, X> : Windows::UI::Composition::ICompositionObject4_adaptor<X> { typedef adapt ICompositionObject4; };
struct ICompositionObject4 : ICompositionObject4_raw, generate<ICompositionObject4> {};

// ICompositionObject3
struct ICompositionObject3_raw : IInspectable {
	virtual STDMETHODIMP _get_DispatcherQueue(System::DispatcherQueue* *value);
};
template<typename X> struct ICompositionObject3_adaptor : X {
	union {
		struct : property {
			ptr<System::DispatcherQueue> get() { System::DispatcherQueue* value; hrcheck(enc(&ICompositionObject3_adaptor::DispatcherQueue)->_get_DispatcherQueue(&value)); return from_abi(value); }
			ptr<System::DispatcherQueue> operator()() { return get(); }
			operator ptr<System::DispatcherQueue> () { return get(); }
			ptr<System::DispatcherQueue> operator->() { return get(); }
		} DispatcherQueue;
	};
	ICompositionObject3_adaptor() {}
};
template<typename X> struct adapt<ICompositionObject3, X> : Windows::UI::Composition::ICompositionObject3_adaptor<X> { typedef adapt ICompositionObject3; };
struct ICompositionObject3 : ICompositionObject3_raw, generate<ICompositionObject3> {};

// ICompositionObject2
struct ICompositionObject2_raw : IInspectable {
	virtual STDMETHODIMP _get_Comment(HSTRING *value);
	virtual STDMETHODIMP _put_Comment(HSTRING value);
	virtual STDMETHODIMP _get_ImplicitAnimations(ImplicitAnimationCollection* *value);
	virtual STDMETHODIMP _put_ImplicitAnimations(ImplicitAnimationCollection* value);
	virtual STDMETHODIMP _StartAnimationGroup(ICompositionAnimationBase* value);
	virtual STDMETHODIMP _StopAnimationGroup(ICompositionAnimationBase* value);
};
template<typename X> struct ICompositionObject2_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICompositionObject2_adaptor::Comment)->_get_Comment(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICompositionObject2_adaptor::Comment)->_put_Comment(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Comment;
		struct : property {
			ptr<ImplicitAnimationCollection> get() { ImplicitAnimationCollection* value; hrcheck(enc(&ICompositionObject2_adaptor::ImplicitAnimations)->_get_ImplicitAnimations(&value)); return from_abi(value); }
			ptr<ImplicitAnimationCollection> operator()() { return get(); }
			operator ptr<ImplicitAnimationCollection> () { return get(); }
			ptr<ImplicitAnimationCollection> operator->() { return get(); }
			void put(pptr<ImplicitAnimationCollection> value) { hrcheck(enc(&ICompositionObject2_adaptor::ImplicitAnimations)->_put_ImplicitAnimations(value)); }
			void operator=(pptr<ImplicitAnimationCollection> value) { put(value); }
			void operator()(pptr<ImplicitAnimationCollection> value) { put(value); }
		} ImplicitAnimations;
	};
	void StartAnimationGroup(pptr<ICompositionAnimationBase> value) { hrcheck(X::get()->_StartAnimationGroup(value)); }
	void StopAnimationGroup(pptr<ICompositionAnimationBase> value) { hrcheck(X::get()->_StopAnimationGroup(value)); }
	ICompositionObject2_adaptor() {}
};
template<typename X> struct adapt<ICompositionObject2, X> : Windows::UI::Composition::ICompositionObject2_adaptor<X> { typedef adapt ICompositionObject2; };
struct ICompositionObject2 : ICompositionObject2_raw, generate<ICompositionObject2> {};

// ICompositionObject
struct ICompositionObject_raw : IInspectable {
	virtual STDMETHODIMP _get_Compositor(Composition::Compositor* *value);
	virtual STDMETHODIMP _get_Dispatcher(UI::Core::CoreDispatcher* *value);
	virtual STDMETHODIMP _get_Properties(CompositionPropertySet* *value);
	virtual STDMETHODIMP _StartAnimation(HSTRING propertyName, CompositionAnimation* animation);
	virtual STDMETHODIMP _StopAnimation(HSTRING propertyName);
};
template<typename X> struct ICompositionObject_adaptor : X {
	union {
		struct : property {
			ptr<Composition::Compositor> get() { Composition::Compositor* value; hrcheck(enc(&ICompositionObject_adaptor::Compositor)->_get_Compositor(&value)); return from_abi(value); }
			ptr<Composition::Compositor> operator()() { return get(); }
			operator ptr<Composition::Compositor> () { return get(); }
			ptr<Composition::Compositor> operator->() { return get(); }
		} Compositor;
		struct : property {
			ptr<UI::Core::CoreDispatcher> get() { UI::Core::CoreDispatcher* value; hrcheck(enc(&ICompositionObject_adaptor::Dispatcher)->_get_Dispatcher(&value)); return from_abi(value); }
			ptr<UI::Core::CoreDispatcher> operator()() { return get(); }
			operator ptr<UI::Core::CoreDispatcher> () { return get(); }
			ptr<UI::Core::CoreDispatcher> operator->() { return get(); }
		} Dispatcher;
		struct : property {
			ptr<CompositionPropertySet> get() { CompositionPropertySet* value; hrcheck(enc(&ICompositionObject_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<CompositionPropertySet> operator()() { return get(); }
			operator ptr<CompositionPropertySet> () { return get(); }
			ptr<CompositionPropertySet> operator->() { return get(); }
		} Properties;
	};
	void StartAnimation(hstring_ref propertyName, pptr<CompositionAnimation> animation) { hrcheck(X::get()->_StartAnimation(propertyName, animation)); }
	void StopAnimation(hstring_ref propertyName) { hrcheck(X::get()->_StopAnimation(propertyName)); }
	ICompositionObject_adaptor() {}
};
template<typename X> struct adapt<ICompositionObject, X> : Windows::UI::Composition::ICompositionObject_adaptor<X> { typedef adapt ICompositionObject; };
struct ICompositionObject : ICompositionObject_raw, generate<ICompositionObject> {};

// CompositionObject
template<typename X> struct statics<CompositionObject, X> : X {
	typedef typename X::root_type CompositionObject;
};
struct CompositionObject : generate<CompositionObject> {};

// ICompositionAnimation2
struct ICompositionAnimation2_raw : IInspectable {
	virtual STDMETHODIMP _SetBooleanParameter(HSTRING key, bool value);
	virtual STDMETHODIMP _get_Target(HSTRING *value);
	virtual STDMETHODIMP _put_Target(HSTRING value);
};
template<typename X> struct ICompositionAnimation2_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICompositionAnimation2_adaptor::Target)->_get_Target(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICompositionAnimation2_adaptor::Target)->_put_Target(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Target;
	};
	void SetBooleanParameter(hstring_ref key, bool value) { hrcheck(X::get()->_SetBooleanParameter(key, value)); }
	ICompositionAnimation2_adaptor() {}
};
template<typename X> struct adapt<ICompositionAnimation2, X> : Windows::UI::Composition::ICompositionAnimation2_adaptor<X> { typedef adapt ICompositionAnimation2; };
struct ICompositionAnimation2 : ICompositionAnimation2_raw, generate<ICompositionAnimation2> {};

// ICompositionAnimation3
struct ICompositionAnimation3_raw : IInspectable {
	virtual STDMETHODIMP _get_InitialValueExpressions(InitialValueExpressionCollection* *value);
};
template<typename X> struct ICompositionAnimation3_adaptor : X {
	union {
		struct : property {
			ptr<InitialValueExpressionCollection> get() { InitialValueExpressionCollection* value; hrcheck(enc(&ICompositionAnimation3_adaptor::InitialValueExpressions)->_get_InitialValueExpressions(&value)); return from_abi(value); }
			ptr<InitialValueExpressionCollection> operator()() { return get(); }
			operator ptr<InitialValueExpressionCollection> () { return get(); }
			ptr<InitialValueExpressionCollection> operator->() { return get(); }
		} InitialValueExpressions;
	};
	ICompositionAnimation3_adaptor() {}
};
template<typename X> struct adapt<ICompositionAnimation3, X> : Windows::UI::Composition::ICompositionAnimation3_adaptor<X> { typedef adapt ICompositionAnimation3; };
struct ICompositionAnimation3 : ICompositionAnimation3_raw, generate<ICompositionAnimation3> {};

// InitialValueExpressionCollection
template<typename X> struct statics<InitialValueExpressionCollection, X> : X {
	typedef typename X::root_type InitialValueExpressionCollection;
};
struct InitialValueExpressionCollection : generate<InitialValueExpressionCollection> {};

// ICompositionAnimationBase
struct ICompositionAnimationBase : IInspectable, generate<ICompositionAnimationBase> {};

// ICompositionAnimationFactory
struct ICompositionAnimationFactory : IInspectable, generate<ICompositionAnimationFactory> {};

// CompositionAnimation
template<typename X> struct statics<CompositionAnimation, X> : X {
	typedef typename X::root_type CompositionAnimation;
};
struct CompositionAnimation : generate<CompositionAnimation> {};

// ICompositionAnimationGroup
struct ICompositionAnimationGroup_raw : IInspectable {
	virtual STDMETHODIMP _get_Count(int *value);
	virtual STDMETHODIMP _Add(CompositionAnimation* value);
	virtual STDMETHODIMP _Remove(CompositionAnimation* value);
	virtual STDMETHODIMP _RemoveAll();
};
template<typename X> struct ICompositionAnimationGroup_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&ICompositionAnimationGroup_adaptor::Count)->_get_Count(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} Count;
	};
	void Add(pptr<CompositionAnimation> value) { hrcheck(X::get()->_Add(value)); }
	void Remove(pptr<CompositionAnimation> value) { hrcheck(X::get()->_Remove(value)); }
	void RemoveAll() { hrcheck(X::get()->_RemoveAll()); }
	ICompositionAnimationGroup_adaptor() {}
};
template<typename X> struct adapt<ICompositionAnimationGroup, X> : Windows::UI::Composition::ICompositionAnimationGroup_adaptor<X> { typedef adapt ICompositionAnimationGroup; };
struct ICompositionAnimationGroup : ICompositionAnimationGroup_raw, generate<ICompositionAnimationGroup> {};

// ICompositionBackdropBrush
struct ICompositionBackdropBrush : IInspectable, generate<ICompositionBackdropBrush> {};

// ICompositionBatchCompletedEventArgs
struct ICompositionBatchCompletedEventArgs : IInspectable, generate<ICompositionBatchCompletedEventArgs> {};

// ICompositionBrush
struct ICompositionBrush : IInspectable, generate<ICompositionBrush> {};

// ICompositionCapabilities
struct ICompositionCapabilities_raw : IInspectable {
	virtual STDMETHODIMP _AreEffectsSupported(bool *value);
	virtual STDMETHODIMP _AreEffectsFast(bool *value);
	virtual STDMETHODIMP _add_Changed(Foundation::TypedEventHandler<CompositionCapabilities*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Changed(Foundation::EventRegistrationToken token);
};
template<typename X> struct ICompositionCapabilities_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<CompositionCapabilities>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICompositionCapabilities_adaptor::Changed)->_add_Changed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICompositionCapabilities_adaptor::Changed)->_remove_Changed(token)); }
		} Changed;
	};
	bool AreEffectsSupported() { bool value; hrcheck(X::get()->_AreEffectsSupported(&value)); return value; }
	bool AreEffectsFast() { bool value; hrcheck(X::get()->_AreEffectsFast(&value)); return value; }
	ICompositionCapabilities_adaptor() {}
};
template<typename X> struct adapt<ICompositionCapabilities, X> : Windows::UI::Composition::ICompositionCapabilities_adaptor<X> { typedef adapt ICompositionCapabilities; };
struct ICompositionCapabilities : ICompositionCapabilities_raw, generate<ICompositionCapabilities> {};

// ICompositionCapabilitiesStatics
struct ICompositionCapabilitiesStatics : IInspectable {
	virtual STDMETHODIMP _GetForCurrentView(CompositionCapabilities* *current);
};

// CompositionCapabilities
template<typename> struct CompositionCapabilities_statics {
	static ptr<CompositionCapabilities> GetForCurrentView() { CompositionCapabilities* current; hrcheck(get_activation_factory<CompositionCapabilities, ICompositionCapabilitiesStatics>()->_GetForCurrentView(&current)); return from_abi(current); }
};

template<typename X> struct statics<CompositionCapabilities, X> : X, Windows::UI::Composition::CompositionCapabilities_statics<void> {
	typedef typename X::root_type CompositionCapabilities;
};
struct CompositionCapabilities : generate<CompositionCapabilities> {};

// ICompositionClip
struct ICompositionClip : IInspectable, generate<ICompositionClip> {};

// ICompositionClip2
struct ICompositionClip2_raw : IInspectable {
	virtual STDMETHODIMP _get_AnchorPoint(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_AnchorPoint(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_CenterPoint(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_CenterPoint(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_Offset(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Offset(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_RotationAngle(float *value);
	virtual STDMETHODIMP _put_RotationAngle(float value);
	virtual STDMETHODIMP _get_RotationAngleInDegrees(float *value);
	virtual STDMETHODIMP _put_RotationAngleInDegrees(float value);
	virtual STDMETHODIMP _get_Scale(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Scale(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_TransformMatrix(Foundation::Numerics::Matrix3x2 *value);
	virtual STDMETHODIMP _put_TransformMatrix(Foundation::Numerics::Matrix3x2 value);
};
template<typename X> struct ICompositionClip2_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionClip2_adaptor::AnchorPoint)->_get_AnchorPoint(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionClip2_adaptor::AnchorPoint)->_put_AnchorPoint(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} AnchorPoint;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionClip2_adaptor::CenterPoint)->_get_CenterPoint(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionClip2_adaptor::CenterPoint)->_put_CenterPoint(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} CenterPoint;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionClip2_adaptor::Offset)->_get_Offset(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionClip2_adaptor::Offset)->_put_Offset(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Offset;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionClip2_adaptor::RotationAngle)->_get_RotationAngle(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionClip2_adaptor::RotationAngle)->_put_RotationAngle(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} RotationAngle;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionClip2_adaptor::RotationAngleInDegrees)->_get_RotationAngleInDegrees(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionClip2_adaptor::RotationAngleInDegrees)->_put_RotationAngleInDegrees(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} RotationAngleInDegrees;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionClip2_adaptor::Scale)->_get_Scale(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionClip2_adaptor::Scale)->_put_Scale(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Scale;
		struct : property {
			Foundation::Numerics::Matrix3x2 get() { Foundation::Numerics::Matrix3x2 value; hrcheck(enc(&ICompositionClip2_adaptor::TransformMatrix)->_get_TransformMatrix(&value)); return value; }
			Foundation::Numerics::Matrix3x2 operator()() { return get(); }
			operator Foundation::Numerics::Matrix3x2 () { return get(); }
			void put(const Foundation::Numerics::Matrix3x2& value) { hrcheck(enc(&ICompositionClip2_adaptor::TransformMatrix)->_put_TransformMatrix(value)); }
			void operator=(const Foundation::Numerics::Matrix3x2& value) { put(value); }
			void operator()(const Foundation::Numerics::Matrix3x2& value) { put(value); }
		} TransformMatrix;
	};
	ICompositionClip2_adaptor() {}
};
template<typename X> struct adapt<ICompositionClip2, X> : Windows::UI::Composition::ICompositionClip2_adaptor<X> { typedef adapt ICompositionClip2; };
struct ICompositionClip2 : ICompositionClip2_raw, generate<ICompositionClip2> {};

// ICompositionColorBrush
struct ICompositionColorBrush_raw : IInspectable {
	virtual STDMETHODIMP _get_Color(UI::Color *value);
	virtual STDMETHODIMP _put_Color(UI::Color value);
};
template<typename X> struct ICompositionColorBrush_adaptor : X {
	union {
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&ICompositionColorBrush_adaptor::Color)->_get_Color(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&ICompositionColorBrush_adaptor::Color)->_put_Color(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} Color;
	};
	ICompositionColorBrush_adaptor() {}
};
template<typename X> struct adapt<ICompositionColorBrush, X> : Windows::UI::Composition::ICompositionColorBrush_adaptor<X> { typedef adapt ICompositionColorBrush; };
struct ICompositionColorBrush : ICompositionColorBrush_raw, generate<ICompositionColorBrush> {};

// ICompositionColorGradientStop
struct ICompositionColorGradientStop_raw : IInspectable {
	virtual STDMETHODIMP _get_Color(UI::Color *value);
	virtual STDMETHODIMP _put_Color(UI::Color value);
	virtual STDMETHODIMP _get_Offset(float *value);
	virtual STDMETHODIMP _put_Offset(float value);
};
template<typename X> struct ICompositionColorGradientStop_adaptor : X {
	union {
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&ICompositionColorGradientStop_adaptor::Color)->_get_Color(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&ICompositionColorGradientStop_adaptor::Color)->_put_Color(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} Color;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionColorGradientStop_adaptor::Offset)->_get_Offset(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionColorGradientStop_adaptor::Offset)->_put_Offset(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Offset;
	};
	ICompositionColorGradientStop_adaptor() {}
};
template<typename X> struct adapt<ICompositionColorGradientStop, X> : Windows::UI::Composition::ICompositionColorGradientStop_adaptor<X> { typedef adapt ICompositionColorGradientStop; };
struct ICompositionColorGradientStop : ICompositionColorGradientStop_raw, generate<ICompositionColorGradientStop> {};

// CompositionColorGradientStop
template<typename X> struct statics<CompositionColorGradientStop, X> : X {
	typedef typename X::root_type CompositionColorGradientStop;
};
struct CompositionColorGradientStop : generate<CompositionColorGradientStop> {};

// ICompositionColorGradientStopCollection
struct ICompositionColorGradientStopCollection : IInspectable, generate<ICompositionColorGradientStopCollection> {};

// ICompositionCommitBatch
struct ICompositionCommitBatch_raw : IInspectable {
	virtual STDMETHODIMP _get_IsActive(bool *value);
	virtual STDMETHODIMP _get_IsEnded(bool *value);
	virtual STDMETHODIMP _add_Completed(Foundation::TypedEventHandler<IInspectable*, CompositionBatchCompletedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Completed(Foundation::EventRegistrationToken token);
};
template<typename X> struct ICompositionCommitBatch_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICompositionCommitBatch_adaptor::IsActive)->_get_IsActive(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsActive;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICompositionCommitBatch_adaptor::IsEnded)->_get_IsEnded(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsEnded;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<object, ptr<CompositionBatchCompletedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICompositionCommitBatch_adaptor::Completed)->_add_Completed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICompositionCommitBatch_adaptor::Completed)->_remove_Completed(token)); }
		} Completed;
	};
	ICompositionCommitBatch_adaptor() {}
};
template<typename X> struct adapt<ICompositionCommitBatch, X> : Windows::UI::Composition::ICompositionCommitBatch_adaptor<X> { typedef adapt ICompositionCommitBatch; };
struct ICompositionCommitBatch : ICompositionCommitBatch_raw, generate<ICompositionCommitBatch> {};

// CompositionBatchCompletedEventArgs
template<typename X> struct statics<CompositionBatchCompletedEventArgs, X> : X {
	typedef typename X::root_type CompositionBatchCompletedEventArgs;
};
struct CompositionBatchCompletedEventArgs : generate<CompositionBatchCompletedEventArgs> {};

// ICompositionContainerShape
struct ICompositionContainerShape_raw : IInspectable {
	virtual STDMETHODIMP _get_Shapes(CompositionShapeCollection* *value);
};
template<typename X> struct ICompositionContainerShape_adaptor : X {
	union {
		struct : property {
			ptr<CompositionShapeCollection> get() { CompositionShapeCollection* value; hrcheck(enc(&ICompositionContainerShape_adaptor::Shapes)->_get_Shapes(&value)); return from_abi(value); }
			ptr<CompositionShapeCollection> operator()() { return get(); }
			operator ptr<CompositionShapeCollection> () { return get(); }
			ptr<CompositionShapeCollection> operator->() { return get(); }
		} Shapes;
	};
	ICompositionContainerShape_adaptor() {}
};
template<typename X> struct adapt<ICompositionContainerShape, X> : Windows::UI::Composition::ICompositionContainerShape_adaptor<X> { typedef adapt ICompositionContainerShape; };
struct ICompositionContainerShape : ICompositionContainerShape_raw, generate<ICompositionContainerShape> {};

// ICompositionShapeFactory
struct ICompositionShapeFactory : IInspectable, generate<ICompositionShapeFactory> {};

// ICompositionShape
struct ICompositionShape_raw : IInspectable {
	virtual STDMETHODIMP _get_CenterPoint(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_CenterPoint(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_Offset(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Offset(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_RotationAngle(float *value);
	virtual STDMETHODIMP _put_RotationAngle(float value);
	virtual STDMETHODIMP _get_RotationAngleInDegrees(float *value);
	virtual STDMETHODIMP _put_RotationAngleInDegrees(float value);
	virtual STDMETHODIMP _get_Scale(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Scale(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_TransformMatrix(Foundation::Numerics::Matrix3x2 *value);
	virtual STDMETHODIMP _put_TransformMatrix(Foundation::Numerics::Matrix3x2 value);
};
template<typename X> struct ICompositionShape_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionShape_adaptor::CenterPoint)->_get_CenterPoint(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionShape_adaptor::CenterPoint)->_put_CenterPoint(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} CenterPoint;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionShape_adaptor::Offset)->_get_Offset(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionShape_adaptor::Offset)->_put_Offset(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Offset;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionShape_adaptor::RotationAngle)->_get_RotationAngle(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionShape_adaptor::RotationAngle)->_put_RotationAngle(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} RotationAngle;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionShape_adaptor::RotationAngleInDegrees)->_get_RotationAngleInDegrees(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionShape_adaptor::RotationAngleInDegrees)->_put_RotationAngleInDegrees(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} RotationAngleInDegrees;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionShape_adaptor::Scale)->_get_Scale(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionShape_adaptor::Scale)->_put_Scale(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Scale;
		struct : property {
			Foundation::Numerics::Matrix3x2 get() { Foundation::Numerics::Matrix3x2 value; hrcheck(enc(&ICompositionShape_adaptor::TransformMatrix)->_get_TransformMatrix(&value)); return value; }
			Foundation::Numerics::Matrix3x2 operator()() { return get(); }
			operator Foundation::Numerics::Matrix3x2 () { return get(); }
			void put(const Foundation::Numerics::Matrix3x2& value) { hrcheck(enc(&ICompositionShape_adaptor::TransformMatrix)->_put_TransformMatrix(value)); }
			void operator=(const Foundation::Numerics::Matrix3x2& value) { put(value); }
			void operator()(const Foundation::Numerics::Matrix3x2& value) { put(value); }
		} TransformMatrix;
	};
	ICompositionShape_adaptor() {}
};
template<typename X> struct adapt<ICompositionShape, X> : Windows::UI::Composition::ICompositionShape_adaptor<X> { typedef adapt ICompositionShape; };
struct ICompositionShape : ICompositionShape_raw, generate<ICompositionShape> {};

// CompositionShape
template<typename X> struct statics<CompositionShape, X> : X {
	typedef typename X::root_type CompositionShape;
};
struct CompositionShape : generate<CompositionShape> {};

// CompositionShapeCollection
template<typename X> struct statics<CompositionShapeCollection, X> : X {
	typedef typename X::root_type CompositionShapeCollection;
};
struct CompositionShapeCollection : generate<CompositionShapeCollection> {};

// ICompositionDrawingSurface
struct ICompositionDrawingSurface_raw : IInspectable {
	virtual STDMETHODIMP _get_AlphaMode(Graphics::DirectX::DirectXAlphaMode *value);
	virtual STDMETHODIMP _get_PixelFormat(Graphics::DirectX::DirectXPixelFormat *value);
	virtual STDMETHODIMP _get_Size(Foundation::Size *value);
};
template<typename X> struct ICompositionDrawingSurface_adaptor : X {
	union {
		struct : property {
			Graphics::DirectX::DirectXAlphaMode get() { Graphics::DirectX::DirectXAlphaMode value; hrcheck(enc(&ICompositionDrawingSurface_adaptor::AlphaMode)->_get_AlphaMode(&value)); return value; }
			Graphics::DirectX::DirectXAlphaMode operator()() { return get(); }
			operator Graphics::DirectX::DirectXAlphaMode () { return get(); }
		} AlphaMode;
		struct : property {
			Graphics::DirectX::DirectXPixelFormat get() { Graphics::DirectX::DirectXPixelFormat value; hrcheck(enc(&ICompositionDrawingSurface_adaptor::PixelFormat)->_get_PixelFormat(&value)); return value; }
			Graphics::DirectX::DirectXPixelFormat operator()() { return get(); }
			operator Graphics::DirectX::DirectXPixelFormat () { return get(); }
		} PixelFormat;
		struct : property {
			Foundation::Size get() { Foundation::Size value; hrcheck(enc(&ICompositionDrawingSurface_adaptor::Size)->_get_Size(&value)); return value; }
			Foundation::Size operator()() { return get(); }
			operator Foundation::Size () { return get(); }
		} Size;
	};
	ICompositionDrawingSurface_adaptor() {}
};
template<typename X> struct adapt<ICompositionDrawingSurface, X> : Windows::UI::Composition::ICompositionDrawingSurface_adaptor<X> { typedef adapt ICompositionDrawingSurface; };
struct ICompositionDrawingSurface : ICompositionDrawingSurface_raw, generate<ICompositionDrawingSurface> {};

// ICompositionDrawingSurface2
struct ICompositionDrawingSurface2_raw : IInspectable {
	virtual STDMETHODIMP _get_SizeInt32(Graphics::SizeInt32 *value);
	virtual STDMETHODIMP _Resize(Graphics::SizeInt32 sizePixels);
	virtual STDMETHODIMP _Scroll(Graphics::PointInt32 offset);
	virtual STDMETHODIMP _ScrollRect(Graphics::PointInt32 offset, Graphics::RectInt32 scrollRect);
	virtual STDMETHODIMP _ScrollWithClip(Graphics::PointInt32 offset, Graphics::RectInt32 clipRect);
	virtual STDMETHODIMP _ScrollRectWithClip(Graphics::PointInt32 offset, Graphics::RectInt32 clipRect, Graphics::RectInt32 scrollRect);
};
template<typename X> struct ICompositionDrawingSurface2_adaptor : X {
	union {
		struct : property {
			Graphics::SizeInt32 get() { Graphics::SizeInt32 value; hrcheck(enc(&ICompositionDrawingSurface2_adaptor::SizeInt32)->_get_SizeInt32(&value)); return value; }
			Graphics::SizeInt32 operator()() { return get(); }
			operator Graphics::SizeInt32 () { return get(); }
		} SizeInt32;
	};
	void Resize(const Graphics::SizeInt32& sizePixels) { hrcheck(X::get()->_Resize(sizePixels)); }
	void Scroll(const Graphics::PointInt32& offset) { hrcheck(X::get()->_Scroll(offset)); }
	void Scroll(const Graphics::PointInt32& offset, const Graphics::RectInt32& scrollRect) { hrcheck(X::get()->_ScrollRect(offset, scrollRect)); }
	void ScrollWithClip(const Graphics::PointInt32& offset, const Graphics::RectInt32& clipRect) { hrcheck(X::get()->_ScrollWithClip(offset, clipRect)); }
	void ScrollWithClip(const Graphics::PointInt32& offset, const Graphics::RectInt32& clipRect, const Graphics::RectInt32& scrollRect) { hrcheck(X::get()->_ScrollRectWithClip(offset, clipRect, scrollRect)); }
	ICompositionDrawingSurface2_adaptor() {}
};
template<typename X> struct adapt<ICompositionDrawingSurface2, X> : Windows::UI::Composition::ICompositionDrawingSurface2_adaptor<X> { typedef adapt ICompositionDrawingSurface2; };
struct ICompositionDrawingSurface2 : ICompositionDrawingSurface2_raw, generate<ICompositionDrawingSurface2> {};

// ICompositionEasingFunction
struct ICompositionEasingFunction : IInspectable, generate<ICompositionEasingFunction> {};

// ICompositionEasingFunctionFactory
struct ICompositionEasingFunctionFactory : IInspectable, generate<ICompositionEasingFunctionFactory> {};

// CompositionEasingFunction
template<typename X> struct statics<CompositionEasingFunction, X> : X {
	typedef typename X::root_type CompositionEasingFunction;
};
struct CompositionEasingFunction : generate<CompositionEasingFunction> {};

// ICompositionEllipseGeometry
struct ICompositionEllipseGeometry_raw : IInspectable {
	virtual STDMETHODIMP _get_Center(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Center(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_Radius(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Radius(Foundation::Numerics::Vector2 value);
};
template<typename X> struct ICompositionEllipseGeometry_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionEllipseGeometry_adaptor::Center)->_get_Center(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionEllipseGeometry_adaptor::Center)->_put_Center(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Center;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionEllipseGeometry_adaptor::Radius)->_get_Radius(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionEllipseGeometry_adaptor::Radius)->_put_Radius(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Radius;
	};
	ICompositionEllipseGeometry_adaptor() {}
};
template<typename X> struct adapt<ICompositionEllipseGeometry, X> : Windows::UI::Composition::ICompositionEllipseGeometry_adaptor<X> { typedef adapt ICompositionEllipseGeometry; };
struct ICompositionEllipseGeometry : ICompositionEllipseGeometry_raw, generate<ICompositionEllipseGeometry> {};

// ICompositionEffectBrush
struct ICompositionEffectBrush_raw : IInspectable {
	virtual STDMETHODIMP _GetSourceParameter(HSTRING name, CompositionBrush* *result);
	virtual STDMETHODIMP _SetSourceParameter(HSTRING name, CompositionBrush* source);
};
template<typename X> struct ICompositionEffectBrush_adaptor : X {
	ptr<CompositionBrush> GetSourceParameter(hstring_ref name) { CompositionBrush* result; hrcheck(X::get()->_GetSourceParameter(name, &result)); return from_abi(result); }
	void SetSourceParameter(hstring_ref name, pptr<CompositionBrush> source) { hrcheck(X::get()->_SetSourceParameter(name, source)); }
};
template<typename X> struct adapt<ICompositionEffectBrush, X> : Windows::UI::Composition::ICompositionEffectBrush_adaptor<X> { typedef adapt ICompositionEffectBrush; };
struct ICompositionEffectBrush : ICompositionEffectBrush_raw, generate<ICompositionEffectBrush> {};

// ICompositionBrushFactory
struct ICompositionBrushFactory : IInspectable, generate<ICompositionBrushFactory> {};

// CompositionBrush
template<typename X> struct statics<CompositionBrush, X> : X {
	typedef typename X::root_type CompositionBrush;
};
struct CompositionBrush : generate<CompositionBrush> {};

// ICompositionEffectFactory
struct ICompositionEffectFactory_raw : IInspectable {
	virtual STDMETHODIMP _CreateBrush(CompositionEffectBrush* *result);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
	virtual STDMETHODIMP _get_LoadStatus(CompositionEffectFactoryLoadStatus *value);
};
template<typename X> struct ICompositionEffectFactory_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&ICompositionEffectFactory_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			CompositionEffectFactoryLoadStatus get() { CompositionEffectFactoryLoadStatus value; hrcheck(enc(&ICompositionEffectFactory_adaptor::LoadStatus)->_get_LoadStatus(&value)); return value; }
			CompositionEffectFactoryLoadStatus operator()() { return get(); }
			operator CompositionEffectFactoryLoadStatus () { return get(); }
		} LoadStatus;
	};
	ptr<CompositionEffectBrush> CreateBrush() { CompositionEffectBrush* result; hrcheck(X::get()->_CreateBrush(&result)); return from_abi(result); }
	ICompositionEffectFactory_adaptor() {}
};
template<typename X> struct adapt<ICompositionEffectFactory, X> : Windows::UI::Composition::ICompositionEffectFactory_adaptor<X> { typedef adapt ICompositionEffectFactory; };
struct ICompositionEffectFactory : ICompositionEffectFactory_raw, generate<ICompositionEffectFactory> {};

// CompositionEffectBrush
template<typename X> struct statics<CompositionEffectBrush, X> : X {
	typedef typename X::root_type CompositionEffectBrush;
};
struct CompositionEffectBrush : generate<CompositionEffectBrush> {};

// ICompositionEffectSourceParameter
struct ICompositionEffectSourceParameter_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
};
template<typename X> struct ICompositionEffectSourceParameter_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICompositionEffectSourceParameter_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
	};
	ICompositionEffectSourceParameter_adaptor() {}
};
template<typename X> struct adapt<ICompositionEffectSourceParameter, X> : Windows::UI::Composition::ICompositionEffectSourceParameter_adaptor<X> { typedef adapt ICompositionEffectSourceParameter; };
struct ICompositionEffectSourceParameter : ICompositionEffectSourceParameter_raw, generate<ICompositionEffectSourceParameter> {};

// ICompositionEffectSourceParameterFactory
struct ICompositionEffectSourceParameterFactory : IInspectable {
	virtual STDMETHODIMP _Create(HSTRING name, CompositionEffectSourceParameter* *instance);
};

// CompositionEffectSourceParameter
template<typename> struct CompositionEffectSourceParameter_statics {
	static CompositionEffectSourceParameter *activate(hstring_ref name) { CompositionEffectSourceParameter *instance; hrcheck(get_activation_factory<CompositionEffectSourceParameter, ICompositionEffectSourceParameterFactory>()->_Create(name, &instance)); return instance; }
};

template<typename X> struct statics<CompositionEffectSourceParameter, X> : X, Windows::UI::Composition::CompositionEffectSourceParameter_statics<void> {
	using Windows::UI::Composition::CompositionEffectSourceParameter_statics<void>::activate;
	typedef typename X::root_type CompositionEffectSourceParameter;
};
struct CompositionEffectSourceParameter : generate<CompositionEffectSourceParameter> {};

// ICompositionGeometry
struct ICompositionGeometry_raw : IInspectable {
	virtual STDMETHODIMP _get_TrimEnd(float *value);
	virtual STDMETHODIMP _put_TrimEnd(float value);
	virtual STDMETHODIMP _get_TrimOffset(float *value);
	virtual STDMETHODIMP _put_TrimOffset(float value);
	virtual STDMETHODIMP _get_TrimStart(float *value);
	virtual STDMETHODIMP _put_TrimStart(float value);
};
template<typename X> struct ICompositionGeometry_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionGeometry_adaptor::TrimEnd)->_get_TrimEnd(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionGeometry_adaptor::TrimEnd)->_put_TrimEnd(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} TrimEnd;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionGeometry_adaptor::TrimOffset)->_get_TrimOffset(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionGeometry_adaptor::TrimOffset)->_put_TrimOffset(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} TrimOffset;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionGeometry_adaptor::TrimStart)->_get_TrimStart(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionGeometry_adaptor::TrimStart)->_put_TrimStart(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} TrimStart;
	};
	ICompositionGeometry_adaptor() {}
};
template<typename X> struct adapt<ICompositionGeometry, X> : Windows::UI::Composition::ICompositionGeometry_adaptor<X> { typedef adapt ICompositionGeometry; };
struct ICompositionGeometry : ICompositionGeometry_raw, generate<ICompositionGeometry> {};

// ICompositionGradientBrush
struct ICompositionGradientBrush_raw : IInspectable {
	virtual STDMETHODIMP _get_AnchorPoint(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_AnchorPoint(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_CenterPoint(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_CenterPoint(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_ColorStops(CompositionColorGradientStopCollection* *value);
	virtual STDMETHODIMP _get_ExtendMode(CompositionGradientExtendMode *value);
	virtual STDMETHODIMP _put_ExtendMode(CompositionGradientExtendMode value);
	virtual STDMETHODIMP _get_InterpolationSpace(CompositionColorSpace *value);
	virtual STDMETHODIMP _put_InterpolationSpace(CompositionColorSpace value);
	virtual STDMETHODIMP _get_Offset(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Offset(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_RotationAngle(float *value);
	virtual STDMETHODIMP _put_RotationAngle(float value);
	virtual STDMETHODIMP _get_RotationAngleInDegrees(float *value);
	virtual STDMETHODIMP _put_RotationAngleInDegrees(float value);
	virtual STDMETHODIMP _get_Scale(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Scale(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_TransformMatrix(Foundation::Numerics::Matrix3x2 *value);
	virtual STDMETHODIMP _put_TransformMatrix(Foundation::Numerics::Matrix3x2 value);
};
template<typename X> struct ICompositionGradientBrush_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionGradientBrush_adaptor::AnchorPoint)->_get_AnchorPoint(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionGradientBrush_adaptor::AnchorPoint)->_put_AnchorPoint(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} AnchorPoint;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionGradientBrush_adaptor::CenterPoint)->_get_CenterPoint(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionGradientBrush_adaptor::CenterPoint)->_put_CenterPoint(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} CenterPoint;
		struct : property {
			ptr<CompositionColorGradientStopCollection> get() { CompositionColorGradientStopCollection* value; hrcheck(enc(&ICompositionGradientBrush_adaptor::ColorStops)->_get_ColorStops(&value)); return from_abi(value); }
			ptr<CompositionColorGradientStopCollection> operator()() { return get(); }
			operator ptr<CompositionColorGradientStopCollection> () { return get(); }
			ptr<CompositionColorGradientStopCollection> operator->() { return get(); }
		} ColorStops;
		struct : property {
			CompositionGradientExtendMode get() { CompositionGradientExtendMode value; hrcheck(enc(&ICompositionGradientBrush_adaptor::ExtendMode)->_get_ExtendMode(&value)); return value; }
			CompositionGradientExtendMode operator()() { return get(); }
			operator CompositionGradientExtendMode () { return get(); }
			void put(CompositionGradientExtendMode value) { hrcheck(enc(&ICompositionGradientBrush_adaptor::ExtendMode)->_put_ExtendMode(value)); }
			void operator=(CompositionGradientExtendMode value) { put(value); }
			void operator()(CompositionGradientExtendMode value) { put(value); }
		} ExtendMode;
		struct : property {
			CompositionColorSpace get() { CompositionColorSpace value; hrcheck(enc(&ICompositionGradientBrush_adaptor::InterpolationSpace)->_get_InterpolationSpace(&value)); return value; }
			CompositionColorSpace operator()() { return get(); }
			operator CompositionColorSpace () { return get(); }
			void put(CompositionColorSpace value) { hrcheck(enc(&ICompositionGradientBrush_adaptor::InterpolationSpace)->_put_InterpolationSpace(value)); }
			void operator=(CompositionColorSpace value) { put(value); }
			void operator()(CompositionColorSpace value) { put(value); }
		} InterpolationSpace;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionGradientBrush_adaptor::Offset)->_get_Offset(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionGradientBrush_adaptor::Offset)->_put_Offset(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Offset;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionGradientBrush_adaptor::RotationAngle)->_get_RotationAngle(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionGradientBrush_adaptor::RotationAngle)->_put_RotationAngle(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} RotationAngle;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionGradientBrush_adaptor::RotationAngleInDegrees)->_get_RotationAngleInDegrees(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionGradientBrush_adaptor::RotationAngleInDegrees)->_put_RotationAngleInDegrees(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} RotationAngleInDegrees;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionGradientBrush_adaptor::Scale)->_get_Scale(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionGradientBrush_adaptor::Scale)->_put_Scale(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Scale;
		struct : property {
			Foundation::Numerics::Matrix3x2 get() { Foundation::Numerics::Matrix3x2 value; hrcheck(enc(&ICompositionGradientBrush_adaptor::TransformMatrix)->_get_TransformMatrix(&value)); return value; }
			Foundation::Numerics::Matrix3x2 operator()() { return get(); }
			operator Foundation::Numerics::Matrix3x2 () { return get(); }
			void put(const Foundation::Numerics::Matrix3x2& value) { hrcheck(enc(&ICompositionGradientBrush_adaptor::TransformMatrix)->_put_TransformMatrix(value)); }
			void operator=(const Foundation::Numerics::Matrix3x2& value) { put(value); }
			void operator()(const Foundation::Numerics::Matrix3x2& value) { put(value); }
		} TransformMatrix;
	};
	ICompositionGradientBrush_adaptor() {}
};
template<typename X> struct adapt<ICompositionGradientBrush, X> : Windows::UI::Composition::ICompositionGradientBrush_adaptor<X> { typedef adapt ICompositionGradientBrush; };
struct ICompositionGradientBrush : ICompositionGradientBrush_raw, generate<ICompositionGradientBrush> {};

// CompositionColorGradientStopCollection
template<typename X> struct statics<CompositionColorGradientStopCollection, X> : X {
	typedef typename X::root_type CompositionColorGradientStopCollection;
};
struct CompositionColorGradientStopCollection : generate<CompositionColorGradientStopCollection> {};

// ICompositionGraphicsDevice
struct ICompositionGraphicsDevice_raw : IInspectable {
	virtual STDMETHODIMP _CreateDrawingSurface(Foundation::Size sizePixels, Graphics::DirectX::DirectXPixelFormat pixelFormat, Graphics::DirectX::DirectXAlphaMode alphaMode, CompositionDrawingSurface* *result);
	virtual STDMETHODIMP _add_RenderingDeviceReplaced(Foundation::TypedEventHandler<CompositionGraphicsDevice*, RenderingDeviceReplacedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_RenderingDeviceReplaced(Foundation::EventRegistrationToken token);
};
template<typename X> struct ICompositionGraphicsDevice_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<CompositionGraphicsDevice>, ptr<RenderingDeviceReplacedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICompositionGraphicsDevice_adaptor::RenderingDeviceReplaced)->_add_RenderingDeviceReplaced(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICompositionGraphicsDevice_adaptor::RenderingDeviceReplaced)->_remove_RenderingDeviceReplaced(token)); }
		} RenderingDeviceReplaced;
	};
	ptr<CompositionDrawingSurface> CreateDrawingSurface(const Foundation::Size& sizePixels, Graphics::DirectX::DirectXPixelFormat pixelFormat, Graphics::DirectX::DirectXAlphaMode alphaMode) { CompositionDrawingSurface* result; hrcheck(X::get()->_CreateDrawingSurface(sizePixels, pixelFormat, alphaMode, &result)); return from_abi(result); }
	ICompositionGraphicsDevice_adaptor() {}
};
template<typename X> struct adapt<ICompositionGraphicsDevice, X> : Windows::UI::Composition::ICompositionGraphicsDevice_adaptor<X> { typedef adapt ICompositionGraphicsDevice; };
struct ICompositionGraphicsDevice : ICompositionGraphicsDevice_raw, generate<ICompositionGraphicsDevice> {};

// ICompositionGraphicsDevice2
struct ICompositionGraphicsDevice2_raw : IInspectable {
	virtual STDMETHODIMP _CreateDrawingSurface2(Graphics::SizeInt32 sizePixels, Graphics::DirectX::DirectXPixelFormat pixelFormat, Graphics::DirectX::DirectXAlphaMode alphaMode, CompositionDrawingSurface* *result);
	virtual STDMETHODIMP _CreateVirtualDrawingSurface(Graphics::SizeInt32 sizePixels, Graphics::DirectX::DirectXPixelFormat pixelFormat, Graphics::DirectX::DirectXAlphaMode alphaMode, CompositionVirtualDrawingSurface* *result);
};
template<typename X> struct ICompositionGraphicsDevice2_adaptor : X {
	ptr<CompositionDrawingSurface> CreateDrawingSurface2(const Graphics::SizeInt32& sizePixels, Graphics::DirectX::DirectXPixelFormat pixelFormat, Graphics::DirectX::DirectXAlphaMode alphaMode) { CompositionDrawingSurface* result; hrcheck(X::get()->_CreateDrawingSurface2(sizePixels, pixelFormat, alphaMode, &result)); return from_abi(result); }
	ptr<CompositionVirtualDrawingSurface> CreateVirtualDrawingSurface(const Graphics::SizeInt32& sizePixels, Graphics::DirectX::DirectXPixelFormat pixelFormat, Graphics::DirectX::DirectXAlphaMode alphaMode) { CompositionVirtualDrawingSurface* result; hrcheck(X::get()->_CreateVirtualDrawingSurface(sizePixels, pixelFormat, alphaMode, &result)); return from_abi(result); }
};
template<typename X> struct adapt<ICompositionGraphicsDevice2, X> : Windows::UI::Composition::ICompositionGraphicsDevice2_adaptor<X> { typedef adapt ICompositionGraphicsDevice2; };
struct ICompositionGraphicsDevice2 : ICompositionGraphicsDevice2_raw, generate<ICompositionGraphicsDevice2> {};

// CompositionGraphicsDevice
template<typename X> struct statics<CompositionGraphicsDevice, X> : X {
	typedef typename X::root_type CompositionGraphicsDevice;
};
struct CompositionGraphicsDevice : generate<CompositionGraphicsDevice> {};

// ICompositionLight
struct ICompositionLight_raw : IInspectable {
	virtual STDMETHODIMP _get_Targets(VisualUnorderedCollection* *value);
};
template<typename X> struct ICompositionLight_adaptor : X {
	union {
		struct : property {
			ptr<VisualUnorderedCollection> get() { VisualUnorderedCollection* value; hrcheck(enc(&ICompositionLight_adaptor::Targets)->_get_Targets(&value)); return from_abi(value); }
			ptr<VisualUnorderedCollection> operator()() { return get(); }
			operator ptr<VisualUnorderedCollection> () { return get(); }
			ptr<VisualUnorderedCollection> operator->() { return get(); }
		} Targets;
	};
	ICompositionLight_adaptor() {}
};
template<typename X> struct adapt<ICompositionLight, X> : Windows::UI::Composition::ICompositionLight_adaptor<X> { typedef adapt ICompositionLight; };
struct ICompositionLight : ICompositionLight_raw, generate<ICompositionLight> {};

// ICompositionLight2
struct ICompositionLight2_raw : IInspectable {
	virtual STDMETHODIMP _get_ExclusionsFromTargets(VisualUnorderedCollection* *value);
};
template<typename X> struct ICompositionLight2_adaptor : X {
	union {
		struct : property {
			ptr<VisualUnorderedCollection> get() { VisualUnorderedCollection* value; hrcheck(enc(&ICompositionLight2_adaptor::ExclusionsFromTargets)->_get_ExclusionsFromTargets(&value)); return from_abi(value); }
			ptr<VisualUnorderedCollection> operator()() { return get(); }
			operator ptr<VisualUnorderedCollection> () { return get(); }
			ptr<VisualUnorderedCollection> operator->() { return get(); }
		} ExclusionsFromTargets;
	};
	ICompositionLight2_adaptor() {}
};
template<typename X> struct adapt<ICompositionLight2, X> : Windows::UI::Composition::ICompositionLight2_adaptor<X> { typedef adapt ICompositionLight2; };
struct ICompositionLight2 : ICompositionLight2_raw, generate<ICompositionLight2> {};

// ICompositionLight3
struct ICompositionLight3_raw : IInspectable {
	virtual STDMETHODIMP _get_IsEnabled(bool *value);
	virtual STDMETHODIMP _put_IsEnabled(bool value);
};
template<typename X> struct ICompositionLight3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICompositionLight3_adaptor::IsEnabled)->_get_IsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICompositionLight3_adaptor::IsEnabled)->_put_IsEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsEnabled;
	};
	ICompositionLight3_adaptor() {}
};
template<typename X> struct adapt<ICompositionLight3, X> : Windows::UI::Composition::ICompositionLight3_adaptor<X> { typedef adapt ICompositionLight3; };
struct ICompositionLight3 : ICompositionLight3_raw, generate<ICompositionLight3> {};

// ICompositionLineGeometry
struct ICompositionLineGeometry_raw : IInspectable {
	virtual STDMETHODIMP _get_Start(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Start(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_End(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_End(Foundation::Numerics::Vector2 value);
};
template<typename X> struct ICompositionLineGeometry_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionLineGeometry_adaptor::End)->_get_End(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionLineGeometry_adaptor::End)->_put_End(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} End;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionLineGeometry_adaptor::Start)->_get_Start(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionLineGeometry_adaptor::Start)->_put_Start(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Start;
	};
	ICompositionLineGeometry_adaptor() {}
};
template<typename X> struct adapt<ICompositionLineGeometry, X> : Windows::UI::Composition::ICompositionLineGeometry_adaptor<X> { typedef adapt ICompositionLineGeometry; };
struct ICompositionLineGeometry : ICompositionLineGeometry_raw, generate<ICompositionLineGeometry> {};

// ICompositionLinearGradientBrush
struct ICompositionLinearGradientBrush_raw : IInspectable {
	virtual STDMETHODIMP _get_EndPoint(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_EndPoint(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_StartPoint(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_StartPoint(Foundation::Numerics::Vector2 value);
};
template<typename X> struct ICompositionLinearGradientBrush_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionLinearGradientBrush_adaptor::EndPoint)->_get_EndPoint(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionLinearGradientBrush_adaptor::EndPoint)->_put_EndPoint(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} EndPoint;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionLinearGradientBrush_adaptor::StartPoint)->_get_StartPoint(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionLinearGradientBrush_adaptor::StartPoint)->_put_StartPoint(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} StartPoint;
	};
	ICompositionLinearGradientBrush_adaptor() {}
};
template<typename X> struct adapt<ICompositionLinearGradientBrush, X> : Windows::UI::Composition::ICompositionLinearGradientBrush_adaptor<X> { typedef adapt ICompositionLinearGradientBrush; };
struct ICompositionLinearGradientBrush : ICompositionLinearGradientBrush_raw, generate<ICompositionLinearGradientBrush> {};

// ICompositionMaskBrush
struct ICompositionMaskBrush_raw : IInspectable {
	virtual STDMETHODIMP _get_Mask(CompositionBrush* *value);
	virtual STDMETHODIMP _put_Mask(CompositionBrush* value);
	virtual STDMETHODIMP _get_Source(CompositionBrush* *value);
	virtual STDMETHODIMP _put_Source(CompositionBrush* value);
};
template<typename X> struct ICompositionMaskBrush_adaptor : X {
	union {
		struct : property {
			ptr<CompositionBrush> get() { CompositionBrush* value; hrcheck(enc(&ICompositionMaskBrush_adaptor::Mask)->_get_Mask(&value)); return from_abi(value); }
			ptr<CompositionBrush> operator()() { return get(); }
			operator ptr<CompositionBrush> () { return get(); }
			ptr<CompositionBrush> operator->() { return get(); }
			void put(pptr<CompositionBrush> value) { hrcheck(enc(&ICompositionMaskBrush_adaptor::Mask)->_put_Mask(value)); }
			void operator=(pptr<CompositionBrush> value) { put(value); }
			void operator()(pptr<CompositionBrush> value) { put(value); }
		} Mask;
		struct : property {
			ptr<CompositionBrush> get() { CompositionBrush* value; hrcheck(enc(&ICompositionMaskBrush_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			ptr<CompositionBrush> operator()() { return get(); }
			operator ptr<CompositionBrush> () { return get(); }
			ptr<CompositionBrush> operator->() { return get(); }
			void put(pptr<CompositionBrush> value) { hrcheck(enc(&ICompositionMaskBrush_adaptor::Source)->_put_Source(value)); }
			void operator=(pptr<CompositionBrush> value) { put(value); }
			void operator()(pptr<CompositionBrush> value) { put(value); }
		} Source;
	};
	ICompositionMaskBrush_adaptor() {}
};
template<typename X> struct adapt<ICompositionMaskBrush, X> : Windows::UI::Composition::ICompositionMaskBrush_adaptor<X> { typedef adapt ICompositionMaskBrush; };
struct ICompositionMaskBrush : ICompositionMaskBrush_raw, generate<ICompositionMaskBrush> {};

// ICompositionNineGridBrush
struct ICompositionNineGridBrush_raw : IInspectable {
	virtual STDMETHODIMP _get_BottomInset(float *value);
	virtual STDMETHODIMP _put_BottomInset(float value);
	virtual STDMETHODIMP _get_BottomInsetScale(float *value);
	virtual STDMETHODIMP _put_BottomInsetScale(float value);
	virtual STDMETHODIMP _get_IsCenterHollow(bool *value);
	virtual STDMETHODIMP _put_IsCenterHollow(bool value);
	virtual STDMETHODIMP _get_LeftInset(float *value);
	virtual STDMETHODIMP _put_LeftInset(float value);
	virtual STDMETHODIMP _get_LeftInsetScale(float *value);
	virtual STDMETHODIMP _put_LeftInsetScale(float value);
	virtual STDMETHODIMP _get_RightInset(float *value);
	virtual STDMETHODIMP _put_RightInset(float value);
	virtual STDMETHODIMP _get_RightInsetScale(float *value);
	virtual STDMETHODIMP _put_RightInsetScale(float value);
	virtual STDMETHODIMP _get_Source(CompositionBrush* *value);
	virtual STDMETHODIMP _put_Source(CompositionBrush* value);
	virtual STDMETHODIMP _get_TopInset(float *value);
	virtual STDMETHODIMP _put_TopInset(float value);
	virtual STDMETHODIMP _get_TopInsetScale(float *value);
	virtual STDMETHODIMP _put_TopInsetScale(float value);
	virtual STDMETHODIMP _SetInsets(float inset);
	virtual STDMETHODIMP _SetInsetsWithValues(float left, float top, float right, float bottom);
	virtual STDMETHODIMP _SetInsetScales(float scale);
	virtual STDMETHODIMP _SetInsetScalesWithValues(float left, float top, float right, float bottom);
};
template<typename X> struct ICompositionNineGridBrush_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionNineGridBrush_adaptor::BottomInset)->_get_BottomInset(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionNineGridBrush_adaptor::BottomInset)->_put_BottomInset(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} BottomInset;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionNineGridBrush_adaptor::BottomInsetScale)->_get_BottomInsetScale(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionNineGridBrush_adaptor::BottomInsetScale)->_put_BottomInsetScale(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} BottomInsetScale;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICompositionNineGridBrush_adaptor::IsCenterHollow)->_get_IsCenterHollow(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICompositionNineGridBrush_adaptor::IsCenterHollow)->_put_IsCenterHollow(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsCenterHollow;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionNineGridBrush_adaptor::LeftInset)->_get_LeftInset(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionNineGridBrush_adaptor::LeftInset)->_put_LeftInset(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} LeftInset;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionNineGridBrush_adaptor::LeftInsetScale)->_get_LeftInsetScale(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionNineGridBrush_adaptor::LeftInsetScale)->_put_LeftInsetScale(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} LeftInsetScale;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionNineGridBrush_adaptor::RightInset)->_get_RightInset(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionNineGridBrush_adaptor::RightInset)->_put_RightInset(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} RightInset;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionNineGridBrush_adaptor::RightInsetScale)->_get_RightInsetScale(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionNineGridBrush_adaptor::RightInsetScale)->_put_RightInsetScale(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} RightInsetScale;
		struct : property {
			ptr<CompositionBrush> get() { CompositionBrush* value; hrcheck(enc(&ICompositionNineGridBrush_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			ptr<CompositionBrush> operator()() { return get(); }
			operator ptr<CompositionBrush> () { return get(); }
			ptr<CompositionBrush> operator->() { return get(); }
			void put(pptr<CompositionBrush> value) { hrcheck(enc(&ICompositionNineGridBrush_adaptor::Source)->_put_Source(value)); }
			void operator=(pptr<CompositionBrush> value) { put(value); }
			void operator()(pptr<CompositionBrush> value) { put(value); }
		} Source;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionNineGridBrush_adaptor::TopInset)->_get_TopInset(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionNineGridBrush_adaptor::TopInset)->_put_TopInset(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} TopInset;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionNineGridBrush_adaptor::TopInsetScale)->_get_TopInsetScale(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionNineGridBrush_adaptor::TopInsetScale)->_put_TopInsetScale(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} TopInsetScale;
	};
	void SetInsets(float inset) { hrcheck(X::get()->_SetInsets(inset)); }
	void SetInsets(float left, float top, float right, float bottom) { hrcheck(X::get()->_SetInsetsWithValues(left, top, right, bottom)); }
	void SetInsetScales(float scale) { hrcheck(X::get()->_SetInsetScales(scale)); }
	void SetInsetScales(float left, float top, float right, float bottom) { hrcheck(X::get()->_SetInsetScalesWithValues(left, top, right, bottom)); }
	ICompositionNineGridBrush_adaptor() {}
};
template<typename X> struct adapt<ICompositionNineGridBrush, X> : Windows::UI::Composition::ICompositionNineGridBrush_adaptor<X> { typedef adapt ICompositionNineGridBrush; };
struct ICompositionNineGridBrush : ICompositionNineGridBrush_raw, generate<ICompositionNineGridBrush> {};

// ICompositorStatics
struct ICompositorStatics : IInspectable {
	virtual STDMETHODIMP _get_MaxGlobalPlaybackRate(float *value);
	virtual STDMETHODIMP _get_MinGlobalPlaybackRate(float *value);
};

// ICompositor5
struct ICompositor5_raw : IInspectable {
	virtual STDMETHODIMP _get_Comment(HSTRING *value);
	virtual STDMETHODIMP _put_Comment(HSTRING value);
	virtual STDMETHODIMP _get_GlobalPlaybackRate(float *value);
	virtual STDMETHODIMP _put_GlobalPlaybackRate(float value);
	virtual STDMETHODIMP _CreateBounceScalarAnimation(BounceScalarNaturalMotionAnimation* *result);
	virtual STDMETHODIMP _CreateBounceVector2Animation(BounceVector2NaturalMotionAnimation* *result);
	virtual STDMETHODIMP _CreateBounceVector3Animation(BounceVector3NaturalMotionAnimation* *result);
	virtual STDMETHODIMP _CreateContainerShape(CompositionContainerShape* *result);
	virtual STDMETHODIMP _CreateEllipseGeometry(CompositionEllipseGeometry* *result);
	virtual STDMETHODIMP _CreateLineGeometry(CompositionLineGeometry* *result);
	virtual STDMETHODIMP _CreatePathGeometry(CompositionPathGeometry* *result);
	virtual STDMETHODIMP _CreatePathGeometryWithPath(CompositionPath* path, CompositionPathGeometry* *result);
	virtual STDMETHODIMP _CreatePathKeyFrameAnimation(PathKeyFrameAnimation* *result);
	virtual STDMETHODIMP _CreateRectangleGeometry(CompositionRectangleGeometry* *result);
	virtual STDMETHODIMP _CreateRoundedRectangleGeometry(CompositionRoundedRectangleGeometry* *result);
	virtual STDMETHODIMP _CreateShapeVisual(ShapeVisual* *result);
	virtual STDMETHODIMP _CreateSpriteShape(CompositionSpriteShape* *result);
	virtual STDMETHODIMP _CreateSpriteShapeWithGeometry(CompositionGeometry* geometry, CompositionSpriteShape* *result);
	virtual STDMETHODIMP _CreateViewBox(CompositionViewBox* *result);
	virtual STDMETHODIMP _RequestCommitAsync(Foundation::IAsyncAction* *action);
};
template<typename X> struct ICompositor5_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICompositor5_adaptor::Comment)->_get_Comment(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICompositor5_adaptor::Comment)->_put_Comment(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Comment;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositor5_adaptor::GlobalPlaybackRate)->_get_GlobalPlaybackRate(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositor5_adaptor::GlobalPlaybackRate)->_put_GlobalPlaybackRate(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} GlobalPlaybackRate;
	};
	ptr<BounceScalarNaturalMotionAnimation> CreateBounceScalarAnimation() { BounceScalarNaturalMotionAnimation* result; hrcheck(X::get()->_CreateBounceScalarAnimation(&result)); return from_abi(result); }
	ptr<BounceVector2NaturalMotionAnimation> CreateBounceVector2Animation() { BounceVector2NaturalMotionAnimation* result; hrcheck(X::get()->_CreateBounceVector2Animation(&result)); return from_abi(result); }
	ptr<BounceVector3NaturalMotionAnimation> CreateBounceVector3Animation() { BounceVector3NaturalMotionAnimation* result; hrcheck(X::get()->_CreateBounceVector3Animation(&result)); return from_abi(result); }
	ptr<CompositionContainerShape> CreateContainerShape() { CompositionContainerShape* result; hrcheck(X::get()->_CreateContainerShape(&result)); return from_abi(result); }
	ptr<CompositionEllipseGeometry> CreateEllipseGeometry() { CompositionEllipseGeometry* result; hrcheck(X::get()->_CreateEllipseGeometry(&result)); return from_abi(result); }
	ptr<CompositionLineGeometry> CreateLineGeometry() { CompositionLineGeometry* result; hrcheck(X::get()->_CreateLineGeometry(&result)); return from_abi(result); }
	ptr<CompositionPathGeometry> CreatePathGeometry() { CompositionPathGeometry* result; hrcheck(X::get()->_CreatePathGeometry(&result)); return from_abi(result); }
	ptr<CompositionPathGeometry> CreatePathGeometry(pptr<CompositionPath> path) { CompositionPathGeometry* result; hrcheck(X::get()->_CreatePathGeometryWithPath(path, &result)); return from_abi(result); }
	ptr<PathKeyFrameAnimation> CreatePathKeyFrameAnimation() { PathKeyFrameAnimation* result; hrcheck(X::get()->_CreatePathKeyFrameAnimation(&result)); return from_abi(result); }
	ptr<CompositionRectangleGeometry> CreateRectangleGeometry() { CompositionRectangleGeometry* result; hrcheck(X::get()->_CreateRectangleGeometry(&result)); return from_abi(result); }
	ptr<CompositionRoundedRectangleGeometry> CreateRoundedRectangleGeometry() { CompositionRoundedRectangleGeometry* result; hrcheck(X::get()->_CreateRoundedRectangleGeometry(&result)); return from_abi(result); }
	ptr<ShapeVisual> CreateShapeVisual() { ShapeVisual* result; hrcheck(X::get()->_CreateShapeVisual(&result)); return from_abi(result); }
	ptr<CompositionSpriteShape> CreateSpriteShape() { CompositionSpriteShape* result; hrcheck(X::get()->_CreateSpriteShape(&result)); return from_abi(result); }
	ptr<CompositionSpriteShape> CreateSpriteShape(pptr<CompositionGeometry> geometry) { CompositionSpriteShape* result; hrcheck(X::get()->_CreateSpriteShapeWithGeometry(geometry, &result)); return from_abi(result); }
	ptr<CompositionViewBox> CreateViewBox() { CompositionViewBox* result; hrcheck(X::get()->_CreateViewBox(&result)); return from_abi(result); }
	ptr<Foundation::IAsyncAction> RequestCommitAsync() { Foundation::IAsyncAction* action; hrcheck(X::get()->_RequestCommitAsync(&action)); return from_abi(action); }
	ICompositor5_adaptor() {}
};
template<typename X> struct adapt<ICompositor5, X> : Windows::UI::Composition::ICompositor5_adaptor<X> { typedef adapt ICompositor5; };
struct ICompositor5 : ICompositor5_raw, generate<ICompositor5> {};

// ICompositor4
struct ICompositor4_raw : IInspectable {
	virtual STDMETHODIMP _CreateColorGradientStop(CompositionColorGradientStop* *result);
	virtual STDMETHODIMP _CreateColorGradientStopWithOffsetAndColor(float offset, Color color, CompositionColorGradientStop* *result);
	virtual STDMETHODIMP _CreateLinearGradientBrush(CompositionLinearGradientBrush* *result);
	virtual STDMETHODIMP _CreateSpringScalarAnimation(SpringScalarNaturalMotionAnimation* *result);
	virtual STDMETHODIMP _CreateSpringVector2Animation(SpringVector2NaturalMotionAnimation* *result);
	virtual STDMETHODIMP _CreateSpringVector3Animation(SpringVector3NaturalMotionAnimation* *result);
};
template<typename X> struct ICompositor4_adaptor : X {
	ptr<CompositionColorGradientStop> CreateColorGradientStop() { CompositionColorGradientStop* result; hrcheck(X::get()->_CreateColorGradientStop(&result)); return from_abi(result); }
	ptr<CompositionColorGradientStop> CreateColorGradientStop(float offset, const Color& color) { CompositionColorGradientStop* result; hrcheck(X::get()->_CreateColorGradientStopWithOffsetAndColor(offset, color, &result)); return from_abi(result); }
	ptr<CompositionLinearGradientBrush> CreateLinearGradientBrush() { CompositionLinearGradientBrush* result; hrcheck(X::get()->_CreateLinearGradientBrush(&result)); return from_abi(result); }
	ptr<SpringScalarNaturalMotionAnimation> CreateSpringScalarAnimation() { SpringScalarNaturalMotionAnimation* result; hrcheck(X::get()->_CreateSpringScalarAnimation(&result)); return from_abi(result); }
	ptr<SpringVector2NaturalMotionAnimation> CreateSpringVector2Animation() { SpringVector2NaturalMotionAnimation* result; hrcheck(X::get()->_CreateSpringVector2Animation(&result)); return from_abi(result); }
	ptr<SpringVector3NaturalMotionAnimation> CreateSpringVector3Animation() { SpringVector3NaturalMotionAnimation* result; hrcheck(X::get()->_CreateSpringVector3Animation(&result)); return from_abi(result); }
};
template<typename X> struct adapt<ICompositor4, X> : Windows::UI::Composition::ICompositor4_adaptor<X> { typedef adapt ICompositor4; };
struct ICompositor4 : ICompositor4_raw, generate<ICompositor4> {};

// ICompositor3
struct ICompositor3_raw : IInspectable {
	virtual STDMETHODIMP _CreateHostBackdropBrush(CompositionBackdropBrush* *result);
};
template<typename X> struct ICompositor3_adaptor : X {
	ptr<CompositionBackdropBrush> CreateHostBackdropBrush() { CompositionBackdropBrush* result; hrcheck(X::get()->_CreateHostBackdropBrush(&result)); return from_abi(result); }
};
template<typename X> struct adapt<ICompositor3, X> : Windows::UI::Composition::ICompositor3_adaptor<X> { typedef adapt ICompositor3; };
struct ICompositor3 : ICompositor3_raw, generate<ICompositor3> {};

// ICompositor2
struct ICompositor2_raw : IInspectable {
	virtual STDMETHODIMP _CreateAmbientLight(AmbientLight* *result);
	virtual STDMETHODIMP _CreateAnimationGroup(CompositionAnimationGroup* *result);
	virtual STDMETHODIMP _CreateBackdropBrush(CompositionBackdropBrush* *result);
	virtual STDMETHODIMP _CreateDistantLight(DistantLight* *result);
	virtual STDMETHODIMP _CreateDropShadow(DropShadow* *result);
	virtual STDMETHODIMP _CreateImplicitAnimationCollection(ImplicitAnimationCollection* *result);
	virtual STDMETHODIMP _CreateLayerVisual(LayerVisual* *result);
	virtual STDMETHODIMP _CreateMaskBrush(CompositionMaskBrush* *result);
	virtual STDMETHODIMP _CreateNineGridBrush(CompositionNineGridBrush* *result);
	virtual STDMETHODIMP _CreatePointLight(PointLight* *result);
	virtual STDMETHODIMP _CreateSpotLight(SpotLight* *result);
	virtual STDMETHODIMP _CreateStepEasingFunction(StepEasingFunction* *result);
	virtual STDMETHODIMP _CreateStepEasingFunctionWithStepCount(int stepCount, StepEasingFunction* *result);
};
template<typename X> struct ICompositor2_adaptor : X {
	ptr<AmbientLight> CreateAmbientLight() { AmbientLight* result; hrcheck(X::get()->_CreateAmbientLight(&result)); return from_abi(result); }
	ptr<CompositionAnimationGroup> CreateAnimationGroup() { CompositionAnimationGroup* result; hrcheck(X::get()->_CreateAnimationGroup(&result)); return from_abi(result); }
	ptr<CompositionBackdropBrush> CreateBackdropBrush() { CompositionBackdropBrush* result; hrcheck(X::get()->_CreateBackdropBrush(&result)); return from_abi(result); }
	ptr<DistantLight> CreateDistantLight() { DistantLight* result; hrcheck(X::get()->_CreateDistantLight(&result)); return from_abi(result); }
	ptr<DropShadow> CreateDropShadow() { DropShadow* result; hrcheck(X::get()->_CreateDropShadow(&result)); return from_abi(result); }
	ptr<ImplicitAnimationCollection> CreateImplicitAnimationCollection() { ImplicitAnimationCollection* result; hrcheck(X::get()->_CreateImplicitAnimationCollection(&result)); return from_abi(result); }
	ptr<LayerVisual> CreateLayerVisual() { LayerVisual* result; hrcheck(X::get()->_CreateLayerVisual(&result)); return from_abi(result); }
	ptr<CompositionMaskBrush> CreateMaskBrush() { CompositionMaskBrush* result; hrcheck(X::get()->_CreateMaskBrush(&result)); return from_abi(result); }
	ptr<CompositionNineGridBrush> CreateNineGridBrush() { CompositionNineGridBrush* result; hrcheck(X::get()->_CreateNineGridBrush(&result)); return from_abi(result); }
	ptr<PointLight> CreatePointLight() { PointLight* result; hrcheck(X::get()->_CreatePointLight(&result)); return from_abi(result); }
	ptr<SpotLight> CreateSpotLight() { SpotLight* result; hrcheck(X::get()->_CreateSpotLight(&result)); return from_abi(result); }
	ptr<StepEasingFunction> CreateStepEasingFunction() { StepEasingFunction* result; hrcheck(X::get()->_CreateStepEasingFunction(&result)); return from_abi(result); }
	ptr<StepEasingFunction> CreateStepEasingFunction(int stepCount) { StepEasingFunction* result; hrcheck(X::get()->_CreateStepEasingFunctionWithStepCount(stepCount, &result)); return from_abi(result); }
};
template<typename X> struct adapt<ICompositor2, X> : Windows::UI::Composition::ICompositor2_adaptor<X> { typedef adapt ICompositor2; };
struct ICompositor2 : ICompositor2_raw, generate<ICompositor2> {};

// ICompositor
struct ICompositor_raw : IInspectable {
	virtual STDMETHODIMP _CreateColorKeyFrameAnimation(ColorKeyFrameAnimation* *result);
	virtual STDMETHODIMP _CreateColorBrush(CompositionColorBrush* *result);
	virtual STDMETHODIMP _CreateColorBrushWithColor(Color color, CompositionColorBrush* *result);
	virtual STDMETHODIMP _CreateContainerVisual(ContainerVisual* *result);
	virtual STDMETHODIMP _CreateCubicBezierEasingFunction(Foundation::Numerics::Vector2 controlPoint1, Foundation::Numerics::Vector2 controlPoint2, CubicBezierEasingFunction* *result);
	virtual STDMETHODIMP _CreateEffectFactory(Graphics::Effects::IGraphicsEffect* graphicsEffect, CompositionEffectFactory* *result);
	virtual STDMETHODIMP _CreateEffectFactoryWithProperties(Graphics::Effects::IGraphicsEffect* graphicsEffect, Foundation::Collections::IIterable<HSTRING>* animatableProperties, CompositionEffectFactory* *result);
	virtual STDMETHODIMP _CreateExpressionAnimation(ExpressionAnimation* *result);
	virtual STDMETHODIMP _CreateExpressionAnimationWithExpression(HSTRING expression, ExpressionAnimation* *result);
	virtual STDMETHODIMP _CreateInsetClip(InsetClip* *result);
	virtual STDMETHODIMP _CreateInsetClipWithInsets(float leftInset, float topInset, float rightInset, float bottomInset, InsetClip* *result);
	virtual STDMETHODIMP _CreateLinearEasingFunction(LinearEasingFunction* *result);
	virtual STDMETHODIMP _CreatePropertySet(CompositionPropertySet* *result);
	virtual STDMETHODIMP _CreateQuaternionKeyFrameAnimation(QuaternionKeyFrameAnimation* *result);
	virtual STDMETHODIMP _CreateScalarKeyFrameAnimation(ScalarKeyFrameAnimation* *result);
	virtual STDMETHODIMP _CreateScopedBatch(CompositionBatchTypes batchType, CompositionScopedBatch* *result);
	virtual STDMETHODIMP _CreateSpriteVisual(SpriteVisual* *result);
	virtual STDMETHODIMP _CreateSurfaceBrush(CompositionSurfaceBrush* *result);
	virtual STDMETHODIMP _CreateSurfaceBrushWithSurface(ICompositionSurface* surface, CompositionSurfaceBrush* *result);
	virtual STDMETHODIMP _CreateTargetForCurrentView(CompositionTarget* *result);
	virtual STDMETHODIMP _CreateVector2KeyFrameAnimation(Vector2KeyFrameAnimation* *result);
	virtual STDMETHODIMP _CreateVector3KeyFrameAnimation(Vector3KeyFrameAnimation* *result);
	virtual STDMETHODIMP _CreateVector4KeyFrameAnimation(Vector4KeyFrameAnimation* *result);
	virtual STDMETHODIMP _GetCommitBatch(CompositionBatchTypes batchType, CompositionCommitBatch* *result);
};
template<typename X> struct ICompositor_adaptor : X {
	ptr<ColorKeyFrameAnimation> CreateColorKeyFrameAnimation() { ColorKeyFrameAnimation* result; hrcheck(X::get()->_CreateColorKeyFrameAnimation(&result)); return from_abi(result); }
	ptr<CompositionColorBrush> CreateColorBrush() { CompositionColorBrush* result; hrcheck(X::get()->_CreateColorBrush(&result)); return from_abi(result); }
	ptr<CompositionColorBrush> CreateColorBrush(const Color& color) { CompositionColorBrush* result; hrcheck(X::get()->_CreateColorBrushWithColor(color, &result)); return from_abi(result); }
	ptr<ContainerVisual> CreateContainerVisual() { ContainerVisual* result; hrcheck(X::get()->_CreateContainerVisual(&result)); return from_abi(result); }
	ptr<CubicBezierEasingFunction> CreateCubicBezierEasingFunction(const Foundation::Numerics::Vector2& controlPoint1, const Foundation::Numerics::Vector2& controlPoint2) { CubicBezierEasingFunction* result; hrcheck(X::get()->_CreateCubicBezierEasingFunction(controlPoint1, controlPoint2, &result)); return from_abi(result); }
	ptr<CompositionEffectFactory> CreateEffectFactory(pptr<Graphics::Effects::IGraphicsEffect> graphicsEffect) { CompositionEffectFactory* result; hrcheck(X::get()->_CreateEffectFactory(graphicsEffect, &result)); return from_abi(result); }
	ptr<CompositionEffectFactory> CreateEffectFactory(pptr<Graphics::Effects::IGraphicsEffect> graphicsEffect, pptr<Foundation::Collections::IIterable<hstring>> animatableProperties) { CompositionEffectFactory* result; hrcheck(X::get()->_CreateEffectFactoryWithProperties(graphicsEffect, to_abi(animatableProperties), &result)); return from_abi(result); }
	ptr<ExpressionAnimation> CreateExpressionAnimation() { ExpressionAnimation* result; hrcheck(X::get()->_CreateExpressionAnimation(&result)); return from_abi(result); }
	ptr<ExpressionAnimation> CreateExpressionAnimation(hstring_ref expression) { ExpressionAnimation* result; hrcheck(X::get()->_CreateExpressionAnimationWithExpression(expression, &result)); return from_abi(result); }
	ptr<InsetClip> CreateInsetClip() { InsetClip* result; hrcheck(X::get()->_CreateInsetClip(&result)); return from_abi(result); }
	ptr<InsetClip> CreateInsetClip(float leftInset, float topInset, float rightInset, float bottomInset) { InsetClip* result; hrcheck(X::get()->_CreateInsetClipWithInsets(leftInset, topInset, rightInset, bottomInset, &result)); return from_abi(result); }
	ptr<LinearEasingFunction> CreateLinearEasingFunction() { LinearEasingFunction* result; hrcheck(X::get()->_CreateLinearEasingFunction(&result)); return from_abi(result); }
	ptr<CompositionPropertySet> CreatePropertySet() { CompositionPropertySet* result; hrcheck(X::get()->_CreatePropertySet(&result)); return from_abi(result); }
	ptr<QuaternionKeyFrameAnimation> CreateQuaternionKeyFrameAnimation() { QuaternionKeyFrameAnimation* result; hrcheck(X::get()->_CreateQuaternionKeyFrameAnimation(&result)); return from_abi(result); }
	ptr<ScalarKeyFrameAnimation> CreateScalarKeyFrameAnimation() { ScalarKeyFrameAnimation* result; hrcheck(X::get()->_CreateScalarKeyFrameAnimation(&result)); return from_abi(result); }
	ptr<CompositionScopedBatch> CreateScopedBatch(CompositionBatchTypes batchType) { CompositionScopedBatch* result; hrcheck(X::get()->_CreateScopedBatch(batchType, &result)); return from_abi(result); }
	ptr<SpriteVisual> CreateSpriteVisual() { SpriteVisual* result; hrcheck(X::get()->_CreateSpriteVisual(&result)); return from_abi(result); }
	ptr<CompositionSurfaceBrush> CreateSurfaceBrush() { CompositionSurfaceBrush* result; hrcheck(X::get()->_CreateSurfaceBrush(&result)); return from_abi(result); }
	ptr<CompositionSurfaceBrush> CreateSurfaceBrush(pptr<ICompositionSurface> surface) { CompositionSurfaceBrush* result; hrcheck(X::get()->_CreateSurfaceBrushWithSurface(surface, &result)); return from_abi(result); }
	ptr<CompositionTarget> CreateTargetForCurrentView() { CompositionTarget* result; hrcheck(X::get()->_CreateTargetForCurrentView(&result)); return from_abi(result); }
	ptr<Vector2KeyFrameAnimation> CreateVector2KeyFrameAnimation() { Vector2KeyFrameAnimation* result; hrcheck(X::get()->_CreateVector2KeyFrameAnimation(&result)); return from_abi(result); }
	ptr<Vector3KeyFrameAnimation> CreateVector3KeyFrameAnimation() { Vector3KeyFrameAnimation* result; hrcheck(X::get()->_CreateVector3KeyFrameAnimation(&result)); return from_abi(result); }
	ptr<Vector4KeyFrameAnimation> CreateVector4KeyFrameAnimation() { Vector4KeyFrameAnimation* result; hrcheck(X::get()->_CreateVector4KeyFrameAnimation(&result)); return from_abi(result); }
	ptr<CompositionCommitBatch> GetCommitBatch(CompositionBatchTypes batchType) { CompositionCommitBatch* result; hrcheck(X::get()->_GetCommitBatch(batchType, &result)); return from_abi(result); }
};
template<typename X> struct adapt<ICompositor, X> : Windows::UI::Composition::ICompositor_adaptor<X> { typedef adapt ICompositor; };
struct ICompositor : ICompositor_raw, generate<ICompositor> {};

// Compositor
template<typename> struct Compositor_statics {
	static struct _MaxGlobalPlaybackRate : property {
		float get() { float value; hrcheck(get_activation_factory<Compositor, ICompositorStatics>()->_get_MaxGlobalPlaybackRate(&value)); return value; }
		float operator()() { return get(); }
		operator float () { return get(); }
	} MaxGlobalPlaybackRate;
	static struct _MinGlobalPlaybackRate : property {
		float get() { float value; hrcheck(get_activation_factory<Compositor, ICompositorStatics>()->_get_MinGlobalPlaybackRate(&value)); return value; }
		float operator()() { return get(); }
		operator float () { return get(); }
	} MinGlobalPlaybackRate;
};
template<typename X> typename Compositor_statics<X>::_MaxGlobalPlaybackRate Compositor_statics<X>::MaxGlobalPlaybackRate;
template<typename X> typename Compositor_statics<X>::_MinGlobalPlaybackRate Compositor_statics<X>::MinGlobalPlaybackRate;

template<typename X> struct statics<Compositor, X> : X, Windows::UI::Composition::Compositor_statics<void> {
	typedef typename X::root_type Compositor;
};
struct Compositor : generate<Compositor> {
	using ICompositor::CreateColorBrush;
	using ICompositor5::CreatePathGeometry;
	using ICompositor5::CreateSpriteShape;
	using ICompositor4::CreateColorGradientStop;
	using ICompositor::CreateSurfaceBrush;
	using ICompositor::CreateExpressionAnimation;
	using ICompositor::CreateEffectFactory;
	using ICompositor2::CreateStepEasingFunction;
	using ICompositor::CreateInsetClip;
};

// AnimationController
template<typename> struct AnimationController_statics {
	static struct _MaxPlaybackRate : property {
		float get() { float value; hrcheck(get_activation_factory<AnimationController, IAnimationControllerStatics>()->_get_MaxPlaybackRate(&value)); return value; }
		float operator()() { return get(); }
		operator float () { return get(); }
	} MaxPlaybackRate;
	static struct _MinPlaybackRate : property {
		float get() { float value; hrcheck(get_activation_factory<AnimationController, IAnimationControllerStatics>()->_get_MinPlaybackRate(&value)); return value; }
		float operator()() { return get(); }
		operator float () { return get(); }
	} MinPlaybackRate;
};
template<typename X> typename AnimationController_statics<X>::_MaxPlaybackRate AnimationController_statics<X>::MaxPlaybackRate;
template<typename X> typename AnimationController_statics<X>::_MinPlaybackRate AnimationController_statics<X>::MinPlaybackRate;

template<typename X> struct statics<AnimationController, X> : X, Windows::UI::Composition::AnimationController_statics<void> {
	typedef typename X::root_type AnimationController;
};
struct AnimationController : generate<AnimationController> {};

// ICompositionPath
struct ICompositionPath : IInspectable, generate<ICompositionPath> {};

// ICompositionPathGeometry
struct ICompositionPathGeometry_raw : IInspectable {
	virtual STDMETHODIMP _get_Path(CompositionPath* *value);
	virtual STDMETHODIMP _put_Path(CompositionPath* value);
};
template<typename X> struct ICompositionPathGeometry_adaptor : X {
	union {
		struct : property {
			ptr<CompositionPath> get() { CompositionPath* value; hrcheck(enc(&ICompositionPathGeometry_adaptor::Path)->_get_Path(&value)); return from_abi(value); }
			ptr<CompositionPath> operator()() { return get(); }
			operator ptr<CompositionPath> () { return get(); }
			ptr<CompositionPath> operator->() { return get(); }
			void put(pptr<CompositionPath> value) { hrcheck(enc(&ICompositionPathGeometry_adaptor::Path)->_put_Path(value)); }
			void operator=(pptr<CompositionPath> value) { put(value); }
			void operator()(pptr<CompositionPath> value) { put(value); }
		} Path;
	};
	ICompositionPathGeometry_adaptor() {}
};
template<typename X> struct adapt<ICompositionPathGeometry, X> : Windows::UI::Composition::ICompositionPathGeometry_adaptor<X> { typedef adapt ICompositionPathGeometry; };
struct ICompositionPathGeometry : ICompositionPathGeometry_raw, generate<ICompositionPathGeometry> {};

// ICompositionPathFactory
struct ICompositionPathFactory : IInspectable {
	virtual STDMETHODIMP _Create(Graphics::IGeometrySource2D* source, CompositionPath* *result);
};

// CompositionPath
template<typename> struct CompositionPath_statics {
	static CompositionPath *activate(pptr<Graphics::IGeometrySource2D> source) { CompositionPath *result; hrcheck(get_activation_factory<CompositionPath, ICompositionPathFactory>()->_Create(source, &result)); return result; }
};

template<typename X> struct statics<CompositionPath, X> : X, Windows::UI::Composition::CompositionPath_statics<void> {
	using Windows::UI::Composition::CompositionPath_statics<void>::activate;
	typedef typename X::root_type CompositionPath;
};
struct CompositionPath : generate<CompositionPath> {};

// ICompositionPropertySet
struct ICompositionPropertySet_raw : IInspectable {
	virtual STDMETHODIMP _InsertColor(HSTRING propertyName, Color value);
	virtual STDMETHODIMP _InsertMatrix3x2(HSTRING propertyName, Foundation::Numerics::Matrix3x2 value);
	virtual STDMETHODIMP _InsertMatrix4x4(HSTRING propertyName, Foundation::Numerics::Matrix4x4 value);
	virtual STDMETHODIMP _InsertQuaternion(HSTRING propertyName, Foundation::Numerics::Quaternion value);
	virtual STDMETHODIMP _InsertScalar(HSTRING propertyName, float value);
	virtual STDMETHODIMP _InsertVector2(HSTRING propertyName, Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _InsertVector3(HSTRING propertyName, Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _InsertVector4(HSTRING propertyName, Foundation::Numerics::Vector4 value);
	virtual STDMETHODIMP _TryGetColor(HSTRING propertyName, Color *value, CompositionGetValueStatus *result);
	virtual STDMETHODIMP _TryGetMatrix3x2(HSTRING propertyName, Foundation::Numerics::Matrix3x2 *value, CompositionGetValueStatus *result);
	virtual STDMETHODIMP _TryGetMatrix4x4(HSTRING propertyName, Foundation::Numerics::Matrix4x4 *value, CompositionGetValueStatus *result);
	virtual STDMETHODIMP _TryGetQuaternion(HSTRING propertyName, Foundation::Numerics::Quaternion *value, CompositionGetValueStatus *result);
	virtual STDMETHODIMP _TryGetScalar(HSTRING propertyName, float *value, CompositionGetValueStatus *result);
	virtual STDMETHODIMP _TryGetVector2(HSTRING propertyName, Foundation::Numerics::Vector2 *value, CompositionGetValueStatus *result);
	virtual STDMETHODIMP _TryGetVector3(HSTRING propertyName, Foundation::Numerics::Vector3 *value, CompositionGetValueStatus *result);
	virtual STDMETHODIMP _TryGetVector4(HSTRING propertyName, Foundation::Numerics::Vector4 *value, CompositionGetValueStatus *result);
};
template<typename X> struct ICompositionPropertySet_adaptor : X {
	void InsertColor(hstring_ref propertyName, const Color& value) { hrcheck(X::get()->_InsertColor(propertyName, value)); }
	void InsertMatrix3x2(hstring_ref propertyName, const Foundation::Numerics::Matrix3x2& value) { hrcheck(X::get()->_InsertMatrix3x2(propertyName, value)); }
	void InsertMatrix4x4(hstring_ref propertyName, const Foundation::Numerics::Matrix4x4& value) { hrcheck(X::get()->_InsertMatrix4x4(propertyName, value)); }
	void InsertQuaternion(hstring_ref propertyName, const Foundation::Numerics::Quaternion& value) { hrcheck(X::get()->_InsertQuaternion(propertyName, value)); }
	void InsertScalar(hstring_ref propertyName, float value) { hrcheck(X::get()->_InsertScalar(propertyName, value)); }
	void InsertVector2(hstring_ref propertyName, const Foundation::Numerics::Vector2& value) { hrcheck(X::get()->_InsertVector2(propertyName, value)); }
	void InsertVector3(hstring_ref propertyName, const Foundation::Numerics::Vector3& value) { hrcheck(X::get()->_InsertVector3(propertyName, value)); }
	void InsertVector4(hstring_ref propertyName, const Foundation::Numerics::Vector4& value) { hrcheck(X::get()->_InsertVector4(propertyName, value)); }
	CompositionGetValueStatus TryGetColor(hstring_ref propertyName, Color *value) { CompositionGetValueStatus result; hrcheck(X::get()->_TryGetColor(propertyName, value, &result)); return result; }
	CompositionGetValueStatus TryGetMatrix3x2(hstring_ref propertyName, Foundation::Numerics::Matrix3x2 *value) { CompositionGetValueStatus result; hrcheck(X::get()->_TryGetMatrix3x2(propertyName, value, &result)); return result; }
	CompositionGetValueStatus TryGetMatrix4x4(hstring_ref propertyName, Foundation::Numerics::Matrix4x4 *value) { CompositionGetValueStatus result; hrcheck(X::get()->_TryGetMatrix4x4(propertyName, value, &result)); return result; }
	CompositionGetValueStatus TryGetQuaternion(hstring_ref propertyName, Foundation::Numerics::Quaternion *value) { CompositionGetValueStatus result; hrcheck(X::get()->_TryGetQuaternion(propertyName, value, &result)); return result; }
	CompositionGetValueStatus TryGetScalar(hstring_ref propertyName, float *value) { CompositionGetValueStatus result; hrcheck(X::get()->_TryGetScalar(propertyName, value, &result)); return result; }
	CompositionGetValueStatus TryGetVector2(hstring_ref propertyName, Foundation::Numerics::Vector2 *value) { CompositionGetValueStatus result; hrcheck(X::get()->_TryGetVector2(propertyName, value, &result)); return result; }
	CompositionGetValueStatus TryGetVector3(hstring_ref propertyName, Foundation::Numerics::Vector3 *value) { CompositionGetValueStatus result; hrcheck(X::get()->_TryGetVector3(propertyName, value, &result)); return result; }
	CompositionGetValueStatus TryGetVector4(hstring_ref propertyName, Foundation::Numerics::Vector4 *value) { CompositionGetValueStatus result; hrcheck(X::get()->_TryGetVector4(propertyName, value, &result)); return result; }
};
template<typename X> struct adapt<ICompositionPropertySet, X> : Windows::UI::Composition::ICompositionPropertySet_adaptor<X> { typedef adapt ICompositionPropertySet; };
struct ICompositionPropertySet : ICompositionPropertySet_raw, generate<ICompositionPropertySet> {};

// ICompositionPropertySet2
struct ICompositionPropertySet2_raw : IInspectable {
	virtual STDMETHODIMP _InsertBoolean(HSTRING propertyName, bool value);
	virtual STDMETHODIMP _TryGetBoolean(HSTRING propertyName, bool *value, CompositionGetValueStatus *result);
};
template<typename X> struct ICompositionPropertySet2_adaptor : X {
	void InsertBoolean(hstring_ref propertyName, bool value) { hrcheck(X::get()->_InsertBoolean(propertyName, value)); }
	CompositionGetValueStatus TryGetBoolean(hstring_ref propertyName, bool *value) { CompositionGetValueStatus result; hrcheck(X::get()->_TryGetBoolean(propertyName, value, &result)); return result; }
};
template<typename X> struct adapt<ICompositionPropertySet2, X> : Windows::UI::Composition::ICompositionPropertySet2_adaptor<X> { typedef adapt ICompositionPropertySet2; };
struct ICompositionPropertySet2 : ICompositionPropertySet2_raw, generate<ICompositionPropertySet2> {};

// CompositionPropertySet
template<typename X> struct statics<CompositionPropertySet, X> : X {
	typedef typename X::root_type CompositionPropertySet;
};
struct CompositionPropertySet : generate<CompositionPropertySet> {};

// ICompositionRectangleGeometry
struct ICompositionRectangleGeometry_raw : IInspectable {
	virtual STDMETHODIMP _get_Offset(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Offset(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_Size(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Size(Foundation::Numerics::Vector2 value);
};
template<typename X> struct ICompositionRectangleGeometry_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionRectangleGeometry_adaptor::Offset)->_get_Offset(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionRectangleGeometry_adaptor::Offset)->_put_Offset(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Offset;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionRectangleGeometry_adaptor::Size)->_get_Size(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionRectangleGeometry_adaptor::Size)->_put_Size(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Size;
	};
	ICompositionRectangleGeometry_adaptor() {}
};
template<typename X> struct adapt<ICompositionRectangleGeometry, X> : Windows::UI::Composition::ICompositionRectangleGeometry_adaptor<X> { typedef adapt ICompositionRectangleGeometry; };
struct ICompositionRectangleGeometry : ICompositionRectangleGeometry_raw, generate<ICompositionRectangleGeometry> {};

// ICompositionRoundedRectangleGeometry
struct ICompositionRoundedRectangleGeometry_raw : IInspectable {
	virtual STDMETHODIMP _get_CornerRadius(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_CornerRadius(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_Offset(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Offset(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_Size(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Size(Foundation::Numerics::Vector2 value);
};
template<typename X> struct ICompositionRoundedRectangleGeometry_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionRoundedRectangleGeometry_adaptor::CornerRadius)->_get_CornerRadius(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionRoundedRectangleGeometry_adaptor::CornerRadius)->_put_CornerRadius(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} CornerRadius;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionRoundedRectangleGeometry_adaptor::Offset)->_get_Offset(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionRoundedRectangleGeometry_adaptor::Offset)->_put_Offset(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Offset;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionRoundedRectangleGeometry_adaptor::Size)->_get_Size(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionRoundedRectangleGeometry_adaptor::Size)->_put_Size(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Size;
	};
	ICompositionRoundedRectangleGeometry_adaptor() {}
};
template<typename X> struct adapt<ICompositionRoundedRectangleGeometry, X> : Windows::UI::Composition::ICompositionRoundedRectangleGeometry_adaptor<X> { typedef adapt ICompositionRoundedRectangleGeometry; };
struct ICompositionRoundedRectangleGeometry : ICompositionRoundedRectangleGeometry_raw, generate<ICompositionRoundedRectangleGeometry> {};

// ICompositionScopedBatch
struct ICompositionScopedBatch_raw : IInspectable {
	virtual STDMETHODIMP _get_IsActive(bool *value);
	virtual STDMETHODIMP _get_IsEnded(bool *value);
	virtual STDMETHODIMP _End();
	virtual STDMETHODIMP _Resume();
	virtual STDMETHODIMP _Suspend();
	virtual STDMETHODIMP _add_Completed(Foundation::TypedEventHandler<IInspectable*, CompositionBatchCompletedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Completed(Foundation::EventRegistrationToken token);
};
template<typename X> struct ICompositionScopedBatch_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICompositionScopedBatch_adaptor::IsActive)->_get_IsActive(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsActive;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICompositionScopedBatch_adaptor::IsEnded)->_get_IsEnded(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsEnded;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<object, ptr<CompositionBatchCompletedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICompositionScopedBatch_adaptor::Completed)->_add_Completed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICompositionScopedBatch_adaptor::Completed)->_remove_Completed(token)); }
		} Completed;
	};
	void End() { hrcheck(X::get()->_End()); }
	void Resume() { hrcheck(X::get()->_Resume()); }
	void Suspend() { hrcheck(X::get()->_Suspend()); }
	ICompositionScopedBatch_adaptor() {}
};
template<typename X> struct adapt<ICompositionScopedBatch, X> : Windows::UI::Composition::ICompositionScopedBatch_adaptor<X> { typedef adapt ICompositionScopedBatch; };
struct ICompositionScopedBatch : ICompositionScopedBatch_raw, generate<ICompositionScopedBatch> {};

// ICompositionShadow
struct ICompositionShadow : IInspectable, generate<ICompositionShadow> {};

// ICompositionSpriteShape
struct ICompositionSpriteShape_raw : IInspectable {
	virtual STDMETHODIMP _get_FillBrush(CompositionBrush* *value);
	virtual STDMETHODIMP _put_FillBrush(CompositionBrush* value);
	virtual STDMETHODIMP _get_Geometry(CompositionGeometry* *value);
	virtual STDMETHODIMP _put_Geometry(CompositionGeometry* value);
	virtual STDMETHODIMP _get_IsStrokeNonScaling(bool *value);
	virtual STDMETHODIMP _put_IsStrokeNonScaling(bool value);
	virtual STDMETHODIMP _get_StrokeBrush(CompositionBrush* *value);
	virtual STDMETHODIMP _put_StrokeBrush(CompositionBrush* value);
	virtual STDMETHODIMP _get_StrokeDashArray(CompositionStrokeDashArray* *value);
	virtual STDMETHODIMP _get_StrokeDashCap(CompositionStrokeCap *value);
	virtual STDMETHODIMP _put_StrokeDashCap(CompositionStrokeCap value);
	virtual STDMETHODIMP _get_StrokeDashOffset(float *value);
	virtual STDMETHODIMP _put_StrokeDashOffset(float value);
	virtual STDMETHODIMP _get_StrokeEndCap(CompositionStrokeCap *value);
	virtual STDMETHODIMP _put_StrokeEndCap(CompositionStrokeCap value);
	virtual STDMETHODIMP _get_StrokeLineJoin(CompositionStrokeLineJoin *value);
	virtual STDMETHODIMP _put_StrokeLineJoin(CompositionStrokeLineJoin value);
	virtual STDMETHODIMP _get_StrokeMiterLimit(float *value);
	virtual STDMETHODIMP _put_StrokeMiterLimit(float value);
	virtual STDMETHODIMP _get_StrokeStartCap(CompositionStrokeCap *value);
	virtual STDMETHODIMP _put_StrokeStartCap(CompositionStrokeCap value);
	virtual STDMETHODIMP _get_StrokeThickness(float *value);
	virtual STDMETHODIMP _put_StrokeThickness(float value);
};
template<typename X> struct ICompositionSpriteShape_adaptor : X {
	union {
		struct : property {
			ptr<CompositionBrush> get() { CompositionBrush* value; hrcheck(enc(&ICompositionSpriteShape_adaptor::FillBrush)->_get_FillBrush(&value)); return from_abi(value); }
			ptr<CompositionBrush> operator()() { return get(); }
			operator ptr<CompositionBrush> () { return get(); }
			ptr<CompositionBrush> operator->() { return get(); }
			void put(pptr<CompositionBrush> value) { hrcheck(enc(&ICompositionSpriteShape_adaptor::FillBrush)->_put_FillBrush(value)); }
			void operator=(pptr<CompositionBrush> value) { put(value); }
			void operator()(pptr<CompositionBrush> value) { put(value); }
		} FillBrush;
		struct : property {
			ptr<CompositionGeometry> get() { CompositionGeometry* value; hrcheck(enc(&ICompositionSpriteShape_adaptor::Geometry)->_get_Geometry(&value)); return from_abi(value); }
			ptr<CompositionGeometry> operator()() { return get(); }
			operator ptr<CompositionGeometry> () { return get(); }
			ptr<CompositionGeometry> operator->() { return get(); }
			void put(pptr<CompositionGeometry> value) { hrcheck(enc(&ICompositionSpriteShape_adaptor::Geometry)->_put_Geometry(value)); }
			void operator=(pptr<CompositionGeometry> value) { put(value); }
			void operator()(pptr<CompositionGeometry> value) { put(value); }
		} Geometry;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICompositionSpriteShape_adaptor::IsStrokeNonScaling)->_get_IsStrokeNonScaling(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICompositionSpriteShape_adaptor::IsStrokeNonScaling)->_put_IsStrokeNonScaling(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsStrokeNonScaling;
		struct : property {
			ptr<CompositionBrush> get() { CompositionBrush* value; hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeBrush)->_get_StrokeBrush(&value)); return from_abi(value); }
			ptr<CompositionBrush> operator()() { return get(); }
			operator ptr<CompositionBrush> () { return get(); }
			ptr<CompositionBrush> operator->() { return get(); }
			void put(pptr<CompositionBrush> value) { hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeBrush)->_put_StrokeBrush(value)); }
			void operator=(pptr<CompositionBrush> value) { put(value); }
			void operator()(pptr<CompositionBrush> value) { put(value); }
		} StrokeBrush;
		struct : property {
			ptr<CompositionStrokeDashArray> get() { CompositionStrokeDashArray* value; hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeDashArray)->_get_StrokeDashArray(&value)); return from_abi(value); }
			ptr<CompositionStrokeDashArray> operator()() { return get(); }
			operator ptr<CompositionStrokeDashArray> () { return get(); }
			ptr<CompositionStrokeDashArray> operator->() { return get(); }
		} StrokeDashArray;
		struct : property {
			CompositionStrokeCap get() { CompositionStrokeCap value; hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeDashCap)->_get_StrokeDashCap(&value)); return value; }
			CompositionStrokeCap operator()() { return get(); }
			operator CompositionStrokeCap () { return get(); }
			void put(CompositionStrokeCap value) { hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeDashCap)->_put_StrokeDashCap(value)); }
			void operator=(CompositionStrokeCap value) { put(value); }
			void operator()(CompositionStrokeCap value) { put(value); }
		} StrokeDashCap;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeDashOffset)->_get_StrokeDashOffset(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeDashOffset)->_put_StrokeDashOffset(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} StrokeDashOffset;
		struct : property {
			CompositionStrokeCap get() { CompositionStrokeCap value; hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeEndCap)->_get_StrokeEndCap(&value)); return value; }
			CompositionStrokeCap operator()() { return get(); }
			operator CompositionStrokeCap () { return get(); }
			void put(CompositionStrokeCap value) { hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeEndCap)->_put_StrokeEndCap(value)); }
			void operator=(CompositionStrokeCap value) { put(value); }
			void operator()(CompositionStrokeCap value) { put(value); }
		} StrokeEndCap;
		struct : property {
			CompositionStrokeLineJoin get() { CompositionStrokeLineJoin value; hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeLineJoin)->_get_StrokeLineJoin(&value)); return value; }
			CompositionStrokeLineJoin operator()() { return get(); }
			operator CompositionStrokeLineJoin () { return get(); }
			void put(CompositionStrokeLineJoin value) { hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeLineJoin)->_put_StrokeLineJoin(value)); }
			void operator=(CompositionStrokeLineJoin value) { put(value); }
			void operator()(CompositionStrokeLineJoin value) { put(value); }
		} StrokeLineJoin;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeMiterLimit)->_get_StrokeMiterLimit(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeMiterLimit)->_put_StrokeMiterLimit(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} StrokeMiterLimit;
		struct : property {
			CompositionStrokeCap get() { CompositionStrokeCap value; hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeStartCap)->_get_StrokeStartCap(&value)); return value; }
			CompositionStrokeCap operator()() { return get(); }
			operator CompositionStrokeCap () { return get(); }
			void put(CompositionStrokeCap value) { hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeStartCap)->_put_StrokeStartCap(value)); }
			void operator=(CompositionStrokeCap value) { put(value); }
			void operator()(CompositionStrokeCap value) { put(value); }
		} StrokeStartCap;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeThickness)->_get_StrokeThickness(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionSpriteShape_adaptor::StrokeThickness)->_put_StrokeThickness(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} StrokeThickness;
	};
	ICompositionSpriteShape_adaptor() {}
};
template<typename X> struct adapt<ICompositionSpriteShape, X> : Windows::UI::Composition::ICompositionSpriteShape_adaptor<X> { typedef adapt ICompositionSpriteShape; };
struct ICompositionSpriteShape : ICompositionSpriteShape_raw, generate<ICompositionSpriteShape> {};

// ICompositionGeometryFactory
struct ICompositionGeometryFactory : IInspectable, generate<ICompositionGeometryFactory> {};

// CompositionGeometry
template<typename X> struct statics<CompositionGeometry, X> : X {
	typedef typename X::root_type CompositionGeometry;
};
struct CompositionGeometry : generate<CompositionGeometry> {};

// CompositionStrokeDashArray
template<typename X> struct statics<CompositionStrokeDashArray, X> : X {
	typedef typename X::root_type CompositionStrokeDashArray;
};
struct CompositionStrokeDashArray : generate<CompositionStrokeDashArray> {};

// ICompositionSurface
struct ICompositionSurface : IInspectable, generate<ICompositionSurface> {};

// ICompositionDrawingSurfaceFactory
struct ICompositionDrawingSurfaceFactory : IInspectable, generate<ICompositionDrawingSurfaceFactory> {};

// CompositionDrawingSurface
template<typename X> struct statics<CompositionDrawingSurface, X> : X {
	typedef typename X::root_type CompositionDrawingSurface;
};
struct CompositionDrawingSurface : generate<CompositionDrawingSurface> {
	using ICompositionDrawingSurface2::ScrollWithClip;
	using ICompositionDrawingSurface2::Scroll;
};

// ICompositionSurfaceBrush
struct ICompositionSurfaceBrush_raw : IInspectable {
	virtual STDMETHODIMP _get_BitmapInterpolationMode(CompositionBitmapInterpolationMode *value);
	virtual STDMETHODIMP _put_BitmapInterpolationMode(CompositionBitmapInterpolationMode value);
	virtual STDMETHODIMP _get_HorizontalAlignmentRatio(float *value);
	virtual STDMETHODIMP _put_HorizontalAlignmentRatio(float value);
	virtual STDMETHODIMP _get_Stretch(CompositionStretch *value);
	virtual STDMETHODIMP _put_Stretch(CompositionStretch value);
	virtual STDMETHODIMP _get_Surface(ICompositionSurface* *value);
	virtual STDMETHODIMP _put_Surface(ICompositionSurface* value);
	virtual STDMETHODIMP _get_VerticalAlignmentRatio(float *value);
	virtual STDMETHODIMP _put_VerticalAlignmentRatio(float value);
};
template<typename X> struct ICompositionSurfaceBrush_adaptor : X {
	union {
		struct : property {
			CompositionBitmapInterpolationMode get() { CompositionBitmapInterpolationMode value; hrcheck(enc(&ICompositionSurfaceBrush_adaptor::BitmapInterpolationMode)->_get_BitmapInterpolationMode(&value)); return value; }
			CompositionBitmapInterpolationMode operator()() { return get(); }
			operator CompositionBitmapInterpolationMode () { return get(); }
			void put(CompositionBitmapInterpolationMode value) { hrcheck(enc(&ICompositionSurfaceBrush_adaptor::BitmapInterpolationMode)->_put_BitmapInterpolationMode(value)); }
			void operator=(CompositionBitmapInterpolationMode value) { put(value); }
			void operator()(CompositionBitmapInterpolationMode value) { put(value); }
		} BitmapInterpolationMode;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionSurfaceBrush_adaptor::HorizontalAlignmentRatio)->_get_HorizontalAlignmentRatio(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionSurfaceBrush_adaptor::HorizontalAlignmentRatio)->_put_HorizontalAlignmentRatio(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} HorizontalAlignmentRatio;
		struct : property {
			CompositionStretch get() { CompositionStretch value; hrcheck(enc(&ICompositionSurfaceBrush_adaptor::Stretch)->_get_Stretch(&value)); return value; }
			CompositionStretch operator()() { return get(); }
			operator CompositionStretch () { return get(); }
			void put(CompositionStretch value) { hrcheck(enc(&ICompositionSurfaceBrush_adaptor::Stretch)->_put_Stretch(value)); }
			void operator=(CompositionStretch value) { put(value); }
			void operator()(CompositionStretch value) { put(value); }
		} Stretch;
		struct : property {
			ptr<ICompositionSurface> get() { ICompositionSurface* value; hrcheck(enc(&ICompositionSurfaceBrush_adaptor::Surface)->_get_Surface(&value)); return from_abi(value); }
			ptr<ICompositionSurface> operator()() { return get(); }
			operator ptr<ICompositionSurface> () { return get(); }
			ptr<ICompositionSurface> operator->() { return get(); }
			void put(pptr<ICompositionSurface> value) { hrcheck(enc(&ICompositionSurfaceBrush_adaptor::Surface)->_put_Surface(value)); }
			void operator=(pptr<ICompositionSurface> value) { put(value); }
			void operator()(pptr<ICompositionSurface> value) { put(value); }
		} Surface;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionSurfaceBrush_adaptor::VerticalAlignmentRatio)->_get_VerticalAlignmentRatio(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionSurfaceBrush_adaptor::VerticalAlignmentRatio)->_put_VerticalAlignmentRatio(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} VerticalAlignmentRatio;
	};
	ICompositionSurfaceBrush_adaptor() {}
};
template<typename X> struct adapt<ICompositionSurfaceBrush, X> : Windows::UI::Composition::ICompositionSurfaceBrush_adaptor<X> { typedef adapt ICompositionSurfaceBrush; };
struct ICompositionSurfaceBrush : ICompositionSurfaceBrush_raw, generate<ICompositionSurfaceBrush> {};

// ICompositionSurfaceBrush2
struct ICompositionSurfaceBrush2_raw : IInspectable {
	virtual STDMETHODIMP _get_AnchorPoint(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_AnchorPoint(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_CenterPoint(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_CenterPoint(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_Offset(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Offset(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_RotationAngle(float *value);
	virtual STDMETHODIMP _put_RotationAngle(float value);
	virtual STDMETHODIMP _get_RotationAngleInDegrees(float *value);
	virtual STDMETHODIMP _put_RotationAngleInDegrees(float value);
	virtual STDMETHODIMP _get_Scale(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Scale(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_TransformMatrix(Foundation::Numerics::Matrix3x2 *value);
	virtual STDMETHODIMP _put_TransformMatrix(Foundation::Numerics::Matrix3x2 value);
};
template<typename X> struct ICompositionSurfaceBrush2_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionSurfaceBrush2_adaptor::AnchorPoint)->_get_AnchorPoint(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionSurfaceBrush2_adaptor::AnchorPoint)->_put_AnchorPoint(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} AnchorPoint;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionSurfaceBrush2_adaptor::CenterPoint)->_get_CenterPoint(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionSurfaceBrush2_adaptor::CenterPoint)->_put_CenterPoint(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} CenterPoint;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionSurfaceBrush2_adaptor::Offset)->_get_Offset(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionSurfaceBrush2_adaptor::Offset)->_put_Offset(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Offset;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionSurfaceBrush2_adaptor::RotationAngle)->_get_RotationAngle(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionSurfaceBrush2_adaptor::RotationAngle)->_put_RotationAngle(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} RotationAngle;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionSurfaceBrush2_adaptor::RotationAngleInDegrees)->_get_RotationAngleInDegrees(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionSurfaceBrush2_adaptor::RotationAngleInDegrees)->_put_RotationAngleInDegrees(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} RotationAngleInDegrees;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionSurfaceBrush2_adaptor::Scale)->_get_Scale(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionSurfaceBrush2_adaptor::Scale)->_put_Scale(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Scale;
		struct : property {
			Foundation::Numerics::Matrix3x2 get() { Foundation::Numerics::Matrix3x2 value; hrcheck(enc(&ICompositionSurfaceBrush2_adaptor::TransformMatrix)->_get_TransformMatrix(&value)); return value; }
			Foundation::Numerics::Matrix3x2 operator()() { return get(); }
			operator Foundation::Numerics::Matrix3x2 () { return get(); }
			void put(const Foundation::Numerics::Matrix3x2& value) { hrcheck(enc(&ICompositionSurfaceBrush2_adaptor::TransformMatrix)->_put_TransformMatrix(value)); }
			void operator=(const Foundation::Numerics::Matrix3x2& value) { put(value); }
			void operator()(const Foundation::Numerics::Matrix3x2& value) { put(value); }
		} TransformMatrix;
	};
	ICompositionSurfaceBrush2_adaptor() {}
};
template<typename X> struct adapt<ICompositionSurfaceBrush2, X> : Windows::UI::Composition::ICompositionSurfaceBrush2_adaptor<X> { typedef adapt ICompositionSurfaceBrush2; };
struct ICompositionSurfaceBrush2 : ICompositionSurfaceBrush2_raw, generate<ICompositionSurfaceBrush2> {};

// ICompositionTarget
struct ICompositionTarget_raw : IInspectable {
	virtual STDMETHODIMP _get_Root(Visual* *value);
	virtual STDMETHODIMP _put_Root(Visual* value);
};
template<typename X> struct ICompositionTarget_adaptor : X {
	union {
		struct : property {
			ptr<Visual> get() { Visual* value; hrcheck(enc(&ICompositionTarget_adaptor::Root)->_get_Root(&value)); return from_abi(value); }
			ptr<Visual> operator()() { return get(); }
			operator ptr<Visual> () { return get(); }
			ptr<Visual> operator->() { return get(); }
			void put(pptr<Visual> value) { hrcheck(enc(&ICompositionTarget_adaptor::Root)->_put_Root(value)); }
			void operator=(pptr<Visual> value) { put(value); }
			void operator()(pptr<Visual> value) { put(value); }
		} Root;
	};
	ICompositionTarget_adaptor() {}
};
template<typename X> struct adapt<ICompositionTarget, X> : Windows::UI::Composition::ICompositionTarget_adaptor<X> { typedef adapt ICompositionTarget; };
struct ICompositionTarget : ICompositionTarget_raw, generate<ICompositionTarget> {};

// ICompositionViewBox
struct ICompositionViewBox_raw : IInspectable {
	virtual STDMETHODIMP _get_HorizontalAlignmentRatio(float *value);
	virtual STDMETHODIMP _put_HorizontalAlignmentRatio(float value);
	virtual STDMETHODIMP _get_Offset(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Offset(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_Size(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Size(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_Stretch(CompositionStretch *value);
	virtual STDMETHODIMP _put_Stretch(CompositionStretch value);
	virtual STDMETHODIMP _get_VerticalAlignmentRatio(float *value);
	virtual STDMETHODIMP _put_VerticalAlignmentRatio(float value);
};
template<typename X> struct ICompositionViewBox_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionViewBox_adaptor::HorizontalAlignmentRatio)->_get_HorizontalAlignmentRatio(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionViewBox_adaptor::HorizontalAlignmentRatio)->_put_HorizontalAlignmentRatio(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} HorizontalAlignmentRatio;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionViewBox_adaptor::Offset)->_get_Offset(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionViewBox_adaptor::Offset)->_put_Offset(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Offset;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICompositionViewBox_adaptor::Size)->_get_Size(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&ICompositionViewBox_adaptor::Size)->_put_Size(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Size;
		struct : property {
			CompositionStretch get() { CompositionStretch value; hrcheck(enc(&ICompositionViewBox_adaptor::Stretch)->_get_Stretch(&value)); return value; }
			CompositionStretch operator()() { return get(); }
			operator CompositionStretch () { return get(); }
			void put(CompositionStretch value) { hrcheck(enc(&ICompositionViewBox_adaptor::Stretch)->_put_Stretch(value)); }
			void operator=(CompositionStretch value) { put(value); }
			void operator()(CompositionStretch value) { put(value); }
		} Stretch;
		struct : property {
			float get() { float value; hrcheck(enc(&ICompositionViewBox_adaptor::VerticalAlignmentRatio)->_get_VerticalAlignmentRatio(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ICompositionViewBox_adaptor::VerticalAlignmentRatio)->_put_VerticalAlignmentRatio(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} VerticalAlignmentRatio;
	};
	ICompositionViewBox_adaptor() {}
};
template<typename X> struct adapt<ICompositionViewBox, X> : Windows::UI::Composition::ICompositionViewBox_adaptor<X> { typedef adapt ICompositionViewBox; };
struct ICompositionViewBox : ICompositionViewBox_raw, generate<ICompositionViewBox> {};

// ICompositionVirtualDrawingSurface
struct ICompositionVirtualDrawingSurface_raw : IInspectable {
	virtual STDMETHODIMP _Trim(unsigned rectsSize, Graphics::RectInt32 *rects);
};
template<typename X> struct ICompositionVirtualDrawingSurface_adaptor : X {
	void Trim(const szarray<Graphics::RectInt32>& rects) { hrcheck(X::get()->_Trim(rects.size, to_abi(rects.p))); }
};
template<typename X> struct adapt<ICompositionVirtualDrawingSurface, X> : Windows::UI::Composition::ICompositionVirtualDrawingSurface_adaptor<X> { typedef adapt ICompositionVirtualDrawingSurface; };
struct ICompositionVirtualDrawingSurface : ICompositionVirtualDrawingSurface_raw, generate<ICompositionVirtualDrawingSurface> {};

// ICompositionVirtualDrawingSurfaceFactory
struct ICompositionVirtualDrawingSurfaceFactory : IInspectable, generate<ICompositionVirtualDrawingSurfaceFactory> {};

// CompositionVirtualDrawingSurface
template<typename X> struct statics<CompositionVirtualDrawingSurface, X> : X {
	typedef typename X::root_type CompositionVirtualDrawingSurface;
};
struct CompositionVirtualDrawingSurface : generate<CompositionVirtualDrawingSurface> {
	using ICompositionDrawingSurface2::ScrollWithClip;
	using ICompositionDrawingSurface2::Scroll;
};

// CompositionColorBrush
template<typename X> struct statics<CompositionColorBrush, X> : X {
	typedef typename X::root_type CompositionColorBrush;
};
struct CompositionColorBrush : generate<CompositionColorBrush> {};

// CompositionEffectFactory
template<typename X> struct statics<CompositionEffectFactory, X> : X {
	typedef typename X::root_type CompositionEffectFactory;
};
struct CompositionEffectFactory : generate<CompositionEffectFactory> {};

// CompositionScopedBatch
template<typename X> struct statics<CompositionScopedBatch, X> : X {
	typedef typename X::root_type CompositionScopedBatch;
};
struct CompositionScopedBatch : generate<CompositionScopedBatch> {};

// CompositionSurfaceBrush
template<typename X> struct statics<CompositionSurfaceBrush, X> : X {
	typedef typename X::root_type CompositionSurfaceBrush;
};
struct CompositionSurfaceBrush : generate<CompositionSurfaceBrush> {};

// ICompositionTargetFactory
struct ICompositionTargetFactory : IInspectable, generate<ICompositionTargetFactory> {};

// CompositionTarget
template<typename X> struct statics<CompositionTarget, X> : X {
	typedef typename X::root_type CompositionTarget;
};
struct CompositionTarget : generate<CompositionTarget> {};

// CompositionCommitBatch
template<typename X> struct statics<CompositionCommitBatch, X> : X {
	typedef typename X::root_type CompositionCommitBatch;
};
struct CompositionCommitBatch : generate<CompositionCommitBatch> {};

// CompositionAnimationGroup
template<typename X> struct statics<CompositionAnimationGroup, X> : X {
	typedef typename X::root_type CompositionAnimationGroup;
};
struct CompositionAnimationGroup : generate<CompositionAnimationGroup> {};

// CompositionBackdropBrush
template<typename X> struct statics<CompositionBackdropBrush, X> : X {
	typedef typename X::root_type CompositionBackdropBrush;
};
struct CompositionBackdropBrush : generate<CompositionBackdropBrush> {};

// CompositionMaskBrush
template<typename X> struct statics<CompositionMaskBrush, X> : X {
	typedef typename X::root_type CompositionMaskBrush;
};
struct CompositionMaskBrush : generate<CompositionMaskBrush> {};

// CompositionNineGridBrush
template<typename X> struct statics<CompositionNineGridBrush, X> : X {
	typedef typename X::root_type CompositionNineGridBrush;
};
struct CompositionNineGridBrush : generate<CompositionNineGridBrush> {
	using ICompositionNineGridBrush::SetInsets;
	using ICompositionNineGridBrush::SetInsetScales;
};

// CompositionEllipseGeometry
template<typename X> struct statics<CompositionEllipseGeometry, X> : X {
	typedef typename X::root_type CompositionEllipseGeometry;
};
struct CompositionEllipseGeometry : generate<CompositionEllipseGeometry> {};

// CompositionLineGeometry
template<typename X> struct statics<CompositionLineGeometry, X> : X {
	typedef typename X::root_type CompositionLineGeometry;
};
struct CompositionLineGeometry : generate<CompositionLineGeometry> {};

// CompositionPathGeometry
template<typename X> struct statics<CompositionPathGeometry, X> : X {
	typedef typename X::root_type CompositionPathGeometry;
};
struct CompositionPathGeometry : generate<CompositionPathGeometry> {};

// CompositionRectangleGeometry
template<typename X> struct statics<CompositionRectangleGeometry, X> : X {
	typedef typename X::root_type CompositionRectangleGeometry;
};
struct CompositionRectangleGeometry : generate<CompositionRectangleGeometry> {};

// CompositionRoundedRectangleGeometry
template<typename X> struct statics<CompositionRoundedRectangleGeometry, X> : X {
	typedef typename X::root_type CompositionRoundedRectangleGeometry;
};
struct CompositionRoundedRectangleGeometry : generate<CompositionRoundedRectangleGeometry> {};

// CompositionViewBox
template<typename X> struct statics<CompositionViewBox, X> : X {
	typedef typename X::root_type CompositionViewBox;
};
struct CompositionViewBox : generate<CompositionViewBox> {};

// IContainerVisual
struct IContainerVisual_raw : IInspectable {
	virtual STDMETHODIMP _get_Children(VisualCollection* *value);
};
template<typename X> struct IContainerVisual_adaptor : X {
	union {
		struct : property {
			ptr<VisualCollection> get() { VisualCollection* value; hrcheck(enc(&IContainerVisual_adaptor::Children)->_get_Children(&value)); return from_abi(value); }
			ptr<VisualCollection> operator()() { return get(); }
			operator ptr<VisualCollection> () { return get(); }
			ptr<VisualCollection> operator->() { return get(); }
		} Children;
	};
	IContainerVisual_adaptor() {}
};
template<typename X> struct adapt<IContainerVisual, X> : Windows::UI::Composition::IContainerVisual_adaptor<X> { typedef adapt IContainerVisual; };
struct IContainerVisual : IContainerVisual_raw, generate<IContainerVisual> {};

// ICubicBezierEasingFunction
struct ICubicBezierEasingFunction_raw : IInspectable {
	virtual STDMETHODIMP _get_ControlPoint1(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _get_ControlPoint2(Foundation::Numerics::Vector2 *value);
};
template<typename X> struct ICubicBezierEasingFunction_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICubicBezierEasingFunction_adaptor::ControlPoint1)->_get_ControlPoint1(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
		} ControlPoint1;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&ICubicBezierEasingFunction_adaptor::ControlPoint2)->_get_ControlPoint2(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
		} ControlPoint2;
	};
	ICubicBezierEasingFunction_adaptor() {}
};
template<typename X> struct adapt<ICubicBezierEasingFunction, X> : Windows::UI::Composition::ICubicBezierEasingFunction_adaptor<X> { typedef adapt ICubicBezierEasingFunction; };
struct ICubicBezierEasingFunction : ICubicBezierEasingFunction_raw, generate<ICubicBezierEasingFunction> {};

// CubicBezierEasingFunction
template<typename X> struct statics<CubicBezierEasingFunction, X> : X {
	typedef typename X::root_type CubicBezierEasingFunction;
};
struct CubicBezierEasingFunction : generate<CubicBezierEasingFunction> {};

// IDistantLight
struct IDistantLight_raw : IInspectable {
	virtual STDMETHODIMP _get_Color(UI::Color *value);
	virtual STDMETHODIMP _put_Color(UI::Color value);
	virtual STDMETHODIMP _get_CoordinateSpace(Visual* *value);
	virtual STDMETHODIMP _put_CoordinateSpace(Visual* value);
	virtual STDMETHODIMP _get_Direction(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_Direction(Foundation::Numerics::Vector3 value);
};
template<typename X> struct IDistantLight_adaptor : X {
	union {
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&IDistantLight_adaptor::Color)->_get_Color(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IDistantLight_adaptor::Color)->_put_Color(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} Color;
		struct : property {
			ptr<Visual> get() { Visual* value; hrcheck(enc(&IDistantLight_adaptor::CoordinateSpace)->_get_CoordinateSpace(&value)); return from_abi(value); }
			ptr<Visual> operator()() { return get(); }
			operator ptr<Visual> () { return get(); }
			ptr<Visual> operator->() { return get(); }
			void put(pptr<Visual> value) { hrcheck(enc(&IDistantLight_adaptor::CoordinateSpace)->_put_CoordinateSpace(value)); }
			void operator=(pptr<Visual> value) { put(value); }
			void operator()(pptr<Visual> value) { put(value); }
		} CoordinateSpace;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IDistantLight_adaptor::Direction)->_get_Direction(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IDistantLight_adaptor::Direction)->_put_Direction(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} Direction;
	};
	IDistantLight_adaptor() {}
};
template<typename X> struct adapt<IDistantLight, X> : Windows::UI::Composition::IDistantLight_adaptor<X> { typedef adapt IDistantLight; };
struct IDistantLight : IDistantLight_raw, generate<IDistantLight> {};

// IDistantLight2
struct IDistantLight2_raw : IInspectable {
	virtual STDMETHODIMP _get_Intensity(float *value);
	virtual STDMETHODIMP _put_Intensity(float value);
};
template<typename X> struct IDistantLight2_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&IDistantLight2_adaptor::Intensity)->_get_Intensity(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IDistantLight2_adaptor::Intensity)->_put_Intensity(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Intensity;
	};
	IDistantLight2_adaptor() {}
};
template<typename X> struct adapt<IDistantLight2, X> : Windows::UI::Composition::IDistantLight2_adaptor<X> { typedef adapt IDistantLight2; };
struct IDistantLight2 : IDistantLight2_raw, generate<IDistantLight2> {};

// IDropShadow
struct IDropShadow_raw : IInspectable {
	virtual STDMETHODIMP _get_BlurRadius(float *value);
	virtual STDMETHODIMP _put_BlurRadius(float value);
	virtual STDMETHODIMP _get_Color(UI::Color *value);
	virtual STDMETHODIMP _put_Color(UI::Color value);
	virtual STDMETHODIMP _get_Mask(CompositionBrush* *value);
	virtual STDMETHODIMP _put_Mask(CompositionBrush* value);
	virtual STDMETHODIMP _get_Offset(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_Offset(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_Opacity(float *value);
	virtual STDMETHODIMP _put_Opacity(float value);
};
template<typename X> struct IDropShadow_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&IDropShadow_adaptor::BlurRadius)->_get_BlurRadius(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IDropShadow_adaptor::BlurRadius)->_put_BlurRadius(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} BlurRadius;
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&IDropShadow_adaptor::Color)->_get_Color(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IDropShadow_adaptor::Color)->_put_Color(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} Color;
		struct : property {
			ptr<CompositionBrush> get() { CompositionBrush* value; hrcheck(enc(&IDropShadow_adaptor::Mask)->_get_Mask(&value)); return from_abi(value); }
			ptr<CompositionBrush> operator()() { return get(); }
			operator ptr<CompositionBrush> () { return get(); }
			ptr<CompositionBrush> operator->() { return get(); }
			void put(pptr<CompositionBrush> value) { hrcheck(enc(&IDropShadow_adaptor::Mask)->_put_Mask(value)); }
			void operator=(pptr<CompositionBrush> value) { put(value); }
			void operator()(pptr<CompositionBrush> value) { put(value); }
		} Mask;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IDropShadow_adaptor::Offset)->_get_Offset(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IDropShadow_adaptor::Offset)->_put_Offset(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} Offset;
		struct : property {
			float get() { float value; hrcheck(enc(&IDropShadow_adaptor::Opacity)->_get_Opacity(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IDropShadow_adaptor::Opacity)->_put_Opacity(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Opacity;
	};
	IDropShadow_adaptor() {}
};
template<typename X> struct adapt<IDropShadow, X> : Windows::UI::Composition::IDropShadow_adaptor<X> { typedef adapt IDropShadow; };
struct IDropShadow : IDropShadow_raw, generate<IDropShadow> {};

// IDropShadow2
struct IDropShadow2_raw : IInspectable {
	virtual STDMETHODIMP _get_SourcePolicy(CompositionDropShadowSourcePolicy *value);
	virtual STDMETHODIMP _put_SourcePolicy(CompositionDropShadowSourcePolicy value);
};
template<typename X> struct IDropShadow2_adaptor : X {
	union {
		struct : property {
			CompositionDropShadowSourcePolicy get() { CompositionDropShadowSourcePolicy value; hrcheck(enc(&IDropShadow2_adaptor::SourcePolicy)->_get_SourcePolicy(&value)); return value; }
			CompositionDropShadowSourcePolicy operator()() { return get(); }
			operator CompositionDropShadowSourcePolicy () { return get(); }
			void put(CompositionDropShadowSourcePolicy value) { hrcheck(enc(&IDropShadow2_adaptor::SourcePolicy)->_put_SourcePolicy(value)); }
			void operator=(CompositionDropShadowSourcePolicy value) { put(value); }
			void operator()(CompositionDropShadowSourcePolicy value) { put(value); }
		} SourcePolicy;
	};
	IDropShadow2_adaptor() {}
};
template<typename X> struct adapt<IDropShadow2, X> : Windows::UI::Composition::IDropShadow2_adaptor<X> { typedef adapt IDropShadow2; };
struct IDropShadow2 : IDropShadow2_raw, generate<IDropShadow2> {};

// IExpressionAnimation
struct IExpressionAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_Expression(HSTRING *value);
	virtual STDMETHODIMP _put_Expression(HSTRING value);
};
template<typename X> struct IExpressionAnimation_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IExpressionAnimation_adaptor::Expression)->_get_Expression(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IExpressionAnimation_adaptor::Expression)->_put_Expression(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Expression;
	};
	IExpressionAnimation_adaptor() {}
};
template<typename X> struct adapt<IExpressionAnimation, X> : Windows::UI::Composition::IExpressionAnimation_adaptor<X> { typedef adapt IExpressionAnimation; };
struct IExpressionAnimation : IExpressionAnimation_raw, generate<IExpressionAnimation> {};

// IImplicitAnimationCollection
struct IImplicitAnimationCollection : IInspectable, generate<IImplicitAnimationCollection> {};

// ImplicitAnimationCollection
template<typename X> struct statics<ImplicitAnimationCollection, X> : X {
	typedef typename X::root_type ImplicitAnimationCollection;
};
struct ImplicitAnimationCollection : generate<ImplicitAnimationCollection> {};

// IInsetClip
struct IInsetClip_raw : IInspectable {
	virtual STDMETHODIMP _get_BottomInset(float *value);
	virtual STDMETHODIMP _put_BottomInset(float value);
	virtual STDMETHODIMP _get_LeftInset(float *value);
	virtual STDMETHODIMP _put_LeftInset(float value);
	virtual STDMETHODIMP _get_RightInset(float *value);
	virtual STDMETHODIMP _put_RightInset(float value);
	virtual STDMETHODIMP _get_TopInset(float *value);
	virtual STDMETHODIMP _put_TopInset(float value);
};
template<typename X> struct IInsetClip_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&IInsetClip_adaptor::BottomInset)->_get_BottomInset(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IInsetClip_adaptor::BottomInset)->_put_BottomInset(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} BottomInset;
		struct : property {
			float get() { float value; hrcheck(enc(&IInsetClip_adaptor::LeftInset)->_get_LeftInset(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IInsetClip_adaptor::LeftInset)->_put_LeftInset(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} LeftInset;
		struct : property {
			float get() { float value; hrcheck(enc(&IInsetClip_adaptor::RightInset)->_get_RightInset(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IInsetClip_adaptor::RightInset)->_put_RightInset(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} RightInset;
		struct : property {
			float get() { float value; hrcheck(enc(&IInsetClip_adaptor::TopInset)->_get_TopInset(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IInsetClip_adaptor::TopInset)->_put_TopInset(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} TopInset;
	};
	IInsetClip_adaptor() {}
};
template<typename X> struct adapt<IInsetClip, X> : Windows::UI::Composition::IInsetClip_adaptor<X> { typedef adapt IInsetClip; };
struct IInsetClip : IInsetClip_raw, generate<IInsetClip> {};

// IKeyFrameAnimation
struct IKeyFrameAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_DelayTime(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_DelayTime(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_Duration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_Duration(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_IterationBehavior(AnimationIterationBehavior *value);
	virtual STDMETHODIMP _put_IterationBehavior(AnimationIterationBehavior value);
	virtual STDMETHODIMP _get_IterationCount(int *value);
	virtual STDMETHODIMP _put_IterationCount(int value);
	virtual STDMETHODIMP _get_KeyFrameCount(int *value);
	virtual STDMETHODIMP _get_StopBehavior(AnimationStopBehavior *value);
	virtual STDMETHODIMP _put_StopBehavior(AnimationStopBehavior value);
	virtual STDMETHODIMP _InsertExpressionKeyFrame(float normalizedProgressKey, HSTRING value);
	virtual STDMETHODIMP _InsertExpressionKeyFrameWithEasingFunction(float normalizedProgressKey, HSTRING value, CompositionEasingFunction* easingFunction);
};
template<typename X> struct IKeyFrameAnimation_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IKeyFrameAnimation_adaptor::DelayTime)->_get_DelayTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IKeyFrameAnimation_adaptor::DelayTime)->_put_DelayTime(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} DelayTime;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IKeyFrameAnimation_adaptor::Duration)->_get_Duration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IKeyFrameAnimation_adaptor::Duration)->_put_Duration(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Duration;
		struct : property {
			AnimationIterationBehavior get() { AnimationIterationBehavior value; hrcheck(enc(&IKeyFrameAnimation_adaptor::IterationBehavior)->_get_IterationBehavior(&value)); return value; }
			AnimationIterationBehavior operator()() { return get(); }
			operator AnimationIterationBehavior () { return get(); }
			void put(AnimationIterationBehavior value) { hrcheck(enc(&IKeyFrameAnimation_adaptor::IterationBehavior)->_put_IterationBehavior(value)); }
			void operator=(AnimationIterationBehavior value) { put(value); }
			void operator()(AnimationIterationBehavior value) { put(value); }
		} IterationBehavior;
		struct : property {
			int get() { int value; hrcheck(enc(&IKeyFrameAnimation_adaptor::IterationCount)->_get_IterationCount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IKeyFrameAnimation_adaptor::IterationCount)->_put_IterationCount(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} IterationCount;
		struct : property {
			int get() { int value; hrcheck(enc(&IKeyFrameAnimation_adaptor::KeyFrameCount)->_get_KeyFrameCount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} KeyFrameCount;
		struct : property {
			AnimationStopBehavior get() { AnimationStopBehavior value; hrcheck(enc(&IKeyFrameAnimation_adaptor::StopBehavior)->_get_StopBehavior(&value)); return value; }
			AnimationStopBehavior operator()() { return get(); }
			operator AnimationStopBehavior () { return get(); }
			void put(AnimationStopBehavior value) { hrcheck(enc(&IKeyFrameAnimation_adaptor::StopBehavior)->_put_StopBehavior(value)); }
			void operator=(AnimationStopBehavior value) { put(value); }
			void operator()(AnimationStopBehavior value) { put(value); }
		} StopBehavior;
	};
	void InsertExpressionKeyFrame(float normalizedProgressKey, hstring_ref value) { hrcheck(X::get()->_InsertExpressionKeyFrame(normalizedProgressKey, value)); }
	void InsertExpressionKeyFrame(float normalizedProgressKey, hstring_ref value, pptr<CompositionEasingFunction> easingFunction) { hrcheck(X::get()->_InsertExpressionKeyFrameWithEasingFunction(normalizedProgressKey, value, easingFunction)); }
	IKeyFrameAnimation_adaptor() {}
};
template<typename X> struct adapt<IKeyFrameAnimation, X> : Windows::UI::Composition::IKeyFrameAnimation_adaptor<X> { typedef adapt IKeyFrameAnimation; };
struct IKeyFrameAnimation : IKeyFrameAnimation_raw, generate<IKeyFrameAnimation> {};

// IKeyFrameAnimation2
struct IKeyFrameAnimation2_raw : IInspectable {
	virtual STDMETHODIMP _get_Direction(AnimationDirection *value);
	virtual STDMETHODIMP _put_Direction(AnimationDirection value);
};
template<typename X> struct IKeyFrameAnimation2_adaptor : X {
	union {
		struct : property {
			AnimationDirection get() { AnimationDirection value; hrcheck(enc(&IKeyFrameAnimation2_adaptor::Direction)->_get_Direction(&value)); return value; }
			AnimationDirection operator()() { return get(); }
			operator AnimationDirection () { return get(); }
			void put(AnimationDirection value) { hrcheck(enc(&IKeyFrameAnimation2_adaptor::Direction)->_put_Direction(value)); }
			void operator=(AnimationDirection value) { put(value); }
			void operator()(AnimationDirection value) { put(value); }
		} Direction;
	};
	IKeyFrameAnimation2_adaptor() {}
};
template<typename X> struct adapt<IKeyFrameAnimation2, X> : Windows::UI::Composition::IKeyFrameAnimation2_adaptor<X> { typedef adapt IKeyFrameAnimation2; };
struct IKeyFrameAnimation2 : IKeyFrameAnimation2_raw, generate<IKeyFrameAnimation2> {};

// IKeyFrameAnimation3
struct IKeyFrameAnimation3_raw : IInspectable {
	virtual STDMETHODIMP _get_DelayBehavior(AnimationDelayBehavior *value);
	virtual STDMETHODIMP _put_DelayBehavior(AnimationDelayBehavior value);
};
template<typename X> struct IKeyFrameAnimation3_adaptor : X {
	union {
		struct : property {
			AnimationDelayBehavior get() { AnimationDelayBehavior value; hrcheck(enc(&IKeyFrameAnimation3_adaptor::DelayBehavior)->_get_DelayBehavior(&value)); return value; }
			AnimationDelayBehavior operator()() { return get(); }
			operator AnimationDelayBehavior () { return get(); }
			void put(AnimationDelayBehavior value) { hrcheck(enc(&IKeyFrameAnimation3_adaptor::DelayBehavior)->_put_DelayBehavior(value)); }
			void operator=(AnimationDelayBehavior value) { put(value); }
			void operator()(AnimationDelayBehavior value) { put(value); }
		} DelayBehavior;
	};
	IKeyFrameAnimation3_adaptor() {}
};
template<typename X> struct adapt<IKeyFrameAnimation3, X> : Windows::UI::Composition::IKeyFrameAnimation3_adaptor<X> { typedef adapt IKeyFrameAnimation3; };
struct IKeyFrameAnimation3 : IKeyFrameAnimation3_raw, generate<IKeyFrameAnimation3> {};

// ILayerVisual
struct ILayerVisual_raw : IInspectable {
	virtual STDMETHODIMP _get_Effect(CompositionEffectBrush* *value);
	virtual STDMETHODIMP _put_Effect(CompositionEffectBrush* value);
};
template<typename X> struct ILayerVisual_adaptor : X {
	union {
		struct : property {
			ptr<CompositionEffectBrush> get() { CompositionEffectBrush* value; hrcheck(enc(&ILayerVisual_adaptor::Effect)->_get_Effect(&value)); return from_abi(value); }
			ptr<CompositionEffectBrush> operator()() { return get(); }
			operator ptr<CompositionEffectBrush> () { return get(); }
			ptr<CompositionEffectBrush> operator->() { return get(); }
			void put(pptr<CompositionEffectBrush> value) { hrcheck(enc(&ILayerVisual_adaptor::Effect)->_put_Effect(value)); }
			void operator=(pptr<CompositionEffectBrush> value) { put(value); }
			void operator()(pptr<CompositionEffectBrush> value) { put(value); }
		} Effect;
	};
	ILayerVisual_adaptor() {}
};
template<typename X> struct adapt<ILayerVisual, X> : Windows::UI::Composition::ILayerVisual_adaptor<X> { typedef adapt ILayerVisual; };
struct ILayerVisual : ILayerVisual_raw, generate<ILayerVisual> {};

// ILayerVisual2
struct ILayerVisual2_raw : IInspectable {
	virtual STDMETHODIMP _get_Shadow(CompositionShadow* *value);
	virtual STDMETHODIMP _put_Shadow(CompositionShadow* value);
};
template<typename X> struct ILayerVisual2_adaptor : X {
	union {
		struct : property {
			ptr<CompositionShadow> get() { CompositionShadow* value; hrcheck(enc(&ILayerVisual2_adaptor::Shadow)->_get_Shadow(&value)); return from_abi(value); }
			ptr<CompositionShadow> operator()() { return get(); }
			operator ptr<CompositionShadow> () { return get(); }
			ptr<CompositionShadow> operator->() { return get(); }
			void put(pptr<CompositionShadow> value) { hrcheck(enc(&ILayerVisual2_adaptor::Shadow)->_put_Shadow(value)); }
			void operator=(pptr<CompositionShadow> value) { put(value); }
			void operator()(pptr<CompositionShadow> value) { put(value); }
		} Shadow;
	};
	ILayerVisual2_adaptor() {}
};
template<typename X> struct adapt<ILayerVisual2, X> : Windows::UI::Composition::ILayerVisual2_adaptor<X> { typedef adapt ILayerVisual2; };
struct ILayerVisual2 : ILayerVisual2_raw, generate<ILayerVisual2> {};

// ICompositionShadowFactory
struct ICompositionShadowFactory : IInspectable, generate<ICompositionShadowFactory> {};

// CompositionShadow
template<typename X> struct statics<CompositionShadow, X> : X {
	typedef typename X::root_type CompositionShadow;
};
struct CompositionShadow : generate<CompositionShadow> {};

// DropShadow
template<typename X> struct statics<DropShadow, X> : X {
	typedef typename X::root_type DropShadow;
};
struct DropShadow : generate<DropShadow> {};

// ILinearEasingFunction
struct ILinearEasingFunction : IInspectable, generate<ILinearEasingFunction> {};

// LinearEasingFunction
template<typename X> struct statics<LinearEasingFunction, X> : X {
	typedef typename X::root_type LinearEasingFunction;
};
struct LinearEasingFunction : generate<LinearEasingFunction> {};

// INaturalMotionAnimation
struct INaturalMotionAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_DelayBehavior(AnimationDelayBehavior *value);
	virtual STDMETHODIMP _put_DelayBehavior(AnimationDelayBehavior value);
	virtual STDMETHODIMP _get_DelayTime(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_DelayTime(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_StopBehavior(AnimationStopBehavior *value);
	virtual STDMETHODIMP _put_StopBehavior(AnimationStopBehavior value);
};
template<typename X> struct INaturalMotionAnimation_adaptor : X {
	union {
		struct : property {
			AnimationDelayBehavior get() { AnimationDelayBehavior value; hrcheck(enc(&INaturalMotionAnimation_adaptor::DelayBehavior)->_get_DelayBehavior(&value)); return value; }
			AnimationDelayBehavior operator()() { return get(); }
			operator AnimationDelayBehavior () { return get(); }
			void put(AnimationDelayBehavior value) { hrcheck(enc(&INaturalMotionAnimation_adaptor::DelayBehavior)->_put_DelayBehavior(value)); }
			void operator=(AnimationDelayBehavior value) { put(value); }
			void operator()(AnimationDelayBehavior value) { put(value); }
		} DelayBehavior;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&INaturalMotionAnimation_adaptor::DelayTime)->_get_DelayTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&INaturalMotionAnimation_adaptor::DelayTime)->_put_DelayTime(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} DelayTime;
		struct : property {
			AnimationStopBehavior get() { AnimationStopBehavior value; hrcheck(enc(&INaturalMotionAnimation_adaptor::StopBehavior)->_get_StopBehavior(&value)); return value; }
			AnimationStopBehavior operator()() { return get(); }
			operator AnimationStopBehavior () { return get(); }
			void put(AnimationStopBehavior value) { hrcheck(enc(&INaturalMotionAnimation_adaptor::StopBehavior)->_put_StopBehavior(value)); }
			void operator=(AnimationStopBehavior value) { put(value); }
			void operator()(AnimationStopBehavior value) { put(value); }
		} StopBehavior;
	};
	INaturalMotionAnimation_adaptor() {}
};
template<typename X> struct adapt<INaturalMotionAnimation, X> : Windows::UI::Composition::INaturalMotionAnimation_adaptor<X> { typedef adapt INaturalMotionAnimation; };
struct INaturalMotionAnimation : INaturalMotionAnimation_raw, generate<INaturalMotionAnimation> {};

// IPathKeyFrameAnimation
struct IPathKeyFrameAnimation_raw : IInspectable {
	virtual STDMETHODIMP _InsertKeyFrame(float normalizedProgressKey, CompositionPath* path);
	virtual STDMETHODIMP _InsertKeyFrameWithEasingFunction(float normalizedProgressKey, CompositionPath* path, CompositionEasingFunction* easingFunction);
};
template<typename X> struct IPathKeyFrameAnimation_adaptor : X {
	void InsertKeyFrame(float normalizedProgressKey, pptr<CompositionPath> path) { hrcheck(X::get()->_InsertKeyFrame(normalizedProgressKey, path)); }
	void InsertKeyFrame(float normalizedProgressKey, pptr<CompositionPath> path, pptr<CompositionEasingFunction> easingFunction) { hrcheck(X::get()->_InsertKeyFrameWithEasingFunction(normalizedProgressKey, path, easingFunction)); }
};
template<typename X> struct adapt<IPathKeyFrameAnimation, X> : Windows::UI::Composition::IPathKeyFrameAnimation_adaptor<X> { typedef adapt IPathKeyFrameAnimation; };
struct IPathKeyFrameAnimation : IPathKeyFrameAnimation_raw, generate<IPathKeyFrameAnimation> {};

// IPointLight
struct IPointLight_raw : IInspectable {
	virtual STDMETHODIMP _get_Color(UI::Color *value);
	virtual STDMETHODIMP _put_Color(UI::Color value);
	virtual STDMETHODIMP _get_ConstantAttenuation(float *value);
	virtual STDMETHODIMP _put_ConstantAttenuation(float value);
	virtual STDMETHODIMP _get_CoordinateSpace(Visual* *value);
	virtual STDMETHODIMP _put_CoordinateSpace(Visual* value);
	virtual STDMETHODIMP _get_LinearAttenuation(float *value);
	virtual STDMETHODIMP _put_LinearAttenuation(float value);
	virtual STDMETHODIMP _get_Offset(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_Offset(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_QuadraticAttenuation(float *value);
	virtual STDMETHODIMP _put_QuadraticAttenuation(float value);
};
template<typename X> struct IPointLight_adaptor : X {
	union {
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&IPointLight_adaptor::Color)->_get_Color(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IPointLight_adaptor::Color)->_put_Color(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} Color;
		struct : property {
			float get() { float value; hrcheck(enc(&IPointLight_adaptor::ConstantAttenuation)->_get_ConstantAttenuation(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IPointLight_adaptor::ConstantAttenuation)->_put_ConstantAttenuation(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} ConstantAttenuation;
		struct : property {
			ptr<Visual> get() { Visual* value; hrcheck(enc(&IPointLight_adaptor::CoordinateSpace)->_get_CoordinateSpace(&value)); return from_abi(value); }
			ptr<Visual> operator()() { return get(); }
			operator ptr<Visual> () { return get(); }
			ptr<Visual> operator->() { return get(); }
			void put(pptr<Visual> value) { hrcheck(enc(&IPointLight_adaptor::CoordinateSpace)->_put_CoordinateSpace(value)); }
			void operator=(pptr<Visual> value) { put(value); }
			void operator()(pptr<Visual> value) { put(value); }
		} CoordinateSpace;
		struct : property {
			float get() { float value; hrcheck(enc(&IPointLight_adaptor::LinearAttenuation)->_get_LinearAttenuation(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IPointLight_adaptor::LinearAttenuation)->_put_LinearAttenuation(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} LinearAttenuation;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IPointLight_adaptor::Offset)->_get_Offset(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IPointLight_adaptor::Offset)->_put_Offset(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} Offset;
		struct : property {
			float get() { float value; hrcheck(enc(&IPointLight_adaptor::QuadraticAttenuation)->_get_QuadraticAttenuation(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IPointLight_adaptor::QuadraticAttenuation)->_put_QuadraticAttenuation(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} QuadraticAttenuation;
	};
	IPointLight_adaptor() {}
};
template<typename X> struct adapt<IPointLight, X> : Windows::UI::Composition::IPointLight_adaptor<X> { typedef adapt IPointLight; };
struct IPointLight : IPointLight_raw, generate<IPointLight> {};

// IPointLight2
struct IPointLight2_raw : IInspectable {
	virtual STDMETHODIMP _get_Intensity(float *value);
	virtual STDMETHODIMP _put_Intensity(float value);
};
template<typename X> struct IPointLight2_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&IPointLight2_adaptor::Intensity)->_get_Intensity(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IPointLight2_adaptor::Intensity)->_put_Intensity(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Intensity;
	};
	IPointLight2_adaptor() {}
};
template<typename X> struct adapt<IPointLight2, X> : Windows::UI::Composition::IPointLight2_adaptor<X> { typedef adapt IPointLight2; };
struct IPointLight2 : IPointLight2_raw, generate<IPointLight2> {};

// IPointLight3
struct IPointLight3_raw : IInspectable {
	virtual STDMETHODIMP _get_MinAttenuationCutoff(float *value);
	virtual STDMETHODIMP _put_MinAttenuationCutoff(float value);
	virtual STDMETHODIMP _get_MaxAttenuationCutoff(float *value);
	virtual STDMETHODIMP _put_MaxAttenuationCutoff(float value);
};
template<typename X> struct IPointLight3_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&IPointLight3_adaptor::MaxAttenuationCutoff)->_get_MaxAttenuationCutoff(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IPointLight3_adaptor::MaxAttenuationCutoff)->_put_MaxAttenuationCutoff(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} MaxAttenuationCutoff;
		struct : property {
			float get() { float value; hrcheck(enc(&IPointLight3_adaptor::MinAttenuationCutoff)->_get_MinAttenuationCutoff(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IPointLight3_adaptor::MinAttenuationCutoff)->_put_MinAttenuationCutoff(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} MinAttenuationCutoff;
	};
	IPointLight3_adaptor() {}
};
template<typename X> struct adapt<IPointLight3, X> : Windows::UI::Composition::IPointLight3_adaptor<X> { typedef adapt IPointLight3; };
struct IPointLight3 : IPointLight3_raw, generate<IPointLight3> {};

// IQuaternionKeyFrameAnimation
struct IQuaternionKeyFrameAnimation_raw : IInspectable {
	virtual STDMETHODIMP _InsertKeyFrame(float normalizedProgressKey, Foundation::Numerics::Quaternion value);
	virtual STDMETHODIMP _InsertKeyFrameWithEasingFunction(float normalizedProgressKey, Foundation::Numerics::Quaternion value, CompositionEasingFunction* easingFunction);
};
template<typename X> struct IQuaternionKeyFrameAnimation_adaptor : X {
	void InsertKeyFrame(float normalizedProgressKey, const Foundation::Numerics::Quaternion& value) { hrcheck(X::get()->_InsertKeyFrame(normalizedProgressKey, value)); }
	void InsertKeyFrame(float normalizedProgressKey, const Foundation::Numerics::Quaternion& value, pptr<CompositionEasingFunction> easingFunction) { hrcheck(X::get()->_InsertKeyFrameWithEasingFunction(normalizedProgressKey, value, easingFunction)); }
};
template<typename X> struct adapt<IQuaternionKeyFrameAnimation, X> : Windows::UI::Composition::IQuaternionKeyFrameAnimation_adaptor<X> { typedef adapt IQuaternionKeyFrameAnimation; };
struct IQuaternionKeyFrameAnimation : IQuaternionKeyFrameAnimation_raw, generate<IQuaternionKeyFrameAnimation> {};

// IRenderingDeviceReplacedEventArgs
struct IRenderingDeviceReplacedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_GraphicsDevice(CompositionGraphicsDevice* *value);
};
template<typename X> struct IRenderingDeviceReplacedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<CompositionGraphicsDevice> get() { CompositionGraphicsDevice* value; hrcheck(enc(&IRenderingDeviceReplacedEventArgs_adaptor::GraphicsDevice)->_get_GraphicsDevice(&value)); return from_abi(value); }
			ptr<CompositionGraphicsDevice> operator()() { return get(); }
			operator ptr<CompositionGraphicsDevice> () { return get(); }
			ptr<CompositionGraphicsDevice> operator->() { return get(); }
		} GraphicsDevice;
	};
	IRenderingDeviceReplacedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IRenderingDeviceReplacedEventArgs, X> : Windows::UI::Composition::IRenderingDeviceReplacedEventArgs_adaptor<X> { typedef adapt IRenderingDeviceReplacedEventArgs; };
struct IRenderingDeviceReplacedEventArgs : IRenderingDeviceReplacedEventArgs_raw, generate<IRenderingDeviceReplacedEventArgs> {};

// RenderingDeviceReplacedEventArgs
template<typename X> struct statics<RenderingDeviceReplacedEventArgs, X> : X {
	typedef typename X::root_type RenderingDeviceReplacedEventArgs;
};
struct RenderingDeviceReplacedEventArgs : generate<RenderingDeviceReplacedEventArgs> {};

// IScalarKeyFrameAnimation
struct IScalarKeyFrameAnimation_raw : IInspectable {
	virtual STDMETHODIMP _InsertKeyFrame(float normalizedProgressKey, float value);
	virtual STDMETHODIMP _InsertKeyFrameWithEasingFunction(float normalizedProgressKey, float value, CompositionEasingFunction* easingFunction);
};
template<typename X> struct IScalarKeyFrameAnimation_adaptor : X {
	void InsertKeyFrame(float normalizedProgressKey, float value) { hrcheck(X::get()->_InsertKeyFrame(normalizedProgressKey, value)); }
	void InsertKeyFrame(float normalizedProgressKey, float value, pptr<CompositionEasingFunction> easingFunction) { hrcheck(X::get()->_InsertKeyFrameWithEasingFunction(normalizedProgressKey, value, easingFunction)); }
};
template<typename X> struct adapt<IScalarKeyFrameAnimation, X> : Windows::UI::Composition::IScalarKeyFrameAnimation_adaptor<X> { typedef adapt IScalarKeyFrameAnimation; };
struct IScalarKeyFrameAnimation : IScalarKeyFrameAnimation_raw, generate<IScalarKeyFrameAnimation> {};

// IScalarNaturalMotionAnimation
struct IScalarNaturalMotionAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_FinalValue(Foundation::IReference<float>* *value);
	virtual STDMETHODIMP _put_FinalValue(Foundation::IReference<float>* value);
	virtual STDMETHODIMP _get_InitialValue(Foundation::IReference<float>* *value);
	virtual STDMETHODIMP _put_InitialValue(Foundation::IReference<float>* value);
	virtual STDMETHODIMP _get_InitialVelocity(float *value);
	virtual STDMETHODIMP _put_InitialVelocity(float value);
};
template<typename X> struct IScalarNaturalMotionAnimation_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<float>> get() { Foundation::IReference<float>* value; hrcheck(enc(&IScalarNaturalMotionAnimation_adaptor::FinalValue)->_get_FinalValue(&value)); return from_abi(value); }
			ptr<Foundation::IReference<float>> operator()() { return get(); }
			operator ptr<Foundation::IReference<float>> () { return get(); }
			ptr<Foundation::IReference<float>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<float>> value) { hrcheck(enc(&IScalarNaturalMotionAnimation_adaptor::FinalValue)->_put_FinalValue(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<float>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<float>> value) { put(to_abi(value)); }
		} FinalValue;
		struct : property {
			ptr<Foundation::IReference<float>> get() { Foundation::IReference<float>* value; hrcheck(enc(&IScalarNaturalMotionAnimation_adaptor::InitialValue)->_get_InitialValue(&value)); return from_abi(value); }
			ptr<Foundation::IReference<float>> operator()() { return get(); }
			operator ptr<Foundation::IReference<float>> () { return get(); }
			ptr<Foundation::IReference<float>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<float>> value) { hrcheck(enc(&IScalarNaturalMotionAnimation_adaptor::InitialValue)->_put_InitialValue(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<float>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<float>> value) { put(to_abi(value)); }
		} InitialValue;
		struct : property {
			float get() { float value; hrcheck(enc(&IScalarNaturalMotionAnimation_adaptor::InitialVelocity)->_get_InitialVelocity(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IScalarNaturalMotionAnimation_adaptor::InitialVelocity)->_put_InitialVelocity(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} InitialVelocity;
	};
	IScalarNaturalMotionAnimation_adaptor() {}
};
template<typename X> struct adapt<IScalarNaturalMotionAnimation, X> : Windows::UI::Composition::IScalarNaturalMotionAnimation_adaptor<X> { typedef adapt IScalarNaturalMotionAnimation; };
struct IScalarNaturalMotionAnimation : IScalarNaturalMotionAnimation_raw, generate<IScalarNaturalMotionAnimation> {};

// IShapeVisual
struct IShapeVisual_raw : IInspectable {
	virtual STDMETHODIMP _get_Shapes(CompositionShapeCollection* *value);
	virtual STDMETHODIMP _get_ViewBox(CompositionViewBox* *value);
	virtual STDMETHODIMP _put_ViewBox(CompositionViewBox* value);
};
template<typename X> struct IShapeVisual_adaptor : X {
	union {
		struct : property {
			ptr<CompositionShapeCollection> get() { CompositionShapeCollection* value; hrcheck(enc(&IShapeVisual_adaptor::Shapes)->_get_Shapes(&value)); return from_abi(value); }
			ptr<CompositionShapeCollection> operator()() { return get(); }
			operator ptr<CompositionShapeCollection> () { return get(); }
			ptr<CompositionShapeCollection> operator->() { return get(); }
		} Shapes;
		struct : property {
			ptr<CompositionViewBox> get() { CompositionViewBox* value; hrcheck(enc(&IShapeVisual_adaptor::ViewBox)->_get_ViewBox(&value)); return from_abi(value); }
			ptr<CompositionViewBox> operator()() { return get(); }
			operator ptr<CompositionViewBox> () { return get(); }
			ptr<CompositionViewBox> operator->() { return get(); }
			void put(pptr<CompositionViewBox> value) { hrcheck(enc(&IShapeVisual_adaptor::ViewBox)->_put_ViewBox(value)); }
			void operator=(pptr<CompositionViewBox> value) { put(value); }
			void operator()(pptr<CompositionViewBox> value) { put(value); }
		} ViewBox;
	};
	IShapeVisual_adaptor() {}
};
template<typename X> struct adapt<IShapeVisual, X> : Windows::UI::Composition::IShapeVisual_adaptor<X> { typedef adapt IShapeVisual; };
struct IShapeVisual : IShapeVisual_raw, generate<IShapeVisual> {};

// ISpotLight
struct ISpotLight_raw : IInspectable {
	virtual STDMETHODIMP _get_ConstantAttenuation(float *value);
	virtual STDMETHODIMP _put_ConstantAttenuation(float value);
	virtual STDMETHODIMP _get_CoordinateSpace(Visual* *value);
	virtual STDMETHODIMP _put_CoordinateSpace(Visual* value);
	virtual STDMETHODIMP _get_Direction(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_Direction(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_InnerConeAngle(float *value);
	virtual STDMETHODIMP _put_InnerConeAngle(float value);
	virtual STDMETHODIMP _get_InnerConeAngleInDegrees(float *value);
	virtual STDMETHODIMP _put_InnerConeAngleInDegrees(float value);
	virtual STDMETHODIMP _get_InnerConeColor(Color *value);
	virtual STDMETHODIMP _put_InnerConeColor(Color value);
	virtual STDMETHODIMP _get_LinearAttenuation(float *value);
	virtual STDMETHODIMP _put_LinearAttenuation(float value);
	virtual STDMETHODIMP _get_Offset(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_Offset(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_OuterConeAngle(float *value);
	virtual STDMETHODIMP _put_OuterConeAngle(float value);
	virtual STDMETHODIMP _get_OuterConeAngleInDegrees(float *value);
	virtual STDMETHODIMP _put_OuterConeAngleInDegrees(float value);
	virtual STDMETHODIMP _get_OuterConeColor(Color *value);
	virtual STDMETHODIMP _put_OuterConeColor(Color value);
	virtual STDMETHODIMP _get_QuadraticAttenuation(float *value);
	virtual STDMETHODIMP _put_QuadraticAttenuation(float value);
};
template<typename X> struct ISpotLight_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&ISpotLight_adaptor::ConstantAttenuation)->_get_ConstantAttenuation(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ISpotLight_adaptor::ConstantAttenuation)->_put_ConstantAttenuation(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} ConstantAttenuation;
		struct : property {
			ptr<Visual> get() { Visual* value; hrcheck(enc(&ISpotLight_adaptor::CoordinateSpace)->_get_CoordinateSpace(&value)); return from_abi(value); }
			ptr<Visual> operator()() { return get(); }
			operator ptr<Visual> () { return get(); }
			ptr<Visual> operator->() { return get(); }
			void put(pptr<Visual> value) { hrcheck(enc(&ISpotLight_adaptor::CoordinateSpace)->_put_CoordinateSpace(value)); }
			void operator=(pptr<Visual> value) { put(value); }
			void operator()(pptr<Visual> value) { put(value); }
		} CoordinateSpace;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&ISpotLight_adaptor::Direction)->_get_Direction(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&ISpotLight_adaptor::Direction)->_put_Direction(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} Direction;
		struct : property {
			float get() { float value; hrcheck(enc(&ISpotLight_adaptor::InnerConeAngle)->_get_InnerConeAngle(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ISpotLight_adaptor::InnerConeAngle)->_put_InnerConeAngle(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} InnerConeAngle;
		struct : property {
			float get() { float value; hrcheck(enc(&ISpotLight_adaptor::InnerConeAngleInDegrees)->_get_InnerConeAngleInDegrees(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ISpotLight_adaptor::InnerConeAngleInDegrees)->_put_InnerConeAngleInDegrees(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} InnerConeAngleInDegrees;
		struct : property {
			Color get() { Color value; hrcheck(enc(&ISpotLight_adaptor::InnerConeColor)->_get_InnerConeColor(&value)); return value; }
			Color operator()() { return get(); }
			operator Color () { return get(); }
			void put(const Color& value) { hrcheck(enc(&ISpotLight_adaptor::InnerConeColor)->_put_InnerConeColor(value)); }
			void operator=(const Color& value) { put(value); }
			void operator()(const Color& value) { put(value); }
		} InnerConeColor;
		struct : property {
			float get() { float value; hrcheck(enc(&ISpotLight_adaptor::LinearAttenuation)->_get_LinearAttenuation(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ISpotLight_adaptor::LinearAttenuation)->_put_LinearAttenuation(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} LinearAttenuation;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&ISpotLight_adaptor::Offset)->_get_Offset(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&ISpotLight_adaptor::Offset)->_put_Offset(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} Offset;
		struct : property {
			float get() { float value; hrcheck(enc(&ISpotLight_adaptor::OuterConeAngle)->_get_OuterConeAngle(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ISpotLight_adaptor::OuterConeAngle)->_put_OuterConeAngle(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} OuterConeAngle;
		struct : property {
			float get() { float value; hrcheck(enc(&ISpotLight_adaptor::OuterConeAngleInDegrees)->_get_OuterConeAngleInDegrees(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ISpotLight_adaptor::OuterConeAngleInDegrees)->_put_OuterConeAngleInDegrees(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} OuterConeAngleInDegrees;
		struct : property {
			Color get() { Color value; hrcheck(enc(&ISpotLight_adaptor::OuterConeColor)->_get_OuterConeColor(&value)); return value; }
			Color operator()() { return get(); }
			operator Color () { return get(); }
			void put(const Color& value) { hrcheck(enc(&ISpotLight_adaptor::OuterConeColor)->_put_OuterConeColor(value)); }
			void operator=(const Color& value) { put(value); }
			void operator()(const Color& value) { put(value); }
		} OuterConeColor;
		struct : property {
			float get() { float value; hrcheck(enc(&ISpotLight_adaptor::QuadraticAttenuation)->_get_QuadraticAttenuation(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ISpotLight_adaptor::QuadraticAttenuation)->_put_QuadraticAttenuation(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} QuadraticAttenuation;
	};
	ISpotLight_adaptor() {}
};
template<typename X> struct adapt<ISpotLight, X> : Windows::UI::Composition::ISpotLight_adaptor<X> { typedef adapt ISpotLight; };
struct ISpotLight : ISpotLight_raw, generate<ISpotLight> {};

// ISpotLight2
struct ISpotLight2_raw : IInspectable {
	virtual STDMETHODIMP _get_InnerConeIntensity(float *value);
	virtual STDMETHODIMP _put_InnerConeIntensity(float value);
	virtual STDMETHODIMP _get_OuterConeIntensity(float *value);
	virtual STDMETHODIMP _put_OuterConeIntensity(float value);
};
template<typename X> struct ISpotLight2_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&ISpotLight2_adaptor::InnerConeIntensity)->_get_InnerConeIntensity(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ISpotLight2_adaptor::InnerConeIntensity)->_put_InnerConeIntensity(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} InnerConeIntensity;
		struct : property {
			float get() { float value; hrcheck(enc(&ISpotLight2_adaptor::OuterConeIntensity)->_get_OuterConeIntensity(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ISpotLight2_adaptor::OuterConeIntensity)->_put_OuterConeIntensity(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} OuterConeIntensity;
	};
	ISpotLight2_adaptor() {}
};
template<typename X> struct adapt<ISpotLight2, X> : Windows::UI::Composition::ISpotLight2_adaptor<X> { typedef adapt ISpotLight2; };
struct ISpotLight2 : ISpotLight2_raw, generate<ISpotLight2> {};

// ISpotLight3
struct ISpotLight3_raw : IInspectable {
	virtual STDMETHODIMP _get_MinAttenuationCutoff(float *value);
	virtual STDMETHODIMP _put_MinAttenuationCutoff(float value);
	virtual STDMETHODIMP _get_MaxAttenuationCutoff(float *value);
	virtual STDMETHODIMP _put_MaxAttenuationCutoff(float value);
};
template<typename X> struct ISpotLight3_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&ISpotLight3_adaptor::MaxAttenuationCutoff)->_get_MaxAttenuationCutoff(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ISpotLight3_adaptor::MaxAttenuationCutoff)->_put_MaxAttenuationCutoff(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} MaxAttenuationCutoff;
		struct : property {
			float get() { float value; hrcheck(enc(&ISpotLight3_adaptor::MinAttenuationCutoff)->_get_MinAttenuationCutoff(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ISpotLight3_adaptor::MinAttenuationCutoff)->_put_MinAttenuationCutoff(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} MinAttenuationCutoff;
	};
	ISpotLight3_adaptor() {}
};
template<typename X> struct adapt<ISpotLight3, X> : Windows::UI::Composition::ISpotLight3_adaptor<X> { typedef adapt ISpotLight3; };
struct ISpotLight3 : ISpotLight3_raw, generate<ISpotLight3> {};

// ISpringScalarNaturalMotionAnimation
struct ISpringScalarNaturalMotionAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_DampingRatio(float *value);
	virtual STDMETHODIMP _put_DampingRatio(float value);
	virtual STDMETHODIMP _get_Period(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_Period(Foundation::TimeSpan value);
};
template<typename X> struct ISpringScalarNaturalMotionAnimation_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&ISpringScalarNaturalMotionAnimation_adaptor::DampingRatio)->_get_DampingRatio(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ISpringScalarNaturalMotionAnimation_adaptor::DampingRatio)->_put_DampingRatio(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} DampingRatio;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ISpringScalarNaturalMotionAnimation_adaptor::Period)->_get_Period(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ISpringScalarNaturalMotionAnimation_adaptor::Period)->_put_Period(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Period;
	};
	ISpringScalarNaturalMotionAnimation_adaptor() {}
};
template<typename X> struct adapt<ISpringScalarNaturalMotionAnimation, X> : Windows::UI::Composition::ISpringScalarNaturalMotionAnimation_adaptor<X> { typedef adapt ISpringScalarNaturalMotionAnimation; };
struct ISpringScalarNaturalMotionAnimation : ISpringScalarNaturalMotionAnimation_raw, generate<ISpringScalarNaturalMotionAnimation> {};

// ISpringVector2NaturalMotionAnimation
struct ISpringVector2NaturalMotionAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_DampingRatio(float *value);
	virtual STDMETHODIMP _put_DampingRatio(float value);
	virtual STDMETHODIMP _get_Period(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_Period(Foundation::TimeSpan value);
};
template<typename X> struct ISpringVector2NaturalMotionAnimation_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&ISpringVector2NaturalMotionAnimation_adaptor::DampingRatio)->_get_DampingRatio(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ISpringVector2NaturalMotionAnimation_adaptor::DampingRatio)->_put_DampingRatio(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} DampingRatio;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ISpringVector2NaturalMotionAnimation_adaptor::Period)->_get_Period(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ISpringVector2NaturalMotionAnimation_adaptor::Period)->_put_Period(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Period;
	};
	ISpringVector2NaturalMotionAnimation_adaptor() {}
};
template<typename X> struct adapt<ISpringVector2NaturalMotionAnimation, X> : Windows::UI::Composition::ISpringVector2NaturalMotionAnimation_adaptor<X> { typedef adapt ISpringVector2NaturalMotionAnimation; };
struct ISpringVector2NaturalMotionAnimation : ISpringVector2NaturalMotionAnimation_raw, generate<ISpringVector2NaturalMotionAnimation> {};

// ISpringVector3NaturalMotionAnimation
struct ISpringVector3NaturalMotionAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_DampingRatio(float *value);
	virtual STDMETHODIMP _put_DampingRatio(float value);
	virtual STDMETHODIMP _get_Period(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_Period(Foundation::TimeSpan value);
};
template<typename X> struct ISpringVector3NaturalMotionAnimation_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&ISpringVector3NaturalMotionAnimation_adaptor::DampingRatio)->_get_DampingRatio(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ISpringVector3NaturalMotionAnimation_adaptor::DampingRatio)->_put_DampingRatio(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} DampingRatio;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ISpringVector3NaturalMotionAnimation_adaptor::Period)->_get_Period(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ISpringVector3NaturalMotionAnimation_adaptor::Period)->_put_Period(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Period;
	};
	ISpringVector3NaturalMotionAnimation_adaptor() {}
};
template<typename X> struct adapt<ISpringVector3NaturalMotionAnimation, X> : Windows::UI::Composition::ISpringVector3NaturalMotionAnimation_adaptor<X> { typedef adapt ISpringVector3NaturalMotionAnimation; };
struct ISpringVector3NaturalMotionAnimation : ISpringVector3NaturalMotionAnimation_raw, generate<ISpringVector3NaturalMotionAnimation> {};

// ISpriteVisual
struct ISpriteVisual_raw : IInspectable {
	virtual STDMETHODIMP _get_Brush(CompositionBrush* *value);
	virtual STDMETHODIMP _put_Brush(CompositionBrush* value);
};
template<typename X> struct ISpriteVisual_adaptor : X {
	union {
		struct : property {
			ptr<CompositionBrush> get() { CompositionBrush* value; hrcheck(enc(&ISpriteVisual_adaptor::Brush)->_get_Brush(&value)); return from_abi(value); }
			ptr<CompositionBrush> operator()() { return get(); }
			operator ptr<CompositionBrush> () { return get(); }
			ptr<CompositionBrush> operator->() { return get(); }
			void put(pptr<CompositionBrush> value) { hrcheck(enc(&ISpriteVisual_adaptor::Brush)->_put_Brush(value)); }
			void operator=(pptr<CompositionBrush> value) { put(value); }
			void operator()(pptr<CompositionBrush> value) { put(value); }
		} Brush;
	};
	ISpriteVisual_adaptor() {}
};
template<typename X> struct adapt<ISpriteVisual, X> : Windows::UI::Composition::ISpriteVisual_adaptor<X> { typedef adapt ISpriteVisual; };
struct ISpriteVisual : ISpriteVisual_raw, generate<ISpriteVisual> {};

// ISpriteVisual2
struct ISpriteVisual2_raw : IInspectable {
	virtual STDMETHODIMP _get_Shadow(CompositionShadow* *value);
	virtual STDMETHODIMP _put_Shadow(CompositionShadow* value);
};
template<typename X> struct ISpriteVisual2_adaptor : X {
	union {
		struct : property {
			ptr<CompositionShadow> get() { CompositionShadow* value; hrcheck(enc(&ISpriteVisual2_adaptor::Shadow)->_get_Shadow(&value)); return from_abi(value); }
			ptr<CompositionShadow> operator()() { return get(); }
			operator ptr<CompositionShadow> () { return get(); }
			ptr<CompositionShadow> operator->() { return get(); }
			void put(pptr<CompositionShadow> value) { hrcheck(enc(&ISpriteVisual2_adaptor::Shadow)->_put_Shadow(value)); }
			void operator=(pptr<CompositionShadow> value) { put(value); }
			void operator()(pptr<CompositionShadow> value) { put(value); }
		} Shadow;
	};
	ISpriteVisual2_adaptor() {}
};
template<typename X> struct adapt<ISpriteVisual2, X> : Windows::UI::Composition::ISpriteVisual2_adaptor<X> { typedef adapt ISpriteVisual2; };
struct ISpriteVisual2 : ISpriteVisual2_raw, generate<ISpriteVisual2> {};

// IStepEasingFunction
struct IStepEasingFunction_raw : IInspectable {
	virtual STDMETHODIMP _get_FinalStep(int *value);
	virtual STDMETHODIMP _put_FinalStep(int value);
	virtual STDMETHODIMP _get_InitialStep(int *value);
	virtual STDMETHODIMP _put_InitialStep(int value);
	virtual STDMETHODIMP _get_IsFinalStepSingleFrame(bool *value);
	virtual STDMETHODIMP _put_IsFinalStepSingleFrame(bool value);
	virtual STDMETHODIMP _get_IsInitialStepSingleFrame(bool *value);
	virtual STDMETHODIMP _put_IsInitialStepSingleFrame(bool value);
	virtual STDMETHODIMP _get_StepCount(int *value);
	virtual STDMETHODIMP _put_StepCount(int value);
};
template<typename X> struct IStepEasingFunction_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IStepEasingFunction_adaptor::FinalStep)->_get_FinalStep(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IStepEasingFunction_adaptor::FinalStep)->_put_FinalStep(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} FinalStep;
		struct : property {
			int get() { int value; hrcheck(enc(&IStepEasingFunction_adaptor::InitialStep)->_get_InitialStep(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IStepEasingFunction_adaptor::InitialStep)->_put_InitialStep(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} InitialStep;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStepEasingFunction_adaptor::IsFinalStepSingleFrame)->_get_IsFinalStepSingleFrame(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IStepEasingFunction_adaptor::IsFinalStepSingleFrame)->_put_IsFinalStepSingleFrame(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsFinalStepSingleFrame;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStepEasingFunction_adaptor::IsInitialStepSingleFrame)->_get_IsInitialStepSingleFrame(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IStepEasingFunction_adaptor::IsInitialStepSingleFrame)->_put_IsInitialStepSingleFrame(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsInitialStepSingleFrame;
		struct : property {
			int get() { int value; hrcheck(enc(&IStepEasingFunction_adaptor::StepCount)->_get_StepCount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IStepEasingFunction_adaptor::StepCount)->_put_StepCount(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} StepCount;
	};
	IStepEasingFunction_adaptor() {}
};
template<typename X> struct adapt<IStepEasingFunction, X> : Windows::UI::Composition::IStepEasingFunction_adaptor<X> { typedef adapt IStepEasingFunction; };
struct IStepEasingFunction : IStepEasingFunction_raw, generate<IStepEasingFunction> {};

// StepEasingFunction
template<typename X> struct statics<StepEasingFunction, X> : X {
	typedef typename X::root_type StepEasingFunction;
};
struct StepEasingFunction : generate<StepEasingFunction> {};

// IVector2KeyFrameAnimation
struct IVector2KeyFrameAnimation_raw : IInspectable {
	virtual STDMETHODIMP _InsertKeyFrame(float normalizedProgressKey, Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _InsertKeyFrameWithEasingFunction(float normalizedProgressKey, Foundation::Numerics::Vector2 value, CompositionEasingFunction* easingFunction);
};
template<typename X> struct IVector2KeyFrameAnimation_adaptor : X {
	void InsertKeyFrame(float normalizedProgressKey, const Foundation::Numerics::Vector2& value) { hrcheck(X::get()->_InsertKeyFrame(normalizedProgressKey, value)); }
	void InsertKeyFrame(float normalizedProgressKey, const Foundation::Numerics::Vector2& value, pptr<CompositionEasingFunction> easingFunction) { hrcheck(X::get()->_InsertKeyFrameWithEasingFunction(normalizedProgressKey, value, easingFunction)); }
};
template<typename X> struct adapt<IVector2KeyFrameAnimation, X> : Windows::UI::Composition::IVector2KeyFrameAnimation_adaptor<X> { typedef adapt IVector2KeyFrameAnimation; };
struct IVector2KeyFrameAnimation : IVector2KeyFrameAnimation_raw, generate<IVector2KeyFrameAnimation> {};

// IVector2NaturalMotionAnimation
struct IVector2NaturalMotionAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_FinalValue(Foundation::IReference<Foundation::Numerics::Vector2>* *value);
	virtual STDMETHODIMP _put_FinalValue(Foundation::IReference<Foundation::Numerics::Vector2>* value);
	virtual STDMETHODIMP _get_InitialValue(Foundation::IReference<Foundation::Numerics::Vector2>* *value);
	virtual STDMETHODIMP _put_InitialValue(Foundation::IReference<Foundation::Numerics::Vector2>* value);
	virtual STDMETHODIMP _get_InitialVelocity(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_InitialVelocity(Foundation::Numerics::Vector2 value);
};
template<typename X> struct IVector2NaturalMotionAnimation_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Foundation::Numerics::Vector2>> get() { Foundation::IReference<Foundation::Numerics::Vector2>* value; hrcheck(enc(&IVector2NaturalMotionAnimation_adaptor::FinalValue)->_get_FinalValue(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::Numerics::Vector2>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::Numerics::Vector2>> () { return get(); }
			ptr<Foundation::IReference<Foundation::Numerics::Vector2>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::Numerics::Vector2>> value) { hrcheck(enc(&IVector2NaturalMotionAnimation_adaptor::FinalValue)->_put_FinalValue(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::Numerics::Vector2>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::Numerics::Vector2>> value) { put(to_abi(value)); }
		} FinalValue;
		struct : property {
			ptr<Foundation::IReference<Foundation::Numerics::Vector2>> get() { Foundation::IReference<Foundation::Numerics::Vector2>* value; hrcheck(enc(&IVector2NaturalMotionAnimation_adaptor::InitialValue)->_get_InitialValue(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::Numerics::Vector2>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::Numerics::Vector2>> () { return get(); }
			ptr<Foundation::IReference<Foundation::Numerics::Vector2>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::Numerics::Vector2>> value) { hrcheck(enc(&IVector2NaturalMotionAnimation_adaptor::InitialValue)->_put_InitialValue(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::Numerics::Vector2>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::Numerics::Vector2>> value) { put(to_abi(value)); }
		} InitialValue;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&IVector2NaturalMotionAnimation_adaptor::InitialVelocity)->_get_InitialVelocity(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&IVector2NaturalMotionAnimation_adaptor::InitialVelocity)->_put_InitialVelocity(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} InitialVelocity;
	};
	IVector2NaturalMotionAnimation_adaptor() {}
};
template<typename X> struct adapt<IVector2NaturalMotionAnimation, X> : Windows::UI::Composition::IVector2NaturalMotionAnimation_adaptor<X> { typedef adapt IVector2NaturalMotionAnimation; };
struct IVector2NaturalMotionAnimation : IVector2NaturalMotionAnimation_raw, generate<IVector2NaturalMotionAnimation> {};

// IVector3NaturalMotionAnimation
struct IVector3NaturalMotionAnimation_raw : IInspectable {
	virtual STDMETHODIMP _get_FinalValue(Foundation::IReference<Foundation::Numerics::Vector3>* *value);
	virtual STDMETHODIMP _put_FinalValue(Foundation::IReference<Foundation::Numerics::Vector3>* value);
	virtual STDMETHODIMP _get_InitialValue(Foundation::IReference<Foundation::Numerics::Vector3>* *value);
	virtual STDMETHODIMP _put_InitialValue(Foundation::IReference<Foundation::Numerics::Vector3>* value);
	virtual STDMETHODIMP _get_InitialVelocity(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_InitialVelocity(Foundation::Numerics::Vector3 value);
};
template<typename X> struct IVector3NaturalMotionAnimation_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Foundation::Numerics::Vector3>> get() { Foundation::IReference<Foundation::Numerics::Vector3>* value; hrcheck(enc(&IVector3NaturalMotionAnimation_adaptor::FinalValue)->_get_FinalValue(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::Numerics::Vector3>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::Numerics::Vector3>> () { return get(); }
			ptr<Foundation::IReference<Foundation::Numerics::Vector3>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::Numerics::Vector3>> value) { hrcheck(enc(&IVector3NaturalMotionAnimation_adaptor::FinalValue)->_put_FinalValue(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::Numerics::Vector3>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::Numerics::Vector3>> value) { put(to_abi(value)); }
		} FinalValue;
		struct : property {
			ptr<Foundation::IReference<Foundation::Numerics::Vector3>> get() { Foundation::IReference<Foundation::Numerics::Vector3>* value; hrcheck(enc(&IVector3NaturalMotionAnimation_adaptor::InitialValue)->_get_InitialValue(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::Numerics::Vector3>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::Numerics::Vector3>> () { return get(); }
			ptr<Foundation::IReference<Foundation::Numerics::Vector3>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::Numerics::Vector3>> value) { hrcheck(enc(&IVector3NaturalMotionAnimation_adaptor::InitialValue)->_put_InitialValue(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::Numerics::Vector3>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::Numerics::Vector3>> value) { put(to_abi(value)); }
		} InitialValue;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IVector3NaturalMotionAnimation_adaptor::InitialVelocity)->_get_InitialVelocity(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IVector3NaturalMotionAnimation_adaptor::InitialVelocity)->_put_InitialVelocity(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} InitialVelocity;
	};
	IVector3NaturalMotionAnimation_adaptor() {}
};
template<typename X> struct adapt<IVector3NaturalMotionAnimation, X> : Windows::UI::Composition::IVector3NaturalMotionAnimation_adaptor<X> { typedef adapt IVector3NaturalMotionAnimation; };
struct IVector3NaturalMotionAnimation : IVector3NaturalMotionAnimation_raw, generate<IVector3NaturalMotionAnimation> {};

// IVector3KeyFrameAnimation
struct IVector3KeyFrameAnimation_raw : IInspectable {
	virtual STDMETHODIMP _InsertKeyFrame(float normalizedProgressKey, Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _InsertKeyFrameWithEasingFunction(float normalizedProgressKey, Foundation::Numerics::Vector3 value, CompositionEasingFunction* easingFunction);
};
template<typename X> struct IVector3KeyFrameAnimation_adaptor : X {
	void InsertKeyFrame(float normalizedProgressKey, const Foundation::Numerics::Vector3& value) { hrcheck(X::get()->_InsertKeyFrame(normalizedProgressKey, value)); }
	void InsertKeyFrame(float normalizedProgressKey, const Foundation::Numerics::Vector3& value, pptr<CompositionEasingFunction> easingFunction) { hrcheck(X::get()->_InsertKeyFrameWithEasingFunction(normalizedProgressKey, value, easingFunction)); }
};
template<typename X> struct adapt<IVector3KeyFrameAnimation, X> : Windows::UI::Composition::IVector3KeyFrameAnimation_adaptor<X> { typedef adapt IVector3KeyFrameAnimation; };
struct IVector3KeyFrameAnimation : IVector3KeyFrameAnimation_raw, generate<IVector3KeyFrameAnimation> {};

// IVector4KeyFrameAnimation
struct IVector4KeyFrameAnimation_raw : IInspectable {
	virtual STDMETHODIMP _InsertKeyFrame(float normalizedProgressKey, Foundation::Numerics::Vector4 value);
	virtual STDMETHODIMP _InsertKeyFrameWithEasingFunction(float normalizedProgressKey, Foundation::Numerics::Vector4 value, CompositionEasingFunction* easingFunction);
};
template<typename X> struct IVector4KeyFrameAnimation_adaptor : X {
	void InsertKeyFrame(float normalizedProgressKey, const Foundation::Numerics::Vector4& value) { hrcheck(X::get()->_InsertKeyFrame(normalizedProgressKey, value)); }
	void InsertKeyFrame(float normalizedProgressKey, const Foundation::Numerics::Vector4& value, pptr<CompositionEasingFunction> easingFunction) { hrcheck(X::get()->_InsertKeyFrameWithEasingFunction(normalizedProgressKey, value, easingFunction)); }
};
template<typename X> struct adapt<IVector4KeyFrameAnimation, X> : Windows::UI::Composition::IVector4KeyFrameAnimation_adaptor<X> { typedef adapt IVector4KeyFrameAnimation; };
struct IVector4KeyFrameAnimation : IVector4KeyFrameAnimation_raw, generate<IVector4KeyFrameAnimation> {};

// IVisual
struct IVisual_raw : IInspectable {
	virtual STDMETHODIMP _get_AnchorPoint(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_AnchorPoint(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_BackfaceVisibility(CompositionBackfaceVisibility *value);
	virtual STDMETHODIMP _put_BackfaceVisibility(CompositionBackfaceVisibility value);
	virtual STDMETHODIMP _get_BorderMode(CompositionBorderMode *value);
	virtual STDMETHODIMP _put_BorderMode(CompositionBorderMode value);
	virtual STDMETHODIMP _get_CenterPoint(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_CenterPoint(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_Clip(CompositionClip* *value);
	virtual STDMETHODIMP _put_Clip(CompositionClip* value);
	virtual STDMETHODIMP _get_CompositeMode(CompositionCompositeMode *value);
	virtual STDMETHODIMP _put_CompositeMode(CompositionCompositeMode value);
	virtual STDMETHODIMP _get_IsVisible(bool *value);
	virtual STDMETHODIMP _put_IsVisible(bool value);
	virtual STDMETHODIMP _get_Offset(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_Offset(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_Opacity(float *value);
	virtual STDMETHODIMP _put_Opacity(float value);
	virtual STDMETHODIMP _get_Orientation(Foundation::Numerics::Quaternion *value);
	virtual STDMETHODIMP _put_Orientation(Foundation::Numerics::Quaternion value);
	virtual STDMETHODIMP _get_Parent(ContainerVisual* *value);
	virtual STDMETHODIMP _get_RotationAngle(float *value);
	virtual STDMETHODIMP _put_RotationAngle(float value);
	virtual STDMETHODIMP _get_RotationAngleInDegrees(float *value);
	virtual STDMETHODIMP _put_RotationAngleInDegrees(float value);
	virtual STDMETHODIMP _get_RotationAxis(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_RotationAxis(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_Scale(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_Scale(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_Size(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_Size(Foundation::Numerics::Vector2 value);
	virtual STDMETHODIMP _get_TransformMatrix(Foundation::Numerics::Matrix4x4 *value);
	virtual STDMETHODIMP _put_TransformMatrix(Foundation::Numerics::Matrix4x4 value);
};
template<typename X> struct IVisual_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&IVisual_adaptor::AnchorPoint)->_get_AnchorPoint(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&IVisual_adaptor::AnchorPoint)->_put_AnchorPoint(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} AnchorPoint;
		struct : property {
			CompositionBackfaceVisibility get() { CompositionBackfaceVisibility value; hrcheck(enc(&IVisual_adaptor::BackfaceVisibility)->_get_BackfaceVisibility(&value)); return value; }
			CompositionBackfaceVisibility operator()() { return get(); }
			operator CompositionBackfaceVisibility () { return get(); }
			void put(CompositionBackfaceVisibility value) { hrcheck(enc(&IVisual_adaptor::BackfaceVisibility)->_put_BackfaceVisibility(value)); }
			void operator=(CompositionBackfaceVisibility value) { put(value); }
			void operator()(CompositionBackfaceVisibility value) { put(value); }
		} BackfaceVisibility;
		struct : property {
			CompositionBorderMode get() { CompositionBorderMode value; hrcheck(enc(&IVisual_adaptor::BorderMode)->_get_BorderMode(&value)); return value; }
			CompositionBorderMode operator()() { return get(); }
			operator CompositionBorderMode () { return get(); }
			void put(CompositionBorderMode value) { hrcheck(enc(&IVisual_adaptor::BorderMode)->_put_BorderMode(value)); }
			void operator=(CompositionBorderMode value) { put(value); }
			void operator()(CompositionBorderMode value) { put(value); }
		} BorderMode;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IVisual_adaptor::CenterPoint)->_get_CenterPoint(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IVisual_adaptor::CenterPoint)->_put_CenterPoint(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} CenterPoint;
		struct : property {
			ptr<CompositionClip> get() { CompositionClip* value; hrcheck(enc(&IVisual_adaptor::Clip)->_get_Clip(&value)); return from_abi(value); }
			ptr<CompositionClip> operator()() { return get(); }
			operator ptr<CompositionClip> () { return get(); }
			ptr<CompositionClip> operator->() { return get(); }
			void put(pptr<CompositionClip> value) { hrcheck(enc(&IVisual_adaptor::Clip)->_put_Clip(value)); }
			void operator=(pptr<CompositionClip> value) { put(value); }
			void operator()(pptr<CompositionClip> value) { put(value); }
		} Clip;
		struct : property {
			CompositionCompositeMode get() { CompositionCompositeMode value; hrcheck(enc(&IVisual_adaptor::CompositeMode)->_get_CompositeMode(&value)); return value; }
			CompositionCompositeMode operator()() { return get(); }
			operator CompositionCompositeMode () { return get(); }
			void put(CompositionCompositeMode value) { hrcheck(enc(&IVisual_adaptor::CompositeMode)->_put_CompositeMode(value)); }
			void operator=(CompositionCompositeMode value) { put(value); }
			void operator()(CompositionCompositeMode value) { put(value); }
		} CompositeMode;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVisual_adaptor::IsVisible)->_get_IsVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVisual_adaptor::IsVisible)->_put_IsVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsVisible;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IVisual_adaptor::Offset)->_get_Offset(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IVisual_adaptor::Offset)->_put_Offset(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} Offset;
		struct : property {
			float get() { float value; hrcheck(enc(&IVisual_adaptor::Opacity)->_get_Opacity(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IVisual_adaptor::Opacity)->_put_Opacity(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Opacity;
		struct : property {
			Foundation::Numerics::Quaternion get() { Foundation::Numerics::Quaternion value; hrcheck(enc(&IVisual_adaptor::Orientation)->_get_Orientation(&value)); return value; }
			Foundation::Numerics::Quaternion operator()() { return get(); }
			operator Foundation::Numerics::Quaternion () { return get(); }
			void put(const Foundation::Numerics::Quaternion& value) { hrcheck(enc(&IVisual_adaptor::Orientation)->_put_Orientation(value)); }
			void operator=(const Foundation::Numerics::Quaternion& value) { put(value); }
			void operator()(const Foundation::Numerics::Quaternion& value) { put(value); }
		} Orientation;
		struct : property {
			ptr<ContainerVisual> get() { ContainerVisual* value; hrcheck(enc(&IVisual_adaptor::Parent)->_get_Parent(&value)); return from_abi(value); }
			ptr<ContainerVisual> operator()() { return get(); }
			operator ptr<ContainerVisual> () { return get(); }
			ptr<ContainerVisual> operator->() { return get(); }
		} Parent;
		struct : property {
			float get() { float value; hrcheck(enc(&IVisual_adaptor::RotationAngle)->_get_RotationAngle(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IVisual_adaptor::RotationAngle)->_put_RotationAngle(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} RotationAngle;
		struct : property {
			float get() { float value; hrcheck(enc(&IVisual_adaptor::RotationAngleInDegrees)->_get_RotationAngleInDegrees(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IVisual_adaptor::RotationAngleInDegrees)->_put_RotationAngleInDegrees(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} RotationAngleInDegrees;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IVisual_adaptor::RotationAxis)->_get_RotationAxis(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IVisual_adaptor::RotationAxis)->_put_RotationAxis(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} RotationAxis;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IVisual_adaptor::Scale)->_get_Scale(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IVisual_adaptor::Scale)->_put_Scale(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} Scale;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&IVisual_adaptor::Size)->_get_Size(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&IVisual_adaptor::Size)->_put_Size(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} Size;
		struct : property {
			Foundation::Numerics::Matrix4x4 get() { Foundation::Numerics::Matrix4x4 value; hrcheck(enc(&IVisual_adaptor::TransformMatrix)->_get_TransformMatrix(&value)); return value; }
			Foundation::Numerics::Matrix4x4 operator()() { return get(); }
			operator Foundation::Numerics::Matrix4x4 () { return get(); }
			void put(const Foundation::Numerics::Matrix4x4& value) { hrcheck(enc(&IVisual_adaptor::TransformMatrix)->_put_TransformMatrix(value)); }
			void operator=(const Foundation::Numerics::Matrix4x4& value) { put(value); }
			void operator()(const Foundation::Numerics::Matrix4x4& value) { put(value); }
		} TransformMatrix;
	};
	IVisual_adaptor() {}
};
template<typename X> struct adapt<IVisual, X> : Windows::UI::Composition::IVisual_adaptor<X> { typedef adapt IVisual; };
struct IVisual : IVisual_raw, generate<IVisual> {};

// ICompositionClipFactory
struct ICompositionClipFactory : IInspectable, generate<ICompositionClipFactory> {};

// CompositionClip
template<typename X> struct statics<CompositionClip, X> : X {
	typedef typename X::root_type CompositionClip;
};
struct CompositionClip : generate<CompositionClip> {};

// InsetClip
template<typename X> struct statics<InsetClip, X> : X {
	typedef typename X::root_type InsetClip;
};
struct InsetClip : generate<InsetClip> {};

// IVisual2
struct IVisual2_raw : IInspectable {
	virtual STDMETHODIMP _get_ParentForTransform(Visual* *value);
	virtual STDMETHODIMP _put_ParentForTransform(Visual* value);
	virtual STDMETHODIMP _get_RelativeOffsetAdjustment(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_RelativeOffsetAdjustment(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_RelativeSizeAdjustment(Foundation::Numerics::Vector2 *value);
	virtual STDMETHODIMP _put_RelativeSizeAdjustment(Foundation::Numerics::Vector2 value);
};
template<typename X> struct IVisual2_adaptor : X {
	union {
		struct : property {
			ptr<Visual> get() { Visual* value; hrcheck(enc(&IVisual2_adaptor::ParentForTransform)->_get_ParentForTransform(&value)); return from_abi(value); }
			ptr<Visual> operator()() { return get(); }
			operator ptr<Visual> () { return get(); }
			ptr<Visual> operator->() { return get(); }
			void put(pptr<Visual> value) { hrcheck(enc(&IVisual2_adaptor::ParentForTransform)->_put_ParentForTransform(value)); }
			void operator=(pptr<Visual> value) { put(value); }
			void operator()(pptr<Visual> value) { put(value); }
		} ParentForTransform;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&IVisual2_adaptor::RelativeOffsetAdjustment)->_get_RelativeOffsetAdjustment(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&IVisual2_adaptor::RelativeOffsetAdjustment)->_put_RelativeOffsetAdjustment(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} RelativeOffsetAdjustment;
		struct : property {
			Foundation::Numerics::Vector2 get() { Foundation::Numerics::Vector2 value; hrcheck(enc(&IVisual2_adaptor::RelativeSizeAdjustment)->_get_RelativeSizeAdjustment(&value)); return value; }
			Foundation::Numerics::Vector2 operator()() { return get(); }
			operator Foundation::Numerics::Vector2 () { return get(); }
			void put(const Foundation::Numerics::Vector2& value) { hrcheck(enc(&IVisual2_adaptor::RelativeSizeAdjustment)->_put_RelativeSizeAdjustment(value)); }
			void operator=(const Foundation::Numerics::Vector2& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector2& value) { put(value); }
		} RelativeSizeAdjustment;
	};
	IVisual2_adaptor() {}
};
template<typename X> struct adapt<IVisual2, X> : Windows::UI::Composition::IVisual2_adaptor<X> { typedef adapt IVisual2; };
struct IVisual2 : IVisual2_raw, generate<IVisual2> {};

// IVisualFactory
struct IVisualFactory : IInspectable, generate<IVisualFactory> {};

// Visual
template<typename X> struct statics<Visual, X> : X {
	typedef typename X::root_type Visual;
};
struct Visual : generate<Visual> {};

// IVisualCollection
struct IVisualCollection_raw : IInspectable {
	virtual STDMETHODIMP _get_Count(int *value);
	virtual STDMETHODIMP _InsertAbove(Visual* newChild, Visual* sibling);
	virtual STDMETHODIMP _InsertAtBottom(Visual* newChild);
	virtual STDMETHODIMP _InsertAtTop(Visual* newChild);
	virtual STDMETHODIMP _InsertBelow(Visual* newChild, Visual* sibling);
	virtual STDMETHODIMP _Remove(Visual* child);
	virtual STDMETHODIMP _RemoveAll();
};
template<typename X> struct IVisualCollection_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IVisualCollection_adaptor::Count)->_get_Count(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} Count;
	};
	void InsertAbove(pptr<Visual> newChild, pptr<Visual> sibling) { hrcheck(X::get()->_InsertAbove(newChild, sibling)); }
	void InsertAtBottom(pptr<Visual> newChild) { hrcheck(X::get()->_InsertAtBottom(newChild)); }
	void InsertAtTop(pptr<Visual> newChild) { hrcheck(X::get()->_InsertAtTop(newChild)); }
	void InsertBelow(pptr<Visual> newChild, pptr<Visual> sibling) { hrcheck(X::get()->_InsertBelow(newChild, sibling)); }
	void Remove(pptr<Visual> child) { hrcheck(X::get()->_Remove(child)); }
	void RemoveAll() { hrcheck(X::get()->_RemoveAll()); }
	IVisualCollection_adaptor() {}
};
template<typename X> struct adapt<IVisualCollection, X> : Windows::UI::Composition::IVisualCollection_adaptor<X> { typedef adapt IVisualCollection; };
struct IVisualCollection : IVisualCollection_raw, generate<IVisualCollection> {};

// VisualCollection
template<typename X> struct statics<VisualCollection, X> : X {
	typedef typename X::root_type VisualCollection;
};
struct VisualCollection : generate<VisualCollection> {};

// IVisualUnorderedCollection
struct IVisualUnorderedCollection_raw : IInspectable {
	virtual STDMETHODIMP _get_Count(int *value);
	virtual STDMETHODIMP _Add(Visual* newVisual);
	virtual STDMETHODIMP _Remove(Visual* visual);
	virtual STDMETHODIMP _RemoveAll();
};
template<typename X> struct IVisualUnorderedCollection_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IVisualUnorderedCollection_adaptor::Count)->_get_Count(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} Count;
	};
	void Add(pptr<Visual> newVisual) { hrcheck(X::get()->_Add(newVisual)); }
	void Remove(pptr<Visual> visual) { hrcheck(X::get()->_Remove(visual)); }
	void RemoveAll() { hrcheck(X::get()->_RemoveAll()); }
	IVisualUnorderedCollection_adaptor() {}
};
template<typename X> struct adapt<IVisualUnorderedCollection, X> : Windows::UI::Composition::IVisualUnorderedCollection_adaptor<X> { typedef adapt IVisualUnorderedCollection; };
struct IVisualUnorderedCollection : IVisualUnorderedCollection_raw, generate<IVisualUnorderedCollection> {};

// VisualUnorderedCollection
template<typename X> struct statics<VisualUnorderedCollection, X> : X {
	typedef typename X::root_type VisualUnorderedCollection;
};
struct VisualUnorderedCollection : generate<VisualUnorderedCollection> {};

// ExpressionAnimation
template<typename X> struct statics<ExpressionAnimation, X> : X {
	typedef typename X::root_type ExpressionAnimation;
};
struct ExpressionAnimation : generate<ExpressionAnimation> {};

// IContainerVisualFactory
struct IContainerVisualFactory : IInspectable, generate<IContainerVisualFactory> {};

// ContainerVisual
template<typename X> struct statics<ContainerVisual, X> : X {
	typedef typename X::root_type ContainerVisual;
};
struct ContainerVisual : generate<ContainerVisual> {};

// SpriteVisual
template<typename X> struct statics<SpriteVisual, X> : X {
	typedef typename X::root_type SpriteVisual;
};
struct SpriteVisual : generate<SpriteVisual> {};

// LayerVisual
template<typename X> struct statics<LayerVisual, X> : X {
	typedef typename X::root_type LayerVisual;
};
struct LayerVisual : generate<LayerVisual> {};

// ShapeVisual
template<typename X> struct statics<ShapeVisual, X> : X {
	typedef typename X::root_type ShapeVisual;
};
struct ShapeVisual : generate<ShapeVisual> {};

// ICompositionLightFactory
struct ICompositionLightFactory : IInspectable, generate<ICompositionLightFactory> {};

// CompositionLight
template<typename X> struct statics<CompositionLight, X> : X {
	typedef typename X::root_type CompositionLight;
};
struct CompositionLight : generate<CompositionLight> {};

// AmbientLight
template<typename X> struct statics<AmbientLight, X> : X {
	typedef typename X::root_type AmbientLight;
};
struct AmbientLight : generate<AmbientLight> {};

// DistantLight
template<typename X> struct statics<DistantLight, X> : X {
	typedef typename X::root_type DistantLight;
};
struct DistantLight : generate<DistantLight> {};

// PointLight
template<typename X> struct statics<PointLight, X> : X {
	typedef typename X::root_type PointLight;
};
struct PointLight : generate<PointLight> {};

// SpotLight
template<typename X> struct statics<SpotLight, X> : X {
	typedef typename X::root_type SpotLight;
};
struct SpotLight : generate<SpotLight> {};

// ICompositionGradientBrushFactory
struct ICompositionGradientBrushFactory : IInspectable, generate<ICompositionGradientBrushFactory> {};

// CompositionGradientBrush
template<typename X> struct statics<CompositionGradientBrush, X> : X {
	typedef typename X::root_type CompositionGradientBrush;
};
struct CompositionGradientBrush : generate<CompositionGradientBrush> {};

// CompositionLinearGradientBrush
template<typename X> struct statics<CompositionLinearGradientBrush, X> : X {
	typedef typename X::root_type CompositionLinearGradientBrush;
};
struct CompositionLinearGradientBrush : generate<CompositionLinearGradientBrush> {};

// CompositionContainerShape
template<typename X> struct statics<CompositionContainerShape, X> : X {
	typedef typename X::root_type CompositionContainerShape;
};
struct CompositionContainerShape : generate<CompositionContainerShape> {};

// CompositionSpriteShape
template<typename X> struct statics<CompositionSpriteShape, X> : X {
	typedef typename X::root_type CompositionSpriteShape;
};
struct CompositionSpriteShape : generate<CompositionSpriteShape> {};

// IKeyFrameAnimationFactory
struct IKeyFrameAnimationFactory : IInspectable, generate<IKeyFrameAnimationFactory> {};

// KeyFrameAnimation
template<typename X> struct statics<KeyFrameAnimation, X> : X {
	typedef typename X::root_type KeyFrameAnimation;
};
struct KeyFrameAnimation : generate<KeyFrameAnimation> {
	using IKeyFrameAnimation::InsertExpressionKeyFrame;
};

// ColorKeyFrameAnimation
template<typename X> struct statics<ColorKeyFrameAnimation, X> : X {
	typedef typename X::root_type ColorKeyFrameAnimation;
};
struct ColorKeyFrameAnimation : generate<ColorKeyFrameAnimation> {
	using IKeyFrameAnimation::InsertExpressionKeyFrame;
	using IColorKeyFrameAnimation::InsertKeyFrame;
};

// QuaternionKeyFrameAnimation
template<typename X> struct statics<QuaternionKeyFrameAnimation, X> : X {
	typedef typename X::root_type QuaternionKeyFrameAnimation;
};
struct QuaternionKeyFrameAnimation : generate<QuaternionKeyFrameAnimation> {
	using IKeyFrameAnimation::InsertExpressionKeyFrame;
	using IQuaternionKeyFrameAnimation::InsertKeyFrame;
};

// ScalarKeyFrameAnimation
template<typename X> struct statics<ScalarKeyFrameAnimation, X> : X {
	typedef typename X::root_type ScalarKeyFrameAnimation;
};
struct ScalarKeyFrameAnimation : generate<ScalarKeyFrameAnimation> {
	using IKeyFrameAnimation::InsertExpressionKeyFrame;
	using IScalarKeyFrameAnimation::InsertKeyFrame;
};

// Vector2KeyFrameAnimation
template<typename X> struct statics<Vector2KeyFrameAnimation, X> : X {
	typedef typename X::root_type Vector2KeyFrameAnimation;
};
struct Vector2KeyFrameAnimation : generate<Vector2KeyFrameAnimation> {
	using IKeyFrameAnimation::InsertExpressionKeyFrame;
	using IVector2KeyFrameAnimation::InsertKeyFrame;
};

// Vector3KeyFrameAnimation
template<typename X> struct statics<Vector3KeyFrameAnimation, X> : X {
	typedef typename X::root_type Vector3KeyFrameAnimation;
};
struct Vector3KeyFrameAnimation : generate<Vector3KeyFrameAnimation> {
	using IKeyFrameAnimation::InsertExpressionKeyFrame;
	using IVector3KeyFrameAnimation::InsertKeyFrame;
};

// Vector4KeyFrameAnimation
template<typename X> struct statics<Vector4KeyFrameAnimation, X> : X {
	typedef typename X::root_type Vector4KeyFrameAnimation;
};
struct Vector4KeyFrameAnimation : generate<Vector4KeyFrameAnimation> {
	using IKeyFrameAnimation::InsertExpressionKeyFrame;
	using IVector4KeyFrameAnimation::InsertKeyFrame;
};

// PathKeyFrameAnimation
template<typename X> struct statics<PathKeyFrameAnimation, X> : X {
	typedef typename X::root_type PathKeyFrameAnimation;
};
struct PathKeyFrameAnimation : generate<PathKeyFrameAnimation> {
	using IKeyFrameAnimation::InsertExpressionKeyFrame;
	using IPathKeyFrameAnimation::InsertKeyFrame;
};

// INaturalMotionAnimationFactory
struct INaturalMotionAnimationFactory : IInspectable, generate<INaturalMotionAnimationFactory> {};

// NaturalMotionAnimation
template<typename X> struct statics<NaturalMotionAnimation, X> : X {
	typedef typename X::root_type NaturalMotionAnimation;
};
struct NaturalMotionAnimation : generate<NaturalMotionAnimation> {};

// IScalarNaturalMotionAnimationFactory
struct IScalarNaturalMotionAnimationFactory : IInspectable, generate<IScalarNaturalMotionAnimationFactory> {};

// ScalarNaturalMotionAnimation
template<typename X> struct statics<ScalarNaturalMotionAnimation, X> : X {
	typedef typename X::root_type ScalarNaturalMotionAnimation;
};
struct ScalarNaturalMotionAnimation : generate<ScalarNaturalMotionAnimation> {};

// SpringScalarNaturalMotionAnimation
template<typename X> struct statics<SpringScalarNaturalMotionAnimation, X> : X {
	typedef typename X::root_type SpringScalarNaturalMotionAnimation;
};
struct SpringScalarNaturalMotionAnimation : generate<SpringScalarNaturalMotionAnimation> {};

// BounceScalarNaturalMotionAnimation
template<typename X> struct statics<BounceScalarNaturalMotionAnimation, X> : X {
	typedef typename X::root_type BounceScalarNaturalMotionAnimation;
};
struct BounceScalarNaturalMotionAnimation : generate<BounceScalarNaturalMotionAnimation> {};

// IVector2NaturalMotionAnimationFactory
struct IVector2NaturalMotionAnimationFactory : IInspectable, generate<IVector2NaturalMotionAnimationFactory> {};

// Vector2NaturalMotionAnimation
template<typename X> struct statics<Vector2NaturalMotionAnimation, X> : X {
	typedef typename X::root_type Vector2NaturalMotionAnimation;
};
struct Vector2NaturalMotionAnimation : generate<Vector2NaturalMotionAnimation> {};

// SpringVector2NaturalMotionAnimation
template<typename X> struct statics<SpringVector2NaturalMotionAnimation, X> : X {
	typedef typename X::root_type SpringVector2NaturalMotionAnimation;
};
struct SpringVector2NaturalMotionAnimation : generate<SpringVector2NaturalMotionAnimation> {};

// BounceVector2NaturalMotionAnimation
template<typename X> struct statics<BounceVector2NaturalMotionAnimation, X> : X {
	typedef typename X::root_type BounceVector2NaturalMotionAnimation;
};
struct BounceVector2NaturalMotionAnimation : generate<BounceVector2NaturalMotionAnimation> {};

// IVector3NaturalMotionAnimationFactory
struct IVector3NaturalMotionAnimationFactory : IInspectable, generate<IVector3NaturalMotionAnimationFactory> {};

// Vector3NaturalMotionAnimation
template<typename X> struct statics<Vector3NaturalMotionAnimation, X> : X {
	typedef typename X::root_type Vector3NaturalMotionAnimation;
};
struct Vector3NaturalMotionAnimation : generate<Vector3NaturalMotionAnimation> {};

// SpringVector3NaturalMotionAnimation
template<typename X> struct statics<SpringVector3NaturalMotionAnimation, X> : X {
	typedef typename X::root_type SpringVector3NaturalMotionAnimation;
};
struct SpringVector3NaturalMotionAnimation : generate<SpringVector3NaturalMotionAnimation> {};

// BounceVector3NaturalMotionAnimation
template<typename X> struct statics<BounceVector3NaturalMotionAnimation, X> : X {
	typedef typename X::root_type BounceVector3NaturalMotionAnimation;
};
struct BounceVector3NaturalMotionAnimation : generate<BounceVector3NaturalMotionAnimation> {};
}}}
} // namespace iso_winrt
