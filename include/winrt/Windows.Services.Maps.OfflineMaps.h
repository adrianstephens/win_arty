#pragma once
// generated by isopod tools
// namespaces:
// Windows.Services.Maps.OfflineMaps

#include "Windows.Services.Maps.OfflineMaps.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Devices { namespace Geolocation {
struct Geocircle;
struct Geopoint;
struct GeoboundingBox;
}}
namespace Foundation { namespace Collections {
template<typename T> struct IVectorView;
}}}

// defs

template<> struct def<Windows::Services::Maps::OfflineMaps::OfflineMapPackageQueryStatus> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::OfflineMaps::OfflineMapPackageStatus> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::OfflineMaps::OfflineMapPackageStartDownloadStatus> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::OfflineMaps::IOfflineMapPackageQueryResult> : interface_type<> {};
template<> struct def<Windows::Services::Maps::OfflineMaps::IOfflineMapPackageStatics> : interface_type<> {};
template<> struct def<Windows::Services::Maps::OfflineMaps::IOfflineMapPackage> : interface_type<> {};
template<> struct def<Windows::Services::Maps::OfflineMaps::OfflineMapPackage> : class_type<Platform::Object, Windows::Services::Maps::OfflineMaps::IOfflineMapPackage> {};
template<> struct def<Windows::Services::Maps::OfflineMaps::IOfflineMapPackageStartDownloadResult> : interface_type<> {};
template<> struct def<Windows::Services::Maps::OfflineMaps::OfflineMapPackageStartDownloadResult> : class_type<Platform::Object, Windows::Services::Maps::OfflineMaps::IOfflineMapPackageStartDownloadResult> {};
template<> struct def<Windows::Services::Maps::OfflineMaps::OfflineMapPackageQueryResult> : class_type<Platform::Object, Windows::Services::Maps::OfflineMaps::IOfflineMapPackageQueryResult> {};

// uuids

template<> struct uuid<Windows::Services::Maps::OfflineMaps::IOfflineMapPackageQueryResult> { define_guid(0x55585411, 0x39E1, 0x4E41, 0xA4, 0xE1, 0x5F, 0x48, 0x72, 0xBE, 0xE1, 0x99);};
template<> struct uuid<Windows::Services::Maps::OfflineMaps::IOfflineMapPackageStatics> { define_guid(0x185E7922, 0xA831, 0x4AB0, 0x94, 0x1F, 0x69, 0x98, 0xFA, 0x92, 0x92, 0x85);};
template<> struct uuid<Windows::Services::Maps::OfflineMaps::IOfflineMapPackage> { define_guid(0xA797673B, 0xA5B5, 0x4144, 0xB5, 0x25, 0xE6, 0x8C, 0x88, 0x62, 0x66, 0x4B);};
template<> struct uuid<Windows::Services::Maps::OfflineMaps::IOfflineMapPackageStartDownloadResult> { define_guid(0xD965B918, 0xD4D6, 0x4AFE, 0x93, 0x78, 0x3E, 0xC7, 0x1E, 0xF1, 0x1C, 0x3D);};

// types

namespace Windows { namespace Services { namespace Maps { namespace OfflineMaps {

// IOfflineMapPackageQueryResult
struct IOfflineMapPackageQueryResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(OfflineMapPackageQueryStatus *value);
	virtual STDMETHODIMP _get_Packages(Foundation::Collections::IVectorView<OfflineMapPackage*>* *value);
};
template<typename X> struct IOfflineMapPackageQueryResult_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<OfflineMapPackage>>> get() { Foundation::Collections::IVectorView<OfflineMapPackage*>* value; hrcheck(enc(&IOfflineMapPackageQueryResult_adaptor::Packages)->_get_Packages(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<OfflineMapPackage>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<OfflineMapPackage>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<OfflineMapPackage>>> operator->() { return get(); }
		} Packages;
		struct : property {
			OfflineMapPackageQueryStatus get() { OfflineMapPackageQueryStatus value; hrcheck(enc(&IOfflineMapPackageQueryResult_adaptor::Status)->_get_Status(&value)); return value; }
			OfflineMapPackageQueryStatus operator()() { return get(); }
			operator OfflineMapPackageQueryStatus () { return get(); }
		} Status;
	};
	IOfflineMapPackageQueryResult_adaptor() {}
};
template<typename X> struct adapt<IOfflineMapPackageQueryResult, X> : Windows::Services::Maps::OfflineMaps::IOfflineMapPackageQueryResult_adaptor<X> { typedef adapt IOfflineMapPackageQueryResult; };
struct IOfflineMapPackageQueryResult : IOfflineMapPackageQueryResult_raw, generate<IOfflineMapPackageQueryResult> {};

// IOfflineMapPackageStatics
struct IOfflineMapPackageStatics : IInspectable {
	virtual STDMETHODIMP _FindPackagesAsync(Devices::Geolocation::Geopoint* queryPoint, Foundation::IAsyncOperation<OfflineMapPackageQueryResult*>* *result);
	virtual STDMETHODIMP _FindPackagesInBoundingBoxAsync(Devices::Geolocation::GeoboundingBox* queryBoundingBox, Foundation::IAsyncOperation<OfflineMapPackageQueryResult*>* *result);
	virtual STDMETHODIMP _FindPackagesInGeocircleAsync(Devices::Geolocation::Geocircle* queryCircle, Foundation::IAsyncOperation<OfflineMapPackageQueryResult*>* *result);
};

// IOfflineMapPackage
struct IOfflineMapPackage_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(OfflineMapPackageStatus *value);
	virtual STDMETHODIMP _get_DisplayName(HSTRING *value);
	virtual STDMETHODIMP _get_EnclosingRegionName(HSTRING *value);
	virtual STDMETHODIMP _get_EstimatedSizeInBytes(unsigned __int64 *value);
	virtual STDMETHODIMP _remove_StatusChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_StatusChanged(Foundation::TypedEventHandler<OfflineMapPackage*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _RequestStartDownloadAsync(Foundation::IAsyncOperation<OfflineMapPackageStartDownloadResult*>* *value);
};
template<typename X> struct IOfflineMapPackage_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IOfflineMapPackage_adaptor::DisplayName)->_get_DisplayName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DisplayName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IOfflineMapPackage_adaptor::EnclosingRegionName)->_get_EnclosingRegionName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} EnclosingRegionName;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IOfflineMapPackage_adaptor::EstimatedSizeInBytes)->_get_EstimatedSizeInBytes(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} EstimatedSizeInBytes;
		struct : property {
			OfflineMapPackageStatus get() { OfflineMapPackageStatus value; hrcheck(enc(&IOfflineMapPackage_adaptor::Status)->_get_Status(&value)); return value; }
			OfflineMapPackageStatus operator()() { return get(); }
			operator OfflineMapPackageStatus () { return get(); }
		} Status;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<OfflineMapPackage>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IOfflineMapPackage_adaptor::StatusChanged)->_add_StatusChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IOfflineMapPackage_adaptor::StatusChanged)->_remove_StatusChanged(token)); }
		} StatusChanged;
	};
	ptr<Foundation::IAsyncOperation<ptr<OfflineMapPackageStartDownloadResult>>> RequestStartDownloadAsync() { Foundation::IAsyncOperation<OfflineMapPackageStartDownloadResult*>* value; hrcheck(X::get()->_RequestStartDownloadAsync(&value)); return from_abi(value); }
	IOfflineMapPackage_adaptor() {}
};
template<typename X> struct adapt<IOfflineMapPackage, X> : Windows::Services::Maps::OfflineMaps::IOfflineMapPackage_adaptor<X> { typedef adapt IOfflineMapPackage; };
struct IOfflineMapPackage : IOfflineMapPackage_raw, generate<IOfflineMapPackage> {};

// OfflineMapPackage
template<typename> struct OfflineMapPackage_statics {
	static ptr<Foundation::IAsyncOperation<ptr<OfflineMapPackageQueryResult>>> FindPackagesAsync(pptr<Devices::Geolocation::Geopoint> queryPoint) { Foundation::IAsyncOperation<OfflineMapPackageQueryResult*>* result; hrcheck(get_activation_factory<OfflineMapPackage, IOfflineMapPackageStatics>()->_FindPackagesAsync(queryPoint, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<OfflineMapPackageQueryResult>>> FindPackagesInBoundingBoxAsync(pptr<Devices::Geolocation::GeoboundingBox> queryBoundingBox) { Foundation::IAsyncOperation<OfflineMapPackageQueryResult*>* result; hrcheck(get_activation_factory<OfflineMapPackage, IOfflineMapPackageStatics>()->_FindPackagesInBoundingBoxAsync(queryBoundingBox, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<OfflineMapPackageQueryResult>>> FindPackagesInGeocircleAsync(pptr<Devices::Geolocation::Geocircle> queryCircle) { Foundation::IAsyncOperation<OfflineMapPackageQueryResult*>* result; hrcheck(get_activation_factory<OfflineMapPackage, IOfflineMapPackageStatics>()->_FindPackagesInGeocircleAsync(queryCircle, &result)); return from_abi(result); }
};

template<typename X> struct statics<OfflineMapPackage, X> : X, Windows::Services::Maps::OfflineMaps::OfflineMapPackage_statics<void> {
	typedef typename X::root_type OfflineMapPackage;
};
struct OfflineMapPackage : generate<OfflineMapPackage> {};

// IOfflineMapPackageStartDownloadResult
struct IOfflineMapPackageStartDownloadResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(OfflineMapPackageStartDownloadStatus *value);
};
template<typename X> struct IOfflineMapPackageStartDownloadResult_adaptor : X {
	union {
		struct : property {
			OfflineMapPackageStartDownloadStatus get() { OfflineMapPackageStartDownloadStatus value; hrcheck(enc(&IOfflineMapPackageStartDownloadResult_adaptor::Status)->_get_Status(&value)); return value; }
			OfflineMapPackageStartDownloadStatus operator()() { return get(); }
			operator OfflineMapPackageStartDownloadStatus () { return get(); }
		} Status;
	};
	IOfflineMapPackageStartDownloadResult_adaptor() {}
};
template<typename X> struct adapt<IOfflineMapPackageStartDownloadResult, X> : Windows::Services::Maps::OfflineMaps::IOfflineMapPackageStartDownloadResult_adaptor<X> { typedef adapt IOfflineMapPackageStartDownloadResult; };
struct IOfflineMapPackageStartDownloadResult : IOfflineMapPackageStartDownloadResult_raw, generate<IOfflineMapPackageStartDownloadResult> {};

// OfflineMapPackageStartDownloadResult
template<typename X> struct statics<OfflineMapPackageStartDownloadResult, X> : X {
	typedef typename X::root_type OfflineMapPackageStartDownloadResult;
};
struct OfflineMapPackageStartDownloadResult : generate<OfflineMapPackageStartDownloadResult> {};

// OfflineMapPackageQueryResult
template<typename X> struct statics<OfflineMapPackageQueryResult, X> : X {
	typedef typename X::root_type OfflineMapPackageQueryResult;
};
struct OfflineMapPackageQueryResult : generate<OfflineMapPackageQueryResult> {};
}}}}
} // namespace iso_winrt
