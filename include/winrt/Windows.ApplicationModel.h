#pragma once
// generated by isopod tools
// namespaces:
// Windows.ApplicationModel

#include "Windows.ApplicationModel.0.h"
#include "Windows.System.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace ApplicationModel { namespace Activation {
struct IActivatedEventArgs;
}
namespace Core {
struct AppListEntry;
}}
namespace Foundation { namespace Collections {
template<typename T> struct IIterable;
template<typename T> struct IVector;
template<typename T> struct IVectorView;
}}
namespace Storage { namespace Streams {
struct RandomAccessStreamReference;
}
struct StorageFolder;
}}

// defs

template<> struct def<Windows::ApplicationModel::FullTrustAppContract> : value_type<> {};
template<> struct def<Windows::ApplicationModel::IFullTrustProcessLauncherStatics> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::FullTrustProcessLauncher> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::ApplicationModel::StartupTaskContract> : value_type<> {};
template<> struct def<Windows::ApplicationModel::StartupTaskState> : enum_type<int> {};
template<> struct def<Windows::ApplicationModel::IStartupTask> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::IStartupTaskStatics> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::StartupTask> : class_type<Platform::Object, Windows::ApplicationModel::IStartupTask> {};
template<> struct def<Windows::ApplicationModel::IAppDisplayInfo> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::AppDisplayInfo> : class_type<Platform::Object, Windows::ApplicationModel::IAppDisplayInfo> {};
template<> struct def<Windows::ApplicationModel::IAppInfo> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::AppInfo> : class_type<Platform::Object, Windows::ApplicationModel::IAppInfo> {};
template<> struct def<Windows::ApplicationModel::PackageSignatureKind> : enum_type<int> {};
template<> struct def<Windows::ApplicationModel::IPackageIdWithMetadata> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::IPackageWithMetadata> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageVersion> : value_type<unsigned short, unsigned short, unsigned short, unsigned short> {};
template<> struct def<Windows::ApplicationModel::PackageInstallProgress> : value_type<unsigned> {};
template<> struct def<Windows::ApplicationModel::IPackageStatus> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::IPackageStatus2> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageStatus> : class_type<Platform::Object, Windows::ApplicationModel::IPackageStatus, Windows::ApplicationModel::IPackageStatus2> {};
template<> struct def<Windows::ApplicationModel::IPackageId> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageId> : class_type<Platform::Object, Windows::ApplicationModel::IPackageId, Windows::ApplicationModel::IPackageIdWithMetadata> {};
template<> struct def<Windows::ApplicationModel::IPackage> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::IPackageStatics> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::IPackage5> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::IPackage4> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::IPackage3> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::IPackage2> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Package> : class_type<Platform::Object, Windows::ApplicationModel::IPackage, Windows::ApplicationModel::IPackage2, Windows::ApplicationModel::IPackage3, Windows::ApplicationModel::IPackageWithMetadata, Windows::ApplicationModel::IPackage4, Windows::ApplicationModel::IPackage5> {};
template<> struct def<Windows::ApplicationModel::IPackageContentGroupStatics> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageContentGroupState> : enum_type<int> {};
template<> struct def<Windows::ApplicationModel::IPackageContentGroup> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageContentGroup> : class_type<Platform::Object, Windows::ApplicationModel::IPackageContentGroup> {};
template<> struct def<Windows::ApplicationModel::IPackageStagingEventArgs> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageStagingEventArgs> : class_type<Platform::Object, Windows::ApplicationModel::IPackageStagingEventArgs> {};
template<> struct def<Windows::ApplicationModel::IPackageInstallingEventArgs> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageInstallingEventArgs> : class_type<Platform::Object, Windows::ApplicationModel::IPackageInstallingEventArgs> {};
template<> struct def<Windows::ApplicationModel::IPackageUpdatingEventArgs> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageUpdatingEventArgs> : class_type<Platform::Object, Windows::ApplicationModel::IPackageUpdatingEventArgs> {};
template<> struct def<Windows::ApplicationModel::IPackageUninstallingEventArgs> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageUninstallingEventArgs> : class_type<Platform::Object, Windows::ApplicationModel::IPackageUninstallingEventArgs> {};
template<> struct def<Windows::ApplicationModel::IPackageStatusChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageStatusChangedEventArgs> : class_type<Platform::Object, Windows::ApplicationModel::IPackageStatusChangedEventArgs> {};
template<> struct def<Windows::ApplicationModel::IPackageContentGroupStagingEventArgs> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageContentGroupStagingEventArgs> : class_type<Platform::Object, Windows::ApplicationModel::IPackageContentGroupStagingEventArgs> {};
template<> struct def<Windows::ApplicationModel::IPackageCatalog> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::IPackageCatalogStatics> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::AddResourcePackageOptions> : enum_type<unsigned> {};
template<> struct def<Windows::ApplicationModel::IPackageCatalog4> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::IPackageCatalog3> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::IPackageCatalog2> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageCatalog> : class_type<Platform::Object, Windows::ApplicationModel::IPackageCatalog, Windows::ApplicationModel::IPackageCatalog2, Windows::ApplicationModel::IPackageCatalog3, Windows::ApplicationModel::IPackageCatalog4> {};
template<> struct def<Windows::ApplicationModel::IPackageCatalogAddOptionalPackageResult> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult> : class_type<Platform::Object, Windows::ApplicationModel::IPackageCatalogAddOptionalPackageResult> {};
template<> struct def<Windows::ApplicationModel::IPackageCatalogRemoveOptionalPackagesResult> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult> : class_type<Platform::Object, Windows::ApplicationModel::IPackageCatalogRemoveOptionalPackagesResult> {};
template<> struct def<Windows::ApplicationModel::IPackageCatalogRemoveResourcePackagesResult> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult> : class_type<Platform::Object, Windows::ApplicationModel::IPackageCatalogRemoveResourcePackagesResult> {};
template<> struct def<Windows::ApplicationModel::IPackageCatalogAddResourcePackageResult> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::PackageCatalogAddResourcePackageResult> : class_type<Platform::Object, Windows::ApplicationModel::IPackageCatalogAddResourcePackageResult> {};
template<> struct def<Windows::ApplicationModel::IDesignModeStatics> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::IDesignModeStatics2> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::DesignMode> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::ApplicationModel::IAppInstance> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::IAppInstanceStatics> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::AppInstance> : class_type<Platform::Object, Windows::ApplicationModel::IAppInstance> {};
template<> struct def<Windows::ApplicationModel::ISuspendingEventArgs> : overridable_type<> {};
template<> struct def<Windows::ApplicationModel::SuspendingEventArgs> : class_type<Platform::Object, Windows::ApplicationModel::ISuspendingEventArgs> {};
template<> struct def<Windows::ApplicationModel::ILeavingBackgroundEventArgs> : overridable_type<> {};
template<> struct def<Windows::ApplicationModel::LeavingBackgroundEventArgs> : class_type<Platform::Object, Windows::ApplicationModel::ILeavingBackgroundEventArgs> {};
template<> struct def<Windows::ApplicationModel::IEnteredBackgroundEventArgs> : overridable_type<> {};
template<> struct def<Windows::ApplicationModel::EnteredBackgroundEventArgs> : class_type<Platform::Object, Windows::ApplicationModel::IEnteredBackgroundEventArgs> {};
template<> struct def<Windows::ApplicationModel::ISuspendingDeferral> : overridable_type<> {};
template<> struct def<Windows::ApplicationModel::SuspendingDeferral> : class_type<Platform::Object, Windows::ApplicationModel::ISuspendingDeferral> {};
template<> struct def<Windows::ApplicationModel::ISuspendingOperation> : overridable_type<> {};
template<> struct def<Windows::ApplicationModel::SuspendingOperation> : class_type<Platform::Object, Windows::ApplicationModel::ISuspendingOperation> {};
template<> struct def<Windows::ApplicationModel::ICameraApplicationManagerStatics> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::CameraApplicationManager> : class_type<Platform::Object, Platform::Object> {};

// uuids

template<> struct uuid<Windows::ApplicationModel::IFullTrustProcessLauncherStatics> { define_guid(0xD784837F, 0x1100, 0x3C6B, 0xA4, 0x55, 0xF6, 0x26, 0x2C, 0xC3, 0x31, 0xB6);};
template<> struct uuid<Windows::ApplicationModel::IStartupTask> { define_guid(0xF75C23C8, 0xB5F2, 0x4F6C, 0x88, 0xDD, 0x36, 0xCB, 0x1D, 0x59, 0x9D, 0x17);};
template<> struct uuid<Windows::ApplicationModel::IStartupTaskStatics> { define_guid(0xEE5B60BD, 0xA148, 0x41A7, 0xB2, 0x6E, 0xE8, 0xB8, 0x8A, 0x1E, 0x62, 0xF8);};
template<> struct uuid<Windows::ApplicationModel::IAppDisplayInfo> { define_guid(0x1AEB1103, 0xE4D4, 0x41AA, 0xA4, 0xF6, 0xC4, 0xA2, 0x76, 0xE7, 0x9E, 0xAC);};
template<> struct uuid<Windows::ApplicationModel::IAppInfo> { define_guid(0xCF7F59B3, 0x6A09, 0x4DE8, 0xA6, 0xC0, 0x57, 0x92, 0xD5, 0x68, 0x80, 0xD1);};
template<> struct uuid<Windows::ApplicationModel::IPackageIdWithMetadata> { define_guid(0x40577A7C, 0xC9E, 0x443D, 0x90, 0x74, 0x85, 0x5F, 0x5C, 0xE0, 0xA0, 0x8D);};
template<> struct uuid<Windows::ApplicationModel::IPackageWithMetadata> { define_guid(0x95949780, 0x1DE9, 0x40F2, 0xB4, 0x52, 0xD, 0xE9, 0xF1, 0x91, 0x0, 0x12);};
template<> struct uuid<Windows::ApplicationModel::IPackageStatus> { define_guid(0x5FE74F71, 0xA365, 0x4C09, 0xA0, 0x2D, 0x4, 0x6D, 0x52, 0x5E, 0xA1, 0xDA);};
template<> struct uuid<Windows::ApplicationModel::IPackageStatus2> { define_guid(0xF428FA93, 0x7C56, 0x4862, 0xAC, 0xFA, 0xAB, 0xAE, 0xDC, 0xC0, 0x69, 0x4D);};
template<> struct uuid<Windows::ApplicationModel::IPackageId> { define_guid(0x1ADB665E, 0x37C7, 0x4790, 0x99, 0x80, 0xDD, 0x7A, 0xE7, 0x4E, 0x8B, 0xB2);};
template<> struct uuid<Windows::ApplicationModel::IPackage> { define_guid(0x163C792F, 0xBD75, 0x413C, 0xBF, 0x23, 0xB1, 0xFE, 0x7B, 0x95, 0xD8, 0x25);};
template<> struct uuid<Windows::ApplicationModel::IPackageStatics> { define_guid(0x4E534BDF, 0x2960, 0x4878, 0x97, 0xA4, 0x96, 0x24, 0xDE, 0xB7, 0x2F, 0x2D);};
template<> struct uuid<Windows::ApplicationModel::IPackage5> { define_guid(0xE842DD4, 0xD9AC, 0x45ED, 0x9A, 0x1E, 0x74, 0xCE, 0x5, 0x6B, 0x26, 0x35);};
template<> struct uuid<Windows::ApplicationModel::IPackage4> { define_guid(0x65AED1AE, 0xB95B, 0x450C, 0x88, 0x2B, 0x62, 0x55, 0x18, 0x7F, 0x39, 0x7E);};
template<> struct uuid<Windows::ApplicationModel::IPackage3> { define_guid(0x5F738B61, 0xF86A, 0x4917, 0x93, 0xD1, 0xF1, 0xEE, 0x9D, 0x3B, 0x35, 0xD9);};
template<> struct uuid<Windows::ApplicationModel::IPackage2> { define_guid(0xA6612FB6, 0x7688, 0x4ACE, 0x95, 0xFB, 0x35, 0x95, 0x38, 0xE7, 0xAA, 0x1);};
template<> struct uuid<Windows::ApplicationModel::IPackageContentGroupStatics> { define_guid(0x70EE7619, 0x5F12, 0x4B92, 0xB9, 0xEA, 0x6C, 0xCA, 0xDA, 0x13, 0xBC, 0x75);};
template<> struct uuid<Windows::ApplicationModel::IPackageContentGroup> { define_guid(0x8F62695D, 0x120A, 0x4798, 0xB5, 0xE1, 0x58, 0x0, 0xDD, 0xA8, 0xF2, 0xE1);};
template<> struct uuid<Windows::ApplicationModel::IPackageStagingEventArgs> { define_guid(0x1041682D, 0x54E2, 0x4F51, 0xB8, 0x28, 0x9E, 0xF7, 0x4, 0x6C, 0x21, 0xF);};
template<> struct uuid<Windows::ApplicationModel::IPackageInstallingEventArgs> { define_guid(0x97741EB7, 0xAB7A, 0x401A, 0x8B, 0x61, 0xEB, 0xE, 0x7F, 0xAF, 0xF2, 0x37);};
template<> struct uuid<Windows::ApplicationModel::IPackageUpdatingEventArgs> { define_guid(0xCD7B4228, 0xFD74, 0x443E, 0xB1, 0x14, 0x23, 0xE6, 0x77, 0xB0, 0xE8, 0x6F);};
template<> struct uuid<Windows::ApplicationModel::IPackageUninstallingEventArgs> { define_guid(0x4443AA52, 0xAB22, 0x44CD, 0x82, 0xBB, 0x4E, 0xC9, 0xB8, 0x27, 0x36, 0x7A);};
template<> struct uuid<Windows::ApplicationModel::IPackageStatusChangedEventArgs> { define_guid(0x437D714D, 0xBD80, 0x4A70, 0xBC, 0x50, 0xF6, 0xE7, 0x96, 0x50, 0x95, 0x75);};
template<> struct uuid<Windows::ApplicationModel::IPackageContentGroupStagingEventArgs> { define_guid(0x3D7BC27E, 0x6F27, 0x446C, 0x98, 0x6E, 0xD4, 0x73, 0x3D, 0x4D, 0x91, 0x13);};
template<> struct uuid<Windows::ApplicationModel::IPackageCatalog> { define_guid(0x230A3751, 0x9DE3, 0x4445, 0xBE, 0x74, 0x91, 0xFB, 0x32, 0x5A, 0xBE, 0xFE);};
template<> struct uuid<Windows::ApplicationModel::IPackageCatalogStatics> { define_guid(0xA18C9696, 0xE65B, 0x4634, 0xBA, 0x21, 0x5E, 0x63, 0xEB, 0x72, 0x44, 0xA7);};
template<> struct uuid<Windows::ApplicationModel::IPackageCatalog4> { define_guid(0xC37C399B, 0x44CC, 0x4B7B, 0x8B, 0xAF, 0x79, 0x6C, 0x4, 0xEA, 0xD3, 0xB9);};
template<> struct uuid<Windows::ApplicationModel::IPackageCatalog3> { define_guid(0x96DD5C88, 0x8837, 0x43F9, 0x90, 0x15, 0x3, 0x34, 0x34, 0xBA, 0x14, 0xF3);};
template<> struct uuid<Windows::ApplicationModel::IPackageCatalog2> { define_guid(0x96A60C36, 0x8FF7, 0x4344, 0xB6, 0xBF, 0xEE, 0x64, 0xC2, 0x20, 0x7E, 0xD2);};
template<> struct uuid<Windows::ApplicationModel::IPackageCatalogAddOptionalPackageResult> { define_guid(0x3BF10CD4, 0xB4DF, 0x47B3, 0xA9, 0x63, 0xE2, 0xFA, 0x83, 0x2F, 0x7D, 0xD3);};
template<> struct uuid<Windows::ApplicationModel::IPackageCatalogRemoveOptionalPackagesResult> { define_guid(0x29D2F97B, 0xD974, 0x4E64, 0x93, 0x59, 0x22, 0xCA, 0xDF, 0xD7, 0x98, 0x28);};
template<> struct uuid<Windows::ApplicationModel::IPackageCatalogRemoveResourcePackagesResult> { define_guid(0xAE719709, 0x1A52, 0x4321, 0x87, 0xB3, 0xE5, 0xA1, 0xA1, 0x79, 0x81, 0xA7);};
template<> struct uuid<Windows::ApplicationModel::IPackageCatalogAddResourcePackageResult> { define_guid(0x9636CE0D, 0x3E17, 0x493F, 0xAA, 0x8, 0xCC, 0xEC, 0x6F, 0xDE, 0xF6, 0x99);};
template<> struct uuid<Windows::ApplicationModel::IDesignModeStatics> { define_guid(0x2C3893CC, 0xF81A, 0x4E7A, 0xB8, 0x57, 0x76, 0xA8, 0x8, 0x87, 0xE1, 0x85);};
template<> struct uuid<Windows::ApplicationModel::IDesignModeStatics2> { define_guid(0x80CF8137, 0xB064, 0x4858, 0xBE, 0xC8, 0x3E, 0xBA, 0x22, 0x35, 0x75, 0x35);};
template<> struct uuid<Windows::ApplicationModel::IAppInstance> { define_guid(0x675F2B47, 0xF25F, 0x4532, 0x9F, 0xD6, 0x36, 0x33, 0xE0, 0x63, 0x4D, 0x1);};
template<> struct uuid<Windows::ApplicationModel::IAppInstanceStatics> { define_guid(0x9D11E77F, 0x9EA6, 0x47AF, 0xA6, 0xEC, 0x46, 0x78, 0x4C, 0x5B, 0xA2, 0x54);};
template<> struct uuid<Windows::ApplicationModel::ISuspendingEventArgs> { define_guid(0x96061C05, 0x2DBA, 0x4D08, 0xB0, 0xBD, 0x2B, 0x30, 0xA1, 0x31, 0xC6, 0xAA);};
template<> struct uuid<Windows::ApplicationModel::ILeavingBackgroundEventArgs> { define_guid(0x39C6EC9A, 0xAE6E, 0x46F9, 0xA0, 0x7A, 0xCF, 0xC2, 0x3F, 0x88, 0x73, 0x3E);};
template<> struct uuid<Windows::ApplicationModel::IEnteredBackgroundEventArgs> { define_guid(0xF722DCC2, 0x9827, 0x403D, 0xAA, 0xED, 0xEC, 0xCA, 0x9A, 0xC1, 0x73, 0x98);};
template<> struct uuid<Windows::ApplicationModel::ISuspendingDeferral> { define_guid(0x59140509, 0x8BC9, 0x4EB4, 0xB6, 0x36, 0xDA, 0xBD, 0xC4, 0xF4, 0x6F, 0x66);};
template<> struct uuid<Windows::ApplicationModel::ISuspendingOperation> { define_guid(0x9DA4CA41, 0x20E1, 0x4E9B, 0x9F, 0x65, 0xA9, 0xF4, 0x35, 0x34, 0xC, 0x3A);};
template<> struct uuid<Windows::ApplicationModel::ICameraApplicationManagerStatics> { define_guid(0x9599DDCE, 0x9BD3, 0x435C, 0x80, 0x54, 0xC1, 0xAD, 0xD5, 0x0, 0x28, 0xFE);};

// types

namespace Windows { namespace ApplicationModel {

// IFullTrustProcessLauncherStatics
struct IFullTrustProcessLauncherStatics : IInspectable {
	virtual STDMETHODIMP _LaunchFullTrustProcessForCurrentAppAsync(Foundation::IAsyncAction* *asyncAction);
	virtual STDMETHODIMP _LaunchFullTrustProcessForCurrentAppWithParametersAsync(HSTRING parameterGroupId, Foundation::IAsyncAction* *asyncAction);
	virtual STDMETHODIMP _LaunchFullTrustProcessForAppAsync(HSTRING fullTrustPackageRelativeAppId, Foundation::IAsyncAction* *asyncAction);
	virtual STDMETHODIMP _LaunchFullTrustProcessForAppWithParametersAsync(HSTRING fullTrustPackageRelativeAppId, HSTRING parameterGroupId, Foundation::IAsyncAction* *asyncAction);
};

// FullTrustProcessLauncher
template<typename> struct FullTrustProcessLauncher_statics {
	static ptr<Foundation::IAsyncAction> LaunchFullTrustProcessForCurrentAppAsync() { Foundation::IAsyncAction* asyncAction; hrcheck(get_activation_factory<FullTrustProcessLauncher, IFullTrustProcessLauncherStatics>()->_LaunchFullTrustProcessForCurrentAppAsync(&asyncAction)); return from_abi(asyncAction); }
	static ptr<Foundation::IAsyncAction> LaunchFullTrustProcessForCurrentAppAsync(hstring_ref parameterGroupId) { Foundation::IAsyncAction* asyncAction; hrcheck(get_activation_factory<FullTrustProcessLauncher, IFullTrustProcessLauncherStatics>()->_LaunchFullTrustProcessForCurrentAppWithParametersAsync(parameterGroupId, &asyncAction)); return from_abi(asyncAction); }
	static ptr<Foundation::IAsyncAction> LaunchFullTrustProcessForAppAsync(hstring_ref fullTrustPackageRelativeAppId) { Foundation::IAsyncAction* asyncAction; hrcheck(get_activation_factory<FullTrustProcessLauncher, IFullTrustProcessLauncherStatics>()->_LaunchFullTrustProcessForAppAsync(fullTrustPackageRelativeAppId, &asyncAction)); return from_abi(asyncAction); }
	static ptr<Foundation::IAsyncAction> LaunchFullTrustProcessForAppAsync(hstring_ref fullTrustPackageRelativeAppId, hstring_ref parameterGroupId) { Foundation::IAsyncAction* asyncAction; hrcheck(get_activation_factory<FullTrustProcessLauncher, IFullTrustProcessLauncherStatics>()->_LaunchFullTrustProcessForAppWithParametersAsync(fullTrustPackageRelativeAppId, parameterGroupId, &asyncAction)); return from_abi(asyncAction); }
};

template<typename X> struct statics<FullTrustProcessLauncher, X> : X, Windows::ApplicationModel::FullTrustProcessLauncher_statics<void> {
	typedef typename X::root_type FullTrustProcessLauncher;
};
struct FullTrustProcessLauncher : generate<FullTrustProcessLauncher> {};

// IStartupTask
struct IStartupTask_raw : IInspectable {
	virtual STDMETHODIMP _RequestEnableAsync(Foundation::IAsyncOperation<StartupTaskState>* *operation);
	virtual STDMETHODIMP _Disable();
	virtual STDMETHODIMP _get_State(StartupTaskState *value);
	virtual STDMETHODIMP _get_TaskId(HSTRING *value);
};
template<typename X> struct IStartupTask_adaptor : X {
	union {
		struct : property {
			StartupTaskState get() { StartupTaskState value; hrcheck(enc(&IStartupTask_adaptor::State)->_get_State(&value)); return value; }
			StartupTaskState operator()() { return get(); }
			operator StartupTaskState () { return get(); }
		} State;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStartupTask_adaptor::TaskId)->_get_TaskId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} TaskId;
	};
	ptr<Foundation::IAsyncOperation<StartupTaskState>> RequestEnableAsync() { Foundation::IAsyncOperation<StartupTaskState>* operation; hrcheck(X::get()->_RequestEnableAsync(&operation)); return from_abi(operation); }
	void Disable() { hrcheck(X::get()->_Disable()); }
	IStartupTask_adaptor() {}
};
template<typename X> struct adapt<IStartupTask, X> : Windows::ApplicationModel::IStartupTask_adaptor<X> { typedef adapt IStartupTask; };
struct IStartupTask : IStartupTask_raw, generate<IStartupTask> {};

// IStartupTaskStatics
struct IStartupTaskStatics : IInspectable {
	virtual STDMETHODIMP _GetForCurrentPackageAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StartupTask*>*>* *operation);
	virtual STDMETHODIMP _GetAsync(HSTRING taskId, Foundation::IAsyncOperation<StartupTask*>* *operation);
};

// StartupTask
template<typename> struct StartupTask_statics {
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<StartupTask>>>>> GetForCurrentPackageAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StartupTask*>*>* operation; hrcheck(get_activation_factory<StartupTask, IStartupTaskStatics>()->_GetForCurrentPackageAsync(&operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StartupTask>>> GetAsync(hstring_ref taskId) { Foundation::IAsyncOperation<StartupTask*>* operation; hrcheck(get_activation_factory<StartupTask, IStartupTaskStatics>()->_GetAsync(taskId, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<StartupTask, X> : X, Windows::ApplicationModel::StartupTask_statics<void> {
	typedef typename X::root_type StartupTask;
};
struct StartupTask : generate<StartupTask> {};

// IAppDisplayInfo
struct IAppDisplayInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_DisplayName(HSTRING *value);
	virtual STDMETHODIMP _get_Description(HSTRING *value);
	virtual STDMETHODIMP _GetLogo(Foundation::Size size, Storage::Streams::RandomAccessStreamReference* *value);
};
template<typename X> struct IAppDisplayInfo_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppDisplayInfo_adaptor::Description)->_get_Description(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Description;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppDisplayInfo_adaptor::DisplayName)->_get_DisplayName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DisplayName;
	};
	ptr<Storage::Streams::RandomAccessStreamReference> GetLogo(const Foundation::Size& size) { Storage::Streams::RandomAccessStreamReference* value; hrcheck(X::get()->_GetLogo(size, &value)); return from_abi(value); }
	IAppDisplayInfo_adaptor() {}
};
template<typename X> struct adapt<IAppDisplayInfo, X> : Windows::ApplicationModel::IAppDisplayInfo_adaptor<X> { typedef adapt IAppDisplayInfo; };
struct IAppDisplayInfo : IAppDisplayInfo_raw, generate<IAppDisplayInfo> {};

// AppDisplayInfo
template<typename X> struct statics<AppDisplayInfo, X> : X {
	typedef typename X::root_type AppDisplayInfo;
};
struct AppDisplayInfo : generate<AppDisplayInfo> {};

// IAppInfo
struct IAppInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_Id(HSTRING *value);
	virtual STDMETHODIMP _get_AppUserModelId(HSTRING *value);
	virtual STDMETHODIMP _get_DisplayInfo(AppDisplayInfo* *value);
	virtual STDMETHODIMP _get_PackageFamilyName(HSTRING *value);
};
template<typename X> struct IAppInfo_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppInfo_adaptor::AppUserModelId)->_get_AppUserModelId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} AppUserModelId;
		struct : property {
			ptr<AppDisplayInfo> get() { AppDisplayInfo* value; hrcheck(enc(&IAppInfo_adaptor::DisplayInfo)->_get_DisplayInfo(&value)); return from_abi(value); }
			ptr<AppDisplayInfo> operator()() { return get(); }
			operator ptr<AppDisplayInfo> () { return get(); }
			ptr<AppDisplayInfo> operator->() { return get(); }
		} DisplayInfo;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppInfo_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppInfo_adaptor::PackageFamilyName)->_get_PackageFamilyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PackageFamilyName;
	};
	IAppInfo_adaptor() {}
};
template<typename X> struct adapt<IAppInfo, X> : Windows::ApplicationModel::IAppInfo_adaptor<X> { typedef adapt IAppInfo; };
struct IAppInfo : IAppInfo_raw, generate<IAppInfo> {};

// AppInfo
template<typename X> struct statics<AppInfo, X> : X {
	typedef typename X::root_type AppInfo;
};
struct AppInfo : generate<AppInfo> {};

// IPackageIdWithMetadata
struct IPackageIdWithMetadata_raw : IInspectable {
	virtual STDMETHODIMP _get_ProductId(HSTRING *value);
	virtual STDMETHODIMP _get_Author(HSTRING *value);
};
template<typename X> struct IPackageIdWithMetadata_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackageIdWithMetadata_adaptor::Author)->_get_Author(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Author;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackageIdWithMetadata_adaptor::ProductId)->_get_ProductId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ProductId;
	};
	IPackageIdWithMetadata_adaptor() {}
};
template<typename X> struct adapt<IPackageIdWithMetadata, X> : Windows::ApplicationModel::IPackageIdWithMetadata_adaptor<X> { typedef adapt IPackageIdWithMetadata; };
struct IPackageIdWithMetadata : IPackageIdWithMetadata_raw, generate<IPackageIdWithMetadata> {};

// IPackageWithMetadata
struct IPackageWithMetadata_raw : IInspectable {
	virtual STDMETHODIMP _get_InstallDate(Foundation::DateTime *value);
	virtual STDMETHODIMP _GetThumbnailToken(HSTRING *value);
	virtual STDMETHODIMP _Launch(HSTRING parameters);
};
template<typename X> struct IPackageWithMetadata_adaptor : X {
	union {
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IPackageWithMetadata_adaptor::InstallDate)->_get_InstallDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} InstallDate;
	};
	hstring GetThumbnailToken() { HSTRING value; hrcheck(X::get()->_GetThumbnailToken(&value)); return from_abi(value); }
	void Launch(hstring_ref parameters) { hrcheck(X::get()->_Launch(parameters)); }
	IPackageWithMetadata_adaptor() {}
};
template<typename X> struct adapt<IPackageWithMetadata, X> : Windows::ApplicationModel::IPackageWithMetadata_adaptor<X> { typedef adapt IPackageWithMetadata; };
struct IPackageWithMetadata : IPackageWithMetadata_raw, generate<IPackageWithMetadata> {};

// IPackageStatus
struct IPackageStatus_raw : IInspectable {
	virtual STDMETHODIMP _VerifyIsOK(bool *value);
	virtual STDMETHODIMP _get_NotAvailable(bool *value);
	virtual STDMETHODIMP _get_PackageOffline(bool *value);
	virtual STDMETHODIMP _get_DataOffline(bool *value);
	virtual STDMETHODIMP _get_Disabled(bool *value);
	virtual STDMETHODIMP _get_NeedsRemediation(bool *value);
	virtual STDMETHODIMP _get_LicenseIssue(bool *value);
	virtual STDMETHODIMP _get_Modified(bool *value);
	virtual STDMETHODIMP _get_Tampered(bool *value);
	virtual STDMETHODIMP _get_DependencyIssue(bool *value);
	virtual STDMETHODIMP _get_Servicing(bool *value);
	virtual STDMETHODIMP _get_DeploymentInProgress(bool *value);
};
template<typename X> struct IPackageStatus_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageStatus_adaptor::DataOffline)->_get_DataOffline(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} DataOffline;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageStatus_adaptor::DependencyIssue)->_get_DependencyIssue(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} DependencyIssue;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageStatus_adaptor::DeploymentInProgress)->_get_DeploymentInProgress(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} DeploymentInProgress;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageStatus_adaptor::Disabled)->_get_Disabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Disabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageStatus_adaptor::LicenseIssue)->_get_LicenseIssue(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} LicenseIssue;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageStatus_adaptor::Modified)->_get_Modified(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Modified;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageStatus_adaptor::NeedsRemediation)->_get_NeedsRemediation(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} NeedsRemediation;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageStatus_adaptor::NotAvailable)->_get_NotAvailable(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} NotAvailable;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageStatus_adaptor::PackageOffline)->_get_PackageOffline(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} PackageOffline;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageStatus_adaptor::Servicing)->_get_Servicing(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Servicing;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageStatus_adaptor::Tampered)->_get_Tampered(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Tampered;
	};
	bool VerifyIsOK() { bool value; hrcheck(X::get()->_VerifyIsOK(&value)); return value; }
	IPackageStatus_adaptor() {}
};
template<typename X> struct adapt<IPackageStatus, X> : Windows::ApplicationModel::IPackageStatus_adaptor<X> { typedef adapt IPackageStatus; };
struct IPackageStatus : IPackageStatus_raw, generate<IPackageStatus> {};

// IPackageStatus2
struct IPackageStatus2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsPartiallyStaged(bool *value);
};
template<typename X> struct IPackageStatus2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageStatus2_adaptor::IsPartiallyStaged)->_get_IsPartiallyStaged(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsPartiallyStaged;
	};
	IPackageStatus2_adaptor() {}
};
template<typename X> struct adapt<IPackageStatus2, X> : Windows::ApplicationModel::IPackageStatus2_adaptor<X> { typedef adapt IPackageStatus2; };
struct IPackageStatus2 : IPackageStatus2_raw, generate<IPackageStatus2> {};

// PackageStatus
template<typename X> struct statics<PackageStatus, X> : X {
	typedef typename X::root_type PackageStatus;
};
struct PackageStatus : generate<PackageStatus> {};

// IPackageId
struct IPackageId_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_Version(PackageVersion *value);
	virtual STDMETHODIMP _get_Architecture(System::ProcessorArchitecture *value);
	virtual STDMETHODIMP _get_ResourceId(HSTRING *value);
	virtual STDMETHODIMP _get_Publisher(HSTRING *value);
	virtual STDMETHODIMP _get_PublisherId(HSTRING *value);
	virtual STDMETHODIMP _get_FullName(HSTRING *value);
	virtual STDMETHODIMP _get_FamilyName(HSTRING *value);
};
template<typename X> struct IPackageId_adaptor : X {
	union {
		struct : property {
			System::ProcessorArchitecture get() { System::ProcessorArchitecture value; hrcheck(enc(&IPackageId_adaptor::Architecture)->_get_Architecture(&value)); return value; }
			System::ProcessorArchitecture operator()() { return get(); }
			operator System::ProcessorArchitecture () { return get(); }
		} Architecture;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackageId_adaptor::FamilyName)->_get_FamilyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} FamilyName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackageId_adaptor::FullName)->_get_FullName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} FullName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackageId_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackageId_adaptor::Publisher)->_get_Publisher(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Publisher;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackageId_adaptor::PublisherId)->_get_PublisherId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PublisherId;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackageId_adaptor::ResourceId)->_get_ResourceId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ResourceId;
		struct : property {
			PackageVersion get() { PackageVersion value; hrcheck(enc(&IPackageId_adaptor::Version)->_get_Version(&value)); return value; }
			PackageVersion operator()() { return get(); }
			operator PackageVersion () { return get(); }
		} Version;
	};
	IPackageId_adaptor() {}
};
template<typename X> struct adapt<IPackageId, X> : Windows::ApplicationModel::IPackageId_adaptor<X> { typedef adapt IPackageId; };
struct IPackageId : IPackageId_raw, generate<IPackageId> {};

// PackageId
template<typename X> struct statics<PackageId, X> : X {
	typedef typename X::root_type PackageId;
};
struct PackageId : generate<PackageId> {};

// IPackage
struct IPackage_raw : IInspectable {
	virtual STDMETHODIMP _get_Id(PackageId* *value);
	virtual STDMETHODIMP _get_InstalledLocation(Storage::StorageFolder* *value);
	virtual STDMETHODIMP _get_IsFramework(bool *value);
	virtual STDMETHODIMP _get_Dependencies(Foundation::Collections::IVectorView<Package*>* *value);
};
template<typename X> struct IPackage_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Package>>> get() { Foundation::Collections::IVectorView<Package*>* value; hrcheck(enc(&IPackage_adaptor::Dependencies)->_get_Dependencies(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Package>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Package>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Package>>> operator->() { return get(); }
		} Dependencies;
		struct : property {
			ptr<PackageId> get() { PackageId* value; hrcheck(enc(&IPackage_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			ptr<PackageId> operator()() { return get(); }
			operator ptr<PackageId> () { return get(); }
			ptr<PackageId> operator->() { return get(); }
		} Id;
		struct : property {
			ptr<Storage::StorageFolder> get() { Storage::StorageFolder* value; hrcheck(enc(&IPackage_adaptor::InstalledLocation)->_get_InstalledLocation(&value)); return from_abi(value); }
			ptr<Storage::StorageFolder> operator()() { return get(); }
			operator ptr<Storage::StorageFolder> () { return get(); }
			ptr<Storage::StorageFolder> operator->() { return get(); }
		} InstalledLocation;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackage_adaptor::IsFramework)->_get_IsFramework(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsFramework;
	};
	IPackage_adaptor() {}
};
template<typename X> struct adapt<IPackage, X> : Windows::ApplicationModel::IPackage_adaptor<X> { typedef adapt IPackage; };
struct IPackage : IPackage_raw, generate<IPackage> {};

// IPackageStatics
struct IPackageStatics : IInspectable {
	virtual STDMETHODIMP _get_Current(Package* *value);
};

// IPackage5
struct IPackage5_raw : IInspectable {
	virtual STDMETHODIMP _GetContentGroupsAsync(Foundation::IAsyncOperation<Foundation::Collections::IVector<PackageContentGroup*>*>* *operation);
	virtual STDMETHODIMP _GetContentGroupAsync(HSTRING name, Foundation::IAsyncOperation<PackageContentGroup*>* *operation);
	virtual STDMETHODIMP _StageContentGroupsAsync(Foundation::Collections::IIterable<HSTRING>* names, Foundation::IAsyncOperation<Foundation::Collections::IVector<PackageContentGroup*>*>* *operation);
	virtual STDMETHODIMP _StageContentGroupsWithPriorityAsync(Foundation::Collections::IIterable<HSTRING>* names, bool moveToHeadOfQueue, Foundation::IAsyncOperation<Foundation::Collections::IVector<PackageContentGroup*>*>* *operation);
	virtual STDMETHODIMP _SetInUseAsync(bool inUse, Foundation::IAsyncOperation<bool>* *operation);
};
template<typename X> struct IPackage5_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVector<ptr<PackageContentGroup>>>>> GetContentGroupsAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVector<PackageContentGroup*>*>* operation; hrcheck(X::get()->_GetContentGroupsAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<PackageContentGroup>>> GetContentGroupAsync(hstring_ref name) { Foundation::IAsyncOperation<PackageContentGroup*>* operation; hrcheck(X::get()->_GetContentGroupAsync(name, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVector<ptr<PackageContentGroup>>>>> StageContentGroupsAsync(pptr<Foundation::Collections::IIterable<hstring>> names) { Foundation::IAsyncOperation<Foundation::Collections::IVector<PackageContentGroup*>*>* operation; hrcheck(X::get()->_StageContentGroupsAsync(to_abi(names), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVector<ptr<PackageContentGroup>>>>> StageContentGroupsAsync(pptr<Foundation::Collections::IIterable<hstring>> names, bool moveToHeadOfQueue) { Foundation::IAsyncOperation<Foundation::Collections::IVector<PackageContentGroup*>*>* operation; hrcheck(X::get()->_StageContentGroupsWithPriorityAsync(to_abi(names), moveToHeadOfQueue, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<bool>> SetInUseAsync(bool inUse) { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_SetInUseAsync(inUse, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IPackage5, X> : Windows::ApplicationModel::IPackage5_adaptor<X> { typedef adapt IPackage5; };
struct IPackage5 : IPackage5_raw, generate<IPackage5> {};

// IPackage4
struct IPackage4_raw : IInspectable {
	virtual STDMETHODIMP _get_SignatureKind(PackageSignatureKind *value);
	virtual STDMETHODIMP _get_IsOptional(bool *value);
	virtual STDMETHODIMP _VerifyContentIntegrityAsync(Foundation::IAsyncOperation<bool>* *operation);
};
template<typename X> struct IPackage4_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackage4_adaptor::IsOptional)->_get_IsOptional(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsOptional;
		struct : property {
			PackageSignatureKind get() { PackageSignatureKind value; hrcheck(enc(&IPackage4_adaptor::SignatureKind)->_get_SignatureKind(&value)); return value; }
			PackageSignatureKind operator()() { return get(); }
			operator PackageSignatureKind () { return get(); }
		} SignatureKind;
	};
	ptr<Foundation::IAsyncOperation<bool>> VerifyContentIntegrityAsync() { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_VerifyContentIntegrityAsync(&operation)); return from_abi(operation); }
	IPackage4_adaptor() {}
};
template<typename X> struct adapt<IPackage4, X> : Windows::ApplicationModel::IPackage4_adaptor<X> { typedef adapt IPackage4; };
struct IPackage4 : IPackage4_raw, generate<IPackage4> {};

// IPackage3
struct IPackage3_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(PackageStatus* *value);
	virtual STDMETHODIMP _get_InstalledDate(Foundation::DateTime *value);
	virtual STDMETHODIMP _GetAppListEntriesAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Core::AppListEntry*>*>* *operation);
};
template<typename X> struct IPackage3_adaptor : X {
	union {
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IPackage3_adaptor::InstalledDate)->_get_InstalledDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} InstalledDate;
		struct : property {
			ptr<PackageStatus> get() { PackageStatus* value; hrcheck(enc(&IPackage3_adaptor::Status)->_get_Status(&value)); return from_abi(value); }
			ptr<PackageStatus> operator()() { return get(); }
			operator ptr<PackageStatus> () { return get(); }
			ptr<PackageStatus> operator->() { return get(); }
		} Status;
	};
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<Core::AppListEntry>>>>> GetAppListEntriesAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Core::AppListEntry*>*>* operation; hrcheck(X::get()->_GetAppListEntriesAsync(&operation)); return from_abi(operation); }
	IPackage3_adaptor() {}
};
template<typename X> struct adapt<IPackage3, X> : Windows::ApplicationModel::IPackage3_adaptor<X> { typedef adapt IPackage3; };
struct IPackage3 : IPackage3_raw, generate<IPackage3> {};

// IPackage2
struct IPackage2_raw : IInspectable {
	virtual STDMETHODIMP _get_DisplayName(HSTRING *value);
	virtual STDMETHODIMP _get_PublisherDisplayName(HSTRING *value);
	virtual STDMETHODIMP _get_Description(HSTRING *value);
	virtual STDMETHODIMP _get_Logo(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_IsResourcePackage(bool *value);
	virtual STDMETHODIMP _get_IsBundle(bool *value);
	virtual STDMETHODIMP _get_IsDevelopmentMode(bool *value);
};
template<typename X> struct IPackage2_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackage2_adaptor::Description)->_get_Description(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Description;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackage2_adaptor::DisplayName)->_get_DisplayName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DisplayName;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackage2_adaptor::IsBundle)->_get_IsBundle(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsBundle;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackage2_adaptor::IsDevelopmentMode)->_get_IsDevelopmentMode(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsDevelopmentMode;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackage2_adaptor::IsResourcePackage)->_get_IsResourcePackage(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsResourcePackage;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IPackage2_adaptor::Logo)->_get_Logo(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Logo;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackage2_adaptor::PublisherDisplayName)->_get_PublisherDisplayName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PublisherDisplayName;
	};
	IPackage2_adaptor() {}
};
template<typename X> struct adapt<IPackage2, X> : Windows::ApplicationModel::IPackage2_adaptor<X> { typedef adapt IPackage2; };
struct IPackage2 : IPackage2_raw, generate<IPackage2> {};

// Package
template<typename> struct Package_statics {
	static struct _Current : property {
		ptr<Package> get() { Package* value; hrcheck(get_activation_factory<Package, IPackageStatics>()->_get_Current(&value)); return from_abi(value); }
		ptr<Package> operator()() { return get(); }
		operator ptr<Package> () { return get(); }
		ptr<Package> operator->() { return get(); }
	} Current;
};
template<typename X> typename Package_statics<X>::_Current Package_statics<X>::Current;

template<typename X> struct statics<Package, X> : X, Windows::ApplicationModel::Package_statics<void> {
	typedef typename X::root_type Package;
};
struct Package : generate<Package> {
	using IPackage5::StageContentGroupsAsync;
};

// IPackageContentGroupStatics
struct IPackageContentGroupStatics : IInspectable {
	virtual STDMETHODIMP _get_RequiredGroupName(HSTRING *value);
};

// IPackageContentGroup
struct IPackageContentGroup_raw : IInspectable {
	virtual STDMETHODIMP _get_Package(ApplicationModel::Package* *value);
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_State(PackageContentGroupState *value);
	virtual STDMETHODIMP _get_IsRequired(bool *value);
};
template<typename X> struct IPackageContentGroup_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageContentGroup_adaptor::IsRequired)->_get_IsRequired(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsRequired;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackageContentGroup_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			ptr<ApplicationModel::Package> get() { ApplicationModel::Package* value; hrcheck(enc(&IPackageContentGroup_adaptor::Package)->_get_Package(&value)); return from_abi(value); }
			ptr<ApplicationModel::Package> operator()() { return get(); }
			operator ptr<ApplicationModel::Package> () { return get(); }
			ptr<ApplicationModel::Package> operator->() { return get(); }
		} Package;
		struct : property {
			PackageContentGroupState get() { PackageContentGroupState value; hrcheck(enc(&IPackageContentGroup_adaptor::State)->_get_State(&value)); return value; }
			PackageContentGroupState operator()() { return get(); }
			operator PackageContentGroupState () { return get(); }
		} State;
	};
	IPackageContentGroup_adaptor() {}
};
template<typename X> struct adapt<IPackageContentGroup, X> : Windows::ApplicationModel::IPackageContentGroup_adaptor<X> { typedef adapt IPackageContentGroup; };
struct IPackageContentGroup : IPackageContentGroup_raw, generate<IPackageContentGroup> {};

// PackageContentGroup
template<typename> struct PackageContentGroup_statics {
	static struct _RequiredGroupName : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<PackageContentGroup, IPackageContentGroupStatics>()->_get_RequiredGroupName(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} RequiredGroupName;
};
template<typename X> typename PackageContentGroup_statics<X>::_RequiredGroupName PackageContentGroup_statics<X>::RequiredGroupName;

template<typename X> struct statics<PackageContentGroup, X> : X, Windows::ApplicationModel::PackageContentGroup_statics<void> {
	typedef typename X::root_type PackageContentGroup;
};
struct PackageContentGroup : generate<PackageContentGroup> {};

// IPackageStagingEventArgs
struct IPackageStagingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ActivityId(Platform::Guid *value);
	virtual STDMETHODIMP _get_Package(ApplicationModel::Package* *value);
	virtual STDMETHODIMP _get_Progress(double *value);
	virtual STDMETHODIMP _get_IsComplete(bool *value);
	virtual STDMETHODIMP _get_ErrorCode(Foundation::HResult *value);
};
template<typename X> struct IPackageStagingEventArgs_adaptor : X {
	union {
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPackageStagingEventArgs_adaptor::ActivityId)->_get_ActivityId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} ActivityId;
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IPackageStagingEventArgs_adaptor::ErrorCode)->_get_ErrorCode(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ErrorCode;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageStagingEventArgs_adaptor::IsComplete)->_get_IsComplete(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsComplete;
		struct : property {
			ptr<ApplicationModel::Package> get() { ApplicationModel::Package* value; hrcheck(enc(&IPackageStagingEventArgs_adaptor::Package)->_get_Package(&value)); return from_abi(value); }
			ptr<ApplicationModel::Package> operator()() { return get(); }
			operator ptr<ApplicationModel::Package> () { return get(); }
			ptr<ApplicationModel::Package> operator->() { return get(); }
		} Package;
		struct : property {
			double get() { double value; hrcheck(enc(&IPackageStagingEventArgs_adaptor::Progress)->_get_Progress(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} Progress;
	};
	IPackageStagingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IPackageStagingEventArgs, X> : Windows::ApplicationModel::IPackageStagingEventArgs_adaptor<X> { typedef adapt IPackageStagingEventArgs; };
struct IPackageStagingEventArgs : IPackageStagingEventArgs_raw, generate<IPackageStagingEventArgs> {};

// PackageStagingEventArgs
template<typename X> struct statics<PackageStagingEventArgs, X> : X {
	typedef typename X::root_type PackageStagingEventArgs;
};
struct PackageStagingEventArgs : generate<PackageStagingEventArgs> {};

// IPackageInstallingEventArgs
struct IPackageInstallingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ActivityId(Platform::Guid *value);
	virtual STDMETHODIMP _get_Package(ApplicationModel::Package* *value);
	virtual STDMETHODIMP _get_Progress(double *value);
	virtual STDMETHODIMP _get_IsComplete(bool *value);
	virtual STDMETHODIMP _get_ErrorCode(Foundation::HResult *value);
};
template<typename X> struct IPackageInstallingEventArgs_adaptor : X {
	union {
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPackageInstallingEventArgs_adaptor::ActivityId)->_get_ActivityId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} ActivityId;
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IPackageInstallingEventArgs_adaptor::ErrorCode)->_get_ErrorCode(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ErrorCode;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageInstallingEventArgs_adaptor::IsComplete)->_get_IsComplete(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsComplete;
		struct : property {
			ptr<ApplicationModel::Package> get() { ApplicationModel::Package* value; hrcheck(enc(&IPackageInstallingEventArgs_adaptor::Package)->_get_Package(&value)); return from_abi(value); }
			ptr<ApplicationModel::Package> operator()() { return get(); }
			operator ptr<ApplicationModel::Package> () { return get(); }
			ptr<ApplicationModel::Package> operator->() { return get(); }
		} Package;
		struct : property {
			double get() { double value; hrcheck(enc(&IPackageInstallingEventArgs_adaptor::Progress)->_get_Progress(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} Progress;
	};
	IPackageInstallingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IPackageInstallingEventArgs, X> : Windows::ApplicationModel::IPackageInstallingEventArgs_adaptor<X> { typedef adapt IPackageInstallingEventArgs; };
struct IPackageInstallingEventArgs : IPackageInstallingEventArgs_raw, generate<IPackageInstallingEventArgs> {};

// PackageInstallingEventArgs
template<typename X> struct statics<PackageInstallingEventArgs, X> : X {
	typedef typename X::root_type PackageInstallingEventArgs;
};
struct PackageInstallingEventArgs : generate<PackageInstallingEventArgs> {};

// IPackageUpdatingEventArgs
struct IPackageUpdatingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ActivityId(Platform::Guid *value);
	virtual STDMETHODIMP _get_SourcePackage(Package* *value);
	virtual STDMETHODIMP _get_TargetPackage(Package* *value);
	virtual STDMETHODIMP _get_Progress(double *value);
	virtual STDMETHODIMP _get_IsComplete(bool *value);
	virtual STDMETHODIMP _get_ErrorCode(Foundation::HResult *value);
};
template<typename X> struct IPackageUpdatingEventArgs_adaptor : X {
	union {
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPackageUpdatingEventArgs_adaptor::ActivityId)->_get_ActivityId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} ActivityId;
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IPackageUpdatingEventArgs_adaptor::ErrorCode)->_get_ErrorCode(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ErrorCode;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageUpdatingEventArgs_adaptor::IsComplete)->_get_IsComplete(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsComplete;
		struct : property {
			double get() { double value; hrcheck(enc(&IPackageUpdatingEventArgs_adaptor::Progress)->_get_Progress(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} Progress;
		struct : property {
			ptr<Package> get() { Package* value; hrcheck(enc(&IPackageUpdatingEventArgs_adaptor::SourcePackage)->_get_SourcePackage(&value)); return from_abi(value); }
			ptr<Package> operator()() { return get(); }
			operator ptr<Package> () { return get(); }
			ptr<Package> operator->() { return get(); }
		} SourcePackage;
		struct : property {
			ptr<Package> get() { Package* value; hrcheck(enc(&IPackageUpdatingEventArgs_adaptor::TargetPackage)->_get_TargetPackage(&value)); return from_abi(value); }
			ptr<Package> operator()() { return get(); }
			operator ptr<Package> () { return get(); }
			ptr<Package> operator->() { return get(); }
		} TargetPackage;
	};
	IPackageUpdatingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IPackageUpdatingEventArgs, X> : Windows::ApplicationModel::IPackageUpdatingEventArgs_adaptor<X> { typedef adapt IPackageUpdatingEventArgs; };
struct IPackageUpdatingEventArgs : IPackageUpdatingEventArgs_raw, generate<IPackageUpdatingEventArgs> {};

// PackageUpdatingEventArgs
template<typename X> struct statics<PackageUpdatingEventArgs, X> : X {
	typedef typename X::root_type PackageUpdatingEventArgs;
};
struct PackageUpdatingEventArgs : generate<PackageUpdatingEventArgs> {};

// IPackageUninstallingEventArgs
struct IPackageUninstallingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ActivityId(Platform::Guid *value);
	virtual STDMETHODIMP _get_Package(ApplicationModel::Package* *value);
	virtual STDMETHODIMP _get_Progress(double *value);
	virtual STDMETHODIMP _get_IsComplete(bool *value);
	virtual STDMETHODIMP _get_ErrorCode(Foundation::HResult *value);
};
template<typename X> struct IPackageUninstallingEventArgs_adaptor : X {
	union {
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPackageUninstallingEventArgs_adaptor::ActivityId)->_get_ActivityId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} ActivityId;
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IPackageUninstallingEventArgs_adaptor::ErrorCode)->_get_ErrorCode(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ErrorCode;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageUninstallingEventArgs_adaptor::IsComplete)->_get_IsComplete(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsComplete;
		struct : property {
			ptr<ApplicationModel::Package> get() { ApplicationModel::Package* value; hrcheck(enc(&IPackageUninstallingEventArgs_adaptor::Package)->_get_Package(&value)); return from_abi(value); }
			ptr<ApplicationModel::Package> operator()() { return get(); }
			operator ptr<ApplicationModel::Package> () { return get(); }
			ptr<ApplicationModel::Package> operator->() { return get(); }
		} Package;
		struct : property {
			double get() { double value; hrcheck(enc(&IPackageUninstallingEventArgs_adaptor::Progress)->_get_Progress(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} Progress;
	};
	IPackageUninstallingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IPackageUninstallingEventArgs, X> : Windows::ApplicationModel::IPackageUninstallingEventArgs_adaptor<X> { typedef adapt IPackageUninstallingEventArgs; };
struct IPackageUninstallingEventArgs : IPackageUninstallingEventArgs_raw, generate<IPackageUninstallingEventArgs> {};

// PackageUninstallingEventArgs
template<typename X> struct statics<PackageUninstallingEventArgs, X> : X {
	typedef typename X::root_type PackageUninstallingEventArgs;
};
struct PackageUninstallingEventArgs : generate<PackageUninstallingEventArgs> {};

// IPackageStatusChangedEventArgs
struct IPackageStatusChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Package(ApplicationModel::Package* *value);
};
template<typename X> struct IPackageStatusChangedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<ApplicationModel::Package> get() { ApplicationModel::Package* value; hrcheck(enc(&IPackageStatusChangedEventArgs_adaptor::Package)->_get_Package(&value)); return from_abi(value); }
			ptr<ApplicationModel::Package> operator()() { return get(); }
			operator ptr<ApplicationModel::Package> () { return get(); }
			ptr<ApplicationModel::Package> operator->() { return get(); }
		} Package;
	};
	IPackageStatusChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IPackageStatusChangedEventArgs, X> : Windows::ApplicationModel::IPackageStatusChangedEventArgs_adaptor<X> { typedef adapt IPackageStatusChangedEventArgs; };
struct IPackageStatusChangedEventArgs : IPackageStatusChangedEventArgs_raw, generate<IPackageStatusChangedEventArgs> {};

// PackageStatusChangedEventArgs
template<typename X> struct statics<PackageStatusChangedEventArgs, X> : X {
	typedef typename X::root_type PackageStatusChangedEventArgs;
};
struct PackageStatusChangedEventArgs : generate<PackageStatusChangedEventArgs> {};

// IPackageContentGroupStagingEventArgs
struct IPackageContentGroupStagingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ActivityId(Platform::Guid *value);
	virtual STDMETHODIMP _get_Package(ApplicationModel::Package* *value);
	virtual STDMETHODIMP _get_Progress(double *value);
	virtual STDMETHODIMP _get_IsComplete(bool *value);
	virtual STDMETHODIMP _get_ErrorCode(Foundation::HResult *value);
	virtual STDMETHODIMP _get_ContentGroupName(HSTRING *value);
	virtual STDMETHODIMP _get_IsContentGroupRequired(bool *value);
};
template<typename X> struct IPackageContentGroupStagingEventArgs_adaptor : X {
	union {
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IPackageContentGroupStagingEventArgs_adaptor::ActivityId)->_get_ActivityId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} ActivityId;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPackageContentGroupStagingEventArgs_adaptor::ContentGroupName)->_get_ContentGroupName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ContentGroupName;
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IPackageContentGroupStagingEventArgs_adaptor::ErrorCode)->_get_ErrorCode(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ErrorCode;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageContentGroupStagingEventArgs_adaptor::IsComplete)->_get_IsComplete(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsComplete;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageContentGroupStagingEventArgs_adaptor::IsContentGroupRequired)->_get_IsContentGroupRequired(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsContentGroupRequired;
		struct : property {
			ptr<ApplicationModel::Package> get() { ApplicationModel::Package* value; hrcheck(enc(&IPackageContentGroupStagingEventArgs_adaptor::Package)->_get_Package(&value)); return from_abi(value); }
			ptr<ApplicationModel::Package> operator()() { return get(); }
			operator ptr<ApplicationModel::Package> () { return get(); }
			ptr<ApplicationModel::Package> operator->() { return get(); }
		} Package;
		struct : property {
			double get() { double value; hrcheck(enc(&IPackageContentGroupStagingEventArgs_adaptor::Progress)->_get_Progress(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} Progress;
	};
	IPackageContentGroupStagingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IPackageContentGroupStagingEventArgs, X> : Windows::ApplicationModel::IPackageContentGroupStagingEventArgs_adaptor<X> { typedef adapt IPackageContentGroupStagingEventArgs; };
struct IPackageContentGroupStagingEventArgs : IPackageContentGroupStagingEventArgs_raw, generate<IPackageContentGroupStagingEventArgs> {};

// PackageContentGroupStagingEventArgs
template<typename X> struct statics<PackageContentGroupStagingEventArgs, X> : X {
	typedef typename X::root_type PackageContentGroupStagingEventArgs;
};
struct PackageContentGroupStagingEventArgs : generate<PackageContentGroupStagingEventArgs> {};

// IPackageCatalog
struct IPackageCatalog_raw : IInspectable {
	virtual STDMETHODIMP _add_PackageStaging(Foundation::TypedEventHandler<PackageCatalog*, PackageStagingEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PackageStaging(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PackageInstalling(Foundation::TypedEventHandler<PackageCatalog*, PackageInstallingEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PackageInstalling(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PackageUpdating(Foundation::TypedEventHandler<PackageCatalog*, PackageUpdatingEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PackageUpdating(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PackageUninstalling(Foundation::TypedEventHandler<PackageCatalog*, PackageUninstallingEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PackageUninstalling(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PackageStatusChanged(Foundation::TypedEventHandler<PackageCatalog*, PackageStatusChangedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PackageStatusChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IPackageCatalog_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<PackageCatalog>, ptr<PackageInstallingEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPackageCatalog_adaptor::PackageInstalling)->_add_PackageInstalling(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPackageCatalog_adaptor::PackageInstalling)->_remove_PackageInstalling(token)); }
		} PackageInstalling;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<PackageCatalog>, ptr<PackageStagingEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPackageCatalog_adaptor::PackageStaging)->_add_PackageStaging(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPackageCatalog_adaptor::PackageStaging)->_remove_PackageStaging(token)); }
		} PackageStaging;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<PackageCatalog>, ptr<PackageStatusChangedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPackageCatalog_adaptor::PackageStatusChanged)->_add_PackageStatusChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPackageCatalog_adaptor::PackageStatusChanged)->_remove_PackageStatusChanged(token)); }
		} PackageStatusChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<PackageCatalog>, ptr<PackageUninstallingEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPackageCatalog_adaptor::PackageUninstalling)->_add_PackageUninstalling(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPackageCatalog_adaptor::PackageUninstalling)->_remove_PackageUninstalling(token)); }
		} PackageUninstalling;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<PackageCatalog>, ptr<PackageUpdatingEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPackageCatalog_adaptor::PackageUpdating)->_add_PackageUpdating(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPackageCatalog_adaptor::PackageUpdating)->_remove_PackageUpdating(token)); }
		} PackageUpdating;
	};
	IPackageCatalog_adaptor() {}
};
template<typename X> struct adapt<IPackageCatalog, X> : Windows::ApplicationModel::IPackageCatalog_adaptor<X> { typedef adapt IPackageCatalog; };
struct IPackageCatalog : IPackageCatalog_raw, generate<IPackageCatalog> {};

// IPackageCatalogStatics
struct IPackageCatalogStatics : IInspectable {
	virtual STDMETHODIMP _OpenForCurrentPackage(PackageCatalog* *value);
	virtual STDMETHODIMP _OpenForCurrentUser(PackageCatalog* *value);
};

// IPackageCatalog4
struct IPackageCatalog4_raw : IInspectable {
	virtual STDMETHODIMP _AddResourcePackageAsync(HSTRING resourcePackageFamilyName, HSTRING resourceID, AddResourcePackageOptions options, Foundation::IAsyncOperationWithProgress<PackageCatalogAddResourcePackageResult*, PackageInstallProgress>* *operation);
	virtual STDMETHODIMP _RemoveResourcePackagesAsync(Foundation::Collections::IIterable<Package*>* resourcePackages, Foundation::IAsyncOperation<PackageCatalogRemoveResourcePackagesResult*>* *operation);
};
template<typename X> struct IPackageCatalog4_adaptor : X {
	ptr<Foundation::IAsyncOperationWithProgress<ptr<PackageCatalogAddResourcePackageResult>, PackageInstallProgress>> AddResourcePackageAsync(hstring_ref resourcePackageFamilyName, hstring_ref resourceID, AddResourcePackageOptions options) { Foundation::IAsyncOperationWithProgress<PackageCatalogAddResourcePackageResult*, PackageInstallProgress>* operation; hrcheck(X::get()->_AddResourcePackageAsync(resourcePackageFamilyName, resourceID, options, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<PackageCatalogRemoveResourcePackagesResult>>> RemoveResourcePackagesAsync(pptr<Foundation::Collections::IIterable<ptr<Package>>> resourcePackages) { Foundation::IAsyncOperation<PackageCatalogRemoveResourcePackagesResult*>* operation; hrcheck(X::get()->_RemoveResourcePackagesAsync(to_abi(resourcePackages), &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IPackageCatalog4, X> : Windows::ApplicationModel::IPackageCatalog4_adaptor<X> { typedef adapt IPackageCatalog4; };
struct IPackageCatalog4 : IPackageCatalog4_raw, generate<IPackageCatalog4> {};

// IPackageCatalog3
struct IPackageCatalog3_raw : IInspectable {
	virtual STDMETHODIMP _RemoveOptionalPackagesAsync(Foundation::Collections::IIterable<HSTRING>* optionalPackageFamilyNames, Foundation::IAsyncOperation<PackageCatalogRemoveOptionalPackagesResult*>* *operation);
};
template<typename X> struct IPackageCatalog3_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<PackageCatalogRemoveOptionalPackagesResult>>> RemoveOptionalPackagesAsync(pptr<Foundation::Collections::IIterable<hstring>> optionalPackageFamilyNames) { Foundation::IAsyncOperation<PackageCatalogRemoveOptionalPackagesResult*>* operation; hrcheck(X::get()->_RemoveOptionalPackagesAsync(to_abi(optionalPackageFamilyNames), &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IPackageCatalog3, X> : Windows::ApplicationModel::IPackageCatalog3_adaptor<X> { typedef adapt IPackageCatalog3; };
struct IPackageCatalog3 : IPackageCatalog3_raw, generate<IPackageCatalog3> {};

// IPackageCatalog2
struct IPackageCatalog2_raw : IInspectable {
	virtual STDMETHODIMP _add_PackageContentGroupStaging(Foundation::TypedEventHandler<PackageCatalog*, PackageContentGroupStagingEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PackageContentGroupStaging(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _AddOptionalPackageAsync(HSTRING optionalPackageFamilyName, Foundation::IAsyncOperation<PackageCatalogAddOptionalPackageResult*>* *operation);
};
template<typename X> struct IPackageCatalog2_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<PackageCatalog>, ptr<PackageContentGroupStagingEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPackageCatalog2_adaptor::PackageContentGroupStaging)->_add_PackageContentGroupStaging(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPackageCatalog2_adaptor::PackageContentGroupStaging)->_remove_PackageContentGroupStaging(token)); }
		} PackageContentGroupStaging;
	};
	ptr<Foundation::IAsyncOperation<ptr<PackageCatalogAddOptionalPackageResult>>> AddOptionalPackageAsync(hstring_ref optionalPackageFamilyName) { Foundation::IAsyncOperation<PackageCatalogAddOptionalPackageResult*>* operation; hrcheck(X::get()->_AddOptionalPackageAsync(optionalPackageFamilyName, &operation)); return from_abi(operation); }
	IPackageCatalog2_adaptor() {}
};
template<typename X> struct adapt<IPackageCatalog2, X> : Windows::ApplicationModel::IPackageCatalog2_adaptor<X> { typedef adapt IPackageCatalog2; };
struct IPackageCatalog2 : IPackageCatalog2_raw, generate<IPackageCatalog2> {};

// PackageCatalog
template<typename> struct PackageCatalog_statics {
	static ptr<PackageCatalog> OpenForCurrentPackage() { PackageCatalog* value; hrcheck(get_activation_factory<PackageCatalog, IPackageCatalogStatics>()->_OpenForCurrentPackage(&value)); return from_abi(value); }
	static ptr<PackageCatalog> OpenForCurrentUser() { PackageCatalog* value; hrcheck(get_activation_factory<PackageCatalog, IPackageCatalogStatics>()->_OpenForCurrentUser(&value)); return from_abi(value); }
};

template<typename X> struct statics<PackageCatalog, X> : X, Windows::ApplicationModel::PackageCatalog_statics<void> {
	typedef typename X::root_type PackageCatalog;
};
struct PackageCatalog : generate<PackageCatalog> {};

// IPackageCatalogAddOptionalPackageResult
struct IPackageCatalogAddOptionalPackageResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Package(ApplicationModel::Package* *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IPackageCatalogAddOptionalPackageResult_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IPackageCatalogAddOptionalPackageResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			ptr<ApplicationModel::Package> get() { ApplicationModel::Package* value; hrcheck(enc(&IPackageCatalogAddOptionalPackageResult_adaptor::Package)->_get_Package(&value)); return from_abi(value); }
			ptr<ApplicationModel::Package> operator()() { return get(); }
			operator ptr<ApplicationModel::Package> () { return get(); }
			ptr<ApplicationModel::Package> operator->() { return get(); }
		} Package;
	};
	IPackageCatalogAddOptionalPackageResult_adaptor() {}
};
template<typename X> struct adapt<IPackageCatalogAddOptionalPackageResult, X> : Windows::ApplicationModel::IPackageCatalogAddOptionalPackageResult_adaptor<X> { typedef adapt IPackageCatalogAddOptionalPackageResult; };
struct IPackageCatalogAddOptionalPackageResult : IPackageCatalogAddOptionalPackageResult_raw, generate<IPackageCatalogAddOptionalPackageResult> {};

// PackageCatalogAddOptionalPackageResult
template<typename X> struct statics<PackageCatalogAddOptionalPackageResult, X> : X {
	typedef typename X::root_type PackageCatalogAddOptionalPackageResult;
};
struct PackageCatalogAddOptionalPackageResult : generate<PackageCatalogAddOptionalPackageResult> {};

// IPackageCatalogRemoveOptionalPackagesResult
struct IPackageCatalogRemoveOptionalPackagesResult_raw : IInspectable {
	virtual STDMETHODIMP _get_PackagesRemoved(Foundation::Collections::IVectorView<Package*>* *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IPackageCatalogRemoveOptionalPackagesResult_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IPackageCatalogRemoveOptionalPackagesResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Package>>> get() { Foundation::Collections::IVectorView<Package*>* value; hrcheck(enc(&IPackageCatalogRemoveOptionalPackagesResult_adaptor::PackagesRemoved)->_get_PackagesRemoved(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Package>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Package>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Package>>> operator->() { return get(); }
		} PackagesRemoved;
	};
	IPackageCatalogRemoveOptionalPackagesResult_adaptor() {}
};
template<typename X> struct adapt<IPackageCatalogRemoveOptionalPackagesResult, X> : Windows::ApplicationModel::IPackageCatalogRemoveOptionalPackagesResult_adaptor<X> { typedef adapt IPackageCatalogRemoveOptionalPackagesResult; };
struct IPackageCatalogRemoveOptionalPackagesResult : IPackageCatalogRemoveOptionalPackagesResult_raw, generate<IPackageCatalogRemoveOptionalPackagesResult> {};

// PackageCatalogRemoveOptionalPackagesResult
template<typename X> struct statics<PackageCatalogRemoveOptionalPackagesResult, X> : X {
	typedef typename X::root_type PackageCatalogRemoveOptionalPackagesResult;
};
struct PackageCatalogRemoveOptionalPackagesResult : generate<PackageCatalogRemoveOptionalPackagesResult> {};

// IPackageCatalogRemoveResourcePackagesResult
struct IPackageCatalogRemoveResourcePackagesResult_raw : IInspectable {
	virtual STDMETHODIMP _get_PackagesRemoved(Foundation::Collections::IVectorView<Package*>* *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IPackageCatalogRemoveResourcePackagesResult_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IPackageCatalogRemoveResourcePackagesResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Package>>> get() { Foundation::Collections::IVectorView<Package*>* value; hrcheck(enc(&IPackageCatalogRemoveResourcePackagesResult_adaptor::PackagesRemoved)->_get_PackagesRemoved(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Package>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Package>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Package>>> operator->() { return get(); }
		} PackagesRemoved;
	};
	IPackageCatalogRemoveResourcePackagesResult_adaptor() {}
};
template<typename X> struct adapt<IPackageCatalogRemoveResourcePackagesResult, X> : Windows::ApplicationModel::IPackageCatalogRemoveResourcePackagesResult_adaptor<X> { typedef adapt IPackageCatalogRemoveResourcePackagesResult; };
struct IPackageCatalogRemoveResourcePackagesResult : IPackageCatalogRemoveResourcePackagesResult_raw, generate<IPackageCatalogRemoveResourcePackagesResult> {};

// PackageCatalogRemoveResourcePackagesResult
template<typename X> struct statics<PackageCatalogRemoveResourcePackagesResult, X> : X {
	typedef typename X::root_type PackageCatalogRemoveResourcePackagesResult;
};
struct PackageCatalogRemoveResourcePackagesResult : generate<PackageCatalogRemoveResourcePackagesResult> {};

// IPackageCatalogAddResourcePackageResult
struct IPackageCatalogAddResourcePackageResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Package(ApplicationModel::Package* *value);
	virtual STDMETHODIMP _get_IsComplete(bool *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct IPackageCatalogAddResourcePackageResult_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IPackageCatalogAddResourcePackageResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPackageCatalogAddResourcePackageResult_adaptor::IsComplete)->_get_IsComplete(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsComplete;
		struct : property {
			ptr<ApplicationModel::Package> get() { ApplicationModel::Package* value; hrcheck(enc(&IPackageCatalogAddResourcePackageResult_adaptor::Package)->_get_Package(&value)); return from_abi(value); }
			ptr<ApplicationModel::Package> operator()() { return get(); }
			operator ptr<ApplicationModel::Package> () { return get(); }
			ptr<ApplicationModel::Package> operator->() { return get(); }
		} Package;
	};
	IPackageCatalogAddResourcePackageResult_adaptor() {}
};
template<typename X> struct adapt<IPackageCatalogAddResourcePackageResult, X> : Windows::ApplicationModel::IPackageCatalogAddResourcePackageResult_adaptor<X> { typedef adapt IPackageCatalogAddResourcePackageResult; };
struct IPackageCatalogAddResourcePackageResult : IPackageCatalogAddResourcePackageResult_raw, generate<IPackageCatalogAddResourcePackageResult> {};

// PackageCatalogAddResourcePackageResult
template<typename X> struct statics<PackageCatalogAddResourcePackageResult, X> : X {
	typedef typename X::root_type PackageCatalogAddResourcePackageResult;
};
struct PackageCatalogAddResourcePackageResult : generate<PackageCatalogAddResourcePackageResult> {};

// IDesignModeStatics
struct IDesignModeStatics : IInspectable {
	virtual STDMETHODIMP _get_DesignModeEnabled(bool *value);
};

// IDesignModeStatics2
struct IDesignModeStatics2 : IInspectable {
	virtual STDMETHODIMP _get_DesignMode2Enabled(bool *value);
};

// DesignMode
template<typename> struct DesignMode_statics {
	static struct _DesignModeEnabled : property {
		bool get() { bool value; hrcheck(get_activation_factory<DesignMode, IDesignModeStatics>()->_get_DesignModeEnabled(&value)); return value; }
		bool operator()() { return get(); }
		operator bool () { return get(); }
	} DesignModeEnabled;
	static struct _DesignMode2Enabled : property {
		bool get() { bool value; hrcheck(get_activation_factory<DesignMode, IDesignModeStatics2>()->_get_DesignMode2Enabled(&value)); return value; }
		bool operator()() { return get(); }
		operator bool () { return get(); }
	} DesignMode2Enabled;
};
template<typename X> typename DesignMode_statics<X>::_DesignModeEnabled DesignMode_statics<X>::DesignModeEnabled;
template<typename X> typename DesignMode_statics<X>::_DesignMode2Enabled DesignMode_statics<X>::DesignMode2Enabled;

template<typename X> struct statics<DesignMode, X> : X, Windows::ApplicationModel::DesignMode_statics<void> {
	typedef typename X::root_type DesignMode;
};
struct DesignMode : generate<DesignMode> {};

// IAppInstance
struct IAppInstance_raw : IInspectable {
	virtual STDMETHODIMP _get_Key(HSTRING *value);
	virtual STDMETHODIMP _get_IsCurrentInstance(bool *value);
	virtual STDMETHODIMP _RedirectActivationTo();
};
template<typename X> struct IAppInstance_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppInstance_adaptor::IsCurrentInstance)->_get_IsCurrentInstance(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsCurrentInstance;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppInstance_adaptor::Key)->_get_Key(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Key;
	};
	void RedirectActivationTo() { hrcheck(X::get()->_RedirectActivationTo()); }
	IAppInstance_adaptor() {}
};
template<typename X> struct adapt<IAppInstance, X> : Windows::ApplicationModel::IAppInstance_adaptor<X> { typedef adapt IAppInstance; };
struct IAppInstance : IAppInstance_raw, generate<IAppInstance> {};

// IAppInstanceStatics
struct IAppInstanceStatics : IInspectable {
	virtual STDMETHODIMP _get_RecommendedInstance(AppInstance* *value);
	virtual STDMETHODIMP _GetActivatedEventArgs(Activation::IActivatedEventArgs* *result);
	virtual STDMETHODIMP _FindOrRegisterInstanceForKey(HSTRING key, AppInstance* *result);
	virtual STDMETHODIMP _Unregister();
	virtual STDMETHODIMP _GetInstances(Foundation::Collections::IVector<AppInstance*>* *result);
};

// AppInstance
template<typename> struct AppInstance_statics {
	static struct _RecommendedInstance : property {
		ptr<AppInstance> get() { AppInstance* value; hrcheck(get_activation_factory<AppInstance, IAppInstanceStatics>()->_get_RecommendedInstance(&value)); return from_abi(value); }
		ptr<AppInstance> operator()() { return get(); }
		operator ptr<AppInstance> () { return get(); }
		ptr<AppInstance> operator->() { return get(); }
	} RecommendedInstance;
	static ptr<Activation::IActivatedEventArgs> GetActivatedEventArgs() { Activation::IActivatedEventArgs* result; hrcheck(get_activation_factory<AppInstance, IAppInstanceStatics>()->_GetActivatedEventArgs(&result)); return from_abi(result); }
	static ptr<AppInstance> FindOrRegisterInstanceForKey(hstring_ref key) { AppInstance* result; hrcheck(get_activation_factory<AppInstance, IAppInstanceStatics>()->_FindOrRegisterInstanceForKey(key, &result)); return from_abi(result); }
	static void Unregister() { hrcheck(get_activation_factory<AppInstance, IAppInstanceStatics>()->_Unregister()); }
	static ptr<Foundation::Collections::IVector<ptr<AppInstance>>> GetInstances() { Foundation::Collections::IVector<AppInstance*>* result; hrcheck(get_activation_factory<AppInstance, IAppInstanceStatics>()->_GetInstances(&result)); return from_abi(result); }
};
template<typename X> typename AppInstance_statics<X>::_RecommendedInstance AppInstance_statics<X>::RecommendedInstance;

template<typename X> struct statics<AppInstance, X> : X, Windows::ApplicationModel::AppInstance_statics<void> {
	typedef typename X::root_type AppInstance;
};
struct AppInstance : generate<AppInstance> {};

// ISuspendingEventArgs
struct ISuspendingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_SuspendingOperation(ApplicationModel::SuspendingOperation* *value) = 0;
};
template<typename X> struct ISuspendingEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<ApplicationModel::SuspendingOperation> get() { ApplicationModel::SuspendingOperation* value; hrcheck(enc(&ISuspendingEventArgs_adaptor::SuspendingOperation)->_get_SuspendingOperation(&value)); return from_abi(value); }
			ptr<ApplicationModel::SuspendingOperation> operator()() { return get(); }
			operator ptr<ApplicationModel::SuspendingOperation> () { return get(); }
			ptr<ApplicationModel::SuspendingOperation> operator->() { return get(); }
		} SuspendingOperation;
	};
	ISuspendingEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISuspendingEventArgs, X> : Windows::ApplicationModel::ISuspendingEventArgs_adaptor<X> { typedef adapt ISuspendingEventArgs; };
template<typename X> struct ISuspendingEventArgs_unadaptor : X {
	STDMETHODIMP _get_SuspendingOperation(ApplicationModel::SuspendingOperation* *value) { return hrtry([&, this] { get_prop(value, SuspendingOperation); }); }
};
template<typename X> struct unadapt<ISuspendingEventArgs, X> : Windows::ApplicationModel::ISuspendingEventArgs_unadaptor<X> {};
struct ISuspendingEventArgs : ISuspendingEventArgs_raw, generate<ISuspendingEventArgs> {};

// SuspendingEventArgs
template<typename X> struct statics<SuspendingEventArgs, X> : X {
	typedef typename X::root_type SuspendingEventArgs;
};
struct SuspendingEventArgs : generate<SuspendingEventArgs> {};

// ILeavingBackgroundEventArgs
struct ILeavingBackgroundEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _GetDeferral(Foundation::Deferral* *value) = 0;
};
template<typename X> struct ILeavingBackgroundEventArgs_adaptor : X {
	ptr<Foundation::Deferral> GetDeferral() { Foundation::Deferral* value; hrcheck(X::get()->_GetDeferral(&value)); return from_abi(value); }
};
template<typename X> struct adapt<ILeavingBackgroundEventArgs, X> : Windows::ApplicationModel::ILeavingBackgroundEventArgs_adaptor<X> { typedef adapt ILeavingBackgroundEventArgs; };
template<typename X> struct ILeavingBackgroundEventArgs_unadaptor : X {
	STDMETHODIMP _GetDeferral(Foundation::Deferral* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetDeferral()); }); }
};
template<typename X> struct unadapt<ILeavingBackgroundEventArgs, X> : Windows::ApplicationModel::ILeavingBackgroundEventArgs_unadaptor<X> {};
struct ILeavingBackgroundEventArgs : ILeavingBackgroundEventArgs_raw, generate<ILeavingBackgroundEventArgs> {};

// LeavingBackgroundEventArgs
template<typename X> struct statics<LeavingBackgroundEventArgs, X> : X {
	typedef typename X::root_type LeavingBackgroundEventArgs;
};
struct LeavingBackgroundEventArgs : generate<LeavingBackgroundEventArgs> {};

// IEnteredBackgroundEventArgs
struct IEnteredBackgroundEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _GetDeferral(Foundation::Deferral* *value) = 0;
};
template<typename X> struct IEnteredBackgroundEventArgs_adaptor : X {
	ptr<Foundation::Deferral> GetDeferral() { Foundation::Deferral* value; hrcheck(X::get()->_GetDeferral(&value)); return from_abi(value); }
};
template<typename X> struct adapt<IEnteredBackgroundEventArgs, X> : Windows::ApplicationModel::IEnteredBackgroundEventArgs_adaptor<X> { typedef adapt IEnteredBackgroundEventArgs; };
template<typename X> struct IEnteredBackgroundEventArgs_unadaptor : X {
	STDMETHODIMP _GetDeferral(Foundation::Deferral* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetDeferral()); }); }
};
template<typename X> struct unadapt<IEnteredBackgroundEventArgs, X> : Windows::ApplicationModel::IEnteredBackgroundEventArgs_unadaptor<X> {};
struct IEnteredBackgroundEventArgs : IEnteredBackgroundEventArgs_raw, generate<IEnteredBackgroundEventArgs> {};

// EnteredBackgroundEventArgs
template<typename X> struct statics<EnteredBackgroundEventArgs, X> : X {
	typedef typename X::root_type EnteredBackgroundEventArgs;
};
struct EnteredBackgroundEventArgs : generate<EnteredBackgroundEventArgs> {};

// ISuspendingDeferral
struct ISuspendingDeferral_raw : IInspectable {
	virtual STDMETHODIMP _Complete() = 0;
};
template<typename X> struct ISuspendingDeferral_adaptor : X {
	void Complete() { hrcheck(X::get()->_Complete()); }
};
template<typename X> struct adapt<ISuspendingDeferral, X> : Windows::ApplicationModel::ISuspendingDeferral_adaptor<X> { typedef adapt ISuspendingDeferral; };
template<typename X> struct ISuspendingDeferral_unadaptor : X {
	STDMETHODIMP _Complete() { return hrtry([&, this] { X::get()->Complete(); }); }
};
template<typename X> struct unadapt<ISuspendingDeferral, X> : Windows::ApplicationModel::ISuspendingDeferral_unadaptor<X> {};
struct ISuspendingDeferral : ISuspendingDeferral_raw, generate<ISuspendingDeferral> {};

// SuspendingDeferral
template<typename X> struct statics<SuspendingDeferral, X> : X {
	typedef typename X::root_type SuspendingDeferral;
};
struct SuspendingDeferral : generate<SuspendingDeferral> {};

// ISuspendingOperation
struct ISuspendingOperation_raw : IInspectable {
	virtual STDMETHODIMP _GetDeferral(SuspendingDeferral* *deferral) = 0;
	virtual STDMETHODIMP _get_Deadline(Foundation::DateTime *value) = 0;
};
template<typename X> struct ISuspendingOperation_adaptor : X {
	union {
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&ISuspendingOperation_adaptor::Deadline)->_get_Deadline(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} Deadline;
	};
	ptr<SuspendingDeferral> GetDeferral() { SuspendingDeferral* deferral; hrcheck(X::get()->_GetDeferral(&deferral)); return from_abi(deferral); }
	ISuspendingOperation_adaptor() {}
};
template<typename X> struct adapt<ISuspendingOperation, X> : Windows::ApplicationModel::ISuspendingOperation_adaptor<X> { typedef adapt ISuspendingOperation; };
template<typename X> struct ISuspendingOperation_unadaptor : X {
	STDMETHODIMP _GetDeferral(SuspendingDeferral* *deferral) { return hrtry([&, this] { *deferral = to_abi(X::get()->GetDeferral()); }); }
	STDMETHODIMP _get_Deadline(Foundation::DateTime *value) { return hrtry([&, this] { get_prop(value, Deadline); }); }
};
template<typename X> struct unadapt<ISuspendingOperation, X> : Windows::ApplicationModel::ISuspendingOperation_unadaptor<X> {};
struct ISuspendingOperation : ISuspendingOperation_raw, generate<ISuspendingOperation> {};

// SuspendingOperation
template<typename X> struct statics<SuspendingOperation, X> : X {
	typedef typename X::root_type SuspendingOperation;
};
struct SuspendingOperation : generate<SuspendingOperation> {};

// ICameraApplicationManagerStatics
struct ICameraApplicationManagerStatics : IInspectable {
	virtual STDMETHODIMP _ShowInstalledApplicationsUI();
};

// CameraApplicationManager
template<typename> struct CameraApplicationManager_statics {
	static void ShowInstalledApplicationsUI() { hrcheck(get_activation_factory<CameraApplicationManager, ICameraApplicationManagerStatics>()->_ShowInstalledApplicationsUI()); }
};

template<typename X> struct statics<CameraApplicationManager, X> : X, Windows::ApplicationModel::CameraApplicationManager_statics<void> {
	typedef typename X::root_type CameraApplicationManager;
};
struct CameraApplicationManager : generate<CameraApplicationManager> {};
}}
} // namespace iso_winrt
