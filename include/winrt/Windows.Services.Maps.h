#pragma once
// generated by isopod tools
// namespaces:
// Windows.Services.Maps

#include "Windows.Services.Maps.0.h"
#include "Windows.UI.Popups.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Devices { namespace Geolocation {
struct Geopath;
struct Geopoint;
struct IGeoshape;
struct GeoboundingBox;
}}
namespace Foundation { namespace Collections {
template<typename T> struct IIterable;
template<typename T> struct IVectorView;
}}}

// defs

template<> struct def<Windows::Services::Maps::MapRouteOptimization> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::MapRouteRestrictions> : enum_type<unsigned> {};
template<> struct def<Windows::Services::Maps::MapRouteManeuverKind> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::MapManeuverNotices> : enum_type<unsigned> {};
template<> struct def<Windows::Services::Maps::MapLocationFinderStatus> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::MapRouteFinderStatus> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::MapLocationDesiredAccuracy> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::WaypointKind> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::MapServiceDataUsagePreference> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::TrafficCongestion> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::ManeuverWarningKind> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::ManeuverWarningSeverity> : enum_type<int> {};
template<> struct def<Windows::Services::Maps::IMapRouteDrivingOptions> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapRouteDrivingOptions2> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapAddress> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapAddress2> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapLocation> : interface_type<> {};
template<> struct def<Windows::Services::Maps::MapAddress> : class_type<Platform::Object, Windows::Services::Maps::IMapAddress, Windows::Services::Maps::IMapAddress2> {};
template<> struct def<Windows::Services::Maps::IMapLocationFinderResult> : interface_type<> {};
template<> struct def<Windows::Services::Maps::MapLocation> : class_type<Platform::Object, Windows::Services::Maps::IMapLocation> {};
template<> struct def<Windows::Services::Maps::IMapRouteManeuver> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapRouteManeuver2> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapRouteManeuver3> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IManeuverWarning> : interface_type<> {};
template<> struct def<Windows::Services::Maps::ManeuverWarning> : class_type<Platform::Object, Windows::Services::Maps::IManeuverWarning> {};
template<> struct def<Windows::Services::Maps::IMapRouteLeg> : interface_type<> {};
template<> struct def<Windows::Services::Maps::MapRouteManeuver> : class_type<Platform::Object, Windows::Services::Maps::IMapRouteManeuver, Windows::Services::Maps::IMapRouteManeuver2, Windows::Services::Maps::IMapRouteManeuver3> {};
template<> struct def<Windows::Services::Maps::IMapRouteLeg2> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapRoute> : interface_type<> {};
template<> struct def<Windows::Services::Maps::MapRouteLeg> : class_type<Platform::Object, Windows::Services::Maps::IMapRouteLeg, Windows::Services::Maps::IMapRouteLeg2> {};
template<> struct def<Windows::Services::Maps::IMapRoute2> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapRoute3> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapRoute4> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapRouteFinderResult> : interface_type<> {};
template<> struct def<Windows::Services::Maps::MapRoute> : class_type<Platform::Object, Windows::Services::Maps::IMapRoute, Windows::Services::Maps::IMapRoute2, Windows::Services::Maps::IMapRoute3, Windows::Services::Maps::IMapRoute4> {};
template<> struct def<Windows::Services::Maps::IMapRouteFinderResult2> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IEnhancedWaypoint> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IEnhancedWaypointFactory> : interface_type<> {};
template<> struct def<Windows::Services::Maps::EnhancedWaypoint> : class_type<Platform::Object, Windows::Services::Maps::IEnhancedWaypoint>, custom_activators {};
template<> struct def<Windows::Services::Maps::IMapLocationFinderStatics> : interface_type<> {};
template<> struct def<Windows::Services::Maps::MapLocationFinderResult> : class_type<Platform::Object, Windows::Services::Maps::IMapLocationFinderResult> {};
template<> struct def<Windows::Services::Maps::IMapLocationFinderStatics2> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapRouteFinderStatics> : interface_type<> {};
template<> struct def<Windows::Services::Maps::MapRouteFinderResult> : class_type<Platform::Object, Windows::Services::Maps::IMapRouteFinderResult, Windows::Services::Maps::IMapRouteFinderResult2> {};
template<> struct def<Windows::Services::Maps::IMapRouteFinderStatics2> : interface_type<> {};
template<> struct def<Windows::Services::Maps::MapRouteDrivingOptions> : class_type<Platform::Object, Windows::Services::Maps::IMapRouteDrivingOptions, Windows::Services::Maps::IMapRouteDrivingOptions2> {};
template<> struct def<Windows::Services::Maps::IMapRouteFinderStatics3> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapServiceStatics> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapManagerStatics> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapServiceStatics2> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapServiceStatics3> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IMapServiceStatics4> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IPlaceInfoCreateOptions> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IPlaceInfoStatics> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IPlaceInfoStatics2> : interface_type<> {};
template<> struct def<Windows::Services::Maps::IPlaceInfo> : interface_type<> {};
template<> struct def<Windows::Services::Maps::PlaceInfo> : class_type<Platform::Object, Windows::Services::Maps::IPlaceInfo> {};
template<> struct def<Windows::Services::Maps::PlaceInfoCreateOptions> : class_type<Platform::Object, Windows::Services::Maps::IPlaceInfoCreateOptions> {};
template<> struct def<Windows::Services::Maps::MapLocationFinder> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Services::Maps::MapRouteFinder> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Services::Maps::MapService> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Services::Maps::MapManager> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Services::Maps::GuidanceContract> : value_type<> {};
template<> struct def<Windows::Services::Maps::LocalSearchContract> : value_type<> {};

// uuids

template<> struct uuid<Windows::Services::Maps::IMapRouteDrivingOptions> { define_guid(0x6815364D, 0xC6DC, 0x4697, 0xA4, 0x52, 0xB1, 0x8F, 0x8F, 0xB, 0x67, 0xA1);};
template<> struct uuid<Windows::Services::Maps::IMapRouteDrivingOptions2> { define_guid(0x35DC8670, 0xC298, 0x48D0, 0xB5, 0xAD, 0x82, 0x54, 0x60, 0x64, 0x56, 0x3);};
template<> struct uuid<Windows::Services::Maps::IMapAddress> { define_guid(0xCFA7A973, 0xA3B4, 0x4494, 0xB3, 0xFF, 0xCB, 0xA9, 0x4D, 0xB6, 0x96, 0x99);};
template<> struct uuid<Windows::Services::Maps::IMapAddress2> { define_guid(0x75CD6DF1, 0xE5AD, 0x45A9, 0xBF, 0x40, 0x6C, 0xF2, 0x56, 0xC1, 0xDD, 0x13);};
template<> struct uuid<Windows::Services::Maps::IMapLocation> { define_guid(0x3C073F57, 0xDA4, 0x42E8, 0x9E, 0xE2, 0xA9, 0x6F, 0xCF, 0x23, 0x71, 0xDC);};
template<> struct uuid<Windows::Services::Maps::IMapLocationFinderResult> { define_guid(0x43F1F179, 0xE8CC, 0x45F6, 0xBE, 0xD2, 0x54, 0xCC, 0xBF, 0x96, 0x5D, 0x9A);};
template<> struct uuid<Windows::Services::Maps::IMapRouteManeuver> { define_guid(0xED5C17F0, 0xA6AB, 0x4D65, 0xA0, 0x86, 0xFA, 0x8A, 0x7E, 0x34, 0xD, 0xF2);};
template<> struct uuid<Windows::Services::Maps::IMapRouteManeuver2> { define_guid(0x5D7BCD9C, 0x7C9B, 0x41DF, 0x83, 0x8B, 0xEA, 0xE2, 0x1E, 0x4B, 0x5, 0xA9);};
template<> struct uuid<Windows::Services::Maps::IMapRouteManeuver3> { define_guid(0xA6A138DF, 0x483, 0x4166, 0x85, 0xBE, 0xB9, 0x93, 0x36, 0xC1, 0x18, 0x75);};
template<> struct uuid<Windows::Services::Maps::IManeuverWarning> { define_guid(0xC1A36D8A, 0x2630, 0x4378, 0x9E, 0x4A, 0x6E, 0x44, 0x25, 0x3D, 0xCE, 0xBA);};
template<> struct uuid<Windows::Services::Maps::IMapRouteLeg> { define_guid(0x96F8B2F6, 0x5BBA, 0x4D17, 0x9D, 0xB6, 0x1A, 0x26, 0x3F, 0xEC, 0x74, 0x71);};
template<> struct uuid<Windows::Services::Maps::IMapRouteLeg2> { define_guid(0x2E2062D, 0xC9C6, 0x45B8, 0x8E, 0x54, 0x1A, 0x10, 0xB5, 0x7A, 0x17, 0xE8);};
template<> struct uuid<Windows::Services::Maps::IMapRoute> { define_guid(0xFB07B732, 0x584D, 0x4583, 0x9C, 0x60, 0x64, 0x1F, 0xEA, 0x27, 0x43, 0x49);};
template<> struct uuid<Windows::Services::Maps::IMapRoute2> { define_guid(0xD1C5D40C, 0x2213, 0x4AB0, 0xA2, 0x60, 0x46, 0xB3, 0x81, 0x69, 0xBE, 0xAC);};
template<> struct uuid<Windows::Services::Maps::IMapRoute3> { define_guid(0x858D1EAE, 0xF2AD, 0x429F, 0xBB, 0x37, 0xCD, 0x21, 0x9, 0x4F, 0xFC, 0x92);};
template<> struct uuid<Windows::Services::Maps::IMapRoute4> { define_guid(0x366C8CA5, 0x3053, 0x4FA1, 0x80, 0xFF, 0xD4, 0x75, 0xF3, 0xED, 0x1E, 0x6E);};
template<> struct uuid<Windows::Services::Maps::IMapRouteFinderResult> { define_guid(0xA868A31A, 0x9422, 0x46AC, 0x8C, 0xA1, 0xB1, 0x61, 0x4D, 0x4B, 0xFB, 0xE2);};
template<> struct uuid<Windows::Services::Maps::IMapRouteFinderResult2> { define_guid(0x20709C6D, 0xD90C, 0x46C8, 0x91, 0xC6, 0x7D, 0x4B, 0xE4, 0xEF, 0xB2, 0x15);};
template<> struct uuid<Windows::Services::Maps::IEnhancedWaypoint> { define_guid(0xED268C74, 0x5913, 0x11E6, 0x8B, 0x77, 0x86, 0xF3, 0xC, 0xA8, 0x93, 0xD3);};
template<> struct uuid<Windows::Services::Maps::IEnhancedWaypointFactory> { define_guid(0xAF868477, 0xA2AA, 0x46DD, 0xB6, 0x45, 0x23, 0xB3, 0x1B, 0x8A, 0xA6, 0xC7);};
template<> struct uuid<Windows::Services::Maps::IMapLocationFinderStatics> { define_guid(0x318ADB5D, 0x1C5D, 0x4F35, 0xA2, 0xDF, 0xAA, 0xCA, 0x94, 0x95, 0x95, 0x17);};
template<> struct uuid<Windows::Services::Maps::IMapLocationFinderStatics2> { define_guid(0x959A8B96, 0x6485, 0x4DFD, 0x85, 0x1A, 0x33, 0xAC, 0x31, 0x7E, 0x3A, 0xF6);};
template<> struct uuid<Windows::Services::Maps::IMapRouteFinderStatics> { define_guid(0xB8A5C50F, 0x1C64, 0x4C3A, 0x81, 0xEB, 0x1F, 0x7C, 0x15, 0x2A, 0xFB, 0xBB);};
template<> struct uuid<Windows::Services::Maps::IMapRouteFinderStatics2> { define_guid(0xAFCC2C73, 0x7760, 0x49AF, 0xB3, 0xBD, 0xBA, 0xF1, 0x35, 0xB7, 0x3, 0xE1);};
template<> struct uuid<Windows::Services::Maps::IMapRouteFinderStatics3> { define_guid(0xF6098134, 0x5913, 0x11E6, 0x8B, 0x77, 0x86, 0xF3, 0xC, 0xA8, 0x93, 0xD3);};
template<> struct uuid<Windows::Services::Maps::IMapServiceStatics> { define_guid(0x144AD85, 0xC04C, 0x4CDD, 0x87, 0x1A, 0xA0, 0x72, 0x6D, 0x9, 0x7C, 0xD4);};
template<> struct uuid<Windows::Services::Maps::IMapManagerStatics> { define_guid(0x37E3E515, 0x82B4, 0x4D54, 0x8F, 0xD9, 0xAF, 0x26, 0x24, 0xB3, 0x1, 0x1C);};
template<> struct uuid<Windows::Services::Maps::IMapServiceStatics2> { define_guid(0xF8193EED, 0x9C85, 0x40A9, 0x88, 0x96, 0xF, 0xC3, 0xFD, 0x2B, 0x7C, 0x2A);};
template<> struct uuid<Windows::Services::Maps::IMapServiceStatics3> { define_guid(0xA11CE20, 0x63A7, 0x4854, 0xB3, 0x55, 0xD6, 0xDC, 0xDA, 0x22, 0x3D, 0x1B);};
template<> struct uuid<Windows::Services::Maps::IMapServiceStatics4> { define_guid(0x88A2862, 0x6ABC, 0x420E, 0x94, 0x5F, 0x4C, 0xFD, 0x89, 0xC6, 0x73, 0x56);};
template<> struct uuid<Windows::Services::Maps::IPlaceInfoCreateOptions> { define_guid(0xCD33C125, 0x67F1, 0x4BB3, 0x99, 0x7, 0xEC, 0xCE, 0x93, 0x9B, 0x3, 0x99);};
template<> struct uuid<Windows::Services::Maps::IPlaceInfoStatics> { define_guid(0x82B9FF71, 0x6CD0, 0x48A4, 0xAF, 0xD9, 0x5E, 0xD8, 0x20, 0x97, 0x93, 0x6B);};
template<> struct uuid<Windows::Services::Maps::IPlaceInfoStatics2> { define_guid(0x730F0249, 0x4047, 0x44A3, 0x8F, 0x81, 0x25, 0x50, 0xA5, 0x21, 0x63, 0x70);};
template<> struct uuid<Windows::Services::Maps::IPlaceInfo> { define_guid(0x9A0810B6, 0x31C8, 0x4F6A, 0x9F, 0x18, 0x95, 0xB, 0x4C, 0x38, 0x95, 0x1A);};

// types

namespace Windows { namespace Services { namespace Maps {

// IMapRouteDrivingOptions
struct IMapRouteDrivingOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_MaxAlternateRouteCount(unsigned *value);
	virtual STDMETHODIMP _put_MaxAlternateRouteCount(unsigned value);
	virtual STDMETHODIMP _get_InitialHeading(Foundation::IReference<double>* *value);
	virtual STDMETHODIMP _put_InitialHeading(Foundation::IReference<double>* value);
	virtual STDMETHODIMP _get_RouteOptimization(MapRouteOptimization *value);
	virtual STDMETHODIMP _put_RouteOptimization(MapRouteOptimization value);
	virtual STDMETHODIMP _get_RouteRestrictions(MapRouteRestrictions *value);
	virtual STDMETHODIMP _put_RouteRestrictions(MapRouteRestrictions value);
};
template<typename X> struct IMapRouteDrivingOptions_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<double>> get() { Foundation::IReference<double>* value; hrcheck(enc(&IMapRouteDrivingOptions_adaptor::InitialHeading)->_get_InitialHeading(&value)); return from_abi(value); }
			ptr<Foundation::IReference<double>> operator()() { return get(); }
			operator ptr<Foundation::IReference<double>> () { return get(); }
			ptr<Foundation::IReference<double>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<double>> value) { hrcheck(enc(&IMapRouteDrivingOptions_adaptor::InitialHeading)->_put_InitialHeading(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<double>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<double>> value) { put(to_abi(value)); }
		} InitialHeading;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IMapRouteDrivingOptions_adaptor::MaxAlternateRouteCount)->_get_MaxAlternateRouteCount(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IMapRouteDrivingOptions_adaptor::MaxAlternateRouteCount)->_put_MaxAlternateRouteCount(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} MaxAlternateRouteCount;
		struct : property {
			MapRouteOptimization get() { MapRouteOptimization value; hrcheck(enc(&IMapRouteDrivingOptions_adaptor::RouteOptimization)->_get_RouteOptimization(&value)); return value; }
			MapRouteOptimization operator()() { return get(); }
			operator MapRouteOptimization () { return get(); }
			void put(MapRouteOptimization value) { hrcheck(enc(&IMapRouteDrivingOptions_adaptor::RouteOptimization)->_put_RouteOptimization(value)); }
			void operator=(MapRouteOptimization value) { put(value); }
			void operator()(MapRouteOptimization value) { put(value); }
		} RouteOptimization;
		struct : property {
			MapRouteRestrictions get() { MapRouteRestrictions value; hrcheck(enc(&IMapRouteDrivingOptions_adaptor::RouteRestrictions)->_get_RouteRestrictions(&value)); return value; }
			MapRouteRestrictions operator()() { return get(); }
			operator MapRouteRestrictions () { return get(); }
			void put(MapRouteRestrictions value) { hrcheck(enc(&IMapRouteDrivingOptions_adaptor::RouteRestrictions)->_put_RouteRestrictions(value)); }
			void operator=(MapRouteRestrictions value) { put(value); }
			void operator()(MapRouteRestrictions value) { put(value); }
		} RouteRestrictions;
	};
	IMapRouteDrivingOptions_adaptor() {}
};
template<typename X> struct adapt<IMapRouteDrivingOptions, X> : Windows::Services::Maps::IMapRouteDrivingOptions_adaptor<X> { typedef adapt IMapRouteDrivingOptions; };
struct IMapRouteDrivingOptions : IMapRouteDrivingOptions_raw, generate<IMapRouteDrivingOptions> {};

// IMapRouteDrivingOptions2
struct IMapRouteDrivingOptions2_raw : IInspectable {
	virtual STDMETHODIMP _get_DepartureTime(Foundation::IReference<Foundation::DateTime>* *value);
	virtual STDMETHODIMP _put_DepartureTime(Foundation::IReference<Foundation::DateTime>* value);
};
template<typename X> struct IMapRouteDrivingOptions2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Foundation::DateTime>> get() { Foundation::IReference<Foundation::DateTime>* value; hrcheck(enc(&IMapRouteDrivingOptions2_adaptor::DepartureTime)->_get_DepartureTime(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::DateTime>> value) { hrcheck(enc(&IMapRouteDrivingOptions2_adaptor::DepartureTime)->_put_DepartureTime(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
		} DepartureTime;
	};
	IMapRouteDrivingOptions2_adaptor() {}
};
template<typename X> struct adapt<IMapRouteDrivingOptions2, X> : Windows::Services::Maps::IMapRouteDrivingOptions2_adaptor<X> { typedef adapt IMapRouteDrivingOptions2; };
struct IMapRouteDrivingOptions2 : IMapRouteDrivingOptions2_raw, generate<IMapRouteDrivingOptions2> {};

// IMapAddress
struct IMapAddress_raw : IInspectable {
	virtual STDMETHODIMP _get_BuildingName(HSTRING *value);
	virtual STDMETHODIMP _get_BuildingFloor(HSTRING *value);
	virtual STDMETHODIMP _get_BuildingRoom(HSTRING *value);
	virtual STDMETHODIMP _get_BuildingWing(HSTRING *value);
	virtual STDMETHODIMP _get_StreetNumber(HSTRING *value);
	virtual STDMETHODIMP _get_Street(HSTRING *value);
	virtual STDMETHODIMP _get_Neighborhood(HSTRING *value);
	virtual STDMETHODIMP _get_District(HSTRING *value);
	virtual STDMETHODIMP _get_Town(HSTRING *value);
	virtual STDMETHODIMP _get_Region(HSTRING *value);
	virtual STDMETHODIMP _get_RegionCode(HSTRING *value);
	virtual STDMETHODIMP _get_Country(HSTRING *value);
	virtual STDMETHODIMP _get_CountryCode(HSTRING *value);
	virtual STDMETHODIMP _get_PostCode(HSTRING *value);
	virtual STDMETHODIMP _get_Continent(HSTRING *value);
};
template<typename X> struct IMapAddress_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress_adaptor::BuildingFloor)->_get_BuildingFloor(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} BuildingFloor;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress_adaptor::BuildingName)->_get_BuildingName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} BuildingName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress_adaptor::BuildingRoom)->_get_BuildingRoom(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} BuildingRoom;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress_adaptor::BuildingWing)->_get_BuildingWing(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} BuildingWing;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress_adaptor::Continent)->_get_Continent(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Continent;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress_adaptor::Country)->_get_Country(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Country;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress_adaptor::CountryCode)->_get_CountryCode(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} CountryCode;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress_adaptor::District)->_get_District(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} District;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress_adaptor::Neighborhood)->_get_Neighborhood(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Neighborhood;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress_adaptor::PostCode)->_get_PostCode(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PostCode;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress_adaptor::Region)->_get_Region(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Region;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress_adaptor::RegionCode)->_get_RegionCode(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} RegionCode;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress_adaptor::Street)->_get_Street(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Street;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress_adaptor::StreetNumber)->_get_StreetNumber(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} StreetNumber;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress_adaptor::Town)->_get_Town(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Town;
	};
	IMapAddress_adaptor() {}
};
template<typename X> struct adapt<IMapAddress, X> : Windows::Services::Maps::IMapAddress_adaptor<X> { typedef adapt IMapAddress; };
struct IMapAddress : IMapAddress_raw, generate<IMapAddress> {};

// IMapAddress2
struct IMapAddress2_raw : IInspectable {
	virtual STDMETHODIMP _get_FormattedAddress(HSTRING *value);
};
template<typename X> struct IMapAddress2_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapAddress2_adaptor::FormattedAddress)->_get_FormattedAddress(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} FormattedAddress;
	};
	IMapAddress2_adaptor() {}
};
template<typename X> struct adapt<IMapAddress2, X> : Windows::Services::Maps::IMapAddress2_adaptor<X> { typedef adapt IMapAddress2; };
struct IMapAddress2 : IMapAddress2_raw, generate<IMapAddress2> {};

// IMapLocation
struct IMapLocation_raw : IInspectable {
	virtual STDMETHODIMP _get_Point(Devices::Geolocation::Geopoint* *value);
	virtual STDMETHODIMP _get_DisplayName(HSTRING *value);
	virtual STDMETHODIMP _get_Description(HSTRING *value);
	virtual STDMETHODIMP _get_Address(MapAddress* *value);
};
template<typename X> struct IMapLocation_adaptor : X {
	union {
		struct : property {
			ptr<MapAddress> get() { MapAddress* value; hrcheck(enc(&IMapLocation_adaptor::Address)->_get_Address(&value)); return from_abi(value); }
			ptr<MapAddress> operator()() { return get(); }
			operator ptr<MapAddress> () { return get(); }
			ptr<MapAddress> operator->() { return get(); }
		} Address;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapLocation_adaptor::Description)->_get_Description(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Description;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapLocation_adaptor::DisplayName)->_get_DisplayName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DisplayName;
		struct : property {
			ptr<Devices::Geolocation::Geopoint> get() { Devices::Geolocation::Geopoint* value; hrcheck(enc(&IMapLocation_adaptor::Point)->_get_Point(&value)); return from_abi(value); }
			ptr<Devices::Geolocation::Geopoint> operator()() { return get(); }
			operator ptr<Devices::Geolocation::Geopoint> () { return get(); }
			ptr<Devices::Geolocation::Geopoint> operator->() { return get(); }
		} Point;
	};
	IMapLocation_adaptor() {}
};
template<typename X> struct adapt<IMapLocation, X> : Windows::Services::Maps::IMapLocation_adaptor<X> { typedef adapt IMapLocation; };
struct IMapLocation : IMapLocation_raw, generate<IMapLocation> {};

// MapAddress
template<typename X> struct statics<MapAddress, X> : X {
	typedef typename X::root_type MapAddress;
};
struct MapAddress : generate<MapAddress> {};

// IMapLocationFinderResult
struct IMapLocationFinderResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Locations(Foundation::Collections::IVectorView<MapLocation*>* *value);
	virtual STDMETHODIMP _get_Status(MapLocationFinderStatus *value);
};
template<typename X> struct IMapLocationFinderResult_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<MapLocation>>> get() { Foundation::Collections::IVectorView<MapLocation*>* value; hrcheck(enc(&IMapLocationFinderResult_adaptor::Locations)->_get_Locations(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<MapLocation>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<MapLocation>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<MapLocation>>> operator->() { return get(); }
		} Locations;
		struct : property {
			MapLocationFinderStatus get() { MapLocationFinderStatus value; hrcheck(enc(&IMapLocationFinderResult_adaptor::Status)->_get_Status(&value)); return value; }
			MapLocationFinderStatus operator()() { return get(); }
			operator MapLocationFinderStatus () { return get(); }
		} Status;
	};
	IMapLocationFinderResult_adaptor() {}
};
template<typename X> struct adapt<IMapLocationFinderResult, X> : Windows::Services::Maps::IMapLocationFinderResult_adaptor<X> { typedef adapt IMapLocationFinderResult; };
struct IMapLocationFinderResult : IMapLocationFinderResult_raw, generate<IMapLocationFinderResult> {};

// MapLocation
template<typename X> struct statics<MapLocation, X> : X {
	typedef typename X::root_type MapLocation;
};
struct MapLocation : generate<MapLocation> {};

// IMapRouteManeuver
struct IMapRouteManeuver_raw : IInspectable {
	virtual STDMETHODIMP _get_StartingPoint(Devices::Geolocation::Geopoint* *value);
	virtual STDMETHODIMP _get_LengthInMeters(double *value);
	virtual STDMETHODIMP _get_InstructionText(HSTRING *value);
	virtual STDMETHODIMP _get_Kind(MapRouteManeuverKind *value);
	virtual STDMETHODIMP _get_ExitNumber(HSTRING *value);
	virtual STDMETHODIMP _get_ManeuverNotices(MapManeuverNotices *value);
};
template<typename X> struct IMapRouteManeuver_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapRouteManeuver_adaptor::ExitNumber)->_get_ExitNumber(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ExitNumber;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapRouteManeuver_adaptor::InstructionText)->_get_InstructionText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} InstructionText;
		struct : property {
			MapRouteManeuverKind get() { MapRouteManeuverKind value; hrcheck(enc(&IMapRouteManeuver_adaptor::Kind)->_get_Kind(&value)); return value; }
			MapRouteManeuverKind operator()() { return get(); }
			operator MapRouteManeuverKind () { return get(); }
		} Kind;
		struct : property {
			double get() { double value; hrcheck(enc(&IMapRouteManeuver_adaptor::LengthInMeters)->_get_LengthInMeters(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} LengthInMeters;
		struct : property {
			MapManeuverNotices get() { MapManeuverNotices value; hrcheck(enc(&IMapRouteManeuver_adaptor::ManeuverNotices)->_get_ManeuverNotices(&value)); return value; }
			MapManeuverNotices operator()() { return get(); }
			operator MapManeuverNotices () { return get(); }
		} ManeuverNotices;
		struct : property {
			ptr<Devices::Geolocation::Geopoint> get() { Devices::Geolocation::Geopoint* value; hrcheck(enc(&IMapRouteManeuver_adaptor::StartingPoint)->_get_StartingPoint(&value)); return from_abi(value); }
			ptr<Devices::Geolocation::Geopoint> operator()() { return get(); }
			operator ptr<Devices::Geolocation::Geopoint> () { return get(); }
			ptr<Devices::Geolocation::Geopoint> operator->() { return get(); }
		} StartingPoint;
	};
	IMapRouteManeuver_adaptor() {}
};
template<typename X> struct adapt<IMapRouteManeuver, X> : Windows::Services::Maps::IMapRouteManeuver_adaptor<X> { typedef adapt IMapRouteManeuver; };
struct IMapRouteManeuver : IMapRouteManeuver_raw, generate<IMapRouteManeuver> {};

// IMapRouteManeuver2
struct IMapRouteManeuver2_raw : IInspectable {
	virtual STDMETHODIMP _get_StartHeading(double *value);
	virtual STDMETHODIMP _get_EndHeading(double *value);
	virtual STDMETHODIMP _get_StreetName(HSTRING *value);
};
template<typename X> struct IMapRouteManeuver2_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IMapRouteManeuver2_adaptor::EndHeading)->_get_EndHeading(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} EndHeading;
		struct : property {
			double get() { double value; hrcheck(enc(&IMapRouteManeuver2_adaptor::StartHeading)->_get_StartHeading(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} StartHeading;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMapRouteManeuver2_adaptor::StreetName)->_get_StreetName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} StreetName;
	};
	IMapRouteManeuver2_adaptor() {}
};
template<typename X> struct adapt<IMapRouteManeuver2, X> : Windows::Services::Maps::IMapRouteManeuver2_adaptor<X> { typedef adapt IMapRouteManeuver2; };
struct IMapRouteManeuver2 : IMapRouteManeuver2_raw, generate<IMapRouteManeuver2> {};

// IMapRouteManeuver3
struct IMapRouteManeuver3_raw : IInspectable {
	virtual STDMETHODIMP _get_Warnings(Foundation::Collections::IVectorView<ManeuverWarning*>* *value);
};
template<typename X> struct IMapRouteManeuver3_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<ManeuverWarning>>> get() { Foundation::Collections::IVectorView<ManeuverWarning*>* value; hrcheck(enc(&IMapRouteManeuver3_adaptor::Warnings)->_get_Warnings(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<ManeuverWarning>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<ManeuverWarning>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<ManeuverWarning>>> operator->() { return get(); }
		} Warnings;
	};
	IMapRouteManeuver3_adaptor() {}
};
template<typename X> struct adapt<IMapRouteManeuver3, X> : Windows::Services::Maps::IMapRouteManeuver3_adaptor<X> { typedef adapt IMapRouteManeuver3; };
struct IMapRouteManeuver3 : IMapRouteManeuver3_raw, generate<IMapRouteManeuver3> {};

// IManeuverWarning
struct IManeuverWarning_raw : IInspectable {
	virtual STDMETHODIMP _get_Kind(ManeuverWarningKind *value);
	virtual STDMETHODIMP _get_Severity(ManeuverWarningSeverity *value);
};
template<typename X> struct IManeuverWarning_adaptor : X {
	union {
		struct : property {
			ManeuverWarningKind get() { ManeuverWarningKind value; hrcheck(enc(&IManeuverWarning_adaptor::Kind)->_get_Kind(&value)); return value; }
			ManeuverWarningKind operator()() { return get(); }
			operator ManeuverWarningKind () { return get(); }
		} Kind;
		struct : property {
			ManeuverWarningSeverity get() { ManeuverWarningSeverity value; hrcheck(enc(&IManeuverWarning_adaptor::Severity)->_get_Severity(&value)); return value; }
			ManeuverWarningSeverity operator()() { return get(); }
			operator ManeuverWarningSeverity () { return get(); }
		} Severity;
	};
	IManeuverWarning_adaptor() {}
};
template<typename X> struct adapt<IManeuverWarning, X> : Windows::Services::Maps::IManeuverWarning_adaptor<X> { typedef adapt IManeuverWarning; };
struct IManeuverWarning : IManeuverWarning_raw, generate<IManeuverWarning> {};

// ManeuverWarning
template<typename X> struct statics<ManeuverWarning, X> : X {
	typedef typename X::root_type ManeuverWarning;
};
struct ManeuverWarning : generate<ManeuverWarning> {};

// IMapRouteLeg
struct IMapRouteLeg_raw : IInspectable {
	virtual STDMETHODIMP _get_BoundingBox(Devices::Geolocation::GeoboundingBox* *value);
	virtual STDMETHODIMP _get_Path(Devices::Geolocation::Geopath* *value);
	virtual STDMETHODIMP _get_LengthInMeters(double *value);
	virtual STDMETHODIMP _get_EstimatedDuration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_Maneuvers(Foundation::Collections::IVectorView<MapRouteManeuver*>* *value);
};
template<typename X> struct IMapRouteLeg_adaptor : X {
	union {
		struct : property {
			ptr<Devices::Geolocation::GeoboundingBox> get() { Devices::Geolocation::GeoboundingBox* value; hrcheck(enc(&IMapRouteLeg_adaptor::BoundingBox)->_get_BoundingBox(&value)); return from_abi(value); }
			ptr<Devices::Geolocation::GeoboundingBox> operator()() { return get(); }
			operator ptr<Devices::Geolocation::GeoboundingBox> () { return get(); }
			ptr<Devices::Geolocation::GeoboundingBox> operator->() { return get(); }
		} BoundingBox;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMapRouteLeg_adaptor::EstimatedDuration)->_get_EstimatedDuration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} EstimatedDuration;
		struct : property {
			double get() { double value; hrcheck(enc(&IMapRouteLeg_adaptor::LengthInMeters)->_get_LengthInMeters(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} LengthInMeters;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<MapRouteManeuver>>> get() { Foundation::Collections::IVectorView<MapRouteManeuver*>* value; hrcheck(enc(&IMapRouteLeg_adaptor::Maneuvers)->_get_Maneuvers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<MapRouteManeuver>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<MapRouteManeuver>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<MapRouteManeuver>>> operator->() { return get(); }
		} Maneuvers;
		struct : property {
			ptr<Devices::Geolocation::Geopath> get() { Devices::Geolocation::Geopath* value; hrcheck(enc(&IMapRouteLeg_adaptor::Path)->_get_Path(&value)); return from_abi(value); }
			ptr<Devices::Geolocation::Geopath> operator()() { return get(); }
			operator ptr<Devices::Geolocation::Geopath> () { return get(); }
			ptr<Devices::Geolocation::Geopath> operator->() { return get(); }
		} Path;
	};
	IMapRouteLeg_adaptor() {}
};
template<typename X> struct adapt<IMapRouteLeg, X> : Windows::Services::Maps::IMapRouteLeg_adaptor<X> { typedef adapt IMapRouteLeg; };
struct IMapRouteLeg : IMapRouteLeg_raw, generate<IMapRouteLeg> {};

// MapRouteManeuver
template<typename X> struct statics<MapRouteManeuver, X> : X {
	typedef typename X::root_type MapRouteManeuver;
};
struct MapRouteManeuver : generate<MapRouteManeuver> {};

// IMapRouteLeg2
struct IMapRouteLeg2_raw : IInspectable {
	virtual STDMETHODIMP _get_DurationWithoutTraffic(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_TrafficCongestion(Maps::TrafficCongestion *value);
};
template<typename X> struct IMapRouteLeg2_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMapRouteLeg2_adaptor::DurationWithoutTraffic)->_get_DurationWithoutTraffic(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} DurationWithoutTraffic;
		struct : property {
			Maps::TrafficCongestion get() { Maps::TrafficCongestion value; hrcheck(enc(&IMapRouteLeg2_adaptor::TrafficCongestion)->_get_TrafficCongestion(&value)); return value; }
			Maps::TrafficCongestion operator()() { return get(); }
			operator Maps::TrafficCongestion () { return get(); }
		} TrafficCongestion;
	};
	IMapRouteLeg2_adaptor() {}
};
template<typename X> struct adapt<IMapRouteLeg2, X> : Windows::Services::Maps::IMapRouteLeg2_adaptor<X> { typedef adapt IMapRouteLeg2; };
struct IMapRouteLeg2 : IMapRouteLeg2_raw, generate<IMapRouteLeg2> {};

// IMapRoute
struct IMapRoute_raw : IInspectable {
	virtual STDMETHODIMP _get_BoundingBox(Devices::Geolocation::GeoboundingBox* *value);
	virtual STDMETHODIMP _get_LengthInMeters(double *value);
	virtual STDMETHODIMP _get_EstimatedDuration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_Path(Devices::Geolocation::Geopath* *value);
	virtual STDMETHODIMP _get_Legs(Foundation::Collections::IVectorView<MapRouteLeg*>* *value);
	virtual STDMETHODIMP _get_IsTrafficBased(bool *value);
};
template<typename X> struct IMapRoute_adaptor : X {
	union {
		struct : property {
			ptr<Devices::Geolocation::GeoboundingBox> get() { Devices::Geolocation::GeoboundingBox* value; hrcheck(enc(&IMapRoute_adaptor::BoundingBox)->_get_BoundingBox(&value)); return from_abi(value); }
			ptr<Devices::Geolocation::GeoboundingBox> operator()() { return get(); }
			operator ptr<Devices::Geolocation::GeoboundingBox> () { return get(); }
			ptr<Devices::Geolocation::GeoboundingBox> operator->() { return get(); }
		} BoundingBox;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMapRoute_adaptor::EstimatedDuration)->_get_EstimatedDuration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} EstimatedDuration;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMapRoute_adaptor::IsTrafficBased)->_get_IsTrafficBased(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsTrafficBased;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<MapRouteLeg>>> get() { Foundation::Collections::IVectorView<MapRouteLeg*>* value; hrcheck(enc(&IMapRoute_adaptor::Legs)->_get_Legs(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<MapRouteLeg>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<MapRouteLeg>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<MapRouteLeg>>> operator->() { return get(); }
		} Legs;
		struct : property {
			double get() { double value; hrcheck(enc(&IMapRoute_adaptor::LengthInMeters)->_get_LengthInMeters(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} LengthInMeters;
		struct : property {
			ptr<Devices::Geolocation::Geopath> get() { Devices::Geolocation::Geopath* value; hrcheck(enc(&IMapRoute_adaptor::Path)->_get_Path(&value)); return from_abi(value); }
			ptr<Devices::Geolocation::Geopath> operator()() { return get(); }
			operator ptr<Devices::Geolocation::Geopath> () { return get(); }
			ptr<Devices::Geolocation::Geopath> operator->() { return get(); }
		} Path;
	};
	IMapRoute_adaptor() {}
};
template<typename X> struct adapt<IMapRoute, X> : Windows::Services::Maps::IMapRoute_adaptor<X> { typedef adapt IMapRoute; };
struct IMapRoute : IMapRoute_raw, generate<IMapRoute> {};

// MapRouteLeg
template<typename X> struct statics<MapRouteLeg, X> : X {
	typedef typename X::root_type MapRouteLeg;
};
struct MapRouteLeg : generate<MapRouteLeg> {};

// IMapRoute2
struct IMapRoute2_raw : IInspectable {
	virtual STDMETHODIMP _get_ViolatedRestrictions(MapRouteRestrictions *value);
	virtual STDMETHODIMP _get_HasBlockedRoads(bool *value);
};
template<typename X> struct IMapRoute2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMapRoute2_adaptor::HasBlockedRoads)->_get_HasBlockedRoads(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasBlockedRoads;
		struct : property {
			MapRouteRestrictions get() { MapRouteRestrictions value; hrcheck(enc(&IMapRoute2_adaptor::ViolatedRestrictions)->_get_ViolatedRestrictions(&value)); return value; }
			MapRouteRestrictions operator()() { return get(); }
			operator MapRouteRestrictions () { return get(); }
		} ViolatedRestrictions;
	};
	IMapRoute2_adaptor() {}
};
template<typename X> struct adapt<IMapRoute2, X> : Windows::Services::Maps::IMapRoute2_adaptor<X> { typedef adapt IMapRoute2; };
struct IMapRoute2 : IMapRoute2_raw, generate<IMapRoute2> {};

// IMapRoute3
struct IMapRoute3_raw : IInspectable {
	virtual STDMETHODIMP _get_DurationWithoutTraffic(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_TrafficCongestion(Maps::TrafficCongestion *value);
};
template<typename X> struct IMapRoute3_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMapRoute3_adaptor::DurationWithoutTraffic)->_get_DurationWithoutTraffic(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} DurationWithoutTraffic;
		struct : property {
			Maps::TrafficCongestion get() { Maps::TrafficCongestion value; hrcheck(enc(&IMapRoute3_adaptor::TrafficCongestion)->_get_TrafficCongestion(&value)); return value; }
			Maps::TrafficCongestion operator()() { return get(); }
			operator Maps::TrafficCongestion () { return get(); }
		} TrafficCongestion;
	};
	IMapRoute3_adaptor() {}
};
template<typename X> struct adapt<IMapRoute3, X> : Windows::Services::Maps::IMapRoute3_adaptor<X> { typedef adapt IMapRoute3; };
struct IMapRoute3 : IMapRoute3_raw, generate<IMapRoute3> {};

// IMapRoute4
struct IMapRoute4_raw : IInspectable {
	virtual STDMETHODIMP _get_IsScenic(bool *value);
};
template<typename X> struct IMapRoute4_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMapRoute4_adaptor::IsScenic)->_get_IsScenic(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsScenic;
	};
	IMapRoute4_adaptor() {}
};
template<typename X> struct adapt<IMapRoute4, X> : Windows::Services::Maps::IMapRoute4_adaptor<X> { typedef adapt IMapRoute4; };
struct IMapRoute4 : IMapRoute4_raw, generate<IMapRoute4> {};

// IMapRouteFinderResult
struct IMapRouteFinderResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Route(MapRoute* *value);
	virtual STDMETHODIMP _get_Status(MapRouteFinderStatus *value);
};
template<typename X> struct IMapRouteFinderResult_adaptor : X {
	union {
		struct : property {
			ptr<MapRoute> get() { MapRoute* value; hrcheck(enc(&IMapRouteFinderResult_adaptor::Route)->_get_Route(&value)); return from_abi(value); }
			ptr<MapRoute> operator()() { return get(); }
			operator ptr<MapRoute> () { return get(); }
			ptr<MapRoute> operator->() { return get(); }
		} Route;
		struct : property {
			MapRouteFinderStatus get() { MapRouteFinderStatus value; hrcheck(enc(&IMapRouteFinderResult_adaptor::Status)->_get_Status(&value)); return value; }
			MapRouteFinderStatus operator()() { return get(); }
			operator MapRouteFinderStatus () { return get(); }
		} Status;
	};
	IMapRouteFinderResult_adaptor() {}
};
template<typename X> struct adapt<IMapRouteFinderResult, X> : Windows::Services::Maps::IMapRouteFinderResult_adaptor<X> { typedef adapt IMapRouteFinderResult; };
struct IMapRouteFinderResult : IMapRouteFinderResult_raw, generate<IMapRouteFinderResult> {};

// MapRoute
template<typename X> struct statics<MapRoute, X> : X {
	typedef typename X::root_type MapRoute;
};
struct MapRoute : generate<MapRoute> {};

// IMapRouteFinderResult2
struct IMapRouteFinderResult2_raw : IInspectable {
	virtual STDMETHODIMP _get_AlternateRoutes(Foundation::Collections::IVectorView<MapRoute*>* *value);
};
template<typename X> struct IMapRouteFinderResult2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<MapRoute>>> get() { Foundation::Collections::IVectorView<MapRoute*>* value; hrcheck(enc(&IMapRouteFinderResult2_adaptor::AlternateRoutes)->_get_AlternateRoutes(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<MapRoute>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<MapRoute>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<MapRoute>>> operator->() { return get(); }
		} AlternateRoutes;
	};
	IMapRouteFinderResult2_adaptor() {}
};
template<typename X> struct adapt<IMapRouteFinderResult2, X> : Windows::Services::Maps::IMapRouteFinderResult2_adaptor<X> { typedef adapt IMapRouteFinderResult2; };
struct IMapRouteFinderResult2 : IMapRouteFinderResult2_raw, generate<IMapRouteFinderResult2> {};

// IEnhancedWaypoint
struct IEnhancedWaypoint_raw : IInspectable {
	virtual STDMETHODIMP _get_Point(Devices::Geolocation::Geopoint* *value);
	virtual STDMETHODIMP _get_Kind(WaypointKind *value);
};
template<typename X> struct IEnhancedWaypoint_adaptor : X {
	union {
		struct : property {
			WaypointKind get() { WaypointKind value; hrcheck(enc(&IEnhancedWaypoint_adaptor::Kind)->_get_Kind(&value)); return value; }
			WaypointKind operator()() { return get(); }
			operator WaypointKind () { return get(); }
		} Kind;
		struct : property {
			ptr<Devices::Geolocation::Geopoint> get() { Devices::Geolocation::Geopoint* value; hrcheck(enc(&IEnhancedWaypoint_adaptor::Point)->_get_Point(&value)); return from_abi(value); }
			ptr<Devices::Geolocation::Geopoint> operator()() { return get(); }
			operator ptr<Devices::Geolocation::Geopoint> () { return get(); }
			ptr<Devices::Geolocation::Geopoint> operator->() { return get(); }
		} Point;
	};
	IEnhancedWaypoint_adaptor() {}
};
template<typename X> struct adapt<IEnhancedWaypoint, X> : Windows::Services::Maps::IEnhancedWaypoint_adaptor<X> { typedef adapt IEnhancedWaypoint; };
struct IEnhancedWaypoint : IEnhancedWaypoint_raw, generate<IEnhancedWaypoint> {};

// IEnhancedWaypointFactory
struct IEnhancedWaypointFactory : IInspectable {
	virtual STDMETHODIMP _Create(Devices::Geolocation::Geopoint* point, WaypointKind kind, EnhancedWaypoint* *value);
};

// EnhancedWaypoint
template<typename> struct EnhancedWaypoint_statics {
	static EnhancedWaypoint *activate(pptr<Devices::Geolocation::Geopoint> point, WaypointKind kind) { EnhancedWaypoint *value; hrcheck(get_activation_factory<EnhancedWaypoint, IEnhancedWaypointFactory>()->_Create(point, kind, &value)); return value; }
};

template<typename X> struct statics<EnhancedWaypoint, X> : X, Windows::Services::Maps::EnhancedWaypoint_statics<void> {
	using Windows::Services::Maps::EnhancedWaypoint_statics<void>::activate;
	typedef typename X::root_type EnhancedWaypoint;
};
struct EnhancedWaypoint : generate<EnhancedWaypoint> {};

// IMapLocationFinderStatics
struct IMapLocationFinderStatics : IInspectable {
	virtual STDMETHODIMP _FindLocationsAtAsync(Devices::Geolocation::Geopoint* queryPoint, Foundation::IAsyncOperation<MapLocationFinderResult*>* *result);
	virtual STDMETHODIMP _FindLocationsAsync(HSTRING searchText, Devices::Geolocation::Geopoint* referencePoint, Foundation::IAsyncOperation<MapLocationFinderResult*>* *result);
	virtual STDMETHODIMP _FindLocationsWithMaxCountAsync(HSTRING searchText, Devices::Geolocation::Geopoint* referencePoint, unsigned maxCount, Foundation::IAsyncOperation<MapLocationFinderResult*>* *result);
};

// MapLocationFinderResult
template<typename X> struct statics<MapLocationFinderResult, X> : X {
	typedef typename X::root_type MapLocationFinderResult;
};
struct MapLocationFinderResult : generate<MapLocationFinderResult> {};

// IMapLocationFinderStatics2
struct IMapLocationFinderStatics2 : IInspectable {
	virtual STDMETHODIMP _FindLocationsAtWithAccuracyAsync(Devices::Geolocation::Geopoint* queryPoint, MapLocationDesiredAccuracy accuracy, Foundation::IAsyncOperation<MapLocationFinderResult*>* *result);
};

// IMapRouteFinderStatics
struct IMapRouteFinderStatics : IInspectable {
	virtual STDMETHODIMP _GetDrivingRouteAsync(Devices::Geolocation::Geopoint* startPoint, Devices::Geolocation::Geopoint* endPoint, Foundation::IAsyncOperation<MapRouteFinderResult*>* *result);
	virtual STDMETHODIMP _GetDrivingRouteWithOptimizationAsync(Devices::Geolocation::Geopoint* startPoint, Devices::Geolocation::Geopoint* endPoint, MapRouteOptimization optimization, Foundation::IAsyncOperation<MapRouteFinderResult*>* *result);
	virtual STDMETHODIMP _GetDrivingRouteWithOptimizationAndRestrictionsAsync(Devices::Geolocation::Geopoint* startPoint, Devices::Geolocation::Geopoint* endPoint, MapRouteOptimization optimization, MapRouteRestrictions restrictions, Foundation::IAsyncOperation<MapRouteFinderResult*>* *result);
	virtual STDMETHODIMP _GetDrivingRouteWithOptimizationRestrictionsAndHeadingAsync(Devices::Geolocation::Geopoint* startPoint, Devices::Geolocation::Geopoint* endPoint, MapRouteOptimization optimization, MapRouteRestrictions restrictions, double headingInDegrees, Foundation::IAsyncOperation<MapRouteFinderResult*>* *result);
	virtual STDMETHODIMP _GetDrivingRouteFromWaypointsAsync(Foundation::Collections::IIterable<Devices::Geolocation::Geopoint*>* wayPoints, Foundation::IAsyncOperation<MapRouteFinderResult*>* *result);
	virtual STDMETHODIMP _GetDrivingRouteFromWaypointsAndOptimizationAsync(Foundation::Collections::IIterable<Devices::Geolocation::Geopoint*>* wayPoints, MapRouteOptimization optimization, Foundation::IAsyncOperation<MapRouteFinderResult*>* *result);
	virtual STDMETHODIMP _GetDrivingRouteFromWaypointsOptimizationAndRestrictionsAsync(Foundation::Collections::IIterable<Devices::Geolocation::Geopoint*>* wayPoints, MapRouteOptimization optimization, MapRouteRestrictions restrictions, Foundation::IAsyncOperation<MapRouteFinderResult*>* *result);
	virtual STDMETHODIMP _GetDrivingRouteFromWaypointsOptimizationRestrictionsAndHeadingAsync(Foundation::Collections::IIterable<Devices::Geolocation::Geopoint*>* wayPoints, MapRouteOptimization optimization, MapRouteRestrictions restrictions, double headingInDegrees, Foundation::IAsyncOperation<MapRouteFinderResult*>* *result);
	virtual STDMETHODIMP _GetWalkingRouteAsync(Devices::Geolocation::Geopoint* startPoint, Devices::Geolocation::Geopoint* endPoint, Foundation::IAsyncOperation<MapRouteFinderResult*>* *result);
	virtual STDMETHODIMP _GetWalkingRouteFromWaypointsAsync(Foundation::Collections::IIterable<Devices::Geolocation::Geopoint*>* wayPoints, Foundation::IAsyncOperation<MapRouteFinderResult*>* *result);
};

// MapRouteFinderResult
template<typename X> struct statics<MapRouteFinderResult, X> : X {
	typedef typename X::root_type MapRouteFinderResult;
};
struct MapRouteFinderResult : generate<MapRouteFinderResult> {};

// IMapRouteFinderStatics2
struct IMapRouteFinderStatics2 : IInspectable {
	virtual STDMETHODIMP _GetDrivingRouteWithOptionsAsync(Devices::Geolocation::Geopoint* startPoint, Devices::Geolocation::Geopoint* endPoint, MapRouteDrivingOptions* options, Foundation::IAsyncOperation<MapRouteFinderResult*>* *result);
};

// MapRouteDrivingOptions
template<typename X> struct statics<MapRouteDrivingOptions, X> : X {
	typedef typename X::root_type MapRouteDrivingOptions;
};
struct MapRouteDrivingOptions : generate<MapRouteDrivingOptions> {};

// IMapRouteFinderStatics3
struct IMapRouteFinderStatics3 : IInspectable {
	virtual STDMETHODIMP _GetDrivingRouteFromEnhancedWaypointsAsync(Foundation::Collections::IIterable<EnhancedWaypoint*>* waypoints, Foundation::IAsyncOperation<MapRouteFinderResult*>* *result);
	virtual STDMETHODIMP _GetDrivingRouteFromEnhancedWaypointsWithOptionsAsync(Foundation::Collections::IIterable<EnhancedWaypoint*>* waypoints, MapRouteDrivingOptions* options, Foundation::IAsyncOperation<MapRouteFinderResult*>* *result);
};

// IMapServiceStatics
struct IMapServiceStatics : IInspectable {
	virtual STDMETHODIMP _put_ServiceToken(HSTRING value);
	virtual STDMETHODIMP _get_ServiceToken(HSTRING *value);
};

// IMapManagerStatics
struct IMapManagerStatics : IInspectable {
	virtual STDMETHODIMP _ShowDownloadedMapsUI();
	virtual STDMETHODIMP _ShowMapsUpdateUI();
};

// IMapServiceStatics2
struct IMapServiceStatics2 : IInspectable {
	virtual STDMETHODIMP _get_WorldViewRegionCode(HSTRING *value);
};

// IMapServiceStatics3
struct IMapServiceStatics3 : IInspectable {
	virtual STDMETHODIMP _get_DataAttributions(HSTRING *value);
};

// IMapServiceStatics4
struct IMapServiceStatics4 : IInspectable {
	virtual STDMETHODIMP _put_DataUsagePreference(MapServiceDataUsagePreference value);
	virtual STDMETHODIMP _get_DataUsagePreference(MapServiceDataUsagePreference *value);
};

// IPlaceInfoCreateOptions
struct IPlaceInfoCreateOptions_raw : IInspectable {
	virtual STDMETHODIMP _put_DisplayName(HSTRING value);
	virtual STDMETHODIMP _get_DisplayName(HSTRING *value);
	virtual STDMETHODIMP _put_DisplayAddress(HSTRING value);
	virtual STDMETHODIMP _get_DisplayAddress(HSTRING *value);
};
template<typename X> struct IPlaceInfoCreateOptions_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPlaceInfoCreateOptions_adaptor::DisplayAddress)->_get_DisplayAddress(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPlaceInfoCreateOptions_adaptor::DisplayAddress)->_put_DisplayAddress(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DisplayAddress;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPlaceInfoCreateOptions_adaptor::DisplayName)->_get_DisplayName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPlaceInfoCreateOptions_adaptor::DisplayName)->_put_DisplayName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DisplayName;
	};
	IPlaceInfoCreateOptions_adaptor() {}
};
template<typename X> struct adapt<IPlaceInfoCreateOptions, X> : Windows::Services::Maps::IPlaceInfoCreateOptions_adaptor<X> { typedef adapt IPlaceInfoCreateOptions; };
struct IPlaceInfoCreateOptions : IPlaceInfoCreateOptions_raw, generate<IPlaceInfoCreateOptions> {};

// IPlaceInfoStatics
struct IPlaceInfoStatics : IInspectable {
	virtual STDMETHODIMP _Create(Devices::Geolocation::Geopoint* referencePoint, PlaceInfo* *resultValue);
	virtual STDMETHODIMP _CreateWithGeopointAndOptions(Devices::Geolocation::Geopoint* referencePoint, PlaceInfoCreateOptions* options, PlaceInfo* *resultValue);
	virtual STDMETHODIMP _CreateFromIdentifier(HSTRING identifier, PlaceInfo* *resultValue);
	virtual STDMETHODIMP _CreateFromIdentifierWithOptions(HSTRING identifier, Devices::Geolocation::Geopoint* defaultPoint, PlaceInfoCreateOptions* options, PlaceInfo* *resultValue);
	virtual STDMETHODIMP _CreateFromMapLocation(MapLocation* location, PlaceInfo* *resultValue);
	virtual STDMETHODIMP _get_IsShowSupported(bool *value);
};

// IPlaceInfoStatics2
struct IPlaceInfoStatics2 : IInspectable {
	virtual STDMETHODIMP _CreateFromAddress(HSTRING displayAddress, PlaceInfo* *resultValue);
	virtual STDMETHODIMP _CreateFromAddressWithName(HSTRING displayAddress, HSTRING displayName, PlaceInfo* *resultValue);
};

// IPlaceInfo
struct IPlaceInfo_raw : IInspectable {
	virtual STDMETHODIMP _Show(Foundation::Rect selection);
	virtual STDMETHODIMP _ShowWithPreferredPlacement(Foundation::Rect selection, UI::Popups::Placement preferredPlacement);
	virtual STDMETHODIMP _get_Identifier(HSTRING *value);
	virtual STDMETHODIMP _get_DisplayName(HSTRING *value);
	virtual STDMETHODIMP _get_DisplayAddress(HSTRING *value);
	virtual STDMETHODIMP _get_Geoshape(Devices::Geolocation::IGeoshape* *value);
};
template<typename X> struct IPlaceInfo_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPlaceInfo_adaptor::DisplayAddress)->_get_DisplayAddress(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DisplayAddress;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPlaceInfo_adaptor::DisplayName)->_get_DisplayName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DisplayName;
		struct : property {
			ptr<Devices::Geolocation::IGeoshape> get() { Devices::Geolocation::IGeoshape* value; hrcheck(enc(&IPlaceInfo_adaptor::Geoshape)->_get_Geoshape(&value)); return from_abi(value); }
			ptr<Devices::Geolocation::IGeoshape> operator()() { return get(); }
			operator ptr<Devices::Geolocation::IGeoshape> () { return get(); }
			ptr<Devices::Geolocation::IGeoshape> operator->() { return get(); }
		} Geoshape;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPlaceInfo_adaptor::Identifier)->_get_Identifier(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Identifier;
	};
	void Show(const Foundation::Rect& selection) { hrcheck(X::get()->_Show(selection)); }
	void Show(const Foundation::Rect& selection, UI::Popups::Placement preferredPlacement) { hrcheck(X::get()->_ShowWithPreferredPlacement(selection, preferredPlacement)); }
	IPlaceInfo_adaptor() {}
};
template<typename X> struct adapt<IPlaceInfo, X> : Windows::Services::Maps::IPlaceInfo_adaptor<X> { typedef adapt IPlaceInfo; };
struct IPlaceInfo : IPlaceInfo_raw, generate<IPlaceInfo> {};

// PlaceInfo
template<typename> struct PlaceInfo_statics {
	static struct _IsShowSupported : property {
		bool get() { bool value; hrcheck(get_activation_factory<PlaceInfo, IPlaceInfoStatics>()->_get_IsShowSupported(&value)); return value; }
		bool operator()() { return get(); }
		operator bool () { return get(); }
	} IsShowSupported;
	static ptr<PlaceInfo> CreateFromAddress(hstring_ref displayAddress) { PlaceInfo* resultValue; hrcheck(get_activation_factory<PlaceInfo, IPlaceInfoStatics2>()->_CreateFromAddress(displayAddress, &resultValue)); return from_abi(resultValue); }
	static ptr<PlaceInfo> CreateFromAddress(hstring_ref displayAddress, hstring_ref displayName) { PlaceInfo* resultValue; hrcheck(get_activation_factory<PlaceInfo, IPlaceInfoStatics2>()->_CreateFromAddressWithName(displayAddress, displayName, &resultValue)); return from_abi(resultValue); }
	static ptr<PlaceInfo> Create(pptr<Devices::Geolocation::Geopoint> referencePoint) { PlaceInfo* resultValue; hrcheck(get_activation_factory<PlaceInfo, IPlaceInfoStatics>()->_Create(referencePoint, &resultValue)); return from_abi(resultValue); }
	static ptr<PlaceInfo> Create(pptr<Devices::Geolocation::Geopoint> referencePoint, pptr<PlaceInfoCreateOptions> options) { PlaceInfo* resultValue; hrcheck(get_activation_factory<PlaceInfo, IPlaceInfoStatics>()->_CreateWithGeopointAndOptions(referencePoint, options, &resultValue)); return from_abi(resultValue); }
	static ptr<PlaceInfo> CreateFromIdentifier(hstring_ref identifier) { PlaceInfo* resultValue; hrcheck(get_activation_factory<PlaceInfo, IPlaceInfoStatics>()->_CreateFromIdentifier(identifier, &resultValue)); return from_abi(resultValue); }
	static ptr<PlaceInfo> CreateFromIdentifier(hstring_ref identifier, pptr<Devices::Geolocation::Geopoint> defaultPoint, pptr<PlaceInfoCreateOptions> options) { PlaceInfo* resultValue; hrcheck(get_activation_factory<PlaceInfo, IPlaceInfoStatics>()->_CreateFromIdentifierWithOptions(identifier, defaultPoint, options, &resultValue)); return from_abi(resultValue); }
	static ptr<PlaceInfo> CreateFromMapLocation(pptr<MapLocation> location) { PlaceInfo* resultValue; hrcheck(get_activation_factory<PlaceInfo, IPlaceInfoStatics>()->_CreateFromMapLocation(location, &resultValue)); return from_abi(resultValue); }
};
template<typename X> typename PlaceInfo_statics<X>::_IsShowSupported PlaceInfo_statics<X>::IsShowSupported;

template<typename X> struct statics<PlaceInfo, X> : X, Windows::Services::Maps::PlaceInfo_statics<void> {
	typedef typename X::root_type PlaceInfo;
};
struct PlaceInfo : generate<PlaceInfo> {
	using IPlaceInfo::Show;
};

// PlaceInfoCreateOptions
template<typename X> struct statics<PlaceInfoCreateOptions, X> : X {
	typedef typename X::root_type PlaceInfoCreateOptions;
};
struct PlaceInfoCreateOptions : generate<PlaceInfoCreateOptions> {};

// MapLocationFinder
template<typename> struct MapLocationFinder_statics {
	static ptr<Foundation::IAsyncOperation<ptr<MapLocationFinderResult>>> FindLocationsAtAsync(pptr<Devices::Geolocation::Geopoint> queryPoint, MapLocationDesiredAccuracy accuracy) { Foundation::IAsyncOperation<MapLocationFinderResult*>* result; hrcheck(get_activation_factory<MapLocationFinder, IMapLocationFinderStatics2>()->_FindLocationsAtWithAccuracyAsync(queryPoint, accuracy, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<MapLocationFinderResult>>> FindLocationsAtAsync(pptr<Devices::Geolocation::Geopoint> queryPoint) { Foundation::IAsyncOperation<MapLocationFinderResult*>* result; hrcheck(get_activation_factory<MapLocationFinder, IMapLocationFinderStatics>()->_FindLocationsAtAsync(queryPoint, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<MapLocationFinderResult>>> FindLocationsAsync(hstring_ref searchText, pptr<Devices::Geolocation::Geopoint> referencePoint) { Foundation::IAsyncOperation<MapLocationFinderResult*>* result; hrcheck(get_activation_factory<MapLocationFinder, IMapLocationFinderStatics>()->_FindLocationsAsync(searchText, referencePoint, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<MapLocationFinderResult>>> FindLocationsAsync(hstring_ref searchText, pptr<Devices::Geolocation::Geopoint> referencePoint, unsigned maxCount) { Foundation::IAsyncOperation<MapLocationFinderResult*>* result; hrcheck(get_activation_factory<MapLocationFinder, IMapLocationFinderStatics>()->_FindLocationsWithMaxCountAsync(searchText, referencePoint, maxCount, &result)); return from_abi(result); }
};

template<typename X> struct statics<MapLocationFinder, X> : X, Windows::Services::Maps::MapLocationFinder_statics<void> {
	typedef typename X::root_type MapLocationFinder;
};
struct MapLocationFinder : generate<MapLocationFinder> {};

// MapRouteFinder
template<typename> struct MapRouteFinder_statics {
	static ptr<Foundation::IAsyncOperation<ptr<MapRouteFinderResult>>> GetDrivingRouteFromEnhancedWaypointsAsync(pptr<Foundation::Collections::IIterable<ptr<EnhancedWaypoint>>> waypoints) { Foundation::IAsyncOperation<MapRouteFinderResult*>* result; hrcheck(get_activation_factory<MapRouteFinder, IMapRouteFinderStatics3>()->_GetDrivingRouteFromEnhancedWaypointsAsync(to_abi(waypoints), &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<MapRouteFinderResult>>> GetDrivingRouteFromEnhancedWaypointsAsync(pptr<Foundation::Collections::IIterable<ptr<EnhancedWaypoint>>> waypoints, pptr<MapRouteDrivingOptions> options) { Foundation::IAsyncOperation<MapRouteFinderResult*>* result; hrcheck(get_activation_factory<MapRouteFinder, IMapRouteFinderStatics3>()->_GetDrivingRouteFromEnhancedWaypointsWithOptionsAsync(to_abi(waypoints), options, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<MapRouteFinderResult>>> GetDrivingRouteAsync(pptr<Devices::Geolocation::Geopoint> startPoint, pptr<Devices::Geolocation::Geopoint> endPoint, pptr<MapRouteDrivingOptions> options) { Foundation::IAsyncOperation<MapRouteFinderResult*>* result; hrcheck(get_activation_factory<MapRouteFinder, IMapRouteFinderStatics2>()->_GetDrivingRouteWithOptionsAsync(startPoint, endPoint, options, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<MapRouteFinderResult>>> GetDrivingRouteAsync(pptr<Devices::Geolocation::Geopoint> startPoint, pptr<Devices::Geolocation::Geopoint> endPoint) { Foundation::IAsyncOperation<MapRouteFinderResult*>* result; hrcheck(get_activation_factory<MapRouteFinder, IMapRouteFinderStatics>()->_GetDrivingRouteAsync(startPoint, endPoint, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<MapRouteFinderResult>>> GetDrivingRouteAsync(pptr<Devices::Geolocation::Geopoint> startPoint, pptr<Devices::Geolocation::Geopoint> endPoint, MapRouteOptimization optimization) { Foundation::IAsyncOperation<MapRouteFinderResult*>* result; hrcheck(get_activation_factory<MapRouteFinder, IMapRouteFinderStatics>()->_GetDrivingRouteWithOptimizationAsync(startPoint, endPoint, optimization, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<MapRouteFinderResult>>> GetDrivingRouteAsync(pptr<Devices::Geolocation::Geopoint> startPoint, pptr<Devices::Geolocation::Geopoint> endPoint, MapRouteOptimization optimization, MapRouteRestrictions restrictions) { Foundation::IAsyncOperation<MapRouteFinderResult*>* result; hrcheck(get_activation_factory<MapRouteFinder, IMapRouteFinderStatics>()->_GetDrivingRouteWithOptimizationAndRestrictionsAsync(startPoint, endPoint, optimization, restrictions, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<MapRouteFinderResult>>> GetDrivingRouteAsync(pptr<Devices::Geolocation::Geopoint> startPoint, pptr<Devices::Geolocation::Geopoint> endPoint, MapRouteOptimization optimization, MapRouteRestrictions restrictions, double headingInDegrees) { Foundation::IAsyncOperation<MapRouteFinderResult*>* result; hrcheck(get_activation_factory<MapRouteFinder, IMapRouteFinderStatics>()->_GetDrivingRouteWithOptimizationRestrictionsAndHeadingAsync(startPoint, endPoint, optimization, restrictions, headingInDegrees, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<MapRouteFinderResult>>> GetDrivingRouteFromWaypointsAsync(pptr<Foundation::Collections::IIterable<ptr<Devices::Geolocation::Geopoint>>> wayPoints) { Foundation::IAsyncOperation<MapRouteFinderResult*>* result; hrcheck(get_activation_factory<MapRouteFinder, IMapRouteFinderStatics>()->_GetDrivingRouteFromWaypointsAsync(to_abi(wayPoints), &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<MapRouteFinderResult>>> GetDrivingRouteFromWaypointsAsync(pptr<Foundation::Collections::IIterable<ptr<Devices::Geolocation::Geopoint>>> wayPoints, MapRouteOptimization optimization) { Foundation::IAsyncOperation<MapRouteFinderResult*>* result; hrcheck(get_activation_factory<MapRouteFinder, IMapRouteFinderStatics>()->_GetDrivingRouteFromWaypointsAndOptimizationAsync(to_abi(wayPoints), optimization, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<MapRouteFinderResult>>> GetDrivingRouteFromWaypointsAsync(pptr<Foundation::Collections::IIterable<ptr<Devices::Geolocation::Geopoint>>> wayPoints, MapRouteOptimization optimization, MapRouteRestrictions restrictions) { Foundation::IAsyncOperation<MapRouteFinderResult*>* result; hrcheck(get_activation_factory<MapRouteFinder, IMapRouteFinderStatics>()->_GetDrivingRouteFromWaypointsOptimizationAndRestrictionsAsync(to_abi(wayPoints), optimization, restrictions, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<MapRouteFinderResult>>> GetDrivingRouteFromWaypointsAsync(pptr<Foundation::Collections::IIterable<ptr<Devices::Geolocation::Geopoint>>> wayPoints, MapRouteOptimization optimization, MapRouteRestrictions restrictions, double headingInDegrees) { Foundation::IAsyncOperation<MapRouteFinderResult*>* result; hrcheck(get_activation_factory<MapRouteFinder, IMapRouteFinderStatics>()->_GetDrivingRouteFromWaypointsOptimizationRestrictionsAndHeadingAsync(to_abi(wayPoints), optimization, restrictions, headingInDegrees, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<MapRouteFinderResult>>> GetWalkingRouteAsync(pptr<Devices::Geolocation::Geopoint> startPoint, pptr<Devices::Geolocation::Geopoint> endPoint) { Foundation::IAsyncOperation<MapRouteFinderResult*>* result; hrcheck(get_activation_factory<MapRouteFinder, IMapRouteFinderStatics>()->_GetWalkingRouteAsync(startPoint, endPoint, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<MapRouteFinderResult>>> GetWalkingRouteFromWaypointsAsync(pptr<Foundation::Collections::IIterable<ptr<Devices::Geolocation::Geopoint>>> wayPoints) { Foundation::IAsyncOperation<MapRouteFinderResult*>* result; hrcheck(get_activation_factory<MapRouteFinder, IMapRouteFinderStatics>()->_GetWalkingRouteFromWaypointsAsync(to_abi(wayPoints), &result)); return from_abi(result); }
};

template<typename X> struct statics<MapRouteFinder, X> : X, Windows::Services::Maps::MapRouteFinder_statics<void> {
	typedef typename X::root_type MapRouteFinder;
};
struct MapRouteFinder : generate<MapRouteFinder> {};

// MapService
template<typename> struct MapService_statics {
	static struct _ServiceToken : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<MapService, IMapServiceStatics>()->_get_ServiceToken(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
		void put(hstring_ref value) { hrcheck(get_activation_factory<MapService, IMapServiceStatics>()->_put_ServiceToken(value)); }
		void operator=(hstring_ref value) { put(value); }
		void operator()(hstring_ref value) { put(value); }
	} ServiceToken;
	static struct _WorldViewRegionCode : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<MapService, IMapServiceStatics2>()->_get_WorldViewRegionCode(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} WorldViewRegionCode;
	static struct _DataAttributions : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<MapService, IMapServiceStatics3>()->_get_DataAttributions(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} DataAttributions;
	static struct _DataUsagePreference : property {
		MapServiceDataUsagePreference get() { MapServiceDataUsagePreference value; hrcheck(get_activation_factory<MapService, IMapServiceStatics4>()->_get_DataUsagePreference(&value)); return value; }
		MapServiceDataUsagePreference operator()() { return get(); }
		operator MapServiceDataUsagePreference () { return get(); }
		void put(MapServiceDataUsagePreference value) { hrcheck(get_activation_factory<MapService, IMapServiceStatics4>()->_put_DataUsagePreference(value)); }
		void operator=(MapServiceDataUsagePreference value) { put(value); }
		void operator()(MapServiceDataUsagePreference value) { put(value); }
	} DataUsagePreference;
};
template<typename X> typename MapService_statics<X>::_ServiceToken MapService_statics<X>::ServiceToken;
template<typename X> typename MapService_statics<X>::_WorldViewRegionCode MapService_statics<X>::WorldViewRegionCode;
template<typename X> typename MapService_statics<X>::_DataAttributions MapService_statics<X>::DataAttributions;
template<typename X> typename MapService_statics<X>::_DataUsagePreference MapService_statics<X>::DataUsagePreference;

template<typename X> struct statics<MapService, X> : X, Windows::Services::Maps::MapService_statics<void> {
	typedef typename X::root_type MapService;
};
struct MapService : generate<MapService> {};

// MapManager
template<typename> struct MapManager_statics {
	static void ShowDownloadedMapsUI() { hrcheck(get_activation_factory<MapManager, IMapManagerStatics>()->_ShowDownloadedMapsUI()); }
	static void ShowMapsUpdateUI() { hrcheck(get_activation_factory<MapManager, IMapManagerStatics>()->_ShowMapsUpdateUI()); }
};

template<typename X> struct statics<MapManager, X> : X, Windows::Services::Maps::MapManager_statics<void> {
	typedef typename X::root_type MapManager;
};
struct MapManager : generate<MapManager> {};
}}}
} // namespace iso_winrt
