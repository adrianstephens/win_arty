#pragma once
// generated by isopod tools
// namespaces:
// Windows.Devices.Custom

#include "Windows.Devices.Custom.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation {
template<typename TResult> struct IAsyncOperation;
}
namespace Storage { namespace Streams {
struct IInputStream;
struct IBuffer;
struct IOutputStream;
}}}

// defs

template<> struct def<Windows::Devices::Custom::CustomDeviceContract> : value_type<> {};
template<> struct def<Windows::Devices::Custom::IKnownDeviceTypesStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Custom::KnownDeviceTypes> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Devices::Custom::IOControlAccessMode> : enum_type<int> {};
template<> struct def<Windows::Devices::Custom::IOControlBufferingMethod> : enum_type<int> {};
template<> struct def<Windows::Devices::Custom::IIOControlCode> : overridable_type<> {};
template<> struct def<Windows::Devices::Custom::IIOControlCodeFactory> : interface_type<> {};
template<> struct def<Windows::Devices::Custom::IOControlCode> : class_type<Platform::Object, Windows::Devices::Custom::IIOControlCode>, custom_activators {};
template<> struct def<Windows::Devices::Custom::DeviceAccessMode> : enum_type<int> {};
template<> struct def<Windows::Devices::Custom::DeviceSharingMode> : enum_type<int> {};
template<> struct def<Windows::Devices::Custom::ICustomDeviceStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Custom::ICustomDevice> : interface_type<> {};
template<> struct def<Windows::Devices::Custom::CustomDevice> : class_type<Platform::Object, Windows::Devices::Custom::ICustomDevice> {};

// uuids

template<> struct uuid<Windows::Devices::Custom::IKnownDeviceTypesStatics> { define_guid(0xEE5479C2, 0x5448, 0x45DA, 0xAD, 0x1B, 0x24, 0x94, 0x8C, 0x23, 0x90, 0x94);};
template<> struct uuid<Windows::Devices::Custom::IIOControlCode> { define_guid(0xE9559E7, 0x60C8, 0x4375, 0xA7, 0x61, 0x7F, 0x88, 0x8, 0x6, 0x6C, 0x60);};
template<> struct uuid<Windows::Devices::Custom::IIOControlCodeFactory> { define_guid(0x856A7CF0, 0x4C11, 0x44AE, 0xAF, 0xC6, 0xB8, 0xD4, 0xA2, 0x12, 0x78, 0x8F);};
template<> struct uuid<Windows::Devices::Custom::ICustomDeviceStatics> { define_guid(0xC8220312, 0xEF4C, 0x46B1, 0xA5, 0x8E, 0xEE, 0xB3, 0x8, 0xDC, 0x89, 0x17);};
template<> struct uuid<Windows::Devices::Custom::ICustomDevice> { define_guid(0xDD30251F, 0xC48B, 0x43BD, 0xBC, 0xB1, 0xDE, 0xC8, 0x8F, 0x15, 0x14, 0x3E);};

// types

namespace Windows { namespace Devices { namespace Custom {

// IKnownDeviceTypesStatics
struct IKnownDeviceTypesStatics : IInspectable {
	virtual STDMETHODIMP _get_Unknown(unsigned short *value);
};

// KnownDeviceTypes
template<typename> struct KnownDeviceTypes_statics {
	static struct _Unknown : property {
		unsigned short get() { unsigned short value; hrcheck(get_activation_factory<KnownDeviceTypes, IKnownDeviceTypesStatics>()->_get_Unknown(&value)); return value; }
		unsigned short operator()() { return get(); }
		operator unsigned short () { return get(); }
	} Unknown;
};
template<typename X> typename KnownDeviceTypes_statics<X>::_Unknown KnownDeviceTypes_statics<X>::Unknown;

template<typename X> struct statics<KnownDeviceTypes, X> : X, Windows::Devices::Custom::KnownDeviceTypes_statics<void> {
	typedef typename X::root_type KnownDeviceTypes;
};
struct KnownDeviceTypes : generate<KnownDeviceTypes> {};

// IIOControlCode
struct IIOControlCode_raw : IInspectable {
	virtual STDMETHODIMP _get_AccessMode(IOControlAccessMode *value) = 0;
	virtual STDMETHODIMP _get_BufferingMethod(IOControlBufferingMethod *value) = 0;
	virtual STDMETHODIMP _get_Function(unsigned short *value) = 0;
	virtual STDMETHODIMP _get_DeviceType(unsigned short *value) = 0;
	virtual STDMETHODIMP _get_ControlCode(unsigned *value) = 0;
};
template<typename X> struct IIOControlCode_adaptor : X {
	union {
		struct : property {
			IOControlAccessMode get() { IOControlAccessMode value; hrcheck(enc(&IIOControlCode_adaptor::AccessMode)->_get_AccessMode(&value)); return value; }
			IOControlAccessMode operator()() { return get(); }
			operator IOControlAccessMode () { return get(); }
		} AccessMode;
		struct : property {
			IOControlBufferingMethod get() { IOControlBufferingMethod value; hrcheck(enc(&IIOControlCode_adaptor::BufferingMethod)->_get_BufferingMethod(&value)); return value; }
			IOControlBufferingMethod operator()() { return get(); }
			operator IOControlBufferingMethod () { return get(); }
		} BufferingMethod;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IIOControlCode_adaptor::ControlCode)->_get_ControlCode(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} ControlCode;
		struct : property {
			unsigned short get() { unsigned short value; hrcheck(enc(&IIOControlCode_adaptor::DeviceType)->_get_DeviceType(&value)); return value; }
			unsigned short operator()() { return get(); }
			operator unsigned short () { return get(); }
		} DeviceType;
		struct : property {
			unsigned short get() { unsigned short value; hrcheck(enc(&IIOControlCode_adaptor::Function)->_get_Function(&value)); return value; }
			unsigned short operator()() { return get(); }
			operator unsigned short () { return get(); }
		} Function;
	};
	IIOControlCode_adaptor() {}
};
template<typename X> struct adapt<IIOControlCode, X> : Windows::Devices::Custom::IIOControlCode_adaptor<X> { typedef adapt IIOControlCode; };
template<typename X> struct IIOControlCode_unadaptor : X {
	STDMETHODIMP _get_AccessMode(IOControlAccessMode *value) { return hrtry([&, this] { get_prop(value, AccessMode); }); }
	STDMETHODIMP _get_BufferingMethod(IOControlBufferingMethod *value) { return hrtry([&, this] { get_prop(value, BufferingMethod); }); }
	STDMETHODIMP _get_Function(unsigned short *value) { return hrtry([&, this] { get_prop(value, Function); }); }
	STDMETHODIMP _get_DeviceType(unsigned short *value) { return hrtry([&, this] { get_prop(value, DeviceType); }); }
	STDMETHODIMP _get_ControlCode(unsigned *value) { return hrtry([&, this] { get_prop(value, ControlCode); }); }
};
template<typename X> struct unadapt<IIOControlCode, X> : Windows::Devices::Custom::IIOControlCode_unadaptor<X> {};
struct IIOControlCode : IIOControlCode_raw, generate<IIOControlCode> {};

// IIOControlCodeFactory
struct IIOControlCodeFactory : IInspectable {
	virtual STDMETHODIMP _CreateIOControlCode(unsigned short deviceType, unsigned short function, IOControlAccessMode accessMode, IOControlBufferingMethod bufferingMethod, IOControlCode* *instance);
};

// IOControlCode
template<typename> struct IOControlCode_statics {
	static IOControlCode *activate(unsigned short deviceType, unsigned short function, IOControlAccessMode accessMode, IOControlBufferingMethod bufferingMethod) { IOControlCode *instance; hrcheck(get_activation_factory<IOControlCode, IIOControlCodeFactory>()->_CreateIOControlCode(deviceType, function, accessMode, bufferingMethod, &instance)); return instance; }
};

template<typename X> struct statics<IOControlCode, X> : X, Windows::Devices::Custom::IOControlCode_statics<void> {
	using Windows::Devices::Custom::IOControlCode_statics<void>::activate;
	typedef typename X::root_type IOControlCode;
};
struct IOControlCode : generate<IOControlCode> {};

// ICustomDeviceStatics
struct ICustomDeviceStatics : IInspectable {
	virtual STDMETHODIMP _GetDeviceSelector(Platform::Guid classGuid, HSTRING *value);
	virtual STDMETHODIMP _FromIdAsync(HSTRING deviceId, DeviceAccessMode desiredAccess, DeviceSharingMode sharingMode, Foundation::IAsyncOperation<CustomDevice*>* *operation);
};

// ICustomDevice
struct ICustomDevice_raw : IInspectable {
	virtual STDMETHODIMP _get_InputStream(Storage::Streams::IInputStream* *value);
	virtual STDMETHODIMP _get_OutputStream(Storage::Streams::IOutputStream* *value);
	virtual STDMETHODIMP _SendIOControlAsync(IIOControlCode* ioControlCode, Storage::Streams::IBuffer* inputBuffer, Storage::Streams::IBuffer* outputBuffer, Foundation::IAsyncOperation<unsigned>* *operation);
	virtual STDMETHODIMP _TrySendIOControlAsync(IIOControlCode* ioControlCode, Storage::Streams::IBuffer* inputBuffer, Storage::Streams::IBuffer* outputBuffer, Foundation::IAsyncOperation<bool>* *operation);
};
template<typename X> struct ICustomDevice_adaptor : X {
	union {
		struct : property {
			ptr<Storage::Streams::IInputStream> get() { Storage::Streams::IInputStream* value; hrcheck(enc(&ICustomDevice_adaptor::InputStream)->_get_InputStream(&value)); return from_abi(value); }
			ptr<Storage::Streams::IInputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IInputStream> () { return get(); }
			ptr<Storage::Streams::IInputStream> operator->() { return get(); }
		} InputStream;
		struct : property {
			ptr<Storage::Streams::IOutputStream> get() { Storage::Streams::IOutputStream* value; hrcheck(enc(&ICustomDevice_adaptor::OutputStream)->_get_OutputStream(&value)); return from_abi(value); }
			ptr<Storage::Streams::IOutputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IOutputStream> () { return get(); }
			ptr<Storage::Streams::IOutputStream> operator->() { return get(); }
		} OutputStream;
	};
	ptr<Foundation::IAsyncOperation<unsigned>> SendIOControlAsync(pptr<IIOControlCode> ioControlCode, pptr<Storage::Streams::IBuffer> inputBuffer, pptr<Storage::Streams::IBuffer> outputBuffer) { Foundation::IAsyncOperation<unsigned>* operation; hrcheck(X::get()->_SendIOControlAsync(ioControlCode, inputBuffer, outputBuffer, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<bool>> TrySendIOControlAsync(pptr<IIOControlCode> ioControlCode, pptr<Storage::Streams::IBuffer> inputBuffer, pptr<Storage::Streams::IBuffer> outputBuffer) { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_TrySendIOControlAsync(ioControlCode, inputBuffer, outputBuffer, &operation)); return from_abi(operation); }
	ICustomDevice_adaptor() {}
};
template<typename X> struct adapt<ICustomDevice, X> : Windows::Devices::Custom::ICustomDevice_adaptor<X> { typedef adapt ICustomDevice; };
struct ICustomDevice : ICustomDevice_raw, generate<ICustomDevice> {};

// CustomDevice
template<typename> struct CustomDevice_statics {
	static hstring GetDeviceSelector(const Platform::Guid& classGuid) { HSTRING value; hrcheck(get_activation_factory<CustomDevice, ICustomDeviceStatics>()->_GetDeviceSelector(classGuid, &value)); return from_abi(value); }
	static ptr<Foundation::IAsyncOperation<ptr<CustomDevice>>> FromIdAsync(hstring_ref deviceId, DeviceAccessMode desiredAccess, DeviceSharingMode sharingMode) { Foundation::IAsyncOperation<CustomDevice*>* operation; hrcheck(get_activation_factory<CustomDevice, ICustomDeviceStatics>()->_FromIdAsync(deviceId, desiredAccess, sharingMode, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<CustomDevice, X> : X, Windows::Devices::Custom::CustomDevice_statics<void> {
	typedef typename X::root_type CustomDevice;
};
struct CustomDevice : generate<CustomDevice> {};
}}}
} // namespace iso_winrt
