#pragma once
// generated by isopod tools
// namespaces:
// Windows.UI.Text

#include "Windows.UI.Text.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.UI.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Storage { namespace Streams {
struct IRandomAccessStream;
}}}

// defs

template<> struct def<Windows::UI::Text::CaretType> : enum_type<int> {};
template<> struct def<Windows::UI::Text::FindOptions> : enum_type<unsigned> {};
template<> struct def<Windows::UI::Text::FormatEffect> : enum_type<int> {};
template<> struct def<Windows::UI::Text::HorizontalCharacterAlignment> : enum_type<int> {};
template<> struct def<Windows::UI::Text::LetterCase> : enum_type<int> {};
template<> struct def<Windows::UI::Text::LineSpacingRule> : enum_type<int> {};
template<> struct def<Windows::UI::Text::LinkType> : enum_type<int> {};
template<> struct def<Windows::UI::Text::MarkerAlignment> : enum_type<int> {};
template<> struct def<Windows::UI::Text::MarkerStyle> : enum_type<int> {};
template<> struct def<Windows::UI::Text::MarkerType> : enum_type<int> {};
template<> struct def<Windows::UI::Text::ParagraphAlignment> : enum_type<int> {};
template<> struct def<Windows::UI::Text::ParagraphStyle> : enum_type<int> {};
template<> struct def<Windows::UI::Text::PointOptions> : enum_type<unsigned> {};
template<> struct def<Windows::UI::Text::RangeGravity> : enum_type<int> {};
template<> struct def<Windows::UI::Text::SelectionOptions> : enum_type<unsigned> {};
template<> struct def<Windows::UI::Text::SelectionType> : enum_type<int> {};
template<> struct def<Windows::UI::Text::TabAlignment> : enum_type<int> {};
template<> struct def<Windows::UI::Text::TabLeader> : enum_type<int> {};
template<> struct def<Windows::UI::Text::TextGetOptions> : enum_type<unsigned> {};
template<> struct def<Windows::UI::Text::TextSetOptions> : enum_type<unsigned> {};
template<> struct def<Windows::UI::Text::TextRangeUnit> : enum_type<int> {};
template<> struct def<Windows::UI::Text::TextScript> : enum_type<int> {};
template<> struct def<Windows::UI::Text::UnderlineType> : enum_type<int> {};
template<> struct def<Windows::UI::Text::VerticalCharacterAlignment> : enum_type<int> {};
template<> struct def<Windows::UI::Text::FontStyle> : enum_type<int> {};
template<> struct def<Windows::UI::Text::FontStretch> : enum_type<int> {};
template<> struct def<Windows::UI::Text::ITextConstantsStatics> : interface_type<> {};
template<> struct def<Windows::UI::Text::TextConstants> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::UI::Text::ITextDocument> : overridable_type<> {};
template<> struct def<Windows::UI::Text::ITextRange> : overridable_type<> {};
template<> struct def<Windows::UI::Text::ITextSelection> : overridable_type<Windows::UI::Text::ITextRange> {};
template<> struct def<Windows::UI::Text::ITextCharacterFormat> : overridable_type<> {};
template<> struct def<Windows::UI::Text::ITextParagraphFormat> : overridable_type<> {};
template<> struct def<Windows::UI::Text::ITextDocument2> : interface_type<Windows::UI::Text::ITextDocument> {};
template<> struct def<Windows::UI::Text::RichEditTextDocument> : class_type<Platform::Object, Windows::UI::Text::ITextDocument, Windows::UI::Text::ITextDocument2> {};
template<> struct def<Windows::UI::Text::IRichEditTextRange> : interface_type<Windows::UI::Text::ITextRange> {};
template<> struct def<Windows::UI::Text::RichEditTextRange> : class_type<Platform::Object, Windows::UI::Text::ITextRange, Windows::UI::Text::IRichEditTextRange> {};
template<> struct def<Windows::UI::Text::IContentLinkInfo> : interface_type<> {};
template<> struct def<Windows::UI::Text::ContentLinkInfo> : class_type<Platform::Object, Windows::UI::Text::IContentLinkInfo> {};
template<> struct def<Windows::UI::Text::FontWeight> : value_type<unsigned short> {};
template<> struct def<Windows::UI::Text::IFontWeights> : interface_type<> {};
template<> struct def<Windows::UI::Text::IFontWeightsStatics> : interface_type<> {};
template<> struct def<Windows::UI::Text::FontWeights> : class_type<Platform::Object, Windows::UI::Text::IFontWeights> {};
template<> struct def<Windows::UI::Text::TextDecorations> : enum_type<unsigned> {};

// uuids

template<> struct uuid<Windows::UI::Text::ITextConstantsStatics> { define_guid(0x779E7C33, 0x189D, 0x4BFA, 0x97, 0xC8, 0x10, 0xDB, 0x13, 0x5D, 0x97, 0x6E);};
template<> struct uuid<Windows::UI::Text::ITextDocument> { define_guid(0xBEEE4DDB, 0x90B2, 0x408C, 0xA2, 0xF6, 0xA, 0xA, 0xC3, 0x1E, 0x33, 0xE4);};
template<> struct uuid<Windows::UI::Text::ITextRange> { define_guid(0x5B9E4E57, 0xC072, 0x42A0, 0x89, 0x45, 0xAF, 0x50, 0x3E, 0xE5, 0x47, 0x68);};
template<> struct uuid<Windows::UI::Text::ITextSelection> { define_guid(0xA6D36724, 0xF28F, 0x430A, 0xB2, 0xCF, 0xC3, 0x43, 0x67, 0x1E, 0xC0, 0xE9);};
template<> struct uuid<Windows::UI::Text::ITextCharacterFormat> { define_guid(0x5ADEF3DB, 0x5FB, 0x442D, 0x80, 0x65, 0x64, 0x2A, 0xFE, 0xA0, 0x2C, 0xED);};
template<> struct uuid<Windows::UI::Text::ITextParagraphFormat> { define_guid(0x2CF8CFA6, 0x4676, 0x498A, 0x93, 0xF5, 0xBB, 0xDB, 0xFC, 0xB, 0xD8, 0x83);};
template<> struct uuid<Windows::UI::Text::ITextDocument2> { define_guid(0xF2311112, 0x8C89, 0x49C9, 0x91, 0x18, 0xF0, 0x57, 0xCB, 0xB8, 0x14, 0xEE);};
template<> struct uuid<Windows::UI::Text::IRichEditTextRange> { define_guid(0x374E3515, 0xBA8A, 0x4A6E, 0x8C, 0x59, 0xD, 0xDE, 0x3D, 0xC, 0xF5, 0xCD);};
template<> struct uuid<Windows::UI::Text::IContentLinkInfo> { define_guid(0x1ED52525, 0x1C5F, 0x48CB, 0xB3, 0x35, 0x78, 0xB5, 0xA, 0x2E, 0xE6, 0x42);};
template<> struct uuid<Windows::UI::Text::IFontWeights> { define_guid(0x7880A444, 0x1AB, 0x4997, 0x85, 0x17, 0xDF, 0x82, 0x2A, 0xC, 0x45, 0xF1);};
template<> struct uuid<Windows::UI::Text::IFontWeightsStatics> { define_guid(0xB3B579D5, 0x1BA9, 0x48EB, 0x9D, 0xAD, 0xC0, 0x95, 0xE8, 0xC2, 0x3B, 0xA3);};

// types

namespace Windows { namespace UI { namespace Text {

// ITextConstantsStatics
struct ITextConstantsStatics : IInspectable {
	virtual STDMETHODIMP _get_AutoColor(Color *value);
	virtual STDMETHODIMP _get_MinUnitCount(int *value);
	virtual STDMETHODIMP _get_MaxUnitCount(int *value);
	virtual STDMETHODIMP _get_UndefinedColor(Color *value);
	virtual STDMETHODIMP _get_UndefinedFloatValue(float *value);
	virtual STDMETHODIMP _get_UndefinedInt32Value(int *value);
	virtual STDMETHODIMP _get_UndefinedFontStretch(FontStretch *value);
	virtual STDMETHODIMP _get_UndefinedFontStyle(FontStyle *value);
};

// TextConstants
template<typename> struct TextConstants_statics {
	static struct _AutoColor : property {
		Color get() { Color value; hrcheck(get_activation_factory<TextConstants, ITextConstantsStatics>()->_get_AutoColor(&value)); return value; }
		Color operator()() { return get(); }
		operator Color () { return get(); }
	} AutoColor;
	static struct _MaxUnitCount : property {
		int get() { int value; hrcheck(get_activation_factory<TextConstants, ITextConstantsStatics>()->_get_MaxUnitCount(&value)); return value; }
		int operator()() { return get(); }
		operator int () { return get(); }
	} MaxUnitCount;
	static struct _MinUnitCount : property {
		int get() { int value; hrcheck(get_activation_factory<TextConstants, ITextConstantsStatics>()->_get_MinUnitCount(&value)); return value; }
		int operator()() { return get(); }
		operator int () { return get(); }
	} MinUnitCount;
	static struct _UndefinedColor : property {
		Color get() { Color value; hrcheck(get_activation_factory<TextConstants, ITextConstantsStatics>()->_get_UndefinedColor(&value)); return value; }
		Color operator()() { return get(); }
		operator Color () { return get(); }
	} UndefinedColor;
	static struct _UndefinedFloatValue : property {
		float get() { float value; hrcheck(get_activation_factory<TextConstants, ITextConstantsStatics>()->_get_UndefinedFloatValue(&value)); return value; }
		float operator()() { return get(); }
		operator float () { return get(); }
	} UndefinedFloatValue;
	static struct _UndefinedFontStretch : property {
		FontStretch get() { FontStretch value; hrcheck(get_activation_factory<TextConstants, ITextConstantsStatics>()->_get_UndefinedFontStretch(&value)); return value; }
		FontStretch operator()() { return get(); }
		operator FontStretch () { return get(); }
	} UndefinedFontStretch;
	static struct _UndefinedFontStyle : property {
		FontStyle get() { FontStyle value; hrcheck(get_activation_factory<TextConstants, ITextConstantsStatics>()->_get_UndefinedFontStyle(&value)); return value; }
		FontStyle operator()() { return get(); }
		operator FontStyle () { return get(); }
	} UndefinedFontStyle;
	static struct _UndefinedInt32Value : property {
		int get() { int value; hrcheck(get_activation_factory<TextConstants, ITextConstantsStatics>()->_get_UndefinedInt32Value(&value)); return value; }
		int operator()() { return get(); }
		operator int () { return get(); }
	} UndefinedInt32Value;
};
template<typename X> typename TextConstants_statics<X>::_AutoColor TextConstants_statics<X>::AutoColor;
template<typename X> typename TextConstants_statics<X>::_MaxUnitCount TextConstants_statics<X>::MaxUnitCount;
template<typename X> typename TextConstants_statics<X>::_MinUnitCount TextConstants_statics<X>::MinUnitCount;
template<typename X> typename TextConstants_statics<X>::_UndefinedColor TextConstants_statics<X>::UndefinedColor;
template<typename X> typename TextConstants_statics<X>::_UndefinedFloatValue TextConstants_statics<X>::UndefinedFloatValue;
template<typename X> typename TextConstants_statics<X>::_UndefinedFontStretch TextConstants_statics<X>::UndefinedFontStretch;
template<typename X> typename TextConstants_statics<X>::_UndefinedFontStyle TextConstants_statics<X>::UndefinedFontStyle;
template<typename X> typename TextConstants_statics<X>::_UndefinedInt32Value TextConstants_statics<X>::UndefinedInt32Value;

template<typename X> struct statics<TextConstants, X> : X, Windows::UI::Text::TextConstants_statics<void> {
	typedef typename X::root_type TextConstants;
};
struct TextConstants : generate<TextConstants> {};

// ITextDocument
struct ITextDocument_raw : IInspectable {
	virtual STDMETHODIMP _get_CaretType(Text::CaretType *value) = 0;
	virtual STDMETHODIMP _put_CaretType(Text::CaretType value) = 0;
	virtual STDMETHODIMP _get_DefaultTabStop(float *value) = 0;
	virtual STDMETHODIMP _put_DefaultTabStop(float value) = 0;
	virtual STDMETHODIMP _get_Selection(ITextSelection* *value) = 0;
	virtual STDMETHODIMP _get_UndoLimit(unsigned *value) = 0;
	virtual STDMETHODIMP _put_UndoLimit(unsigned value) = 0;
	virtual STDMETHODIMP _CanCopy(bool *value) = 0;
	virtual STDMETHODIMP _CanPaste(bool *value) = 0;
	virtual STDMETHODIMP _CanRedo(bool *value) = 0;
	virtual STDMETHODIMP _CanUndo(bool *value) = 0;
	virtual STDMETHODIMP _ApplyDisplayUpdates(int *count) = 0;
	virtual STDMETHODIMP _BatchDisplayUpdates(int *count) = 0;
	virtual STDMETHODIMP _BeginUndoGroup() = 0;
	virtual STDMETHODIMP _EndUndoGroup() = 0;
	virtual STDMETHODIMP _GetDefaultCharacterFormat(ITextCharacterFormat* *value) = 0;
	virtual STDMETHODIMP _GetDefaultParagraphFormat(ITextParagraphFormat* *value) = 0;
	virtual STDMETHODIMP _GetRange(int startPosition, int endPosition, ITextRange* *value) = 0;
	virtual STDMETHODIMP _GetRangeFromPoint(Foundation::Point point, PointOptions options, ITextRange* *value) = 0;
	virtual STDMETHODIMP _GetText(TextGetOptions options, HSTRING *value) = 0;
	virtual STDMETHODIMP _LoadFromStream(TextSetOptions options, Storage::Streams::IRandomAccessStream* value) = 0;
	virtual STDMETHODIMP _Redo() = 0;
	virtual STDMETHODIMP _SaveToStream(TextGetOptions options, Storage::Streams::IRandomAccessStream* value) = 0;
	virtual STDMETHODIMP _SetDefaultCharacterFormat(ITextCharacterFormat* value) = 0;
	virtual STDMETHODIMP _SetDefaultParagraphFormat(ITextParagraphFormat* value) = 0;
	virtual STDMETHODIMP _SetText(TextSetOptions options, HSTRING value) = 0;
	virtual STDMETHODIMP _Undo() = 0;
};
template<typename X> struct ITextDocument_adaptor : X {
	union {
		struct : property {
			Text::CaretType get() { Text::CaretType value; hrcheck(enc(&ITextDocument_adaptor::CaretType)->_get_CaretType(&value)); return value; }
			Text::CaretType operator()() { return get(); }
			operator Text::CaretType () { return get(); }
			void put(Text::CaretType value) { hrcheck(enc(&ITextDocument_adaptor::CaretType)->_put_CaretType(value)); }
			void operator=(Text::CaretType value) { put(value); }
			void operator()(Text::CaretType value) { put(value); }
		} CaretType;
		struct : property {
			float get() { float value; hrcheck(enc(&ITextDocument_adaptor::DefaultTabStop)->_get_DefaultTabStop(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ITextDocument_adaptor::DefaultTabStop)->_put_DefaultTabStop(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} DefaultTabStop;
		struct : property {
			ptr<ITextSelection> get() { ITextSelection* value; hrcheck(enc(&ITextDocument_adaptor::Selection)->_get_Selection(&value)); return from_abi(value); }
			ptr<ITextSelection> operator()() { return get(); }
			operator ptr<ITextSelection> () { return get(); }
			ptr<ITextSelection> operator->() { return get(); }
		} Selection;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&ITextDocument_adaptor::UndoLimit)->_get_UndoLimit(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&ITextDocument_adaptor::UndoLimit)->_put_UndoLimit(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} UndoLimit;
	};
	bool CanCopy() { bool value; hrcheck(X::get()->_CanCopy(&value)); return value; }
	bool CanPaste() { bool value; hrcheck(X::get()->_CanPaste(&value)); return value; }
	bool CanRedo() { bool value; hrcheck(X::get()->_CanRedo(&value)); return value; }
	bool CanUndo() { bool value; hrcheck(X::get()->_CanUndo(&value)); return value; }
	int ApplyDisplayUpdates() { int count; hrcheck(X::get()->_ApplyDisplayUpdates(&count)); return count; }
	int BatchDisplayUpdates() { int count; hrcheck(X::get()->_BatchDisplayUpdates(&count)); return count; }
	void BeginUndoGroup() { hrcheck(X::get()->_BeginUndoGroup()); }
	void EndUndoGroup() { hrcheck(X::get()->_EndUndoGroup()); }
	ptr<ITextCharacterFormat> GetDefaultCharacterFormat() { ITextCharacterFormat* value; hrcheck(X::get()->_GetDefaultCharacterFormat(&value)); return from_abi(value); }
	ptr<ITextParagraphFormat> GetDefaultParagraphFormat() { ITextParagraphFormat* value; hrcheck(X::get()->_GetDefaultParagraphFormat(&value)); return from_abi(value); }
	ptr<ITextRange> GetRange(int startPosition, int endPosition) { ITextRange* value; hrcheck(X::get()->_GetRange(startPosition, endPosition, &value)); return from_abi(value); }
	ptr<ITextRange> GetRangeFromPoint(const Foundation::Point& point, PointOptions options) { ITextRange* value; hrcheck(X::get()->_GetRangeFromPoint(point, options, &value)); return from_abi(value); }
	hstring GetText(TextGetOptions options) { HSTRING value; hrcheck(X::get()->_GetText(options, &value)); return from_abi(value); }
	void LoadFromStream(TextSetOptions options, pptr<Storage::Streams::IRandomAccessStream> value) { hrcheck(X::get()->_LoadFromStream(options, value)); }
	void Redo() { hrcheck(X::get()->_Redo()); }
	void SaveToStream(TextGetOptions options, pptr<Storage::Streams::IRandomAccessStream> value) { hrcheck(X::get()->_SaveToStream(options, value)); }
	void SetDefaultCharacterFormat(pptr<ITextCharacterFormat> value) { hrcheck(X::get()->_SetDefaultCharacterFormat(value)); }
	void SetDefaultParagraphFormat(pptr<ITextParagraphFormat> value) { hrcheck(X::get()->_SetDefaultParagraphFormat(value)); }
	void SetText(TextSetOptions options, hstring_ref value) { hrcheck(X::get()->_SetText(options, value)); }
	void Undo() { hrcheck(X::get()->_Undo()); }
	ITextDocument_adaptor() {}
};
template<typename X> struct adapt<ITextDocument, X> : Windows::UI::Text::ITextDocument_adaptor<X> { typedef adapt ITextDocument; };
template<typename X> struct ITextDocument_unadaptor : X {
	STDMETHODIMP _get_CaretType(Text::CaretType *value) { return hrtry([&, this] { get_prop(value, CaretType); }); }
	STDMETHODIMP _put_CaretType(Text::CaretType value) { return hrtry([&, this] { put_prop(value, CaretType); }); }
	STDMETHODIMP _get_DefaultTabStop(float *value) { return hrtry([&, this] { get_prop(value, DefaultTabStop); }); }
	STDMETHODIMP _put_DefaultTabStop(float value) { return hrtry([&, this] { put_prop(value, DefaultTabStop); }); }
	STDMETHODIMP _get_Selection(ITextSelection* *value) { return hrtry([&, this] { get_prop(value, Selection); }); }
	STDMETHODIMP _get_UndoLimit(unsigned *value) { return hrtry([&, this] { get_prop(value, UndoLimit); }); }
	STDMETHODIMP _put_UndoLimit(unsigned value) { return hrtry([&, this] { put_prop(value, UndoLimit); }); }
	STDMETHODIMP _CanCopy(bool *value) { return hrtry([&, this] { *value = X::get()->CanCopy(); }); }
	STDMETHODIMP _CanPaste(bool *value) { return hrtry([&, this] { *value = X::get()->CanPaste(); }); }
	STDMETHODIMP _CanRedo(bool *value) { return hrtry([&, this] { *value = X::get()->CanRedo(); }); }
	STDMETHODIMP _CanUndo(bool *value) { return hrtry([&, this] { *value = X::get()->CanUndo(); }); }
	STDMETHODIMP _ApplyDisplayUpdates(int *count) { return hrtry([&, this] { *count = X::get()->ApplyDisplayUpdates(); }); }
	STDMETHODIMP _BatchDisplayUpdates(int *count) { return hrtry([&, this] { *count = X::get()->BatchDisplayUpdates(); }); }
	STDMETHODIMP _BeginUndoGroup() { return hrtry([&, this] { X::get()->BeginUndoGroup(); }); }
	STDMETHODIMP _EndUndoGroup() { return hrtry([&, this] { X::get()->EndUndoGroup(); }); }
	STDMETHODIMP _GetDefaultCharacterFormat(ITextCharacterFormat* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetDefaultCharacterFormat()); }); }
	STDMETHODIMP _GetDefaultParagraphFormat(ITextParagraphFormat* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetDefaultParagraphFormat()); }); }
	STDMETHODIMP _GetRange(int startPosition, int endPosition, ITextRange* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetRange(startPosition, endPosition)); }); }
	STDMETHODIMP _GetRangeFromPoint(Foundation::Point point, PointOptions options, ITextRange* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetRangeFromPoint(point, options)); }); }
	STDMETHODIMP _GetText(TextGetOptions options, HSTRING *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetText(options, )); }); }
	STDMETHODIMP _LoadFromStream(TextSetOptions options, Storage::Streams::IRandomAccessStream* value) { return hrtry([&, this] { X::get()->LoadFromStream(options, value); }); }
	STDMETHODIMP _Redo() { return hrtry([&, this] { X::get()->Redo(); }); }
	STDMETHODIMP _SaveToStream(TextGetOptions options, Storage::Streams::IRandomAccessStream* value) { return hrtry([&, this] { X::get()->SaveToStream(options, value); }); }
	STDMETHODIMP _SetDefaultCharacterFormat(ITextCharacterFormat* value) { return hrtry([&, this] { X::get()->SetDefaultCharacterFormat(value); }); }
	STDMETHODIMP _SetDefaultParagraphFormat(ITextParagraphFormat* value) { return hrtry([&, this] { X::get()->SetDefaultParagraphFormat(value); }); }
	STDMETHODIMP _SetText(TextSetOptions options, HSTRING value) { return hrtry([&, this] { X::get()->SetText(options, value); }); }
	STDMETHODIMP _Undo() { return hrtry([&, this] { X::get()->Undo(); }); }
};
template<typename X> struct unadapt<ITextDocument, X> : Windows::UI::Text::ITextDocument_unadaptor<X> {};
struct ITextDocument : ITextDocument_raw, generate<ITextDocument> {};

// ITextRange
struct ITextRange_raw : IInspectable {
	virtual STDMETHODIMP _get_Character(char *value) = 0;
	virtual STDMETHODIMP _put_Character(char value) = 0;
	virtual STDMETHODIMP _get_CharacterFormat(ITextCharacterFormat* *value) = 0;
	virtual STDMETHODIMP _put_CharacterFormat(ITextCharacterFormat* value) = 0;
	virtual STDMETHODIMP _get_FormattedText(ITextRange* *value) = 0;
	virtual STDMETHODIMP _put_FormattedText(ITextRange* value) = 0;
	virtual STDMETHODIMP _get_EndPosition(int *value) = 0;
	virtual STDMETHODIMP _put_EndPosition(int value) = 0;
	virtual STDMETHODIMP _get_Gravity(RangeGravity *value) = 0;
	virtual STDMETHODIMP _put_Gravity(RangeGravity value) = 0;
	virtual STDMETHODIMP _get_Length(int *length) = 0;
	virtual STDMETHODIMP _get_Link(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_Link(HSTRING value) = 0;
	virtual STDMETHODIMP _get_ParagraphFormat(ITextParagraphFormat* *value) = 0;
	virtual STDMETHODIMP _put_ParagraphFormat(ITextParagraphFormat* value) = 0;
	virtual STDMETHODIMP _get_StartPosition(int *value) = 0;
	virtual STDMETHODIMP _put_StartPosition(int value) = 0;
	virtual STDMETHODIMP _get_StoryLength(int *value) = 0;
	virtual STDMETHODIMP _get_Text(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_Text(HSTRING value) = 0;
	virtual STDMETHODIMP _CanPaste(int format, bool *value) = 0;
	virtual STDMETHODIMP _ChangeCase(LetterCase value) = 0;
	virtual STDMETHODIMP _Collapse(bool value) = 0;
	virtual STDMETHODIMP _Copy() = 0;
	virtual STDMETHODIMP _Cut() = 0;
	virtual STDMETHODIMP _Delete(TextRangeUnit unit, int count, int *delta) = 0;
	virtual STDMETHODIMP _EndOf(TextRangeUnit unit, bool extend, int *delta) = 0;
	virtual STDMETHODIMP _Expand(TextRangeUnit unit, int *delta) = 0;
	virtual STDMETHODIMP _FindText(HSTRING value, int scanLength, FindOptions options, int *length) = 0;
	virtual STDMETHODIMP _GetCharacterUtf32(unsigned *value, int offset) = 0;
	virtual STDMETHODIMP _GetClone(ITextRange* *value) = 0;
	virtual STDMETHODIMP _GetIndex(TextRangeUnit unit, int *index) = 0;
	virtual STDMETHODIMP _GetPoint(HorizontalCharacterAlignment horizontalAlign, VerticalCharacterAlignment verticalAlign, PointOptions options, Foundation::Point *point) = 0;
	virtual STDMETHODIMP _GetRect(PointOptions options, Foundation::Rect *rect, int *hit) = 0;
	virtual STDMETHODIMP _GetText(TextGetOptions options, HSTRING *value) = 0;
	virtual STDMETHODIMP _GetTextViaStream(TextGetOptions options, Storage::Streams::IRandomAccessStream* value) = 0;
	virtual STDMETHODIMP _InRange(ITextRange* range, bool *value) = 0;
	virtual STDMETHODIMP _InsertImage(int width, int height, int ascent, VerticalCharacterAlignment verticalAlign, HSTRING alternateText, Storage::Streams::IRandomAccessStream* value) = 0;
	virtual STDMETHODIMP _InStory(ITextRange* range, bool *value) = 0;
	virtual STDMETHODIMP _IsEqual(ITextRange* range, bool *value) = 0;
	virtual STDMETHODIMP _Move(TextRangeUnit unit, int count, int *delta) = 0;
	virtual STDMETHODIMP _MoveEnd(TextRangeUnit unit, int count, int *delta) = 0;
	virtual STDMETHODIMP _MoveStart(TextRangeUnit unit, int count, int *delta) = 0;
	virtual STDMETHODIMP _Paste(int format) = 0;
	virtual STDMETHODIMP _ScrollIntoView(PointOptions value) = 0;
	virtual STDMETHODIMP _MatchSelection() = 0;
	virtual STDMETHODIMP _SetIndex(TextRangeUnit unit, int index, bool extend) = 0;
	virtual STDMETHODIMP _SetPoint(Foundation::Point point, PointOptions options, bool extend) = 0;
	virtual STDMETHODIMP _SetRange(int startPosition, int endPosition) = 0;
	virtual STDMETHODIMP _SetText(TextSetOptions options, HSTRING value) = 0;
	virtual STDMETHODIMP _SetTextViaStream(TextSetOptions options, Storage::Streams::IRandomAccessStream* value) = 0;
	virtual STDMETHODIMP _StartOf(TextRangeUnit unit, bool extend, int *delta) = 0;
};
template<typename X> struct ITextRange_adaptor : X {
	union {
		struct : property {
			char get() { char value; hrcheck(enc(&ITextRange_adaptor::Character)->_get_Character(&value)); return value; }
			char operator()() { return get(); }
			operator char () { return get(); }
			void put(char value) { hrcheck(enc(&ITextRange_adaptor::Character)->_put_Character(value)); }
			void operator=(char value) { put(value); }
			void operator()(char value) { put(value); }
		} Character;
		struct : property {
			ptr<ITextCharacterFormat> get() { ITextCharacterFormat* value; hrcheck(enc(&ITextRange_adaptor::CharacterFormat)->_get_CharacterFormat(&value)); return from_abi(value); }
			ptr<ITextCharacterFormat> operator()() { return get(); }
			operator ptr<ITextCharacterFormat> () { return get(); }
			ptr<ITextCharacterFormat> operator->() { return get(); }
			void put(pptr<ITextCharacterFormat> value) { hrcheck(enc(&ITextRange_adaptor::CharacterFormat)->_put_CharacterFormat(value)); }
			void operator=(pptr<ITextCharacterFormat> value) { put(value); }
			void operator()(pptr<ITextCharacterFormat> value) { put(value); }
		} CharacterFormat;
		struct : property {
			int get() { int value; hrcheck(enc(&ITextRange_adaptor::EndPosition)->_get_EndPosition(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ITextRange_adaptor::EndPosition)->_put_EndPosition(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} EndPosition;
		struct : property {
			ptr<ITextRange> get() { ITextRange* value; hrcheck(enc(&ITextRange_adaptor::FormattedText)->_get_FormattedText(&value)); return from_abi(value); }
			ptr<ITextRange> operator()() { return get(); }
			operator ptr<ITextRange> () { return get(); }
			ptr<ITextRange> operator->() { return get(); }
			void put(pptr<ITextRange> value) { hrcheck(enc(&ITextRange_adaptor::FormattedText)->_put_FormattedText(value)); }
			void operator=(pptr<ITextRange> value) { put(value); }
			void operator()(pptr<ITextRange> value) { put(value); }
		} FormattedText;
		struct : property {
			RangeGravity get() { RangeGravity value; hrcheck(enc(&ITextRange_adaptor::Gravity)->_get_Gravity(&value)); return value; }
			RangeGravity operator()() { return get(); }
			operator RangeGravity () { return get(); }
			void put(RangeGravity value) { hrcheck(enc(&ITextRange_adaptor::Gravity)->_put_Gravity(value)); }
			void operator=(RangeGravity value) { put(value); }
			void operator()(RangeGravity value) { put(value); }
		} Gravity;
		struct : property {
			int get() { int length; hrcheck(enc(&ITextRange_adaptor::Length)->_get_Length(&length)); return length; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} Length;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITextRange_adaptor::Link)->_get_Link(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITextRange_adaptor::Link)->_put_Link(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Link;
		struct : property {
			ptr<ITextParagraphFormat> get() { ITextParagraphFormat* value; hrcheck(enc(&ITextRange_adaptor::ParagraphFormat)->_get_ParagraphFormat(&value)); return from_abi(value); }
			ptr<ITextParagraphFormat> operator()() { return get(); }
			operator ptr<ITextParagraphFormat> () { return get(); }
			ptr<ITextParagraphFormat> operator->() { return get(); }
			void put(pptr<ITextParagraphFormat> value) { hrcheck(enc(&ITextRange_adaptor::ParagraphFormat)->_put_ParagraphFormat(value)); }
			void operator=(pptr<ITextParagraphFormat> value) { put(value); }
			void operator()(pptr<ITextParagraphFormat> value) { put(value); }
		} ParagraphFormat;
		struct : property {
			int get() { int value; hrcheck(enc(&ITextRange_adaptor::StartPosition)->_get_StartPosition(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ITextRange_adaptor::StartPosition)->_put_StartPosition(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} StartPosition;
		struct : property {
			int get() { int value; hrcheck(enc(&ITextRange_adaptor::StoryLength)->_get_StoryLength(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} StoryLength;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITextRange_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITextRange_adaptor::Text)->_put_Text(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Text;
	};
	bool CanPaste(int format) { bool value; hrcheck(X::get()->_CanPaste(format, &value)); return value; }
	void ChangeCase(LetterCase value) { hrcheck(X::get()->_ChangeCase(value)); }
	void Collapse(bool value) { hrcheck(X::get()->_Collapse(value)); }
	void Copy() { hrcheck(X::get()->_Copy()); }
	void Cut() { hrcheck(X::get()->_Cut()); }
	int Delete(TextRangeUnit unit, int count) { int delta; hrcheck(X::get()->_Delete(unit, count, &delta)); return delta; }
	int EndOf(TextRangeUnit unit, bool extend) { int delta; hrcheck(X::get()->_EndOf(unit, extend, &delta)); return delta; }
	int Expand(TextRangeUnit unit) { int delta; hrcheck(X::get()->_Expand(unit, &delta)); return delta; }
	int FindText(hstring_ref value, int scanLength, FindOptions options) { int length; hrcheck(X::get()->_FindText(value, scanLength, options, &length)); return length; }
	unsigned GetCharacterUtf32(int offset) { unsigned value; hrcheck(X::get()->_GetCharacterUtf32(&value, offset)); return value; }
	ptr<ITextRange> GetClone() { ITextRange* value; hrcheck(X::get()->_GetClone(&value)); return from_abi(value); }
	int GetIndex(TextRangeUnit unit) { int index; hrcheck(X::get()->_GetIndex(unit, &index)); return index; }
	Foundation::Point GetPoint(HorizontalCharacterAlignment horizontalAlign, VerticalCharacterAlignment verticalAlign, PointOptions options) { Foundation::Point point; hrcheck(X::get()->_GetPoint(horizontalAlign, verticalAlign, options, &point)); return point; }
	int GetRect(PointOptions options, Foundation::Rect *rect) { int hit; hrcheck(X::get()->_GetRect(options, rect, &hit)); return hit; }
	hstring GetText(TextGetOptions options) { HSTRING value; hrcheck(X::get()->_GetText(options, &value)); return from_abi(value); }
	void GetTextViaStream(TextGetOptions options, pptr<Storage::Streams::IRandomAccessStream> value) { hrcheck(X::get()->_GetTextViaStream(options, value)); }
	bool InRange(pptr<ITextRange> range) { bool value; hrcheck(X::get()->_InRange(range, &value)); return value; }
	void InsertImage(int width, int height, int ascent, VerticalCharacterAlignment verticalAlign, hstring_ref alternateText, pptr<Storage::Streams::IRandomAccessStream> value) { hrcheck(X::get()->_InsertImage(width, height, ascent, verticalAlign, alternateText, value)); }
	bool InStory(pptr<ITextRange> range) { bool value; hrcheck(X::get()->_InStory(range, &value)); return value; }
	bool IsEqual(pptr<ITextRange> range) { bool value; hrcheck(X::get()->_IsEqual(range, &value)); return value; }
	int Move(TextRangeUnit unit, int count) { int delta; hrcheck(X::get()->_Move(unit, count, &delta)); return delta; }
	int MoveEnd(TextRangeUnit unit, int count) { int delta; hrcheck(X::get()->_MoveEnd(unit, count, &delta)); return delta; }
	int MoveStart(TextRangeUnit unit, int count) { int delta; hrcheck(X::get()->_MoveStart(unit, count, &delta)); return delta; }
	void Paste(int format) { hrcheck(X::get()->_Paste(format)); }
	void ScrollIntoView(PointOptions value) { hrcheck(X::get()->_ScrollIntoView(value)); }
	void MatchSelection() { hrcheck(X::get()->_MatchSelection()); }
	void SetIndex(TextRangeUnit unit, int index, bool extend) { hrcheck(X::get()->_SetIndex(unit, index, extend)); }
	void SetPoint(const Foundation::Point& point, PointOptions options, bool extend) { hrcheck(X::get()->_SetPoint(point, options, extend)); }
	void SetRange(int startPosition, int endPosition) { hrcheck(X::get()->_SetRange(startPosition, endPosition)); }
	void SetText(TextSetOptions options, hstring_ref value) { hrcheck(X::get()->_SetText(options, value)); }
	void SetTextViaStream(TextSetOptions options, pptr<Storage::Streams::IRandomAccessStream> value) { hrcheck(X::get()->_SetTextViaStream(options, value)); }
	int StartOf(TextRangeUnit unit, bool extend) { int delta; hrcheck(X::get()->_StartOf(unit, extend, &delta)); return delta; }
	ITextRange_adaptor() {}
};
template<typename X> struct adapt<ITextRange, X> : Windows::UI::Text::ITextRange_adaptor<X> { typedef adapt ITextRange; };
template<typename X> struct ITextRange_unadaptor : X {
	STDMETHODIMP _get_Character(char *value) { return hrtry([&, this] { get_prop(value, Character); }); }
	STDMETHODIMP _put_Character(char value) { return hrtry([&, this] { put_prop(value, Character); }); }
	STDMETHODIMP _get_CharacterFormat(ITextCharacterFormat* *value) { return hrtry([&, this] { get_prop(value, CharacterFormat); }); }
	STDMETHODIMP _put_CharacterFormat(ITextCharacterFormat* value) { return hrtry([&, this] { put_prop(value, CharacterFormat); }); }
	STDMETHODIMP _get_FormattedText(ITextRange* *value) { return hrtry([&, this] { get_prop(value, FormattedText); }); }
	STDMETHODIMP _put_FormattedText(ITextRange* value) { return hrtry([&, this] { put_prop(value, FormattedText); }); }
	STDMETHODIMP _get_EndPosition(int *value) { return hrtry([&, this] { get_prop(value, EndPosition); }); }
	STDMETHODIMP _put_EndPosition(int value) { return hrtry([&, this] { put_prop(value, EndPosition); }); }
	STDMETHODIMP _get_Gravity(RangeGravity *value) { return hrtry([&, this] { get_prop(value, Gravity); }); }
	STDMETHODIMP _put_Gravity(RangeGravity value) { return hrtry([&, this] { put_prop(value, Gravity); }); }
	STDMETHODIMP _get_Length(int *length) { return hrtry([&, this] { get_prop(length, Length); }); }
	STDMETHODIMP _get_Link(HSTRING *value) { return hrtry([&, this] { get_prop(value, Link); }); }
	STDMETHODIMP _put_Link(HSTRING value) { return hrtry([&, this] { put_prop(value, Link); }); }
	STDMETHODIMP _get_ParagraphFormat(ITextParagraphFormat* *value) { return hrtry([&, this] { get_prop(value, ParagraphFormat); }); }
	STDMETHODIMP _put_ParagraphFormat(ITextParagraphFormat* value) { return hrtry([&, this] { put_prop(value, ParagraphFormat); }); }
	STDMETHODIMP _get_StartPosition(int *value) { return hrtry([&, this] { get_prop(value, StartPosition); }); }
	STDMETHODIMP _put_StartPosition(int value) { return hrtry([&, this] { put_prop(value, StartPosition); }); }
	STDMETHODIMP _get_StoryLength(int *value) { return hrtry([&, this] { get_prop(value, StoryLength); }); }
	STDMETHODIMP _get_Text(HSTRING *value) { return hrtry([&, this] { get_prop(value, Text); }); }
	STDMETHODIMP _put_Text(HSTRING value) { return hrtry([&, this] { put_prop(value, Text); }); }
	STDMETHODIMP _CanPaste(int format, bool *value) { return hrtry([&, this] { *value = X::get()->CanPaste(format); }); }
	STDMETHODIMP _ChangeCase(LetterCase value) { return hrtry([&, this] { X::get()->ChangeCase(value); }); }
	STDMETHODIMP _Collapse(bool value) { return hrtry([&, this] { X::get()->Collapse(value); }); }
	STDMETHODIMP _Copy() { return hrtry([&, this] { X::get()->Copy(); }); }
	STDMETHODIMP _Cut() { return hrtry([&, this] { X::get()->Cut(); }); }
	STDMETHODIMP _Delete(TextRangeUnit unit, int count, int *delta) { return hrtry([&, this] { *delta = X::get()->Delete(unit, count); }); }
	STDMETHODIMP _EndOf(TextRangeUnit unit, bool extend, int *delta) { return hrtry([&, this] { *delta = X::get()->EndOf(unit, extend); }); }
	STDMETHODIMP _Expand(TextRangeUnit unit, int *delta) { return hrtry([&, this] { *delta = X::get()->Expand(unit); }); }
	STDMETHODIMP _FindText(HSTRING value, int scanLength, FindOptions options, int *length) { return hrtry([&, this] { *length = X::get()->FindText(value, scanLength, options); }); }
	STDMETHODIMP _GetCharacterUtf32(unsigned *value, int offset) { return hrtry([&, this] { *value = X::get()->GetCharacterUtf32(offset); }); }
	STDMETHODIMP _GetClone(ITextRange* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetClone()); }); }
	STDMETHODIMP _GetIndex(TextRangeUnit unit, int *index) { return hrtry([&, this] { *index = X::get()->GetIndex(unit); }); }
	STDMETHODIMP _GetPoint(HorizontalCharacterAlignment horizontalAlign, VerticalCharacterAlignment verticalAlign, PointOptions options, Foundation::Point *point) { return hrtry([&, this] { *point = X::get()->GetPoint(horizontalAlign, verticalAlign, options, ); }); }
	STDMETHODIMP _GetRect(PointOptions options, Foundation::Rect *rect, int *hit) { return hrtry([&, this] { *hit = X::get()->GetRect(options, rect, ); }); }
	STDMETHODIMP _GetText(TextGetOptions options, HSTRING *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetText(options, )); }); }
	STDMETHODIMP _GetTextViaStream(TextGetOptions options, Storage::Streams::IRandomAccessStream* value) { return hrtry([&, this] { X::get()->GetTextViaStream(options, value); }); }
	STDMETHODIMP _InRange(ITextRange* range, bool *value) { return hrtry([&, this] { *value = X::get()->InRange(range); }); }
	STDMETHODIMP _InsertImage(int width, int height, int ascent, VerticalCharacterAlignment verticalAlign, HSTRING alternateText, Storage::Streams::IRandomAccessStream* value) { return hrtry([&, this] { X::get()->InsertImage(width, height, ascent, verticalAlign, alternateText, value); }); }
	STDMETHODIMP _InStory(ITextRange* range, bool *value) { return hrtry([&, this] { *value = X::get()->InStory(range); }); }
	STDMETHODIMP _IsEqual(ITextRange* range, bool *value) { return hrtry([&, this] { *value = X::get()->IsEqual(range); }); }
	STDMETHODIMP _Move(TextRangeUnit unit, int count, int *delta) { return hrtry([&, this] { *delta = X::get()->Move(unit, count); }); }
	STDMETHODIMP _MoveEnd(TextRangeUnit unit, int count, int *delta) { return hrtry([&, this] { *delta = X::get()->MoveEnd(unit, count); }); }
	STDMETHODIMP _MoveStart(TextRangeUnit unit, int count, int *delta) { return hrtry([&, this] { *delta = X::get()->MoveStart(unit, count); }); }
	STDMETHODIMP _Paste(int format) { return hrtry([&, this] { X::get()->Paste(format); }); }
	STDMETHODIMP _ScrollIntoView(PointOptions value) { return hrtry([&, this] { X::get()->ScrollIntoView(value); }); }
	STDMETHODIMP _MatchSelection() { return hrtry([&, this] { X::get()->MatchSelection(); }); }
	STDMETHODIMP _SetIndex(TextRangeUnit unit, int index, bool extend) { return hrtry([&, this] { X::get()->SetIndex(unit, index, extend); }); }
	STDMETHODIMP _SetPoint(Foundation::Point point, PointOptions options, bool extend) { return hrtry([&, this] { X::get()->SetPoint(point, options, extend); }); }
	STDMETHODIMP _SetRange(int startPosition, int endPosition) { return hrtry([&, this] { X::get()->SetRange(startPosition, endPosition); }); }
	STDMETHODIMP _SetText(TextSetOptions options, HSTRING value) { return hrtry([&, this] { X::get()->SetText(options, value); }); }
	STDMETHODIMP _SetTextViaStream(TextSetOptions options, Storage::Streams::IRandomAccessStream* value) { return hrtry([&, this] { X::get()->SetTextViaStream(options, value); }); }
	STDMETHODIMP _StartOf(TextRangeUnit unit, bool extend, int *delta) { return hrtry([&, this] { *delta = X::get()->StartOf(unit, extend); }); }
};
template<typename X> struct unadapt<ITextRange, X> : Windows::UI::Text::ITextRange_unadaptor<X> {};
struct ITextRange : ITextRange_raw, generate<ITextRange> {};

// ITextSelection
struct ITextSelection_raw : IInspectable {
	virtual STDMETHODIMP _get_Options(SelectionOptions *value) = 0;
	virtual STDMETHODIMP _put_Options(SelectionOptions value) = 0;
	virtual STDMETHODIMP _get_Type(SelectionType *value) = 0;
	virtual STDMETHODIMP _EndKey(TextRangeUnit unit, bool extend, int *delta) = 0;
	virtual STDMETHODIMP _HomeKey(TextRangeUnit unit, bool extend, int *delta) = 0;
	virtual STDMETHODIMP _MoveDown(TextRangeUnit unit, int count, bool extend, int *delta) = 0;
	virtual STDMETHODIMP _MoveLeft(TextRangeUnit unit, int count, bool extend, int *delta) = 0;
	virtual STDMETHODIMP _MoveRight(TextRangeUnit unit, int count, bool extend, int *delta) = 0;
	virtual STDMETHODIMP _MoveUp(TextRangeUnit unit, int count, bool extend, int *delta) = 0;
	virtual STDMETHODIMP _TypeText(HSTRING value) = 0;
};
template<typename X> struct ITextSelection_adaptor : X {
	union {
		struct : property {
			SelectionOptions get() { SelectionOptions value; hrcheck(enc(&ITextSelection_adaptor::Options)->_get_Options(&value)); return value; }
			SelectionOptions operator()() { return get(); }
			operator SelectionOptions () { return get(); }
			void put(SelectionOptions value) { hrcheck(enc(&ITextSelection_adaptor::Options)->_put_Options(value)); }
			void operator=(SelectionOptions value) { put(value); }
			void operator()(SelectionOptions value) { put(value); }
		} Options;
		struct : property {
			SelectionType get() { SelectionType value; hrcheck(enc(&ITextSelection_adaptor::Type)->_get_Type(&value)); return value; }
			SelectionType operator()() { return get(); }
			operator SelectionType () { return get(); }
		} Type;
	};
	int EndKey(TextRangeUnit unit, bool extend) { int delta; hrcheck(X::get()->_EndKey(unit, extend, &delta)); return delta; }
	int HomeKey(TextRangeUnit unit, bool extend) { int delta; hrcheck(X::get()->_HomeKey(unit, extend, &delta)); return delta; }
	int MoveDown(TextRangeUnit unit, int count, bool extend) { int delta; hrcheck(X::get()->_MoveDown(unit, count, extend, &delta)); return delta; }
	int MoveLeft(TextRangeUnit unit, int count, bool extend) { int delta; hrcheck(X::get()->_MoveLeft(unit, count, extend, &delta)); return delta; }
	int MoveRight(TextRangeUnit unit, int count, bool extend) { int delta; hrcheck(X::get()->_MoveRight(unit, count, extend, &delta)); return delta; }
	int MoveUp(TextRangeUnit unit, int count, bool extend) { int delta; hrcheck(X::get()->_MoveUp(unit, count, extend, &delta)); return delta; }
	void TypeText(hstring_ref value) { hrcheck(X::get()->_TypeText(value)); }
	ITextSelection_adaptor() {}
};
template<typename X> struct adapt<ITextSelection, X> : Windows::UI::Text::ITextSelection_adaptor<X> { typedef adapt ITextSelection; };
template<typename X> struct ITextSelection_unadaptor : X {
	STDMETHODIMP _get_Options(SelectionOptions *value) { return hrtry([&, this] { get_prop(value, Options); }); }
	STDMETHODIMP _put_Options(SelectionOptions value) { return hrtry([&, this] { put_prop(value, Options); }); }
	STDMETHODIMP _get_Type(SelectionType *value) { return hrtry([&, this] { get_prop(value, Type); }); }
	STDMETHODIMP _EndKey(TextRangeUnit unit, bool extend, int *delta) { return hrtry([&, this] { *delta = X::get()->EndKey(unit, extend); }); }
	STDMETHODIMP _HomeKey(TextRangeUnit unit, bool extend, int *delta) { return hrtry([&, this] { *delta = X::get()->HomeKey(unit, extend); }); }
	STDMETHODIMP _MoveDown(TextRangeUnit unit, int count, bool extend, int *delta) { return hrtry([&, this] { *delta = X::get()->MoveDown(unit, count, extend); }); }
	STDMETHODIMP _MoveLeft(TextRangeUnit unit, int count, bool extend, int *delta) { return hrtry([&, this] { *delta = X::get()->MoveLeft(unit, count, extend); }); }
	STDMETHODIMP _MoveRight(TextRangeUnit unit, int count, bool extend, int *delta) { return hrtry([&, this] { *delta = X::get()->MoveRight(unit, count, extend); }); }
	STDMETHODIMP _MoveUp(TextRangeUnit unit, int count, bool extend, int *delta) { return hrtry([&, this] { *delta = X::get()->MoveUp(unit, count, extend); }); }
	STDMETHODIMP _TypeText(HSTRING value) { return hrtry([&, this] { X::get()->TypeText(value); }); }
};
template<typename X> struct unadapt<ITextSelection, X> : Windows::UI::Text::ITextSelection_unadaptor<X> {};
struct ITextSelection : ITextSelection_raw, generate<ITextSelection> {};

// ITextCharacterFormat
struct ITextCharacterFormat_raw : IInspectable {
	virtual STDMETHODIMP _get_AllCaps(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_AllCaps(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_BackgroundColor(Color *value) = 0;
	virtual STDMETHODIMP _put_BackgroundColor(Color value) = 0;
	virtual STDMETHODIMP _get_Bold(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_Bold(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_FontStretch(Text::FontStretch *value) = 0;
	virtual STDMETHODIMP _put_FontStretch(Text::FontStretch value) = 0;
	virtual STDMETHODIMP _get_FontStyle(Text::FontStyle *value) = 0;
	virtual STDMETHODIMP _put_FontStyle(Text::FontStyle value) = 0;
	virtual STDMETHODIMP _get_ForegroundColor(Color *value) = 0;
	virtual STDMETHODIMP _put_ForegroundColor(Color value) = 0;
	virtual STDMETHODIMP _get_Hidden(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_Hidden(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_Italic(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_Italic(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_Kerning(float *value) = 0;
	virtual STDMETHODIMP _put_Kerning(float value) = 0;
	virtual STDMETHODIMP _get_LanguageTag(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_LanguageTag(HSTRING value) = 0;
	virtual STDMETHODIMP _get_LinkType(Text::LinkType *value) = 0;
	virtual STDMETHODIMP _get_Name(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_Name(HSTRING value) = 0;
	virtual STDMETHODIMP _get_Outline(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_Outline(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_Position(float *value) = 0;
	virtual STDMETHODIMP _put_Position(float value) = 0;
	virtual STDMETHODIMP _get_ProtectedText(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_ProtectedText(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_Size(float *value) = 0;
	virtual STDMETHODIMP _put_Size(float value) = 0;
	virtual STDMETHODIMP _get_SmallCaps(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_SmallCaps(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_Spacing(float *value) = 0;
	virtual STDMETHODIMP _put_Spacing(float value) = 0;
	virtual STDMETHODIMP _get_Strikethrough(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_Strikethrough(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_Subscript(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_Subscript(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_Superscript(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_Superscript(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_TextScript(Text::TextScript *value) = 0;
	virtual STDMETHODIMP _put_TextScript(Text::TextScript value) = 0;
	virtual STDMETHODIMP _get_Underline(UnderlineType *value) = 0;
	virtual STDMETHODIMP _put_Underline(UnderlineType value) = 0;
	virtual STDMETHODIMP _get_Weight(int *value) = 0;
	virtual STDMETHODIMP _put_Weight(int value) = 0;
	virtual STDMETHODIMP _SetClone(ITextCharacterFormat* value) = 0;
	virtual STDMETHODIMP _GetClone(ITextCharacterFormat* *value) = 0;
	virtual STDMETHODIMP _IsEqual(ITextCharacterFormat* format, bool *value) = 0;
};
template<typename X> struct ITextCharacterFormat_adaptor : X {
	union {
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextCharacterFormat_adaptor::AllCaps)->_get_AllCaps(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextCharacterFormat_adaptor::AllCaps)->_put_AllCaps(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} AllCaps;
		struct : property {
			Color get() { Color value; hrcheck(enc(&ITextCharacterFormat_adaptor::BackgroundColor)->_get_BackgroundColor(&value)); return value; }
			Color operator()() { return get(); }
			operator Color () { return get(); }
			void put(const Color& value) { hrcheck(enc(&ITextCharacterFormat_adaptor::BackgroundColor)->_put_BackgroundColor(value)); }
			void operator=(const Color& value) { put(value); }
			void operator()(const Color& value) { put(value); }
		} BackgroundColor;
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextCharacterFormat_adaptor::Bold)->_get_Bold(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextCharacterFormat_adaptor::Bold)->_put_Bold(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} Bold;
		struct : property {
			Text::FontStretch get() { Text::FontStretch value; hrcheck(enc(&ITextCharacterFormat_adaptor::FontStretch)->_get_FontStretch(&value)); return value; }
			Text::FontStretch operator()() { return get(); }
			operator Text::FontStretch () { return get(); }
			void put(Text::FontStretch value) { hrcheck(enc(&ITextCharacterFormat_adaptor::FontStretch)->_put_FontStretch(value)); }
			void operator=(Text::FontStretch value) { put(value); }
			void operator()(Text::FontStretch value) { put(value); }
		} FontStretch;
		struct : property {
			Text::FontStyle get() { Text::FontStyle value; hrcheck(enc(&ITextCharacterFormat_adaptor::FontStyle)->_get_FontStyle(&value)); return value; }
			Text::FontStyle operator()() { return get(); }
			operator Text::FontStyle () { return get(); }
			void put(Text::FontStyle value) { hrcheck(enc(&ITextCharacterFormat_adaptor::FontStyle)->_put_FontStyle(value)); }
			void operator=(Text::FontStyle value) { put(value); }
			void operator()(Text::FontStyle value) { put(value); }
		} FontStyle;
		struct : property {
			Color get() { Color value; hrcheck(enc(&ITextCharacterFormat_adaptor::ForegroundColor)->_get_ForegroundColor(&value)); return value; }
			Color operator()() { return get(); }
			operator Color () { return get(); }
			void put(const Color& value) { hrcheck(enc(&ITextCharacterFormat_adaptor::ForegroundColor)->_put_ForegroundColor(value)); }
			void operator=(const Color& value) { put(value); }
			void operator()(const Color& value) { put(value); }
		} ForegroundColor;
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextCharacterFormat_adaptor::Hidden)->_get_Hidden(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextCharacterFormat_adaptor::Hidden)->_put_Hidden(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} Hidden;
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextCharacterFormat_adaptor::Italic)->_get_Italic(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextCharacterFormat_adaptor::Italic)->_put_Italic(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} Italic;
		struct : property {
			float get() { float value; hrcheck(enc(&ITextCharacterFormat_adaptor::Kerning)->_get_Kerning(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ITextCharacterFormat_adaptor::Kerning)->_put_Kerning(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Kerning;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITextCharacterFormat_adaptor::LanguageTag)->_get_LanguageTag(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITextCharacterFormat_adaptor::LanguageTag)->_put_LanguageTag(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} LanguageTag;
		struct : property {
			Text::LinkType get() { Text::LinkType value; hrcheck(enc(&ITextCharacterFormat_adaptor::LinkType)->_get_LinkType(&value)); return value; }
			Text::LinkType operator()() { return get(); }
			operator Text::LinkType () { return get(); }
		} LinkType;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITextCharacterFormat_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITextCharacterFormat_adaptor::Name)->_put_Name(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Name;
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextCharacterFormat_adaptor::Outline)->_get_Outline(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextCharacterFormat_adaptor::Outline)->_put_Outline(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} Outline;
		struct : property {
			float get() { float value; hrcheck(enc(&ITextCharacterFormat_adaptor::Position)->_get_Position(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ITextCharacterFormat_adaptor::Position)->_put_Position(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Position;
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextCharacterFormat_adaptor::ProtectedText)->_get_ProtectedText(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextCharacterFormat_adaptor::ProtectedText)->_put_ProtectedText(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} ProtectedText;
		struct : property {
			float get() { float value; hrcheck(enc(&ITextCharacterFormat_adaptor::Size)->_get_Size(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ITextCharacterFormat_adaptor::Size)->_put_Size(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Size;
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextCharacterFormat_adaptor::SmallCaps)->_get_SmallCaps(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextCharacterFormat_adaptor::SmallCaps)->_put_SmallCaps(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} SmallCaps;
		struct : property {
			float get() { float value; hrcheck(enc(&ITextCharacterFormat_adaptor::Spacing)->_get_Spacing(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ITextCharacterFormat_adaptor::Spacing)->_put_Spacing(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} Spacing;
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextCharacterFormat_adaptor::Strikethrough)->_get_Strikethrough(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextCharacterFormat_adaptor::Strikethrough)->_put_Strikethrough(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} Strikethrough;
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextCharacterFormat_adaptor::Subscript)->_get_Subscript(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextCharacterFormat_adaptor::Subscript)->_put_Subscript(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} Subscript;
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextCharacterFormat_adaptor::Superscript)->_get_Superscript(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextCharacterFormat_adaptor::Superscript)->_put_Superscript(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} Superscript;
		struct : property {
			Text::TextScript get() { Text::TextScript value; hrcheck(enc(&ITextCharacterFormat_adaptor::TextScript)->_get_TextScript(&value)); return value; }
			Text::TextScript operator()() { return get(); }
			operator Text::TextScript () { return get(); }
			void put(Text::TextScript value) { hrcheck(enc(&ITextCharacterFormat_adaptor::TextScript)->_put_TextScript(value)); }
			void operator=(Text::TextScript value) { put(value); }
			void operator()(Text::TextScript value) { put(value); }
		} TextScript;
		struct : property {
			UnderlineType get() { UnderlineType value; hrcheck(enc(&ITextCharacterFormat_adaptor::Underline)->_get_Underline(&value)); return value; }
			UnderlineType operator()() { return get(); }
			operator UnderlineType () { return get(); }
			void put(UnderlineType value) { hrcheck(enc(&ITextCharacterFormat_adaptor::Underline)->_put_Underline(value)); }
			void operator=(UnderlineType value) { put(value); }
			void operator()(UnderlineType value) { put(value); }
		} Underline;
		struct : property {
			int get() { int value; hrcheck(enc(&ITextCharacterFormat_adaptor::Weight)->_get_Weight(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ITextCharacterFormat_adaptor::Weight)->_put_Weight(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} Weight;
	};
	void SetClone(pptr<ITextCharacterFormat> value) { hrcheck(X::get()->_SetClone(value)); }
	ptr<ITextCharacterFormat> GetClone() { ITextCharacterFormat* value; hrcheck(X::get()->_GetClone(&value)); return from_abi(value); }
	bool IsEqual(pptr<ITextCharacterFormat> format) { bool value; hrcheck(X::get()->_IsEqual(format, &value)); return value; }
	ITextCharacterFormat_adaptor() {}
};
template<typename X> struct adapt<ITextCharacterFormat, X> : Windows::UI::Text::ITextCharacterFormat_adaptor<X> { typedef adapt ITextCharacterFormat; };
template<typename X> struct ITextCharacterFormat_unadaptor : X {
	STDMETHODIMP _get_AllCaps(FormatEffect *value) { return hrtry([&, this] { get_prop(value, AllCaps); }); }
	STDMETHODIMP _put_AllCaps(FormatEffect value) { return hrtry([&, this] { put_prop(value, AllCaps); }); }
	STDMETHODIMP _get_BackgroundColor(Color *value) { return hrtry([&, this] { get_prop(value, BackgroundColor); }); }
	STDMETHODIMP _put_BackgroundColor(Color value) { return hrtry([&, this] { put_prop(value, BackgroundColor); }); }
	STDMETHODIMP _get_Bold(FormatEffect *value) { return hrtry([&, this] { get_prop(value, Bold); }); }
	STDMETHODIMP _put_Bold(FormatEffect value) { return hrtry([&, this] { put_prop(value, Bold); }); }
	STDMETHODIMP _get_FontStretch(Text::FontStretch *value) { return hrtry([&, this] { get_prop(value, FontStretch); }); }
	STDMETHODIMP _put_FontStretch(Text::FontStretch value) { return hrtry([&, this] { put_prop(value, FontStretch); }); }
	STDMETHODIMP _get_FontStyle(Text::FontStyle *value) { return hrtry([&, this] { get_prop(value, FontStyle); }); }
	STDMETHODIMP _put_FontStyle(Text::FontStyle value) { return hrtry([&, this] { put_prop(value, FontStyle); }); }
	STDMETHODIMP _get_ForegroundColor(Color *value) { return hrtry([&, this] { get_prop(value, ForegroundColor); }); }
	STDMETHODIMP _put_ForegroundColor(Color value) { return hrtry([&, this] { put_prop(value, ForegroundColor); }); }
	STDMETHODIMP _get_Hidden(FormatEffect *value) { return hrtry([&, this] { get_prop(value, Hidden); }); }
	STDMETHODIMP _put_Hidden(FormatEffect value) { return hrtry([&, this] { put_prop(value, Hidden); }); }
	STDMETHODIMP _get_Italic(FormatEffect *value) { return hrtry([&, this] { get_prop(value, Italic); }); }
	STDMETHODIMP _put_Italic(FormatEffect value) { return hrtry([&, this] { put_prop(value, Italic); }); }
	STDMETHODIMP _get_Kerning(float *value) { return hrtry([&, this] { get_prop(value, Kerning); }); }
	STDMETHODIMP _put_Kerning(float value) { return hrtry([&, this] { put_prop(value, Kerning); }); }
	STDMETHODIMP _get_LanguageTag(HSTRING *value) { return hrtry([&, this] { get_prop(value, LanguageTag); }); }
	STDMETHODIMP _put_LanguageTag(HSTRING value) { return hrtry([&, this] { put_prop(value, LanguageTag); }); }
	STDMETHODIMP _get_LinkType(Text::LinkType *value) { return hrtry([&, this] { get_prop(value, LinkType); }); }
	STDMETHODIMP _get_Name(HSTRING *value) { return hrtry([&, this] { get_prop(value, Name); }); }
	STDMETHODIMP _put_Name(HSTRING value) { return hrtry([&, this] { put_prop(value, Name); }); }
	STDMETHODIMP _get_Outline(FormatEffect *value) { return hrtry([&, this] { get_prop(value, Outline); }); }
	STDMETHODIMP _put_Outline(FormatEffect value) { return hrtry([&, this] { put_prop(value, Outline); }); }
	STDMETHODIMP _get_Position(float *value) { return hrtry([&, this] { get_prop(value, Position); }); }
	STDMETHODIMP _put_Position(float value) { return hrtry([&, this] { put_prop(value, Position); }); }
	STDMETHODIMP _get_ProtectedText(FormatEffect *value) { return hrtry([&, this] { get_prop(value, ProtectedText); }); }
	STDMETHODIMP _put_ProtectedText(FormatEffect value) { return hrtry([&, this] { put_prop(value, ProtectedText); }); }
	STDMETHODIMP _get_Size(float *value) { return hrtry([&, this] { get_prop(value, Size); }); }
	STDMETHODIMP _put_Size(float value) { return hrtry([&, this] { put_prop(value, Size); }); }
	STDMETHODIMP _get_SmallCaps(FormatEffect *value) { return hrtry([&, this] { get_prop(value, SmallCaps); }); }
	STDMETHODIMP _put_SmallCaps(FormatEffect value) { return hrtry([&, this] { put_prop(value, SmallCaps); }); }
	STDMETHODIMP _get_Spacing(float *value) { return hrtry([&, this] { get_prop(value, Spacing); }); }
	STDMETHODIMP _put_Spacing(float value) { return hrtry([&, this] { put_prop(value, Spacing); }); }
	STDMETHODIMP _get_Strikethrough(FormatEffect *value) { return hrtry([&, this] { get_prop(value, Strikethrough); }); }
	STDMETHODIMP _put_Strikethrough(FormatEffect value) { return hrtry([&, this] { put_prop(value, Strikethrough); }); }
	STDMETHODIMP _get_Subscript(FormatEffect *value) { return hrtry([&, this] { get_prop(value, Subscript); }); }
	STDMETHODIMP _put_Subscript(FormatEffect value) { return hrtry([&, this] { put_prop(value, Subscript); }); }
	STDMETHODIMP _get_Superscript(FormatEffect *value) { return hrtry([&, this] { get_prop(value, Superscript); }); }
	STDMETHODIMP _put_Superscript(FormatEffect value) { return hrtry([&, this] { put_prop(value, Superscript); }); }
	STDMETHODIMP _get_TextScript(Text::TextScript *value) { return hrtry([&, this] { get_prop(value, TextScript); }); }
	STDMETHODIMP _put_TextScript(Text::TextScript value) { return hrtry([&, this] { put_prop(value, TextScript); }); }
	STDMETHODIMP _get_Underline(UnderlineType *value) { return hrtry([&, this] { get_prop(value, Underline); }); }
	STDMETHODIMP _put_Underline(UnderlineType value) { return hrtry([&, this] { put_prop(value, Underline); }); }
	STDMETHODIMP _get_Weight(int *value) { return hrtry([&, this] { get_prop(value, Weight); }); }
	STDMETHODIMP _put_Weight(int value) { return hrtry([&, this] { put_prop(value, Weight); }); }
	STDMETHODIMP _SetClone(ITextCharacterFormat* value) { return hrtry([&, this] { X::get()->SetClone(value); }); }
	STDMETHODIMP _GetClone(ITextCharacterFormat* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetClone()); }); }
	STDMETHODIMP _IsEqual(ITextCharacterFormat* format, bool *value) { return hrtry([&, this] { *value = X::get()->IsEqual(format); }); }
};
template<typename X> struct unadapt<ITextCharacterFormat, X> : Windows::UI::Text::ITextCharacterFormat_unadaptor<X> {};
struct ITextCharacterFormat : ITextCharacterFormat_raw, generate<ITextCharacterFormat> {};

// ITextParagraphFormat
struct ITextParagraphFormat_raw : IInspectable {
	virtual STDMETHODIMP _get_Alignment(ParagraphAlignment *value) = 0;
	virtual STDMETHODIMP _put_Alignment(ParagraphAlignment value) = 0;
	virtual STDMETHODIMP _get_FirstLineIndent(float *value) = 0;
	virtual STDMETHODIMP _get_KeepTogether(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_KeepTogether(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_KeepWithNext(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_KeepWithNext(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_LeftIndent(float *value) = 0;
	virtual STDMETHODIMP _get_LineSpacing(float *value) = 0;
	virtual STDMETHODIMP _get_LineSpacingRule(Text::LineSpacingRule *value) = 0;
	virtual STDMETHODIMP _get_ListAlignment(MarkerAlignment *value) = 0;
	virtual STDMETHODIMP _put_ListAlignment(MarkerAlignment value) = 0;
	virtual STDMETHODIMP _get_ListLevelIndex(int *value) = 0;
	virtual STDMETHODIMP _put_ListLevelIndex(int value) = 0;
	virtual STDMETHODIMP _get_ListStart(int *value) = 0;
	virtual STDMETHODIMP _put_ListStart(int value) = 0;
	virtual STDMETHODIMP _get_ListStyle(MarkerStyle *value) = 0;
	virtual STDMETHODIMP _put_ListStyle(MarkerStyle value) = 0;
	virtual STDMETHODIMP _get_ListTab(float *value) = 0;
	virtual STDMETHODIMP _put_ListTab(float value) = 0;
	virtual STDMETHODIMP _get_ListType(MarkerType *value) = 0;
	virtual STDMETHODIMP _put_ListType(MarkerType value) = 0;
	virtual STDMETHODIMP _get_NoLineNumber(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_NoLineNumber(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_PageBreakBefore(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_PageBreakBefore(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_RightIndent(float *value) = 0;
	virtual STDMETHODIMP _put_RightIndent(float value) = 0;
	virtual STDMETHODIMP _get_RightToLeft(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_RightToLeft(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_Style(ParagraphStyle *value) = 0;
	virtual STDMETHODIMP _put_Style(ParagraphStyle value) = 0;
	virtual STDMETHODIMP _get_SpaceAfter(float *value) = 0;
	virtual STDMETHODIMP _put_SpaceAfter(float value) = 0;
	virtual STDMETHODIMP _get_SpaceBefore(float *value) = 0;
	virtual STDMETHODIMP _put_SpaceBefore(float value) = 0;
	virtual STDMETHODIMP _get_WidowControl(FormatEffect *value) = 0;
	virtual STDMETHODIMP _put_WidowControl(FormatEffect value) = 0;
	virtual STDMETHODIMP _get_TabCount(int *value) = 0;
	virtual STDMETHODIMP _AddTab(float position, TabAlignment align, TabLeader leader) = 0;
	virtual STDMETHODIMP _ClearAllTabs() = 0;
	virtual STDMETHODIMP _DeleteTab(float position) = 0;
	virtual STDMETHODIMP _GetClone(ITextParagraphFormat* *value) = 0;
	virtual STDMETHODIMP _GetTab(int index, float *position, TabAlignment *align, TabLeader *leader) = 0;
	virtual STDMETHODIMP _IsEqual(ITextParagraphFormat* format, bool *value) = 0;
	virtual STDMETHODIMP _SetClone(ITextParagraphFormat* format) = 0;
	virtual STDMETHODIMP _SetIndents(float start, float left, float right) = 0;
	virtual STDMETHODIMP _SetLineSpacing(Text::LineSpacingRule rule, float spacing) = 0;
};
template<typename X> struct ITextParagraphFormat_adaptor : X {
	union {
		struct : property {
			ParagraphAlignment get() { ParagraphAlignment value; hrcheck(enc(&ITextParagraphFormat_adaptor::Alignment)->_get_Alignment(&value)); return value; }
			ParagraphAlignment operator()() { return get(); }
			operator ParagraphAlignment () { return get(); }
			void put(ParagraphAlignment value) { hrcheck(enc(&ITextParagraphFormat_adaptor::Alignment)->_put_Alignment(value)); }
			void operator=(ParagraphAlignment value) { put(value); }
			void operator()(ParagraphAlignment value) { put(value); }
		} Alignment;
		struct : property {
			float get() { float value; hrcheck(enc(&ITextParagraphFormat_adaptor::FirstLineIndent)->_get_FirstLineIndent(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} FirstLineIndent;
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextParagraphFormat_adaptor::KeepTogether)->_get_KeepTogether(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextParagraphFormat_adaptor::KeepTogether)->_put_KeepTogether(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} KeepTogether;
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextParagraphFormat_adaptor::KeepWithNext)->_get_KeepWithNext(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextParagraphFormat_adaptor::KeepWithNext)->_put_KeepWithNext(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} KeepWithNext;
		struct : property {
			float get() { float value; hrcheck(enc(&ITextParagraphFormat_adaptor::LeftIndent)->_get_LeftIndent(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} LeftIndent;
		struct : property {
			float get() { float value; hrcheck(enc(&ITextParagraphFormat_adaptor::LineSpacing)->_get_LineSpacing(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} LineSpacing;
		struct : property {
			Text::LineSpacingRule get() { Text::LineSpacingRule value; hrcheck(enc(&ITextParagraphFormat_adaptor::LineSpacingRule)->_get_LineSpacingRule(&value)); return value; }
			Text::LineSpacingRule operator()() { return get(); }
			operator Text::LineSpacingRule () { return get(); }
		} LineSpacingRule;
		struct : property {
			MarkerAlignment get() { MarkerAlignment value; hrcheck(enc(&ITextParagraphFormat_adaptor::ListAlignment)->_get_ListAlignment(&value)); return value; }
			MarkerAlignment operator()() { return get(); }
			operator MarkerAlignment () { return get(); }
			void put(MarkerAlignment value) { hrcheck(enc(&ITextParagraphFormat_adaptor::ListAlignment)->_put_ListAlignment(value)); }
			void operator=(MarkerAlignment value) { put(value); }
			void operator()(MarkerAlignment value) { put(value); }
		} ListAlignment;
		struct : property {
			int get() { int value; hrcheck(enc(&ITextParagraphFormat_adaptor::ListLevelIndex)->_get_ListLevelIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ITextParagraphFormat_adaptor::ListLevelIndex)->_put_ListLevelIndex(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} ListLevelIndex;
		struct : property {
			int get() { int value; hrcheck(enc(&ITextParagraphFormat_adaptor::ListStart)->_get_ListStart(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ITextParagraphFormat_adaptor::ListStart)->_put_ListStart(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} ListStart;
		struct : property {
			MarkerStyle get() { MarkerStyle value; hrcheck(enc(&ITextParagraphFormat_adaptor::ListStyle)->_get_ListStyle(&value)); return value; }
			MarkerStyle operator()() { return get(); }
			operator MarkerStyle () { return get(); }
			void put(MarkerStyle value) { hrcheck(enc(&ITextParagraphFormat_adaptor::ListStyle)->_put_ListStyle(value)); }
			void operator=(MarkerStyle value) { put(value); }
			void operator()(MarkerStyle value) { put(value); }
		} ListStyle;
		struct : property {
			float get() { float value; hrcheck(enc(&ITextParagraphFormat_adaptor::ListTab)->_get_ListTab(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ITextParagraphFormat_adaptor::ListTab)->_put_ListTab(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} ListTab;
		struct : property {
			MarkerType get() { MarkerType value; hrcheck(enc(&ITextParagraphFormat_adaptor::ListType)->_get_ListType(&value)); return value; }
			MarkerType operator()() { return get(); }
			operator MarkerType () { return get(); }
			void put(MarkerType value) { hrcheck(enc(&ITextParagraphFormat_adaptor::ListType)->_put_ListType(value)); }
			void operator=(MarkerType value) { put(value); }
			void operator()(MarkerType value) { put(value); }
		} ListType;
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextParagraphFormat_adaptor::NoLineNumber)->_get_NoLineNumber(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextParagraphFormat_adaptor::NoLineNumber)->_put_NoLineNumber(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} NoLineNumber;
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextParagraphFormat_adaptor::PageBreakBefore)->_get_PageBreakBefore(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextParagraphFormat_adaptor::PageBreakBefore)->_put_PageBreakBefore(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} PageBreakBefore;
		struct : property {
			float get() { float value; hrcheck(enc(&ITextParagraphFormat_adaptor::RightIndent)->_get_RightIndent(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ITextParagraphFormat_adaptor::RightIndent)->_put_RightIndent(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} RightIndent;
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextParagraphFormat_adaptor::RightToLeft)->_get_RightToLeft(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextParagraphFormat_adaptor::RightToLeft)->_put_RightToLeft(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} RightToLeft;
		struct : property {
			float get() { float value; hrcheck(enc(&ITextParagraphFormat_adaptor::SpaceAfter)->_get_SpaceAfter(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ITextParagraphFormat_adaptor::SpaceAfter)->_put_SpaceAfter(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} SpaceAfter;
		struct : property {
			float get() { float value; hrcheck(enc(&ITextParagraphFormat_adaptor::SpaceBefore)->_get_SpaceBefore(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ITextParagraphFormat_adaptor::SpaceBefore)->_put_SpaceBefore(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} SpaceBefore;
		struct : property {
			ParagraphStyle get() { ParagraphStyle value; hrcheck(enc(&ITextParagraphFormat_adaptor::Style)->_get_Style(&value)); return value; }
			ParagraphStyle operator()() { return get(); }
			operator ParagraphStyle () { return get(); }
			void put(ParagraphStyle value) { hrcheck(enc(&ITextParagraphFormat_adaptor::Style)->_put_Style(value)); }
			void operator=(ParagraphStyle value) { put(value); }
			void operator()(ParagraphStyle value) { put(value); }
		} Style;
		struct : property {
			int get() { int value; hrcheck(enc(&ITextParagraphFormat_adaptor::TabCount)->_get_TabCount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} TabCount;
		struct : property {
			FormatEffect get() { FormatEffect value; hrcheck(enc(&ITextParagraphFormat_adaptor::WidowControl)->_get_WidowControl(&value)); return value; }
			FormatEffect operator()() { return get(); }
			operator FormatEffect () { return get(); }
			void put(FormatEffect value) { hrcheck(enc(&ITextParagraphFormat_adaptor::WidowControl)->_put_WidowControl(value)); }
			void operator=(FormatEffect value) { put(value); }
			void operator()(FormatEffect value) { put(value); }
		} WidowControl;
	};
	void AddTab(float position, TabAlignment align, TabLeader leader) { hrcheck(X::get()->_AddTab(position, align, leader)); }
	void ClearAllTabs() { hrcheck(X::get()->_ClearAllTabs()); }
	void DeleteTab(float position) { hrcheck(X::get()->_DeleteTab(position)); }
	ptr<ITextParagraphFormat> GetClone() { ITextParagraphFormat* value; hrcheck(X::get()->_GetClone(&value)); return from_abi(value); }
	TabLeader GetTab(int index, float *position, TabAlignment *align) { TabLeader leader; hrcheck(X::get()->_GetTab(index, position, align, &leader)); return leader; }
	bool IsEqual(pptr<ITextParagraphFormat> format) { bool value; hrcheck(X::get()->_IsEqual(format, &value)); return value; }
	void SetClone(pptr<ITextParagraphFormat> format) { hrcheck(X::get()->_SetClone(format)); }
	void SetIndents(float start, float left, float right) { hrcheck(X::get()->_SetIndents(start, left, right)); }
	void SetLineSpacing(Text::LineSpacingRule rule, float spacing) { hrcheck(X::get()->_SetLineSpacing(rule, spacing)); }
	ITextParagraphFormat_adaptor() {}
};
template<typename X> struct adapt<ITextParagraphFormat, X> : Windows::UI::Text::ITextParagraphFormat_adaptor<X> { typedef adapt ITextParagraphFormat; };
template<typename X> struct ITextParagraphFormat_unadaptor : X {
	STDMETHODIMP _get_Alignment(ParagraphAlignment *value) { return hrtry([&, this] { get_prop(value, Alignment); }); }
	STDMETHODIMP _put_Alignment(ParagraphAlignment value) { return hrtry([&, this] { put_prop(value, Alignment); }); }
	STDMETHODIMP _get_FirstLineIndent(float *value) { return hrtry([&, this] { get_prop(value, FirstLineIndent); }); }
	STDMETHODIMP _get_KeepTogether(FormatEffect *value) { return hrtry([&, this] { get_prop(value, KeepTogether); }); }
	STDMETHODIMP _put_KeepTogether(FormatEffect value) { return hrtry([&, this] { put_prop(value, KeepTogether); }); }
	STDMETHODIMP _get_KeepWithNext(FormatEffect *value) { return hrtry([&, this] { get_prop(value, KeepWithNext); }); }
	STDMETHODIMP _put_KeepWithNext(FormatEffect value) { return hrtry([&, this] { put_prop(value, KeepWithNext); }); }
	STDMETHODIMP _get_LeftIndent(float *value) { return hrtry([&, this] { get_prop(value, LeftIndent); }); }
	STDMETHODIMP _get_LineSpacing(float *value) { return hrtry([&, this] { get_prop(value, LineSpacing); }); }
	STDMETHODIMP _get_LineSpacingRule(Text::LineSpacingRule *value) { return hrtry([&, this] { get_prop(value, LineSpacingRule); }); }
	STDMETHODIMP _get_ListAlignment(MarkerAlignment *value) { return hrtry([&, this] { get_prop(value, ListAlignment); }); }
	STDMETHODIMP _put_ListAlignment(MarkerAlignment value) { return hrtry([&, this] { put_prop(value, ListAlignment); }); }
	STDMETHODIMP _get_ListLevelIndex(int *value) { return hrtry([&, this] { get_prop(value, ListLevelIndex); }); }
	STDMETHODIMP _put_ListLevelIndex(int value) { return hrtry([&, this] { put_prop(value, ListLevelIndex); }); }
	STDMETHODIMP _get_ListStart(int *value) { return hrtry([&, this] { get_prop(value, ListStart); }); }
	STDMETHODIMP _put_ListStart(int value) { return hrtry([&, this] { put_prop(value, ListStart); }); }
	STDMETHODIMP _get_ListStyle(MarkerStyle *value) { return hrtry([&, this] { get_prop(value, ListStyle); }); }
	STDMETHODIMP _put_ListStyle(MarkerStyle value) { return hrtry([&, this] { put_prop(value, ListStyle); }); }
	STDMETHODIMP _get_ListTab(float *value) { return hrtry([&, this] { get_prop(value, ListTab); }); }
	STDMETHODIMP _put_ListTab(float value) { return hrtry([&, this] { put_prop(value, ListTab); }); }
	STDMETHODIMP _get_ListType(MarkerType *value) { return hrtry([&, this] { get_prop(value, ListType); }); }
	STDMETHODIMP _put_ListType(MarkerType value) { return hrtry([&, this] { put_prop(value, ListType); }); }
	STDMETHODIMP _get_NoLineNumber(FormatEffect *value) { return hrtry([&, this] { get_prop(value, NoLineNumber); }); }
	STDMETHODIMP _put_NoLineNumber(FormatEffect value) { return hrtry([&, this] { put_prop(value, NoLineNumber); }); }
	STDMETHODIMP _get_PageBreakBefore(FormatEffect *value) { return hrtry([&, this] { get_prop(value, PageBreakBefore); }); }
	STDMETHODIMP _put_PageBreakBefore(FormatEffect value) { return hrtry([&, this] { put_prop(value, PageBreakBefore); }); }
	STDMETHODIMP _get_RightIndent(float *value) { return hrtry([&, this] { get_prop(value, RightIndent); }); }
	STDMETHODIMP _put_RightIndent(float value) { return hrtry([&, this] { put_prop(value, RightIndent); }); }
	STDMETHODIMP _get_RightToLeft(FormatEffect *value) { return hrtry([&, this] { get_prop(value, RightToLeft); }); }
	STDMETHODIMP _put_RightToLeft(FormatEffect value) { return hrtry([&, this] { put_prop(value, RightToLeft); }); }
	STDMETHODIMP _get_Style(ParagraphStyle *value) { return hrtry([&, this] { get_prop(value, Style); }); }
	STDMETHODIMP _put_Style(ParagraphStyle value) { return hrtry([&, this] { put_prop(value, Style); }); }
	STDMETHODIMP _get_SpaceAfter(float *value) { return hrtry([&, this] { get_prop(value, SpaceAfter); }); }
	STDMETHODIMP _put_SpaceAfter(float value) { return hrtry([&, this] { put_prop(value, SpaceAfter); }); }
	STDMETHODIMP _get_SpaceBefore(float *value) { return hrtry([&, this] { get_prop(value, SpaceBefore); }); }
	STDMETHODIMP _put_SpaceBefore(float value) { return hrtry([&, this] { put_prop(value, SpaceBefore); }); }
	STDMETHODIMP _get_WidowControl(FormatEffect *value) { return hrtry([&, this] { get_prop(value, WidowControl); }); }
	STDMETHODIMP _put_WidowControl(FormatEffect value) { return hrtry([&, this] { put_prop(value, WidowControl); }); }
	STDMETHODIMP _get_TabCount(int *value) { return hrtry([&, this] { get_prop(value, TabCount); }); }
	STDMETHODIMP _AddTab(float position, TabAlignment align, TabLeader leader) { return hrtry([&, this] { X::get()->AddTab(position, align, leader); }); }
	STDMETHODIMP _ClearAllTabs() { return hrtry([&, this] { X::get()->ClearAllTabs(); }); }
	STDMETHODIMP _DeleteTab(float position) { return hrtry([&, this] { X::get()->DeleteTab(position); }); }
	STDMETHODIMP _GetClone(ITextParagraphFormat* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetClone()); }); }
	STDMETHODIMP _GetTab(int index, float *position, TabAlignment *align, TabLeader *leader) { return hrtry([&, this] { *leader = X::get()->GetTab(index, position, align, ); }); }
	STDMETHODIMP _IsEqual(ITextParagraphFormat* format, bool *value) { return hrtry([&, this] { *value = X::get()->IsEqual(format); }); }
	STDMETHODIMP _SetClone(ITextParagraphFormat* format) { return hrtry([&, this] { X::get()->SetClone(format); }); }
	STDMETHODIMP _SetIndents(float start, float left, float right) { return hrtry([&, this] { X::get()->SetIndents(start, left, right); }); }
	STDMETHODIMP _SetLineSpacing(Text::LineSpacingRule rule, float spacing) { return hrtry([&, this] { X::get()->SetLineSpacing(rule, spacing); }); }
};
template<typename X> struct unadapt<ITextParagraphFormat, X> : Windows::UI::Text::ITextParagraphFormat_unadaptor<X> {};
struct ITextParagraphFormat : ITextParagraphFormat_raw, generate<ITextParagraphFormat> {};

// ITextDocument2
struct ITextDocument2_raw : IInspectable {
	virtual STDMETHODIMP _get_AlignmentIncludesTrailingWhitespace(bool *value);
	virtual STDMETHODIMP _put_AlignmentIncludesTrailingWhitespace(bool value);
	virtual STDMETHODIMP _get_IgnoreTrailingCharacterSpacing(bool *value);
	virtual STDMETHODIMP _put_IgnoreTrailingCharacterSpacing(bool value);
};
template<typename X> struct ITextDocument2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextDocument2_adaptor::AlignmentIncludesTrailingWhitespace)->_get_AlignmentIncludesTrailingWhitespace(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextDocument2_adaptor::AlignmentIncludesTrailingWhitespace)->_put_AlignmentIncludesTrailingWhitespace(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AlignmentIncludesTrailingWhitespace;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextDocument2_adaptor::IgnoreTrailingCharacterSpacing)->_get_IgnoreTrailingCharacterSpacing(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextDocument2_adaptor::IgnoreTrailingCharacterSpacing)->_put_IgnoreTrailingCharacterSpacing(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IgnoreTrailingCharacterSpacing;
	};
	ITextDocument2_adaptor() {}
};
template<typename X> struct adapt<ITextDocument2, X> : Windows::UI::Text::ITextDocument2_adaptor<X> { typedef adapt ITextDocument2; };
struct ITextDocument2 : ITextDocument2_raw, generate<ITextDocument2> {};

// RichEditTextDocument
template<typename X> struct statics<RichEditTextDocument, X> : X {
	typedef typename X::root_type RichEditTextDocument;
};
struct RichEditTextDocument : generate<RichEditTextDocument> {};

// IRichEditTextRange
struct IRichEditTextRange_raw : IInspectable {
	virtual STDMETHODIMP _get_ContentLinkInfo(Text::ContentLinkInfo* *value);
	virtual STDMETHODIMP _put_ContentLinkInfo(Text::ContentLinkInfo* value);
};
template<typename X> struct IRichEditTextRange_adaptor : X {
	union {
		struct : property {
			ptr<Text::ContentLinkInfo> get() { Text::ContentLinkInfo* value; hrcheck(enc(&IRichEditTextRange_adaptor::ContentLinkInfo)->_get_ContentLinkInfo(&value)); return from_abi(value); }
			ptr<Text::ContentLinkInfo> operator()() { return get(); }
			operator ptr<Text::ContentLinkInfo> () { return get(); }
			ptr<Text::ContentLinkInfo> operator->() { return get(); }
			void put(pptr<Text::ContentLinkInfo> value) { hrcheck(enc(&IRichEditTextRange_adaptor::ContentLinkInfo)->_put_ContentLinkInfo(value)); }
			void operator=(pptr<Text::ContentLinkInfo> value) { put(value); }
			void operator()(pptr<Text::ContentLinkInfo> value) { put(value); }
		} ContentLinkInfo;
	};
	IRichEditTextRange_adaptor() {}
};
template<typename X> struct adapt<IRichEditTextRange, X> : Windows::UI::Text::IRichEditTextRange_adaptor<X> { typedef adapt IRichEditTextRange; };
struct IRichEditTextRange : IRichEditTextRange_raw, generate<IRichEditTextRange> {};

// RichEditTextRange
template<typename X> struct statics<RichEditTextRange, X> : X {
	typedef typename X::root_type RichEditTextRange;
};
struct RichEditTextRange : generate<RichEditTextRange> {};

// IContentLinkInfo
struct IContentLinkInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_Id(unsigned *value);
	virtual STDMETHODIMP _put_Id(unsigned value);
	virtual STDMETHODIMP _get_DisplayText(HSTRING *value);
	virtual STDMETHODIMP _put_DisplayText(HSTRING value);
	virtual STDMETHODIMP _get_SecondaryText(HSTRING *value);
	virtual STDMETHODIMP _put_SecondaryText(HSTRING value);
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_Uri(Foundation::Uri* value);
	virtual STDMETHODIMP _get_LinkContentKind(HSTRING *value);
	virtual STDMETHODIMP _put_LinkContentKind(HSTRING value);
};
template<typename X> struct IContentLinkInfo_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IContentLinkInfo_adaptor::DisplayText)->_get_DisplayText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IContentLinkInfo_adaptor::DisplayText)->_put_DisplayText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DisplayText;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IContentLinkInfo_adaptor::Id)->_get_Id(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IContentLinkInfo_adaptor::Id)->_put_Id(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} Id;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IContentLinkInfo_adaptor::LinkContentKind)->_get_LinkContentKind(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IContentLinkInfo_adaptor::LinkContentKind)->_put_LinkContentKind(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} LinkContentKind;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IContentLinkInfo_adaptor::SecondaryText)->_get_SecondaryText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IContentLinkInfo_adaptor::SecondaryText)->_put_SecondaryText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} SecondaryText;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IContentLinkInfo_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IContentLinkInfo_adaptor::Uri)->_put_Uri(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} Uri;
	};
	IContentLinkInfo_adaptor() {}
};
template<typename X> struct adapt<IContentLinkInfo, X> : Windows::UI::Text::IContentLinkInfo_adaptor<X> { typedef adapt IContentLinkInfo; };
struct IContentLinkInfo : IContentLinkInfo_raw, generate<IContentLinkInfo> {};

// ContentLinkInfo
template<typename X> struct statics<ContentLinkInfo, X> : X {
	typedef typename X::root_type ContentLinkInfo;
};
struct ContentLinkInfo : generate<ContentLinkInfo> {};

// IFontWeights
struct IFontWeights : IInspectable, generate<IFontWeights> {};

// IFontWeightsStatics
struct IFontWeightsStatics : IInspectable {
	virtual STDMETHODIMP _get_Black(FontWeight *value);
	virtual STDMETHODIMP _get_Bold(FontWeight *value);
	virtual STDMETHODIMP _get_ExtraBlack(FontWeight *value);
	virtual STDMETHODIMP _get_ExtraBold(FontWeight *value);
	virtual STDMETHODIMP _get_ExtraLight(FontWeight *value);
	virtual STDMETHODIMP _get_Light(FontWeight *value);
	virtual STDMETHODIMP _get_Medium(FontWeight *value);
	virtual STDMETHODIMP _get_Normal(FontWeight *value);
	virtual STDMETHODIMP _get_SemiBold(FontWeight *value);
	virtual STDMETHODIMP _get_SemiLight(FontWeight *value);
	virtual STDMETHODIMP _get_Thin(FontWeight *value);
};

// FontWeights
template<typename> struct FontWeights_statics {
	static struct _Black : property {
		FontWeight get() { FontWeight value; hrcheck(get_activation_factory<FontWeights, IFontWeightsStatics>()->_get_Black(&value)); return value; }
		FontWeight operator()() { return get(); }
		operator FontWeight () { return get(); }
	} Black;
	static struct _Bold : property {
		FontWeight get() { FontWeight value; hrcheck(get_activation_factory<FontWeights, IFontWeightsStatics>()->_get_Bold(&value)); return value; }
		FontWeight operator()() { return get(); }
		operator FontWeight () { return get(); }
	} Bold;
	static struct _ExtraBlack : property {
		FontWeight get() { FontWeight value; hrcheck(get_activation_factory<FontWeights, IFontWeightsStatics>()->_get_ExtraBlack(&value)); return value; }
		FontWeight operator()() { return get(); }
		operator FontWeight () { return get(); }
	} ExtraBlack;
	static struct _ExtraBold : property {
		FontWeight get() { FontWeight value; hrcheck(get_activation_factory<FontWeights, IFontWeightsStatics>()->_get_ExtraBold(&value)); return value; }
		FontWeight operator()() { return get(); }
		operator FontWeight () { return get(); }
	} ExtraBold;
	static struct _ExtraLight : property {
		FontWeight get() { FontWeight value; hrcheck(get_activation_factory<FontWeights, IFontWeightsStatics>()->_get_ExtraLight(&value)); return value; }
		FontWeight operator()() { return get(); }
		operator FontWeight () { return get(); }
	} ExtraLight;
	static struct _Light : property {
		FontWeight get() { FontWeight value; hrcheck(get_activation_factory<FontWeights, IFontWeightsStatics>()->_get_Light(&value)); return value; }
		FontWeight operator()() { return get(); }
		operator FontWeight () { return get(); }
	} Light;
	static struct _Medium : property {
		FontWeight get() { FontWeight value; hrcheck(get_activation_factory<FontWeights, IFontWeightsStatics>()->_get_Medium(&value)); return value; }
		FontWeight operator()() { return get(); }
		operator FontWeight () { return get(); }
	} Medium;
	static struct _Normal : property {
		FontWeight get() { FontWeight value; hrcheck(get_activation_factory<FontWeights, IFontWeightsStatics>()->_get_Normal(&value)); return value; }
		FontWeight operator()() { return get(); }
		operator FontWeight () { return get(); }
	} Normal;
	static struct _SemiBold : property {
		FontWeight get() { FontWeight value; hrcheck(get_activation_factory<FontWeights, IFontWeightsStatics>()->_get_SemiBold(&value)); return value; }
		FontWeight operator()() { return get(); }
		operator FontWeight () { return get(); }
	} SemiBold;
	static struct _SemiLight : property {
		FontWeight get() { FontWeight value; hrcheck(get_activation_factory<FontWeights, IFontWeightsStatics>()->_get_SemiLight(&value)); return value; }
		FontWeight operator()() { return get(); }
		operator FontWeight () { return get(); }
	} SemiLight;
	static struct _Thin : property {
		FontWeight get() { FontWeight value; hrcheck(get_activation_factory<FontWeights, IFontWeightsStatics>()->_get_Thin(&value)); return value; }
		FontWeight operator()() { return get(); }
		operator FontWeight () { return get(); }
	} Thin;
};
template<typename X> typename FontWeights_statics<X>::_Black FontWeights_statics<X>::Black;
template<typename X> typename FontWeights_statics<X>::_Bold FontWeights_statics<X>::Bold;
template<typename X> typename FontWeights_statics<X>::_ExtraBlack FontWeights_statics<X>::ExtraBlack;
template<typename X> typename FontWeights_statics<X>::_ExtraBold FontWeights_statics<X>::ExtraBold;
template<typename X> typename FontWeights_statics<X>::_ExtraLight FontWeights_statics<X>::ExtraLight;
template<typename X> typename FontWeights_statics<X>::_Light FontWeights_statics<X>::Light;
template<typename X> typename FontWeights_statics<X>::_Medium FontWeights_statics<X>::Medium;
template<typename X> typename FontWeights_statics<X>::_Normal FontWeights_statics<X>::Normal;
template<typename X> typename FontWeights_statics<X>::_SemiBold FontWeights_statics<X>::SemiBold;
template<typename X> typename FontWeights_statics<X>::_SemiLight FontWeights_statics<X>::SemiLight;
template<typename X> typename FontWeights_statics<X>::_Thin FontWeights_statics<X>::Thin;

template<typename X> struct statics<FontWeights, X> : X, Windows::UI::Text::FontWeights_statics<void> {
	typedef typename X::root_type FontWeights;
};
struct FontWeights : generate<FontWeights> {};
}}}
} // namespace iso_winrt
