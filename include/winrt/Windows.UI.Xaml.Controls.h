#pragma once
// generated by isopod tools
// namespaces:
// Windows.UI.Xaml.Controls
// Windows.UI.Xaml.Controls.Primitives

#include "Windows.UI.Xaml.Controls.0.h"
#include "Windows.Web.0.h"
#include "Windows.UI.Xaml.Input.0.h"
#include "Windows.UI.Core.0.h"
#include "Windows.UI.0.h"
#include "Windows.Globalization.0.h"
#include "Windows.Foundation.Numerics.0.h"
#include "Windows.System.0.h"
#include "Windows.ApplicationModel.DataTransfer.0.h"
#include "Windows.UI.Xaml.Navigation.0.h"
#include "Windows.UI.Text.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.UI.Xaml.Interop.0.h"
#include "Windows.UI.Xaml.Documents.0.h"
#include "Windows.UI.Xaml.Data.h"
#include "Windows.Foundation.Collections.h"
#include "Windows.UI.Xaml.Media.h"
#include "Windows.UI.Xaml.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace ApplicationModel { namespace Contacts {
struct Contact;
}
namespace Search {
struct SearchQueryLinguisticDetails;
struct LocalContentSuggestionSettings;
struct SearchSuggestionsRequest;
}}
namespace Media { namespace Capture {
struct MediaCapture;
}
namespace Casting {
struct CastingSource;
}
namespace Core {
struct IMediaSource;
}
namespace PlayTo {
struct PlayToSource;
}
namespace Playback {
struct MediaPlayer;
struct IMediaPlaybackSource;
}
namespace Protection {
struct MediaProtectionManager;
}}
namespace Storage { namespace Streams {
struct IRandomAccessStream;
}}
namespace UI { namespace Composition {
struct CompositionBrush;
}
namespace Input { namespace Inking {
struct InkPresenterRuler;
struct InkPresenter;
struct InkPresenterProtractor;
struct InkDrawingAttributes;
}}
namespace Xaml { namespace Controls { namespace Primitives {
struct DragDeltaEventHandler;
struct DragCompletedEventHandler;
struct FlyoutBase;
struct ColorPickerSlider;
struct RangeBase;
struct DragStartedEventHandler;
struct FlyoutBaseClosingEventArgs;
struct ButtonBase;
struct ListViewItemPresenter;
struct GridViewItemPresenter;
struct ScrollEventArgs;
struct ItemsChangedEventArgs;
struct RangeBaseValueChangedEventArgs;
struct DragStartedEventArgs;
struct DragDeltaEventArgs;
struct DragCompletedEventArgs;
struct PivotHeaderItem;
struct ProgressRingTemplateSettings;
struct ItemsChangedEventHandler;
struct ScrollEventHandler;
struct ToggleSwitchTemplateSettings;
struct ColorSpectrum;
struct ProgressBarTemplateSettings;
struct AppBarToggleButtonTemplateSettings;
struct AppBarButtonTemplateSettings;
struct SettingsFlyoutTemplateSettings;
struct RangeBaseValueChangedEventHandler;
struct ToolTipTemplateSettings;
struct ToggleButton;
struct CommandBarTemplateSettings;
struct ComboBoxTemplateSettings;
struct MenuFlyoutItemTemplateSettings;
struct GridViewItemTemplateSettings;
struct AppBarTemplateSettings;
struct SplitViewTemplateSettings;
struct CalendarViewTemplateSettings;
struct ListViewItemTemplateSettings;
struct CarouselPanel;
struct PickerFlyoutBase;
struct SelectorItem;
struct MenuFlyoutPresenterTemplateSettings;
}}
namespace Media { namespace Animation {
struct NavigationTransitionInfo;
struct TransitionCollection;
struct ConnectedAnimation;
}}}}
namespace Web { namespace Http {
struct HttpRequestMessage;
}}}

// defs

template<> struct def<Windows::UI::Xaml::Controls::Primitives::IPivotHeaderPanel> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICanvasFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICanvasStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICanvas> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPanelFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPanelStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPanel> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Panel> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::IPanel> {};
template<> struct def<Windows::UI::Xaml::Controls::Canvas> : class_type<Windows::UI::Xaml::Controls::Panel, Windows::UI::Xaml::Controls::ICanvas>, composer_type<Windows::UI::Xaml::Controls::ICanvasFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::PivotHeaderPanel> : class_type<Windows::UI::Xaml::Controls::Canvas, Windows::UI::Xaml::Controls::Primitives::IPivotHeaderPanel> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IPivotHeaderItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IPivotHeaderItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentControlFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentControlStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentControl2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentControlOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentControl> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IControlStatics5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IControlStatics4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IControlStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IControlStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IControlFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IControlStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::RequiresPointer> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IControlOverrides6> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IControl5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IControl4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IControl3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IControl2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IControlProtected> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IControlOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IControl> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Control> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::IControl, Windows::UI::Xaml::Controls::IControlOverrides, Windows::UI::Xaml::Controls::IControlProtected, Windows::UI::Xaml::Controls::IControl2, Windows::UI::Xaml::Controls::IControl3, Windows::UI::Xaml::Controls::IControl4, Windows::UI::Xaml::Controls::IControl5, Windows::UI::Xaml::Controls::IControlOverrides6> {};
template<> struct def<Windows::UI::Xaml::Controls::ContentControl> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IContentControl, Windows::UI::Xaml::Controls::IContentControlOverrides, Windows::UI::Xaml::Controls::IContentControl2>, composer_type<Windows::UI::Xaml::Controls::IContentControlFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::PivotHeaderItem> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::Primitives::IPivotHeaderItem>, composer_type<Windows::UI::Xaml::Controls::Primitives::IPivotHeaderItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::SnapPointsAlignment> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Orientation> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ILoopingSelectorPanel> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::LoopingSelectorPanel> : class_type<Windows::UI::Xaml::Controls::Canvas, Windows::UI::Xaml::Controls::Primitives::ILoopingSelectorPanel, Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ILoopingSelectorItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::LoopingSelectorItem> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::Primitives::ILoopingSelectorItem> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IPivotPanel> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::PivotPanel> : class_type<Windows::UI::Xaml::Controls::Panel, Windows::UI::Xaml::Controls::Primitives::IPivotPanel, Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ILoopingSelectorStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ILoopingSelector> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::LoopingSelector> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::Primitives::ILoopingSelector> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IPickerFlyoutBaseFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IPickerFlyoutBaseStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IPickerFlyoutBaseOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IPickerFlyoutBase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::LightDismissOverlayMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::FlyoutPlacementMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides4> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IFlyoutBase4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IFlyoutBase3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IFlyoutBase2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IFlyoutBase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::FlyoutBase> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::IFlyoutBase, Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides, Windows::UI::Xaml::Controls::Primitives::IFlyoutBase2, Windows::UI::Xaml::Controls::Primitives::IFlyoutBase3, Windows::UI::Xaml::Controls::Primitives::IFlyoutBase4, Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides4> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::PickerFlyoutBase> : class_type<Windows::UI::Xaml::Controls::Primitives::FlyoutBase, Windows::UI::Xaml::Controls::Primitives::IPickerFlyoutBase, Windows::UI::Xaml::Controls::Primitives::IPickerFlyoutBaseOverrides> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IJumpListItemForegroundConverterStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IJumpListItemForegroundConverter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::IJumpListItemForegroundConverter, Windows::UI::Xaml::Data::IValueConverter> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IJumpListItemBackgroundConverterStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IJumpListItemBackgroundConverter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::IJumpListItemBackgroundConverter, Windows::UI::Xaml::Data::IValueConverter> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseClosingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseClosingEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IToggleButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IToggleButtonStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IToggleButtonOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IToggleButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IButtonBaseFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IButtonBaseStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ClickMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IButtonBase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ButtonBase> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::Primitives::IButtonBase> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ToggleButton> : class_type<Windows::UI::Xaml::Controls::Primitives::ButtonBase, Windows::UI::Xaml::Controls::Primitives::IToggleButton, Windows::UI::Xaml::Controls::Primitives::IToggleButtonOverrides>, composer_type<Windows::UI::Xaml::Controls::Primitives::IToggleButtonFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IRepeatButtonStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IRepeatButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::RepeatButton> : class_type<Windows::UI::Xaml::Controls::Primitives::ButtonBase, Windows::UI::Xaml::Controls::Primitives::IRepeatButton> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ISelectorFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ISelectorStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ISelector> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsControlFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsControlStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsControl3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemContainerMapping> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsControl2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsControlOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsControl> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ItemsControl> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IItemsControl, Windows::UI::Xaml::Controls::IItemsControlOverrides, Windows::UI::Xaml::Controls::IItemsControl2, Windows::UI::Xaml::Controls::IItemContainerMapping, Windows::UI::Xaml::Controls::IItemsControl3>, composer_type<Windows::UI::Xaml::Controls::IItemsControlFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::Selector> : class_type<Windows::UI::Xaml::Controls::ItemsControl, Windows::UI::Xaml::Controls::Primitives::ISelector> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IScrollBarStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ScrollingIndicatorMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IScrollBar> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IRangeBaseFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IRangeBaseStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IRangeBaseOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IRangeBase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::RangeBase> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::Primitives::IRangeBase, Windows::UI::Xaml::Controls::Primitives::IRangeBaseOverrides> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ScrollBar> : class_type<Windows::UI::Xaml::Controls::Primitives::RangeBase, Windows::UI::Xaml::Controls::Primitives::IScrollBar> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IThumbStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IThumb> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::Thumb> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::Primitives::IThumb> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IColorPickerSliderFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IColorPickerSliderStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ColorPickerHsvChannel> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IColorPickerSlider> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISliderStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISliderFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISliderStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::TickPlacement> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::SliderSnapsTo> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::ISlider2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISlider> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Slider> : class_type<Windows::UI::Xaml::Controls::Primitives::RangeBase, Windows::UI::Xaml::Controls::ISlider, Windows::UI::Xaml::Controls::ISlider2>, composer_type<Windows::UI::Xaml::Controls::ISliderFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ColorPickerSlider> : class_type<Windows::UI::Xaml::Controls::Slider, Windows::UI::Xaml::Controls::Primitives::IColorPickerSlider>, composer_type<Windows::UI::Xaml::Controls::Primitives::IColorPickerSliderFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ISelectorItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ISelectorItemStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ISelectorItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::SelectorItem> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::Primitives::ISelectorItem> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IColorSpectrumFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IColorSpectrumStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ColorSpectrumComponents> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::ColorSpectrumShape> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IColorSpectrum> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ColorSpectrum> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::Primitives::IColorSpectrum>, composer_type<Windows::UI::Xaml::Controls::Primitives::IColorSpectrumFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenterStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenterStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenterFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenterStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenterCheckMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentPresenterStatics4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentPresenterStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentPresenterStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentPresenterFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentPresenterStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentPresenter4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentPresenter3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentPresenter2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentPresenterOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentPresenter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ContentPresenter> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::IContentPresenter, Windows::UI::Xaml::Controls::IContentPresenterOverrides, Windows::UI::Xaml::Controls::IContentPresenter2, Windows::UI::Xaml::Controls::IContentPresenter3, Windows::UI::Xaml::Controls::IContentPresenter4>, composer_type<Windows::UI::Xaml::Controls::IContentPresenterFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter> : class_type<Windows::UI::Xaml::Controls::ContentPresenter, Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter, Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter2, Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter3>, composer_type<Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenterFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IGridViewItemPresenterFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IGridViewItemPresenterStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IGridViewItemPresenter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter> : class_type<Windows::UI::Xaml::Controls::ContentPresenter, Windows::UI::Xaml::Controls::Primitives::IGridViewItemPresenter>, composer_type<Windows::UI::Xaml::Controls::Primitives::IGridViewItemPresenterFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ICalendarPanel> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::CalendarPanel> : class_type<Windows::UI::Xaml::Controls::Panel, Windows::UI::Xaml::Controls::Primitives::ICalendarPanel> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IOrientedVirtualizingPanelFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInsertionPanel> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IOrientedVirtualizingPanel> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IVirtualizingPanelFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IVirtualizingPanelProtected> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IVirtualizingPanelOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IVirtualizingPanel> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::VirtualizingPanel> : class_type<Windows::UI::Xaml::Controls::Panel, Windows::UI::Xaml::Controls::IVirtualizingPanel, Windows::UI::Xaml::Controls::IVirtualizingPanelOverrides, Windows::UI::Xaml::Controls::IVirtualizingPanelProtected> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel> : class_type<Windows::UI::Xaml::Controls::VirtualizingPanel, Windows::UI::Xaml::Controls::Primitives::IOrientedVirtualizingPanel, Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo, Windows::UI::Xaml::Controls::IInsertionPanel> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ICarouselPanelFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ICarouselPanel> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::CarouselPanel> : class_type<Windows::UI::Xaml::Controls::VirtualizingPanel, Windows::UI::Xaml::Controls::Primitives::ICarouselPanel, Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>, composer_type<Windows::UI::Xaml::Controls::Primitives::ICarouselPanelFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ITickBarStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ITickBar> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::TickBar> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::Primitives::ITickBar> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IPopupStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IPopupStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IPopup2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IPopup> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::Popup> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::Primitives::IPopup, Windows::UI::Xaml::Controls::Primitives::IPopup2> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ScrollEventType> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IScrollEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ScrollEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Controls::Primitives::IScrollEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IRangeBaseValueChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Controls::Primitives::IRangeBaseValueChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IDragStartedEventArgsFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IDragStartedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::DragStartedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Controls::Primitives::IDragStartedEventArgs>, composer_type<Windows::UI::Xaml::Controls::Primitives::IDragStartedEventArgsFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IDragDeltaEventArgsFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IDragDeltaEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::DragDeltaEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Controls::Primitives::IDragDeltaEventArgs>, composer_type<Windows::UI::Xaml::Controls::Primitives::IDragDeltaEventArgsFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IDragCompletedEventArgsFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IDragCompletedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::DragCompletedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Controls::Primitives::IDragCompletedEventArgs>, composer_type<Windows::UI::Xaml::Controls::Primitives::IDragCompletedEventArgsFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IAppBarToggleButtonTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::IAppBarToggleButtonTemplateSettings> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IAppBarButtonTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::IAppBarButtonTemplateSettings> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ICommandBarTemplateSettings3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ICommandBarTemplateSettings2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ICommandBarTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::ICommandBarTemplateSettings, Windows::UI::Xaml::Controls::Primitives::ICommandBarTemplateSettings2, Windows::UI::Xaml::Controls::Primitives::ICommandBarTemplateSettings3> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IMenuFlyoutItemTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::IMenuFlyoutItemTemplateSettings> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IAppBarTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::IAppBarTemplateSettings> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ISplitViewTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::ISplitViewTemplateSettings> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ICalendarViewTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::ICalendarViewTemplateSettings> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IMenuFlyoutPresenterTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::IMenuFlyoutPresenterTemplateSettings> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IListViewItemTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::IListViewItemTemplateSettings> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IGridViewItemTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::IGridViewItemTemplateSettings> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::AnimationDirection> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IComboBoxTemplateSettings2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IComboBoxTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::IComboBoxTemplateSettings, Windows::UI::Xaml::Controls::Primitives::IComboBoxTemplateSettings2> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IToolTipTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::IToolTipTemplateSettings> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ISettingsFlyoutTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::SettingsFlyoutTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::ISettingsFlyoutTemplateSettings> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IProgressBarTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ProgressBarTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::IProgressBarTemplateSettings> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IToggleSwitchTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::IToggleSwitchTemplateSettings> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IProgressRingTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ProgressRingTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::Primitives::IProgressRingTemplateSettings> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::GeneratorPosition> : value_type<int, int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IGeneratorPositionHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IGeneratorPositionHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::GeneratorPositionHelper> : class_type<Platform::Object, Windows::UI::Xaml::Controls::Primitives::IGeneratorPositionHelper> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::EdgeTransitionLocation> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ComponentResourceLocation> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::GeneratorDirection> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::GroupHeaderPlacement> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::PlacementMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::DragCompletedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::DragDeltaEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::DragStartedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ItemsChangedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::IItemsChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::Primitives::IItemsChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ScrollEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ILayoutInformationStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ILayoutInformationStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::ILayoutInformation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Primitives::LayoutInformation> : class_type<Platform::Object, Windows::UI::Xaml::Controls::Primitives::ILayoutInformation> {};
template<> struct def<Windows::UI::Xaml::Controls::IDragItemsCompletedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::DragItemsCompletedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IDragItemsCompletedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IDragItemsStartingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGroupStyle> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IStyleSelectorFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IStyleSelectorOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IStyleSelector> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::StyleSelector> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IStyleSelector, Windows::UI::Xaml::Controls::IStyleSelectorOverrides>, composer_type<Windows::UI::Xaml::Controls::IStyleSelectorFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IGroupStyleFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGroupStyle2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::GroupStyle> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IGroupStyle, Windows::UI::Xaml::Data::INotifyPropertyChanged, Windows::UI::Xaml::Controls::IGroupStyle2>, composer_type<Windows::UI::Xaml::Controls::IGroupStyleFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IGroupStyleSelector> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGroupStyleSelectorOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGroupStyleSelectorFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::GroupStyleSelector> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IGroupStyleSelector, Windows::UI::Xaml::Controls::IGroupStyleSelectorOverrides>, composer_type<Windows::UI::Xaml::Controls::IGroupStyleSelectorFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IHandwritingPanelClosedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::HandwritingPanelClosedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IHandwritingPanelClosedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IHandwritingPanelOpenedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::HandwritingPanelOpenedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IHandwritingPanelOpenedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IIsTextTrimmedChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IsTextTrimmedChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IIsTextTrimmedChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ItemCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IObservableVector<object>, Windows::Foundation::Collections::IVector<object>, Windows::Foundation::Collections::IIterable<object>> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemContainerGenerator> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ItemContainerGenerator> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IItemContainerGenerator> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaTransportControlsHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaTransportControlsHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::MediaTransportControlsHelper> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IMediaTransportControlsHelper> {};
template<> struct def<Windows::UI::Xaml::Controls::INotifyEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::INotifyEventArgs2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPasswordBoxPasswordChangingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::PasswordBoxPasswordChangingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IPasswordBoxPasswordChangingEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IRowDefinitionStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRowDefinition> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::RowDefinition> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::IRowDefinition> {};
template<> struct def<Windows::UI::Xaml::Controls::RowDefinitionCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Controls::RowDefinition>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Controls::RowDefinition>>> {};
template<> struct def<Windows::UI::Xaml::Controls::ISemanticZoomLocation> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISemanticZoomViewChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBoxBeforeTextChangingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::TextBoxBeforeTextChangingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ITextBoxBeforeTextChangingEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBoxTextChangingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBoxTextChangingEventArgs2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::TextBoxTextChangingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ITextBoxTextChangingEventArgs, Windows::UI::Xaml::Controls::ITextBoxTextChangingEventArgs2> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextCompositionChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::TextCompositionChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ITextCompositionChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextCompositionEndedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::TextCompositionEndedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ITextCompositionEndedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextCompositionStartedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::TextCompositionStartedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ITextCompositionStartedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextControlCopyingToClipboardEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::TextControlCopyingToClipboardEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ITextControlCopyingToClipboardEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextControlCuttingToClipboardEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::TextControlCuttingToClipboardEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ITextControlCuttingToClipboardEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextControlPasteEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IToolTipService> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IToolTipServiceStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ToolTipService> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IToolTipService> {};
template<> struct def<Windows::UI::Xaml::Controls::ICleanUpVirtualizedItemEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IColumnDefinition> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IColumnDefinitionStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContextMenuEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemClickEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISelectionChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISelectionChangedEventArgsFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsPanelTemplate> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IBorder> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IBorderStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICaptureElement> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICaptureElementStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IImage> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IImageStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IImage2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IImage3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsPresenter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsPresenterStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsPresenter2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsPresenterStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlock> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlockStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlock2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlockStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlock3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlockStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlock4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlockStatics4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlock5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlockStatics5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlockOverflow> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlockOverflowStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlockOverflow2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlockOverflowStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlockOverflow3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichTextBlockOverflowStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBlock> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBlockStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBlock2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBlockStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBlock3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBlockStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBlock4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBlock5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBlockStatics5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBlock6> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBlockStatics6> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::StretchDirection> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IViewbox> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IViewboxStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGrid> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGridStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGridFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGrid2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGridStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGrid3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGridStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::HandwritingPanelPlacementAlignment> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IHandwritingView> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IHandwritingViewStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IHandwritingViewFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaTransportControls> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaTransportControlsStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaTransportControlsFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaTransportControls2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaTransportControlsStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaTransportControls3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaTransportControlsStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaTransportControls4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaTransportControlsStatics4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPasswordBox> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPasswordBoxStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPasswordBox2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPasswordBoxStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::PasswordRevealMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IPasswordBox3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPasswordBoxStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPasswordBox4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IProgressRing> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IProgressRingStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRelativePanel> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRelativePanelStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRelativePanelFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISemanticZoom> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISemanticZoomStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IStackPanel> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IStackPanelStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IStackPanelFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IStackPanel2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IStackPanelStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IStackPanel4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IStackPanelStatics4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBox> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBoxStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBoxFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBox2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBoxStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::CandidateWindowAlignment> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBox3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBoxStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBox4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBox5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBoxStatics5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::CharacterCasing> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBox6> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBoxStatics6> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBox7> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITextBoxStatics7> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IToggleSwitch> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IToggleSwitchOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IToggleSwitchStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IUserControl> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IUserControlStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IUserControlFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IVariableSizedWrapGrid> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IVariableSizedWrapGridStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGroupItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGroupItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewBaseHeaderItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewBaseHeaderItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IProgressBar> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IProgressBarStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IProgressBarFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISettingsFlyout> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISettingsFlyoutStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISettingsFlyoutFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IToolTip> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IToolTipStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IToolTipFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IButtonWithFlyout> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IButtonStaticsWithFlyout> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IComboBox> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IComboBoxOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IComboBoxStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IComboBoxFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IComboBox2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IComboBoxStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IComboBox3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IComboBoxStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ComboBoxSelectionChangedTrigger> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IComboBox4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IComboBoxStatics4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IComboBox5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IComboBoxStatics5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IComboBoxItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IComboBoxItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFlipView> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFlipViewFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFlipView2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFlipViewStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFlipViewItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFlipViewItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IHyperlinkButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IHyperlinkButtonStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IHyperlinkButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::SelectionMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IListBox> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListBoxStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListBoxFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListBox2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListBoxStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListBoxItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListBoxItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ScrollIntoViewAlignment> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IncrementalLoadingTrigger> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::ListViewSelectionMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewBase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewBaseStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewBaseFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewBase2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewBaseStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ListViewReorderMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewBase3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewBaseStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewBase4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewBaseStatics4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewBase5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewBaseStatics5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewBase6> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IVirtualizingStackPanel> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IVirtualizingStackPanelOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::VirtualizationMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IVirtualizingStackPanelStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICheckBox> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICheckBoxFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRadioButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRadioButtonStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRadioButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IDataTemplateSelectorOverrides2> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IDataTemplateSelector2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IDataTemplateSelectorFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IDataTemplateSelectorOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IDataTemplateSelector> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::DataTemplateSelector> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IDataTemplateSelector, Windows::UI::Xaml::Controls::IDataTemplateSelectorOverrides, Windows::UI::Xaml::Controls::IDataTemplateSelector2, Windows::UI::Xaml::Controls::IDataTemplateSelectorOverrides2>, composer_type<Windows::UI::Xaml::Controls::IDataTemplateSelectorFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IContainerContentChangingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ColumnDefinition> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::IColumnDefinition> {};
template<> struct def<Windows::UI::Xaml::Controls::ColumnDefinitionCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Controls::ColumnDefinition>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Controls::ColumnDefinition>>> {};
template<> struct def<Windows::UI::Xaml::Controls::IChoosingItemContainerEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ChoosingItemContainerEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IChoosingItemContainerEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IChoosingGroupHeaderContainerEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ChoosingGroupHeaderContainerEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IChoosingGroupHeaderContainerEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ICandidateWindowBoundsChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::CandidateWindowBoundsChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ICandidateWindowBoundsChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IBackClickEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::SemanticZoomLocation> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ISemanticZoomLocation> {};
template<> struct def<Windows::UI::Xaml::Controls::ISemanticZoomInformation> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigate> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ContainerContentChangingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IContainerContentChangingEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::TextControlPasteEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ITextControlPasteEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::TextControlPasteEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::TextChangedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::SemanticZoomViewChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ISemanticZoomViewChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::SemanticZoomViewChangedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::SelectionChangedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::NotifyEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::INotifyEventArgs, Windows::UI::Xaml::Controls::INotifyEventArgs2> {};
template<> struct def<Windows::UI::Xaml::Controls::NotifyEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::ItemClickEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::DragItemsStartingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IDragItemsStartingEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::DragItemsStartingEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::ContextMenuOpeningEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::CleanUpVirtualizedItemEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::BackClickEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IBackClickEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::BackClickEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::ZoomMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::SnapPointsType> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::ScrollMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::ScrollBarVisibility> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::RichEditClipboardFormat> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::PanelScrollingDirection> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::ItemsUpdatingScrollMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::DisabledFormattingAccelerators> : enum_type<unsigned> {};
template<> struct def<Windows::UI::Xaml::Controls::AppBarClosedDisplayMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::AutoSuggestionBoxTextChangeReason> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::CalendarViewDisplayMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::CalendarViewSelectionMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::CommandBarDefaultLabelPosition> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::CommandBarDynamicOverflowAction> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::CommandBarLabelPosition> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::CommandBarOverflowButtonVisibility> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::ContentDialogButton> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::ContentDialogPlacement> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::ContentDialogResult> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::ContentLinkChangeKind> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::SplitViewDisplayMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::SplitViewPanePlacement> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::Symbol> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewExecutionMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewPermissionState> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewPermissionType> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::CalendarViewDayItemChangingEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::ICalendarViewDayItemChangingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::CalendarViewDayItemChangingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ICalendarViewDayItemChangingEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::HubSectionHeaderClickEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::IHubSectionHeaderClickEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::HubSectionHeaderClickEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IHubSectionHeaderClickEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ListViewItemToKeyHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::ListViewKeyToItemHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::SectionsInViewChangedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::ISectionsInViewChangedEventArgsFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISectionsInViewChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::SectionsInViewChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ISectionsInViewChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewNavigationFailedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewNavigationFailedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewNavigationFailedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IWebViewNavigationFailedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ICommandBarElement> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICommandBarElement2> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICalendarDatePickerDateChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::CalendarDatePickerDateChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ICalendarDatePickerDateChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ICalendarViewSelectedDatesChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::CalendarViewSelectedDatesChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ICalendarViewSelectedDatesChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentDialogButtonClickDeferral> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ContentDialogButtonClickDeferral> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IContentDialogButtonClickDeferral> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentDialogButtonClickEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ContentDialogButtonClickEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IContentDialogButtonClickEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentDialogClosedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ContentDialogClosedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IContentDialogClosedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentDialogClosingDeferral> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ContentDialogClosingDeferral> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IContentDialogClosingDeferral> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentDialogClosingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ContentDialogClosingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IContentDialogClosingEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentDialogOpenedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ContentDialogOpenedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IContentDialogOpenedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentLinkChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ContentLinkChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IContentLinkChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IDatePickerValueChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::DatePickerValueChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IDatePickerValueChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IDynamicOverflowItemsChangingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::DynamicOverflowItemsChangingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IDynamicOverflowItemsChangingEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IHubSectionFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IHubSectionStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IHubSection> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::HubSection> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IHubSection>, composer_type<Windows::UI::Xaml::Controls::IHubSectionFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::HubSectionCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Controls::HubSection>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Controls::HubSection>>> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewPersistenceHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewPersistenceHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ListViewPersistenceHelper> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IListViewPersistenceHelper> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBoxTextChangingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBoxTextChangingEventArgs2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::RichEditBoxTextChangingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IRichEditBoxTextChangingEventArgs, Windows::UI::Xaml::Controls::IRichEditBoxTextChangingEventArgs2> {};
template<> struct def<Windows::UI::Xaml::Controls::IScrollViewerView> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ScrollViewerView> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IScrollViewerView> {};
template<> struct def<Windows::UI::Xaml::Controls::IScrollViewerViewChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ScrollViewerViewChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IScrollViewerViewChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IScrollViewerViewChangingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ScrollViewerViewChangingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IScrollViewerViewChangingEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ISearchBoxQueryChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::SearchBoxQueryChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ISearchBoxQueryChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ISearchBoxQuerySubmittedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::SearchBoxQuerySubmittedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ISearchBoxQuerySubmittedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ISearchBoxResultSuggestionChosenEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::SearchBoxResultSuggestionChosenEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ISearchBoxResultSuggestionChosenEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ISearchBoxSuggestionsRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::SearchBoxSuggestionsRequestedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ISearchBoxSuggestionsRequestedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ISplitViewPaneClosingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::SplitViewPaneClosingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ISplitViewPaneClosingEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ITimePickerValueChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::TimePickerValueChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ITimePickerValueChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewContentLoadingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewContentLoadingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IWebViewContentLoadingEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewDeferredPermissionRequest> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewDeferredPermissionRequest> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IWebViewDeferredPermissionRequest> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewDOMContentLoadedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewDOMContentLoadedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IWebViewDOMContentLoadedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewLongRunningScriptDetectedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewLongRunningScriptDetectedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IWebViewLongRunningScriptDetectedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewNavigationCompletedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewNavigationCompletedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IWebViewNavigationCompletedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewNavigationStartingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewNavigationStartingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IWebViewNavigationStartingEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewNewWindowRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewNewWindowRequestedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IWebViewNewWindowRequestedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewPermissionRequest> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewPermissionRequest> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IWebViewPermissionRequest> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewPermissionRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewPermissionRequestedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IWebViewPermissionRequestedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewSeparateProcessLostEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewSeparateProcessLostEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IWebViewSeparateProcessLostEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewSettings> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IWebViewSettings> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewUnsupportedUriSchemeIdentifiedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewUnsupportedUriSchemeIdentifiedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IWebViewUnsupportedUriSchemeIdentifiedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewUnviewableContentIdentifiedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewUnviewableContentIdentifiedEventArgs2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewUnviewableContentIdentifiedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IWebViewUnviewableContentIdentifiedEventArgs, Windows::UI::Xaml::Controls::IWebViewUnviewableContentIdentifiedEventArgs2> {};
template<> struct def<Windows::UI::Xaml::Controls::IAutoSuggestBoxQuerySubmittedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAutoSuggestBoxSuggestionChosenEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAutoSuggestBoxTextChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAutoSuggestBoxTextChangedEventArgsStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IIconSource> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IIconSourceStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IIconSourceFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IBitmapIconSourceStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IBitmapIconSourceFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFlyout> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFlyoutStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFlyoutFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFontIconSource> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFontIconSourceStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFontIconSourceFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyout> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyout2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPathIconSource> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPathIconSourceStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPathIconSourceFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISymbolIconSource> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISymbolIconSourceStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISymbolIconSourceFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IIconElement> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IIconElementStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IIconElementFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkCanvas> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkCanvasFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaElement> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaElementStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaElement2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaElementStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaElement3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaPlayerPresenter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaPlayerPresenterStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaPlayerPresenterFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebView> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebView2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebView3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebView4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewStatics4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewFactory4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebView5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewStatics5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebView6> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewBrush> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWebViewBrushStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarSeparator> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarSeparatorStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarSeparatorFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarSeparatorStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IBitmapIcon> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IBitmapIconStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IBitmapIconFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IBitmapIcon2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IBitmapIconStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICalendarDatePicker> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICalendarDatePickerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICalendarDatePickerFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICalendarDatePicker2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICalendarDatePickerStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICalendarView> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICalendarViewStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICalendarViewFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICalendarViewDayItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICalendarViewDayItemStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICalendarViewDayItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IDatePicker> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IDatePickerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IDatePickerFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IDatePicker2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IDatePickerStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFontIcon> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFontIconStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFontIconFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFontIcon2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFontIconStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFontIcon3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFontIconStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IHub> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IHubStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IHubFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsStackPanel> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsStackPanelStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsStackPanel2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsStackPanelStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsWrapGrid> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsWrapGridStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsWrapGrid2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsWrapGridStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaPlayerElement> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaPlayerElementStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMediaPlayerElementFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutItemBase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutItemBaseFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPathIcon> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPathIconStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPathIconFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBox> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBoxStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBoxFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBox2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBoxStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBox3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBoxStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBox4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBoxStatics4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBox5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBoxStatics5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBox6> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBoxStatics6> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBox7> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRichEditBoxStatics7> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IScrollContentPresenter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISearchBox> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISearchBoxStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISearchBoxFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISplitView> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISplitViewStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISplitViewFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISplitView2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISplitViewStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISplitView3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISymbolIcon> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISymbolIconStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISymbolIconFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITimePicker> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITimePickerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITimePickerFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITimePicker2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITimePickerStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBar> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBar2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBar3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarOverrides3> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBar4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarStatics4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAutoSuggestBox> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAutoSuggestBoxStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAutoSuggestBox2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAutoSuggestBoxStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAutoSuggestBox3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAutoSuggestBoxStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICommandBarOverflowPresenter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICommandBarOverflowPresenterFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentDialog> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentDialogStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentDialogFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentDialog2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentDialogStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IContentDialog3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFlyoutPresenter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFlyoutPresenterFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFrame> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFrameStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFrameFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFrame2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFrameStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFrame3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFrame4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutItemStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutItem2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutItemStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutItem3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutItemStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutPresenter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutPresenterFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutPresenter2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutSeparator> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutSeparatorFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutSubItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutSubItemStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutSubItem2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IMenuFlyoutSubItemStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPage> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPageOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPageStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPageFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IScrollViewer> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IScrollViewerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IScrollViewer2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IScrollViewerStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IScrollViewer3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwapChainBackgroundPanel> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwapChainBackgroundPanelFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwapChainBackgroundPanel2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwapChainPanel> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwapChainPanelStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwapChainPanelFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICommandBar> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICommandBarStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICommandBarFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICommandBar2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICommandBarStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICommandBar3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ICommandBarStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGridViewHeaderItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGridViewHeaderItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGridViewItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGridViewItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewHeaderItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewHeaderItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IToggleMenuFlyoutItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IToggleMenuFlyoutItemStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IToggleMenuFlyoutItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWrapGrid> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IWrapGridStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarButtonStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarButton3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarButtonStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarButton4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarButtonStatics4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarButton5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarToggleButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarToggleButtonStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarToggleButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarToggleButton3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarToggleButtonStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarToggleButton4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarToggleButtonStatics4> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IAppBarToggleButton5> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGridView> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IGridViewFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListView> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListViewFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewItemStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewItemTemplateSettingsFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewItemTemplateSettings> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::TreeViewSelectionMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeView> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewListFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewList> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewCollapsedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::TreeViewCollapsedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ITreeViewCollapsedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewExpandingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::TreeViewExpandingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ITreeViewExpandingEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewNodeFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewNodeStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewNode> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::TreeViewItemInvokedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwipeControlStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwipeControlFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwipeControl> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwipeItemsStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwipeItemsFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::SwipeMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwipeItems> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwipeItemInvokedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRatingItemInfoFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRatingItemInfo> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::RatingItemInfo> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::IRatingItemInfo>, composer_type<Windows::UI::Xaml::Controls::IRatingItemInfoFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IRatingItemFontInfoStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRatingItemFontInfoFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRatingItemFontInfo> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::RatingItemFontInfo> : class_type<Windows::UI::Xaml::Controls::RatingItemInfo, Windows::UI::Xaml::Controls::IRatingItemFontInfo>, composer_type<Windows::UI::Xaml::Controls::IRatingItemFontInfoFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IRatingItemImageInfoStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRatingItemImageInfoFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRatingItemImageInfo> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::RatingItemImageInfo> : class_type<Windows::UI::Xaml::Controls::RatingItemInfo, Windows::UI::Xaml::Controls::IRatingItemImageInfo>, composer_type<Windows::UI::Xaml::Controls::IRatingItemImageInfoFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwipeItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwipeItemStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::SwipeBehaviorOnInvoked> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::ISwipeItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::SwipeItem> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::ISwipeItem>, composer_type<Windows::UI::Xaml::Controls::ISwipeItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::SwipeItems> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::ISwipeItems, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::Controls::SwipeItem>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::Controls::SwipeItem>>>, composer_type<Windows::UI::Xaml::Controls::ISwipeItemsFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::TreeViewNode> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::ITreeViewNode>, composer_type<Windows::UI::Xaml::Controls::ITreeViewNodeFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::TreeViewItemTemplateSettings> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::ITreeViewItemTemplateSettings>, composer_type<Windows::UI::Xaml::Controls::ITreeViewItemTemplateSettingsFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::SwipeItemInvokedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::ISwipeItemInvokedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IRefreshContainerFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRefreshContainerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::RefreshPullDirection> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IRefreshContainer> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IconSource> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::IIconSource> {};
template<> struct def<Windows::UI::Xaml::Controls::AutoSuggestBoxQuerySubmittedEventArgs> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::IAutoSuggestBoxQuerySubmittedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::AutoSuggestBoxSuggestionChosenEventArgs> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::IAutoSuggestBoxSuggestionChosenEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::AutoSuggestBoxTextChangedEventArgs> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::IAutoSuggestBoxTextChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IBitmapIconSource> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::BitmapIconSource> : class_type<Windows::UI::Xaml::Controls::IconSource, Windows::UI::Xaml::Controls::IBitmapIconSource>, composer_type<Windows::UI::Xaml::Controls::IBitmapIconSourceFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::FontIconSource> : class_type<Windows::UI::Xaml::Controls::IconSource, Windows::UI::Xaml::Controls::IFontIconSource>, composer_type<Windows::UI::Xaml::Controls::IFontIconSourceFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::PathIconSource> : class_type<Windows::UI::Xaml::Controls::IconSource, Windows::UI::Xaml::Controls::IPathIconSource>, composer_type<Windows::UI::Xaml::Controls::IPathIconSourceFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::SymbolIconSource> : class_type<Windows::UI::Xaml::Controls::IconSource, Windows::UI::Xaml::Controls::ISymbolIconSource>, composer_type<Windows::UI::Xaml::Controls::ISymbolIconSourceFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IRefreshRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::RefreshVisualizerState> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IRefreshStateChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRefreshVisualizerFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRefreshVisualizerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::RefreshStateChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IRefreshStateChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::RefreshRequestedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IRefreshRequestedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::CleanUpVirtualizedItemEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Controls::ICleanUpVirtualizedItemEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ContextMenuEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Controls::IContextMenuEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ItemClickEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Controls::IItemClickEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::SelectionChangedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Controls::ISelectionChangedEventArgs>, composer_type<Windows::UI::Xaml::Controls::ISelectionChangedEventArgsFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::TextChangedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Controls::ITextChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::RefreshVisualizerOrientation> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IRefreshVisualizer> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRefreshInteractionRatioChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::RefreshInteractionRatioChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IRefreshInteractionRatioChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ItemsPanelTemplate> : class_type<Windows::UI::Xaml::FrameworkTemplate, Windows::UI::Xaml::Controls::IItemsPanelTemplate> {};
template<> struct def<Windows::UI::Xaml::Controls::IParallaxViewFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IParallaxViewStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ParallaxSourceOffsetKind> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IParallaxView> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ParallaxView> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::IParallaxView>, composer_type<Windows::UI::Xaml::Controls::IParallaxViewFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IRatingControlStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Border> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::IBorder> {};
template<> struct def<Windows::UI::Xaml::Controls::CaptureElement> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::ICaptureElement> {};
template<> struct def<Windows::UI::Xaml::Controls::Image> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::IImage, Windows::UI::Xaml::Controls::IImage2, Windows::UI::Xaml::Controls::IImage3> {};
template<> struct def<Windows::UI::Xaml::Controls::ItemsPresenter> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::IItemsPresenter, Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo, Windows::UI::Xaml::Controls::IItemsPresenter2> {};
template<> struct def<Windows::UI::Xaml::Controls::RichTextBlockOverflow> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::IRichTextBlockOverflow, Windows::UI::Xaml::Controls::IRichTextBlockOverflow2, Windows::UI::Xaml::Controls::IRichTextBlockOverflow3> {};
template<> struct def<Windows::UI::Xaml::Controls::RichTextBlock> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::IRichTextBlock, Windows::UI::Xaml::Controls::IRichTextBlock2, Windows::UI::Xaml::Controls::IRichTextBlock3, Windows::UI::Xaml::Controls::IRichTextBlock4, Windows::UI::Xaml::Controls::IRichTextBlock5> {};
template<> struct def<Windows::UI::Xaml::Controls::TextBlock> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::ITextBlock, Windows::UI::Xaml::Controls::ITextBlock2, Windows::UI::Xaml::Controls::ITextBlock3, Windows::UI::Xaml::Controls::ITextBlock4, Windows::UI::Xaml::Controls::ITextBlock5, Windows::UI::Xaml::Controls::ITextBlock6> {};
template<> struct def<Windows::UI::Xaml::Controls::Viewbox> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::IViewbox> {};
template<> struct def<Windows::UI::Xaml::Controls::Grid> : class_type<Windows::UI::Xaml::Controls::Panel, Windows::UI::Xaml::Controls::IGrid, Windows::UI::Xaml::Controls::IGrid2, Windows::UI::Xaml::Controls::IGrid3>, composer_type<Windows::UI::Xaml::Controls::IGridFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::RelativePanel> : class_type<Windows::UI::Xaml::Controls::Panel, Windows::UI::Xaml::Controls::IRelativePanel>, composer_type<Windows::UI::Xaml::Controls::IRelativePanelFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::StackPanel> : class_type<Windows::UI::Xaml::Controls::Panel, Windows::UI::Xaml::Controls::IStackPanel, Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo, Windows::UI::Xaml::Controls::IStackPanel2, Windows::UI::Xaml::Controls::IInsertionPanel, Windows::UI::Xaml::Controls::IStackPanel4>, composer_type<Windows::UI::Xaml::Controls::IStackPanelFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::VariableSizedWrapGrid> : class_type<Windows::UI::Xaml::Controls::Panel, Windows::UI::Xaml::Controls::IVariableSizedWrapGrid> {};
template<> struct def<Windows::UI::Xaml::Controls::IRatingControlFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IRatingControl> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::VirtualizingStackPanel> : class_type<Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel, Windows::UI::Xaml::Controls::IVirtualizingStackPanel, Windows::UI::Xaml::Controls::IVirtualizingStackPanelOverrides> {};
template<> struct def<Windows::UI::Xaml::Controls::IconElement> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::IIconElement> {};
template<> struct def<Windows::UI::Xaml::Controls::InkCanvas> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::IInkCanvas>, composer_type<Windows::UI::Xaml::Controls::IInkCanvasFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::MediaElement> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::IMediaElement, Windows::UI::Xaml::Controls::IMediaElement2, Windows::UI::Xaml::Controls::IMediaElement3> {};
template<> struct def<Windows::UI::Xaml::Controls::MediaPlayerPresenter> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::IMediaPlayerPresenter>, composer_type<Windows::UI::Xaml::Controls::IMediaPlayerPresenterFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::WebView> : class_type<Windows::UI::Xaml::FrameworkElement, Windows::UI::Xaml::Controls::IWebView, Windows::UI::Xaml::Controls::IWebView2, Windows::UI::Xaml::Controls::IWebView3, Windows::UI::Xaml::Controls::IWebView4, Windows::UI::Xaml::Controls::IWebView5, Windows::UI::Xaml::Controls::IWebView6>, custom_activators {};
template<> struct def<Windows::UI::Xaml::Controls::BitmapIcon> : class_type<Windows::UI::Xaml::Controls::IconElement, Windows::UI::Xaml::Controls::IBitmapIcon, Windows::UI::Xaml::Controls::IBitmapIcon2>, composer_type<Windows::UI::Xaml::Controls::IBitmapIconFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::FontIcon> : class_type<Windows::UI::Xaml::Controls::IconElement, Windows::UI::Xaml::Controls::IFontIcon, Windows::UI::Xaml::Controls::IFontIcon2, Windows::UI::Xaml::Controls::IFontIcon3>, composer_type<Windows::UI::Xaml::Controls::IFontIconFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ItemsStackPanel> : class_type<Windows::UI::Xaml::Controls::Panel, Windows::UI::Xaml::Controls::IItemsStackPanel, Windows::UI::Xaml::Controls::IItemsStackPanel2> {};
template<> struct def<Windows::UI::Xaml::Controls::ItemsWrapGrid> : class_type<Windows::UI::Xaml::Controls::Panel, Windows::UI::Xaml::Controls::IItemsWrapGrid, Windows::UI::Xaml::Controls::IItemsWrapGrid2> {};
template<> struct def<Windows::UI::Xaml::Controls::PathIcon> : class_type<Windows::UI::Xaml::Controls::IconElement, Windows::UI::Xaml::Controls::IPathIcon>, composer_type<Windows::UI::Xaml::Controls::IPathIconFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ScrollContentPresenter> : class_type<Windows::UI::Xaml::Controls::ContentPresenter, Windows::UI::Xaml::Controls::IScrollContentPresenter> {};
template<> struct def<Windows::UI::Xaml::Controls::SymbolIcon> : class_type<Windows::UI::Xaml::Controls::IconElement, Windows::UI::Xaml::Controls::ISymbolIcon>, custom_activators {};
template<> struct def<Windows::UI::Xaml::Controls::SwapChainBackgroundPanel> : class_type<Windows::UI::Xaml::Controls::Grid, Windows::UI::Xaml::Controls::ISwapChainBackgroundPanel, Windows::UI::Xaml::Controls::ISwapChainBackgroundPanel2>, composer_type<Windows::UI::Xaml::Controls::ISwapChainBackgroundPanelFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::SwapChainPanel> : class_type<Windows::UI::Xaml::Controls::Grid, Windows::UI::Xaml::Controls::ISwapChainPanel>, composer_type<Windows::UI::Xaml::Controls::ISwapChainPanelFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::WrapGrid> : class_type<Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel, Windows::UI::Xaml::Controls::IWrapGrid> {};
template<> struct def<Windows::UI::Xaml::Controls::IUIElementCollection> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::UIElementCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVector<ptr<Windows::UI::Xaml::UIElement>>, Windows::Foundation::Collections::IIterable<ptr<Windows::UI::Xaml::UIElement>>, Windows::UI::Xaml::Controls::IUIElementCollection> {};
template<> struct def<Windows::UI::Xaml::Controls::IFocusDisengagedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::FocusDisengagedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Controls::IFocusDisengagedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IFocusEngagedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IFocusEngagedEventArgs2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::FocusEngagedEventArgs> : class_type<Windows::UI::Xaml::RoutedEventArgs, Windows::UI::Xaml::Controls::IFocusEngagedEventArgs, Windows::UI::Xaml::Controls::IFocusEngagedEventArgs2> {};
template<> struct def<Windows::UI::Xaml::Controls::IControlTemplate> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ControlTemplate> : class_type<Windows::UI::Xaml::FrameworkTemplate, Windows::UI::Xaml::Controls::IControlTemplate> {};
template<> struct def<Windows::UI::Xaml::Controls::IColorPickerFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IColorPickerStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IColorPicker> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ColorPicker> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IColorPicker>, composer_type<Windows::UI::Xaml::Controls::IColorPickerFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IPersonPictureStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPersonPictureFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPersonPicture> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::PersonPicture> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IPersonPicture>, composer_type<Windows::UI::Xaml::Controls::IPersonPictureFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::RatingControl> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IRatingControl>, composer_type<Windows::UI::Xaml::Controls::IRatingControlFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::RefreshVisualizer> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IRefreshVisualizer>, composer_type<Windows::UI::Xaml::Controls::IRefreshVisualizerFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::TreeView> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::ITreeView>, composer_type<Windows::UI::Xaml::Controls::ITreeViewFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::SemanticZoom> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::ISemanticZoom> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::NavigationViewBackButtonVisible> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::NavigationViewDisplayMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationView2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationView> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::NavigationView> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::INavigationView, Windows::UI::Xaml::Controls::INavigationView2>, composer_type<Windows::UI::Xaml::Controls::INavigationViewFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::RefreshContainer> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::IRefreshContainer>, composer_type<Windows::UI::Xaml::Controls::IRefreshContainerFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::SwipeControl> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::ISwipeControl>, composer_type<Windows::UI::Xaml::Controls::ISwipeControlFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ListViewBaseHeaderItem> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::IListViewBaseHeaderItem> {};
template<> struct def<Windows::UI::Xaml::Controls::HandwritingView> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IHandwritingView>, composer_type<Windows::UI::Xaml::Controls::IHandwritingViewFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::MediaTransportControls> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IMediaTransportControls, Windows::UI::Xaml::Controls::IMediaTransportControls2, Windows::UI::Xaml::Controls::IMediaTransportControls3, Windows::UI::Xaml::Controls::IMediaTransportControls4>, composer_type<Windows::UI::Xaml::Controls::IMediaTransportControlsFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::PasswordBox> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IPasswordBox, Windows::UI::Xaml::Controls::IPasswordBox2, Windows::UI::Xaml::Controls::IPasswordBox3, Windows::UI::Xaml::Controls::IPasswordBox4> {};
template<> struct def<Windows::UI::Xaml::Controls::ProgressRing> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IProgressRing> {};
template<> struct def<Windows::UI::Xaml::Controls::TextBox> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::ITextBox, Windows::UI::Xaml::Controls::ITextBox2, Windows::UI::Xaml::Controls::ITextBox3, Windows::UI::Xaml::Controls::ITextBox4, Windows::UI::Xaml::Controls::ITextBox5, Windows::UI::Xaml::Controls::ITextBox6, Windows::UI::Xaml::Controls::ITextBox7>, composer_type<Windows::UI::Xaml::Controls::ITextBoxFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ToggleSwitch> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IToggleSwitch, Windows::UI::Xaml::Controls::IToggleSwitchOverrides> {};
template<> struct def<Windows::UI::Xaml::Controls::UserControl> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IUserControl>, composer_type<Windows::UI::Xaml::Controls::IUserControlFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::GroupItem> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::IGroupItem>, composer_type<Windows::UI::Xaml::Controls::IGroupItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::SettingsFlyout> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::ISettingsFlyout>, composer_type<Windows::UI::Xaml::Controls::ISettingsFlyoutFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ToolTip> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::IToolTip>, composer_type<Windows::UI::Xaml::Controls::IToolTipFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ComboBoxItem> : class_type<Windows::UI::Xaml::Controls::Primitives::SelectorItem, Windows::UI::Xaml::Controls::IComboBoxItem>, composer_type<Windows::UI::Xaml::Controls::IComboBoxItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::FlipViewItem> : class_type<Windows::UI::Xaml::Controls::Primitives::SelectorItem, Windows::UI::Xaml::Controls::IFlipViewItem>, composer_type<Windows::UI::Xaml::Controls::IFlipViewItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ListBoxItem> : class_type<Windows::UI::Xaml::Controls::Primitives::SelectorItem, Windows::UI::Xaml::Controls::IListBoxItem>, composer_type<Windows::UI::Xaml::Controls::IListBoxItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ProgressBar> : class_type<Windows::UI::Xaml::Controls::Primitives::RangeBase, Windows::UI::Xaml::Controls::IProgressBar>, composer_type<Windows::UI::Xaml::Controls::IProgressBarFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Button> : class_type<Windows::UI::Xaml::Controls::Primitives::ButtonBase, Windows::UI::Xaml::Controls::IButton, Windows::UI::Xaml::Controls::IButtonWithFlyout>, composer_type<Windows::UI::Xaml::Controls::IButtonFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::HyperlinkButton> : class_type<Windows::UI::Xaml::Controls::Primitives::ButtonBase, Windows::UI::Xaml::Controls::IHyperlinkButton>, composer_type<Windows::UI::Xaml::Controls::IHyperlinkButtonFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ListViewBase> : class_type<Windows::UI::Xaml::Controls::Primitives::Selector, Windows::UI::Xaml::Controls::IListViewBase, Windows::UI::Xaml::Controls::ISemanticZoomInformation, Windows::UI::Xaml::Controls::IListViewBase2, Windows::UI::Xaml::Controls::IListViewBase3, Windows::UI::Xaml::Controls::IListViewBase4, Windows::UI::Xaml::Controls::IListViewBase5, Windows::UI::Xaml::Controls::IListViewBase6> {};
template<> struct def<Windows::UI::Xaml::Controls::ComboBox> : class_type<Windows::UI::Xaml::Controls::Primitives::Selector, Windows::UI::Xaml::Controls::IComboBox, Windows::UI::Xaml::Controls::IComboBoxOverrides, Windows::UI::Xaml::Controls::IComboBox2, Windows::UI::Xaml::Controls::IComboBox3, Windows::UI::Xaml::Controls::IComboBox4, Windows::UI::Xaml::Controls::IComboBox5>, composer_type<Windows::UI::Xaml::Controls::IComboBoxFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::FlipView> : class_type<Windows::UI::Xaml::Controls::Primitives::Selector, Windows::UI::Xaml::Controls::IFlipView, Windows::UI::Xaml::Controls::IFlipView2>, composer_type<Windows::UI::Xaml::Controls::IFlipViewFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ListBox> : class_type<Windows::UI::Xaml::Controls::Primitives::Selector, Windows::UI::Xaml::Controls::IListBox, Windows::UI::Xaml::Controls::IListBox2>, composer_type<Windows::UI::Xaml::Controls::IListBoxFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::CheckBox> : class_type<Windows::UI::Xaml::Controls::Primitives::ToggleButton, Windows::UI::Xaml::Controls::ICheckBox>, composer_type<Windows::UI::Xaml::Controls::ICheckBoxFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::RadioButton> : class_type<Windows::UI::Xaml::Controls::Primitives::ToggleButton, Windows::UI::Xaml::Controls::IRadioButton>, composer_type<Windows::UI::Xaml::Controls::IRadioButtonFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::CalendarView> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::ICalendarView>, composer_type<Windows::UI::Xaml::Controls::ICalendarViewFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::CalendarViewDayItem> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::ICalendarViewDayItem>, composer_type<Windows::UI::Xaml::Controls::ICalendarViewDayItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::MenuFlyoutItemBase> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IMenuFlyoutItemBase> {};
template<> struct def<Windows::UI::Xaml::Controls::AppBarSeparator> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IAppBarSeparator, Windows::UI::Xaml::Controls::ICommandBarElement, Windows::UI::Xaml::Controls::ICommandBarElement2>, composer_type<Windows::UI::Xaml::Controls::IAppBarSeparatorFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::CalendarDatePicker> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::ICalendarDatePicker, Windows::UI::Xaml::Controls::ICalendarDatePicker2>, composer_type<Windows::UI::Xaml::Controls::ICalendarDatePickerFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::DatePicker> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IDatePicker, Windows::UI::Xaml::Controls::IDatePicker2>, composer_type<Windows::UI::Xaml::Controls::IDatePickerFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Hub> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IHub, Windows::UI::Xaml::Controls::ISemanticZoomInformation>, composer_type<Windows::UI::Xaml::Controls::IHubFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::MediaPlayerElement> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IMediaPlayerElement>, composer_type<Windows::UI::Xaml::Controls::IMediaPlayerElementFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::RichEditBox> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IRichEditBox, Windows::UI::Xaml::Controls::IRichEditBox2, Windows::UI::Xaml::Controls::IRichEditBox3, Windows::UI::Xaml::Controls::IRichEditBox4, Windows::UI::Xaml::Controls::IRichEditBox5, Windows::UI::Xaml::Controls::IRichEditBox6, Windows::UI::Xaml::Controls::IRichEditBox7>, composer_type<Windows::UI::Xaml::Controls::IRichEditBoxFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::SearchBox> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::ISearchBox>, composer_type<Windows::UI::Xaml::Controls::ISearchBoxFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::SplitView> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::ISplitView, Windows::UI::Xaml::Controls::ISplitView2, Windows::UI::Xaml::Controls::ISplitView3>, composer_type<Windows::UI::Xaml::Controls::ISplitViewFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::TimePicker> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::ITimePicker, Windows::UI::Xaml::Controls::ITimePicker2>, composer_type<Windows::UI::Xaml::Controls::ITimePickerFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::AppBar> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::IAppBar, Windows::UI::Xaml::Controls::IAppBarOverrides, Windows::UI::Xaml::Controls::IAppBar2, Windows::UI::Xaml::Controls::IAppBar3, Windows::UI::Xaml::Controls::IAppBarOverrides3, Windows::UI::Xaml::Controls::IAppBar4>, composer_type<Windows::UI::Xaml::Controls::IAppBarFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::AutoSuggestBox> : class_type<Windows::UI::Xaml::Controls::ItemsControl, Windows::UI::Xaml::Controls::IAutoSuggestBox, Windows::UI::Xaml::Controls::IAutoSuggestBox2, Windows::UI::Xaml::Controls::IAutoSuggestBox3> {};
template<> struct def<Windows::UI::Xaml::Controls::CommandBarOverflowPresenter> : class_type<Windows::UI::Xaml::Controls::ItemsControl, Windows::UI::Xaml::Controls::ICommandBarOverflowPresenter>, composer_type<Windows::UI::Xaml::Controls::ICommandBarOverflowPresenterFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ContentDialog> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::IContentDialog, Windows::UI::Xaml::Controls::IContentDialog2, Windows::UI::Xaml::Controls::IContentDialog3>, composer_type<Windows::UI::Xaml::Controls::IContentDialogFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::FlyoutPresenter> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::IFlyoutPresenter>, composer_type<Windows::UI::Xaml::Controls::IFlyoutPresenterFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Frame> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::IFrame, Windows::UI::Xaml::Controls::INavigate, Windows::UI::Xaml::Controls::IFrame2, Windows::UI::Xaml::Controls::IFrame3, Windows::UI::Xaml::Controls::IFrame4>, composer_type<Windows::UI::Xaml::Controls::IFrameFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::MenuFlyoutItem> : class_type<Windows::UI::Xaml::Controls::MenuFlyoutItemBase, Windows::UI::Xaml::Controls::IMenuFlyoutItem, Windows::UI::Xaml::Controls::IMenuFlyoutItem2, Windows::UI::Xaml::Controls::IMenuFlyoutItem3>, composer_type<Windows::UI::Xaml::Controls::IMenuFlyoutItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::MenuFlyoutPresenter> : class_type<Windows::UI::Xaml::Controls::ItemsControl, Windows::UI::Xaml::Controls::IMenuFlyoutPresenter, Windows::UI::Xaml::Controls::IMenuFlyoutPresenter2>, composer_type<Windows::UI::Xaml::Controls::IMenuFlyoutPresenterFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::MenuFlyoutSeparator> : class_type<Windows::UI::Xaml::Controls::MenuFlyoutItemBase, Windows::UI::Xaml::Controls::IMenuFlyoutSeparator>, composer_type<Windows::UI::Xaml::Controls::IMenuFlyoutSeparatorFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::MenuFlyoutSubItem> : class_type<Windows::UI::Xaml::Controls::MenuFlyoutItemBase, Windows::UI::Xaml::Controls::IMenuFlyoutSubItem, Windows::UI::Xaml::Controls::IMenuFlyoutSubItem2> {};
template<> struct def<Windows::UI::Xaml::Controls::Page> : class_type<Windows::UI::Xaml::Controls::UserControl, Windows::UI::Xaml::Controls::IPage, Windows::UI::Xaml::Controls::IPageOverrides>, composer_type<Windows::UI::Xaml::Controls::IPageFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ScrollViewer> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::IScrollViewer, Windows::UI::Xaml::Controls::IScrollViewer2, Windows::UI::Xaml::Controls::IScrollViewer3> {};
template<> struct def<Windows::UI::Xaml::Controls::CommandBar> : class_type<Windows::UI::Xaml::Controls::AppBar, Windows::UI::Xaml::Controls::ICommandBar, Windows::UI::Xaml::Controls::ICommandBar2, Windows::UI::Xaml::Controls::ICommandBar3>, composer_type<Windows::UI::Xaml::Controls::ICommandBarFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::GridViewHeaderItem> : class_type<Windows::UI::Xaml::Controls::ListViewBaseHeaderItem, Windows::UI::Xaml::Controls::IGridViewHeaderItem>, composer_type<Windows::UI::Xaml::Controls::IGridViewHeaderItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::GridViewItem> : class_type<Windows::UI::Xaml::Controls::Primitives::SelectorItem, Windows::UI::Xaml::Controls::IGridViewItem>, composer_type<Windows::UI::Xaml::Controls::IGridViewItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ListViewHeaderItem> : class_type<Windows::UI::Xaml::Controls::ListViewBaseHeaderItem, Windows::UI::Xaml::Controls::IListViewHeaderItem>, composer_type<Windows::UI::Xaml::Controls::IListViewHeaderItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ListViewItem> : class_type<Windows::UI::Xaml::Controls::Primitives::SelectorItem, Windows::UI::Xaml::Controls::IListViewItem>, composer_type<Windows::UI::Xaml::Controls::IListViewItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewItemBaseFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewItemBase> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::NavigationViewItemBase> : class_type<Windows::UI::Xaml::Controls::ListViewItem, Windows::UI::Xaml::Controls::INavigationViewItemBase> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewItemStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::NavigationViewItem> : class_type<Windows::UI::Xaml::Controls::NavigationViewItemBase, Windows::UI::Xaml::Controls::INavigationViewItem>, composer_type<Windows::UI::Xaml::Controls::INavigationViewItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewItemSeparatorFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewItemSeparator> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::NavigationViewItemSeparator> : class_type<Windows::UI::Xaml::Controls::NavigationViewItemBase, Windows::UI::Xaml::Controls::INavigationViewItemSeparator>, composer_type<Windows::UI::Xaml::Controls::INavigationViewItemSeparatorFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewItemHeaderFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewItemHeader> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::NavigationViewItemHeader> : class_type<Windows::UI::Xaml::Controls::NavigationViewItemBase, Windows::UI::Xaml::Controls::INavigationViewItemHeader>, composer_type<Windows::UI::Xaml::Controls::INavigationViewItemHeaderFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::TreeViewItem> : class_type<Windows::UI::Xaml::Controls::ListViewItem, Windows::UI::Xaml::Controls::ITreeViewItem>, composer_type<Windows::UI::Xaml::Controls::ITreeViewItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ToggleMenuFlyoutItem> : class_type<Windows::UI::Xaml::Controls::MenuFlyoutItem, Windows::UI::Xaml::Controls::IToggleMenuFlyoutItem>, composer_type<Windows::UI::Xaml::Controls::IToggleMenuFlyoutItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::AppBarButton> : class_type<Windows::UI::Xaml::Controls::Button, Windows::UI::Xaml::Controls::IAppBarButton, Windows::UI::Xaml::Controls::ICommandBarElement, Windows::UI::Xaml::Controls::IAppBarButton3, Windows::UI::Xaml::Controls::ICommandBarElement2, Windows::UI::Xaml::Controls::IAppBarButton4, Windows::UI::Xaml::Controls::IAppBarButton5>, composer_type<Windows::UI::Xaml::Controls::IAppBarButtonFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::AppBarToggleButton> : class_type<Windows::UI::Xaml::Controls::Primitives::ToggleButton, Windows::UI::Xaml::Controls::IAppBarToggleButton, Windows::UI::Xaml::Controls::ICommandBarElement, Windows::UI::Xaml::Controls::IAppBarToggleButton3, Windows::UI::Xaml::Controls::ICommandBarElement2, Windows::UI::Xaml::Controls::IAppBarToggleButton4, Windows::UI::Xaml::Controls::IAppBarToggleButton5>, composer_type<Windows::UI::Xaml::Controls::IAppBarToggleButtonFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::GridView> : class_type<Windows::UI::Xaml::Controls::ListViewBase, Windows::UI::Xaml::Controls::IGridView>, composer_type<Windows::UI::Xaml::Controls::IGridViewFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ListView> : class_type<Windows::UI::Xaml::Controls::ListViewBase, Windows::UI::Xaml::Controls::IListView>, composer_type<Windows::UI::Xaml::Controls::IListViewFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewListFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewList> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::NavigationViewList> : class_type<Windows::UI::Xaml::Controls::ListView, Windows::UI::Xaml::Controls::INavigationViewList>, composer_type<Windows::UI::Xaml::Controls::INavigationViewListFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::TreeViewList> : class_type<Windows::UI::Xaml::Controls::ListView, Windows::UI::Xaml::Controls::ITreeViewList>, composer_type<Windows::UI::Xaml::Controls::ITreeViewListFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::Flyout> : class_type<Windows::UI::Xaml::Controls::Primitives::FlyoutBase, Windows::UI::Xaml::Controls::IFlyout>, composer_type<Windows::UI::Xaml::Controls::IFlyoutFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::MenuFlyout> : class_type<Windows::UI::Xaml::Controls::Primitives::FlyoutBase, Windows::UI::Xaml::Controls::IMenuFlyout, Windows::UI::Xaml::Controls::IMenuFlyout2>, composer_type<Windows::UI::Xaml::Controls::IMenuFlyoutFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::WebViewBrush> : class_type<Windows::UI::Xaml::Media::TileBrush, Windows::UI::Xaml::Controls::IWebViewBrush> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarButtonFlyoutPlacement> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarFlyoutItemKind> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarInitialControls> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarMenuKind> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarStencilKind> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarToggle> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarTool> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarIsStencilButtonCheckedChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarIsStencilButtonCheckedChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IInkToolbarIsStencilButtonCheckedChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarCustomPen> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarCustomPenOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarCustomPenFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarCustomPen> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::IInkToolbarCustomPen, Windows::UI::Xaml::Controls::IInkToolbarCustomPenOverrides> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbar> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbar2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbar> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IInkToolbar, Windows::UI::Xaml::Controls::IInkToolbar2>, composer_type<Windows::UI::Xaml::Controls::IInkToolbarFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarPenConfigurationControl> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarPenConfigurationControlStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarPenConfigurationControlFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarPenConfigurationControl> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IInkToolbarPenConfigurationControl>, composer_type<Windows::UI::Xaml::Controls::IInkToolbarPenConfigurationControlFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarFlyoutItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarFlyoutItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarFlyoutItemStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarFlyoutItem> : class_type<Windows::UI::Xaml::Controls::Primitives::ButtonBase, Windows::UI::Xaml::Controls::IInkToolbarFlyoutItem>, composer_type<Windows::UI::Xaml::Controls::IInkToolbarFlyoutItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarMenuButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarMenuButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarMenuButtonStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarMenuButton> : class_type<Windows::UI::Xaml::Controls::Primitives::ToggleButton, Windows::UI::Xaml::Controls::IInkToolbarMenuButton> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarStencilButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarStencilButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarStencilButtonStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarStencilButton> : class_type<Windows::UI::Xaml::Controls::InkToolbarMenuButton, Windows::UI::Xaml::Controls::IInkToolbarStencilButton>, composer_type<Windows::UI::Xaml::Controls::IInkToolbarStencilButtonFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarToggleButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarToggleButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarToggleButton> : class_type<Windows::UI::Xaml::Controls::CheckBox, Windows::UI::Xaml::Controls::IInkToolbarToggleButton> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarToolButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarToolButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarToolButtonStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarToolButton> : class_type<Windows::UI::Xaml::Controls::RadioButton, Windows::UI::Xaml::Controls::IInkToolbarToolButton> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarCustomToggleButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarCustomToggleButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton> : class_type<Windows::UI::Xaml::Controls::InkToolbarToggleButton, Windows::UI::Xaml::Controls::IInkToolbarCustomToggleButton>, composer_type<Windows::UI::Xaml::Controls::IInkToolbarCustomToggleButtonFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarCustomToolButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarCustomToolButtonStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarCustomToolButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarCustomToolButton> : class_type<Windows::UI::Xaml::Controls::InkToolbarToolButton, Windows::UI::Xaml::Controls::IInkToolbarCustomToolButton>, composer_type<Windows::UI::Xaml::Controls::IInkToolbarCustomToolButtonFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarEraserButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarEraserButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarEraserButton2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarEraserButtonStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarEraserButton> : class_type<Windows::UI::Xaml::Controls::InkToolbarToolButton, Windows::UI::Xaml::Controls::IInkToolbarEraserButton, Windows::UI::Xaml::Controls::IInkToolbarEraserButton2>, composer_type<Windows::UI::Xaml::Controls::IInkToolbarEraserButtonFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarPenButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarPenButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarPenButtonStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarPenButton> : class_type<Windows::UI::Xaml::Controls::InkToolbarToolButton, Windows::UI::Xaml::Controls::IInkToolbarPenButton> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarRulerButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarRulerButtonStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarRulerButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarRulerButton> : class_type<Windows::UI::Xaml::Controls::InkToolbarToggleButton, Windows::UI::Xaml::Controls::IInkToolbarRulerButton>, composer_type<Windows::UI::Xaml::Controls::IInkToolbarRulerButtonFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarBallpointPenButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarBallpointPenButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton> : class_type<Windows::UI::Xaml::Controls::InkToolbarPenButton, Windows::UI::Xaml::Controls::IInkToolbarBallpointPenButton>, composer_type<Windows::UI::Xaml::Controls::IInkToolbarBallpointPenButtonFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarCustomPenButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarCustomPenButtonStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarCustomPenButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarCustomPenButton> : class_type<Windows::UI::Xaml::Controls::InkToolbarPenButton, Windows::UI::Xaml::Controls::IInkToolbarCustomPenButton>, composer_type<Windows::UI::Xaml::Controls::IInkToolbarCustomPenButtonFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarHighlighterButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarHighlighterButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarHighlighterButton> : class_type<Windows::UI::Xaml::Controls::InkToolbarPenButton, Windows::UI::Xaml::Controls::IInkToolbarHighlighterButton>, composer_type<Windows::UI::Xaml::Controls::IInkToolbarHighlighterButtonFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarPencilButton> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IInkToolbarPencilButtonFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::InkToolbarPencilButton> : class_type<Windows::UI::Xaml::Controls::InkToolbarPenButton, Windows::UI::Xaml::Controls::IInkToolbarPencilButton>, composer_type<Windows::UI::Xaml::Controls::IInkToolbarPencilButtonFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::ListPickerFlyoutSelectionMode> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::PivotHeaderFocusVisualPlacement> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::PivotSlideInAnimationGroup> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Controls::IPivotItemEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::PivotItemEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IPivotItemEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IDatePickedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::DatePickedEventArgs> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::IDatePickedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IDatePickerFlyoutItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IDatePickerFlyoutItemStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::DatePickerFlyoutItem> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::IDatePickerFlyoutItem, Windows::UI::Xaml::Data::ICustomPropertyProvider> {};
template<> struct def<Windows::UI::Xaml::Controls::IItemsPickedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ItemsPickedEventArgs> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::IItemsPickedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IPickerConfirmedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::PickerConfirmedEventArgs> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::IPickerConfirmedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::ITimePickedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::TimePickedEventArgs> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Controls::ITimePickedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IDatePickerFlyout> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IDatePickerFlyoutStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IDatePickerFlyout2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IDatePickerFlyoutStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListPickerFlyout> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IListPickerFlyoutStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPickerFlyout> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPickerFlyoutStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITimePickerFlyout> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ITimePickerFlyoutStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IDatePickerFlyoutPresenter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::DatePickerFlyoutPresenter> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IDatePickerFlyoutPresenter> {};
template<> struct def<Windows::UI::Xaml::Controls::IListPickerFlyoutPresenter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ListPickerFlyoutPresenter> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::IListPickerFlyoutPresenter> {};
template<> struct def<Windows::UI::Xaml::Controls::ITimePickerFlyoutPresenter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::TimePickerFlyoutPresenter> : class_type<Windows::UI::Xaml::Controls::Control, Windows::UI::Xaml::Controls::ITimePickerFlyoutPresenter> {};
template<> struct def<Windows::UI::Xaml::Controls::IPickerFlyoutPresenter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::PickerFlyoutPresenter> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::IPickerFlyoutPresenter> {};
template<> struct def<Windows::UI::Xaml::Controls::IPivot> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPivotStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPivotFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPivot2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPivotStatics2> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPivot3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPivotStatics3> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::Pivot> : class_type<Windows::UI::Xaml::Controls::ItemsControl, Windows::UI::Xaml::Controls::IPivot, Windows::UI::Xaml::Controls::IPivot2, Windows::UI::Xaml::Controls::IPivot3>, composer_type<Windows::UI::Xaml::Controls::IPivotFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::IPivotItem> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPivotItemFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::IPivotItemStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::PivotItem> : class_type<Windows::UI::Xaml::Controls::ContentControl, Windows::UI::Xaml::Controls::IPivotItem>, composer_type<Windows::UI::Xaml::Controls::IPivotItemFactory> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewBackRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::NavigationViewBackRequestedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::INavigationViewBackRequestedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewPaneClosingEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::NavigationViewPaneClosingEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::INavigationViewPaneClosingEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::NavigationViewItemInvokedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::NavigationViewSelectionChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::DatePickerFlyout> : class_type<Windows::UI::Xaml::Controls::Primitives::PickerFlyoutBase, Windows::UI::Xaml::Controls::IDatePickerFlyout, Windows::UI::Xaml::Controls::IDatePickerFlyout2> {};
template<> struct def<Windows::UI::Xaml::Controls::ListPickerFlyout> : class_type<Windows::UI::Xaml::Controls::Primitives::PickerFlyoutBase, Windows::UI::Xaml::Controls::IListPickerFlyout> {};
template<> struct def<Windows::UI::Xaml::Controls::PickerFlyout> : class_type<Windows::UI::Xaml::Controls::Primitives::PickerFlyoutBase, Windows::UI::Xaml::Controls::IPickerFlyout> {};
template<> struct def<Windows::UI::Xaml::Controls::TimePickerFlyout> : class_type<Windows::UI::Xaml::Controls::Primitives::PickerFlyoutBase, Windows::UI::Xaml::Controls::ITimePickerFlyout> {};
template<> struct def<Windows::UI::Xaml::Controls::INavigationViewDisplayModeChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::NavigationViewDisplayModeChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::INavigationViewDisplayModeChangedEventArgs> {};
template<> struct def<Windows::UI::Xaml::Controls::IColorChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Controls::ColorChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Controls::IColorChangedEventArgs> {};

// uuids

template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IPivotHeaderPanel> { define_guid(0x21484EBC, 0x9241, 0x4203, 0xBD, 0x37, 0x6C, 0x8, 0xFB, 0x9, 0x66, 0x12);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICanvasFactory> { define_guid(0x1B328BD1, 0xB400, 0x4A8E, 0x94, 0x3B, 0x5A, 0xD2, 0xC4, 0x5B, 0xE0, 0xDF);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICanvasStatics> { define_guid(0x40CE5C46, 0x2962, 0x446F, 0xAA, 0xFB, 0x4C, 0xDC, 0x48, 0x69, 0x39, 0xC9);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICanvas> { define_guid(0x79190E19, 0xCD38, 0x4823, 0xAE, 0xAE, 0x64, 0xA7, 0x71, 0x32, 0xF5, 0x19);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPanelFactory> { define_guid(0xEEE68111, 0xC7CC, 0x433F, 0x95, 0xCD, 0xD6, 0x30, 0xC3, 0x43, 0x2, 0xDD);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPanelStatics> { define_guid(0xF23D6B5D, 0x8330, 0x47A6, 0xA0, 0x46, 0x25, 0xF5, 0x9, 0xB2, 0x52, 0x32);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPanel> { define_guid(0xA50A4BBD, 0x8361, 0x469C, 0x90, 0xDA, 0xE9, 0xA4, 0xC, 0x74, 0x74, 0xDF);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IPivotHeaderItemFactory> { define_guid(0x14308B37, 0x185B, 0x4117, 0xBC, 0x77, 0xDD, 0xA2, 0xEB, 0x26, 0x1B, 0x99);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IPivotHeaderItem> { define_guid(0x594572C2, 0x82AA, 0x410B, 0x9E, 0x55, 0xFD, 0x8E, 0x2C, 0x98, 0x86, 0x2D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentControlFactory> { define_guid(0xAB017B19, 0x196E, 0x4ED5, 0xA2, 0x7F, 0x55, 0xC5, 0x8F, 0xB1, 0x67, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentControlStatics> { define_guid(0x116982A4, 0x5CF5, 0x4C05, 0xA5, 0x3F, 0x15, 0xE4, 0x87, 0x6C, 0x85, 0xEC);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentControl2> { define_guid(0x652C208C, 0x8CCF, 0x4399, 0xBD, 0x3E, 0x5A, 0x1, 0x5A, 0xA1, 0xBC, 0x3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentControlOverrides> { define_guid(0x5F4C0B10, 0xE38E, 0x4B5D, 0xBE, 0x1A, 0x5E, 0xD0, 0x42, 0x46, 0xA6, 0x35);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentControl> { define_guid(0xA26DD1DC, 0xCD44, 0x435C, 0xBE, 0x94, 0x1, 0xD6, 0x24, 0x1C, 0x23, 0x1C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IControlStatics5> { define_guid(0xF635B5A3, 0xEF8E, 0x404F, 0x87, 0x7B, 0x55, 0x80, 0x47, 0x37, 0x10, 0xA6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IControlStatics4> { define_guid(0x59FDA728, 0xC05A, 0x4EC2, 0x8A, 0x4B, 0x6, 0xAD, 0x69, 0xB6, 0x6E, 0x15);};
template<> struct uuid<Windows::UI::Xaml::Controls::IControlStatics3> { define_guid(0xAAD15E61, 0xE4B9, 0x4D72, 0xB6, 0x53, 0x93, 0x41, 0x49, 0xAA, 0x50, 0x3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IControlStatics2> { define_guid(0x32233E36, 0xAB74, 0x4A25, 0xA5, 0x56, 0x45, 0x29, 0x31, 0x35, 0xB2, 0xC5);};
template<> struct uuid<Windows::UI::Xaml::Controls::IControlFactory> { define_guid(0xB12B1D5A, 0x6419, 0x4E16, 0xB2, 0x12, 0xA4, 0x53, 0x36, 0xB7, 0x57, 0x78);};
template<> struct uuid<Windows::UI::Xaml::Controls::IControlStatics> { define_guid(0x473B305B, 0x877D, 0x4C35, 0x8F, 0xCA, 0x46, 0xA0, 0x5F, 0x96, 0x60, 0x7A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IControlOverrides6> { define_guid(0xE194C96A, 0xD8CC, 0x4339, 0xA0, 0xE1, 0x2E, 0x9C, 0x42, 0x8, 0x79, 0xEC);};
template<> struct uuid<Windows::UI::Xaml::Controls::IControl5> { define_guid(0x5EBB51D5, 0x9E58, 0x49B7, 0xBC, 0x2D, 0x1, 0x55, 0xFF, 0x11, 0x86, 0x64);};
template<> struct uuid<Windows::UI::Xaml::Controls::IControl4> { define_guid(0xE18AEEE, 0x5F2E, 0x44EA, 0x85, 0x13, 0xD3, 0x87, 0x5C, 0xA, 0x75, 0x13);};
template<> struct uuid<Windows::UI::Xaml::Controls::IControl3> { define_guid(0x77B29E4, 0xDADE, 0x4F55, 0x9B, 0x96, 0x9, 0xE2, 0x1B, 0x28, 0xEB, 0x1C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IControl2> { define_guid(0x43E0FE10, 0x14EC, 0x427E, 0x8C, 0x57, 0xDE, 0xE6, 0xD, 0xF6, 0xA, 0xA8);};
template<> struct uuid<Windows::UI::Xaml::Controls::IControlProtected> { define_guid(0x1791587A, 0x2A7C, 0x4981, 0xA2, 0xD8, 0xAB, 0x99, 0xFF, 0xFC, 0x65, 0xB9);};
template<> struct uuid<Windows::UI::Xaml::Controls::IControlOverrides> { define_guid(0xA09691DF, 0x9824, 0x41FE, 0xB5, 0x30, 0xB0, 0xD8, 0x99, 0xE, 0x64, 0xC1);};
template<> struct uuid<Windows::UI::Xaml::Controls::IControl> { define_guid(0xA8912263, 0x2951, 0x4F58, 0xA9, 0xC5, 0x5A, 0x13, 0x4E, 0xAA, 0x7F, 0x7);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo> { define_guid(0x1B5D1336, 0xE61B, 0x4D51, 0xBE, 0x41, 0xFD, 0x8D, 0xDC, 0x55, 0xC5, 0x8C);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ILoopingSelectorPanel> { define_guid(0x40A9BA70, 0x1011, 0x4778, 0x87, 0xF7, 0x6B, 0xFD, 0x20, 0xD6, 0x37, 0x7D);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ILoopingSelectorItem> { define_guid(0xC69714B9, 0x27C6, 0x4433, 0x9D, 0x7C, 0xD, 0xBF, 0xB2, 0xF4, 0x34, 0x4F);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IPivotPanel> { define_guid(0xAD4EBE80, 0x22A9, 0x4CA3, 0x92, 0x12, 0x27, 0x73, 0xB6, 0x35, 0x9F, 0xF3);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ILoopingSelectorStatics> { define_guid(0x3E8BAFA, 0x8C7D, 0x4FC5, 0xB9, 0x2A, 0xF0, 0x49, 0xFB, 0x93, 0x3C, 0xC5);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ILoopingSelector> { define_guid(0x4C9A3E04, 0x4827, 0x49D9, 0x88, 0x6, 0x9, 0x39, 0x57, 0xB0, 0xFD, 0x21);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IPickerFlyoutBaseFactory> { define_guid(0x7EC27A53, 0x9502, 0x4BEB, 0xB3, 0x42, 0x0, 0x56, 0x6C, 0x8F, 0x16, 0xB0);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IPickerFlyoutBaseStatics> { define_guid(0x5A4D0AC5, 0x89AE, 0x40E5, 0xA7, 0xF1, 0xBB, 0x70, 0x23, 0x55, 0xAD, 0xF3);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IPickerFlyoutBaseOverrides> { define_guid(0x5BFC4F4A, 0x4822, 0x47B4, 0xA9, 0x58, 0x77, 0xC2, 0xB, 0xA1, 0x20, 0xD3);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IPickerFlyoutBase> { define_guid(0xE33574EA, 0x1076, 0x44D1, 0x93, 0x83, 0xDC, 0x24, 0xAC, 0x5C, 0xFF, 0x2A);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseStatics3> { define_guid(0x7BA92E4F, 0xDD16, 0x4BE4, 0x99, 0xDB, 0xBD, 0x9D, 0x44, 0x6, 0xC0, 0xF8);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseStatics2> { define_guid(0xA8E913FE, 0x2D60, 0x4307, 0xAA, 0xD9, 0x56, 0xB4, 0x50, 0x12, 0x1B, 0x58);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseFactory> { define_guid(0x1C3363D7, 0xFCA7, 0x407E, 0x92, 0xE, 0x70, 0xE1, 0x5E, 0x9F, 0xB, 0xF1);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseStatics> { define_guid(0xE2D795E3, 0x85C0, 0x4DE2, 0xBA, 0xC1, 0x52, 0x94, 0xCA, 0x1, 0x1A, 0x78);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides4> { define_guid(0xA6BFD04D, 0x5FF3, 0x4418, 0xAD, 0xD8, 0x40, 0x42, 0xA8, 0x8D, 0x2D, 0xA5);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IFlyoutBase4> { define_guid(0xE3897D69, 0xA37F, 0x4828, 0x9B, 0x70, 0xE, 0xF6, 0x7C, 0x3, 0xB5, 0xF8);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IFlyoutBase3> { define_guid(0xA89C9712, 0x48E0, 0x4240, 0x95, 0xB9, 0xD, 0xFD, 0x8, 0x26, 0xA8, 0xD3);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IFlyoutBase2> { define_guid(0xF82B435E, 0x65B3, 0x41C6, 0xA9, 0xE2, 0x77, 0xB6, 0x7B, 0xC4, 0xC0, 0xC);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides> { define_guid(0x101DEC86, 0x6F4D, 0x45A4, 0x9D, 0xE, 0x3E, 0xCE, 0x6F, 0x16, 0x97, 0x7E);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IFlyoutBase> { define_guid(0x723EEA0B, 0xD12E, 0x430D, 0xA9, 0xF0, 0x9B, 0xB3, 0x2B, 0xBF, 0x99, 0x13);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IJumpListItemForegroundConverterStatics> { define_guid(0x474E7352, 0x210C, 0x4673, 0xAC, 0x6A, 0x41, 0x3F, 0xE, 0x2C, 0x77, 0x50);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IJumpListItemForegroundConverter> { define_guid(0x1590ED38, 0xC504, 0x4796, 0xA6, 0x3A, 0x5B, 0xFC, 0x9E, 0xEF, 0xAA, 0xE8);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IJumpListItemBackgroundConverterStatics> { define_guid(0x20E7C3DD, 0x6F27, 0x4808, 0xB0, 0xBE, 0x83, 0xE0, 0xE9, 0xB5, 0xCC, 0x45);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IJumpListItemBackgroundConverter> { define_guid(0x81177858, 0xD224, 0x410C, 0xB1, 0x6C, 0xC5, 0xB6, 0xBB, 0x61, 0x88, 0xB2);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseClosingEventArgs> { define_guid(0xD075852D, 0xB09A, 0x4FD1, 0xB0, 0x5, 0xDB, 0x2B, 0xA0, 0x12, 0x6, 0xFB);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IToggleButtonFactory> { define_guid(0xD56AA2FC, 0xFC7F, 0x449C, 0x98, 0x55, 0x7A, 0x10, 0x55, 0xD6, 0x68, 0xA8);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IToggleButtonStatics> { define_guid(0xAF1EAB12, 0x128, 0x4F67, 0x9C, 0x5A, 0x82, 0x32, 0xC, 0x44, 0x5D, 0x19);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IToggleButtonOverrides> { define_guid(0xD20E4C28, 0xF18B, 0x491A, 0x9A, 0x45, 0xF1, 0xA0, 0x4A, 0x93, 0x69, 0xA4);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IToggleButton> { define_guid(0x589877FB, 0xFC7, 0x4036, 0x9D, 0x8B, 0x12, 0x7D, 0xFA, 0x75, 0xC1, 0x6D);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IButtonBaseFactory> { define_guid(0x389B7C71, 0x5220, 0x42B2, 0x99, 0x92, 0x26, 0x90, 0xC1, 0xA6, 0x70, 0x2F);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IButtonBaseStatics> { define_guid(0x67EF17E1, 0xFE37, 0x474F, 0x9E, 0x97, 0x3B, 0x5E, 0xB, 0x30, 0xF2, 0xDF);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IButtonBase> { define_guid(0xFA002C1A, 0x494E, 0x46CF, 0x91, 0xD4, 0xE1, 0x4A, 0x8D, 0x79, 0x86, 0x74);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IRepeatButtonStatics> { define_guid(0x3914AC4E, 0xF462, 0x4F73, 0x81, 0x97, 0xE8, 0x84, 0x66, 0x39, 0xC6, 0x82);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IRepeatButton> { define_guid(0x2200DF9, 0x21A, 0x484A, 0xA9, 0x3B, 0xF, 0x31, 0x2, 0x3, 0x14, 0xE5);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ISelectorFactory> { define_guid(0xC9BE2995, 0xD136, 0x4600, 0xB1, 0x87, 0x8A, 0xD5, 0x60, 0x79, 0xB4, 0x8A);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ISelectorStatics> { define_guid(0x13300B06, 0xBD10, 0x4E09, 0xBF, 0xF7, 0x71, 0xEF, 0xB8, 0xBB, 0xB4, 0x2B);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ISelector> { define_guid(0xE30EB3A5, 0xB36B, 0x42DC, 0x85, 0x27, 0xCD, 0x25, 0x13, 0x6C, 0x8, 0x3C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsControlFactory> { define_guid(0xF7BBC359, 0xF8FD, 0x471C, 0xBC, 0xB2, 0x2C, 0x74, 0xBE, 0x8E, 0xBF, 0x8C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsControlStatics> { define_guid(0x37DABD89, 0xDCFB, 0x45B8, 0x9A, 0xFE, 0x87, 0x4D, 0xF0, 0x97, 0x90, 0x5E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsControl3> { define_guid(0x502B7489, 0xAEE4, 0x4DE3, 0xA2, 0xAB, 0x19, 0x5A, 0xC2, 0xC, 0x42, 0x12);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemContainerMapping> { define_guid(0x53C9F23A, 0xF25D, 0x446A, 0x99, 0xB8, 0xC7, 0xAE, 0xB8, 0x39, 0x5, 0xF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsControl2> { define_guid(0x754C3266, 0x529, 0x45E3, 0x87, 0x48, 0xBF, 0x74, 0x7D, 0x15, 0x83, 0x57);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsControlOverrides> { define_guid(0xC79BB41B, 0xA084, 0x4301, 0xA4, 0x96, 0x72, 0x97, 0x1F, 0x36, 0x4E, 0xD1);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsControl> { define_guid(0xF4A91DD8, 0xD979, 0x4381, 0x86, 0x52, 0xBD, 0xA0, 0x34, 0x2A, 0x76, 0x5E);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IScrollBarStatics> { define_guid(0x45EAF38D, 0xB814, 0x48CF, 0x97, 0xF2, 0x53, 0x9E, 0xB1, 0x6D, 0xFD, 0x4D);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IScrollBar> { define_guid(0xF57AE6CA, 0xD1A6, 0x4B90, 0xA4, 0xE9, 0x54, 0xDF, 0x1B, 0xA8, 0xD2, 0xEC);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IRangeBaseFactory> { define_guid(0x389B7C71, 0x5220, 0x42B2, 0x99, 0x92, 0x26, 0x90, 0xC1, 0xA6, 0x70, 0x30);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IRangeBaseStatics> { define_guid(0x67EF17E1, 0xFE37, 0x474F, 0x9E, 0x97, 0x3B, 0x5E, 0xB, 0x30, 0xF2, 0xE0);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IRangeBaseOverrides> { define_guid(0x4291AF39, 0x7F0B, 0x4BC2, 0x99, 0xC4, 0x6, 0xE7, 0x6, 0x26, 0x82, 0xD8);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IRangeBase> { define_guid(0xFA002C1A, 0x494E, 0x46CF, 0x91, 0xD4, 0xE1, 0x4A, 0x8D, 0x79, 0x86, 0x75);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IThumbStatics> { define_guid(0x955024EB, 0x36F3, 0x4672, 0xA1, 0x86, 0xBA, 0xAF, 0x62, 0x6A, 0xC4, 0xAD);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IThumb> { define_guid(0xE8B2B281, 0xD6A, 0x45CF, 0xB3, 0x33, 0x24, 0x2, 0xB0, 0x37, 0xF0, 0x99);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IColorPickerSliderFactory> { define_guid(0x6D879A2, 0x8C07, 0x4B1E, 0xA9, 0x40, 0x9F, 0xBC, 0xE8, 0xF4, 0x96, 0x39);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IColorPickerSliderStatics> { define_guid(0x22EAFC6A, 0x9FE3, 0x4EEE, 0x87, 0x34, 0xA1, 0x39, 0x8E, 0xC4, 0x41, 0x3A);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IColorPickerSlider> { define_guid(0x94394D83, 0xE0DF, 0x4C5F, 0xBB, 0xCD, 0x81, 0x55, 0xF4, 0x2, 0x4, 0x40);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISliderStatics2> { define_guid(0xE7935D, 0x79A5, 0x4759, 0x96, 0xA6, 0x29, 0xE0, 0xA9, 0x4A, 0xDD, 0x33);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISliderFactory> { define_guid(0x3A67B37, 0xC7BF, 0x437C, 0x84, 0x8F, 0x8C, 0xB5, 0xB7, 0x53, 0xEA, 0xB4);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISliderStatics> { define_guid(0x8A4363D7, 0x7FDF, 0x4D30, 0x98, 0xFE, 0xCE, 0x78, 0xC0, 0x5B, 0x31, 0xCF);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISlider2> { define_guid(0x40A3C50E, 0x87D6, 0x4D2F, 0xB1, 0xCF, 0xB2, 0x79, 0xCC, 0x99, 0x6F, 0x26);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISlider> { define_guid(0x89572027, 0x4C48, 0x4700, 0x80, 0x76, 0x49, 0x7B, 0xA7, 0x3D, 0x9C, 0x18);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ISelectorItemFactory> { define_guid(0xB9363945, 0xC86A, 0x4B1E, 0x94, 0x40, 0x18, 0x79, 0x37, 0x8D, 0x53, 0x13);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ISelectorItemStatics> { define_guid(0x2A353AB8, 0xCBE9, 0x4303, 0x92, 0xE7, 0xC8, 0x90, 0x6E, 0x21, 0x83, 0x92);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ISelectorItem> { define_guid(0x541C8D6C, 0x283, 0x4581, 0xB9, 0x45, 0x2A, 0x64, 0xC2, 0x8A, 0x6, 0x46);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IColorSpectrumFactory> { define_guid(0x90C7E61E, 0x904D, 0x42AB, 0xB4, 0x4F, 0xE6, 0x8D, 0xBF, 0xC, 0xDE, 0xE9);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IColorSpectrumStatics> { define_guid(0x906BEE7C, 0x2CEE, 0x4E90, 0x96, 0x8B, 0xF0, 0xA5, 0xBD, 0x69, 0x1B, 0x4A);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IColorSpectrum> { define_guid(0xCE46F271, 0xF509, 0x4F98, 0x82, 0x88, 0xE4, 0x94, 0x2F, 0xB3, 0x85, 0xDF);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenterStatics3> { define_guid(0xC3D3D11E, 0xFA26, 0x4CE7, 0xA4, 0xED, 0xFF, 0x94, 0x8F, 0x1, 0xB7, 0xC0);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenterStatics2> { define_guid(0x4CB3B945, 0xD24D, 0x42A3, 0x9E, 0x83, 0xA8, 0x6D, 0x6, 0x18, 0xBF, 0x1B);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenterFactory> { define_guid(0xE0777CFD, 0xF7E4, 0x4A67, 0x9A, 0xC0, 0xA9, 0x94, 0xFC, 0xAC, 0xD0, 0x20);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenterStatics> { define_guid(0x6504A55A, 0x15DD, 0x42FB, 0xAA, 0x5D, 0x2D, 0x8C, 0xE2, 0xE9, 0xC2, 0x94);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter3> { define_guid(0x36620013, 0x390, 0x4E30, 0xAD, 0x97, 0x87, 0x44, 0x40, 0x4F, 0x70, 0x10);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter2> { define_guid(0xF5DC5496, 0xE122, 0x4C57, 0xA6, 0x25, 0xAC, 0x4B, 0x8, 0xFB, 0x2D, 0x4C);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter> { define_guid(0xFC8946BD, 0xA3A2, 0x4969, 0x81, 0x74, 0x25, 0xB5, 0xD3, 0xC2, 0x80, 0x33);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentPresenterStatics4> { define_guid(0xFF8BE292, 0xAF28, 0x47EB, 0xA5, 0xC3, 0xDC, 0x44, 0xCE, 0xD4, 0xF, 0xD2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentPresenterStatics3> { define_guid(0xCBE6CF5B, 0x38B1, 0x4D5D, 0xB0, 0x98, 0xBC, 0x94, 0xB3, 0x5C, 0x8D, 0xDF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentPresenterStatics2> { define_guid(0xC7D89DD9, 0x6E6, 0x46BE, 0xA8, 0xA0, 0x9C, 0x11, 0x7D, 0x30, 0x24, 0xA3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentPresenterFactory> { define_guid(0x3339D4F7, 0x4815, 0x44C4, 0x9F, 0x76, 0x68, 0xC8, 0x38, 0x80, 0xEF, 0x10);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentPresenterStatics> { define_guid(0x18C2893B, 0xDA2E, 0x4426, 0xB8, 0x5A, 0x2C, 0x7E, 0x21, 0x71, 0xBE, 0xDF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentPresenter4> { define_guid(0x997B1B17, 0x3BF8, 0x432B, 0x8F, 0xD9, 0x68, 0xC7, 0xBA, 0xB2, 0x1F, 0x9D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentPresenter3> { define_guid(0xB038876A, 0x9C4D, 0x4402, 0xAC, 0x56, 0xA2, 0x23, 0x48, 0x7D, 0xC6, 0xC8);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentPresenter2> { define_guid(0x5138E958, 0x335D, 0x4210, 0x8B, 0xBB, 0xA, 0xA2, 0xB4, 0xB5, 0xC2, 0x9E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentPresenterOverrides> { define_guid(0xA76339ED, 0x32FF, 0x438B, 0xAA, 0xD5, 0x1D, 0x68, 0xFA, 0xE9, 0x34, 0x26);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentPresenter> { define_guid(0x79FDE5B4, 0xCD37, 0x491C, 0x88, 0x45, 0xDA, 0xF4, 0x72, 0xDE, 0xFF, 0xF6);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IGridViewItemPresenterFactory> { define_guid(0x53C12178, 0x63BB, 0x4A65, 0xA3, 0xF1, 0xAB, 0x11, 0x4C, 0xFC, 0x6F, 0xFE);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IGridViewItemPresenterStatics> { define_guid(0xE958F8C4, 0x277E, 0x4A72, 0xA0, 0x1E, 0x9E, 0x16, 0x88, 0x98, 0x1, 0x78);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IGridViewItemPresenter> { define_guid(0x214F9010, 0x56E2, 0x4821, 0x8A, 0x1C, 0x23, 0x5, 0x70, 0x9A, 0xF9, 0x4B);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ICalendarPanel> { define_guid(0xFCD55A2D, 0x2D3, 0x4EE6, 0x9A, 0x90, 0x9D, 0xF3, 0xEA, 0xD0, 0x9, 0x94);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IOrientedVirtualizingPanelFactory> { define_guid(0x7B8EAEAF, 0xF92F, 0x439D, 0x9E, 0xBF, 0xE9, 0x91, 0x9F, 0x56, 0xC9, 0x4D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInsertionPanel> { define_guid(0x6B8DE08F, 0x6527, 0x4D39, 0xBC, 0xBF, 0x58, 0xB0, 0x1D, 0xA9, 0x23, 0xD7);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IOrientedVirtualizingPanel> { define_guid(0xF077B577, 0x39BD, 0x46EE, 0xBD, 0xD7, 0x8, 0x26, 0xBE, 0xED, 0x71, 0xB8);};
template<> struct uuid<Windows::UI::Xaml::Controls::IVirtualizingPanelFactory> { define_guid(0xBE19F839, 0xCBD0, 0x43E9, 0xA5, 0xD0, 0xB, 0xDB, 0xA0, 0xFF, 0xBD, 0x38);};
template<> struct uuid<Windows::UI::Xaml::Controls::IVirtualizingPanelProtected> { define_guid(0xC9C9AB42, 0xC232, 0x479D, 0xA7, 0xC9, 0x5E, 0x76, 0x11, 0x19, 0x6A, 0x45);};
template<> struct uuid<Windows::UI::Xaml::Controls::IVirtualizingPanelOverrides> { define_guid(0x5EF6BD7D, 0x677F, 0x408D, 0xA9, 0x6C, 0xB1, 0x95, 0x7, 0x75, 0x4, 0x66);};
template<> struct uuid<Windows::UI::Xaml::Controls::IVirtualizingPanel> { define_guid(0x38AAD50C, 0x12CF, 0x4D1E, 0xA8, 0x84, 0xC9, 0xDF, 0x85, 0xF0, 0x7C, 0xD9);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ICarouselPanelFactory> { define_guid(0xC1109404, 0x9AE1, 0x440E, 0xA0, 0xDD, 0xBB, 0xB6, 0xE2, 0x29, 0x3C, 0xBE);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ICarouselPanel> { define_guid(0xDEAB78B2, 0x373B, 0x4151, 0x87, 0x85, 0xE5, 0x44, 0xD0, 0xD9, 0x36, 0x2B);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ITickBarStatics> { define_guid(0x2C6D7E40, 0x799D, 0x4A54, 0xBE, 0x9, 0x1F, 0xEF, 0xC6, 0x1D, 0x1, 0x8E);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ITickBar> { define_guid(0x994683FA, 0xF1F6, 0x487D, 0xA5, 0xAC, 0xC1, 0x59, 0x21, 0xBF, 0xA9, 0x95);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IPopupStatics2> { define_guid(0x2B9AE9EC, 0x55EF, 0x43B6, 0xB4, 0x59, 0x12, 0xE4, 0xF, 0xFA, 0x43, 0x2);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IPopupStatics> { define_guid(0x5AE3BF1A, 0x6E34, 0x40D6, 0x8A, 0x7F, 0xCA, 0x82, 0x2A, 0xAF, 0x59, 0xE3);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IPopup2> { define_guid(0x376A8C4C, 0xAAC0, 0x4B20, 0x96, 0x6A, 0xB, 0x93, 0x64, 0xFE, 0xB4, 0xB5);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IPopup> { define_guid(0x62418240, 0xE6D3, 0x4705, 0xA1, 0xDC, 0x39, 0x15, 0x64, 0x56, 0xEE, 0x29);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IScrollEventArgs> { define_guid(0xC57E5168, 0x3AFE, 0x448D, 0xB7, 0x52, 0x2F, 0x36, 0x4C, 0x75, 0xD7, 0x43);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IRangeBaseValueChangedEventArgs> { define_guid(0xA1921777, 0xD5C1, 0x4F9C, 0xA7, 0xB0, 0x4, 0x1, 0xB7, 0xE6, 0xDC, 0x5C);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IDragStartedEventArgsFactory> { define_guid(0x5EEFE579, 0xC706, 0x4781, 0xA3, 0x8, 0xC9, 0xE7, 0xF4, 0xC6, 0xA1, 0xD7);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IDragStartedEventArgs> { define_guid(0x9F915DD0, 0xA124, 0x4366, 0xBD, 0x85, 0x24, 0x8, 0x21, 0x4A, 0xEE, 0xD4);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IDragDeltaEventArgsFactory> { define_guid(0x46E7A1EF, 0xAE15, 0x44A6, 0x8A, 0x4, 0x95, 0xB0, 0xBF, 0x9A, 0xB8, 0x76);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IDragDeltaEventArgs> { define_guid(0x2C2DD73C, 0x2806, 0x49FC, 0xAA, 0xE9, 0x6D, 0x79, 0x2B, 0x57, 0x2B, 0x6A);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IDragCompletedEventArgsFactory> { define_guid(0x36A7D99D, 0x148C, 0x495F, 0xA0, 0xFC, 0xAF, 0xC8, 0x71, 0xD6, 0x2F, 0x33);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IDragCompletedEventArgs> { define_guid(0xB04F29A1, 0xBD16, 0x48F6, 0xA5, 0x11, 0x9C, 0x27, 0x63, 0x64, 0x13, 0x31);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IAppBarToggleButtonTemplateSettings> { define_guid(0xAAF99C48, 0xD8F4, 0x40D9, 0x9F, 0xA3, 0x3A, 0x64, 0xF0, 0xFE, 0xC5, 0xD8);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IAppBarButtonTemplateSettings> { define_guid(0xCBC9B39D, 0xC95, 0x4951, 0xBF, 0xF2, 0x13, 0x96, 0x36, 0x91, 0xC3, 0x66);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ICommandBarTemplateSettings3> { define_guid(0x3BD71EBA, 0x3403, 0x4BFE, 0x84, 0x2D, 0x2C, 0xE8, 0xC5, 0x11, 0xD2, 0x45);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ICommandBarTemplateSettings2> { define_guid(0xFBB24F93, 0xC2E2, 0x4177, 0xA2, 0xB6, 0x3C, 0xD7, 0x5, 0x7, 0x3C, 0xF6);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ICommandBarTemplateSettings> { define_guid(0x61C8F92C, 0x5AA, 0x414A, 0xA2, 0xAE, 0x48, 0x2C, 0x5A, 0x46, 0xC0, 0x8E);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IMenuFlyoutItemTemplateSettings> { define_guid(0x56AD1809, 0x3A16, 0x4147, 0x81, 0xCB, 0xD0, 0xB3, 0x5C, 0x83, 0x4E, 0xF);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IAppBarTemplateSettings> { define_guid(0xBCC2A863, 0xEB35, 0x423C, 0x83, 0x89, 0xD7, 0x82, 0x7B, 0xE3, 0xBF, 0x67);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ISplitViewTemplateSettings> { define_guid(0xC16AB5A7, 0x4996, 0x4443, 0xB1, 0x99, 0x6B, 0x6B, 0x89, 0x12, 0x4E, 0xAB);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ICalendarViewTemplateSettings> { define_guid(0x56C71483, 0x64E1, 0x477C, 0x8A, 0xB, 0xCB, 0x2F, 0x33, 0x34, 0xB9, 0xB0);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IMenuFlyoutPresenterTemplateSettings> { define_guid(0xD68FD00D, 0x629D, 0x4349, 0xAC, 0x51, 0xB8, 0x77, 0xC8, 0x9, 0x83, 0xB8);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IListViewItemTemplateSettings> { define_guid(0x67AF84BF, 0x8279, 0x4686, 0x93, 0x26, 0xCD, 0x18, 0x9F, 0x27, 0x57, 0x5D);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IGridViewItemTemplateSettings> { define_guid(0x9E30BAAF, 0x165D, 0x4267, 0xA4, 0x5E, 0x1A, 0x43, 0xA7, 0x57, 0x6, 0xAC);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IComboBoxTemplateSettings2> { define_guid(0xE90CD7, 0x68BE, 0x449D, 0xB5, 0xA7, 0x76, 0xE2, 0x6F, 0x70, 0x3E, 0x9B);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IComboBoxTemplateSettings> { define_guid(0x83285C4E, 0x17F6, 0x4AA3, 0xB6, 0x1B, 0xE8, 0x7C, 0x71, 0x86, 0x4, 0xEA);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IToolTipTemplateSettings> { define_guid(0xD4388247, 0xEC4, 0x4506, 0xAF, 0xFD, 0xAF, 0xAC, 0x22, 0x25, 0xB4, 0x8C);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ISettingsFlyoutTemplateSettings> { define_guid(0xBCF14C10, 0xCEA7, 0x43F1, 0x9D, 0x68, 0x57, 0x60, 0x5D, 0xED, 0x69, 0xD4);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IProgressBarTemplateSettings> { define_guid(0x3FE2EA2A, 0xE3F2, 0x4C2B, 0x94, 0x88, 0x91, 0x8D, 0x77, 0xD2, 0xBB, 0xE4);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IToggleSwitchTemplateSettings> { define_guid(0x2B7BDCD, 0x628A, 0x4363, 0x86, 0xE0, 0x51, 0xD6, 0xE2, 0xE8, 0x9E, 0x58);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IProgressRingTemplateSettings> { define_guid(0xB9B675EC, 0xC723, 0x42E6, 0x83, 0xE9, 0x98, 0x26, 0x27, 0x2B, 0xDC, 0xE);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IGeneratorPositionHelperStatics> { define_guid(0xAD4095CD, 0x60EC, 0x4588, 0x8D, 0x60, 0x39, 0xD2, 0x90, 0x97, 0xA4, 0xDF);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IGeneratorPositionHelper> { define_guid(0xCD40318D, 0x7745, 0x40D9, 0xAB, 0x9D, 0xAB, 0xBD, 0xA4, 0xA7, 0xFF, 0xEA);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::DragCompletedEventHandler> { define_guid(0x36B28888, 0x19AC, 0x4B4E, 0x91, 0x37, 0xA6, 0xCF, 0x2B, 0x2, 0x38, 0x83);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::DragDeltaEventHandler> { define_guid(0x4AC24F9F, 0xAC28, 0x49E9, 0x91, 0x89, 0xDC, 0xCF, 0xFE, 0xB6, 0x64, 0x72);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::DragStartedEventHandler> { define_guid(0xD2EEA48A, 0xC65A, 0x495D, 0xA2, 0xF1, 0x72, 0xC6, 0x69, 0x89, 0x14, 0x2D);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ItemsChangedEventHandler> { define_guid(0x178257BE, 0xA304, 0x482F, 0x8B, 0xF0, 0xB9, 0xD2, 0xE3, 0x96, 0x12, 0xA3);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::IItemsChangedEventArgs> { define_guid(0xE8B45568, 0x7D10, 0x421E, 0xBE, 0x29, 0x81, 0x83, 0x9A, 0x91, 0xDE, 0x20);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventHandler> { define_guid(0xE3906FD9, 0x4D1B, 0x4AC8, 0xA4, 0x3C, 0xC3, 0xB9, 0x8, 0x74, 0x27, 0x99);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ScrollEventHandler> { define_guid(0x8860B0A4, 0xA383, 0x4C83, 0xB3, 0x6, 0xA1, 0xC3, 0x9D, 0x7D, 0xB8, 0x7F);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ILayoutInformationStatics2> { define_guid(0x760315B5, 0x6D4E, 0x4939, 0xAC, 0x61, 0x63, 0x98, 0x63, 0xCE, 0xA3, 0x6B);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ILayoutInformationStatics> { define_guid(0xCF06CF99, 0x58E9, 0x4682, 0x83, 0x26, 0x50, 0xCA, 0xAB, 0x65, 0xED, 0x7C);};
template<> struct uuid<Windows::UI::Xaml::Controls::Primitives::ILayoutInformation> { define_guid(0xB5384C9B, 0xC8CF, 0x41B3, 0xBF, 0x16, 0x18, 0xC8, 0x42, 0xE, 0x72, 0xC9);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDragItemsCompletedEventArgs> { define_guid(0xAF05F22F, 0x9E78, 0x4B21, 0x9A, 0x8E, 0x41, 0xC2, 0xD1, 0x36, 0x7A, 0x2A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDragItemsStartingEventArgs> { define_guid(0x71CF215C, 0xDAED, 0x4783, 0xAA, 0x11, 0xDC, 0x57, 0x4D, 0x27, 0x13, 0xE9);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGroupStyle> { define_guid(0x71CA300B, 0xB89E, 0x4184, 0xB0, 0xDF, 0xA9, 0xE9, 0x54, 0x47, 0xDE, 0x8D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IStyleSelectorFactory> { define_guid(0x9E942AE7, 0x3761, 0x447F, 0x8F, 0x97, 0x29, 0xE3, 0x9D, 0x5E, 0xB3, 0x10);};
template<> struct uuid<Windows::UI::Xaml::Controls::IStyleSelectorOverrides> { define_guid(0x8ADD66D, 0xE2E, 0x43A0, 0xAE, 0xCA, 0x8F, 0xAA, 0x94, 0xB9, 0xD0, 0x17);};
template<> struct uuid<Windows::UI::Xaml::Controls::IStyleSelector> { define_guid(0xD1113F67, 0xD8C1, 0x4AE4, 0x98, 0xF0, 0xD8, 0x50, 0x45, 0x2, 0xF0, 0x8B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGroupStyleFactory> { define_guid(0x56FF664F, 0xE2D7, 0x4F49, 0x80, 0x3D, 0xC7, 0x27, 0xCD, 0xF9, 0x37, 0x2D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGroupStyle2> { define_guid(0x69F90679, 0x3A11, 0x4FE7, 0xB4, 0xDF, 0x2A, 0x1, 0x39, 0xD4, 0x1, 0x8B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGroupStyleSelector> { define_guid(0x6DDA119E, 0x9A74, 0x478F, 0xA3, 0x39, 0x5B, 0xB5, 0x2D, 0xE6, 0xC5, 0x1E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGroupStyleSelectorOverrides> { define_guid(0xF691CAB2, 0x77AD, 0x4D3D, 0xA5, 0x1C, 0x8E, 0xF9, 0xC3, 0x83, 0x64, 0x56);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGroupStyleSelectorFactory> { define_guid(0xBF570D33, 0xB2F6, 0x481F, 0xA4, 0x50, 0xC8, 0xC, 0x29, 0x1F, 0xB2, 0x2D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IHandwritingPanelClosedEventArgs> { define_guid(0x4FB91C73, 0x192D, 0x4DD2, 0xA1, 0xA2, 0x80, 0xED, 0x1, 0x12, 0x58, 0x76);};
template<> struct uuid<Windows::UI::Xaml::Controls::IHandwritingPanelOpenedEventArgs> { define_guid(0xFC15B16D, 0x9F15, 0x47B0, 0xB9, 0x7A, 0x94, 0xA6, 0x8C, 0xC6, 0x13, 0x45);};
template<> struct uuid<Windows::UI::Xaml::Controls::IIsTextTrimmedChangedEventArgs> { define_guid(0x16F597CD, 0xEBFF, 0x4FB4, 0x87, 0x14, 0x26, 0x14, 0x74, 0x18, 0xB9, 0x45);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemContainerGenerator> { define_guid(0x40765F00, 0x83F0, 0x4D7F, 0xB1, 0xB8, 0xF1, 0x9D, 0xE4, 0xF1, 0xD5, 0xDA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaTransportControlsHelper> { define_guid(0x3D41D509, 0xFF44, 0x4420, 0x80, 0x7E, 0x8F, 0x7A, 0x2E, 0x2C, 0x42, 0x51);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaTransportControlsHelperStatics> { define_guid(0x5A772047, 0xA9A1, 0x4625, 0x92, 0x70, 0x7F, 0x49, 0x87, 0x5D, 0x43, 0x94);};
template<> struct uuid<Windows::UI::Xaml::Controls::INotifyEventArgs> { define_guid(0xAF0E05F7, 0xC4B7, 0x44C5, 0xB0, 0x9D, 0x5C, 0xB7, 0x5, 0x2B, 0x3A, 0x97);};
template<> struct uuid<Windows::UI::Xaml::Controls::INotifyEventArgs2> { define_guid(0xD140F56, 0x1DCE, 0x4FCD, 0x85, 0xBC, 0x5A, 0x55, 0x72, 0x27, 0x3B, 0x9C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPasswordBoxPasswordChangingEventArgs> { define_guid(0x142EDA22, 0x3552, 0x4AB8, 0x81, 0xA6, 0xA4, 0x86, 0x20, 0xEE, 0x9C, 0x53);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRowDefinitionStatics> { define_guid(0x5ADF3FE5, 0x2056, 0x4724, 0x94, 0xD6, 0xE4, 0x81, 0x2B, 0x2, 0x2E, 0xC8);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRowDefinition> { define_guid(0x4ABAE829, 0xD80C, 0x4A5E, 0xA4, 0x8C, 0xF8, 0xB3, 0xD3, 0xB6, 0x53, 0x3D);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISemanticZoomLocation> { define_guid(0x42011736, 0xE3C2, 0x496B, 0xBC, 0x4E, 0xD7, 0x50, 0xD4, 0x37, 0x5B, 0x9A);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISemanticZoomViewChangedEventArgs> { define_guid(0x47DFC068, 0xB569, 0x4B19, 0x84, 0x2D, 0x8E, 0x6C, 0xF9, 0x9, 0x89, 0xAF);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBoxBeforeTextChangingEventArgs> { define_guid(0xA5541DB3, 0x7784, 0x4258, 0xAA, 0x83, 0xE4, 0xBE, 0xDD, 0x72, 0x74, 0x67);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBoxTextChangingEventArgs> { define_guid(0x4E6A4B75, 0x43DD, 0x4E33, 0xAC, 0xBE, 0x2D, 0x87, 0x96, 0xA1, 0x79, 0x27);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBoxTextChangingEventArgs2> { define_guid(0xC0723D44, 0x53A6, 0x415F, 0xA9, 0x81, 0x50, 0xDF, 0xAF, 0x1B, 0xEC, 0xBE);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextCompositionChangedEventArgs> { define_guid(0xB9C7E0F2, 0x50B7, 0x441D, 0x99, 0xC, 0x68, 0x55, 0x3E, 0x2E, 0x5, 0x6B);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextCompositionEndedEventArgs> { define_guid(0x46E34DB2, 0x77C0, 0x4015, 0x8E, 0xB4, 0x92, 0xEE, 0xFD, 0xFC, 0x59, 0x14);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextCompositionStartedEventArgs> { define_guid(0xDF22ABB2, 0x10CF, 0x491E, 0x91, 0xE8, 0xD3, 0xCD, 0x72, 0xD8, 0xA0, 0xD3);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextControlCopyingToClipboardEventArgs> { define_guid(0xE405EF19, 0xD0DF, 0x43DA, 0xAC, 0xE6, 0x16, 0xF9, 0x11, 0x38, 0x68, 0xC3);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextControlCuttingToClipboardEventArgs> { define_guid(0x5F894995, 0xA58D, 0x4CF3, 0xB5, 0x89, 0xB5, 0xE5, 0x0, 0xE0, 0x64, 0x75);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextControlPasteEventArgs> { define_guid(0x4BD1D625, 0x221A, 0x477E, 0xBB, 0x2C, 0xAD, 0xC, 0x1E, 0xD1, 0x25, 0xE7);};
template<> struct uuid<Windows::UI::Xaml::Controls::IToolTipService> { define_guid(0x3A55F87, 0xBFCC, 0x4A1E, 0x8F, 0xEA, 0x98, 0xF6, 0x10, 0x83, 0x2C, 0xEA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IToolTipServiceStatics> { define_guid(0x86E649F8, 0xE245, 0x48AA, 0xA8, 0xC8, 0xD1, 0x7, 0x3E, 0xD7, 0x63, 0x19);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICleanUpVirtualizedItemEventArgs> { define_guid(0xEA05CCE9, 0x937C, 0x4120, 0x84, 0x6, 0x79, 0x21, 0x85, 0x78, 0x43, 0x38);};
template<> struct uuid<Windows::UI::Xaml::Controls::IColumnDefinition> { define_guid(0xF7F1B229, 0xF024, 0x467F, 0x97, 0xA, 0x7E, 0x70, 0x56, 0x15, 0xDB, 0x7B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IColumnDefinitionStatics> { define_guid(0x6B0D728, 0xD044, 0x40C6, 0x94, 0x2E, 0xAE, 0x60, 0xEA, 0xC7, 0x48, 0x51);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContextMenuEventArgs> { define_guid(0x1F7DF263, 0xC14B, 0x4528, 0xB6, 0xF0, 0x63, 0x79, 0x99, 0xD8, 0x3C, 0xC6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemClickEventArgs> { define_guid(0x9C314242, 0xF29A, 0x494D, 0xA3, 0xA5, 0xD4, 0xC7, 0xB2, 0xA4, 0x68, 0x52);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISelectionChangedEventArgs> { define_guid(0xC972D2DC, 0xB609, 0x4758, 0x85, 0x1E, 0xA7, 0x99, 0xC2, 0x1D, 0xE9, 0x7D);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISelectionChangedEventArgsFactory> { define_guid(0x11A8B6B5, 0x2830, 0x4517, 0x84, 0xCD, 0x55, 0x24, 0xC8, 0xB8, 0x8B, 0x45);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextChangedEventArgs> { define_guid(0x4DD04F7D, 0x7A11, 0x4B2E, 0x99, 0x33, 0x57, 0x7D, 0xF3, 0x92, 0x52, 0xB6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsPanelTemplate> { define_guid(0x14EAD768, 0x34B2, 0x4B97, 0xBF, 0x3C, 0xE8, 0xD7, 0x32, 0x30, 0xA2, 0xAA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IBorder> { define_guid(0x797C4539, 0x45BD, 0x4633, 0xA0, 0x44, 0xBF, 0xB0, 0x2E, 0xF5, 0x17, 0xF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IBorderStatics> { define_guid(0xB81D1639, 0xE911, 0x4FD7, 0xA4, 0xC4, 0xB9, 0xC7, 0xF0, 0x8, 0xB7, 0xFC);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICaptureElement> { define_guid(0x31A5C0E7, 0xF307, 0x4D4A, 0xB6, 0x26, 0xE9, 0x78, 0x86, 0x3F, 0x5B, 0x74);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICaptureElementStatics> { define_guid(0x1E438DED, 0x7DA6, 0x409E, 0x80, 0x6E, 0x30, 0x5A, 0xE4, 0xAD, 0x9B, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IImage> { define_guid(0x495B7402, 0x9AF3, 0x4E50, 0xAA, 0x90, 0x3, 0x38, 0x8F, 0x30, 0x86, 0xD2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IImageStatics> { define_guid(0x89903772, 0xC336, 0x43D1, 0x9D, 0x51, 0xC3, 0xBB, 0xD5, 0xD5, 0xD6, 0x91);};
template<> struct uuid<Windows::UI::Xaml::Controls::IImage2> { define_guid(0xF445119E, 0x881F, 0x48BB, 0x87, 0x3A, 0x64, 0x41, 0x7C, 0xA4, 0xF0, 0x2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IImage3> { define_guid(0x6EBE792, 0x47C2, 0x4D92, 0xA4, 0x88, 0x8C, 0xD6, 0x85, 0xD0, 0x6A, 0xCA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsPresenter> { define_guid(0xC271569B, 0x6DCA, 0x4E2B, 0x8E, 0x14, 0xC5, 0x51, 0x36, 0xB0, 0x2A, 0x71);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsPresenterStatics> { define_guid(0x18DE66CD, 0x4A6C, 0x4B2E, 0xAA, 0x86, 0xCB, 0x12, 0x6C, 0x9A, 0x29, 0x20);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsPresenter2> { define_guid(0x5C04AA33, 0x1DF3, 0x4731, 0xA4, 0xC9, 0xDA, 0x81, 0x83, 0x78, 0xD6, 0x3D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsPresenterStatics2> { define_guid(0x8971632E, 0x7867, 0x4D66, 0x96, 0x30, 0x29, 0xF1, 0xC5, 0xF7, 0x40, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlock> { define_guid(0xE5FFF9E2, 0xB968, 0x49E7, 0x97, 0xD4, 0x8C, 0xCA, 0x2A, 0xC3, 0xAE, 0x7C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlockStatics> { define_guid(0x492D883C, 0xADEA, 0x433C, 0xBE, 0x1C, 0x20, 0x8A, 0x16, 0x42, 0x62, 0xBE);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlock2> { define_guid(0x3F209013, 0x3E7, 0x4508, 0x96, 0x4A, 0x91, 0xAE, 0xDA, 0xB3, 0xD1, 0x1E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlockStatics2> { define_guid(0xD6131E1, 0xAF29, 0x48CE, 0x8A, 0xAF, 0x74, 0xEC, 0xC2, 0x8B, 0xFB, 0xB0);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlock3> { define_guid(0x7D39AE83, 0x8918, 0x4613, 0xB0, 0x7, 0x7C, 0x89, 0x8B, 0xA2, 0x95, 0xE);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlockStatics3> { define_guid(0x73F7EF4, 0xCA2B, 0x4B49, 0xA5, 0x9A, 0x31, 0xD8, 0xFA, 0x74, 0x33, 0x32);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlock4> { define_guid(0x3577C1EA, 0x24FD, 0x4F50, 0xBB, 0xE4, 0x3F, 0xB6, 0x54, 0xEA, 0x58, 0xC5);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlockStatics4> { define_guid(0x80155BC4, 0x6D96, 0x4B08, 0xAD, 0x57, 0x13, 0xDB, 0xF, 0x4, 0x64, 0x12);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlock5> { define_guid(0x9C7DC0C6, 0x7A9F, 0x45B6, 0x88, 0x18, 0x82, 0x2C, 0x54, 0x9B, 0xA0, 0x94);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlockStatics5> { define_guid(0xAC9283A1, 0x4F25, 0x4280, 0x88, 0x68, 0x3E, 0xEE, 0xE8, 0x28, 0x21, 0xE8);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlockOverflow> { define_guid(0x4F93749B, 0xDAC3, 0x4A42, 0x9C, 0xBB, 0x99, 0xF0, 0xDE, 0x37, 0xC0, 0x71);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlockOverflowStatics> { define_guid(0x41AC2F7, 0x4F2B, 0x43C3, 0xA1, 0x22, 0x3F, 0xEA, 0x9C, 0xA9, 0xDC, 0x87);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlockOverflow2> { define_guid(0x8742624E, 0xA882, 0x4826, 0xB9, 0x29, 0x4D, 0x5C, 0x39, 0x5, 0xB9, 0xA1);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlockOverflowStatics2> { define_guid(0xB5EBED4C, 0xF8C4, 0x4A3A, 0x90, 0x7F, 0xE5, 0x3E, 0x78, 0x27, 0x9F, 0xA3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlockOverflow3> { define_guid(0x7F69587B, 0x5C7F, 0x4B5F, 0xBD, 0xBC, 0xFB, 0x95, 0xC9, 0xE, 0x10, 0xDE);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichTextBlockOverflowStatics3> { define_guid(0xD1D4A705, 0xEB0B, 0x4ECB, 0xB9, 0xB7, 0xE6, 0x5D, 0x3, 0x8, 0x7C, 0x8E);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBlock> { define_guid(0xAE2D9271, 0x3B4A, 0x45FC, 0x84, 0x68, 0xF7, 0x94, 0x95, 0x48, 0xF4, 0xD5);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBlockStatics> { define_guid(0x193EC042, 0xA847, 0x4552, 0xB4, 0xE8, 0xDB, 0x36, 0x65, 0x5B, 0x84, 0xA);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBlock2> { define_guid(0x45206A4C, 0xA4E, 0x4FBF, 0xAE, 0xE9, 0x33, 0x5D, 0x5A, 0x20, 0x5F, 0x6E);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBlockStatics2> { define_guid(0x88100B1B, 0xFF24, 0x4B93, 0xA0, 0xE6, 0xF0, 0x29, 0xC9, 0x48, 0x71, 0xF1);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBlock3> { define_guid(0xB651DD5A, 0x424B, 0x48C3, 0x9B, 0x67, 0x48, 0x6F, 0x4E, 0x13, 0x98, 0x99);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBlockStatics3> { define_guid(0x8D16B9EB, 0x20A1, 0x4EAB, 0xBB, 0xF2, 0x1D, 0x6B, 0xDC, 0xBC, 0xD7, 0x5);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBlock4> { define_guid(0xB014F270, 0x9808, 0x4ADC, 0xB4, 0x52, 0x60, 0xCD, 0xA5, 0x41, 0x0, 0xC1);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBlock5> { define_guid(0x624A2D38, 0xEDBD, 0x4A5A, 0xB6, 0x78, 0xE4, 0x9F, 0x1E, 0x7, 0xAF, 0xBD);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBlockStatics5> { define_guid(0x8E4D9C70, 0xD4E, 0x48DF, 0xAE, 0x7F, 0xBB, 0x7A, 0x9A, 0xF6, 0x85, 0x2E);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBlock6> { define_guid(0x31816CD9, 0x404, 0x410F, 0x91, 0xEC, 0x33, 0xB0, 0xA0, 0xBB, 0x92, 0xB2);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBlockStatics6> { define_guid(0x3D1013A9, 0xF9A6, 0x43A2, 0x99, 0xD3, 0x57, 0x3B, 0x89, 0xA8, 0x3C, 0xA3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IViewbox> { define_guid(0x5252C58, 0xBA9D, 0x4809, 0x9E, 0xC3, 0xFA, 0xD, 0x16, 0x71, 0xB, 0xA1);};
template<> struct uuid<Windows::UI::Xaml::Controls::IViewboxStatics> { define_guid(0x5CD1E72D, 0xE8D3, 0x4865, 0x8F, 0x8, 0xB6, 0xB2, 0xD6, 0x89, 0xAD, 0xF1);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGrid> { define_guid(0xFD104460, 0x2E15, 0x4BA3, 0x8B, 0x8F, 0xFA, 0x69, 0x3A, 0x41, 0x61, 0xE9);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGridStatics> { define_guid(0x64FE2E9F, 0xF951, 0x42B6, 0xA9, 0xCE, 0xBB, 0x17, 0x9A, 0xF1, 0x15, 0x95);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGridFactory> { define_guid(0xAE814041, 0xC531, 0x43B4, 0xBF, 0x99, 0x12, 0xF5, 0x6, 0xF7, 0xB0, 0x1C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGrid2> { define_guid(0xF76EFA41, 0x380E, 0x45DB, 0xBE, 0x87, 0x9E, 0x13, 0x26, 0xBA, 0x4B, 0x57);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGridStatics2> { define_guid(0x2D666658, 0x58B6, 0x4A1B, 0x84, 0x1B, 0x87, 0x5B, 0xA9, 0x3B, 0x5D, 0x6A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGrid3> { define_guid(0x12DFC5FC, 0x2342, 0x4DD2, 0x9E, 0x7D, 0x20, 0x90, 0xA1, 0x71, 0xD1, 0xEF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGridStatics3> { define_guid(0xC3FBA437, 0x5A0C, 0x407A, 0x96, 0x21, 0x79, 0x54, 0x53, 0x86, 0xD8, 0x11);};
template<> struct uuid<Windows::UI::Xaml::Controls::IHandwritingView> { define_guid(0xC44204A7, 0x31E0, 0x44BC, 0xA3, 0x8B, 0x4B, 0xEE, 0x64, 0xEC, 0xD9, 0x9F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IHandwritingViewStatics> { define_guid(0xBB7CEED0, 0xCC5F, 0x4004, 0xB8, 0xC8, 0x14, 0x2E, 0x19, 0x5F, 0x6, 0x18);};
template<> struct uuid<Windows::UI::Xaml::Controls::IHandwritingViewFactory> { define_guid(0xE00C873F, 0x12, 0x475C, 0x89, 0xC, 0x97, 0xAE, 0x30, 0x86, 0x42, 0xDE);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaTransportControls> { define_guid(0xD6F69E7D, 0x825, 0x49A9, 0x9F, 0xCE, 0x55, 0x86, 0xD8, 0x69, 0x4F, 0xC);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaTransportControlsStatics> { define_guid(0x590EA907, 0xD2EF, 0x4C1A, 0x94, 0x29, 0xB4, 0xB1, 0x5D, 0x64, 0xFD, 0x56);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaTransportControlsFactory> { define_guid(0x1DA2015A, 0xA8E4, 0x4C1B, 0x88, 0xC9, 0xB, 0x18, 0x3E, 0xCC, 0x62, 0xE3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaTransportControls2> { define_guid(0x2B89EFEC, 0x1BEA, 0x451E, 0x8B, 0xCD, 0xCF, 0xE2, 0xD9, 0x42, 0x32, 0x62);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaTransportControlsStatics2> { define_guid(0x1728CFDC, 0x561F, 0x4386, 0xA7, 0xF8, 0x9, 0xD, 0x95, 0xF6, 0x8D, 0x96);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaTransportControls3> { define_guid(0x5086430E, 0x940, 0x11E7, 0x93, 0xAE, 0x92, 0x36, 0x1F, 0x0, 0x26, 0x71);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaTransportControlsStatics3> { define_guid(0x5FE05542, 0x940, 0x11E7, 0x93, 0xAE, 0x92, 0x36, 0x1F, 0x0, 0x26, 0x71);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaTransportControls4> { define_guid(0xFB17C58, 0x9F23, 0x11E7, 0xAB, 0xC4, 0xCE, 0xC2, 0x78, 0xB6, 0xB5, 0xA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaTransportControlsStatics4> { define_guid(0xFB18144, 0x9F23, 0x11E7, 0xAB, 0xC4, 0xCE, 0xC2, 0x78, 0xB6, 0xB5, 0xA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPasswordBox> { define_guid(0x2B9AA11, 0xB47, 0x4E7D, 0xAD, 0x91, 0x3A, 0x41, 0x68, 0xED, 0x23, 0xD);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPasswordBoxStatics> { define_guid(0x5EE67563, 0x2D74, 0x4ACE, 0xBD, 0x79, 0xFC, 0xAB, 0x61, 0xA7, 0xD7, 0x7B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPasswordBox2> { define_guid(0x5ED738DF, 0x212F, 0x4AEB, 0xB5, 0xB8, 0x2C, 0x21, 0x9A, 0xEC, 0x3C, 0xC);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPasswordBoxStatics2> { define_guid(0xFC57935F, 0x98FA, 0x4066, 0xB7, 0x85, 0xFA, 0x72, 0x5E, 0xCD, 0xE2, 0x32);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPasswordBox3> { define_guid(0x6024D9D1, 0x56B7, 0x41F0, 0x95, 0x58, 0x39, 0x34, 0xC1, 0x42, 0x44, 0xD6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPasswordBoxStatics3> { define_guid(0xA2CDD319, 0xAD6A, 0x4352, 0xB5, 0x90, 0xF6, 0x96, 0xFF, 0xCB, 0x8E, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPasswordBox4> { define_guid(0x569F4343, 0x8E6C, 0x44BF, 0x80, 0x8D, 0xE, 0x3, 0x96, 0x4E, 0xD3, 0x2F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IProgressRing> { define_guid(0x6DA5E49E, 0x6E9D, 0x425C, 0xBD, 0x7C, 0x2, 0x17, 0x3E, 0x39, 0x76, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IProgressRingStatics> { define_guid(0xE8B62507, 0x4E2C, 0x47D5, 0xA5, 0x4A, 0xC6, 0xC4, 0x8A, 0x5E, 0x69, 0x89);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRelativePanel> { define_guid(0x2EABFAEB, 0xB35A, 0x4035, 0xAC, 0xEA, 0x3C, 0x4A, 0x37, 0x30, 0x68, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRelativePanelStatics> { define_guid(0x15903C27, 0xF18C, 0x4C35, 0x8E, 0x19, 0x6A, 0x74, 0x59, 0xD9, 0x7, 0xB6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRelativePanelFactory> { define_guid(0x8460193C, 0x361B, 0x44BA, 0xA1, 0x7E, 0xB8, 0x4C, 0x9D, 0xCD, 0xC7, 0x72);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISemanticZoom> { define_guid(0x19FFF21, 0xECE6, 0x4FBC, 0xBF, 0x40, 0x89, 0x38, 0xD4, 0x81, 0x3E, 0x27);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISemanticZoomStatics> { define_guid(0x8EF17EF2, 0x9898, 0x4666, 0xB2, 0x85, 0x3E, 0xD3, 0x8A, 0x7, 0x91, 0xE);};
template<> struct uuid<Windows::UI::Xaml::Controls::IStackPanel> { define_guid(0xB8AE8FE2, 0xD641, 0x4FD7, 0x80, 0xB4, 0x74, 0x39, 0x20, 0x7D, 0x27, 0x98);};
template<> struct uuid<Windows::UI::Xaml::Controls::IStackPanelStatics> { define_guid(0xF0D0CD93, 0x4DBC, 0x48A7, 0x99, 0x14, 0x95, 0x49, 0x24, 0x65, 0x77, 0x71);};
template<> struct uuid<Windows::UI::Xaml::Controls::IStackPanelFactory> { define_guid(0x63D8248A, 0x8B34, 0x445A, 0x80, 0x8F, 0xB6, 0xEC, 0xD6, 0x2A, 0x27, 0xD9);};
template<> struct uuid<Windows::UI::Xaml::Controls::IStackPanel2> { define_guid(0x36F23359, 0x40E, 0x48F7, 0x9A, 0x98, 0xF2, 0x66, 0x45, 0x91, 0x95, 0x9C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IStackPanelStatics2> { define_guid(0xD97E6257, 0x80D, 0x412E, 0xA9, 0x1A, 0xCE, 0x6E, 0x5D, 0x2, 0xAA, 0xD3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IStackPanel4> { define_guid(0x43EBF7F6, 0x3196, 0x412E, 0x8A, 0x95, 0xAD, 0xD0, 0x2, 0xFF, 0x43, 0xF0);};
template<> struct uuid<Windows::UI::Xaml::Controls::IStackPanelStatics4> { define_guid(0x279CDD71, 0x67B, 0x459F, 0x81, 0x5F, 0xEC, 0xD8, 0x5C, 0x5E, 0x48, 0x43);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBox> { define_guid(0xE48F5A8B, 0x1DFF, 0x4352, 0xA1, 0xF4, 0xE5, 0x16, 0x51, 0x4E, 0xC8, 0x82);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBoxStatics> { define_guid(0x7E37F4FB, 0xA4BC, 0x4625, 0x88, 0x38, 0x8E, 0xB2, 0xA9, 0x9, 0x12, 0x83);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBoxFactory> { define_guid(0x710E4278, 0x8529, 0x47D3, 0x8D, 0x8E, 0x30, 0x7E, 0x34, 0xCF, 0xF0, 0x81);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBox2> { define_guid(0xF7168C00, 0x1432, 0x462A, 0x94, 0x5, 0x38, 0xF3, 0x85, 0xBF, 0xC3, 0x7C);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBoxStatics2> { define_guid(0x7592F37D, 0x4E76, 0x4EE4, 0x8E, 0xF, 0x7D, 0x6E, 0x1A, 0x23, 0x32, 0x6B);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBox3> { define_guid(0x7DF18C3C, 0x2826, 0x425E, 0x9A, 0x94, 0x0, 0xB7, 0xF7, 0x3F, 0x37, 0x56);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBoxStatics3> { define_guid(0xE1005C0, 0x10B5, 0x40F6, 0x92, 0xC2, 0xCE, 0x13, 0x4B, 0xD, 0x34, 0x57);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBox4> { define_guid(0xB5F1A675, 0xCCE1, 0x45AF, 0xAE, 0xF9, 0xC4, 0x78, 0x7B, 0xBB, 0x5E, 0x30);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBox5> { define_guid(0x35F9CFC1, 0x4176, 0x44F4, 0xB7, 0x56, 0xE9, 0xCC, 0xC4, 0x39, 0x98, 0x5);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBoxStatics5> { define_guid(0x7D04B45, 0x1B2F, 0x4627, 0x82, 0xFD, 0x68, 0x3F, 0x19, 0x7E, 0x5A, 0x75);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBox6> { define_guid(0x41FF2D07, 0x5085, 0x4E52, 0xA5, 0x1C, 0xF9, 0x4B, 0x6, 0xCD, 0x55, 0x8B);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBoxStatics6> { define_guid(0xDC0D97E7, 0x1CB7, 0x433E, 0xAA, 0x4F, 0x9C, 0x64, 0xC9, 0x8C, 0xDE, 0xE5);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBox7> { define_guid(0xDA4911F9, 0xFFE1, 0x4C6A, 0xAC, 0x6D, 0x1B, 0x4A, 0x17, 0x4C, 0xCF, 0x80);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITextBoxStatics7> { define_guid(0xCD6C6F47, 0x147E, 0x46F8, 0xA4, 0xE8, 0x74, 0x9C, 0x49, 0x84, 0x7A, 0x3E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IToggleSwitch> { define_guid(0x331D8F00, 0xC5F9, 0x46A5, 0xB6, 0xC8, 0xED, 0xE5, 0x39, 0x30, 0x45, 0x67);};
template<> struct uuid<Windows::UI::Xaml::Controls::IToggleSwitchOverrides> { define_guid(0xBFD07F53, 0xF8CA, 0x4E47, 0x94, 0x9E, 0x9E, 0x80, 0x42, 0x9B, 0x3D, 0x16);};
template<> struct uuid<Windows::UI::Xaml::Controls::IToggleSwitchStatics> { define_guid(0x1D37147F, 0x97DF, 0x4226, 0x92, 0xCA, 0xDD, 0xF4, 0x53, 0xD7, 0xFD, 0x5A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IUserControl> { define_guid(0xA7A69EC9, 0xEA35, 0x4679, 0xBF, 0x29, 0xF4, 0xF0, 0x92, 0x86, 0xD3, 0x14);};
template<> struct uuid<Windows::UI::Xaml::Controls::IUserControlStatics> { define_guid(0xE8887976, 0x2C5C, 0x41CF, 0xBE, 0x6A, 0x9E, 0x44, 0xBE, 0xFD, 0xF6, 0x55);};
template<> struct uuid<Windows::UI::Xaml::Controls::IUserControlFactory> { define_guid(0x38B1ED92, 0xA28A, 0x4972, 0x93, 0xDF, 0xF4, 0xF7, 0x59, 0xB8, 0xAF, 0xD2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IVariableSizedWrapGrid> { define_guid(0x9CA507C7, 0x23C9, 0x4F01, 0xB8, 0xF, 0xBE, 0x5C, 0x21, 0xEE, 0xF4, 0x74);};
template<> struct uuid<Windows::UI::Xaml::Controls::IVariableSizedWrapGridStatics> { define_guid(0xFE9DB859, 0x8127, 0x4AEF, 0xB7, 0xA2, 0x94, 0x98, 0x47, 0x48, 0x6E, 0x96);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGroupItem> { define_guid(0x4AE8D5D1, 0x7228, 0x4A16, 0xA6, 0x1F, 0x88, 0xC0, 0xE8, 0xF4, 0x5C, 0x76);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGroupItemFactory> { define_guid(0xD9A1D53E, 0xB1E0, 0x4319, 0x98, 0x8, 0x7A, 0x9E, 0x88, 0x7E, 0x13, 0xB0);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewBaseHeaderItem> { define_guid(0x6D0DED27, 0xD19, 0x4091, 0x89, 0x17, 0xCE, 0x7C, 0x85, 0xC1, 0xE6, 0x30);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewBaseHeaderItemFactory> { define_guid(0x3872A6A1, 0xEA19, 0x455F, 0x9D, 0xF7, 0x14, 0x7C, 0xC4, 0x1D, 0x32, 0x9C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IProgressBar> { define_guid(0xAE752C89, 0x67, 0x4963, 0xBF, 0x4C, 0x29, 0xDB, 0xC, 0x4A, 0x50, 0x7E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IProgressBarStatics> { define_guid(0x7A129FDA, 0x5837, 0x4E26, 0xB3, 0xB4, 0xE1, 0xC0, 0x92, 0xCE, 0xBB, 0xEC);};
template<> struct uuid<Windows::UI::Xaml::Controls::IProgressBarFactory> { define_guid(0xDA9A8C11, 0x1591, 0x400B, 0xA9, 0x93, 0xF, 0x1C, 0x5C, 0xC1, 0x2F, 0x3B);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISettingsFlyout> { define_guid(0x830BA82B, 0xC55B, 0x4E32, 0xA5, 0x1C, 0x57, 0x91, 0xE0, 0x24, 0xC8, 0xAF);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISettingsFlyoutStatics> { define_guid(0xD0E3B535, 0x9157, 0x4BE4, 0xA4, 0x2A, 0xF5, 0x91, 0x69, 0x88, 0x46, 0xAC);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISettingsFlyoutFactory> { define_guid(0x480C7011, 0x57AA, 0x4DB6, 0xB6, 0xFD, 0xEC, 0x67, 0x6F, 0x6D, 0x41, 0x4E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IToolTip> { define_guid(0x7DE5D75F, 0x4415, 0x429F, 0xB5, 0x23, 0x69, 0x9B, 0xDB, 0x8C, 0x30, 0xDB);};
template<> struct uuid<Windows::UI::Xaml::Controls::IToolTipStatics> { define_guid(0xF00285B8, 0x4BA9, 0x4F4F, 0x86, 0xA7, 0x86, 0x0, 0x38, 0x13, 0xCE, 0xB3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IToolTipFactory> { define_guid(0x89839403, 0xB538, 0x49E3, 0xA4, 0x30, 0x3A, 0xC0, 0x37, 0xDC, 0x6F, 0xE0);};
template<> struct uuid<Windows::UI::Xaml::Controls::IButton> { define_guid(0x280335AE, 0x5570, 0x46C7, 0x8E, 0xB, 0x60, 0x2B, 0xE7, 0x12, 0x29, 0xA2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IButtonFactory> { define_guid(0x80A13C19, 0x843A, 0x451C, 0x8C, 0xF5, 0x44, 0xC7, 0x1, 0xB0, 0xE2, 0x16);};
template<> struct uuid<Windows::UI::Xaml::Controls::IButtonWithFlyout> { define_guid(0x9108F87, 0xDF6C, 0x4180, 0x9B, 0x3A, 0xE6, 0x8, 0x45, 0x82, 0x58, 0x11);};
template<> struct uuid<Windows::UI::Xaml::Controls::IButtonStaticsWithFlyout> { define_guid(0x90143898, 0xA16C, 0x4759, 0xB2, 0xF0, 0xA5, 0xF7, 0xE6, 0x25, 0x16, 0x9E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IComboBox> { define_guid(0xB9A8D05C, 0xAC97, 0x47F1, 0xA5, 0xF4, 0x3F, 0x9F, 0x4D, 0x4B, 0x11, 0x6C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IComboBoxOverrides> { define_guid(0x4F016541, 0xBCFE, 0x4A22, 0x89, 0x32, 0xC9, 0x14, 0x98, 0x1C, 0x22, 0x40);};
template<> struct uuid<Windows::UI::Xaml::Controls::IComboBoxStatics> { define_guid(0x3E14C9B1, 0xD15B, 0x4DC9, 0x81, 0x10, 0xCF, 0x3A, 0x11, 0x7B, 0x96, 0xE7);};
template<> struct uuid<Windows::UI::Xaml::Controls::IComboBoxFactory> { define_guid(0xAC0D0444, 0xA65B, 0x4ABD, 0x86, 0xDF, 0x30, 0x16, 0x4, 0x9E, 0xFE, 0xDC);};
template<> struct uuid<Windows::UI::Xaml::Controls::IComboBox2> { define_guid(0xEA0CBF91, 0xCA36, 0x4FAD, 0x97, 0x2A, 0x2E, 0x53, 0xA6, 0x71, 0x8B, 0x9F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IComboBoxStatics2> { define_guid(0x93988A11, 0x402C, 0x4B13, 0x96, 0xD1, 0x72, 0x20, 0x26, 0x6B, 0x92, 0x20);};
template<> struct uuid<Windows::UI::Xaml::Controls::IComboBox3> { define_guid(0x52400A63, 0x476C, 0x4BB6, 0xB7, 0x81, 0x1, 0x93, 0x24, 0xD3, 0xFE, 0xD9);};
template<> struct uuid<Windows::UI::Xaml::Controls::IComboBoxStatics3> { define_guid(0x949E140F, 0xCE7F, 0x4E41, 0xBD, 0xC5, 0xD1, 0xD3, 0x38, 0x8A, 0xD0, 0xA6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IComboBox4> { define_guid(0xB7974F49, 0xB05C, 0x47F9, 0x9A, 0xAF, 0xD6, 0xF9, 0x18, 0x7B, 0xE5, 0xFD);};
template<> struct uuid<Windows::UI::Xaml::Controls::IComboBoxStatics4> { define_guid(0xD9F58358, 0xF7B0, 0x46CE, 0x80, 0x61, 0xAD, 0x83, 0xEC, 0x2F, 0x2D, 0xD4);};
template<> struct uuid<Windows::UI::Xaml::Controls::IComboBox5> { define_guid(0xAB79D646, 0x800A, 0x4A28, 0x96, 0x9B, 0x34, 0xBB, 0x8F, 0xB4, 0x58, 0xCF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IComboBoxStatics5> { define_guid(0xB802CEF1, 0xA264, 0x444A, 0x9A, 0x61, 0xAA, 0x88, 0x67, 0xB7, 0xA6, 0x3C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IComboBoxItem> { define_guid(0x993FD6D2, 0x2AAE, 0x4F3B, 0xB4, 0x4D, 0x56, 0x48, 0xF4, 0xD0, 0x61, 0x14);};
template<> struct uuid<Windows::UI::Xaml::Controls::IComboBoxItemFactory> { define_guid(0x8FFFE867, 0xD94C, 0x4E87, 0x8F, 0xC4, 0x6E, 0xBC, 0xD6, 0x3C, 0x5A, 0xC2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFlipView> { define_guid(0xA1582F68, 0x3D7D, 0x4D3B, 0xB7, 0x1D, 0x48, 0x8E, 0xED, 0x1E, 0x34, 0x93);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFlipViewFactory> { define_guid(0xF1DEA9BE, 0x9AE8, 0x4D4B, 0xAB, 0x43, 0x16, 0xD3, 0x1E, 0x5, 0xF4, 0xF3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFlipView2> { define_guid(0xC4FEA4FD, 0x7AF3, 0x4952, 0x9F, 0xD9, 0x9E, 0x9, 0x87, 0xFC, 0x4F, 0x29);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFlipViewStatics2> { define_guid(0x70E3D93F, 0x4308, 0x4BA2, 0xBB, 0xCE, 0xE2, 0xCB, 0xE, 0xD3, 0x44, 0x76);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFlipViewItem> { define_guid(0x56196565, 0xCE2B, 0x4BDA, 0xA3, 0x6B, 0x82, 0xA2, 0xB8, 0xB0, 0xD4, 0xC0);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFlipViewItemFactory> { define_guid(0xF21D91FE, 0x22A0, 0x4412, 0xA8, 0x53, 0x9D, 0x6A, 0x6E, 0x8F, 0x2A, 0xAF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IHyperlinkButton> { define_guid(0xCCEBACA3, 0x3B5C, 0x4F4C, 0x9B, 0xFD, 0x86, 0x88, 0x7B, 0xC7, 0x97, 0x72);};
template<> struct uuid<Windows::UI::Xaml::Controls::IHyperlinkButtonStatics> { define_guid(0xFBAEB5C7, 0xCDB7, 0x4263, 0xB7, 0xD6, 0x3C, 0xD, 0x29, 0x4, 0xED, 0x98);};
template<> struct uuid<Windows::UI::Xaml::Controls::IHyperlinkButtonFactory> { define_guid(0x43521BAD, 0x4E97, 0x4DA9, 0xA6, 0x4D, 0x93, 0x5D, 0xFD, 0x8C, 0xED, 0xF2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListBox> { define_guid(0xE9F3B9FF, 0x8E91, 0x4ECF, 0xA7, 0x7, 0xC9, 0x27, 0xF6, 0x94, 0xF8, 0x81);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListBoxStatics> { define_guid(0x6D3F7F73, 0x706A, 0x4E53, 0xA9, 0xAA, 0xC9, 0xA5, 0x3C, 0x9C, 0xDD, 0x70);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListBoxFactory> { define_guid(0x60CDFDA2, 0x2F44, 0x444B, 0x9C, 0x94, 0xB8, 0xC9, 0xFD, 0xA4, 0x6F, 0x59);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListBox2> { define_guid(0x70572ABA, 0x8AD1, 0x4085, 0x93, 0x50, 0xDE, 0xEE, 0x35, 0x92, 0x94, 0xE3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListBoxStatics2> { define_guid(0x89ADEB, 0xB709, 0x4C8D, 0xB1, 0xED, 0x4A, 0x7D, 0x97, 0xEE, 0x77, 0x16);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListBoxItem> { define_guid(0x43C13323, 0x6EDF, 0x4E4B, 0xB6, 0xB2, 0x3A, 0x93, 0xEE, 0xC4, 0x1D, 0x95);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListBoxItemFactory> { define_guid(0x4398B8D4, 0xA3DE, 0x402C, 0xB2, 0x3D, 0x19, 0x3, 0x84, 0xB2, 0x7C, 0xA8);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewBase> { define_guid(0x3D0813BA, 0x6890, 0x4537, 0xBF, 0xE5, 0x79, 0x6D, 0x94, 0x58, 0xED, 0xD6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewBaseStatics> { define_guid(0x8532B8F7, 0x3E16, 0x455B, 0x89, 0xA8, 0xC1, 0x34, 0x62, 0x23, 0xF6, 0xD3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewBaseFactory> { define_guid(0xE67E6C7F, 0x150F, 0x46D0, 0xA6, 0xAC, 0xC5, 0x0, 0x2B, 0xD9, 0xCA, 0x53);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewBase2> { define_guid(0xD1C2A4F7, 0x78A3, 0x4491, 0x86, 0xE0, 0x2D, 0xDE, 0xBC, 0x0, 0x7A, 0xC5);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewBaseStatics2> { define_guid(0x821C00C8, 0x78CC, 0x411F, 0x9F, 0x2E, 0xA5, 0x57, 0x58, 0x22, 0x7F, 0x3E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewBase3> { define_guid(0xB364C035, 0xA13, 0x406F, 0xA3, 0xFB, 0xF3, 0xE, 0x7D, 0xDC, 0xA9, 0x4C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewBaseStatics3> { define_guid(0x3B539091, 0x31C6, 0x4D0C, 0x90, 0xAF, 0x5D, 0xC1, 0xD6, 0xAE, 0x9C, 0x5);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewBase4> { define_guid(0x18B7792B, 0x11DC, 0x4EB6, 0xA7, 0xBC, 0x74, 0x1A, 0xDB, 0x3E, 0xEB, 0x79);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewBaseStatics4> { define_guid(0xAD13258B, 0xFBD0, 0x4F18, 0x8B, 0xF8, 0x9B, 0x86, 0x13, 0x95, 0x1C, 0x22);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewBase5> { define_guid(0x1A9C6E99, 0x1719, 0x4B80, 0xB3, 0x35, 0x62, 0x83, 0x31, 0xA0, 0x70, 0x19);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewBaseStatics5> { define_guid(0x40346FCF, 0x476, 0x4259, 0x89, 0x5F, 0xA6, 0x56, 0x97, 0x38, 0x62, 0xF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewBase6> { define_guid(0xF8A42637, 0x965B, 0x483B, 0x94, 0xE5, 0xE5, 0xC9, 0xFE, 0xF0, 0xE3, 0x52);};
template<> struct uuid<Windows::UI::Xaml::Controls::IVirtualizingStackPanel> { define_guid(0x7567CD9A, 0xA3B4, 0x4DEA, 0xBB, 0x11, 0x54, 0x9E, 0x2C, 0x2F, 0x91, 0x9D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IVirtualizingStackPanelOverrides> { define_guid(0xCBE6F72C, 0x2892, 0x46D1, 0x98, 0x7F, 0x58, 0xCA, 0x10, 0x81, 0xF0, 0x40);};
template<> struct uuid<Windows::UI::Xaml::Controls::IVirtualizingStackPanelStatics> { define_guid(0x8314E778, 0x91D3, 0x4D56, 0xAC, 0x9, 0x22, 0x3A, 0xDC, 0xD2, 0xBD, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICheckBox> { define_guid(0x2294C894, 0x7E2A, 0x4B70, 0xB0, 0x88, 0x8F, 0x5D, 0x81, 0x48, 0x75, 0xBA);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICheckBoxFactory> { define_guid(0x4FA6AABB, 0x3F4B, 0x4301, 0xBE, 0x7, 0x11, 0x72, 0xEA, 0x61, 0xEE, 0xFB);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRadioButton> { define_guid(0x325C44E0, 0x9A03, 0x4BF3, 0xAB, 0xD6, 0x6F, 0xBB, 0x46, 0xC9, 0xA4, 0x86);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRadioButtonStatics> { define_guid(0x6B149293, 0xF50F, 0x4BD8, 0xB0, 0xAC, 0x5C, 0x16, 0x2F, 0x33, 0xA2, 0x8);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRadioButtonFactory> { define_guid(0xF1D04933, 0x34E1, 0x4A5C, 0xB2, 0xAE, 0xCA, 0x3B, 0x1C, 0xB, 0x20, 0xDE);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDataTemplateSelectorOverrides2> { define_guid(0x6C3FB5FC, 0x8E84, 0x4C91, 0xAC, 0x15, 0x4, 0xA1, 0xD8, 0x85, 0x50, 0xF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDataTemplateSelector2> { define_guid(0x3792BC47, 0x8C4B, 0x4257, 0xA5, 0xAE, 0xCC, 0x3F, 0x8E, 0xD7, 0x86, 0xEB);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDataTemplateSelectorFactory> { define_guid(0x511BAAD0, 0x210A, 0x457D, 0x95, 0x21, 0x43, 0x3D, 0x2B, 0x11, 0xB7, 0xD2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDataTemplateSelectorOverrides> { define_guid(0x2D162925, 0x5966, 0x4BFA, 0x86, 0x38, 0x4D, 0x34, 0x56, 0x89, 0xF6, 0xCF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDataTemplateSelector> { define_guid(0xA907D496, 0x46A0, 0x4CD7, 0x8D, 0xBE, 0xF9, 0xA5, 0x81, 0xDF, 0x60, 0xB1);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContainerContentChangingEventArgs> { define_guid(0x7DEEAA7, 0x18F, 0x4DDA, 0xB3, 0x99, 0xFD, 0x4E, 0x13, 0xA3, 0x1B, 0xEA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IChoosingItemContainerEventArgs> { define_guid(0x9BB43BCE, 0xAE67, 0x4A80, 0x83, 0x63, 0xE3, 0xFE, 0x1B, 0x24, 0x4F, 0x2C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IChoosingGroupHeaderContainerEventArgs> { define_guid(0x67DB44D6, 0xD201, 0x4D72, 0xBE, 0xAC, 0x5E, 0x8E, 0x58, 0xAF, 0xD8, 0xC7);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICandidateWindowBoundsChangedEventArgs> { define_guid(0x8A946458, 0x83B0, 0x4C32, 0x94, 0x50, 0x51, 0x69, 0xA5, 0x83, 0x8B, 0x55);};
template<> struct uuid<Windows::UI::Xaml::Controls::IBackClickEventArgs> { define_guid(0x2AE6146C, 0x477E, 0x48C9, 0x88, 0x30, 0x2C, 0x46, 0x4B, 0x7C, 0x71, 0x4);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISemanticZoomInformation> { define_guid(0xA76A3B63, 0x229B, 0x4DC5, 0xAA, 0x11, 0x9D, 0x92, 0x2F, 0xBF, 0x8A, 0x98);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigate> { define_guid(0xBF2195A9, 0xF4EA, 0x4336, 0x97, 0x7C, 0xF8, 0xFC, 0xF7, 0x8B, 0xD, 0x9E);};
template<> struct uuid<Windows::UI::Xaml::Controls::TextControlPasteEventHandler> { define_guid(0xD56DB359, 0x6F77, 0x4296, 0xAB, 0x9C, 0x79, 0x49, 0x39, 0x44, 0x43, 0x65);};
template<> struct uuid<Windows::UI::Xaml::Controls::TextChangedEventHandler> { define_guid(0x8EB35B97, 0xAD87, 0x40E8, 0x81, 0x8B, 0x77, 0xDB, 0x24, 0x75, 0x95, 0x66);};
template<> struct uuid<Windows::UI::Xaml::Controls::SemanticZoomViewChangedEventHandler> { define_guid(0x1FA9161D, 0x5D73, 0x44FB, 0x81, 0xAC, 0xD1, 0xC9, 0x38, 0x49, 0x19, 0xD4);};
template<> struct uuid<Windows::UI::Xaml::Controls::SelectionChangedEventHandler> { define_guid(0xE1A05352, 0x5AA0, 0x42CA, 0x9C, 0xD9, 0x6, 0x8A, 0x14, 0xDB, 0x6E, 0x68);};
template<> struct uuid<Windows::UI::Xaml::Controls::NotifyEventHandler> { define_guid(0xC2FDD1F8, 0x7105, 0x4A74, 0xA1, 0x9, 0xDE, 0x29, 0xDF, 0xF5, 0x6B, 0x98);};
template<> struct uuid<Windows::UI::Xaml::Controls::ItemClickEventHandler> { define_guid(0x3DF6D14E, 0xE18A, 0x4A75, 0x93, 0x95, 0x62, 0x7C, 0x5F, 0x3C, 0xD4, 0x89);};
template<> struct uuid<Windows::UI::Xaml::Controls::DragItemsStartingEventHandler> { define_guid(0x3AAEAB4C, 0x14CB, 0x4434, 0xBE, 0xCC, 0x88, 0xA8, 0x58, 0x5C, 0x2F, 0x89);};
template<> struct uuid<Windows::UI::Xaml::Controls::ContextMenuOpeningEventHandler> { define_guid(0xDF945151, 0x745C, 0x4446, 0xB2, 0xFC, 0x21, 0x6D, 0x76, 0x58, 0x47, 0xA0);};
template<> struct uuid<Windows::UI::Xaml::Controls::CleanUpVirtualizedItemEventHandler> { define_guid(0xCACAD0D6, 0xF0D, 0x4870, 0x88, 0x4D, 0xF2, 0xDE, 0xDF, 0x67, 0x42, 0x88);};
template<> struct uuid<Windows::UI::Xaml::Controls::BackClickEventHandler> { define_guid(0xFA9BC21F, 0x9892, 0x482E, 0xAB, 0xF6, 0xEB, 0x2D, 0x60, 0x7D, 0x32, 0xDE);};
template<> struct uuid<Windows::UI::Xaml::Controls::CalendarViewDayItemChangingEventHandler> { define_guid(0x8D745891, 0x4DE3, 0x49CB, 0x97, 0x4B, 0x8, 0x38, 0x71, 0xA3, 0xAF, 0xE6);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICalendarViewDayItemChangingEventArgs> { define_guid(0x73146666, 0x1FB1, 0x44F9, 0xB7, 0xAD, 0x4D, 0xE8, 0x59, 0xEC, 0xC5, 0x65);};
template<> struct uuid<Windows::UI::Xaml::Controls::HubSectionHeaderClickEventHandler> { define_guid(0xAFE17B9B, 0x9C63, 0x4583, 0x88, 0xE4, 0xC5, 0x90, 0x19, 0xB7, 0xF4, 0x9D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IHubSectionHeaderClickEventArgs> { define_guid(0xE1C5EF04, 0x1EDD, 0x4112, 0xAE, 0xEB, 0x99, 0x6C, 0x96, 0x40, 0x6, 0x98);};
template<> struct uuid<Windows::UI::Xaml::Controls::ListViewItemToKeyHandler> { define_guid(0x6AF5DA76, 0x7E8B, 0x4A91, 0x9A, 0x56, 0x46, 0xC, 0xB4, 0x7D, 0x52, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::Controls::ListViewKeyToItemHandler> { define_guid(0x26FD5855, 0xB530, 0x4688, 0xB9, 0xF0, 0x42, 0x82, 0x49, 0x17, 0x8E, 0xF8);};
template<> struct uuid<Windows::UI::Xaml::Controls::SectionsInViewChangedEventHandler> { define_guid(0x6BECAA6A, 0x63F8, 0x47FF, 0xB6, 0xAC, 0x76, 0xE7, 0xDA, 0x24, 0x7D, 0x67);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISectionsInViewChangedEventArgsFactory> { define_guid(0x557F5244, 0x92F8, 0x4150, 0xB7, 0x30, 0xE6, 0x34, 0x6E, 0x8F, 0x50, 0xD1);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISectionsInViewChangedEventArgs> { define_guid(0xDD49EE6B, 0xD165, 0x430F, 0xA3, 0x7D, 0xB8, 0x7, 0x6, 0x4F, 0x85, 0xE1);};
template<> struct uuid<Windows::UI::Xaml::Controls::WebViewNavigationFailedEventHandler> { define_guid(0xA31EAFE1, 0x41DC, 0x47F8, 0xAE, 0x22, 0x97, 0x6, 0xC8, 0xF1, 0x43, 0xD4);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewNavigationFailedEventArgs> { define_guid(0xAF09609A, 0x129C, 0x4170, 0x9E, 0x9C, 0xE2, 0xCD, 0xF0, 0x25, 0xDC, 0xA4);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICommandBarElement> { define_guid(0x67918E1B, 0xF2D5, 0x44D1, 0x8B, 0x84, 0x92, 0xB8, 0x7F, 0x80, 0xA3, 0x50);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICommandBarElement2> { define_guid(0xA9BF1236, 0x4402, 0x4688, 0xB9, 0x87, 0x9D, 0x2B, 0x9B, 0x7B, 0xF2, 0xBD);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICalendarDatePickerDateChangedEventArgs> { define_guid(0x60D90DB2, 0x5010, 0x46BA, 0x84, 0x2D, 0xA4, 0x15, 0x2C, 0x65, 0x4, 0xE7);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICalendarViewSelectedDatesChangedEventArgs> { define_guid(0xEE6069F6, 0x13EF, 0x4896, 0x8F, 0xFC, 0x53, 0x2, 0xB1, 0xB1, 0x75, 0x39);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentDialogButtonClickDeferral> { define_guid(0xBD0D3637, 0x19CE, 0x4946, 0x8E, 0x77, 0xBD, 0x3, 0xFE, 0x8E, 0xBE, 0x3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentDialogButtonClickEventArgs> { define_guid(0x5F34C205, 0x8AFA, 0x4CF2, 0x8C, 0xA0, 0x26, 0x4D, 0x73, 0xBE, 0xD6, 0x3D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentDialogClosedEventArgs> { define_guid(0x905522EF, 0x2CBA, 0x4AF8, 0xB6, 0x66, 0xCC, 0x36, 0xC2, 0x27, 0x32, 0xFB);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentDialogClosingDeferral> { define_guid(0x215D4D11, 0x7E30, 0x4CB9, 0xA7, 0x10, 0x5A, 0x4F, 0x9C, 0xCA, 0x8B, 0x42);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentDialogClosingEventArgs> { define_guid(0xDB3C1C34, 0x3BBF, 0x47D4, 0xBE, 0x4F, 0xC9, 0xEC, 0x11, 0x59, 0x18, 0xB9);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentDialogOpenedEventArgs> { define_guid(0x966B315, 0x5F59, 0x4999, 0x9E, 0x3E, 0x37, 0x4C, 0xF, 0x17, 0x4B, 0x4);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentLinkChangedEventArgs> { define_guid(0x64F3F1DE, 0x89FB, 0x4B77, 0x8B, 0x9B, 0x19, 0x1B, 0x6D, 0x19, 0x29, 0xA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDatePickerValueChangedEventArgs> { define_guid(0x1AE661B2, 0xB1B4, 0x4273, 0x96, 0xE0, 0x19, 0xDA, 0xFF, 0x18, 0x74, 0x46);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDynamicOverflowItemsChangingEventArgs> { define_guid(0xC93C736F, 0x6F6E, 0x4E43, 0x90, 0xD9, 0x9B, 0x46, 0xA0, 0xD8, 0x8B, 0x9F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IHubSectionFactory> { define_guid(0xFFF55FA2, 0xECE4, 0x4BBA, 0xAA, 0x3B, 0x98, 0x4, 0xAE, 0xF4, 0x78, 0x83);};
template<> struct uuid<Windows::UI::Xaml::Controls::IHubSectionStatics> { define_guid(0x12D2D85A, 0xEA27, 0x42D1, 0x99, 0x8B, 0x61, 0xE5, 0x2A, 0xED, 0x84, 0x2B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IHubSection> { define_guid(0xA4E66CB7, 0x7FDD, 0x4FE0, 0xAB, 0x49, 0xC2, 0x46, 0x63, 0x9D, 0xCC, 0xF9);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewPersistenceHelper> { define_guid(0x5BDE8A6, 0x2191, 0x4B4B, 0x8C, 0x22, 0x9B, 0x25, 0x67, 0x6E, 0x80, 0x6E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewPersistenceHelperStatics> { define_guid(0x6D0C2B08, 0xBB9B, 0x44F9, 0x80, 0x63, 0x5C, 0x3F, 0x9C, 0x21, 0x88, 0x4B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBoxTextChangingEventArgs> { define_guid(0x54065018, 0x2813, 0x4922, 0x9F, 0x8E, 0xB6, 0xBB, 0xAF, 0xD9, 0x95, 0xD8);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBoxTextChangingEventArgs2> { define_guid(0x395B0DB5, 0x636E, 0x413E, 0x9E, 0xB4, 0xFC, 0x22, 0xEB, 0xFA, 0x36, 0x28);};
template<> struct uuid<Windows::UI::Xaml::Controls::IScrollViewerView> { define_guid(0x64E9BE01, 0x4DC2, 0x493E, 0xAB, 0xE8, 0xCB, 0xD3, 0xC5, 0x77, 0x49, 0xE);};
template<> struct uuid<Windows::UI::Xaml::Controls::IScrollViewerViewChangedEventArgs> { define_guid(0x4DD04F7E, 0x7A11, 0x4B2E, 0x99, 0x33, 0x57, 0x7D, 0xF3, 0x92, 0x52, 0xB6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IScrollViewerViewChangingEventArgs> { define_guid(0x4DD04F7F, 0x7A11, 0x4B2E, 0x99, 0x33, 0x57, 0x7D, 0xF3, 0x92, 0x52, 0xB6);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISearchBoxQueryChangedEventArgs> { define_guid(0xA9A70F8F, 0xCB0, 0x4BD2, 0x99, 0x98, 0x2F, 0xB5, 0x7A, 0xD5, 0xE7, 0x31);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISearchBoxQuerySubmittedEventArgs> { define_guid(0x126E90FD, 0x3C4E, 0x4CCB, 0x9A, 0xEF, 0x47, 0x5, 0xD1, 0x9F, 0xE5, 0x48);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISearchBoxResultSuggestionChosenEventArgs> { define_guid(0x18918C23, 0xE4C3, 0x4662, 0xA0, 0x3B, 0xD0, 0x54, 0xFF, 0xD0, 0xF9, 0x5);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISearchBoxSuggestionsRequestedEventArgs> { define_guid(0xDA15170E, 0xE566, 0x48CB, 0xBD, 0x11, 0xFE, 0x4B, 0xF, 0x30, 0xA4, 0x4D);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISplitViewPaneClosingEventArgs> { define_guid(0x93CF494E, 0x7A95, 0x44D8, 0x95, 0x62, 0x1B, 0x34, 0x82, 0x48, 0xDA, 0x9F);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITimePickerValueChangedEventArgs> { define_guid(0x2F4EDB8D, 0xB995, 0x4E31, 0x8B, 0xA9, 0xC4, 0xDC, 0xDE, 0xB2, 0x1C, 0xA3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewContentLoadingEventArgs> { define_guid(0x6E2980BB, 0x98B8, 0x413E, 0x81, 0x29, 0x97, 0x1C, 0x6F, 0x7E, 0x4C, 0x8A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewDeferredPermissionRequest> { define_guid(0xA3DCC461, 0x7350, 0x4D3A, 0x8F, 0xB9, 0x40, 0xEE, 0xEC, 0x27, 0x46, 0xC2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewDOMContentLoadedEventArgs> { define_guid(0xC47EBA15, 0xDC6B, 0x4B36, 0x9D, 0x80, 0x82, 0xFB, 0x88, 0x17, 0xB9, 0x88);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewLongRunningScriptDetectedEventArgs> { define_guid(0xF3F020AB, 0xA46C, 0x42B0, 0x9E, 0xFE, 0x69, 0x76, 0x4D, 0x5C, 0xFF, 0xA6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewNavigationCompletedEventArgs> { define_guid(0x11E6F20B, 0xEBA7, 0x44C0, 0x88, 0x9B, 0xED, 0xEB, 0x6A, 0x6, 0x4D, 0xDD);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewNavigationStartingEventArgs> { define_guid(0x94CB8668, 0x8367, 0x43D5, 0x91, 0xBB, 0x96, 0xEB, 0xA3, 0x7E, 0xC7, 0x84);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewNewWindowRequestedEventArgs> { define_guid(0x470FA818, 0x6862, 0x44D9, 0xB3, 0xD1, 0xC0, 0x69, 0x63, 0x73, 0xDE, 0x35);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewPermissionRequest> { define_guid(0x17B76332, 0x66C4, 0x4131, 0x99, 0x9E, 0xDF, 0x7D, 0xE2, 0xA, 0x8C, 0x9C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewPermissionRequestedEventArgs> { define_guid(0xDADECFD0, 0x6E1E, 0x473F, 0xB0, 0xBE, 0xB0, 0x24, 0x4, 0xD6, 0xA8, 0x6D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewSeparateProcessLostEventArgs> { define_guid(0xA405700A, 0xC482, 0x40B5, 0xAA, 0xEA, 0xE1, 0xC, 0xFA, 0x9F, 0x5A, 0xBE);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewSettings> { define_guid(0x1D50AD4D, 0xABF6, 0x4785, 0x8D, 0xF3, 0xFD, 0xEB, 0xC1, 0x27, 0x3, 0x1);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewUnsupportedUriSchemeIdentifiedEventArgs> { define_guid(0xB9C9E1A7, 0x620F, 0x4895, 0x93, 0x5D, 0x10, 0xFB, 0xAC, 0x6F, 0xD2, 0x9E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewUnviewableContentIdentifiedEventArgs> { define_guid(0x37BC16E1, 0x6062, 0x4678, 0xB2, 0xB, 0x6C, 0x36, 0xAC, 0x9C, 0x59, 0xAC);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewUnviewableContentIdentifiedEventArgs2> { define_guid(0x9ABE1154, 0x36F0, 0x4268, 0x8D, 0x88, 0x12, 0x1E, 0xED, 0xF4, 0x5E, 0x6A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAutoSuggestBoxQuerySubmittedEventArgs> { define_guid(0x78DCB116, 0x818A, 0x4CB5, 0xBC, 0xA7, 0x38, 0x2C, 0xE6, 0xDD, 0xC9, 0xD);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAutoSuggestBoxSuggestionChosenEventArgs> { define_guid(0x396F7254, 0x1ED5, 0x4BC5, 0xA0, 0x60, 0x65, 0x55, 0x30, 0xBC, 0xA6, 0xBA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAutoSuggestBoxTextChangedEventArgs> { define_guid(0x3A6F7254, 0x1ED5, 0x4BC5, 0xA0, 0x60, 0x65, 0x55, 0x30, 0xBC, 0xA6, 0xBA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAutoSuggestBoxTextChangedEventArgsStatics> { define_guid(0xFEF7772B, 0x9F45, 0x44DB, 0x8C, 0x27, 0xBD, 0xA3, 0xF9, 0x33, 0xE7, 0xB5);};
template<> struct uuid<Windows::UI::Xaml::Controls::IIconSource> { define_guid(0x92EC8D55, 0x45EB, 0x47A4, 0x86, 0x3C, 0x91, 0xB2, 0x24, 0x4, 0x4F, 0x9B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IIconSourceStatics> { define_guid(0x1D389DBE, 0x1CD3, 0x4F4F, 0x83, 0xB0, 0x55, 0xDC, 0x63, 0x87, 0x68, 0x5B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IIconSourceFactory> { define_guid(0x4D117CF1, 0x1FD6, 0x49D7, 0xB4, 0x83, 0x2, 0xEC, 0x3D, 0xE9, 0x97, 0xD6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IBitmapIconSourceStatics> { define_guid(0x5A105887, 0xE494, 0x4D2B, 0x85, 0x28, 0x39, 0x47, 0x22, 0x96, 0x13, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IBitmapIconSourceFactory> { define_guid(0x6509E5C6, 0x44B6, 0x4CD1, 0x86, 0xCD, 0xC3, 0x18, 0x9B, 0x12, 0xC4, 0x3C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFlyout> { define_guid(0x6584EBDF, 0xCBC7, 0x4E19, 0x84, 0x3A, 0xA1, 0x4F, 0x24, 0xA7, 0x93, 0xEA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFlyoutStatics> { define_guid(0x61364E0B, 0xDB75, 0x47E1, 0xB2, 0xC3, 0x5B, 0x90, 0x1C, 0x3D, 0x74, 0xB6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFlyoutFactory> { define_guid(0x4BED4933, 0x8E, 0x4B03, 0xA3, 0x85, 0x79, 0xFE, 0x52, 0x66, 0xDD, 0xBA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFontIconSource> { define_guid(0x2211AC9A, 0x74E3, 0x43ED, 0xB6, 0x1C, 0x21, 0xAF, 0xC7, 0xDF, 0x4D, 0x10);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFontIconSourceStatics> { define_guid(0x8C0E422F, 0x8269, 0x43B1, 0xB9, 0x5A, 0xEF, 0x7, 0xE, 0x86, 0x77, 0xD);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFontIconSourceFactory> { define_guid(0x8BDCF6BD, 0xFC06, 0x42B8, 0xB3, 0xB, 0x75, 0x5, 0x8, 0x2A, 0xC3, 0x8F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyout> { define_guid(0xAD3210F1, 0x985B, 0x4171, 0xBB, 0xBA, 0x67, 0xBC, 0xC7, 0x29, 0x64, 0x9B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutStatics> { define_guid(0x3DBEFBA1, 0x9522, 0x4045, 0x9E, 0x58, 0xC9, 0x9B, 0x13, 0xAA, 0xB9, 0xB9);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutFactory> { define_guid(0x644533AB, 0xBBB9, 0x499B, 0x9F, 0xF3, 0x30, 0xD4, 0xE, 0x2C, 0x56, 0xD8);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyout2> { define_guid(0x507C7BAD, 0xD9D1, 0x4C05, 0x9D, 0x4B, 0xCD, 0xA8, 0xDE, 0x9A, 0xB2, 0x42);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPathIconSource> { define_guid(0x1F47010E, 0xB305, 0x4863, 0x8B, 0x7A, 0x15, 0xD0, 0x8D, 0x63, 0x3C, 0x7A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPathIconSourceStatics> { define_guid(0xDF7027D5, 0x3682, 0x43FF, 0x80, 0xF0, 0xAF, 0xA2, 0x56, 0xB2, 0xFD, 0xC3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPathIconSourceFactory> { define_guid(0x8F7F85B9, 0x5247, 0x4F3B, 0x83, 0x3F, 0xE3, 0x84, 0xBF, 0x7E, 0x9C, 0x84);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISymbolIconSource> { define_guid(0x625D95A2, 0xB6B1, 0x408A, 0xB2, 0x89, 0xEA, 0xB2, 0xEC, 0xBA, 0x62, 0xD8);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISymbolIconSourceStatics> { define_guid(0x8BC49738, 0xD94E, 0x4148, 0x8D, 0x64, 0x1A, 0xDF, 0xF, 0x23, 0xF2, 0x5F);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISymbolIconSourceFactory> { define_guid(0xA526AAB0, 0x4130, 0x4907, 0xB0, 0x49, 0x21, 0xF9, 0x24, 0xC, 0x7A, 0x40);};
template<> struct uuid<Windows::UI::Xaml::Controls::IIconElement> { define_guid(0x9AF0803B, 0xD04C, 0x467A, 0xBB, 0xD5, 0x9B, 0x81, 0xF0, 0x2D, 0x9A, 0x56);};
template<> struct uuid<Windows::UI::Xaml::Controls::IIconElementStatics> { define_guid(0xBE19A623, 0x77CF, 0x472F, 0x82, 0xEA, 0x4, 0x78, 0x1, 0xD1, 0x20, 0x12);};
template<> struct uuid<Windows::UI::Xaml::Controls::IIconElementFactory> { define_guid(0xCF37A562, 0x424, 0x43C7, 0x8B, 0xEA, 0x72, 0xF, 0xBA, 0x97, 0x3E, 0xF1);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkCanvas> { define_guid(0x29443C28, 0x8E48, 0x4FC8, 0xA4, 0x73, 0x35, 0xB0, 0xBA, 0x12, 0xAC, 0xEA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkCanvasFactory> { define_guid(0x924AC2DE, 0xAB04, 0x48F0, 0x96, 0x53, 0xE0, 0xF2, 0xDA, 0x4D, 0xBF, 0x1A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaElement> { define_guid(0xA38ED2CF, 0x13DE, 0x4299, 0xAD, 0xE2, 0xAE, 0x18, 0xF7, 0x4E, 0xD3, 0x53);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaElementStatics> { define_guid(0xDCCD2CB9, 0x7568, 0x4682, 0xA7, 0x2A, 0x8D, 0xDF, 0x2A, 0x26, 0x65, 0xCA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaElement2> { define_guid(0xFD53DA65, 0xB186, 0x4654, 0xBF, 0xDB, 0x18, 0xE, 0xD2, 0x6C, 0xAD, 0x7);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaElementStatics2> { define_guid(0x9EE7F826, 0xF154, 0x4DC6, 0x80, 0x14, 0xA6, 0xEB, 0xA9, 0x87, 0xF8, 0x47);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaElement3> { define_guid(0x479F6F13, 0xFDB, 0x4ED8, 0x92, 0x8A, 0x4D, 0x39, 0x16, 0x9C, 0x3C, 0xD2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaPlayerPresenter> { define_guid(0x77A92326, 0xC5B, 0x41FC, 0xBF, 0x49, 0x15, 0xF6, 0xC3, 0x52, 0x4B, 0x6B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaPlayerPresenterStatics> { define_guid(0x84D774FE, 0xEAD4, 0x4957, 0xB4, 0x2B, 0x22, 0x31, 0x58, 0xCA, 0xD, 0xE7);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaPlayerPresenterFactory> { define_guid(0xE6766FB7, 0xD96F, 0x4B95, 0xB3, 0x3C, 0x59, 0xE8, 0x1C, 0xB1, 0xE9, 0xBA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebView> { define_guid(0x5862CC46, 0x1F7D, 0x479B, 0x92, 0xA6, 0xDE, 0x78, 0x58, 0xFE, 0x8D, 0x54);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewStatics> { define_guid(0xA0B561DE, 0x5FDB, 0x443B, 0xB9, 0xF0, 0x5C, 0x30, 0xF6, 0xB7, 0xA1, 0xF4);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebView2> { define_guid(0xD481759E, 0x3EFF, 0x4462, 0x82, 0x3D, 0xFD, 0x52, 0xF9, 0xBA, 0x4C, 0xC8);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewStatics2> { define_guid(0x322F8780, 0xE812, 0x466B, 0x9E, 0x50, 0x8E, 0x9F, 0xEC, 0x24, 0x1, 0x8A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebView3> { define_guid(0xC497789B, 0xB499, 0x4D69, 0xB5, 0xC2, 0xAE, 0x9D, 0x5D, 0x6D, 0x59, 0x4E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewStatics3> { define_guid(0x129BEF8A, 0x4509, 0x4374, 0xB0, 0xD1, 0xA7, 0x10, 0x4D, 0xC, 0x3A, 0x2F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebView4> { define_guid(0xE28243BC, 0x67F3, 0x462A, 0xB4, 0xE0, 0x3B, 0xBF, 0x6C, 0x3D, 0xAB, 0xB);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewStatics4> { define_guid(0x44B197B0, 0xB746, 0x40F3, 0x99, 0x36, 0x4E, 0xBB, 0xFF, 0x6B, 0x47, 0xB8);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewFactory4> { define_guid(0x82EDAC58, 0xEE6A, 0x4C9B, 0xA3, 0xA0, 0x93, 0x47, 0xA7, 0xD0, 0xEF, 0x4C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebView5> { define_guid(0x8C9884A6, 0x2F3B, 0x4A55, 0xA4, 0x63, 0x84, 0x44, 0xC2, 0x9, 0x5D, 0x0);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewStatics5> { define_guid(0x8A0B8D1, 0x508A, 0x4DB8, 0x97, 0xEF, 0xF, 0xA5, 0x5, 0xE1, 0x9E, 0xC2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebView6> { define_guid(0x38CCD942, 0x2536, 0x467C, 0xA2, 0x11, 0xAF, 0x35, 0x9C, 0x3B, 0x4F, 0xDA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewBrush> { define_guid(0x40E86F75, 0xCF4, 0x4B72, 0xA4, 0xD6, 0xCF, 0x5D, 0x15, 0x78, 0x1, 0x16);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWebViewBrushStatics> { define_guid(0xD74DAA24, 0x1D05, 0x463E, 0xB0, 0x28, 0x6B, 0xAA, 0x44, 0x20, 0xE7, 0x62);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarSeparator> { define_guid(0x1B0795A1, 0x1BC1, 0x4D53, 0x95, 0xEA, 0xFB, 0xA, 0x2C, 0xCC, 0xC9, 0x5);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarSeparatorStatics> { define_guid(0x37F23484, 0x5B35, 0x4663, 0xA7, 0x5D, 0xF2, 0xD5, 0xC, 0xB9, 0xC6, 0x19);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarSeparatorFactory> { define_guid(0x5DA25CD, 0xF407, 0x48DE, 0x8B, 0x50, 0xFF, 0x87, 0xD1, 0xE2, 0x81, 0x8F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarSeparatorStatics3> { define_guid(0x36C753F9, 0x7373, 0x4E5E, 0x9B, 0xA4, 0xC3, 0x62, 0x2A, 0x0, 0x3C, 0x4E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IBitmapIcon> { define_guid(0xE8FE17CB, 0x35F7, 0x40F3, 0xA1, 0x85, 0x48, 0xB3, 0x97, 0xB7, 0x3E, 0x68);};
template<> struct uuid<Windows::UI::Xaml::Controls::IBitmapIconStatics> { define_guid(0xE072D117, 0xE4E7, 0x4E0C, 0x94, 0x70, 0x53, 0xFF, 0x1C, 0xE8, 0x4F, 0x67);};
template<> struct uuid<Windows::UI::Xaml::Controls::IBitmapIconFactory> { define_guid(0x46D64B1D, 0x7A49, 0x4F66, 0x97, 0x29, 0x28, 0x48, 0xC7, 0x88, 0xE4, 0x2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IBitmapIcon2> { define_guid(0x624A20A, 0x9DD1, 0x4201, 0xBB, 0x20, 0x42, 0x86, 0x3D, 0xA1, 0x56, 0x58);};
template<> struct uuid<Windows::UI::Xaml::Controls::IBitmapIconStatics2> { define_guid(0x9745026B, 0xB742, 0x4A89, 0xA5, 0xD7, 0xA0, 0xE5, 0xFB, 0x80, 0x9A, 0xF1);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICalendarDatePicker> { define_guid(0x63C9C16F, 0x668C, 0x4491, 0x94, 0x44, 0xD4, 0x5D, 0x8B, 0xF4, 0xFA, 0x29);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICalendarDatePickerStatics> { define_guid(0x39A3D291, 0xAFAB, 0x4B94, 0x83, 0x95, 0xBA, 0x7B, 0x87, 0x4E, 0x3C, 0x8C);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICalendarDatePickerFactory> { define_guid(0x107AAD5D, 0x38BE, 0x42AF, 0xA9, 0x57, 0xFC, 0x86, 0xA5, 0xCF, 0x1E, 0x9A);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICalendarDatePicker2> { define_guid(0xB216C159, 0x2411, 0x4A60, 0xA7, 0xAA, 0x27, 0x41, 0x6B, 0x49, 0x48, 0x1E);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICalendarDatePickerStatics2> { define_guid(0x30206B58, 0xA2F6, 0x4A00, 0x8D, 0x13, 0x33, 0xC4, 0x6B, 0x6B, 0x8E, 0xD);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICalendarView> { define_guid(0xCD639203, 0xDFB5, 0x4312, 0xAC, 0x7, 0xC0, 0x39, 0x18, 0x24, 0x60, 0x7B);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICalendarViewStatics> { define_guid(0x7260F1C4, 0x2F5D, 0x41BD, 0x99, 0xBB, 0x45, 0x71, 0xB2, 0xB, 0x79, 0xA8);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICalendarViewFactory> { define_guid(0x3D8F82E3, 0x6CC6, 0x423E, 0x8D, 0x7C, 0x70, 0x14, 0xD9, 0x54, 0xDD, 0xEF);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICalendarViewDayItem> { define_guid(0xFDB2DC5, 0x32C1, 0x4B8F, 0xBE, 0xFC, 0x1, 0x7B, 0x55, 0x5B, 0x32, 0xD2);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICalendarViewDayItemStatics> { define_guid(0xC3A1DBBF, 0xBD88, 0x488B, 0xB9, 0x16, 0xD0, 0xD, 0x69, 0xB1, 0x73, 0x5A);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICalendarViewDayItemFactory> { define_guid(0x62112BDC, 0x1D2F, 0x4E44, 0x9B, 0xAF, 0x16, 0x65, 0x74, 0x95, 0x21, 0xF2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDatePicker> { define_guid(0x6DA3946, 0x8B8, 0x4103, 0x8B, 0x8A, 0x9, 0x3E, 0xFD, 0x6A, 0x76, 0x57);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDatePickerStatics> { define_guid(0x182E7C69, 0x2116, 0x4C67, 0xB5, 0x13, 0x71, 0x33, 0x64, 0x83, 0x1D, 0x79);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDatePickerFactory> { define_guid(0xEEC3CA84, 0x9896, 0x4A7D, 0xBB, 0x35, 0x6F, 0xB2, 0x1E, 0xAE, 0xCA, 0x11);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDatePicker2> { define_guid(0xBB28B475, 0x2C1F, 0x4340, 0x9E, 0x30, 0x94, 0x8F, 0x99, 0xC9, 0xE5, 0x7A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDatePickerStatics2> { define_guid(0xF1076DF6, 0xFBA6, 0x4550, 0x8B, 0x88, 0xA6, 0x42, 0x8, 0x47, 0xF6, 0xD);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFontIcon> { define_guid(0xD4D61391, 0x39AC, 0x4950, 0x91, 0x66, 0x36, 0x6, 0xC2, 0x64, 0x41, 0x8B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFontIconStatics> { define_guid(0xB3BE7BF6, 0x1467, 0x4086, 0xBB, 0xCB, 0x4E, 0x21, 0xD9, 0x7A, 0x7B, 0x4D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFontIconFactory> { define_guid(0x1C781B6B, 0x37BF, 0x4DDC, 0xA1, 0xA8, 0x1B, 0x77, 0xDB, 0x3C, 0xF0, 0xEA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFontIcon2> { define_guid(0xF6EBD84D, 0x37E8, 0x46EE, 0xA5, 0x74, 0x41, 0xAD, 0x55, 0x4, 0x82, 0xE0);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFontIconStatics2> { define_guid(0xE6080672, 0x8F8, 0x43D3, 0x87, 0x90, 0x46, 0x4, 0x29, 0xC, 0xBE, 0xBD);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFontIcon3> { define_guid(0x6155D919, 0x1C6C, 0x4950, 0x87, 0x94, 0x23, 0x1E, 0xF0, 0x91, 0x4D, 0x94);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFontIconStatics3> { define_guid(0xA4528B17, 0xB084, 0x4BD5, 0xAA, 0xB4, 0xFE, 0xAE, 0x9D, 0x3B, 0x5D, 0x26);};
template<> struct uuid<Windows::UI::Xaml::Controls::IHub> { define_guid(0xAE692E82, 0x7314, 0x4F51, 0xAB, 0x11, 0x2A, 0xF1, 0xED, 0x4A, 0x19, 0xF8);};
template<> struct uuid<Windows::UI::Xaml::Controls::IHubStatics> { define_guid(0xE6FA034, 0xAD3C, 0x4F32, 0xB7, 0x1, 0xE2, 0x4F, 0xAB, 0x56, 0x20, 0x28);};
template<> struct uuid<Windows::UI::Xaml::Controls::IHubFactory> { define_guid(0xDCA6B2BA, 0xC6F5, 0x4961, 0x99, 0x53, 0xC5, 0x18, 0x73, 0xDB, 0x54, 0x24);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsStackPanel> { define_guid(0xDF7AB79D, 0x7AD5, 0x4B58, 0x93, 0x63, 0x91, 0x9A, 0xF9, 0x2, 0x26, 0xE6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsStackPanelStatics> { define_guid(0xCA25D63F, 0x44F, 0x4B6B, 0xB3, 0x15, 0xB, 0x60, 0xE0, 0xB4, 0xF8, 0x7D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsStackPanel2> { define_guid(0xEEEECDB0, 0xB4, 0x4534, 0x93, 0x7B, 0x56, 0x31, 0x8B, 0x29, 0x3E, 0x92);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsStackPanelStatics2> { define_guid(0x3972EB2C, 0x384A, 0x48BF, 0xAD, 0xFD, 0x77, 0x2E, 0x25, 0x72, 0xC5, 0x4);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsWrapGrid> { define_guid(0xDDFE6B5F, 0xBA88, 0x4A7D, 0x8A, 0x5B, 0xE5, 0x8C, 0xAF, 0xF, 0x4E, 0x2D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsWrapGridStatics> { define_guid(0x4EC5427D, 0x24A0, 0x449A, 0xB7, 0x63, 0x30, 0x77, 0xBA, 0xF, 0x2D, 0xD5);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsWrapGrid2> { define_guid(0x80C21C0F, 0x63EC, 0x4258, 0xBD, 0x61, 0xD4, 0xA6, 0x95, 0x6C, 0x86, 0x4A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsWrapGridStatics2> { define_guid(0x2E27D3F7, 0xFEAA, 0x478D, 0xBF, 0xD1, 0x29, 0x33, 0x8A, 0xDC, 0x5A, 0x3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaPlayerElement> { define_guid(0x3B4CA526, 0x2E25, 0x4598, 0xBC, 0x71, 0xD4, 0x91, 0xF8, 0xE8, 0xDE, 0x39);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaPlayerElementStatics> { define_guid(0x1E7C4020, 0xAC57, 0x42DD, 0xAD, 0x1C, 0x3E, 0xBC, 0x2D, 0x7F, 0x8, 0xBA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMediaPlayerElementFactory> { define_guid(0x77E525C3, 0xEB17, 0x4B8D, 0x88, 0x9D, 0x1E, 0xA8, 0xAB, 0xDB, 0xD4, 0xEF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutItemBase> { define_guid(0xF9B56047, 0x8DA6, 0x4730, 0x92, 0x8, 0x14, 0x41, 0x25, 0xC6, 0xB3, 0x96);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutItemBaseFactory> { define_guid(0x83E6DBAD, 0xFC67, 0x41D5, 0x87, 0x97, 0x60, 0xAC, 0xD1, 0xCE, 0xB1, 0xD9);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPathIcon> { define_guid(0x214C62DB, 0xC366, 0x4A0E, 0xB9, 0xAD, 0xDC, 0xF1, 0x68, 0xD7, 0xEC, 0xC);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPathIconStatics> { define_guid(0x77B75DB8, 0xFB15, 0x491A, 0xB6, 0xE3, 0x7D, 0xBB, 0xA9, 0x11, 0xBA, 0xFE);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPathIconFactory> { define_guid(0xAF9D9652, 0x9C5D, 0x4A37, 0x9E, 0x1A, 0x4, 0x4A, 0xBE, 0xEF, 0x79, 0x2B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBox> { define_guid(0x90A57A40, 0x80B6, 0x4FCE, 0xB1, 0xEC, 0xE3, 0xC6, 0x16, 0x28, 0x4B, 0x6A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBoxStatics> { define_guid(0xF5E03A74, 0x88EA, 0x479B, 0x9A, 0x5, 0x37, 0x8, 0x9F, 0xF3, 0xE, 0xDE);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBoxFactory> { define_guid(0x61A1DF62, 0x2806, 0x41ED, 0x88, 0xED, 0xAE, 0x21, 0xF4, 0x7A, 0xB4, 0x22);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBox2> { define_guid(0xBBEA6EAD, 0xE805, 0x47A4, 0xBB, 0xE7, 0x47, 0xE5, 0x9B, 0x8F, 0x74, 0xA7);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBoxStatics2> { define_guid(0xE3EB26DE, 0x2748, 0x420B, 0xB1, 0xFC, 0xCE, 0x95, 0xB6, 0xE8, 0x5E, 0xEC);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBox3> { define_guid(0x6B17A462, 0xFBB6, 0x4FFF, 0x99, 0x91, 0x93, 0x99, 0xCB, 0x9C, 0xB, 0x90);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBoxStatics3> { define_guid(0x6D17EEC5, 0x1FB3, 0x4C8B, 0xAA, 0x23, 0xF5, 0xE1, 0x5D, 0x6A, 0xB6, 0x4E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBox4> { define_guid(0x5CAA8D35, 0xC838, 0x4BAD, 0xA0, 0x7C, 0x20, 0x41, 0x83, 0xBB, 0x75, 0x1F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBoxStatics4> { define_guid(0xF5D54FD7, 0x7796, 0x42A5, 0xA5, 0xE5, 0x2C, 0xD2, 0x11, 0xEE, 0x81, 0x76);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBox5> { define_guid(0xA66D9CEA, 0x6391, 0x4F3B, 0x9F, 0xD3, 0x1F, 0xD0, 0x1F, 0x49, 0xF3, 0x27);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBoxStatics5> { define_guid(0x4B5C4568, 0x43D5, 0x43E6, 0xBB, 0xB9, 0xCB, 0x4E, 0x62, 0x50, 0xF4, 0x5A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBox6> { define_guid(0xC89D500, 0xE8D8, 0x4EAE, 0x88, 0x4, 0x33, 0x64, 0x92, 0x5, 0xD7, 0xD2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBoxStatics6> { define_guid(0xFE40E287, 0x82ED, 0x4F7E, 0x92, 0xBA, 0x66, 0xF6, 0x7B, 0xC1, 0xFF, 0x44);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBox7> { define_guid(0x980C93EA, 0x241F, 0x4F6A, 0xA5, 0x39, 0x9D, 0x18, 0x5C, 0x8C, 0xF1, 0x8A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRichEditBoxStatics7> { define_guid(0x59FA898F, 0xF861, 0x43DA, 0xA7, 0xCE, 0x4B, 0x9C, 0x21, 0xD8, 0x35, 0xF9);};
template<> struct uuid<Windows::UI::Xaml::Controls::IScrollContentPresenter> { define_guid(0x5712EE2B, 0xEEB, 0x46D3, 0xAA, 0x31, 0x5F, 0x68, 0x1, 0xB8, 0xDE, 0x20);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISearchBox> { define_guid(0xF89ECC5A, 0x99BA, 0x4BD4, 0x96, 0x6C, 0xF1, 0x1F, 0xA4, 0x43, 0xD1, 0x3C);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISearchBoxStatics> { define_guid(0xB123634F, 0x6871, 0x48CD, 0x92, 0xDF, 0x4C, 0xFF, 0x22, 0x45, 0x90, 0x82);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISearchBoxFactory> { define_guid(0xCD743F6D, 0x8685, 0x46B4, 0x9D, 0xDD, 0x20, 0x2F, 0x69, 0x41, 0xB7, 0x1);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISplitView> { define_guid(0x97222F31, 0x3844, 0x429E, 0x93, 0x9C, 0x16, 0x73, 0x15, 0x53, 0x22, 0xA1);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISplitViewStatics> { define_guid(0x859B4F6F, 0x44AB, 0x4E4B, 0x91, 0xC1, 0x17, 0xB7, 0x5, 0x6D, 0x9B, 0x5F);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISplitViewFactory> { define_guid(0xF101773A, 0x84E, 0x4FB9, 0x84, 0x42, 0x63, 0x22, 0x1B, 0x44, 0x53, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISplitView2> { define_guid(0x5EA7DC10, 0xCC83, 0x409A, 0x82, 0xF9, 0x3E, 0x91, 0xD6, 0xD7, 0x8, 0x4F);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISplitViewStatics2> { define_guid(0x14B7CD7A, 0xDFBC, 0x422C, 0x80, 0xA9, 0x58, 0x58, 0x71, 0x29, 0x71, 0x13);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISplitView3> { define_guid(0xEA12D8D, 0x1171, 0x407B, 0x96, 0xD3, 0x5E, 0x1B, 0x47, 0xC, 0x3E, 0xC5);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISymbolIcon> { define_guid(0x7A4774C9, 0xA6A3, 0x4B30, 0x8F, 0xF1, 0x90, 0x81, 0xD7, 0xE, 0x9A, 0x5C);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISymbolIconStatics> { define_guid(0x8624FBDF, 0x952C, 0x4F76, 0xB0, 0x3F, 0x30, 0x83, 0x3B, 0xE9, 0x95, 0x72);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISymbolIconFactory> { define_guid(0xC7252B88, 0xE76C, 0x4B44, 0x8A, 0x5, 0x4, 0x6B, 0x9D, 0xC7, 0x72, 0xB8);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITimePicker> { define_guid(0xE39099F2, 0x3AFF, 0x4792, 0x90, 0x9E, 0x2D, 0x99, 0x41, 0xEC, 0x3, 0x57);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITimePickerStatics> { define_guid(0xFA71DFB1, 0x233E, 0x4F31, 0xB8, 0xBE, 0xA6, 0xEA, 0x67, 0xC, 0x25, 0xCD);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITimePickerFactory> { define_guid(0x553FE413, 0x6CD7, 0x46A9, 0xA9, 0x7B, 0xA1, 0x8B, 0xDC, 0x4B, 0x4C, 0xA3);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITimePicker2> { define_guid(0xFF0798C, 0xF922, 0x419F, 0x8B, 0x3D, 0x23, 0xEE, 0x75, 0x86, 0xD4, 0x8E);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITimePickerStatics2> { define_guid(0x36D8ABCD, 0x4E10, 0x451A, 0xB9, 0x3B, 0x1A, 0x73, 0x1E, 0xA7, 0xEE, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBar> { define_guid(0x7B0FC253, 0x86A5, 0x4B43, 0x98, 0x72, 0xB, 0x8A, 0x62, 0x34, 0xB7, 0x4B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarOverrides> { define_guid(0xF003E4E2, 0x7B0F, 0x4F4A, 0x97, 0xD, 0xAE, 0x8A, 0xE, 0xAA, 0x9B, 0x70);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarStatics> { define_guid(0x79BB7E8D, 0xDCA9, 0x4B5F, 0xA4, 0x48, 0x37, 0xB1, 0x32, 0x38, 0xED, 0x76);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarFactory> { define_guid(0x614708D1, 0x8E65, 0x43CB, 0x92, 0xD7, 0x8E, 0xEE, 0x17, 0x51, 0x5F, 0x8D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBar2> { define_guid(0xC3AB17B3, 0x7AD7, 0x4676, 0x99, 0x10, 0x7F, 0xE3, 0xF0, 0xE8, 0xE9, 0x93);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarStatics2> { define_guid(0x222355E9, 0x384, 0x49DE, 0x87, 0x38, 0xDF, 0xC9, 0xD4, 0x9, 0xAC, 0x5D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBar3> { define_guid(0x982B001F, 0x752E, 0x4E7A, 0xB0, 0x55, 0x54, 0x80, 0x2C, 0x9E, 0xA7, 0x49);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarOverrides3> { define_guid(0x412BBBC8, 0x51D0, 0x4B49, 0xAB, 0x62, 0xA3, 0xDD, 0x6B, 0xDC, 0xB2, 0x98);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBar4> { define_guid(0x94EBC8CD, 0xA64, 0x4DA3, 0xBF, 0x43, 0xF1, 0x31, 0x0, 0xA4, 0x66, 0x5);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarStatics4> { define_guid(0xBA02082E, 0x1165, 0x4451, 0x94, 0xB3, 0xEB, 0x3A, 0xC7, 0x3E, 0x41, 0x96);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAutoSuggestBox> { define_guid(0x103E9B13, 0x3400, 0x4A16, 0x90, 0xB9, 0x69, 0x12, 0xBF, 0x6, 0x97, 0x4F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAutoSuggestBoxStatics> { define_guid(0xEE22C7F4, 0xC15D, 0x4FF3, 0x8A, 0x94, 0xF5, 0xD, 0xFD, 0xFB, 0xE8, 0x9A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAutoSuggestBox2> { define_guid(0xAA87DDDE, 0xE679, 0x45B2, 0xA7, 0xC9, 0x9A, 0xED, 0xC3, 0x9D, 0xB8, 0x86);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAutoSuggestBoxStatics2> { define_guid(0x1CD297A8, 0x8E6A, 0x41EF, 0xA9, 0x5D, 0x71, 0x57, 0xDC, 0xC, 0x71, 0x6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAutoSuggestBox3> { define_guid(0x9BBBFCEF, 0xF32D, 0x402E, 0x90, 0x9, 0x5, 0xBD, 0xBA, 0xF6, 0x33, 0x6E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAutoSuggestBoxStatics3> { define_guid(0x2CEAD2DD, 0xC4D5, 0x4AB2, 0x8A, 0x13, 0xAF, 0xDD, 0xCF, 0x6, 0x7C, 0x86);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICommandBarOverflowPresenter> { define_guid(0x6E7A9427, 0x58EF, 0x4366, 0xA0, 0x17, 0x18, 0xC1, 0x93, 0xD5, 0x6B, 0x14);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICommandBarOverflowPresenterFactory> { define_guid(0x8323F774, 0x5AAA, 0x4049, 0xB7, 0x8F, 0x21, 0x8C, 0x6A, 0x19, 0xC3, 0x7E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentDialog> { define_guid(0x38DC4404, 0xD24E, 0x40D8, 0x94, 0x15, 0x34, 0x94, 0x64, 0xC1, 0xAF, 0xDC);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentDialogStatics> { define_guid(0x23AB47A6, 0x508A, 0x4F33, 0xB7, 0x86, 0xF2, 0xFA, 0x96, 0xD8, 0x69, 0xAF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentDialogFactory> { define_guid(0x5557178, 0x9D8E, 0x4315, 0xB3, 0x7D, 0x68, 0xC, 0x14, 0x1, 0x2C, 0x35);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentDialog2> { define_guid(0x2F93EB45, 0xEE43, 0x4303, 0x9B, 0x38, 0x3F, 0xE1, 0xA1, 0x11, 0xEC, 0xBF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentDialogStatics2> { define_guid(0x329825B2, 0x8FB0, 0x4125, 0xBB, 0x7, 0xE7, 0x9A, 0x5A, 0x3, 0x81, 0x9F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IContentDialog3> { define_guid(0x9D9A089E, 0xF954, 0x4EDE, 0xB0, 0x7F, 0x6B, 0x6, 0x9A, 0x9C, 0x1, 0x80);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFlyoutPresenter> { define_guid(0x827D5B79, 0xE37B, 0x46A5, 0x8D, 0x44, 0x63, 0xA1, 0x1A, 0x58, 0xE, 0x83);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFlyoutPresenterFactory> { define_guid(0xEE4D668F, 0xDA76, 0x469A, 0xAC, 0xD7, 0x30, 0x60, 0xE6, 0x13, 0xAD, 0xE7);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFrame> { define_guid(0x68EA500B, 0x3FE9, 0x4735, 0xB6, 0xA0, 0xE7, 0x60, 0x19, 0x33, 0xB0, 0x89);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFrameStatics> { define_guid(0xD5ACF0E9, 0xD967, 0x471B, 0x84, 0x59, 0xC8, 0xAF, 0x43, 0x41, 0x51, 0x1B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFrameFactory> { define_guid(0x2EE93D4, 0x448E, 0x469E, 0x97, 0x99, 0xA, 0x8A, 0x1F, 0x70, 0xF1, 0x71);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFrame2> { define_guid(0x3F367F87, 0x9F5A, 0x4B04, 0xB8, 0x18, 0xB5, 0x54, 0xC0, 0x69, 0x59, 0x7A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFrameStatics2> { define_guid(0xE4B5CDFE, 0x42F0, 0x4462, 0xA1, 0xC1, 0x5D, 0x25, 0x9D, 0xD8, 0x2A, 0x3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFrame3> { define_guid(0x648A2B4D, 0x53CA, 0x4B5A, 0xAA, 0x8E, 0x3C, 0xC7, 0x44, 0xF, 0x4A, 0x67);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFrame4> { define_guid(0x9B17C21A, 0xBD2B, 0x4A00, 0x99, 0xEB, 0x94, 0x6B, 0xE9, 0x61, 0x80, 0x84);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutItem> { define_guid(0x160775CF, 0xB598, 0x44AF, 0xA4, 0x88, 0xC3, 0xCE, 0x2A, 0xF6, 0xD3, 0xF0);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutItemStatics> { define_guid(0x4950B424, 0xA43A, 0x41F7, 0xAA, 0x3A, 0x9C, 0xE9, 0x61, 0x97, 0x47, 0xD5);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutItemFactory> { define_guid(0xC5AA39E2, 0x44F3, 0x455E, 0x9C, 0x5B, 0x62, 0xBB, 0x6A, 0xFC, 0xE3, 0xAD);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutItem2> { define_guid(0xAE266EB, 0x28C, 0x4423, 0xA8, 0xE3, 0x98, 0x9F, 0xD9, 0xDD, 0x71, 0x26);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutItemStatics2> { define_guid(0xACA4F564, 0x1790, 0x4601, 0x91, 0x6E, 0x5A, 0xE1, 0xF0, 0x1F, 0x4B, 0xD6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutItem3> { define_guid(0x9727B2E3, 0xB2B6, 0x49DC, 0x8C, 0x22, 0xE0, 0x13, 0x8B, 0x94, 0x15, 0x59);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutItemStatics3> { define_guid(0xD83FD7C3, 0xAEB, 0x4EF3, 0x82, 0x70, 0x8B, 0x9B, 0x95, 0xF2, 0xB2, 0x98);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutPresenter> { define_guid(0x906E0304, 0x254E, 0x413F, 0xB2, 0x19, 0xC7, 0xB9, 0x7F, 0x0, 0x37, 0x52);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutPresenterFactory> { define_guid(0xB88B5091, 0x101C, 0x41F8, 0xAA, 0xC1, 0x1B, 0x10, 0x5C, 0x14, 0xFB, 0x99);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutPresenter2> { define_guid(0x895894DF, 0x5A9F, 0x4A1F, 0x85, 0xEC, 0x6F, 0x3C, 0x1B, 0x6D, 0xCB, 0x89);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutSeparator> { define_guid(0x71FA2B7D, 0xB51, 0x4950, 0xA1, 0xA4, 0xBB, 0xC4, 0x2E, 0xAC, 0x4C, 0x12);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutSeparatorFactory> { define_guid(0xC159DCC8, 0xB437, 0x44E0, 0xB2, 0x4B, 0x57, 0x20, 0xAE, 0xA1, 0xDB, 0xAC);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutSubItem> { define_guid(0xE5386550, 0xFE2C, 0x43E2, 0xA7, 0x3F, 0x62, 0x16, 0x8F, 0x61, 0x99, 0x73);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutSubItemStatics> { define_guid(0xDDB27A36, 0x1874, 0x4AEF, 0x83, 0x7D, 0x6F, 0xEC, 0x9D, 0xA4, 0xE6, 0x81);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutSubItem2> { define_guid(0xAC935626, 0x190A, 0x4DE2, 0x8D, 0x71, 0x7C, 0xC4, 0x74, 0x7D, 0xA5, 0x80);};
template<> struct uuid<Windows::UI::Xaml::Controls::IMenuFlyoutSubItemStatics2> { define_guid(0xAC14D09B, 0x3E93, 0x4785, 0x94, 0xEF, 0xFD, 0xB2, 0x3B, 0xAB, 0xA9, 0x65);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPage> { define_guid(0xC4B27075, 0xE641, 0x453E, 0x82, 0x4D, 0x1, 0x2F, 0xC7, 0xCF, 0x95, 0xCF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPageOverrides> { define_guid(0x230B9CB8, 0x3419, 0x4306, 0xAA, 0xBE, 0x4A, 0x8E, 0x68, 0xD, 0x36, 0x27);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPageStatics> { define_guid(0x376DDE71, 0xF725, 0x46DD, 0x8D, 0x80, 0xEE, 0xEA, 0xF7, 0xDA, 0x74, 0xE5);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPageFactory> { define_guid(0xDFA149AC, 0x1849, 0x445E, 0x93, 0x7C, 0x40, 0xA9, 0x59, 0xC, 0xC0, 0x76);};
template<> struct uuid<Windows::UI::Xaml::Controls::IScrollViewer> { define_guid(0x64E9BE00, 0x4DC1, 0x493D, 0xAB, 0xE7, 0xCB, 0xD3, 0xC5, 0x77, 0x49, 0xD);};
template<> struct uuid<Windows::UI::Xaml::Controls::IScrollViewerStatics> { define_guid(0x33D1299D, 0x8D6E, 0x4290, 0xBF, 0x22, 0x90, 0x5C, 0xCC, 0xD0, 0x4D, 0x31);};
template<> struct uuid<Windows::UI::Xaml::Controls::IScrollViewer2> { define_guid(0x64E9BE10, 0x4DD1, 0x494D, 0xAB, 0xF7, 0xCB, 0xD3, 0xC5, 0x77, 0x49, 0x1D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IScrollViewerStatics2> { define_guid(0x33D129AD, 0x8D7E, 0x42A0, 0xBF, 0x32, 0x90, 0x5C, 0xCC, 0xD0, 0x4D, 0x41);};
template<> struct uuid<Windows::UI::Xaml::Controls::IScrollViewer3> { define_guid(0x74E9BE21, 0x5DE2, 0x595E, 0xBC, 0x8, 0xDB, 0xD3, 0xC5, 0x77, 0x49, 0x2C);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwapChainBackgroundPanel> { define_guid(0x1C59DB48, 0x8233, 0x4C0C, 0xBC, 0xF5, 0x2, 0xA5, 0xFB, 0x35, 0xAE, 0x0);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwapChainBackgroundPanelFactory> { define_guid(0x198289D4, 0xC89B, 0x49B2, 0x89, 0x6C, 0x59, 0x17, 0xBF, 0x8A, 0xDC, 0xAE);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwapChainBackgroundPanel2> { define_guid(0x21E672F2, 0x2592, 0x4C38, 0x87, 0xF, 0x28, 0xFB, 0xCF, 0x52, 0xC0, 0x95);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwapChainPanel> { define_guid(0xC589644F, 0xEBA8, 0x427A, 0xB7, 0x5A, 0x9F, 0x1F, 0x93, 0xA1, 0x1A, 0xE9);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwapChainPanelStatics> { define_guid(0xF89C0297, 0xEEA8, 0x498C, 0x99, 0xC4, 0x25, 0x7E, 0x36, 0x60, 0xDF, 0x7E);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwapChainPanelFactory> { define_guid(0xF38F8D7F, 0x1A48, 0x49CB, 0x86, 0xD2, 0x10, 0xEA, 0xAA, 0xF6, 0xFD, 0x70);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICommandBar> { define_guid(0x98BC4280, 0x4A3D, 0x4CEE, 0xBD, 0x7, 0x22, 0xCE, 0x94, 0xC5, 0xAF, 0x76);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICommandBarStatics> { define_guid(0x5BD981EA, 0xE278, 0x409C, 0xB5, 0x22, 0xF9, 0x46, 0xCA, 0x25, 0x3B, 0x44);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICommandBarFactory> { define_guid(0x67BDEB44, 0x20E1, 0x4177, 0xAD, 0x44, 0xF6, 0x17, 0xB3, 0x74, 0xE8, 0xE8);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICommandBar2> { define_guid(0x57662F58, 0x5B32, 0x475D, 0xBE, 0x64, 0x4C, 0xA3, 0x6E, 0x7B, 0x97, 0xD4);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICommandBarStatics2> { define_guid(0x3D9EC8E3, 0x51A9, 0x4E34, 0x95, 0x6C, 0x70, 0x81, 0xD0, 0x6F, 0x26, 0xF8);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICommandBar3> { define_guid(0x40EBBC23, 0x2A79, 0x48B3, 0x9A, 0x67, 0x64, 0x9B, 0x85, 0x2D, 0x85, 0x89);};
template<> struct uuid<Windows::UI::Xaml::Controls::ICommandBarStatics3> { define_guid(0xB45A24A4, 0x8AF1, 0x4843, 0xB3, 0x19, 0xE0, 0x3F, 0xC4, 0x5A, 0xB7, 0x26);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGridViewHeaderItem> { define_guid(0x72D75D7E, 0x5DC3, 0x4FFC, 0x9B, 0x1C, 0x93, 0x9B, 0x5C, 0x37, 0x16, 0x1C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGridViewHeaderItemFactory> { define_guid(0x36E0C96E, 0xB56A, 0x4B3B, 0x8B, 0xAC, 0x7A, 0xEF, 0x5E, 0x6F, 0x99, 0x45);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGridViewItem> { define_guid(0x7D9901F1, 0xE7C1, 0x4E83, 0xB4, 0x70, 0xC9, 0xD6, 0xD7, 0xBD, 0xA9, 0xF5);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGridViewItemFactory> { define_guid(0x229B00AF, 0x3FA6, 0x43E9, 0x97, 0x9D, 0x7, 0xEA, 0xD, 0x62, 0x80, 0xDC);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewHeaderItem> { define_guid(0x1B61BAEB, 0xE196, 0x4B3B, 0xA5, 0xF9, 0x1E, 0xD6, 0x36, 0xF3, 0xF7, 0x9B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewHeaderItemFactory> { define_guid(0x68D2C96A, 0x96B0, 0x4F08, 0xA7, 0xA5, 0xF1, 0x8, 0x67, 0x20, 0xA0, 0xFA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewItem> { define_guid(0xB7BB4305, 0x3DD9, 0x43DE, 0xA8, 0xC0, 0xC4, 0x72, 0xF0, 0x85, 0xBC, 0x11);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewItemFactory> { define_guid(0xF431073D, 0x9CAC, 0x42A2, 0x82, 0xDF, 0xF, 0x44, 0x90, 0xBC, 0x4E, 0x2E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IToggleMenuFlyoutItem> { define_guid(0x49841EDD, 0x88E9, 0x4663, 0xA7, 0x1, 0xCD, 0x4F, 0xD2, 0x5E, 0x39, 0x8F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IToggleMenuFlyoutItemStatics> { define_guid(0x16C724FB, 0x6C1A, 0x4852, 0x92, 0x58, 0x8, 0xC0, 0x38, 0x36, 0x79, 0x7);};
template<> struct uuid<Windows::UI::Xaml::Controls::IToggleMenuFlyoutItemFactory> { define_guid(0xA151966F, 0x3BF7, 0x46B6, 0xB6, 0x1C, 0x9B, 0x2C, 0x1B, 0xA6, 0x88, 0x43);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWrapGrid> { define_guid(0x552178B, 0x7567, 0x47C2, 0xBD, 0x5C, 0xAD, 0x83, 0x94, 0xC8, 0x28, 0xBA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IWrapGridStatics> { define_guid(0xD04A6B97, 0x13CB, 0x479C, 0xA2, 0x85, 0xE4, 0xE5, 0x68, 0x46, 0xC4, 0xCB);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarButton> { define_guid(0x4459A451, 0x69E8, 0x440C, 0x98, 0x96, 0x4B, 0xB4, 0xF5, 0xF6, 0x42, 0xD1);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarButtonStatics> { define_guid(0x7CCD13E6, 0x5301, 0x407F, 0x87, 0x4E, 0xDC, 0x91, 0x60, 0xAA, 0x7, 0xAF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarButtonFactory> { define_guid(0xBDBB1BB6, 0xCB2E, 0x4276, 0xAB, 0xD6, 0x79, 0x35, 0x13, 0x5, 0x10, 0xE0);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarButton3> { define_guid(0xB282150, 0x198B, 0x4E84, 0x8F, 0x1C, 0x9F, 0x6A, 0x8B, 0xA2, 0x67, 0xA7);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarButtonStatics3> { define_guid(0x4D7BF314, 0x2EDE, 0x4328, 0x89, 0x6, 0x75, 0x2A, 0x1F, 0x27, 0xCD, 0xFA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarButton4> { define_guid(0x958FCE6B, 0xFD08, 0x4414, 0x84, 0x58, 0x9D, 0x40, 0x86, 0x6D, 0xC8, 0x4E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarButtonStatics4> { define_guid(0x1C0AE26A, 0xC755, 0x4FE6, 0xA3, 0xB6, 0xE, 0x33, 0x94, 0xE9, 0x52, 0xC0);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarButton5> { define_guid(0x4096FC7F, 0x1AEC, 0x4B0F, 0xA0, 0x31, 0xCA, 0x8C, 0x4E, 0x6, 0xD2, 0xED);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarToggleButton> { define_guid(0x2E914438, 0xFD53, 0x4B8D, 0x85, 0x8B, 0x36, 0x44, 0x26, 0x9F, 0x8E, 0x4D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarToggleButtonStatics> { define_guid(0xFE5AAF96, 0x7929, 0x4DA1, 0xAA, 0x67, 0xCD, 0xDF, 0x73, 0xA3, 0xE4, 0xB5);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarToggleButtonFactory> { define_guid(0x28AA7D4, 0x8F54, 0x45A6, 0x9F, 0x90, 0x13, 0x60, 0x56, 0x56, 0xD7, 0x93);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarToggleButton3> { define_guid(0xEF9A85E5, 0x16FF, 0x4D72, 0xB9, 0xE8, 0x9B, 0x86, 0x1E, 0xAF, 0x84, 0xA8);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarToggleButtonStatics3> { define_guid(0xBD4C65BF, 0x2EDD, 0x44D1, 0xAC, 0xD5, 0x35, 0xC0, 0xE, 0x2F, 0x21, 0xBC);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarToggleButton4> { define_guid(0xB86B736E, 0x3EAF, 0x4751, 0xA8, 0x97, 0x0, 0x2, 0x9F, 0x1F, 0x6A, 0xCA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarToggleButtonStatics4> { define_guid(0xA478B984, 0xE916, 0x4137, 0xBD, 0xBD, 0x95, 0xBD, 0x46, 0xFF, 0x3C, 0xE6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IAppBarToggleButton5> { define_guid(0x9DCA3357, 0xC130, 0x4FB6, 0xA1, 0xE2, 0xD2, 0xB3, 0x48, 0xFE, 0x43, 0xBE);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGridView> { define_guid(0x26AE934, 0xB67E, 0x4D80, 0x8F, 0x72, 0x8A, 0xA6, 0x4B, 0x4D, 0x82, 0x7B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IGridViewFactory> { define_guid(0xD9BCCA89, 0x9F9, 0x4C6E, 0xA8, 0x3E, 0xF1, 0x99, 0x14, 0x6F, 0xE, 0x7D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListView> { define_guid(0xF6CE8C6D, 0xFE96, 0x41AD, 0xA6, 0x4A, 0xC2, 0xB8, 0x1C, 0x4A, 0xF7, 0xF8);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListViewFactory> { define_guid(0xBDFF696D, 0x3F22, 0x41F9, 0x97, 0xA6, 0x88, 0x31, 0x34, 0xA7, 0x61, 0x13);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewItemFactory> { define_guid(0x4EA32731, 0x568D, 0x4D0D, 0xAD, 0xFD, 0x3D, 0x8D, 0xC5, 0xAA, 0x5D, 0x88);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewItemStatics> { define_guid(0x436795BE, 0x7396, 0x46DC, 0xA2, 0x64, 0x21, 0xC5, 0x65, 0x81, 0xC5, 0xE5);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewItem> { define_guid(0x4E05D3E6, 0x6167, 0x44E7, 0x9C, 0x74, 0x29, 0x1D, 0xDD, 0x6D, 0xF6, 0xEB);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewItemTemplateSettingsFactory> { define_guid(0x11A1953B, 0x31B7, 0x4F40, 0x86, 0x33, 0x2, 0xFC, 0x61, 0x4B, 0x51, 0x8C);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewItemTemplateSettingsStatics> { define_guid(0x55C720A8, 0x70ED, 0x4C21, 0x93, 0xF4, 0x2D, 0x79, 0xC1, 0xA4, 0xA5, 0xF7);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewItemTemplateSettings> { define_guid(0xEC323744, 0xDE31, 0x4936, 0xBF, 0xC2, 0x1C, 0xB3, 0x7B, 0xA1, 0xDC, 0x8);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewFactory> { define_guid(0xCC5267C3, 0x6C69, 0x49CE, 0xB4, 0x45, 0x75, 0x3A, 0xCE, 0xE7, 0x94, 0x8B);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewStatics> { define_guid(0xEF913E08, 0x83F2, 0x4E16, 0xBF, 0xB1, 0x15, 0x77, 0xB9, 0x83, 0x55, 0xF5);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeView> { define_guid(0x9353CC5C, 0xDD6E, 0x453C, 0xAE, 0xDD, 0xC, 0x3A, 0xC9, 0x93, 0x97, 0x8B);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewListFactory> { define_guid(0x288F6232, 0x41D2, 0x46F7, 0xB1, 0xF5, 0x69, 0x1C, 0x62, 0x52, 0x64, 0xB7);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewList> { define_guid(0xF00A54E, 0x99A, 0x47A5, 0xA9, 0x42, 0x94, 0x69, 0x2B, 0x1, 0xF4, 0x52);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewCollapsedEventArgs> { define_guid(0x391DB3B0, 0x1E58, 0x4539, 0x9E, 0x93, 0x38, 0x79, 0x78, 0xF4, 0x6C, 0xCE);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewExpandingEventArgs> { define_guid(0xC5E1FA63, 0x4154, 0x49D2, 0xA2, 0x1F, 0xC3, 0x41, 0x76, 0x60, 0x5E, 0x3A);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewNodeFactory> { define_guid(0x6EC62D90, 0xAA19, 0x414A, 0x8A, 0x45, 0xA, 0x55, 0x89, 0xA8, 0x36, 0xF7);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewNodeStatics> { define_guid(0x5D8276FE, 0xE1D1, 0x4B61, 0x9E, 0x81, 0xC7, 0xFB, 0x18, 0x9A, 0x29, 0x80);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewNode> { define_guid(0xC04C8ED3, 0x9AF2, 0x4E75, 0xA3, 0x29, 0x74, 0x97, 0xA1, 0x10, 0xE7, 0xA8);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs> { define_guid(0x472AB521, 0x242, 0x4290, 0x93, 0x63, 0xAB, 0x4F, 0xE7, 0x4, 0x52, 0x7F);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwipeControlStatics> { define_guid(0xE57AE83C, 0x2216, 0x4717, 0x9E, 0xF6, 0x46, 0x62, 0x33, 0x4C, 0x65, 0x1);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwipeControlFactory> { define_guid(0xC0AAA3AE, 0xD141, 0x4E12, 0xA7, 0x28, 0x5F, 0x95, 0xB5, 0x7, 0xE7, 0xAB);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwipeControl> { define_guid(0x9EE3D96F, 0x6704, 0x4823, 0xAA, 0x15, 0x1C, 0x14, 0x3B, 0xC5, 0x3C, 0xF7);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwipeItemsStatics> { define_guid(0x376250DF, 0x48DB, 0x43E3, 0xB0, 0xE9, 0x8, 0x9E, 0x5D, 0xA9, 0xA1, 0x14);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwipeItemsFactory> { define_guid(0x47C460EE, 0xD5AA, 0x445F, 0xB3, 0x1E, 0x50, 0xC0, 0x76, 0xC0, 0x11, 0xB9);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwipeItems> { define_guid(0xB01726FF, 0x969A, 0x40D0, 0x9F, 0x4, 0x76, 0x8, 0x4C, 0xE6, 0xD7, 0xB7);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwipeItemInvokedEventArgs> { define_guid(0xC5B025F5, 0xCB32, 0x4733, 0x80, 0x11, 0x5D, 0xD, 0x37, 0xF4, 0x55, 0xA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRatingItemInfoFactory> { define_guid(0xB0FD43D6, 0xCFEC, 0x43C8, 0x9A, 0xC5, 0xB, 0xD, 0x5E, 0x25, 0xD8, 0x62);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRatingItemInfo> { define_guid(0x9CCBE6A2, 0x591E, 0x47A0, 0xA3, 0x18, 0x6A, 0x1F, 0x79, 0x47, 0xDA, 0x2D);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRatingItemFontInfoStatics> { define_guid(0xFB214F01, 0x6434, 0x4EEB, 0x82, 0xFF, 0x7C, 0xE5, 0xD4, 0xB, 0xF5, 0x10);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRatingItemFontInfoFactory> { define_guid(0x9603FE56, 0x9E9F, 0x40B5, 0xBA, 0xE1, 0x44, 0x81, 0xBB, 0x73, 0xBC, 0xD3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRatingItemFontInfo> { define_guid(0x54723E9, 0x7989, 0x4D5C, 0x9D, 0x1, 0xA7, 0xEB, 0x87, 0x6F, 0x10, 0x71);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRatingItemImageInfoStatics> { define_guid(0x8438486B, 0x4B1C, 0x4123, 0xBA, 0xB, 0x73, 0x48, 0x4D, 0x68, 0xC3, 0x38);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRatingItemImageInfoFactory> { define_guid(0x269E03F2, 0xDA79, 0x4787, 0x9F, 0x4A, 0x24, 0xA6, 0xFA, 0x56, 0xCD, 0xE2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRatingItemImageInfo> { define_guid(0x25240E8C, 0xE0D2, 0x490E, 0xB8, 0xF8, 0x96, 0xC8, 0xEE, 0x5, 0x12, 0xB9);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwipeItemFactory> { define_guid(0x844BD61A, 0x1716, 0x4097, 0xBB, 0xA2, 0x75, 0x26, 0xDA, 0x22, 0xDE, 0x39);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwipeItemStatics> { define_guid(0xD0B44E96, 0x2766, 0x4D93, 0xB5, 0xDB, 0xF5, 0xE1, 0xBE, 0x83, 0x2C, 0x2D);};
template<> struct uuid<Windows::UI::Xaml::Controls::ISwipeItem> { define_guid(0x836EDADC, 0x45C8, 0x4A00, 0x90, 0xA0, 0x71, 0x7, 0xFA, 0x89, 0x4A, 0x1B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRefreshContainerFactory> { define_guid(0xA04777F, 0x89E, 0x4239, 0xBA, 0xEB, 0xC4, 0x64, 0x14, 0x84, 0xC3, 0x7E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRefreshContainerStatics> { define_guid(0xA20AF5A5, 0x7015, 0x475D, 0x9D, 0xE3, 0x81, 0xA0, 0x47, 0x9D, 0xDA, 0x38);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRefreshContainer> { define_guid(0x535DC413, 0xB1D5, 0x43C1, 0xB0, 0x57, 0x86, 0x58, 0xCE, 0x1E, 0xB, 0xA2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IBitmapIconSource> { define_guid(0xC8E33DC7, 0xD4AE, 0x4A87, 0x94, 0x7F, 0xAC, 0x4D, 0xB, 0xCF, 0x5A, 0xF4);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRefreshRequestedEventArgs> { define_guid(0x1B089F43, 0xCFCF, 0x4AC6, 0xB3, 0x1F, 0x8D, 0xAB, 0x6E, 0xEF, 0xDD, 0x93);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRefreshStateChangedEventArgs> { define_guid(0xBB6C901E, 0x21FE, 0x4109, 0xAF, 0x80, 0x73, 0xEC, 0x66, 0x1B, 0x67, 0x8A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRefreshVisualizerFactory> { define_guid(0x6F5C6132, 0x6E09, 0x4C10, 0x82, 0x4A, 0x12, 0x7D, 0x36, 0x67, 0x27, 0x15);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRefreshVisualizerStatics> { define_guid(0xAFEA56AF, 0x362A, 0x4015, 0xB1, 0x55, 0x73, 0x3A, 0x1F, 0x86, 0x98, 0x31);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRefreshVisualizer> { define_guid(0xC0E30122, 0xF3EB, 0x4BAA, 0xA1, 0x1F, 0xC3, 0xF8, 0x73, 0x42, 0xCB, 0xF4);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRefreshInteractionRatioChangedEventArgs> { define_guid(0xD7E47820, 0xDC47, 0x4B8E, 0xBB, 0x27, 0x7F, 0xA, 0x83, 0xF2, 0x9A, 0x7);};
template<> struct uuid<Windows::UI::Xaml::Controls::IParallaxViewFactory> { define_guid(0xE4EB9642, 0x3E8E, 0x5A26, 0x94, 0xF2, 0x91, 0x21, 0xD1, 0x21, 0xB9, 0x16);};
template<> struct uuid<Windows::UI::Xaml::Controls::IParallaxViewStatics> { define_guid(0x8836E49C, 0xE0E, 0x57D8, 0x93, 0x95, 0xF0, 0xA9, 0xA0, 0xD1, 0xBB, 0x28);};
template<> struct uuid<Windows::UI::Xaml::Controls::IParallaxView> { define_guid(0x6B84FCD4, 0x4083, 0x5B4B, 0xBC, 0x40, 0xD9, 0x20, 0x4E, 0x19, 0xB4, 0x1A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRatingControlStatics> { define_guid(0xD062D399, 0xAD85, 0x4C1C, 0xB2, 0xC4, 0x35, 0xDD, 0x44, 0x32, 0x27, 0x5E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRatingControlFactory> { define_guid(0x18D81716, 0xC542, 0x4CCB, 0xB3, 0x47, 0x5E, 0x62, 0xC5, 0xDB, 0x78, 0x2E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IRatingControl> { define_guid(0xA7D91CA7, 0xE5CF, 0x4963, 0xA2, 0x4E, 0x96, 0x73, 0xFE, 0x5F, 0xFD, 0xD5);};
template<> struct uuid<Windows::UI::Xaml::Controls::IUIElementCollection> { define_guid(0xD6602D54, 0x88F6, 0x43F6, 0x85, 0xD8, 0xA9, 0xD9, 0x14, 0xA6, 0xDD, 0x3B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFocusDisengagedEventArgs> { define_guid(0x5E14280F, 0x953E, 0x4CF8, 0xB9, 0xEA, 0xC5, 0x30, 0xA1, 0xCE, 0x2, 0xAD);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFocusEngagedEventArgs> { define_guid(0xA69FC352, 0xDA66, 0x404C, 0x82, 0x3F, 0x53, 0x58, 0x59, 0x4E, 0x70, 0xBB);};
template<> struct uuid<Windows::UI::Xaml::Controls::IFocusEngagedEventArgs2> { define_guid(0x4A59E0F4, 0x87C0, 0x4CCD, 0x93, 0xC4, 0xA3, 0xA0, 0x1C, 0xE3, 0x92, 0x65);};
template<> struct uuid<Windows::UI::Xaml::Controls::IControlTemplate> { define_guid(0xEFD2418E, 0x41E0, 0x48BB, 0x8B, 0x82, 0x91, 0xED, 0xA1, 0xBA, 0x3F, 0xE2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IColorPickerFactory> { define_guid(0xABAE07FF, 0xAECF, 0x481D, 0x92, 0x4, 0x20, 0x1C, 0x38, 0x94, 0xCD, 0x1B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IColorPickerStatics> { define_guid(0x67CA9BE7, 0x1574, 0x451A, 0xB6, 0xDF, 0xFE, 0x57, 0xD9, 0xD0, 0x7B, 0x46);};
template<> struct uuid<Windows::UI::Xaml::Controls::IColorPicker> { define_guid(0x6232E371, 0x5C64, 0x43CB, 0x8B, 0x35, 0x7F, 0x82, 0xDD, 0xE3, 0x67, 0x40);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPersonPictureStatics> { define_guid(0xDBEC0982, 0x3C10, 0x4639, 0x96, 0x14, 0xAA, 0x5B, 0x7C, 0xDC, 0x32, 0xCA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPersonPictureFactory> { define_guid(0x4F18330D, 0x416, 0x4B92, 0xBF, 0xD3, 0xBF, 0x57, 0x80, 0xB4, 0x6A, 0xB2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPersonPicture> { define_guid(0x6C230B6D, 0xD75, 0x4059, 0x91, 0xBC, 0x7B, 0x17, 0x4D, 0x1D, 0x73, 0x15);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewStatics2> { define_guid(0x8CC50D74, 0x1A42, 0x4852, 0xAB, 0x5A, 0x6D, 0xC8, 0x2F, 0x28, 0xA4, 0xBA);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewStatics> { define_guid(0x363A86C7, 0x72DA, 0x4420, 0xB8, 0x71, 0x15, 0xD9, 0xD0, 0xD4, 0x57, 0x56);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewFactory> { define_guid(0xE50687C1, 0xB7C2, 0x4975, 0xAD, 0x7A, 0x5F, 0x4F, 0xE6, 0xA5, 0x14, 0xC9);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationView2> { define_guid(0x2BE49737, 0x7C13, 0x4C44, 0x86, 0xC3, 0x8B, 0x25, 0xE6, 0x97, 0xA8, 0xE);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationView> { define_guid(0xF209CE15, 0x391A, 0x42CA, 0x9F, 0xC6, 0xF7, 0x9D, 0xA6, 0x5A, 0xCA, 0x32);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewItemBaseFactory> { define_guid(0xEB014CEF, 0x7890, 0x4EBB, 0x82, 0x45, 0x2, 0xE8, 0x51, 0xF, 0x32, 0x1D);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewItemBase> { define_guid(0xEDF04EB1, 0x37D1, 0x471F, 0x85, 0x70, 0x38, 0x29, 0xEE, 0x5B, 0x2B, 0xC6);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewItemStatics> { define_guid(0x803C0081, 0xFDA5, 0x4B90, 0xAA, 0xCE, 0x3F, 0x23, 0x6, 0xDB, 0xE5, 0xC4);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewItemFactory> { define_guid(0x973BDB4A, 0x7E08, 0x4F76, 0x92, 0x3C, 0xF1, 0x2B, 0xD6, 0x85, 0xE8, 0x6E);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewItem> { define_guid(0x8614BE0F, 0xB7B6, 0x4851, 0x96, 0xA, 0xF5, 0xE3, 0xF6, 0x9F, 0x62, 0x4A);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewItemSeparatorFactory> { define_guid(0x71CF3A66, 0xDB86, 0x49E0, 0x81, 0x54, 0x5F, 0xD3, 0x56, 0xAE, 0xDE, 0xC0);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewItemSeparator> { define_guid(0xDE62C951, 0xBB9B, 0x471E, 0x83, 0xE3, 0xAF, 0x47, 0x91, 0xE7, 0x9, 0x6A);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewItemHeaderFactory> { define_guid(0xF3105988, 0x7768, 0x45D3, 0x8B, 0xB0, 0x6D, 0xED, 0x9E, 0x43, 0xA9, 0x8B);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewItemHeader> { define_guid(0xE21DF22C, 0xDA4A, 0x4E74, 0x9F, 0xFC, 0xB1, 0x63, 0xBD, 0x7A, 0xDA, 0xCD);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewListFactory> { define_guid(0xFAEE9541, 0xC3BF, 0x47BF, 0xB9, 0x4, 0x61, 0x55, 0xF4, 0xDF, 0x6B, 0x4F);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewList> { define_guid(0x4F726F85, 0x5CE0, 0x48CD, 0x8E, 0xF2, 0x1A, 0x29, 0x45, 0x8A, 0x34, 0x4);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarIsStencilButtonCheckedChangedEventArgs> { define_guid(0x26EDD26, 0xD32B, 0x4E28, 0xA0, 0x33, 0xD5, 0x9, 0x76, 0x62, 0xB2, 0x92);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarCustomPen> { define_guid(0x4082207B, 0x2F3D, 0x4E6A, 0x8C, 0x27, 0xFE, 0x61, 0xEF, 0x7E, 0x70, 0xEB);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarCustomPenOverrides> { define_guid(0x9D22EB6C, 0x1255, 0x4256, 0xB6, 0xBD, 0x82, 0xC2, 0xFD, 0x27, 0x34, 0x88);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarCustomPenFactory> { define_guid(0xD214D636, 0xF1AA, 0x4F48, 0xBF, 0x2C, 0xA9, 0x26, 0xCA, 0xAE, 0x4C, 0x60);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbar> { define_guid(0x3DDD0CCA, 0x51F0, 0x486F, 0xA0, 0x3E, 0x4E, 0xE1, 0x3D, 0xC1, 0x2B, 0xCB);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarStatics> { define_guid(0xA3B493BB, 0xCB4F, 0x4E6B, 0xA3, 0x3D, 0xF1, 0x1E, 0x7A, 0x29, 0x5E, 0xFA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarFactory> { define_guid(0x3947AA99, 0x36B1, 0x4374, 0xAB, 0x5C, 0x98, 0xBF, 0x7, 0xA4, 0x32, 0xB);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbar2> { define_guid(0x86F0C111, 0xB484, 0x454A, 0xAE, 0x78, 0x1D, 0x25, 0xA3, 0x3D, 0x1C, 0x67);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarStatics2> { define_guid(0xAAC1F8F2, 0x2C1F, 0x4E9C, 0xB3, 0xF3, 0x31, 0xFF, 0x22, 0xB5, 0x1C, 0x7A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarPenConfigurationControl> { define_guid(0x601AE5F6, 0x28A5, 0x44CC, 0x89, 0xA6, 0x38, 0xE, 0x91, 0xA5, 0x72, 0xDD);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarPenConfigurationControlStatics> { define_guid(0x48A61BEF, 0x19CE, 0x41BB, 0xAB, 0xE0, 0x7C, 0x87, 0x26, 0xFA, 0xE7, 0x5E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarPenConfigurationControlFactory> { define_guid(0x67F065EE, 0xF5E7, 0x46EB, 0x91, 0x87, 0x8D, 0x3C, 0xA3, 0xAF, 0x89, 0x1B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarFlyoutItem> { define_guid(0x92B68786, 0x37EE, 0x4915, 0x9E, 0x89, 0xE1, 0x87, 0x56, 0x4A, 0x88, 0x9A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarFlyoutItemFactory> { define_guid(0x352E7B93, 0x803B, 0x4F0E, 0x8C, 0x72, 0x9D, 0xFC, 0x3, 0x29, 0x32, 0x9F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarFlyoutItemStatics> { define_guid(0x1FE54B64, 0x4063, 0x4A5F, 0xB8, 0x9C, 0x9F, 0x58, 0x93, 0x5E, 0xE3, 0x79);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarMenuButton> { define_guid(0x860ECAE5, 0x7633, 0x4EA1, 0xA2, 0x9, 0x50, 0x39, 0x2D, 0x1A, 0xEB, 0xD1);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarMenuButtonFactory> { define_guid(0x7A463A9D, 0x5DC7, 0x44A7, 0xAF, 0xD0, 0x2B, 0x68, 0x5C, 0xB9, 0xA9, 0x6C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarMenuButtonStatics> { define_guid(0xF03B17A6, 0xB8B0, 0x4A87, 0xA9, 0x61, 0x37, 0xCD, 0x5, 0xD8, 0x31, 0x37);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarStencilButton> { define_guid(0x306A2616, 0x5B40, 0x4BF3, 0x92, 0xB7, 0xF1, 0xDF, 0x93, 0x6A, 0xEF, 0xF5);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarStencilButtonFactory> { define_guid(0xA20701D1, 0x8A70, 0x4D77, 0x89, 0xD4, 0x17, 0x30, 0xA3, 0xA5, 0x8E, 0xDF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarStencilButtonStatics> { define_guid(0x4748C07F, 0x63E4, 0x420D, 0x93, 0x9A, 0x6B, 0x72, 0x43, 0xE9, 0xD1, 0x24);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarToggleButton> { define_guid(0xB4A278FA, 0xF5F0, 0x4B1F, 0xBE, 0xB0, 0xB, 0x8A, 0x29, 0x90, 0x5A, 0x4A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarToggleButtonFactory> { define_guid(0xB2F90710, 0xE5A1, 0x4365, 0x9D, 0x1A, 0xE5, 0xB7, 0xAD, 0x8B, 0x96, 0x68);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarToolButton> { define_guid(0x5C5AF41E, 0xCCB7, 0x4458, 0x80, 0x64, 0xA9, 0x84, 0x9D, 0x31, 0x56, 0x1B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarToolButtonFactory> { define_guid(0x6293BF4B, 0x89FE, 0x4ED0, 0xA1, 0xA6, 0x88, 0xD3, 0xEB, 0xA9, 0x17, 0xB2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarToolButtonStatics> { define_guid(0x9E097D18, 0xD136, 0x4EF6, 0xB0, 0xFD, 0x1A, 0x78, 0xC2, 0x88, 0x4A, 0x1);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarCustomToggleButton> { define_guid(0x550C4D84, 0x4F54, 0x4FBE, 0xB1, 0x2B, 0xE0, 0xA5, 0xA, 0xAB, 0xD, 0x5);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarCustomToggleButtonFactory> { define_guid(0x4A00374D, 0x4CD2, 0x4ED9, 0x86, 0x3E, 0x83, 0xB8, 0xCF, 0x3F, 0xD2, 0xAF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarCustomToolButton> { define_guid(0x9F98ACD7, 0xC605, 0x4105, 0xBE, 0x10, 0x39, 0x43, 0xA7, 0xC0, 0xDA, 0x3C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarCustomToolButtonStatics> { define_guid(0x11FE4CB9, 0xBBAC, 0x4314, 0x93, 0x44, 0x92, 0xC6, 0x69, 0x3D, 0xDE, 0xAF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarCustomToolButtonFactory> { define_guid(0xC295FE4E, 0x30EB, 0x4130, 0xA6, 0xB6, 0x8C, 0x85, 0xD8, 0xE2, 0x6E, 0x89);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarEraserButton> { define_guid(0x4CBDB92E, 0x5F5E, 0x4B35, 0xA4, 0x1C, 0x16, 0xFF, 0xB0, 0x28, 0x3B, 0xC0);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarEraserButtonFactory> { define_guid(0xFD40611D, 0xD1BA, 0x4D67, 0xAF, 0x0, 0x14, 0x80, 0x36, 0xAD, 0x49, 0x2C);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarEraserButton2> { define_guid(0xE7A59257, 0x5AE8, 0x436D, 0xB2, 0xE2, 0x93, 0xC2, 0x0, 0x90, 0xC, 0xA0);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarEraserButtonStatics2> { define_guid(0x38A1736, 0xC5CD, 0x4311, 0x83, 0xF4, 0x38, 0xCB, 0xF0, 0x7C, 0x20, 0x66);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarPenButton> { define_guid(0xE0B80C21, 0xB032, 0x40EE, 0xA2, 0xB9, 0x50, 0x7F, 0x6C, 0xCB, 0x82, 0x7B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarPenButtonFactory> { define_guid(0xB1463D21, 0x59CB, 0x4A83, 0x92, 0xE1, 0x69, 0x28, 0x42, 0x79, 0x7B, 0x2E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarPenButtonStatics> { define_guid(0xB922CE42, 0x9F0, 0x453D, 0x80, 0x26, 0x44, 0xDA, 0xF2, 0x75, 0x3F, 0x65);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarRulerButton> { define_guid(0x4A992832, 0x1984, 0x4148, 0x9F, 0x25, 0x38, 0x2B, 0x35, 0xDB, 0x8, 0x7F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarRulerButtonStatics> { define_guid(0xBAE75F65, 0xBE30, 0x4BEE, 0x96, 0x4B, 0xFF, 0x9E, 0x49, 0x8F, 0xEE, 0x37);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarRulerButtonFactory> { define_guid(0xBB26D85F, 0xCFD6, 0x495F, 0x93, 0xAB, 0xB8, 0x56, 0x6A, 0xF9, 0xF8, 0xAF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarBallpointPenButton> { define_guid(0x158329F8, 0x1E99, 0x3ACC, 0x91, 0xF, 0x9D, 0xA2, 0xD8, 0x72, 0xAE, 0x12);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarBallpointPenButtonFactory> { define_guid(0x2F0BD3E4, 0xD754, 0x4255, 0x8E, 0xC4, 0x0, 0xCD, 0x10, 0x12, 0x96, 0xAB);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarCustomPenButton> { define_guid(0x46024401, 0x2B2A, 0x4F3C, 0xA5, 0x3C, 0x1A, 0x4, 0x5A, 0x40, 0x8E, 0xFA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarCustomPenButtonStatics> { define_guid(0x373C25F4, 0xE555, 0x4E85, 0xA8, 0xD, 0xDA, 0x6B, 0x84, 0x33, 0xDB, 0xDE);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarCustomPenButtonFactory> { define_guid(0xF2EF0BA, 0xC8B9, 0x4C36, 0x89, 0x87, 0x94, 0xD3, 0xDA, 0xFE, 0xDE, 0x18);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarHighlighterButton> { define_guid(0xB3CC15B, 0x7ABF, 0x487E, 0xAC, 0xC1, 0x5B, 0x50, 0x48, 0xFE, 0xE6, 0xD2);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarHighlighterButtonFactory> { define_guid(0x7C334ADD, 0x42CA, 0x4943, 0x94, 0xA4, 0x23, 0xB5, 0xA6, 0xE5, 0x5C, 0xF1);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarPencilButton> { define_guid(0x5B112832, 0x1984, 0x4148, 0x9F, 0x25, 0x38, 0x2B, 0x35, 0xDB, 0x8, 0x7F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IInkToolbarPencilButtonFactory> { define_guid(0xDB66D85F, 0xCFD6, 0x495F, 0x93, 0xAB, 0xB8, 0x56, 0x6A, 0xF9, 0xF8, 0xAF);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPivotItemEventArgs> { define_guid(0x1A6F7254, 0x1ED5, 0x4BC5, 0xA0, 0x60, 0x65, 0x55, 0x30, 0xBC, 0xA6, 0xBA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDatePickedEventArgs> { define_guid(0xA1527B12, 0x59C1, 0x4521, 0xB2, 0x8C, 0xB1, 0x76, 0x67, 0x5E, 0x7C, 0x5A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDatePickerFlyoutItem> { define_guid(0x9D9BC289, 0xD2, 0x4AAC, 0x9C, 0x85, 0xD7, 0x4F, 0x6, 0x36, 0x78, 0x87);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDatePickerFlyoutItemStatics> { define_guid(0xAA9C91DA, 0x7F6, 0x4CDF, 0x89, 0xB4, 0xDD, 0xA3, 0xBD, 0xB0, 0xEA, 0x6B);};
template<> struct uuid<Windows::UI::Xaml::Controls::IItemsPickedEventArgs> { define_guid(0xF95B9AAC, 0xA621, 0x488E, 0x91, 0x56, 0x8E, 0xE3, 0x11, 0x65, 0xBE, 0x4);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPickerConfirmedEventArgs> { define_guid(0x447A9B51, 0x1E23, 0x4779, 0x99, 0x2B, 0x98, 0x68, 0x49, 0x71, 0x39, 0x41);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITimePickedEventArgs> { define_guid(0x8AD3FF21, 0x5F66, 0x4785, 0xB9, 0x99, 0x24, 0xFE, 0xF3, 0x9F, 0xB6, 0xDB);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDatePickerFlyout> { define_guid(0xFBF33B1A, 0xA3A4, 0x4DF8, 0x92, 0x28, 0x23, 0xA5, 0xAC, 0x27, 0xDF, 0x4E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDatePickerFlyoutStatics> { define_guid(0xCD570377, 0x5845, 0x4C12, 0x8C, 0x10, 0x59, 0x2D, 0x9F, 0xCC, 0x7C, 0xD9);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDatePickerFlyout2> { define_guid(0xCFB18DBB, 0x9931, 0x4119, 0x8B, 0xDA, 0x54, 0xA8, 0x6F, 0xDF, 0xAC, 0x84);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDatePickerFlyoutStatics2> { define_guid(0xAFD3E569, 0x81E6, 0x4B54, 0x84, 0xA9, 0x68, 0x7, 0x9B, 0x73, 0xE3, 0x4E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListPickerFlyout> { define_guid(0xF0CB9D7, 0xE5F3, 0x45E6, 0x90, 0x63, 0xFF, 0x7B, 0xBB, 0x19, 0x3C, 0x47);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListPickerFlyoutStatics> { define_guid(0xFEE25B97, 0x8B96, 0x4602, 0x81, 0xD2, 0x82, 0xFD, 0x8E, 0xF, 0x7E, 0xA8);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPickerFlyout> { define_guid(0xA336FFDB, 0x8D9, 0x43E6, 0x94, 0x4E, 0xF2, 0xE5, 0xC7, 0xCE, 0xE6, 0x30);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPickerFlyoutStatics> { define_guid(0xAF18A436, 0xF38A, 0x4ABD, 0xB9, 0x33, 0x62, 0x86, 0xC1, 0x15, 0xB0, 0x7F);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITimePickerFlyout> { define_guid(0xBB739D75, 0xE836, 0x439E, 0x86, 0xD5, 0x50, 0x6D, 0x2D, 0x18, 0xE4, 0x4);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITimePickerFlyoutStatics> { define_guid(0x3F6728CE, 0x2169, 0x4003, 0xB4, 0xA8, 0x8D, 0xE7, 0x3, 0x5A, 0xA, 0xD6);};
template<> struct uuid<Windows::UI::Xaml::Controls::IDatePickerFlyoutPresenter> { define_guid(0x7C62F70E, 0x2DDC, 0x4381, 0x83, 0x2F, 0x54, 0xCB, 0xDF, 0xAA, 0x84, 0x9A);};
template<> struct uuid<Windows::UI::Xaml::Controls::IListPickerFlyoutPresenter> { define_guid(0x68155FB3, 0x883E, 0x417A, 0x80, 0xD0, 0xE2, 0xFD, 0x88, 0x41, 0x0, 0x84);};
template<> struct uuid<Windows::UI::Xaml::Controls::ITimePickerFlyoutPresenter> { define_guid(0xC5320638, 0x7A18, 0x40ED, 0x9F, 0xD0, 0x4C, 0x85, 0x2C, 0x9, 0xB2, 0x4E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPickerFlyoutPresenter> { define_guid(0x5884C978, 0x6B27, 0x4B38, 0xA9, 0xAE, 0x67, 0x7C, 0x29, 0x94, 0x65, 0x2E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPivot> { define_guid(0x103E9B13, 0x3400, 0x4A16, 0x90, 0xB9, 0x69, 0x12, 0xBF, 0x6, 0x97, 0x4E);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPivotStatics> { define_guid(0xEE22C7F4, 0xC15D, 0x4FF3, 0x8A, 0x94, 0xF5, 0xD, 0xFD, 0xFB, 0xE8, 0x99);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPivotFactory> { define_guid(0x1B0A818E, 0x2529, 0x4762, 0xBA, 0x44, 0x9A, 0xBC, 0x68, 0xC3, 0xCE, 0xCA);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPivot2> { define_guid(0x8B8A8660, 0x1A55, 0x411C, 0xA8, 0x2D, 0x18, 0x99, 0x1C, 0x3F, 0xD, 0x6F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPivotStatics2> { define_guid(0xD7518ADD, 0xBE75, 0x4023, 0x8D, 0xEB, 0xC6, 0x51, 0x3C, 0x31, 0x92, 0xA3);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPivot3> { define_guid(0x95BCBF96, 0xF0DA, 0x4089, 0x8C, 0x65, 0xE8, 0xB8, 0x13, 0x54, 0xC7, 0x66);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPivotStatics3> { define_guid(0x78B6274E, 0x6616, 0x4600, 0xA0, 0x39, 0x92, 0x2A, 0x5D, 0x9, 0x33, 0xB);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPivotItem> { define_guid(0xA4764371, 0xA502, 0x47A3, 0x91, 0x5E, 0x4A, 0xA0, 0x96, 0xDA, 0xF8, 0x7F);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPivotItemFactory> { define_guid(0xDCED981, 0x636E, 0x4A34, 0x8A, 0x3F, 0x8E, 0xE0, 0x18, 0x63, 0x92, 0x85);};
template<> struct uuid<Windows::UI::Xaml::Controls::IPivotItemStatics> { define_guid(0xE147AD0C, 0x488B, 0x4A6E, 0xBE, 0xCD, 0xA5, 0xDB, 0xD9, 0x94, 0x17, 0x54);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewBackRequestedEventArgs> { define_guid(0x446700E1, 0x9A9D, 0x4500, 0xA7, 0x1D, 0x25, 0xC1, 0x58, 0x9, 0xB8, 0x79);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewPaneClosingEventArgs> { define_guid(0x955575BA, 0x75F5, 0x432D, 0xB4, 0x9B, 0x60, 0xE4, 0x75, 0x52, 0xD5, 0xEE);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs> { define_guid(0x29496822, 0x55D2, 0x49FA, 0x96, 0x4B, 0xF1, 0xDB, 0xAF, 0xEF, 0x85, 0xC4);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs> { define_guid(0x5AA509A0, 0x3A5E, 0x4F54, 0x89, 0x6C, 0x98, 0xB8, 0x5F, 0x81, 0x95, 0x8);};
template<> struct uuid<Windows::UI::Xaml::Controls::INavigationViewDisplayModeChangedEventArgs> { define_guid(0xB7C1AD35, 0x5544, 0x40C1, 0x9B, 0x33, 0xAC, 0xFE, 0x1D, 0x6C, 0x80, 0x94);};
template<> struct uuid<Windows::UI::Xaml::Controls::IColorChangedEventArgs> { define_guid(0x34F7201F, 0xAAD0, 0x4C3A, 0xB9, 0x7B, 0x2A, 0xBF, 0x36, 0x45, 0x55, 0x39);};

// types

namespace Windows { namespace UI { namespace Xaml { namespace Controls { namespace Primitives {

// IPivotHeaderPanel
struct IPivotHeaderPanel : IInspectable, generate<IPivotHeaderPanel> {};
}

// ICanvasFactory
struct ICanvasFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Canvas* *instance);
};

// ICanvasStatics
struct ICanvasStatics : IInspectable {
	virtual STDMETHODIMP _get_LeftProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetLeft(UIElement* element, double *length);
	virtual STDMETHODIMP _SetLeft(UIElement* element, double length);
	virtual STDMETHODIMP _get_TopProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetTop(UIElement* element, double *length);
	virtual STDMETHODIMP _SetTop(UIElement* element, double length);
	virtual STDMETHODIMP _get_ZIndexProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetZIndex(UIElement* element, int *value);
	virtual STDMETHODIMP _SetZIndex(UIElement* element, int value);
};

// ICanvas
struct ICanvas : IInspectable, generate<ICanvas> {};

// IPanelFactory
struct IPanelFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Panel* *instance);
};

// IPanelStatics
struct IPanelStatics : IInspectable {
	virtual STDMETHODIMP _get_BackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsItemsHostProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ChildrenTransitionsProperty(DependencyProperty* *value);
};

// IPanel
struct IPanel_raw : IInspectable {
	virtual STDMETHODIMP _get_Children(UIElementCollection* *value);
	virtual STDMETHODIMP _get_Background(Media::Brush* *value);
	virtual STDMETHODIMP _put_Background(Media::Brush* value);
	virtual STDMETHODIMP _get_IsItemsHost(bool *value);
	virtual STDMETHODIMP _get_ChildrenTransitions(Media::Animation::TransitionCollection* *value);
	virtual STDMETHODIMP _put_ChildrenTransitions(Media::Animation::TransitionCollection* value);
};
template<typename X> struct IPanel_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IPanel_adaptor::Background)->_get_Background(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IPanel_adaptor::Background)->_put_Background(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Background;
		struct : property {
			ptr<UIElementCollection> get() { UIElementCollection* value; hrcheck(enc(&IPanel_adaptor::Children)->_get_Children(&value)); return from_abi(value); }
			ptr<UIElementCollection> operator()() { return get(); }
			operator ptr<UIElementCollection> () { return get(); }
			ptr<UIElementCollection> operator->() { return get(); }
		} Children;
		struct : property {
			ptr<Media::Animation::TransitionCollection> get() { Media::Animation::TransitionCollection* value; hrcheck(enc(&IPanel_adaptor::ChildrenTransitions)->_get_ChildrenTransitions(&value)); return from_abi(value); }
			ptr<Media::Animation::TransitionCollection> operator()() { return get(); }
			operator ptr<Media::Animation::TransitionCollection> () { return get(); }
			ptr<Media::Animation::TransitionCollection> operator->() { return get(); }
			void put(pptr<Media::Animation::TransitionCollection> value) { hrcheck(enc(&IPanel_adaptor::ChildrenTransitions)->_put_ChildrenTransitions(value)); }
			void operator=(pptr<Media::Animation::TransitionCollection> value) { put(value); }
			void operator()(pptr<Media::Animation::TransitionCollection> value) { put(value); }
		} ChildrenTransitions;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPanel_adaptor::IsItemsHost)->_get_IsItemsHost(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsItemsHost;
	};
	IPanel_adaptor() {}
};
template<typename X> struct adapt<IPanel, X> : Windows::UI::Xaml::Controls::IPanel_adaptor<X> { typedef adapt IPanel; };
struct IPanel : IPanel_raw, generate<IPanel> {};

// Panel
template<typename> struct Panel_statics {
	static struct _BackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Panel, IPanelStatics>()->_get_BackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BackgroundProperty;
	static struct _ChildrenTransitionsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Panel, IPanelStatics>()->_get_ChildrenTransitionsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ChildrenTransitionsProperty;
	static struct _IsItemsHostProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Panel, IPanelStatics>()->_get_IsItemsHostProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsItemsHostProperty;
};
template<typename X> typename Panel_statics<X>::_BackgroundProperty Panel_statics<X>::BackgroundProperty;
template<typename X> typename Panel_statics<X>::_ChildrenTransitionsProperty Panel_statics<X>::ChildrenTransitionsProperty;
template<typename X> typename Panel_statics<X>::_IsItemsHostProperty Panel_statics<X>::IsItemsHostProperty;

template<typename X> struct statics<Panel, X> : X, Windows::UI::Xaml::Controls::Panel_statics<void> {
	typedef typename X::root_type Panel;
};
struct Panel : generate<Panel> {};

// Canvas
template<typename> struct Canvas_statics {
	static struct _LeftProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Canvas, ICanvasStatics>()->_get_LeftProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LeftProperty;
	static struct _TopProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Canvas, ICanvasStatics>()->_get_TopProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TopProperty;
	static struct _ZIndexProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Canvas, ICanvasStatics>()->_get_ZIndexProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ZIndexProperty;
	static double GetLeft(pptr<UIElement> element) { double length; hrcheck(get_activation_factory<Canvas, ICanvasStatics>()->_GetLeft(element, &length)); return length; }
	static void SetLeft(pptr<UIElement> element, double length) { hrcheck(get_activation_factory<Canvas, ICanvasStatics>()->_SetLeft(element, length)); }
	static double GetTop(pptr<UIElement> element) { double length; hrcheck(get_activation_factory<Canvas, ICanvasStatics>()->_GetTop(element, &length)); return length; }
	static void SetTop(pptr<UIElement> element, double length) { hrcheck(get_activation_factory<Canvas, ICanvasStatics>()->_SetTop(element, length)); }
	static int GetZIndex(pptr<UIElement> element) { int value; hrcheck(get_activation_factory<Canvas, ICanvasStatics>()->_GetZIndex(element, &value)); return value; }
	static void SetZIndex(pptr<UIElement> element, int value) { hrcheck(get_activation_factory<Canvas, ICanvasStatics>()->_SetZIndex(element, value)); }
	static Canvas *activate(object_ref outer, IInspectable* *inner) { Canvas *instance; hrcheck(get_activation_factory<Canvas, ICanvasFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename Canvas_statics<X>::_LeftProperty Canvas_statics<X>::LeftProperty;
template<typename X> typename Canvas_statics<X>::_TopProperty Canvas_statics<X>::TopProperty;
template<typename X> typename Canvas_statics<X>::_ZIndexProperty Canvas_statics<X>::ZIndexProperty;

template<typename X> struct statics<Canvas, X> : X, Windows::UI::Xaml::Controls::Canvas_statics<void> {
	using Windows::UI::Xaml::Controls::Canvas_statics<void>::activate;
	typedef typename X::root_type Canvas;
};
struct Canvas : generate<Canvas> {};
namespace Primitives {

// PivotHeaderPanel
template<typename X> struct statics<PivotHeaderPanel, X> : X {
	typedef typename X::root_type PivotHeaderPanel;
};
struct PivotHeaderPanel : generate<PivotHeaderPanel> {};

// IPivotHeaderItemFactory
struct IPivotHeaderItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, PivotHeaderItem* *instance);
};

// IPivotHeaderItem
struct IPivotHeaderItem : IInspectable, generate<IPivotHeaderItem> {};
}

// IContentControlFactory
struct IContentControlFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ContentControl* *instance);
};

// IContentControlStatics
struct IContentControlStatics : IInspectable {
	virtual STDMETHODIMP _get_ContentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentTemplateSelectorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentTransitionsProperty(DependencyProperty* *value);
};

// IContentControl2
struct IContentControl2_raw : IInspectable {
	virtual STDMETHODIMP _get_ContentTemplateRoot(UIElement* *value);
};
template<typename X> struct IContentControl2_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IContentControl2_adaptor::ContentTemplateRoot)->_get_ContentTemplateRoot(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
		} ContentTemplateRoot;
	};
	IContentControl2_adaptor() {}
};
template<typename X> struct adapt<IContentControl2, X> : Windows::UI::Xaml::Controls::IContentControl2_adaptor<X> { typedef adapt IContentControl2; };
struct IContentControl2 : IContentControl2_raw, generate<IContentControl2> {};

// IContentControlOverrides
struct IContentControlOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnContentChanged(IInspectable* oldContent, IInspectable* newContent) = 0;
	virtual STDMETHODIMP _OnContentTemplateChanged(DataTemplate* oldContentTemplate, DataTemplate* newContentTemplate) = 0;
	virtual STDMETHODIMP _OnContentTemplateSelectorChanged(DataTemplateSelector* oldContentTemplateSelector, DataTemplateSelector* newContentTemplateSelector) = 0;
};
template<typename X> struct IContentControlOverrides_adaptor : X {
	void OnContentChanged(object_ref oldContent, object_ref newContent) { hrcheck(X::get()->_OnContentChanged(oldContent, newContent)); }
	void OnContentTemplateChanged(pptr<DataTemplate> oldContentTemplate, pptr<DataTemplate> newContentTemplate) { hrcheck(X::get()->_OnContentTemplateChanged(oldContentTemplate, newContentTemplate)); }
	void OnContentTemplateSelectorChanged(pptr<DataTemplateSelector> oldContentTemplateSelector, pptr<DataTemplateSelector> newContentTemplateSelector) { hrcheck(X::get()->_OnContentTemplateSelectorChanged(oldContentTemplateSelector, newContentTemplateSelector)); }
};
template<typename X> struct adapt<IContentControlOverrides, X> : Windows::UI::Xaml::Controls::IContentControlOverrides_adaptor<X> { typedef adapt IContentControlOverrides; };
template<typename X> struct IContentControlOverrides_unadaptor : X {
	STDMETHODIMP _OnContentChanged(IInspectable* oldContent, IInspectable* newContent) { return hrtry([&, this] { X::get()->OnContentChanged(oldContent, newContent); }); }
	STDMETHODIMP _OnContentTemplateChanged(DataTemplate* oldContentTemplate, DataTemplate* newContentTemplate) { return hrtry([&, this] { X::get()->OnContentTemplateChanged(oldContentTemplate, newContentTemplate); }); }
	STDMETHODIMP _OnContentTemplateSelectorChanged(DataTemplateSelector* oldContentTemplateSelector, DataTemplateSelector* newContentTemplateSelector) { return hrtry([&, this] { X::get()->OnContentTemplateSelectorChanged(oldContentTemplateSelector, newContentTemplateSelector); }); }
};
template<typename X> struct unadapt<IContentControlOverrides, X> : Windows::UI::Xaml::Controls::IContentControlOverrides_unadaptor<X> {};
struct IContentControlOverrides : IContentControlOverrides_raw, generate<IContentControlOverrides> {};

// IContentControl
struct IContentControl_raw : IInspectable {
	virtual STDMETHODIMP _get_Content(IInspectable* *value);
	virtual STDMETHODIMP _put_Content(IInspectable* value);
	virtual STDMETHODIMP _get_ContentTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_ContentTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_ContentTemplateSelector(DataTemplateSelector* *value);
	virtual STDMETHODIMP _put_ContentTemplateSelector(DataTemplateSelector* value);
	virtual STDMETHODIMP _get_ContentTransitions(Media::Animation::TransitionCollection* *value);
	virtual STDMETHODIMP _put_ContentTransitions(Media::Animation::TransitionCollection* value);
};
template<typename X> struct IContentControl_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IContentControl_adaptor::Content)->_get_Content(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IContentControl_adaptor::Content)->_put_Content(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Content;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IContentControl_adaptor::ContentTemplate)->_get_ContentTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IContentControl_adaptor::ContentTemplate)->_put_ContentTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} ContentTemplate;
		struct : property {
			ptr<DataTemplateSelector> get() { DataTemplateSelector* value; hrcheck(enc(&IContentControl_adaptor::ContentTemplateSelector)->_get_ContentTemplateSelector(&value)); return from_abi(value); }
			ptr<DataTemplateSelector> operator()() { return get(); }
			operator ptr<DataTemplateSelector> () { return get(); }
			ptr<DataTemplateSelector> operator->() { return get(); }
			void put(pptr<DataTemplateSelector> value) { hrcheck(enc(&IContentControl_adaptor::ContentTemplateSelector)->_put_ContentTemplateSelector(value)); }
			void operator=(pptr<DataTemplateSelector> value) { put(value); }
			void operator()(pptr<DataTemplateSelector> value) { put(value); }
		} ContentTemplateSelector;
		struct : property {
			ptr<Media::Animation::TransitionCollection> get() { Media::Animation::TransitionCollection* value; hrcheck(enc(&IContentControl_adaptor::ContentTransitions)->_get_ContentTransitions(&value)); return from_abi(value); }
			ptr<Media::Animation::TransitionCollection> operator()() { return get(); }
			operator ptr<Media::Animation::TransitionCollection> () { return get(); }
			ptr<Media::Animation::TransitionCollection> operator->() { return get(); }
			void put(pptr<Media::Animation::TransitionCollection> value) { hrcheck(enc(&IContentControl_adaptor::ContentTransitions)->_put_ContentTransitions(value)); }
			void operator=(pptr<Media::Animation::TransitionCollection> value) { put(value); }
			void operator()(pptr<Media::Animation::TransitionCollection> value) { put(value); }
		} ContentTransitions;
	};
	IContentControl_adaptor() {}
};
template<typename X> struct adapt<IContentControl, X> : Windows::UI::Xaml::Controls::IContentControl_adaptor<X> { typedef adapt IContentControl; };
struct IContentControl : IContentControl_raw, generate<IContentControl> {};

// IControlStatics5
struct IControlStatics5 : IInspectable {
	virtual STDMETHODIMP _get_DefaultStyleResourceUriProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsTemplateKeyTipTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsTemplateKeyTipTarget(DependencyObject* element, bool *value);
	virtual STDMETHODIMP _SetIsTemplateKeyTipTarget(DependencyObject* element, bool value);
};

// IControlStatics4
struct IControlStatics4 : IInspectable {
	virtual STDMETHODIMP _get_IsFocusEngagementEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsFocusEngagedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RequiresPointerProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_XYFocusLeftProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_XYFocusRightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_XYFocusUpProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_XYFocusDownProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ElementSoundModeProperty(DependencyProperty* *value);
};

// IControlStatics3
struct IControlStatics3 : IInspectable {
	virtual STDMETHODIMP _get_UseSystemFocusVisualsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsTemplateFocusTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsTemplateFocusTarget(FrameworkElement* element, bool *value);
	virtual STDMETHODIMP _SetIsTemplateFocusTarget(FrameworkElement* element, bool value);
};

// IControlStatics2
struct IControlStatics2 : IInspectable {
	virtual STDMETHODIMP _get_IsTextScaleFactorEnabledProperty(DependencyProperty* *value);
};

// IControlFactory
struct IControlFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Control* *instance);
};

// IControlStatics
struct IControlStatics : IInspectable {
	virtual STDMETHODIMP _get_FontSizeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontFamilyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontWeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontStretchProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CharacterSpacingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ForegroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsTabStopProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TabIndexProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TabNavigationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PaddingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalContentAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalContentAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BorderThicknessProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DefaultStyleKeyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FocusStateProperty(DependencyProperty* *value);
};

// IControlOverrides6
struct IControlOverrides6_raw : IInspectable {
	virtual STDMETHODIMP _OnPreviewKeyDown(Input::KeyRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnPreviewKeyUp(Input::KeyRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnCharacterReceived(Input::CharacterReceivedRoutedEventArgs* e) = 0;
};
template<typename X> struct IControlOverrides6_adaptor : X {
	void OnPreviewKeyDown(pptr<Input::KeyRoutedEventArgs> e) { hrcheck(X::get()->_OnPreviewKeyDown(e)); }
	void OnPreviewKeyUp(pptr<Input::KeyRoutedEventArgs> e) { hrcheck(X::get()->_OnPreviewKeyUp(e)); }
	void OnCharacterReceived(pptr<Input::CharacterReceivedRoutedEventArgs> e) { hrcheck(X::get()->_OnCharacterReceived(e)); }
};
template<typename X> struct adapt<IControlOverrides6, X> : Windows::UI::Xaml::Controls::IControlOverrides6_adaptor<X> { typedef adapt IControlOverrides6; };
template<typename X> struct IControlOverrides6_unadaptor : X {
	STDMETHODIMP _OnPreviewKeyDown(Input::KeyRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnPreviewKeyDown(e); }); }
	STDMETHODIMP _OnPreviewKeyUp(Input::KeyRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnPreviewKeyUp(e); }); }
	STDMETHODIMP _OnCharacterReceived(Input::CharacterReceivedRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnCharacterReceived(e); }); }
};
template<typename X> struct unadapt<IControlOverrides6, X> : Windows::UI::Xaml::Controls::IControlOverrides6_unadaptor<X> {};
struct IControlOverrides6 : IControlOverrides6_raw, generate<IControlOverrides6> {};

// IControl5
struct IControl5_raw : IInspectable {
	virtual STDMETHODIMP _get_DefaultStyleResourceUri(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_DefaultStyleResourceUri(Foundation::Uri* value);
};
template<typename X> struct IControl5_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IControl5_adaptor::DefaultStyleResourceUri)->_get_DefaultStyleResourceUri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IControl5_adaptor::DefaultStyleResourceUri)->_put_DefaultStyleResourceUri(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} DefaultStyleResourceUri;
	};
	IControl5_adaptor() {}
};
template<typename X> struct adapt<IControl5, X> : Windows::UI::Xaml::Controls::IControl5_adaptor<X> { typedef adapt IControl5; };
struct IControl5 : IControl5_raw, generate<IControl5> {};

// IControl4
struct IControl4_raw : IInspectable {
	virtual STDMETHODIMP _get_IsFocusEngagementEnabled(bool *value);
	virtual STDMETHODIMP _put_IsFocusEngagementEnabled(bool value);
	virtual STDMETHODIMP _get_IsFocusEngaged(bool *value);
	virtual STDMETHODIMP _put_IsFocusEngaged(bool value);
	virtual STDMETHODIMP _get_RequiresPointer(Controls::RequiresPointer *value);
	virtual STDMETHODIMP _put_RequiresPointer(Controls::RequiresPointer value);
	virtual STDMETHODIMP _get_XYFocusLeft(DependencyObject* *value);
	virtual STDMETHODIMP _put_XYFocusLeft(DependencyObject* value);
	virtual STDMETHODIMP _get_XYFocusRight(DependencyObject* *value);
	virtual STDMETHODIMP _put_XYFocusRight(DependencyObject* value);
	virtual STDMETHODIMP _get_XYFocusUp(DependencyObject* *value);
	virtual STDMETHODIMP _put_XYFocusUp(DependencyObject* value);
	virtual STDMETHODIMP _get_XYFocusDown(DependencyObject* *value);
	virtual STDMETHODIMP _put_XYFocusDown(DependencyObject* value);
	virtual STDMETHODIMP _get_ElementSoundMode(Xaml::ElementSoundMode *value);
	virtual STDMETHODIMP _put_ElementSoundMode(Xaml::ElementSoundMode value);
	virtual STDMETHODIMP _add_FocusEngaged(Foundation::TypedEventHandler<Control*, FocusEngagedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_FocusEngaged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_FocusDisengaged(Foundation::TypedEventHandler<Control*, FocusDisengagedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_FocusDisengaged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _RemoveFocusEngagement();
};
template<typename X> struct IControl4_adaptor : X {
	union {
		struct : property {
			Xaml::ElementSoundMode get() { Xaml::ElementSoundMode value; hrcheck(enc(&IControl4_adaptor::ElementSoundMode)->_get_ElementSoundMode(&value)); return value; }
			Xaml::ElementSoundMode operator()() { return get(); }
			operator Xaml::ElementSoundMode () { return get(); }
			void put(Xaml::ElementSoundMode value) { hrcheck(enc(&IControl4_adaptor::ElementSoundMode)->_put_ElementSoundMode(value)); }
			void operator=(Xaml::ElementSoundMode value) { put(value); }
			void operator()(Xaml::ElementSoundMode value) { put(value); }
		} ElementSoundMode;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IControl4_adaptor::IsFocusEngaged)->_get_IsFocusEngaged(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IControl4_adaptor::IsFocusEngaged)->_put_IsFocusEngaged(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsFocusEngaged;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IControl4_adaptor::IsFocusEngagementEnabled)->_get_IsFocusEngagementEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IControl4_adaptor::IsFocusEngagementEnabled)->_put_IsFocusEngagementEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsFocusEngagementEnabled;
		struct : property {
			Controls::RequiresPointer get() { Controls::RequiresPointer value; hrcheck(enc(&IControl4_adaptor::RequiresPointer)->_get_RequiresPointer(&value)); return value; }
			Controls::RequiresPointer operator()() { return get(); }
			operator Controls::RequiresPointer () { return get(); }
			void put(Controls::RequiresPointer value) { hrcheck(enc(&IControl4_adaptor::RequiresPointer)->_put_RequiresPointer(value)); }
			void operator=(Controls::RequiresPointer value) { put(value); }
			void operator()(Controls::RequiresPointer value) { put(value); }
		} RequiresPointer;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IControl4_adaptor::XYFocusDown)->_get_XYFocusDown(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IControl4_adaptor::XYFocusDown)->_put_XYFocusDown(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} XYFocusDown;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IControl4_adaptor::XYFocusLeft)->_get_XYFocusLeft(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IControl4_adaptor::XYFocusLeft)->_put_XYFocusLeft(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} XYFocusLeft;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IControl4_adaptor::XYFocusRight)->_get_XYFocusRight(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IControl4_adaptor::XYFocusRight)->_put_XYFocusRight(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} XYFocusRight;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IControl4_adaptor::XYFocusUp)->_get_XYFocusUp(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IControl4_adaptor::XYFocusUp)->_put_XYFocusUp(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} XYFocusUp;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<Control>, ptr<FocusDisengagedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IControl4_adaptor::FocusDisengaged)->_add_FocusDisengaged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IControl4_adaptor::FocusDisengaged)->_remove_FocusDisengaged(token)); }
		} FocusDisengaged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<Control>, ptr<FocusEngagedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IControl4_adaptor::FocusEngaged)->_add_FocusEngaged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IControl4_adaptor::FocusEngaged)->_remove_FocusEngaged(token)); }
		} FocusEngaged;
	};
	void RemoveFocusEngagement() { hrcheck(X::get()->_RemoveFocusEngagement()); }
	IControl4_adaptor() {}
};
template<typename X> struct adapt<IControl4, X> : Windows::UI::Xaml::Controls::IControl4_adaptor<X> { typedef adapt IControl4; };
struct IControl4 : IControl4_raw, generate<IControl4> {};

// IControl3
struct IControl3_raw : IInspectable {
	virtual STDMETHODIMP _get_UseSystemFocusVisuals(bool *value);
	virtual STDMETHODIMP _put_UseSystemFocusVisuals(bool value);
};
template<typename X> struct IControl3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IControl3_adaptor::UseSystemFocusVisuals)->_get_UseSystemFocusVisuals(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IControl3_adaptor::UseSystemFocusVisuals)->_put_UseSystemFocusVisuals(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} UseSystemFocusVisuals;
	};
	IControl3_adaptor() {}
};
template<typename X> struct adapt<IControl3, X> : Windows::UI::Xaml::Controls::IControl3_adaptor<X> { typedef adapt IControl3; };
struct IControl3 : IControl3_raw, generate<IControl3> {};

// IControl2
struct IControl2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsTextScaleFactorEnabled(bool *value);
	virtual STDMETHODIMP _put_IsTextScaleFactorEnabled(bool value);
};
template<typename X> struct IControl2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IControl2_adaptor::IsTextScaleFactorEnabled)->_get_IsTextScaleFactorEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IControl2_adaptor::IsTextScaleFactorEnabled)->_put_IsTextScaleFactorEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTextScaleFactorEnabled;
	};
	IControl2_adaptor() {}
};
template<typename X> struct adapt<IControl2, X> : Windows::UI::Xaml::Controls::IControl2_adaptor<X> { typedef adapt IControl2; };
struct IControl2 : IControl2_raw, generate<IControl2> {};

// IControlProtected
struct IControlProtected_raw : IInspectable {
	virtual STDMETHODIMP _get_DefaultStyleKey(IInspectable* *value);
	virtual STDMETHODIMP _put_DefaultStyleKey(IInspectable* value);
	virtual STDMETHODIMP _GetTemplateChild(HSTRING childName, DependencyObject* *returnValue);
};
template<typename X> struct IControlProtected_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IControlProtected_adaptor::DefaultStyleKey)->_get_DefaultStyleKey(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IControlProtected_adaptor::DefaultStyleKey)->_put_DefaultStyleKey(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} DefaultStyleKey;
	};
	ptr<DependencyObject> GetTemplateChild(hstring_ref childName) { DependencyObject* returnValue; hrcheck(X::get()->_GetTemplateChild(childName, &returnValue)); return from_abi(returnValue); }
	IControlProtected_adaptor() {}
};
template<typename X> struct adapt<IControlProtected, X> : Windows::UI::Xaml::Controls::IControlProtected_adaptor<X> { typedef adapt IControlProtected; };
struct IControlProtected : IControlProtected_raw, generate<IControlProtected> {};

// IControlOverrides
struct IControlOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnPointerEntered(Input::PointerRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnPointerPressed(Input::PointerRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnPointerMoved(Input::PointerRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnPointerReleased(Input::PointerRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnPointerExited(Input::PointerRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnPointerCaptureLost(Input::PointerRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnPointerCanceled(Input::PointerRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnPointerWheelChanged(Input::PointerRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnTapped(Input::TappedRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnDoubleTapped(Input::DoubleTappedRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnHolding(Input::HoldingRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnRightTapped(Input::RightTappedRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnManipulationStarting(Input::ManipulationStartingRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnManipulationInertiaStarting(Input::ManipulationInertiaStartingRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnManipulationStarted(Input::ManipulationStartedRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnManipulationDelta(Input::ManipulationDeltaRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnManipulationCompleted(Input::ManipulationCompletedRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnKeyUp(Input::KeyRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnKeyDown(Input::KeyRoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnGotFocus(RoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnLostFocus(RoutedEventArgs* e) = 0;
	virtual STDMETHODIMP _OnDragEnter(DragEventArgs* e) = 0;
	virtual STDMETHODIMP _OnDragLeave(DragEventArgs* e) = 0;
	virtual STDMETHODIMP _OnDragOver(DragEventArgs* e) = 0;
	virtual STDMETHODIMP _OnDrop(DragEventArgs* e) = 0;
};
template<typename X> struct IControlOverrides_adaptor : X {
	void OnPointerEntered(pptr<Input::PointerRoutedEventArgs> e) { hrcheck(X::get()->_OnPointerEntered(e)); }
	void OnPointerPressed(pptr<Input::PointerRoutedEventArgs> e) { hrcheck(X::get()->_OnPointerPressed(e)); }
	void OnPointerMoved(pptr<Input::PointerRoutedEventArgs> e) { hrcheck(X::get()->_OnPointerMoved(e)); }
	void OnPointerReleased(pptr<Input::PointerRoutedEventArgs> e) { hrcheck(X::get()->_OnPointerReleased(e)); }
	void OnPointerExited(pptr<Input::PointerRoutedEventArgs> e) { hrcheck(X::get()->_OnPointerExited(e)); }
	void OnPointerCaptureLost(pptr<Input::PointerRoutedEventArgs> e) { hrcheck(X::get()->_OnPointerCaptureLost(e)); }
	void OnPointerCanceled(pptr<Input::PointerRoutedEventArgs> e) { hrcheck(X::get()->_OnPointerCanceled(e)); }
	void OnPointerWheelChanged(pptr<Input::PointerRoutedEventArgs> e) { hrcheck(X::get()->_OnPointerWheelChanged(e)); }
	void OnTapped(pptr<Input::TappedRoutedEventArgs> e) { hrcheck(X::get()->_OnTapped(e)); }
	void OnDoubleTapped(pptr<Input::DoubleTappedRoutedEventArgs> e) { hrcheck(X::get()->_OnDoubleTapped(e)); }
	void OnHolding(pptr<Input::HoldingRoutedEventArgs> e) { hrcheck(X::get()->_OnHolding(e)); }
	void OnRightTapped(pptr<Input::RightTappedRoutedEventArgs> e) { hrcheck(X::get()->_OnRightTapped(e)); }
	void OnManipulationStarting(pptr<Input::ManipulationStartingRoutedEventArgs> e) { hrcheck(X::get()->_OnManipulationStarting(e)); }
	void OnManipulationInertiaStarting(pptr<Input::ManipulationInertiaStartingRoutedEventArgs> e) { hrcheck(X::get()->_OnManipulationInertiaStarting(e)); }
	void OnManipulationStarted(pptr<Input::ManipulationStartedRoutedEventArgs> e) { hrcheck(X::get()->_OnManipulationStarted(e)); }
	void OnManipulationDelta(pptr<Input::ManipulationDeltaRoutedEventArgs> e) { hrcheck(X::get()->_OnManipulationDelta(e)); }
	void OnManipulationCompleted(pptr<Input::ManipulationCompletedRoutedEventArgs> e) { hrcheck(X::get()->_OnManipulationCompleted(e)); }
	void OnKeyUp(pptr<Input::KeyRoutedEventArgs> e) { hrcheck(X::get()->_OnKeyUp(e)); }
	void OnKeyDown(pptr<Input::KeyRoutedEventArgs> e) { hrcheck(X::get()->_OnKeyDown(e)); }
	void OnGotFocus(pptr<RoutedEventArgs> e) { hrcheck(X::get()->_OnGotFocus(e)); }
	void OnLostFocus(pptr<RoutedEventArgs> e) { hrcheck(X::get()->_OnLostFocus(e)); }
	void OnDragEnter(pptr<DragEventArgs> e) { hrcheck(X::get()->_OnDragEnter(e)); }
	void OnDragLeave(pptr<DragEventArgs> e) { hrcheck(X::get()->_OnDragLeave(e)); }
	void OnDragOver(pptr<DragEventArgs> e) { hrcheck(X::get()->_OnDragOver(e)); }
	void OnDrop(pptr<DragEventArgs> e) { hrcheck(X::get()->_OnDrop(e)); }
};
template<typename X> struct adapt<IControlOverrides, X> : Windows::UI::Xaml::Controls::IControlOverrides_adaptor<X> { typedef adapt IControlOverrides; };
template<typename X> struct IControlOverrides_unadaptor : X {
	STDMETHODIMP _OnPointerEntered(Input::PointerRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnPointerEntered(e); }); }
	STDMETHODIMP _OnPointerPressed(Input::PointerRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnPointerPressed(e); }); }
	STDMETHODIMP _OnPointerMoved(Input::PointerRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnPointerMoved(e); }); }
	STDMETHODIMP _OnPointerReleased(Input::PointerRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnPointerReleased(e); }); }
	STDMETHODIMP _OnPointerExited(Input::PointerRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnPointerExited(e); }); }
	STDMETHODIMP _OnPointerCaptureLost(Input::PointerRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnPointerCaptureLost(e); }); }
	STDMETHODIMP _OnPointerCanceled(Input::PointerRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnPointerCanceled(e); }); }
	STDMETHODIMP _OnPointerWheelChanged(Input::PointerRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnPointerWheelChanged(e); }); }
	STDMETHODIMP _OnTapped(Input::TappedRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnTapped(e); }); }
	STDMETHODIMP _OnDoubleTapped(Input::DoubleTappedRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnDoubleTapped(e); }); }
	STDMETHODIMP _OnHolding(Input::HoldingRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnHolding(e); }); }
	STDMETHODIMP _OnRightTapped(Input::RightTappedRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnRightTapped(e); }); }
	STDMETHODIMP _OnManipulationStarting(Input::ManipulationStartingRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnManipulationStarting(e); }); }
	STDMETHODIMP _OnManipulationInertiaStarting(Input::ManipulationInertiaStartingRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnManipulationInertiaStarting(e); }); }
	STDMETHODIMP _OnManipulationStarted(Input::ManipulationStartedRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnManipulationStarted(e); }); }
	STDMETHODIMP _OnManipulationDelta(Input::ManipulationDeltaRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnManipulationDelta(e); }); }
	STDMETHODIMP _OnManipulationCompleted(Input::ManipulationCompletedRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnManipulationCompleted(e); }); }
	STDMETHODIMP _OnKeyUp(Input::KeyRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnKeyUp(e); }); }
	STDMETHODIMP _OnKeyDown(Input::KeyRoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnKeyDown(e); }); }
	STDMETHODIMP _OnGotFocus(RoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnGotFocus(e); }); }
	STDMETHODIMP _OnLostFocus(RoutedEventArgs* e) { return hrtry([&, this] { X::get()->OnLostFocus(e); }); }
	STDMETHODIMP _OnDragEnter(DragEventArgs* e) { return hrtry([&, this] { X::get()->OnDragEnter(e); }); }
	STDMETHODIMP _OnDragLeave(DragEventArgs* e) { return hrtry([&, this] { X::get()->OnDragLeave(e); }); }
	STDMETHODIMP _OnDragOver(DragEventArgs* e) { return hrtry([&, this] { X::get()->OnDragOver(e); }); }
	STDMETHODIMP _OnDrop(DragEventArgs* e) { return hrtry([&, this] { X::get()->OnDrop(e); }); }
};
template<typename X> struct unadapt<IControlOverrides, X> : Windows::UI::Xaml::Controls::IControlOverrides_unadaptor<X> {};
struct IControlOverrides : IControlOverrides_raw, generate<IControlOverrides> {};

// IControl
struct IControl_raw : IInspectable {
	virtual STDMETHODIMP _get_FontSize(double *value);
	virtual STDMETHODIMP _put_FontSize(double value);
	virtual STDMETHODIMP _get_FontFamily(Media::FontFamily* *value);
	virtual STDMETHODIMP _put_FontFamily(Media::FontFamily* value);
	virtual STDMETHODIMP _get_FontWeight(Text::FontWeight *value);
	virtual STDMETHODIMP _put_FontWeight(Text::FontWeight value);
	virtual STDMETHODIMP _get_FontStyle(Text::FontStyle *value);
	virtual STDMETHODIMP _put_FontStyle(Text::FontStyle value);
	virtual STDMETHODIMP _get_FontStretch(Text::FontStretch *value);
	virtual STDMETHODIMP _put_FontStretch(Text::FontStretch value);
	virtual STDMETHODIMP _get_CharacterSpacing(int *value);
	virtual STDMETHODIMP _put_CharacterSpacing(int value);
	virtual STDMETHODIMP _get_Foreground(Media::Brush* *value);
	virtual STDMETHODIMP _put_Foreground(Media::Brush* value);
	virtual STDMETHODIMP _get_IsTabStop(bool *value);
	virtual STDMETHODIMP _put_IsTabStop(bool value);
	virtual STDMETHODIMP _get_IsEnabled(bool *value);
	virtual STDMETHODIMP _put_IsEnabled(bool value);
	virtual STDMETHODIMP _get_TabIndex(int *value);
	virtual STDMETHODIMP _put_TabIndex(int value);
	virtual STDMETHODIMP _get_TabNavigation(Input::KeyboardNavigationMode *value);
	virtual STDMETHODIMP _put_TabNavigation(Input::KeyboardNavigationMode value);
	virtual STDMETHODIMP _get_Template(ControlTemplate* *value);
	virtual STDMETHODIMP _put_Template(ControlTemplate* value);
	virtual STDMETHODIMP _get_Padding(Thickness *value);
	virtual STDMETHODIMP _put_Padding(Thickness value);
	virtual STDMETHODIMP _get_HorizontalContentAlignment(HorizontalAlignment *value);
	virtual STDMETHODIMP _put_HorizontalContentAlignment(HorizontalAlignment value);
	virtual STDMETHODIMP _get_VerticalContentAlignment(VerticalAlignment *value);
	virtual STDMETHODIMP _put_VerticalContentAlignment(VerticalAlignment value);
	virtual STDMETHODIMP _get_Background(Media::Brush* *value);
	virtual STDMETHODIMP _put_Background(Media::Brush* value);
	virtual STDMETHODIMP _get_BorderThickness(Thickness *value);
	virtual STDMETHODIMP _put_BorderThickness(Thickness value);
	virtual STDMETHODIMP _get_BorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_BorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_FocusState(Xaml::FocusState *value);
	virtual STDMETHODIMP _add_IsEnabledChanged(DependencyPropertyChangedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_IsEnabledChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _ApplyTemplate(bool *returnValue);
	virtual STDMETHODIMP _Focus(Xaml::FocusState value, bool *returnValue);
};
template<typename X> struct IControl_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IControl_adaptor::Background)->_get_Background(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IControl_adaptor::Background)->_put_Background(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Background;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IControl_adaptor::BorderBrush)->_get_BorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IControl_adaptor::BorderBrush)->_put_BorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} BorderBrush;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IControl_adaptor::BorderThickness)->_get_BorderThickness(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IControl_adaptor::BorderThickness)->_put_BorderThickness(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} BorderThickness;
		struct : property {
			int get() { int value; hrcheck(enc(&IControl_adaptor::CharacterSpacing)->_get_CharacterSpacing(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IControl_adaptor::CharacterSpacing)->_put_CharacterSpacing(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} CharacterSpacing;
		struct : property {
			Xaml::FocusState get() { Xaml::FocusState value; hrcheck(enc(&IControl_adaptor::FocusState)->_get_FocusState(&value)); return value; }
			Xaml::FocusState operator()() { return get(); }
			operator Xaml::FocusState () { return get(); }
		} FocusState;
		struct : property {
			ptr<Media::FontFamily> get() { Media::FontFamily* value; hrcheck(enc(&IControl_adaptor::FontFamily)->_get_FontFamily(&value)); return from_abi(value); }
			ptr<Media::FontFamily> operator()() { return get(); }
			operator ptr<Media::FontFamily> () { return get(); }
			ptr<Media::FontFamily> operator->() { return get(); }
			void put(pptr<Media::FontFamily> value) { hrcheck(enc(&IControl_adaptor::FontFamily)->_put_FontFamily(value)); }
			void operator=(pptr<Media::FontFamily> value) { put(value); }
			void operator()(pptr<Media::FontFamily> value) { put(value); }
		} FontFamily;
		struct : property {
			double get() { double value; hrcheck(enc(&IControl_adaptor::FontSize)->_get_FontSize(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IControl_adaptor::FontSize)->_put_FontSize(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FontSize;
		struct : property {
			Text::FontStretch get() { Text::FontStretch value; hrcheck(enc(&IControl_adaptor::FontStretch)->_get_FontStretch(&value)); return value; }
			Text::FontStretch operator()() { return get(); }
			operator Text::FontStretch () { return get(); }
			void put(Text::FontStretch value) { hrcheck(enc(&IControl_adaptor::FontStretch)->_put_FontStretch(value)); }
			void operator=(Text::FontStretch value) { put(value); }
			void operator()(Text::FontStretch value) { put(value); }
		} FontStretch;
		struct : property {
			Text::FontStyle get() { Text::FontStyle value; hrcheck(enc(&IControl_adaptor::FontStyle)->_get_FontStyle(&value)); return value; }
			Text::FontStyle operator()() { return get(); }
			operator Text::FontStyle () { return get(); }
			void put(Text::FontStyle value) { hrcheck(enc(&IControl_adaptor::FontStyle)->_put_FontStyle(value)); }
			void operator=(Text::FontStyle value) { put(value); }
			void operator()(Text::FontStyle value) { put(value); }
		} FontStyle;
		struct : property {
			Text::FontWeight get() { Text::FontWeight value; hrcheck(enc(&IControl_adaptor::FontWeight)->_get_FontWeight(&value)); return value; }
			Text::FontWeight operator()() { return get(); }
			operator Text::FontWeight () { return get(); }
			void put(const Text::FontWeight& value) { hrcheck(enc(&IControl_adaptor::FontWeight)->_put_FontWeight(value)); }
			void operator=(const Text::FontWeight& value) { put(value); }
			void operator()(const Text::FontWeight& value) { put(value); }
		} FontWeight;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IControl_adaptor::Foreground)->_get_Foreground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IControl_adaptor::Foreground)->_put_Foreground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Foreground;
		struct : property {
			HorizontalAlignment get() { HorizontalAlignment value; hrcheck(enc(&IControl_adaptor::HorizontalContentAlignment)->_get_HorizontalContentAlignment(&value)); return value; }
			HorizontalAlignment operator()() { return get(); }
			operator HorizontalAlignment () { return get(); }
			void put(HorizontalAlignment value) { hrcheck(enc(&IControl_adaptor::HorizontalContentAlignment)->_put_HorizontalContentAlignment(value)); }
			void operator=(HorizontalAlignment value) { put(value); }
			void operator()(HorizontalAlignment value) { put(value); }
		} HorizontalContentAlignment;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IControl_adaptor::IsEnabled)->_get_IsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IControl_adaptor::IsEnabled)->_put_IsEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IControl_adaptor::IsTabStop)->_get_IsTabStop(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IControl_adaptor::IsTabStop)->_put_IsTabStop(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTabStop;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IControl_adaptor::Padding)->_get_Padding(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IControl_adaptor::Padding)->_put_Padding(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} Padding;
		struct : property {
			int get() { int value; hrcheck(enc(&IControl_adaptor::TabIndex)->_get_TabIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IControl_adaptor::TabIndex)->_put_TabIndex(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} TabIndex;
		struct : property {
			Input::KeyboardNavigationMode get() { Input::KeyboardNavigationMode value; hrcheck(enc(&IControl_adaptor::TabNavigation)->_get_TabNavigation(&value)); return value; }
			Input::KeyboardNavigationMode operator()() { return get(); }
			operator Input::KeyboardNavigationMode () { return get(); }
			void put(Input::KeyboardNavigationMode value) { hrcheck(enc(&IControl_adaptor::TabNavigation)->_put_TabNavigation(value)); }
			void operator=(Input::KeyboardNavigationMode value) { put(value); }
			void operator()(Input::KeyboardNavigationMode value) { put(value); }
		} TabNavigation;
		struct : property {
			ptr<ControlTemplate> get() { ControlTemplate* value; hrcheck(enc(&IControl_adaptor::Template)->_get_Template(&value)); return from_abi(value); }
			ptr<ControlTemplate> operator()() { return get(); }
			operator ptr<ControlTemplate> () { return get(); }
			ptr<ControlTemplate> operator->() { return get(); }
			void put(pptr<ControlTemplate> value) { hrcheck(enc(&IControl_adaptor::Template)->_put_Template(value)); }
			void operator=(pptr<ControlTemplate> value) { put(value); }
			void operator()(pptr<ControlTemplate> value) { put(value); }
		} Template;
		struct : property {
			VerticalAlignment get() { VerticalAlignment value; hrcheck(enc(&IControl_adaptor::VerticalContentAlignment)->_get_VerticalContentAlignment(&value)); return value; }
			VerticalAlignment operator()() { return get(); }
			operator VerticalAlignment () { return get(); }
			void put(VerticalAlignment value) { hrcheck(enc(&IControl_adaptor::VerticalContentAlignment)->_put_VerticalContentAlignment(value)); }
			void operator=(VerticalAlignment value) { put(value); }
			void operator()(VerticalAlignment value) { put(value); }
		} VerticalContentAlignment;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<DependencyPropertyChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IControl_adaptor::IsEnabledChanged)->_add_IsEnabledChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IControl_adaptor::IsEnabledChanged)->_remove_IsEnabledChanged(token)); }
		} IsEnabledChanged;
	};
	bool ApplyTemplate() { bool returnValue; hrcheck(X::get()->_ApplyTemplate(&returnValue)); return returnValue; }
	bool Focus(Xaml::FocusState value) { bool returnValue; hrcheck(X::get()->_Focus(value, &returnValue)); return returnValue; }
	IControl_adaptor() {}
};
template<typename X> struct adapt<IControl, X> : Windows::UI::Xaml::Controls::IControl_adaptor<X> { typedef adapt IControl; };
struct IControl : IControl_raw, generate<IControl> {};

// Control
template<typename> struct Control_statics {
	static struct _BackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_BackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BackgroundProperty;
	static struct _BorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_BorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BorderBrushProperty;
	static struct _BorderThicknessProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_BorderThicknessProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BorderThicknessProperty;
	static struct _CharacterSpacingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_CharacterSpacingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CharacterSpacingProperty;
	static struct _DefaultStyleKeyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_DefaultStyleKeyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DefaultStyleKeyProperty;
	static struct _FocusStateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_FocusStateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FocusStateProperty;
	static struct _FontFamilyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_FontFamilyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontFamilyProperty;
	static struct _FontSizeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_FontSizeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontSizeProperty;
	static struct _FontStretchProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_FontStretchProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontStretchProperty;
	static struct _FontStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_FontStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontStyleProperty;
	static struct _FontWeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_FontWeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontWeightProperty;
	static struct _ForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_ForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ForegroundProperty;
	static struct _HorizontalContentAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_HorizontalContentAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalContentAlignmentProperty;
	static struct _IsEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_IsEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsEnabledProperty;
	static struct _IsTabStopProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_IsTabStopProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTabStopProperty;
	static struct _PaddingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_PaddingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaddingProperty;
	static struct _TabIndexProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_TabIndexProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TabIndexProperty;
	static struct _TabNavigationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_TabNavigationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TabNavigationProperty;
	static struct _TemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_TemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TemplateProperty;
	static struct _VerticalContentAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics>()->_get_VerticalContentAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalContentAlignmentProperty;
	static struct _IsTextScaleFactorEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics2>()->_get_IsTextScaleFactorEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTextScaleFactorEnabledProperty;
	static struct _IsTemplateFocusTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics3>()->_get_IsTemplateFocusTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTemplateFocusTargetProperty;
	static struct _UseSystemFocusVisualsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics3>()->_get_UseSystemFocusVisualsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} UseSystemFocusVisualsProperty;
	static struct _ElementSoundModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics4>()->_get_ElementSoundModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ElementSoundModeProperty;
	static struct _IsFocusEngagedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics4>()->_get_IsFocusEngagedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsFocusEngagedProperty;
	static struct _IsFocusEngagementEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics4>()->_get_IsFocusEngagementEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsFocusEngagementEnabledProperty;
	static struct _RequiresPointerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics4>()->_get_RequiresPointerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RequiresPointerProperty;
	static struct _XYFocusDownProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics4>()->_get_XYFocusDownProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} XYFocusDownProperty;
	static struct _XYFocusLeftProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics4>()->_get_XYFocusLeftProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} XYFocusLeftProperty;
	static struct _XYFocusRightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics4>()->_get_XYFocusRightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} XYFocusRightProperty;
	static struct _XYFocusUpProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics4>()->_get_XYFocusUpProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} XYFocusUpProperty;
	static struct _DefaultStyleResourceUriProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics5>()->_get_DefaultStyleResourceUriProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DefaultStyleResourceUriProperty;
	static struct _IsTemplateKeyTipTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Control, IControlStatics5>()->_get_IsTemplateKeyTipTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTemplateKeyTipTargetProperty;
	static bool GetIsTemplateKeyTipTarget(pptr<DependencyObject> element) { bool value; hrcheck(get_activation_factory<Control, IControlStatics5>()->_GetIsTemplateKeyTipTarget(element, &value)); return value; }
	static void SetIsTemplateKeyTipTarget(pptr<DependencyObject> element, bool value) { hrcheck(get_activation_factory<Control, IControlStatics5>()->_SetIsTemplateKeyTipTarget(element, value)); }
	static bool GetIsTemplateFocusTarget(pptr<FrameworkElement> element) { bool value; hrcheck(get_activation_factory<Control, IControlStatics3>()->_GetIsTemplateFocusTarget(element, &value)); return value; }
	static void SetIsTemplateFocusTarget(pptr<FrameworkElement> element, bool value) { hrcheck(get_activation_factory<Control, IControlStatics3>()->_SetIsTemplateFocusTarget(element, value)); }
};
template<typename X> typename Control_statics<X>::_BackgroundProperty Control_statics<X>::BackgroundProperty;
template<typename X> typename Control_statics<X>::_BorderBrushProperty Control_statics<X>::BorderBrushProperty;
template<typename X> typename Control_statics<X>::_BorderThicknessProperty Control_statics<X>::BorderThicknessProperty;
template<typename X> typename Control_statics<X>::_CharacterSpacingProperty Control_statics<X>::CharacterSpacingProperty;
template<typename X> typename Control_statics<X>::_DefaultStyleKeyProperty Control_statics<X>::DefaultStyleKeyProperty;
template<typename X> typename Control_statics<X>::_FocusStateProperty Control_statics<X>::FocusStateProperty;
template<typename X> typename Control_statics<X>::_FontFamilyProperty Control_statics<X>::FontFamilyProperty;
template<typename X> typename Control_statics<X>::_FontSizeProperty Control_statics<X>::FontSizeProperty;
template<typename X> typename Control_statics<X>::_FontStretchProperty Control_statics<X>::FontStretchProperty;
template<typename X> typename Control_statics<X>::_FontStyleProperty Control_statics<X>::FontStyleProperty;
template<typename X> typename Control_statics<X>::_FontWeightProperty Control_statics<X>::FontWeightProperty;
template<typename X> typename Control_statics<X>::_ForegroundProperty Control_statics<X>::ForegroundProperty;
template<typename X> typename Control_statics<X>::_HorizontalContentAlignmentProperty Control_statics<X>::HorizontalContentAlignmentProperty;
template<typename X> typename Control_statics<X>::_IsEnabledProperty Control_statics<X>::IsEnabledProperty;
template<typename X> typename Control_statics<X>::_IsTabStopProperty Control_statics<X>::IsTabStopProperty;
template<typename X> typename Control_statics<X>::_PaddingProperty Control_statics<X>::PaddingProperty;
template<typename X> typename Control_statics<X>::_TabIndexProperty Control_statics<X>::TabIndexProperty;
template<typename X> typename Control_statics<X>::_TabNavigationProperty Control_statics<X>::TabNavigationProperty;
template<typename X> typename Control_statics<X>::_TemplateProperty Control_statics<X>::TemplateProperty;
template<typename X> typename Control_statics<X>::_VerticalContentAlignmentProperty Control_statics<X>::VerticalContentAlignmentProperty;
template<typename X> typename Control_statics<X>::_IsTextScaleFactorEnabledProperty Control_statics<X>::IsTextScaleFactorEnabledProperty;
template<typename X> typename Control_statics<X>::_IsTemplateFocusTargetProperty Control_statics<X>::IsTemplateFocusTargetProperty;
template<typename X> typename Control_statics<X>::_UseSystemFocusVisualsProperty Control_statics<X>::UseSystemFocusVisualsProperty;
template<typename X> typename Control_statics<X>::_ElementSoundModeProperty Control_statics<X>::ElementSoundModeProperty;
template<typename X> typename Control_statics<X>::_IsFocusEngagedProperty Control_statics<X>::IsFocusEngagedProperty;
template<typename X> typename Control_statics<X>::_IsFocusEngagementEnabledProperty Control_statics<X>::IsFocusEngagementEnabledProperty;
template<typename X> typename Control_statics<X>::_RequiresPointerProperty Control_statics<X>::RequiresPointerProperty;
template<typename X> typename Control_statics<X>::_XYFocusDownProperty Control_statics<X>::XYFocusDownProperty;
template<typename X> typename Control_statics<X>::_XYFocusLeftProperty Control_statics<X>::XYFocusLeftProperty;
template<typename X> typename Control_statics<X>::_XYFocusRightProperty Control_statics<X>::XYFocusRightProperty;
template<typename X> typename Control_statics<X>::_XYFocusUpProperty Control_statics<X>::XYFocusUpProperty;
template<typename X> typename Control_statics<X>::_DefaultStyleResourceUriProperty Control_statics<X>::DefaultStyleResourceUriProperty;
template<typename X> typename Control_statics<X>::_IsTemplateKeyTipTargetProperty Control_statics<X>::IsTemplateKeyTipTargetProperty;

template<typename X> struct statics<Control, X> : X, Windows::UI::Xaml::Controls::Control_statics<void> {
	typedef typename X::root_type Control;
};
struct Control : generate<Control> {};

// ContentControl
template<typename> struct ContentControl_statics {
	static struct _ContentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentControl, IContentControlStatics>()->_get_ContentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentProperty;
	static struct _ContentTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentControl, IContentControlStatics>()->_get_ContentTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentTemplateProperty;
	static struct _ContentTemplateSelectorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentControl, IContentControlStatics>()->_get_ContentTemplateSelectorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentTemplateSelectorProperty;
	static struct _ContentTransitionsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentControl, IContentControlStatics>()->_get_ContentTransitionsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentTransitionsProperty;
	static ContentControl *activate(object_ref outer, IInspectable* *inner) { ContentControl *instance; hrcheck(get_activation_factory<ContentControl, IContentControlFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename ContentControl_statics<X>::_ContentProperty ContentControl_statics<X>::ContentProperty;
template<typename X> typename ContentControl_statics<X>::_ContentTemplateProperty ContentControl_statics<X>::ContentTemplateProperty;
template<typename X> typename ContentControl_statics<X>::_ContentTemplateSelectorProperty ContentControl_statics<X>::ContentTemplateSelectorProperty;
template<typename X> typename ContentControl_statics<X>::_ContentTransitionsProperty ContentControl_statics<X>::ContentTransitionsProperty;

template<typename X> struct statics<ContentControl, X> : X, Windows::UI::Xaml::Controls::ContentControl_statics<void> {
	using Windows::UI::Xaml::Controls::ContentControl_statics<void>::activate;
	typedef typename X::root_type ContentControl;
};
struct ContentControl : generate<ContentControl> {};
namespace Primitives {

// PivotHeaderItem
template<typename> struct PivotHeaderItem_statics {
	static PivotHeaderItem *activate(object_ref outer, IInspectable* *inner) { PivotHeaderItem *instance; hrcheck(get_activation_factory<PivotHeaderItem, IPivotHeaderItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<PivotHeaderItem, X> : X, Windows::UI::Xaml::Controls::Primitives::PivotHeaderItem_statics<void> {
	using Windows::UI::Xaml::Controls::Primitives::PivotHeaderItem_statics<void>::activate;
	typedef typename X::root_type PivotHeaderItem;
};
struct PivotHeaderItem : generate<PivotHeaderItem> {};

// IScrollSnapPointsInfo
struct IScrollSnapPointsInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_AreHorizontalSnapPointsRegular(bool *value) = 0;
	virtual STDMETHODIMP _get_AreVerticalSnapPointsRegular(bool *value) = 0;
	virtual STDMETHODIMP _add_HorizontalSnapPointsChanged(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token) = 0;
	virtual STDMETHODIMP _remove_HorizontalSnapPointsChanged(Foundation::EventRegistrationToken token) = 0;
	virtual STDMETHODIMP _add_VerticalSnapPointsChanged(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token) = 0;
	virtual STDMETHODIMP _remove_VerticalSnapPointsChanged(Foundation::EventRegistrationToken token) = 0;
	virtual STDMETHODIMP _GetIrregularSnapPoints(Orientation orientation, SnapPointsAlignment alignment, Foundation::Collections::IVectorView<float>* *returnValue) = 0;
	virtual STDMETHODIMP _GetRegularSnapPoints(Orientation orientation, SnapPointsAlignment alignment, float *offset, float *returnValue) = 0;
};
template<typename X> struct IScrollSnapPointsInfo_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollSnapPointsInfo_adaptor::AreHorizontalSnapPointsRegular)->_get_AreHorizontalSnapPointsRegular(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} AreHorizontalSnapPointsRegular;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollSnapPointsInfo_adaptor::AreVerticalSnapPointsRegular)->_get_AreVerticalSnapPointsRegular(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} AreVerticalSnapPointsRegular;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IScrollSnapPointsInfo_adaptor::HorizontalSnapPointsChanged)->_add_HorizontalSnapPointsChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IScrollSnapPointsInfo_adaptor::HorizontalSnapPointsChanged)->_remove_HorizontalSnapPointsChanged(token)); }
		} HorizontalSnapPointsChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IScrollSnapPointsInfo_adaptor::VerticalSnapPointsChanged)->_add_VerticalSnapPointsChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IScrollSnapPointsInfo_adaptor::VerticalSnapPointsChanged)->_remove_VerticalSnapPointsChanged(token)); }
		} VerticalSnapPointsChanged;
	};
	ptr<Foundation::Collections::IVectorView<float>> GetIrregularSnapPoints(Orientation orientation, SnapPointsAlignment alignment) { Foundation::Collections::IVectorView<float>* returnValue; hrcheck(X::get()->_GetIrregularSnapPoints(orientation, alignment, &returnValue)); return from_abi(returnValue); }
	float GetRegularSnapPoints(Orientation orientation, SnapPointsAlignment alignment, float *offset) { float returnValue; hrcheck(X::get()->_GetRegularSnapPoints(orientation, alignment, offset, &returnValue)); return returnValue; }
	IScrollSnapPointsInfo_adaptor() {}
};
template<typename X> struct adapt<IScrollSnapPointsInfo, X> : Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo_adaptor<X> { typedef adapt IScrollSnapPointsInfo; };
template<typename X> struct IScrollSnapPointsInfo_unadaptor : X {
	STDMETHODIMP _get_AreHorizontalSnapPointsRegular(bool *value) { return hrtry([&, this] { get_prop(value, AreHorizontalSnapPointsRegular); }); }
	STDMETHODIMP _get_AreVerticalSnapPointsRegular(bool *value) { return hrtry([&, this] { get_prop(value, AreVerticalSnapPointsRegular); }); }
	STDMETHODIMP _add_HorizontalSnapPointsChanged(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token) { return hrtry([&, this] { *token = X::get()->HorizontalSnapPointsChanged+=value; }); }
	STDMETHODIMP _remove_HorizontalSnapPointsChanged(Foundation::EventRegistrationToken token) { return hrtry([&, this] { X::get()->HorizontalSnapPointsChanged-=token; }); }
	STDMETHODIMP _add_VerticalSnapPointsChanged(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token) { return hrtry([&, this] { *token = X::get()->VerticalSnapPointsChanged+=value; }); }
	STDMETHODIMP _remove_VerticalSnapPointsChanged(Foundation::EventRegistrationToken token) { return hrtry([&, this] { X::get()->VerticalSnapPointsChanged-=token; }); }
	STDMETHODIMP _GetIrregularSnapPoints(Orientation orientation, SnapPointsAlignment alignment, Foundation::Collections::IVectorView<float>* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetIrregularSnapPoints(orientation, alignment)); }); }
	STDMETHODIMP _GetRegularSnapPoints(Orientation orientation, SnapPointsAlignment alignment, float *offset, float *returnValue) { return hrtry([&, this] { *returnValue = X::get()->GetRegularSnapPoints(orientation, alignment, offset); }); }
};
template<typename X> struct unadapt<IScrollSnapPointsInfo, X> : Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo_unadaptor<X> {};
struct IScrollSnapPointsInfo : IScrollSnapPointsInfo_raw, generate<IScrollSnapPointsInfo> {};

// ILoopingSelectorPanel
struct ILoopingSelectorPanel : IInspectable, generate<ILoopingSelectorPanel> {};

// LoopingSelectorPanel
template<typename X> struct statics<LoopingSelectorPanel, X> : X {
	typedef typename X::root_type LoopingSelectorPanel;
};
struct LoopingSelectorPanel : generate<LoopingSelectorPanel> {};

// ILoopingSelectorItem
struct ILoopingSelectorItem : IInspectable, generate<ILoopingSelectorItem> {};

// LoopingSelectorItem
template<typename X> struct statics<LoopingSelectorItem, X> : X {
	typedef typename X::root_type LoopingSelectorItem;
};
struct LoopingSelectorItem : generate<LoopingSelectorItem> {};

// IPivotPanel
struct IPivotPanel : IInspectable, generate<IPivotPanel> {};

// PivotPanel
template<typename X> struct statics<PivotPanel, X> : X {
	typedef typename X::root_type PivotPanel;
};
struct PivotPanel : generate<PivotPanel> {};

// ILoopingSelectorStatics
struct ILoopingSelectorStatics : IInspectable {
	virtual STDMETHODIMP _get_ShouldLoopProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedIndexProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedItemProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemTemplateProperty(DependencyProperty* *value);
};

// ILoopingSelector
struct ILoopingSelector_raw : IInspectable {
	virtual STDMETHODIMP _get_ShouldLoop(bool *value);
	virtual STDMETHODIMP _put_ShouldLoop(bool value);
	virtual STDMETHODIMP _get_Items(Foundation::Collections::IVector<IInspectable*>* *value);
	virtual STDMETHODIMP _put_Items(Foundation::Collections::IVector<IInspectable*>* value);
	virtual STDMETHODIMP _get_SelectedIndex(int *value);
	virtual STDMETHODIMP _put_SelectedIndex(int value);
	virtual STDMETHODIMP _get_SelectedItem(IInspectable* *value);
	virtual STDMETHODIMP _put_SelectedItem(IInspectable* value);
	virtual STDMETHODIMP _get_ItemWidth(int *value);
	virtual STDMETHODIMP _put_ItemWidth(int value);
	virtual STDMETHODIMP _get_ItemHeight(int *value);
	virtual STDMETHODIMP _put_ItemHeight(int value);
	virtual STDMETHODIMP _get_ItemTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_ItemTemplate(DataTemplate* value);
	virtual STDMETHODIMP _add_SelectionChanged(SelectionChangedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SelectionChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct ILoopingSelector_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&ILoopingSelector_adaptor::ItemHeight)->_get_ItemHeight(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ILoopingSelector_adaptor::ItemHeight)->_put_ItemHeight(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} ItemHeight;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&ILoopingSelector_adaptor::ItemTemplate)->_get_ItemTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&ILoopingSelector_adaptor::ItemTemplate)->_put_ItemTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} ItemTemplate;
		struct : property {
			int get() { int value; hrcheck(enc(&ILoopingSelector_adaptor::ItemWidth)->_get_ItemWidth(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ILoopingSelector_adaptor::ItemWidth)->_put_ItemWidth(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} ItemWidth;
		struct : property {
			ptr<Foundation::Collections::IVector<object>> get() { Foundation::Collections::IVector<IInspectable*>* value; hrcheck(enc(&ILoopingSelector_adaptor::Items)->_get_Items(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<object>> () { return get(); }
			ptr<Foundation::Collections::IVector<object>> operator->() { return get(); }
			void put(pptr<Foundation::Collections::IVector<object>> value) { hrcheck(enc(&ILoopingSelector_adaptor::Items)->_put_Items(to_abi(value))); }
			void operator=(pptr<Foundation::Collections::IVector<object>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::Collections::IVector<object>> value) { put(to_abi(value)); }
		} Items;
		struct : property {
			int get() { int value; hrcheck(enc(&ILoopingSelector_adaptor::SelectedIndex)->_get_SelectedIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ILoopingSelector_adaptor::SelectedIndex)->_put_SelectedIndex(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} SelectedIndex;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ILoopingSelector_adaptor::SelectedItem)->_get_SelectedItem(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&ILoopingSelector_adaptor::SelectedItem)->_put_SelectedItem(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} SelectedItem;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILoopingSelector_adaptor::ShouldLoop)->_get_ShouldLoop(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ILoopingSelector_adaptor::ShouldLoop)->_put_ShouldLoop(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ShouldLoop;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<SelectionChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ILoopingSelector_adaptor::SelectionChanged)->_add_SelectionChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ILoopingSelector_adaptor::SelectionChanged)->_remove_SelectionChanged(token)); }
		} SelectionChanged;
	};
	ILoopingSelector_adaptor() {}
};
template<typename X> struct adapt<ILoopingSelector, X> : Windows::UI::Xaml::Controls::Primitives::ILoopingSelector_adaptor<X> { typedef adapt ILoopingSelector; };
struct ILoopingSelector : ILoopingSelector_raw, generate<ILoopingSelector> {};

// LoopingSelector
template<typename> struct LoopingSelector_statics {
	static struct _ItemHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<LoopingSelector, ILoopingSelectorStatics>()->_get_ItemHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemHeightProperty;
	static struct _ItemTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<LoopingSelector, ILoopingSelectorStatics>()->_get_ItemTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemTemplateProperty;
	static struct _ItemWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<LoopingSelector, ILoopingSelectorStatics>()->_get_ItemWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemWidthProperty;
	static struct _ItemsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<LoopingSelector, ILoopingSelectorStatics>()->_get_ItemsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemsProperty;
	static struct _SelectedIndexProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<LoopingSelector, ILoopingSelectorStatics>()->_get_SelectedIndexProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedIndexProperty;
	static struct _SelectedItemProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<LoopingSelector, ILoopingSelectorStatics>()->_get_SelectedItemProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedItemProperty;
	static struct _ShouldLoopProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<LoopingSelector, ILoopingSelectorStatics>()->_get_ShouldLoopProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ShouldLoopProperty;
};
template<typename X> typename LoopingSelector_statics<X>::_ItemHeightProperty LoopingSelector_statics<X>::ItemHeightProperty;
template<typename X> typename LoopingSelector_statics<X>::_ItemTemplateProperty LoopingSelector_statics<X>::ItemTemplateProperty;
template<typename X> typename LoopingSelector_statics<X>::_ItemWidthProperty LoopingSelector_statics<X>::ItemWidthProperty;
template<typename X> typename LoopingSelector_statics<X>::_ItemsProperty LoopingSelector_statics<X>::ItemsProperty;
template<typename X> typename LoopingSelector_statics<X>::_SelectedIndexProperty LoopingSelector_statics<X>::SelectedIndexProperty;
template<typename X> typename LoopingSelector_statics<X>::_SelectedItemProperty LoopingSelector_statics<X>::SelectedItemProperty;
template<typename X> typename LoopingSelector_statics<X>::_ShouldLoopProperty LoopingSelector_statics<X>::ShouldLoopProperty;

template<typename X> struct statics<LoopingSelector, X> : X, Windows::UI::Xaml::Controls::Primitives::LoopingSelector_statics<void> {
	typedef typename X::root_type LoopingSelector;
};
struct LoopingSelector : generate<LoopingSelector> {};

// IPickerFlyoutBaseFactory
struct IPickerFlyoutBaseFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, PickerFlyoutBase* *instance);
};

// IPickerFlyoutBaseStatics
struct IPickerFlyoutBaseStatics : IInspectable {
	virtual STDMETHODIMP _get_TitleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetTitle(DependencyObject* element, HSTRING *value);
	virtual STDMETHODIMP _SetTitle(DependencyObject* element, HSTRING value);
};

// IPickerFlyoutBaseOverrides
struct IPickerFlyoutBaseOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnConfirmed() = 0;
	virtual STDMETHODIMP _ShouldShowConfirmationButtons(bool *returnValue) = 0;
};
template<typename X> struct IPickerFlyoutBaseOverrides_adaptor : X {
	void OnConfirmed() { hrcheck(X::get()->_OnConfirmed()); }
	bool ShouldShowConfirmationButtons() { bool returnValue; hrcheck(X::get()->_ShouldShowConfirmationButtons(&returnValue)); return returnValue; }
};
template<typename X> struct adapt<IPickerFlyoutBaseOverrides, X> : Windows::UI::Xaml::Controls::Primitives::IPickerFlyoutBaseOverrides_adaptor<X> { typedef adapt IPickerFlyoutBaseOverrides; };
template<typename X> struct IPickerFlyoutBaseOverrides_unadaptor : X {
	STDMETHODIMP _OnConfirmed() { return hrtry([&, this] { X::get()->OnConfirmed(); }); }
	STDMETHODIMP _ShouldShowConfirmationButtons(bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->ShouldShowConfirmationButtons(); }); }
};
template<typename X> struct unadapt<IPickerFlyoutBaseOverrides, X> : Windows::UI::Xaml::Controls::Primitives::IPickerFlyoutBaseOverrides_unadaptor<X> {};
struct IPickerFlyoutBaseOverrides : IPickerFlyoutBaseOverrides_raw, generate<IPickerFlyoutBaseOverrides> {};

// IPickerFlyoutBase
struct IPickerFlyoutBase : IInspectable, generate<IPickerFlyoutBase> {};

// IFlyoutBaseStatics3
struct IFlyoutBaseStatics3 : IInspectable {
	virtual STDMETHODIMP _get_OverlayInputPassThroughElementProperty(DependencyProperty* *value);
};

// IFlyoutBaseStatics2
struct IFlyoutBaseStatics2 : IInspectable {
	virtual STDMETHODIMP _get_AllowFocusOnInteractionProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_LightDismissOverlayModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AllowFocusWhenDisabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ElementSoundModeProperty(DependencyProperty* *value);
};

// IFlyoutBaseFactory
struct IFlyoutBaseFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, FlyoutBase* *instance);
};

// IFlyoutBaseStatics
struct IFlyoutBaseStatics : IInspectable {
	virtual STDMETHODIMP _get_PlacementProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AttachedFlyoutProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetAttachedFlyout(FrameworkElement* element, FlyoutBase* *value);
	virtual STDMETHODIMP _SetAttachedFlyout(FrameworkElement* element, FlyoutBase* value);
	virtual STDMETHODIMP _ShowAttachedFlyout(FrameworkElement* flyoutOwner);
};

// IFlyoutBaseOverrides4
struct IFlyoutBaseOverrides4_raw : IInspectable {
	virtual STDMETHODIMP _OnProcessKeyboardAccelerators(Input::ProcessKeyboardAcceleratorEventArgs* args) = 0;
};
template<typename X> struct IFlyoutBaseOverrides4_adaptor : X {
	void OnProcessKeyboardAccelerators(pptr<Input::ProcessKeyboardAcceleratorEventArgs> args) { hrcheck(X::get()->_OnProcessKeyboardAccelerators(args)); }
};
template<typename X> struct adapt<IFlyoutBaseOverrides4, X> : Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides4_adaptor<X> { typedef adapt IFlyoutBaseOverrides4; };
template<typename X> struct IFlyoutBaseOverrides4_unadaptor : X {
	STDMETHODIMP _OnProcessKeyboardAccelerators(Input::ProcessKeyboardAcceleratorEventArgs* args) { return hrtry([&, this] { X::get()->OnProcessKeyboardAccelerators(args); }); }
};
template<typename X> struct unadapt<IFlyoutBaseOverrides4, X> : Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides4_unadaptor<X> {};
struct IFlyoutBaseOverrides4 : IFlyoutBaseOverrides4_raw, generate<IFlyoutBaseOverrides4> {};

// IFlyoutBase4
struct IFlyoutBase4_raw : IInspectable {
	virtual STDMETHODIMP _TryInvokeKeyboardAccelerator(Input::ProcessKeyboardAcceleratorEventArgs* args);
};
template<typename X> struct IFlyoutBase4_adaptor : X {
	void TryInvokeKeyboardAccelerator(pptr<Input::ProcessKeyboardAcceleratorEventArgs> args) { hrcheck(X::get()->_TryInvokeKeyboardAccelerator(args)); }
};
template<typename X> struct adapt<IFlyoutBase4, X> : Windows::UI::Xaml::Controls::Primitives::IFlyoutBase4_adaptor<X> { typedef adapt IFlyoutBase4; };
struct IFlyoutBase4 : IFlyoutBase4_raw, generate<IFlyoutBase4> {};

// IFlyoutBase3
struct IFlyoutBase3_raw : IInspectable {
	virtual STDMETHODIMP _get_OverlayInputPassThroughElement(DependencyObject* *value);
	virtual STDMETHODIMP _put_OverlayInputPassThroughElement(DependencyObject* value);
};
template<typename X> struct IFlyoutBase3_adaptor : X {
	union {
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IFlyoutBase3_adaptor::OverlayInputPassThroughElement)->_get_OverlayInputPassThroughElement(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IFlyoutBase3_adaptor::OverlayInputPassThroughElement)->_put_OverlayInputPassThroughElement(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} OverlayInputPassThroughElement;
	};
	IFlyoutBase3_adaptor() {}
};
template<typename X> struct adapt<IFlyoutBase3, X> : Windows::UI::Xaml::Controls::Primitives::IFlyoutBase3_adaptor<X> { typedef adapt IFlyoutBase3; };
struct IFlyoutBase3 : IFlyoutBase3_raw, generate<IFlyoutBase3> {};

// IFlyoutBase2
struct IFlyoutBase2_raw : IInspectable {
	virtual STDMETHODIMP _get_Target(FrameworkElement* *value);
	virtual STDMETHODIMP _get_AllowFocusOnInteraction(bool *value);
	virtual STDMETHODIMP _put_AllowFocusOnInteraction(bool value);
	virtual STDMETHODIMP _get_LightDismissOverlayMode(Controls::LightDismissOverlayMode *value);
	virtual STDMETHODIMP _put_LightDismissOverlayMode(Controls::LightDismissOverlayMode value);
	virtual STDMETHODIMP _get_AllowFocusWhenDisabled(bool *value);
	virtual STDMETHODIMP _put_AllowFocusWhenDisabled(bool value);
	virtual STDMETHODIMP _get_ElementSoundMode(Xaml::ElementSoundMode *value);
	virtual STDMETHODIMP _put_ElementSoundMode(Xaml::ElementSoundMode value);
	virtual STDMETHODIMP _add_Closing(Foundation::TypedEventHandler<FlyoutBase*, FlyoutBaseClosingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Closing(Foundation::EventRegistrationToken token);
};
template<typename X> struct IFlyoutBase2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFlyoutBase2_adaptor::AllowFocusOnInteraction)->_get_AllowFocusOnInteraction(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IFlyoutBase2_adaptor::AllowFocusOnInteraction)->_put_AllowFocusOnInteraction(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AllowFocusOnInteraction;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFlyoutBase2_adaptor::AllowFocusWhenDisabled)->_get_AllowFocusWhenDisabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IFlyoutBase2_adaptor::AllowFocusWhenDisabled)->_put_AllowFocusWhenDisabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AllowFocusWhenDisabled;
		struct : property {
			Xaml::ElementSoundMode get() { Xaml::ElementSoundMode value; hrcheck(enc(&IFlyoutBase2_adaptor::ElementSoundMode)->_get_ElementSoundMode(&value)); return value; }
			Xaml::ElementSoundMode operator()() { return get(); }
			operator Xaml::ElementSoundMode () { return get(); }
			void put(Xaml::ElementSoundMode value) { hrcheck(enc(&IFlyoutBase2_adaptor::ElementSoundMode)->_put_ElementSoundMode(value)); }
			void operator=(Xaml::ElementSoundMode value) { put(value); }
			void operator()(Xaml::ElementSoundMode value) { put(value); }
		} ElementSoundMode;
		struct : property {
			Controls::LightDismissOverlayMode get() { Controls::LightDismissOverlayMode value; hrcheck(enc(&IFlyoutBase2_adaptor::LightDismissOverlayMode)->_get_LightDismissOverlayMode(&value)); return value; }
			Controls::LightDismissOverlayMode operator()() { return get(); }
			operator Controls::LightDismissOverlayMode () { return get(); }
			void put(Controls::LightDismissOverlayMode value) { hrcheck(enc(&IFlyoutBase2_adaptor::LightDismissOverlayMode)->_put_LightDismissOverlayMode(value)); }
			void operator=(Controls::LightDismissOverlayMode value) { put(value); }
			void operator()(Controls::LightDismissOverlayMode value) { put(value); }
		} LightDismissOverlayMode;
		struct : property {
			ptr<FrameworkElement> get() { FrameworkElement* value; hrcheck(enc(&IFlyoutBase2_adaptor::Target)->_get_Target(&value)); return from_abi(value); }
			ptr<FrameworkElement> operator()() { return get(); }
			operator ptr<FrameworkElement> () { return get(); }
			ptr<FrameworkElement> operator->() { return get(); }
		} Target;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<FlyoutBase>, ptr<FlyoutBaseClosingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IFlyoutBase2_adaptor::Closing)->_add_Closing(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IFlyoutBase2_adaptor::Closing)->_remove_Closing(token)); }
		} Closing;
	};
	IFlyoutBase2_adaptor() {}
};
template<typename X> struct adapt<IFlyoutBase2, X> : Windows::UI::Xaml::Controls::Primitives::IFlyoutBase2_adaptor<X> { typedef adapt IFlyoutBase2; };
struct IFlyoutBase2 : IFlyoutBase2_raw, generate<IFlyoutBase2> {};

// IFlyoutBaseOverrides
struct IFlyoutBaseOverrides_raw : IInspectable {
	virtual STDMETHODIMP _CreatePresenter(Control* *returnValue) = 0;
};
template<typename X> struct IFlyoutBaseOverrides_adaptor : X {
	ptr<Control> CreatePresenter() { Control* returnValue; hrcheck(X::get()->_CreatePresenter(&returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IFlyoutBaseOverrides, X> : Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides_adaptor<X> { typedef adapt IFlyoutBaseOverrides; };
template<typename X> struct IFlyoutBaseOverrides_unadaptor : X {
	STDMETHODIMP _CreatePresenter(Control* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->CreatePresenter()); }); }
};
template<typename X> struct unadapt<IFlyoutBaseOverrides, X> : Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides_unadaptor<X> {};
struct IFlyoutBaseOverrides : IFlyoutBaseOverrides_raw, generate<IFlyoutBaseOverrides> {};

// IFlyoutBase
struct IFlyoutBase_raw : IInspectable {
	virtual STDMETHODIMP _get_Placement(FlyoutPlacementMode *value);
	virtual STDMETHODIMP _put_Placement(FlyoutPlacementMode value);
	virtual STDMETHODIMP _add_Opened(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Opened(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Closed(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Closed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Opening(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Opening(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _ShowAt(FrameworkElement* placementTarget);
	virtual STDMETHODIMP _Hide();
};
template<typename X> struct IFlyoutBase_adaptor : X {
	union {
		struct : property {
			FlyoutPlacementMode get() { FlyoutPlacementMode value; hrcheck(enc(&IFlyoutBase_adaptor::Placement)->_get_Placement(&value)); return value; }
			FlyoutPlacementMode operator()() { return get(); }
			operator FlyoutPlacementMode () { return get(); }
			void put(FlyoutPlacementMode value) { hrcheck(enc(&IFlyoutBase_adaptor::Placement)->_put_Placement(value)); }
			void operator=(FlyoutPlacementMode value) { put(value); }
			void operator()(FlyoutPlacementMode value) { put(value); }
		} Placement;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IFlyoutBase_adaptor::Closed)->_add_Closed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IFlyoutBase_adaptor::Closed)->_remove_Closed(token)); }
		} Closed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IFlyoutBase_adaptor::Opened)->_add_Opened(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IFlyoutBase_adaptor::Opened)->_remove_Opened(token)); }
		} Opened;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IFlyoutBase_adaptor::Opening)->_add_Opening(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IFlyoutBase_adaptor::Opening)->_remove_Opening(token)); }
		} Opening;
	};
	void ShowAt(pptr<FrameworkElement> placementTarget) { hrcheck(X::get()->_ShowAt(placementTarget)); }
	void Hide() { hrcheck(X::get()->_Hide()); }
	IFlyoutBase_adaptor() {}
};
template<typename X> struct adapt<IFlyoutBase, X> : Windows::UI::Xaml::Controls::Primitives::IFlyoutBase_adaptor<X> { typedef adapt IFlyoutBase; };
struct IFlyoutBase : IFlyoutBase_raw, generate<IFlyoutBase> {};

// FlyoutBase
template<typename> struct FlyoutBase_statics {
	static struct _AttachedFlyoutProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FlyoutBase, IFlyoutBaseStatics>()->_get_AttachedFlyoutProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AttachedFlyoutProperty;
	static struct _PlacementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FlyoutBase, IFlyoutBaseStatics>()->_get_PlacementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlacementProperty;
	static struct _AllowFocusOnInteractionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FlyoutBase, IFlyoutBaseStatics2>()->_get_AllowFocusOnInteractionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AllowFocusOnInteractionProperty;
	static struct _AllowFocusWhenDisabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FlyoutBase, IFlyoutBaseStatics2>()->_get_AllowFocusWhenDisabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AllowFocusWhenDisabledProperty;
	static struct _ElementSoundModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FlyoutBase, IFlyoutBaseStatics2>()->_get_ElementSoundModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ElementSoundModeProperty;
	static struct _LightDismissOverlayModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FlyoutBase, IFlyoutBaseStatics2>()->_get_LightDismissOverlayModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LightDismissOverlayModeProperty;
	static struct _OverlayInputPassThroughElementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FlyoutBase, IFlyoutBaseStatics3>()->_get_OverlayInputPassThroughElementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OverlayInputPassThroughElementProperty;
	static ptr<FlyoutBase> GetAttachedFlyout(pptr<FrameworkElement> element) { FlyoutBase* value; hrcheck(get_activation_factory<FlyoutBase, IFlyoutBaseStatics>()->_GetAttachedFlyout(element, &value)); return from_abi(value); }
	static void SetAttachedFlyout(pptr<FrameworkElement> element, pptr<FlyoutBase> value) { hrcheck(get_activation_factory<FlyoutBase, IFlyoutBaseStatics>()->_SetAttachedFlyout(element, value)); }
	static void ShowAttachedFlyout(pptr<FrameworkElement> flyoutOwner) { hrcheck(get_activation_factory<FlyoutBase, IFlyoutBaseStatics>()->_ShowAttachedFlyout(flyoutOwner)); }
};
template<typename X> typename FlyoutBase_statics<X>::_AttachedFlyoutProperty FlyoutBase_statics<X>::AttachedFlyoutProperty;
template<typename X> typename FlyoutBase_statics<X>::_PlacementProperty FlyoutBase_statics<X>::PlacementProperty;
template<typename X> typename FlyoutBase_statics<X>::_AllowFocusOnInteractionProperty FlyoutBase_statics<X>::AllowFocusOnInteractionProperty;
template<typename X> typename FlyoutBase_statics<X>::_AllowFocusWhenDisabledProperty FlyoutBase_statics<X>::AllowFocusWhenDisabledProperty;
template<typename X> typename FlyoutBase_statics<X>::_ElementSoundModeProperty FlyoutBase_statics<X>::ElementSoundModeProperty;
template<typename X> typename FlyoutBase_statics<X>::_LightDismissOverlayModeProperty FlyoutBase_statics<X>::LightDismissOverlayModeProperty;
template<typename X> typename FlyoutBase_statics<X>::_OverlayInputPassThroughElementProperty FlyoutBase_statics<X>::OverlayInputPassThroughElementProperty;

template<typename X> struct statics<FlyoutBase, X> : X, Windows::UI::Xaml::Controls::Primitives::FlyoutBase_statics<void> {
	typedef typename X::root_type FlyoutBase;
};
struct FlyoutBase : generate<FlyoutBase> {};

// PickerFlyoutBase
template<typename> struct PickerFlyoutBase_statics {
	static struct _TitleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PickerFlyoutBase, IPickerFlyoutBaseStatics>()->_get_TitleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TitleProperty;
	static hstring GetTitle(pptr<DependencyObject> element) { HSTRING value; hrcheck(get_activation_factory<PickerFlyoutBase, IPickerFlyoutBaseStatics>()->_GetTitle(element, &value)); return from_abi(value); }
	static void SetTitle(pptr<DependencyObject> element, hstring_ref value) { hrcheck(get_activation_factory<PickerFlyoutBase, IPickerFlyoutBaseStatics>()->_SetTitle(element, value)); }
};
template<typename X> typename PickerFlyoutBase_statics<X>::_TitleProperty PickerFlyoutBase_statics<X>::TitleProperty;

template<typename X> struct statics<PickerFlyoutBase, X> : X, Windows::UI::Xaml::Controls::Primitives::PickerFlyoutBase_statics<void> {
	typedef typename X::root_type PickerFlyoutBase;
};
struct PickerFlyoutBase : generate<PickerFlyoutBase> {};

// IJumpListItemForegroundConverterStatics
struct IJumpListItemForegroundConverterStatics : IInspectable {
	virtual STDMETHODIMP _get_EnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DisabledProperty(DependencyProperty* *value);
};

// IJumpListItemForegroundConverter
struct IJumpListItemForegroundConverter_raw : IInspectable {
	virtual STDMETHODIMP _get_Enabled(Media::Brush* *value);
	virtual STDMETHODIMP _put_Enabled(Media::Brush* value);
	virtual STDMETHODIMP _get_Disabled(Media::Brush* *value);
	virtual STDMETHODIMP _put_Disabled(Media::Brush* value);
};
template<typename X> struct IJumpListItemForegroundConverter_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IJumpListItemForegroundConverter_adaptor::Disabled)->_get_Disabled(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IJumpListItemForegroundConverter_adaptor::Disabled)->_put_Disabled(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Disabled;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IJumpListItemForegroundConverter_adaptor::Enabled)->_get_Enabled(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IJumpListItemForegroundConverter_adaptor::Enabled)->_put_Enabled(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Enabled;
	};
	IJumpListItemForegroundConverter_adaptor() {}
};
template<typename X> struct adapt<IJumpListItemForegroundConverter, X> : Windows::UI::Xaml::Controls::Primitives::IJumpListItemForegroundConverter_adaptor<X> { typedef adapt IJumpListItemForegroundConverter; };
struct IJumpListItemForegroundConverter : IJumpListItemForegroundConverter_raw, generate<IJumpListItemForegroundConverter> {};

// JumpListItemForegroundConverter
template<typename> struct JumpListItemForegroundConverter_statics {
	static struct _DisabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<JumpListItemForegroundConverter, IJumpListItemForegroundConverterStatics>()->_get_DisabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DisabledProperty;
	static struct _EnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<JumpListItemForegroundConverter, IJumpListItemForegroundConverterStatics>()->_get_EnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EnabledProperty;
};
template<typename X> typename JumpListItemForegroundConverter_statics<X>::_DisabledProperty JumpListItemForegroundConverter_statics<X>::DisabledProperty;
template<typename X> typename JumpListItemForegroundConverter_statics<X>::_EnabledProperty JumpListItemForegroundConverter_statics<X>::EnabledProperty;

template<typename X> struct statics<JumpListItemForegroundConverter, X> : X, Windows::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter_statics<void> {
	typedef typename X::root_type JumpListItemForegroundConverter;
};
struct JumpListItemForegroundConverter : generate<JumpListItemForegroundConverter> {};

// IJumpListItemBackgroundConverterStatics
struct IJumpListItemBackgroundConverterStatics : IInspectable {
	virtual STDMETHODIMP _get_EnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DisabledProperty(DependencyProperty* *value);
};

// IJumpListItemBackgroundConverter
struct IJumpListItemBackgroundConverter_raw : IInspectable {
	virtual STDMETHODIMP _get_Enabled(Media::Brush* *value);
	virtual STDMETHODIMP _put_Enabled(Media::Brush* value);
	virtual STDMETHODIMP _get_Disabled(Media::Brush* *value);
	virtual STDMETHODIMP _put_Disabled(Media::Brush* value);
};
template<typename X> struct IJumpListItemBackgroundConverter_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IJumpListItemBackgroundConverter_adaptor::Disabled)->_get_Disabled(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IJumpListItemBackgroundConverter_adaptor::Disabled)->_put_Disabled(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Disabled;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IJumpListItemBackgroundConverter_adaptor::Enabled)->_get_Enabled(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IJumpListItemBackgroundConverter_adaptor::Enabled)->_put_Enabled(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Enabled;
	};
	IJumpListItemBackgroundConverter_adaptor() {}
};
template<typename X> struct adapt<IJumpListItemBackgroundConverter, X> : Windows::UI::Xaml::Controls::Primitives::IJumpListItemBackgroundConverter_adaptor<X> { typedef adapt IJumpListItemBackgroundConverter; };
struct IJumpListItemBackgroundConverter : IJumpListItemBackgroundConverter_raw, generate<IJumpListItemBackgroundConverter> {};

// JumpListItemBackgroundConverter
template<typename> struct JumpListItemBackgroundConverter_statics {
	static struct _DisabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<JumpListItemBackgroundConverter, IJumpListItemBackgroundConverterStatics>()->_get_DisabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DisabledProperty;
	static struct _EnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<JumpListItemBackgroundConverter, IJumpListItemBackgroundConverterStatics>()->_get_EnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} EnabledProperty;
};
template<typename X> typename JumpListItemBackgroundConverter_statics<X>::_DisabledProperty JumpListItemBackgroundConverter_statics<X>::DisabledProperty;
template<typename X> typename JumpListItemBackgroundConverter_statics<X>::_EnabledProperty JumpListItemBackgroundConverter_statics<X>::EnabledProperty;

template<typename X> struct statics<JumpListItemBackgroundConverter, X> : X, Windows::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter_statics<void> {
	typedef typename X::root_type JumpListItemBackgroundConverter;
};
struct JumpListItemBackgroundConverter : generate<JumpListItemBackgroundConverter> {};

// IFlyoutBaseClosingEventArgs
struct IFlyoutBaseClosingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Cancel(bool *value);
	virtual STDMETHODIMP _put_Cancel(bool value);
};
template<typename X> struct IFlyoutBaseClosingEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFlyoutBaseClosingEventArgs_adaptor::Cancel)->_get_Cancel(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IFlyoutBaseClosingEventArgs_adaptor::Cancel)->_put_Cancel(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Cancel;
	};
	IFlyoutBaseClosingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IFlyoutBaseClosingEventArgs, X> : Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseClosingEventArgs_adaptor<X> { typedef adapt IFlyoutBaseClosingEventArgs; };
struct IFlyoutBaseClosingEventArgs : IFlyoutBaseClosingEventArgs_raw, generate<IFlyoutBaseClosingEventArgs> {};

// FlyoutBaseClosingEventArgs
template<typename X> struct statics<FlyoutBaseClosingEventArgs, X> : X {
	typedef typename X::root_type FlyoutBaseClosingEventArgs;
};
struct FlyoutBaseClosingEventArgs : generate<FlyoutBaseClosingEventArgs> {};

// IToggleButtonFactory
struct IToggleButtonFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ToggleButton* *instance);
};

// IToggleButtonStatics
struct IToggleButtonStatics : IInspectable {
	virtual STDMETHODIMP _get_IsCheckedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsThreeStateProperty(DependencyProperty* *value);
};

// IToggleButtonOverrides
struct IToggleButtonOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnToggle() = 0;
};
template<typename X> struct IToggleButtonOverrides_adaptor : X {
	void OnToggle() { hrcheck(X::get()->_OnToggle()); }
};
template<typename X> struct adapt<IToggleButtonOverrides, X> : Windows::UI::Xaml::Controls::Primitives::IToggleButtonOverrides_adaptor<X> { typedef adapt IToggleButtonOverrides; };
template<typename X> struct IToggleButtonOverrides_unadaptor : X {
	STDMETHODIMP _OnToggle() { return hrtry([&, this] { X::get()->OnToggle(); }); }
};
template<typename X> struct unadapt<IToggleButtonOverrides, X> : Windows::UI::Xaml::Controls::Primitives::IToggleButtonOverrides_unadaptor<X> {};
struct IToggleButtonOverrides : IToggleButtonOverrides_raw, generate<IToggleButtonOverrides> {};

// IToggleButton
struct IToggleButton_raw : IInspectable {
	virtual STDMETHODIMP _get_IsChecked(Foundation::IReference<bool>* *value);
	virtual STDMETHODIMP _put_IsChecked(Foundation::IReference<bool>* value);
	virtual STDMETHODIMP _get_IsThreeState(bool *value);
	virtual STDMETHODIMP _put_IsThreeState(bool value);
	virtual STDMETHODIMP _add_Checked(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Checked(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Unchecked(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Unchecked(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Indeterminate(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Indeterminate(Foundation::EventRegistrationToken token);
};
template<typename X> struct IToggleButton_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<bool>> get() { Foundation::IReference<bool>* value; hrcheck(enc(&IToggleButton_adaptor::IsChecked)->_get_IsChecked(&value)); return from_abi(value); }
			ptr<Foundation::IReference<bool>> operator()() { return get(); }
			operator ptr<Foundation::IReference<bool>> () { return get(); }
			ptr<Foundation::IReference<bool>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<bool>> value) { hrcheck(enc(&IToggleButton_adaptor::IsChecked)->_put_IsChecked(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<bool>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<bool>> value) { put(to_abi(value)); }
		} IsChecked;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IToggleButton_adaptor::IsThreeState)->_get_IsThreeState(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IToggleButton_adaptor::IsThreeState)->_put_IsThreeState(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsThreeState;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IToggleButton_adaptor::Checked)->_add_Checked(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IToggleButton_adaptor::Checked)->_remove_Checked(token)); }
		} Checked;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IToggleButton_adaptor::Indeterminate)->_add_Indeterminate(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IToggleButton_adaptor::Indeterminate)->_remove_Indeterminate(token)); }
		} Indeterminate;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IToggleButton_adaptor::Unchecked)->_add_Unchecked(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IToggleButton_adaptor::Unchecked)->_remove_Unchecked(token)); }
		} Unchecked;
	};
	IToggleButton_adaptor() {}
};
template<typename X> struct adapt<IToggleButton, X> : Windows::UI::Xaml::Controls::Primitives::IToggleButton_adaptor<X> { typedef adapt IToggleButton; };
struct IToggleButton : IToggleButton_raw, generate<IToggleButton> {};

// IButtonBaseFactory
struct IButtonBaseFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ButtonBase* *instance);
};

// IButtonBaseStatics
struct IButtonBaseStatics : IInspectable {
	virtual STDMETHODIMP _get_ClickModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsPointerOverProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsPressedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CommandProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CommandParameterProperty(DependencyProperty* *value);
};

// IButtonBase
struct IButtonBase_raw : IInspectable {
	virtual STDMETHODIMP _get_ClickMode(Controls::ClickMode *value);
	virtual STDMETHODIMP _put_ClickMode(Controls::ClickMode value);
	virtual STDMETHODIMP _get_IsPointerOver(bool *value);
	virtual STDMETHODIMP _get_IsPressed(bool *value);
	virtual STDMETHODIMP _get_Command(Input::ICommand* *value);
	virtual STDMETHODIMP _put_Command(Input::ICommand* value);
	virtual STDMETHODIMP _get_CommandParameter(IInspectable* *value);
	virtual STDMETHODIMP _put_CommandParameter(IInspectable* value);
	virtual STDMETHODIMP _add_Click(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Click(Foundation::EventRegistrationToken token);
};
template<typename X> struct IButtonBase_adaptor : X {
	union {
		struct : property {
			Controls::ClickMode get() { Controls::ClickMode value; hrcheck(enc(&IButtonBase_adaptor::ClickMode)->_get_ClickMode(&value)); return value; }
			Controls::ClickMode operator()() { return get(); }
			operator Controls::ClickMode () { return get(); }
			void put(Controls::ClickMode value) { hrcheck(enc(&IButtonBase_adaptor::ClickMode)->_put_ClickMode(value)); }
			void operator=(Controls::ClickMode value) { put(value); }
			void operator()(Controls::ClickMode value) { put(value); }
		} ClickMode;
		struct : property {
			ptr<Input::ICommand> get() { Input::ICommand* value; hrcheck(enc(&IButtonBase_adaptor::Command)->_get_Command(&value)); return from_abi(value); }
			ptr<Input::ICommand> operator()() { return get(); }
			operator ptr<Input::ICommand> () { return get(); }
			ptr<Input::ICommand> operator->() { return get(); }
			void put(pptr<Input::ICommand> value) { hrcheck(enc(&IButtonBase_adaptor::Command)->_put_Command(value)); }
			void operator=(pptr<Input::ICommand> value) { put(value); }
			void operator()(pptr<Input::ICommand> value) { put(value); }
		} Command;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IButtonBase_adaptor::CommandParameter)->_get_CommandParameter(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IButtonBase_adaptor::CommandParameter)->_put_CommandParameter(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} CommandParameter;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IButtonBase_adaptor::IsPointerOver)->_get_IsPointerOver(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsPointerOver;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IButtonBase_adaptor::IsPressed)->_get_IsPressed(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsPressed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IButtonBase_adaptor::Click)->_add_Click(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IButtonBase_adaptor::Click)->_remove_Click(token)); }
		} Click;
	};
	IButtonBase_adaptor() {}
};
template<typename X> struct adapt<IButtonBase, X> : Windows::UI::Xaml::Controls::Primitives::IButtonBase_adaptor<X> { typedef adapt IButtonBase; };
struct IButtonBase : IButtonBase_raw, generate<IButtonBase> {};

// ButtonBase
template<typename> struct ButtonBase_statics {
	static struct _ClickModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ButtonBase, IButtonBaseStatics>()->_get_ClickModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ClickModeProperty;
	static struct _CommandParameterProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ButtonBase, IButtonBaseStatics>()->_get_CommandParameterProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CommandParameterProperty;
	static struct _CommandProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ButtonBase, IButtonBaseStatics>()->_get_CommandProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CommandProperty;
	static struct _IsPointerOverProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ButtonBase, IButtonBaseStatics>()->_get_IsPointerOverProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsPointerOverProperty;
	static struct _IsPressedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ButtonBase, IButtonBaseStatics>()->_get_IsPressedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsPressedProperty;
};
template<typename X> typename ButtonBase_statics<X>::_ClickModeProperty ButtonBase_statics<X>::ClickModeProperty;
template<typename X> typename ButtonBase_statics<X>::_CommandParameterProperty ButtonBase_statics<X>::CommandParameterProperty;
template<typename X> typename ButtonBase_statics<X>::_CommandProperty ButtonBase_statics<X>::CommandProperty;
template<typename X> typename ButtonBase_statics<X>::_IsPointerOverProperty ButtonBase_statics<X>::IsPointerOverProperty;
template<typename X> typename ButtonBase_statics<X>::_IsPressedProperty ButtonBase_statics<X>::IsPressedProperty;

template<typename X> struct statics<ButtonBase, X> : X, Windows::UI::Xaml::Controls::Primitives::ButtonBase_statics<void> {
	typedef typename X::root_type ButtonBase;
};
struct ButtonBase : generate<ButtonBase> {};

// ToggleButton
template<typename> struct ToggleButton_statics {
	static struct _IsCheckedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToggleButton, IToggleButtonStatics>()->_get_IsCheckedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsCheckedProperty;
	static struct _IsThreeStateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToggleButton, IToggleButtonStatics>()->_get_IsThreeStateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsThreeStateProperty;
	static ToggleButton *activate(object_ref outer, IInspectable* *inner) { ToggleButton *instance; hrcheck(get_activation_factory<ToggleButton, IToggleButtonFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename ToggleButton_statics<X>::_IsCheckedProperty ToggleButton_statics<X>::IsCheckedProperty;
template<typename X> typename ToggleButton_statics<X>::_IsThreeStateProperty ToggleButton_statics<X>::IsThreeStateProperty;

template<typename X> struct statics<ToggleButton, X> : X, Windows::UI::Xaml::Controls::Primitives::ToggleButton_statics<void> {
	using Windows::UI::Xaml::Controls::Primitives::ToggleButton_statics<void>::activate;
	typedef typename X::root_type ToggleButton;
};
struct ToggleButton : generate<ToggleButton> {};

// IRepeatButtonStatics
struct IRepeatButtonStatics : IInspectable {
	virtual STDMETHODIMP _get_DelayProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IntervalProperty(DependencyProperty* *value);
};

// IRepeatButton
struct IRepeatButton_raw : IInspectable {
	virtual STDMETHODIMP _get_Delay(int *value);
	virtual STDMETHODIMP _put_Delay(int value);
	virtual STDMETHODIMP _get_Interval(int *value);
	virtual STDMETHODIMP _put_Interval(int value);
};
template<typename X> struct IRepeatButton_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IRepeatButton_adaptor::Delay)->_get_Delay(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IRepeatButton_adaptor::Delay)->_put_Delay(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} Delay;
		struct : property {
			int get() { int value; hrcheck(enc(&IRepeatButton_adaptor::Interval)->_get_Interval(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IRepeatButton_adaptor::Interval)->_put_Interval(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} Interval;
	};
	IRepeatButton_adaptor() {}
};
template<typename X> struct adapt<IRepeatButton, X> : Windows::UI::Xaml::Controls::Primitives::IRepeatButton_adaptor<X> { typedef adapt IRepeatButton; };
struct IRepeatButton : IRepeatButton_raw, generate<IRepeatButton> {};

// RepeatButton
template<typename> struct RepeatButton_statics {
	static struct _DelayProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RepeatButton, IRepeatButtonStatics>()->_get_DelayProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DelayProperty;
	static struct _IntervalProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RepeatButton, IRepeatButtonStatics>()->_get_IntervalProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IntervalProperty;
};
template<typename X> typename RepeatButton_statics<X>::_DelayProperty RepeatButton_statics<X>::DelayProperty;
template<typename X> typename RepeatButton_statics<X>::_IntervalProperty RepeatButton_statics<X>::IntervalProperty;

template<typename X> struct statics<RepeatButton, X> : X, Windows::UI::Xaml::Controls::Primitives::RepeatButton_statics<void> {
	typedef typename X::root_type RepeatButton;
};
struct RepeatButton : generate<RepeatButton> {};

// ISelectorFactory
struct ISelectorFactory : IInspectable, generate<ISelectorFactory> {};

// ISelectorStatics
struct ISelectorStatics : IInspectable {
	virtual STDMETHODIMP _get_SelectedIndexProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedItemProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedValueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedValuePathProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsSynchronizedWithCurrentItemProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsSelectionActive(DependencyObject* element, bool *returnValue);
};

// ISelector
struct ISelector_raw : IInspectable {
	virtual STDMETHODIMP _get_SelectedIndex(int *value);
	virtual STDMETHODIMP _put_SelectedIndex(int value);
	virtual STDMETHODIMP _get_SelectedItem(IInspectable* *value);
	virtual STDMETHODIMP _put_SelectedItem(IInspectable* value);
	virtual STDMETHODIMP _get_SelectedValue(IInspectable* *value);
	virtual STDMETHODIMP _put_SelectedValue(IInspectable* value);
	virtual STDMETHODIMP _get_SelectedValuePath(HSTRING *value);
	virtual STDMETHODIMP _put_SelectedValuePath(HSTRING value);
	virtual STDMETHODIMP _get_IsSynchronizedWithCurrentItem(Foundation::IReference<bool>* *value);
	virtual STDMETHODIMP _put_IsSynchronizedWithCurrentItem(Foundation::IReference<bool>* value);
	virtual STDMETHODIMP _add_SelectionChanged(SelectionChangedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SelectionChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct ISelector_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<bool>> get() { Foundation::IReference<bool>* value; hrcheck(enc(&ISelector_adaptor::IsSynchronizedWithCurrentItem)->_get_IsSynchronizedWithCurrentItem(&value)); return from_abi(value); }
			ptr<Foundation::IReference<bool>> operator()() { return get(); }
			operator ptr<Foundation::IReference<bool>> () { return get(); }
			ptr<Foundation::IReference<bool>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<bool>> value) { hrcheck(enc(&ISelector_adaptor::IsSynchronizedWithCurrentItem)->_put_IsSynchronizedWithCurrentItem(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<bool>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<bool>> value) { put(to_abi(value)); }
		} IsSynchronizedWithCurrentItem;
		struct : property {
			int get() { int value; hrcheck(enc(&ISelector_adaptor::SelectedIndex)->_get_SelectedIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ISelector_adaptor::SelectedIndex)->_put_SelectedIndex(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} SelectedIndex;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ISelector_adaptor::SelectedItem)->_get_SelectedItem(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&ISelector_adaptor::SelectedItem)->_put_SelectedItem(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} SelectedItem;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ISelector_adaptor::SelectedValue)->_get_SelectedValue(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&ISelector_adaptor::SelectedValue)->_put_SelectedValue(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} SelectedValue;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISelector_adaptor::SelectedValuePath)->_get_SelectedValuePath(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISelector_adaptor::SelectedValuePath)->_put_SelectedValuePath(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} SelectedValuePath;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<SelectionChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISelector_adaptor::SelectionChanged)->_add_SelectionChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISelector_adaptor::SelectionChanged)->_remove_SelectionChanged(token)); }
		} SelectionChanged;
	};
	ISelector_adaptor() {}
};
template<typename X> struct adapt<ISelector, X> : Windows::UI::Xaml::Controls::Primitives::ISelector_adaptor<X> { typedef adapt ISelector; };
struct ISelector : ISelector_raw, generate<ISelector> {};
}

// IItemsControlFactory
struct IItemsControlFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ItemsControl* *instance);
};

// IItemsControlStatics
struct IItemsControlStatics : IInspectable {
	virtual STDMETHODIMP _get_ItemsSourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemTemplateSelectorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemsPanelProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DisplayMemberPathProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemContainerStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemContainerStyleSelectorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemContainerTransitionsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_GroupStyleSelectorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsGroupingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetItemsOwner(DependencyObject* element, ItemsControl* *returnValue);
	virtual STDMETHODIMP _ItemsControlFromItemContainer(DependencyObject* container, ItemsControl* *returnValue);
};

// IItemsControl3
struct IItemsControl3_raw : IInspectable {
	virtual STDMETHODIMP _GroupHeaderContainerFromItemContainer(DependencyObject* itemContainer, DependencyObject* *returnValue);
};
template<typename X> struct IItemsControl3_adaptor : X {
	ptr<DependencyObject> GroupHeaderContainerFromItemContainer(pptr<DependencyObject> itemContainer) { DependencyObject* returnValue; hrcheck(X::get()->_GroupHeaderContainerFromItemContainer(itemContainer, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IItemsControl3, X> : Windows::UI::Xaml::Controls::IItemsControl3_adaptor<X> { typedef adapt IItemsControl3; };
struct IItemsControl3 : IItemsControl3_raw, generate<IItemsControl3> {};

// IItemContainerMapping
struct IItemContainerMapping_raw : IInspectable {
	virtual STDMETHODIMP _ItemFromContainer(DependencyObject* container, IInspectable* *returnValue) = 0;
	virtual STDMETHODIMP _ContainerFromItem(IInspectable* item, DependencyObject* *returnValue) = 0;
	virtual STDMETHODIMP _IndexFromContainer(DependencyObject* container, int *returnValue) = 0;
	virtual STDMETHODIMP _ContainerFromIndex(int index, DependencyObject* *returnValue) = 0;
};
template<typename X> struct IItemContainerMapping_adaptor : X {
	object ItemFromContainer(pptr<DependencyObject> container) { IInspectable* returnValue; hrcheck(X::get()->_ItemFromContainer(container, &returnValue)); return from_abi(returnValue); }
	ptr<DependencyObject> ContainerFromItem(object_ref item) { DependencyObject* returnValue; hrcheck(X::get()->_ContainerFromItem(item, &returnValue)); return from_abi(returnValue); }
	int IndexFromContainer(pptr<DependencyObject> container) { int returnValue; hrcheck(X::get()->_IndexFromContainer(container, &returnValue)); return returnValue; }
	ptr<DependencyObject> ContainerFromIndex(int index) { DependencyObject* returnValue; hrcheck(X::get()->_ContainerFromIndex(index, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IItemContainerMapping, X> : Windows::UI::Xaml::Controls::IItemContainerMapping_adaptor<X> { typedef adapt IItemContainerMapping; };
template<typename X> struct IItemContainerMapping_unadaptor : X {
	STDMETHODIMP _ItemFromContainer(DependencyObject* container, IInspectable* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->ItemFromContainer(container)); }); }
	STDMETHODIMP _ContainerFromItem(IInspectable* item, DependencyObject* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->ContainerFromItem(item)); }); }
	STDMETHODIMP _IndexFromContainer(DependencyObject* container, int *returnValue) { return hrtry([&, this] { *returnValue = X::get()->IndexFromContainer(container); }); }
	STDMETHODIMP _ContainerFromIndex(int index, DependencyObject* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->ContainerFromIndex(index)); }); }
};
template<typename X> struct unadapt<IItemContainerMapping, X> : Windows::UI::Xaml::Controls::IItemContainerMapping_unadaptor<X> {};
struct IItemContainerMapping : IItemContainerMapping_raw, generate<IItemContainerMapping> {};

// IItemsControl2
struct IItemsControl2_raw : IInspectable {
	virtual STDMETHODIMP _get_ItemsPanelRoot(Panel* *value);
};
template<typename X> struct IItemsControl2_adaptor : X {
	union {
		struct : property {
			ptr<Panel> get() { Panel* value; hrcheck(enc(&IItemsControl2_adaptor::ItemsPanelRoot)->_get_ItemsPanelRoot(&value)); return from_abi(value); }
			ptr<Panel> operator()() { return get(); }
			operator ptr<Panel> () { return get(); }
			ptr<Panel> operator->() { return get(); }
		} ItemsPanelRoot;
	};
	IItemsControl2_adaptor() {}
};
template<typename X> struct adapt<IItemsControl2, X> : Windows::UI::Xaml::Controls::IItemsControl2_adaptor<X> { typedef adapt IItemsControl2; };
struct IItemsControl2 : IItemsControl2_raw, generate<IItemsControl2> {};

// IItemsControlOverrides
struct IItemsControlOverrides_raw : IInspectable {
	virtual STDMETHODIMP _IsItemItsOwnContainerOverride(IInspectable* item, bool *returnValue) = 0;
	virtual STDMETHODIMP _GetContainerForItemOverride(DependencyObject* *returnValue) = 0;
	virtual STDMETHODIMP _ClearContainerForItemOverride(DependencyObject* element, IInspectable* item) = 0;
	virtual STDMETHODIMP _PrepareContainerForItemOverride(DependencyObject* element, IInspectable* item) = 0;
	virtual STDMETHODIMP _OnItemsChanged(IInspectable* e) = 0;
	virtual STDMETHODIMP _OnItemContainerStyleChanged(Style* oldItemContainerStyle, Style* newItemContainerStyle) = 0;
	virtual STDMETHODIMP _OnItemContainerStyleSelectorChanged(StyleSelector* oldItemContainerStyleSelector, StyleSelector* newItemContainerStyleSelector) = 0;
	virtual STDMETHODIMP _OnItemTemplateChanged(DataTemplate* oldItemTemplate, DataTemplate* newItemTemplate) = 0;
	virtual STDMETHODIMP _OnItemTemplateSelectorChanged(DataTemplateSelector* oldItemTemplateSelector, DataTemplateSelector* newItemTemplateSelector) = 0;
	virtual STDMETHODIMP _OnGroupStyleSelectorChanged(GroupStyleSelector* oldGroupStyleSelector, GroupStyleSelector* newGroupStyleSelector) = 0;
};
template<typename X> struct IItemsControlOverrides_adaptor : X {
	bool IsItemItsOwnContainerOverride(object_ref item) { bool returnValue; hrcheck(X::get()->_IsItemItsOwnContainerOverride(item, &returnValue)); return returnValue; }
	ptr<DependencyObject> GetContainerForItemOverride() { DependencyObject* returnValue; hrcheck(X::get()->_GetContainerForItemOverride(&returnValue)); return from_abi(returnValue); }
	void ClearContainerForItemOverride(pptr<DependencyObject> element, object_ref item) { hrcheck(X::get()->_ClearContainerForItemOverride(element, item)); }
	void PrepareContainerForItemOverride(pptr<DependencyObject> element, object_ref item) { hrcheck(X::get()->_PrepareContainerForItemOverride(element, item)); }
	void OnItemsChanged(object_ref e) { hrcheck(X::get()->_OnItemsChanged(e)); }
	void OnItemContainerStyleChanged(pptr<Style> oldItemContainerStyle, pptr<Style> newItemContainerStyle) { hrcheck(X::get()->_OnItemContainerStyleChanged(oldItemContainerStyle, newItemContainerStyle)); }
	void OnItemContainerStyleSelectorChanged(pptr<StyleSelector> oldItemContainerStyleSelector, pptr<StyleSelector> newItemContainerStyleSelector) { hrcheck(X::get()->_OnItemContainerStyleSelectorChanged(oldItemContainerStyleSelector, newItemContainerStyleSelector)); }
	void OnItemTemplateChanged(pptr<DataTemplate> oldItemTemplate, pptr<DataTemplate> newItemTemplate) { hrcheck(X::get()->_OnItemTemplateChanged(oldItemTemplate, newItemTemplate)); }
	void OnItemTemplateSelectorChanged(pptr<DataTemplateSelector> oldItemTemplateSelector, pptr<DataTemplateSelector> newItemTemplateSelector) { hrcheck(X::get()->_OnItemTemplateSelectorChanged(oldItemTemplateSelector, newItemTemplateSelector)); }
	void OnGroupStyleSelectorChanged(pptr<GroupStyleSelector> oldGroupStyleSelector, pptr<GroupStyleSelector> newGroupStyleSelector) { hrcheck(X::get()->_OnGroupStyleSelectorChanged(oldGroupStyleSelector, newGroupStyleSelector)); }
};
template<typename X> struct adapt<IItemsControlOverrides, X> : Windows::UI::Xaml::Controls::IItemsControlOverrides_adaptor<X> { typedef adapt IItemsControlOverrides; };
template<typename X> struct IItemsControlOverrides_unadaptor : X {
	STDMETHODIMP _IsItemItsOwnContainerOverride(IInspectable* item, bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->IsItemItsOwnContainerOverride(item); }); }
	STDMETHODIMP _GetContainerForItemOverride(DependencyObject* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetContainerForItemOverride()); }); }
	STDMETHODIMP _ClearContainerForItemOverride(DependencyObject* element, IInspectable* item) { return hrtry([&, this] { X::get()->ClearContainerForItemOverride(element, item); }); }
	STDMETHODIMP _PrepareContainerForItemOverride(DependencyObject* element, IInspectable* item) { return hrtry([&, this] { X::get()->PrepareContainerForItemOverride(element, item); }); }
	STDMETHODIMP _OnItemsChanged(IInspectable* e) { return hrtry([&, this] { X::get()->OnItemsChanged(e); }); }
	STDMETHODIMP _OnItemContainerStyleChanged(Style* oldItemContainerStyle, Style* newItemContainerStyle) { return hrtry([&, this] { X::get()->OnItemContainerStyleChanged(oldItemContainerStyle, newItemContainerStyle); }); }
	STDMETHODIMP _OnItemContainerStyleSelectorChanged(StyleSelector* oldItemContainerStyleSelector, StyleSelector* newItemContainerStyleSelector) { return hrtry([&, this] { X::get()->OnItemContainerStyleSelectorChanged(oldItemContainerStyleSelector, newItemContainerStyleSelector); }); }
	STDMETHODIMP _OnItemTemplateChanged(DataTemplate* oldItemTemplate, DataTemplate* newItemTemplate) { return hrtry([&, this] { X::get()->OnItemTemplateChanged(oldItemTemplate, newItemTemplate); }); }
	STDMETHODIMP _OnItemTemplateSelectorChanged(DataTemplateSelector* oldItemTemplateSelector, DataTemplateSelector* newItemTemplateSelector) { return hrtry([&, this] { X::get()->OnItemTemplateSelectorChanged(oldItemTemplateSelector, newItemTemplateSelector); }); }
	STDMETHODIMP _OnGroupStyleSelectorChanged(GroupStyleSelector* oldGroupStyleSelector, GroupStyleSelector* newGroupStyleSelector) { return hrtry([&, this] { X::get()->OnGroupStyleSelectorChanged(oldGroupStyleSelector, newGroupStyleSelector); }); }
};
template<typename X> struct unadapt<IItemsControlOverrides, X> : Windows::UI::Xaml::Controls::IItemsControlOverrides_unadaptor<X> {};
struct IItemsControlOverrides : IItemsControlOverrides_raw, generate<IItemsControlOverrides> {};

// IItemsControl
struct IItemsControl_raw : IInspectable {
	virtual STDMETHODIMP _get_ItemsSource(IInspectable* *value);
	virtual STDMETHODIMP _put_ItemsSource(IInspectable* value);
	virtual STDMETHODIMP _get_Items(ItemCollection* *value);
	virtual STDMETHODIMP _get_ItemTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_ItemTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_ItemTemplateSelector(DataTemplateSelector* *value);
	virtual STDMETHODIMP _put_ItemTemplateSelector(DataTemplateSelector* value);
	virtual STDMETHODIMP _get_ItemsPanel(ItemsPanelTemplate* *value);
	virtual STDMETHODIMP _put_ItemsPanel(ItemsPanelTemplate* value);
	virtual STDMETHODIMP _get_DisplayMemberPath(HSTRING *value);
	virtual STDMETHODIMP _put_DisplayMemberPath(HSTRING value);
	virtual STDMETHODIMP _get_ItemContainerStyle(Style* *value);
	virtual STDMETHODIMP _put_ItemContainerStyle(Style* value);
	virtual STDMETHODIMP _get_ItemContainerStyleSelector(StyleSelector* *value);
	virtual STDMETHODIMP _put_ItemContainerStyleSelector(StyleSelector* value);
	virtual STDMETHODIMP _get_ItemContainerGenerator(Controls::ItemContainerGenerator* *value);
	virtual STDMETHODIMP _get_ItemContainerTransitions(Media::Animation::TransitionCollection* *value);
	virtual STDMETHODIMP _put_ItemContainerTransitions(Media::Animation::TransitionCollection* value);
	virtual STDMETHODIMP _get_GroupStyle(Foundation::Collections::IObservableVector<Controls::GroupStyle*>* *value);
	virtual STDMETHODIMP _get_GroupStyleSelector(Controls::GroupStyleSelector* *value);
	virtual STDMETHODIMP _put_GroupStyleSelector(Controls::GroupStyleSelector* value);
	virtual STDMETHODIMP _get_IsGrouping(bool *value);
};
template<typename X> struct IItemsControl_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IItemsControl_adaptor::DisplayMemberPath)->_get_DisplayMemberPath(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IItemsControl_adaptor::DisplayMemberPath)->_put_DisplayMemberPath(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DisplayMemberPath;
		struct : property {
			ptr<Foundation::Collections::IObservableVector<ptr<Controls::GroupStyle>>> get() { Foundation::Collections::IObservableVector<Controls::GroupStyle*>* value; hrcheck(enc(&IItemsControl_adaptor::GroupStyle)->_get_GroupStyle(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IObservableVector<ptr<Controls::GroupStyle>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IObservableVector<ptr<Controls::GroupStyle>>> () { return get(); }
			ptr<Foundation::Collections::IObservableVector<ptr<Controls::GroupStyle>>> operator->() { return get(); }
		} GroupStyle;
		struct : property {
			ptr<Controls::GroupStyleSelector> get() { Controls::GroupStyleSelector* value; hrcheck(enc(&IItemsControl_adaptor::GroupStyleSelector)->_get_GroupStyleSelector(&value)); return from_abi(value); }
			ptr<Controls::GroupStyleSelector> operator()() { return get(); }
			operator ptr<Controls::GroupStyleSelector> () { return get(); }
			ptr<Controls::GroupStyleSelector> operator->() { return get(); }
			void put(pptr<Controls::GroupStyleSelector> value) { hrcheck(enc(&IItemsControl_adaptor::GroupStyleSelector)->_put_GroupStyleSelector(value)); }
			void operator=(pptr<Controls::GroupStyleSelector> value) { put(value); }
			void operator()(pptr<Controls::GroupStyleSelector> value) { put(value); }
		} GroupStyleSelector;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IItemsControl_adaptor::IsGrouping)->_get_IsGrouping(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsGrouping;
		struct : property {
			ptr<Controls::ItemContainerGenerator> get() { Controls::ItemContainerGenerator* value; hrcheck(enc(&IItemsControl_adaptor::ItemContainerGenerator)->_get_ItemContainerGenerator(&value)); return from_abi(value); }
			ptr<Controls::ItemContainerGenerator> operator()() { return get(); }
			operator ptr<Controls::ItemContainerGenerator> () { return get(); }
			ptr<Controls::ItemContainerGenerator> operator->() { return get(); }
		} ItemContainerGenerator;
		struct : property {
			ptr<Style> get() { Style* value; hrcheck(enc(&IItemsControl_adaptor::ItemContainerStyle)->_get_ItemContainerStyle(&value)); return from_abi(value); }
			ptr<Style> operator()() { return get(); }
			operator ptr<Style> () { return get(); }
			ptr<Style> operator->() { return get(); }
			void put(pptr<Style> value) { hrcheck(enc(&IItemsControl_adaptor::ItemContainerStyle)->_put_ItemContainerStyle(value)); }
			void operator=(pptr<Style> value) { put(value); }
			void operator()(pptr<Style> value) { put(value); }
		} ItemContainerStyle;
		struct : property {
			ptr<StyleSelector> get() { StyleSelector* value; hrcheck(enc(&IItemsControl_adaptor::ItemContainerStyleSelector)->_get_ItemContainerStyleSelector(&value)); return from_abi(value); }
			ptr<StyleSelector> operator()() { return get(); }
			operator ptr<StyleSelector> () { return get(); }
			ptr<StyleSelector> operator->() { return get(); }
			void put(pptr<StyleSelector> value) { hrcheck(enc(&IItemsControl_adaptor::ItemContainerStyleSelector)->_put_ItemContainerStyleSelector(value)); }
			void operator=(pptr<StyleSelector> value) { put(value); }
			void operator()(pptr<StyleSelector> value) { put(value); }
		} ItemContainerStyleSelector;
		struct : property {
			ptr<Media::Animation::TransitionCollection> get() { Media::Animation::TransitionCollection* value; hrcheck(enc(&IItemsControl_adaptor::ItemContainerTransitions)->_get_ItemContainerTransitions(&value)); return from_abi(value); }
			ptr<Media::Animation::TransitionCollection> operator()() { return get(); }
			operator ptr<Media::Animation::TransitionCollection> () { return get(); }
			ptr<Media::Animation::TransitionCollection> operator->() { return get(); }
			void put(pptr<Media::Animation::TransitionCollection> value) { hrcheck(enc(&IItemsControl_adaptor::ItemContainerTransitions)->_put_ItemContainerTransitions(value)); }
			void operator=(pptr<Media::Animation::TransitionCollection> value) { put(value); }
			void operator()(pptr<Media::Animation::TransitionCollection> value) { put(value); }
		} ItemContainerTransitions;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IItemsControl_adaptor::ItemTemplate)->_get_ItemTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IItemsControl_adaptor::ItemTemplate)->_put_ItemTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} ItemTemplate;
		struct : property {
			ptr<DataTemplateSelector> get() { DataTemplateSelector* value; hrcheck(enc(&IItemsControl_adaptor::ItemTemplateSelector)->_get_ItemTemplateSelector(&value)); return from_abi(value); }
			ptr<DataTemplateSelector> operator()() { return get(); }
			operator ptr<DataTemplateSelector> () { return get(); }
			ptr<DataTemplateSelector> operator->() { return get(); }
			void put(pptr<DataTemplateSelector> value) { hrcheck(enc(&IItemsControl_adaptor::ItemTemplateSelector)->_put_ItemTemplateSelector(value)); }
			void operator=(pptr<DataTemplateSelector> value) { put(value); }
			void operator()(pptr<DataTemplateSelector> value) { put(value); }
		} ItemTemplateSelector;
		struct : property {
			ptr<ItemCollection> get() { ItemCollection* value; hrcheck(enc(&IItemsControl_adaptor::Items)->_get_Items(&value)); return from_abi(value); }
			ptr<ItemCollection> operator()() { return get(); }
			operator ptr<ItemCollection> () { return get(); }
			ptr<ItemCollection> operator->() { return get(); }
		} Items;
		struct : property {
			ptr<ItemsPanelTemplate> get() { ItemsPanelTemplate* value; hrcheck(enc(&IItemsControl_adaptor::ItemsPanel)->_get_ItemsPanel(&value)); return from_abi(value); }
			ptr<ItemsPanelTemplate> operator()() { return get(); }
			operator ptr<ItemsPanelTemplate> () { return get(); }
			ptr<ItemsPanelTemplate> operator->() { return get(); }
			void put(pptr<ItemsPanelTemplate> value) { hrcheck(enc(&IItemsControl_adaptor::ItemsPanel)->_put_ItemsPanel(value)); }
			void operator=(pptr<ItemsPanelTemplate> value) { put(value); }
			void operator()(pptr<ItemsPanelTemplate> value) { put(value); }
		} ItemsPanel;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IItemsControl_adaptor::ItemsSource)->_get_ItemsSource(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IItemsControl_adaptor::ItemsSource)->_put_ItemsSource(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} ItemsSource;
	};
	IItemsControl_adaptor() {}
};
template<typename X> struct adapt<IItemsControl, X> : Windows::UI::Xaml::Controls::IItemsControl_adaptor<X> { typedef adapt IItemsControl; };
struct IItemsControl : IItemsControl_raw, generate<IItemsControl> {};

// ItemsControl
template<typename> struct ItemsControl_statics {
	static struct _DisplayMemberPathProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsControl, IItemsControlStatics>()->_get_DisplayMemberPathProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DisplayMemberPathProperty;
	static struct _GroupStyleSelectorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsControl, IItemsControlStatics>()->_get_GroupStyleSelectorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GroupStyleSelectorProperty;
	static struct _IsGroupingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsControl, IItemsControlStatics>()->_get_IsGroupingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsGroupingProperty;
	static struct _ItemContainerStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsControl, IItemsControlStatics>()->_get_ItemContainerStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemContainerStyleProperty;
	static struct _ItemContainerStyleSelectorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsControl, IItemsControlStatics>()->_get_ItemContainerStyleSelectorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemContainerStyleSelectorProperty;
	static struct _ItemContainerTransitionsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsControl, IItemsControlStatics>()->_get_ItemContainerTransitionsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemContainerTransitionsProperty;
	static struct _ItemTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsControl, IItemsControlStatics>()->_get_ItemTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemTemplateProperty;
	static struct _ItemTemplateSelectorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsControl, IItemsControlStatics>()->_get_ItemTemplateSelectorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemTemplateSelectorProperty;
	static struct _ItemsPanelProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsControl, IItemsControlStatics>()->_get_ItemsPanelProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemsPanelProperty;
	static struct _ItemsSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsControl, IItemsControlStatics>()->_get_ItemsSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemsSourceProperty;
	static ptr<ItemsControl> GetItemsOwner(pptr<DependencyObject> element) { ItemsControl* returnValue; hrcheck(get_activation_factory<ItemsControl, IItemsControlStatics>()->_GetItemsOwner(element, &returnValue)); return from_abi(returnValue); }
	static ptr<ItemsControl> ItemsControlFromItemContainer(pptr<DependencyObject> container) { ItemsControl* returnValue; hrcheck(get_activation_factory<ItemsControl, IItemsControlStatics>()->_ItemsControlFromItemContainer(container, &returnValue)); return from_abi(returnValue); }
	static ItemsControl *activate(object_ref outer, IInspectable* *inner) { ItemsControl *instance; hrcheck(get_activation_factory<ItemsControl, IItemsControlFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename ItemsControl_statics<X>::_DisplayMemberPathProperty ItemsControl_statics<X>::DisplayMemberPathProperty;
template<typename X> typename ItemsControl_statics<X>::_GroupStyleSelectorProperty ItemsControl_statics<X>::GroupStyleSelectorProperty;
template<typename X> typename ItemsControl_statics<X>::_IsGroupingProperty ItemsControl_statics<X>::IsGroupingProperty;
template<typename X> typename ItemsControl_statics<X>::_ItemContainerStyleProperty ItemsControl_statics<X>::ItemContainerStyleProperty;
template<typename X> typename ItemsControl_statics<X>::_ItemContainerStyleSelectorProperty ItemsControl_statics<X>::ItemContainerStyleSelectorProperty;
template<typename X> typename ItemsControl_statics<X>::_ItemContainerTransitionsProperty ItemsControl_statics<X>::ItemContainerTransitionsProperty;
template<typename X> typename ItemsControl_statics<X>::_ItemTemplateProperty ItemsControl_statics<X>::ItemTemplateProperty;
template<typename X> typename ItemsControl_statics<X>::_ItemTemplateSelectorProperty ItemsControl_statics<X>::ItemTemplateSelectorProperty;
template<typename X> typename ItemsControl_statics<X>::_ItemsPanelProperty ItemsControl_statics<X>::ItemsPanelProperty;
template<typename X> typename ItemsControl_statics<X>::_ItemsSourceProperty ItemsControl_statics<X>::ItemsSourceProperty;

template<typename X> struct statics<ItemsControl, X> : X, Windows::UI::Xaml::Controls::ItemsControl_statics<void> {
	using Windows::UI::Xaml::Controls::ItemsControl_statics<void>::activate;
	typedef typename X::root_type ItemsControl;
};
struct ItemsControl : generate<ItemsControl> {};
namespace Primitives {

// Selector
template<typename> struct Selector_statics {
	static struct _IsSynchronizedWithCurrentItemProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Selector, ISelectorStatics>()->_get_IsSynchronizedWithCurrentItemProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsSynchronizedWithCurrentItemProperty;
	static struct _SelectedIndexProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Selector, ISelectorStatics>()->_get_SelectedIndexProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedIndexProperty;
	static struct _SelectedItemProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Selector, ISelectorStatics>()->_get_SelectedItemProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedItemProperty;
	static struct _SelectedValuePathProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Selector, ISelectorStatics>()->_get_SelectedValuePathProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedValuePathProperty;
	static struct _SelectedValueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Selector, ISelectorStatics>()->_get_SelectedValueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedValueProperty;
	static bool GetIsSelectionActive(pptr<DependencyObject> element) { bool returnValue; hrcheck(get_activation_factory<Selector, ISelectorStatics>()->_GetIsSelectionActive(element, &returnValue)); return returnValue; }
};
template<typename X> typename Selector_statics<X>::_IsSynchronizedWithCurrentItemProperty Selector_statics<X>::IsSynchronizedWithCurrentItemProperty;
template<typename X> typename Selector_statics<X>::_SelectedIndexProperty Selector_statics<X>::SelectedIndexProperty;
template<typename X> typename Selector_statics<X>::_SelectedItemProperty Selector_statics<X>::SelectedItemProperty;
template<typename X> typename Selector_statics<X>::_SelectedValuePathProperty Selector_statics<X>::SelectedValuePathProperty;
template<typename X> typename Selector_statics<X>::_SelectedValueProperty Selector_statics<X>::SelectedValueProperty;

template<typename X> struct statics<Selector, X> : X, Windows::UI::Xaml::Controls::Primitives::Selector_statics<void> {
	typedef typename X::root_type Selector;
};
struct Selector : generate<Selector> {};

// IScrollBarStatics
struct IScrollBarStatics : IInspectable {
	virtual STDMETHODIMP _get_OrientationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ViewportSizeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IndicatorModeProperty(DependencyProperty* *value);
};

// IScrollBar
struct IScrollBar_raw : IInspectable {
	virtual STDMETHODIMP _get_Orientation(Controls::Orientation *value);
	virtual STDMETHODIMP _put_Orientation(Controls::Orientation value);
	virtual STDMETHODIMP _get_ViewportSize(double *value);
	virtual STDMETHODIMP _put_ViewportSize(double value);
	virtual STDMETHODIMP _get_IndicatorMode(ScrollingIndicatorMode *value);
	virtual STDMETHODIMP _put_IndicatorMode(ScrollingIndicatorMode value);
	virtual STDMETHODIMP _add_Scroll(ScrollEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Scroll(Foundation::EventRegistrationToken token);
};
template<typename X> struct IScrollBar_adaptor : X {
	union {
		struct : property {
			ScrollingIndicatorMode get() { ScrollingIndicatorMode value; hrcheck(enc(&IScrollBar_adaptor::IndicatorMode)->_get_IndicatorMode(&value)); return value; }
			ScrollingIndicatorMode operator()() { return get(); }
			operator ScrollingIndicatorMode () { return get(); }
			void put(ScrollingIndicatorMode value) { hrcheck(enc(&IScrollBar_adaptor::IndicatorMode)->_put_IndicatorMode(value)); }
			void operator=(ScrollingIndicatorMode value) { put(value); }
			void operator()(ScrollingIndicatorMode value) { put(value); }
		} IndicatorMode;
		struct : property {
			Controls::Orientation get() { Controls::Orientation value; hrcheck(enc(&IScrollBar_adaptor::Orientation)->_get_Orientation(&value)); return value; }
			Controls::Orientation operator()() { return get(); }
			operator Controls::Orientation () { return get(); }
			void put(Controls::Orientation value) { hrcheck(enc(&IScrollBar_adaptor::Orientation)->_put_Orientation(value)); }
			void operator=(Controls::Orientation value) { put(value); }
			void operator()(Controls::Orientation value) { put(value); }
		} Orientation;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollBar_adaptor::ViewportSize)->_get_ViewportSize(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IScrollBar_adaptor::ViewportSize)->_put_ViewportSize(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ViewportSize;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<ScrollEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IScrollBar_adaptor::Scroll)->_add_Scroll(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IScrollBar_adaptor::Scroll)->_remove_Scroll(token)); }
		} Scroll;
	};
	IScrollBar_adaptor() {}
};
template<typename X> struct adapt<IScrollBar, X> : Windows::UI::Xaml::Controls::Primitives::IScrollBar_adaptor<X> { typedef adapt IScrollBar; };
struct IScrollBar : IScrollBar_raw, generate<IScrollBar> {};

// IRangeBaseFactory
struct IRangeBaseFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, RangeBase* *instance);
};

// IRangeBaseStatics
struct IRangeBaseStatics : IInspectable {
	virtual STDMETHODIMP _get_MinimumProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaximumProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SmallChangeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_LargeChangeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ValueProperty(DependencyProperty* *value);
};

// IRangeBaseOverrides
struct IRangeBaseOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnMinimumChanged(double oldMinimum, double newMinimum) = 0;
	virtual STDMETHODIMP _OnMaximumChanged(double oldMaximum, double newMaximum) = 0;
	virtual STDMETHODIMP _OnValueChanged(double oldValue, double newValue) = 0;
};
template<typename X> struct IRangeBaseOverrides_adaptor : X {
	void OnMinimumChanged(double oldMinimum, double newMinimum) { hrcheck(X::get()->_OnMinimumChanged(oldMinimum, newMinimum)); }
	void OnMaximumChanged(double oldMaximum, double newMaximum) { hrcheck(X::get()->_OnMaximumChanged(oldMaximum, newMaximum)); }
	void OnValueChanged(double oldValue, double newValue) { hrcheck(X::get()->_OnValueChanged(oldValue, newValue)); }
};
template<typename X> struct adapt<IRangeBaseOverrides, X> : Windows::UI::Xaml::Controls::Primitives::IRangeBaseOverrides_adaptor<X> { typedef adapt IRangeBaseOverrides; };
template<typename X> struct IRangeBaseOverrides_unadaptor : X {
	STDMETHODIMP _OnMinimumChanged(double oldMinimum, double newMinimum) { return hrtry([&, this] { X::get()->OnMinimumChanged(oldMinimum, newMinimum); }); }
	STDMETHODIMP _OnMaximumChanged(double oldMaximum, double newMaximum) { return hrtry([&, this] { X::get()->OnMaximumChanged(oldMaximum, newMaximum); }); }
	STDMETHODIMP _OnValueChanged(double oldValue, double newValue) { return hrtry([&, this] { X::get()->OnValueChanged(oldValue, newValue); }); }
};
template<typename X> struct unadapt<IRangeBaseOverrides, X> : Windows::UI::Xaml::Controls::Primitives::IRangeBaseOverrides_unadaptor<X> {};
struct IRangeBaseOverrides : IRangeBaseOverrides_raw, generate<IRangeBaseOverrides> {};

// IRangeBase
struct IRangeBase_raw : IInspectable {
	virtual STDMETHODIMP _get_Minimum(double *value);
	virtual STDMETHODIMP _put_Minimum(double value);
	virtual STDMETHODIMP _get_Maximum(double *value);
	virtual STDMETHODIMP _put_Maximum(double value);
	virtual STDMETHODIMP _get_SmallChange(double *value);
	virtual STDMETHODIMP _put_SmallChange(double value);
	virtual STDMETHODIMP _get_LargeChange(double *value);
	virtual STDMETHODIMP _put_LargeChange(double value);
	virtual STDMETHODIMP _get_Value(double *value);
	virtual STDMETHODIMP _put_Value(double value);
	virtual STDMETHODIMP _add_ValueChanged(RangeBaseValueChangedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ValueChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IRangeBase_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IRangeBase_adaptor::LargeChange)->_get_LargeChange(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRangeBase_adaptor::LargeChange)->_put_LargeChange(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} LargeChange;
		struct : property {
			double get() { double value; hrcheck(enc(&IRangeBase_adaptor::Maximum)->_get_Maximum(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRangeBase_adaptor::Maximum)->_put_Maximum(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Maximum;
		struct : property {
			double get() { double value; hrcheck(enc(&IRangeBase_adaptor::Minimum)->_get_Minimum(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRangeBase_adaptor::Minimum)->_put_Minimum(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Minimum;
		struct : property {
			double get() { double value; hrcheck(enc(&IRangeBase_adaptor::SmallChange)->_get_SmallChange(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRangeBase_adaptor::SmallChange)->_put_SmallChange(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} SmallChange;
		struct : property {
			double get() { double value; hrcheck(enc(&IRangeBase_adaptor::Value)->_get_Value(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRangeBase_adaptor::Value)->_put_Value(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Value;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RangeBaseValueChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRangeBase_adaptor::ValueChanged)->_add_ValueChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRangeBase_adaptor::ValueChanged)->_remove_ValueChanged(token)); }
		} ValueChanged;
	};
	IRangeBase_adaptor() {}
};
template<typename X> struct adapt<IRangeBase, X> : Windows::UI::Xaml::Controls::Primitives::IRangeBase_adaptor<X> { typedef adapt IRangeBase; };
struct IRangeBase : IRangeBase_raw, generate<IRangeBase> {};

// RangeBase
template<typename> struct RangeBase_statics {
	static struct _LargeChangeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RangeBase, IRangeBaseStatics>()->_get_LargeChangeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LargeChangeProperty;
	static struct _MaximumProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RangeBase, IRangeBaseStatics>()->_get_MaximumProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaximumProperty;
	static struct _MinimumProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RangeBase, IRangeBaseStatics>()->_get_MinimumProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinimumProperty;
	static struct _SmallChangeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RangeBase, IRangeBaseStatics>()->_get_SmallChangeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SmallChangeProperty;
	static struct _ValueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RangeBase, IRangeBaseStatics>()->_get_ValueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ValueProperty;
};
template<typename X> typename RangeBase_statics<X>::_LargeChangeProperty RangeBase_statics<X>::LargeChangeProperty;
template<typename X> typename RangeBase_statics<X>::_MaximumProperty RangeBase_statics<X>::MaximumProperty;
template<typename X> typename RangeBase_statics<X>::_MinimumProperty RangeBase_statics<X>::MinimumProperty;
template<typename X> typename RangeBase_statics<X>::_SmallChangeProperty RangeBase_statics<X>::SmallChangeProperty;
template<typename X> typename RangeBase_statics<X>::_ValueProperty RangeBase_statics<X>::ValueProperty;

template<typename X> struct statics<RangeBase, X> : X, Windows::UI::Xaml::Controls::Primitives::RangeBase_statics<void> {
	typedef typename X::root_type RangeBase;
};
struct RangeBase : generate<RangeBase> {};

// ScrollBar
template<typename> struct ScrollBar_statics {
	static struct _IndicatorModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollBar, IScrollBarStatics>()->_get_IndicatorModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IndicatorModeProperty;
	static struct _OrientationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollBar, IScrollBarStatics>()->_get_OrientationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OrientationProperty;
	static struct _ViewportSizeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollBar, IScrollBarStatics>()->_get_ViewportSizeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ViewportSizeProperty;
};
template<typename X> typename ScrollBar_statics<X>::_IndicatorModeProperty ScrollBar_statics<X>::IndicatorModeProperty;
template<typename X> typename ScrollBar_statics<X>::_OrientationProperty ScrollBar_statics<X>::OrientationProperty;
template<typename X> typename ScrollBar_statics<X>::_ViewportSizeProperty ScrollBar_statics<X>::ViewportSizeProperty;

template<typename X> struct statics<ScrollBar, X> : X, Windows::UI::Xaml::Controls::Primitives::ScrollBar_statics<void> {
	typedef typename X::root_type ScrollBar;
};
struct ScrollBar : generate<ScrollBar> {};

// IThumbStatics
struct IThumbStatics : IInspectable {
	virtual STDMETHODIMP _get_IsDraggingProperty(DependencyProperty* *value);
};

// IThumb
struct IThumb_raw : IInspectable {
	virtual STDMETHODIMP _get_IsDragging(bool *value);
	virtual STDMETHODIMP _add_DragStarted(DragStartedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DragStarted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DragDelta(DragDeltaEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DragDelta(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DragCompleted(DragCompletedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DragCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _CancelDrag();
};
template<typename X> struct IThumb_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IThumb_adaptor::IsDragging)->_get_IsDragging(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsDragging;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<DragCompletedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IThumb_adaptor::DragCompleted)->_add_DragCompleted(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IThumb_adaptor::DragCompleted)->_remove_DragCompleted(token)); }
		} DragCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<DragDeltaEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IThumb_adaptor::DragDelta)->_add_DragDelta(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IThumb_adaptor::DragDelta)->_remove_DragDelta(token)); }
		} DragDelta;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<DragStartedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IThumb_adaptor::DragStarted)->_add_DragStarted(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IThumb_adaptor::DragStarted)->_remove_DragStarted(token)); }
		} DragStarted;
	};
	void CancelDrag() { hrcheck(X::get()->_CancelDrag()); }
	IThumb_adaptor() {}
};
template<typename X> struct adapt<IThumb, X> : Windows::UI::Xaml::Controls::Primitives::IThumb_adaptor<X> { typedef adapt IThumb; };
struct IThumb : IThumb_raw, generate<IThumb> {};

// Thumb
template<typename> struct Thumb_statics {
	static struct _IsDraggingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Thumb, IThumbStatics>()->_get_IsDraggingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsDraggingProperty;
};
template<typename X> typename Thumb_statics<X>::_IsDraggingProperty Thumb_statics<X>::IsDraggingProperty;

template<typename X> struct statics<Thumb, X> : X, Windows::UI::Xaml::Controls::Primitives::Thumb_statics<void> {
	typedef typename X::root_type Thumb;
};
struct Thumb : generate<Thumb> {};

// IColorPickerSliderFactory
struct IColorPickerSliderFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ColorPickerSlider* *instance);
};

// IColorPickerSliderStatics
struct IColorPickerSliderStatics : IInspectable {
	virtual STDMETHODIMP _get_ColorChannelProperty(DependencyProperty* *value);
};

// IColorPickerSlider
struct IColorPickerSlider_raw : IInspectable {
	virtual STDMETHODIMP _get_ColorChannel(ColorPickerHsvChannel *result);
	virtual STDMETHODIMP _put_ColorChannel(ColorPickerHsvChannel value);
};
template<typename X> struct IColorPickerSlider_adaptor : X {
	union {
		struct : property {
			ColorPickerHsvChannel get() { ColorPickerHsvChannel result; hrcheck(enc(&IColorPickerSlider_adaptor::ColorChannel)->_get_ColorChannel(&result)); return result; }
			ColorPickerHsvChannel operator()() { return get(); }
			operator ColorPickerHsvChannel () { return get(); }
			void put(ColorPickerHsvChannel value) { hrcheck(enc(&IColorPickerSlider_adaptor::ColorChannel)->_put_ColorChannel(value)); }
			void operator=(ColorPickerHsvChannel value) { put(value); }
			void operator()(ColorPickerHsvChannel value) { put(value); }
		} ColorChannel;
	};
	IColorPickerSlider_adaptor() {}
};
template<typename X> struct adapt<IColorPickerSlider, X> : Windows::UI::Xaml::Controls::Primitives::IColorPickerSlider_adaptor<X> { typedef adapt IColorPickerSlider; };
struct IColorPickerSlider : IColorPickerSlider_raw, generate<IColorPickerSlider> {};
}

// ISliderStatics2
struct ISliderStatics2 : IInspectable {
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTemplateProperty(DependencyProperty* *value);
};

// ISliderFactory
struct ISliderFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Slider* *instance);
};

// ISliderStatics
struct ISliderStatics : IInspectable {
	virtual STDMETHODIMP _get_IntermediateValueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_StepFrequencyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SnapsToProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TickFrequencyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TickPlacementProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OrientationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsDirectionReversedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsThumbToolTipEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ThumbToolTipValueConverterProperty(DependencyProperty* *value);
};

// ISlider2
struct ISlider2_raw : IInspectable {
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
};
template<typename X> struct ISlider2_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ISlider2_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&ISlider2_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&ISlider2_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&ISlider2_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
	};
	ISlider2_adaptor() {}
};
template<typename X> struct adapt<ISlider2, X> : Windows::UI::Xaml::Controls::ISlider2_adaptor<X> { typedef adapt ISlider2; };
struct ISlider2 : ISlider2_raw, generate<ISlider2> {};

// ISlider
struct ISlider_raw : IInspectable {
	virtual STDMETHODIMP _get_IntermediateValue(double *value);
	virtual STDMETHODIMP _put_IntermediateValue(double value);
	virtual STDMETHODIMP _get_StepFrequency(double *value);
	virtual STDMETHODIMP _put_StepFrequency(double value);
	virtual STDMETHODIMP _get_SnapsTo(Primitives::SliderSnapsTo *value);
	virtual STDMETHODIMP _put_SnapsTo(Primitives::SliderSnapsTo value);
	virtual STDMETHODIMP _get_TickFrequency(double *value);
	virtual STDMETHODIMP _put_TickFrequency(double value);
	virtual STDMETHODIMP _get_TickPlacement(Primitives::TickPlacement *value);
	virtual STDMETHODIMP _put_TickPlacement(Primitives::TickPlacement value);
	virtual STDMETHODIMP _get_Orientation(Controls::Orientation *value);
	virtual STDMETHODIMP _put_Orientation(Controls::Orientation value);
	virtual STDMETHODIMP _get_IsDirectionReversed(bool *value);
	virtual STDMETHODIMP _put_IsDirectionReversed(bool value);
	virtual STDMETHODIMP _get_IsThumbToolTipEnabled(bool *value);
	virtual STDMETHODIMP _put_IsThumbToolTipEnabled(bool value);
	virtual STDMETHODIMP _get_ThumbToolTipValueConverter(Data::IValueConverter* *value);
	virtual STDMETHODIMP _put_ThumbToolTipValueConverter(Data::IValueConverter* value);
};
template<typename X> struct ISlider_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&ISlider_adaptor::IntermediateValue)->_get_IntermediateValue(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISlider_adaptor::IntermediateValue)->_put_IntermediateValue(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} IntermediateValue;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISlider_adaptor::IsDirectionReversed)->_get_IsDirectionReversed(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISlider_adaptor::IsDirectionReversed)->_put_IsDirectionReversed(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsDirectionReversed;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISlider_adaptor::IsThumbToolTipEnabled)->_get_IsThumbToolTipEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISlider_adaptor::IsThumbToolTipEnabled)->_put_IsThumbToolTipEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsThumbToolTipEnabled;
		struct : property {
			Controls::Orientation get() { Controls::Orientation value; hrcheck(enc(&ISlider_adaptor::Orientation)->_get_Orientation(&value)); return value; }
			Controls::Orientation operator()() { return get(); }
			operator Controls::Orientation () { return get(); }
			void put(Controls::Orientation value) { hrcheck(enc(&ISlider_adaptor::Orientation)->_put_Orientation(value)); }
			void operator=(Controls::Orientation value) { put(value); }
			void operator()(Controls::Orientation value) { put(value); }
		} Orientation;
		struct : property {
			Primitives::SliderSnapsTo get() { Primitives::SliderSnapsTo value; hrcheck(enc(&ISlider_adaptor::SnapsTo)->_get_SnapsTo(&value)); return value; }
			Primitives::SliderSnapsTo operator()() { return get(); }
			operator Primitives::SliderSnapsTo () { return get(); }
			void put(Primitives::SliderSnapsTo value) { hrcheck(enc(&ISlider_adaptor::SnapsTo)->_put_SnapsTo(value)); }
			void operator=(Primitives::SliderSnapsTo value) { put(value); }
			void operator()(Primitives::SliderSnapsTo value) { put(value); }
		} SnapsTo;
		struct : property {
			double get() { double value; hrcheck(enc(&ISlider_adaptor::StepFrequency)->_get_StepFrequency(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISlider_adaptor::StepFrequency)->_put_StepFrequency(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} StepFrequency;
		struct : property {
			ptr<Data::IValueConverter> get() { Data::IValueConverter* value; hrcheck(enc(&ISlider_adaptor::ThumbToolTipValueConverter)->_get_ThumbToolTipValueConverter(&value)); return from_abi(value); }
			ptr<Data::IValueConverter> operator()() { return get(); }
			operator ptr<Data::IValueConverter> () { return get(); }
			ptr<Data::IValueConverter> operator->() { return get(); }
			void put(pptr<Data::IValueConverter> value) { hrcheck(enc(&ISlider_adaptor::ThumbToolTipValueConverter)->_put_ThumbToolTipValueConverter(value)); }
			void operator=(pptr<Data::IValueConverter> value) { put(value); }
			void operator()(pptr<Data::IValueConverter> value) { put(value); }
		} ThumbToolTipValueConverter;
		struct : property {
			double get() { double value; hrcheck(enc(&ISlider_adaptor::TickFrequency)->_get_TickFrequency(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISlider_adaptor::TickFrequency)->_put_TickFrequency(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} TickFrequency;
		struct : property {
			Primitives::TickPlacement get() { Primitives::TickPlacement value; hrcheck(enc(&ISlider_adaptor::TickPlacement)->_get_TickPlacement(&value)); return value; }
			Primitives::TickPlacement operator()() { return get(); }
			operator Primitives::TickPlacement () { return get(); }
			void put(Primitives::TickPlacement value) { hrcheck(enc(&ISlider_adaptor::TickPlacement)->_put_TickPlacement(value)); }
			void operator=(Primitives::TickPlacement value) { put(value); }
			void operator()(Primitives::TickPlacement value) { put(value); }
		} TickPlacement;
	};
	ISlider_adaptor() {}
};
template<typename X> struct adapt<ISlider, X> : Windows::UI::Xaml::Controls::ISlider_adaptor<X> { typedef adapt ISlider; };
struct ISlider : ISlider_raw, generate<ISlider> {};

// Slider
template<typename> struct Slider_statics {
	static struct _IntermediateValueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Slider, ISliderStatics>()->_get_IntermediateValueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IntermediateValueProperty;
	static struct _IsDirectionReversedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Slider, ISliderStatics>()->_get_IsDirectionReversedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsDirectionReversedProperty;
	static struct _IsThumbToolTipEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Slider, ISliderStatics>()->_get_IsThumbToolTipEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsThumbToolTipEnabledProperty;
	static struct _OrientationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Slider, ISliderStatics>()->_get_OrientationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OrientationProperty;
	static struct _SnapsToProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Slider, ISliderStatics>()->_get_SnapsToProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SnapsToProperty;
	static struct _StepFrequencyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Slider, ISliderStatics>()->_get_StepFrequencyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StepFrequencyProperty;
	static struct _ThumbToolTipValueConverterProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Slider, ISliderStatics>()->_get_ThumbToolTipValueConverterProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ThumbToolTipValueConverterProperty;
	static struct _TickFrequencyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Slider, ISliderStatics>()->_get_TickFrequencyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TickFrequencyProperty;
	static struct _TickPlacementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Slider, ISliderStatics>()->_get_TickPlacementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TickPlacementProperty;
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Slider, ISliderStatics2>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static struct _HeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Slider, ISliderStatics2>()->_get_HeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTemplateProperty;
	static Slider *activate(object_ref outer, IInspectable* *inner) { Slider *instance; hrcheck(get_activation_factory<Slider, ISliderFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename Slider_statics<X>::_IntermediateValueProperty Slider_statics<X>::IntermediateValueProperty;
template<typename X> typename Slider_statics<X>::_IsDirectionReversedProperty Slider_statics<X>::IsDirectionReversedProperty;
template<typename X> typename Slider_statics<X>::_IsThumbToolTipEnabledProperty Slider_statics<X>::IsThumbToolTipEnabledProperty;
template<typename X> typename Slider_statics<X>::_OrientationProperty Slider_statics<X>::OrientationProperty;
template<typename X> typename Slider_statics<X>::_SnapsToProperty Slider_statics<X>::SnapsToProperty;
template<typename X> typename Slider_statics<X>::_StepFrequencyProperty Slider_statics<X>::StepFrequencyProperty;
template<typename X> typename Slider_statics<X>::_ThumbToolTipValueConverterProperty Slider_statics<X>::ThumbToolTipValueConverterProperty;
template<typename X> typename Slider_statics<X>::_TickFrequencyProperty Slider_statics<X>::TickFrequencyProperty;
template<typename X> typename Slider_statics<X>::_TickPlacementProperty Slider_statics<X>::TickPlacementProperty;
template<typename X> typename Slider_statics<X>::_HeaderProperty Slider_statics<X>::HeaderProperty;
template<typename X> typename Slider_statics<X>::_HeaderTemplateProperty Slider_statics<X>::HeaderTemplateProperty;

template<typename X> struct statics<Slider, X> : X, Windows::UI::Xaml::Controls::Slider_statics<void> {
	using Windows::UI::Xaml::Controls::Slider_statics<void>::activate;
	typedef typename X::root_type Slider;
};
struct Slider : generate<Slider> {};
namespace Primitives {

// ColorPickerSlider
template<typename> struct ColorPickerSlider_statics {
	static struct _ColorChannelProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPickerSlider, IColorPickerSliderStatics>()->_get_ColorChannelProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ColorChannelProperty;
	static ColorPickerSlider *activate(object_ref outer, IInspectable* *inner) { ColorPickerSlider *instance; hrcheck(get_activation_factory<ColorPickerSlider, IColorPickerSliderFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename ColorPickerSlider_statics<X>::_ColorChannelProperty ColorPickerSlider_statics<X>::ColorChannelProperty;

template<typename X> struct statics<ColorPickerSlider, X> : X, Windows::UI::Xaml::Controls::Primitives::ColorPickerSlider_statics<void> {
	using Windows::UI::Xaml::Controls::Primitives::ColorPickerSlider_statics<void>::activate;
	typedef typename X::root_type ColorPickerSlider;
};
struct ColorPickerSlider : generate<ColorPickerSlider> {};

// ISelectorItemFactory
struct ISelectorItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, SelectorItem* *instance);
};

// ISelectorItemStatics
struct ISelectorItemStatics : IInspectable {
	virtual STDMETHODIMP _get_IsSelectedProperty(DependencyProperty* *value);
};

// ISelectorItem
struct ISelectorItem_raw : IInspectable {
	virtual STDMETHODIMP _get_IsSelected(bool *value);
	virtual STDMETHODIMP _put_IsSelected(bool value);
};
template<typename X> struct ISelectorItem_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISelectorItem_adaptor::IsSelected)->_get_IsSelected(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISelectorItem_adaptor::IsSelected)->_put_IsSelected(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSelected;
	};
	ISelectorItem_adaptor() {}
};
template<typename X> struct adapt<ISelectorItem, X> : Windows::UI::Xaml::Controls::Primitives::ISelectorItem_adaptor<X> { typedef adapt ISelectorItem; };
struct ISelectorItem : ISelectorItem_raw, generate<ISelectorItem> {};

// SelectorItem
template<typename> struct SelectorItem_statics {
	static struct _IsSelectedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SelectorItem, ISelectorItemStatics>()->_get_IsSelectedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsSelectedProperty;
};
template<typename X> typename SelectorItem_statics<X>::_IsSelectedProperty SelectorItem_statics<X>::IsSelectedProperty;

template<typename X> struct statics<SelectorItem, X> : X, Windows::UI::Xaml::Controls::Primitives::SelectorItem_statics<void> {
	typedef typename X::root_type SelectorItem;
};
struct SelectorItem : generate<SelectorItem> {};

// IColorSpectrumFactory
struct IColorSpectrumFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ColorSpectrum* *instance);
};

// IColorSpectrumStatics
struct IColorSpectrumStatics : IInspectable {
	virtual STDMETHODIMP _get_ColorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HsvColorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinHueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxHueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinSaturationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxSaturationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinValueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxValueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ShapeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ComponentsProperty(DependencyProperty* *value);
};

// IColorSpectrum
struct IColorSpectrum_raw : IInspectable {
	virtual STDMETHODIMP _get_Color(UI::Color *result);
	virtual STDMETHODIMP _put_Color(UI::Color value);
	virtual STDMETHODIMP _get_HsvColor(Foundation::Numerics::Vector4 *result);
	virtual STDMETHODIMP _put_HsvColor(Foundation::Numerics::Vector4 value);
	virtual STDMETHODIMP _get_MinHue(int *result);
	virtual STDMETHODIMP _put_MinHue(int value);
	virtual STDMETHODIMP _get_MaxHue(int *result);
	virtual STDMETHODIMP _put_MaxHue(int value);
	virtual STDMETHODIMP _get_MinSaturation(int *result);
	virtual STDMETHODIMP _put_MinSaturation(int value);
	virtual STDMETHODIMP _get_MaxSaturation(int *result);
	virtual STDMETHODIMP _put_MaxSaturation(int value);
	virtual STDMETHODIMP _get_MinValue(int *result);
	virtual STDMETHODIMP _put_MinValue(int value);
	virtual STDMETHODIMP _get_MaxValue(int *result);
	virtual STDMETHODIMP _put_MaxValue(int value);
	virtual STDMETHODIMP _get_Shape(ColorSpectrumShape *result);
	virtual STDMETHODIMP _put_Shape(ColorSpectrumShape value);
	virtual STDMETHODIMP _get_Components(ColorSpectrumComponents *result);
	virtual STDMETHODIMP _put_Components(ColorSpectrumComponents value);
	virtual STDMETHODIMP _add_ColorChanged(Foundation::TypedEventHandler<ColorSpectrum*, ColorChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ColorChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IColorSpectrum_adaptor : X {
	union {
		struct : property {
			UI::Color get() { UI::Color result; hrcheck(enc(&IColorSpectrum_adaptor::Color)->_get_Color(&result)); return result; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IColorSpectrum_adaptor::Color)->_put_Color(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} Color;
		struct : property {
			ColorSpectrumComponents get() { ColorSpectrumComponents result; hrcheck(enc(&IColorSpectrum_adaptor::Components)->_get_Components(&result)); return result; }
			ColorSpectrumComponents operator()() { return get(); }
			operator ColorSpectrumComponents () { return get(); }
			void put(ColorSpectrumComponents value) { hrcheck(enc(&IColorSpectrum_adaptor::Components)->_put_Components(value)); }
			void operator=(ColorSpectrumComponents value) { put(value); }
			void operator()(ColorSpectrumComponents value) { put(value); }
		} Components;
		struct : property {
			Foundation::Numerics::Vector4 get() { Foundation::Numerics::Vector4 result; hrcheck(enc(&IColorSpectrum_adaptor::HsvColor)->_get_HsvColor(&result)); return result; }
			Foundation::Numerics::Vector4 operator()() { return get(); }
			operator Foundation::Numerics::Vector4 () { return get(); }
			void put(const Foundation::Numerics::Vector4& value) { hrcheck(enc(&IColorSpectrum_adaptor::HsvColor)->_put_HsvColor(value)); }
			void operator=(const Foundation::Numerics::Vector4& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector4& value) { put(value); }
		} HsvColor;
		struct : property {
			int get() { int result; hrcheck(enc(&IColorSpectrum_adaptor::MaxHue)->_get_MaxHue(&result)); return result; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IColorSpectrum_adaptor::MaxHue)->_put_MaxHue(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaxHue;
		struct : property {
			int get() { int result; hrcheck(enc(&IColorSpectrum_adaptor::MaxSaturation)->_get_MaxSaturation(&result)); return result; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IColorSpectrum_adaptor::MaxSaturation)->_put_MaxSaturation(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaxSaturation;
		struct : property {
			int get() { int result; hrcheck(enc(&IColorSpectrum_adaptor::MaxValue)->_get_MaxValue(&result)); return result; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IColorSpectrum_adaptor::MaxValue)->_put_MaxValue(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaxValue;
		struct : property {
			int get() { int result; hrcheck(enc(&IColorSpectrum_adaptor::MinHue)->_get_MinHue(&result)); return result; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IColorSpectrum_adaptor::MinHue)->_put_MinHue(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MinHue;
		struct : property {
			int get() { int result; hrcheck(enc(&IColorSpectrum_adaptor::MinSaturation)->_get_MinSaturation(&result)); return result; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IColorSpectrum_adaptor::MinSaturation)->_put_MinSaturation(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MinSaturation;
		struct : property {
			int get() { int result; hrcheck(enc(&IColorSpectrum_adaptor::MinValue)->_get_MinValue(&result)); return result; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IColorSpectrum_adaptor::MinValue)->_put_MinValue(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MinValue;
		struct : property {
			ColorSpectrumShape get() { ColorSpectrumShape result; hrcheck(enc(&IColorSpectrum_adaptor::Shape)->_get_Shape(&result)); return result; }
			ColorSpectrumShape operator()() { return get(); }
			operator ColorSpectrumShape () { return get(); }
			void put(ColorSpectrumShape value) { hrcheck(enc(&IColorSpectrum_adaptor::Shape)->_put_Shape(value)); }
			void operator=(ColorSpectrumShape value) { put(value); }
			void operator()(ColorSpectrumShape value) { put(value); }
		} Shape;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ColorSpectrum>, ptr<ColorChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IColorSpectrum_adaptor::ColorChanged)->_add_ColorChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IColorSpectrum_adaptor::ColorChanged)->_remove_ColorChanged(token)); }
		} ColorChanged;
	};
	IColorSpectrum_adaptor() {}
};
template<typename X> struct adapt<IColorSpectrum, X> : Windows::UI::Xaml::Controls::Primitives::IColorSpectrum_adaptor<X> { typedef adapt IColorSpectrum; };
struct IColorSpectrum : IColorSpectrum_raw, generate<IColorSpectrum> {};

// ColorSpectrum
template<typename> struct ColorSpectrum_statics {
	static struct _ColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorSpectrum, IColorSpectrumStatics>()->_get_ColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ColorProperty;
	static struct _ComponentsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorSpectrum, IColorSpectrumStatics>()->_get_ComponentsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ComponentsProperty;
	static struct _HsvColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorSpectrum, IColorSpectrumStatics>()->_get_HsvColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HsvColorProperty;
	static struct _MaxHueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorSpectrum, IColorSpectrumStatics>()->_get_MaxHueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxHueProperty;
	static struct _MaxSaturationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorSpectrum, IColorSpectrumStatics>()->_get_MaxSaturationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxSaturationProperty;
	static struct _MaxValueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorSpectrum, IColorSpectrumStatics>()->_get_MaxValueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxValueProperty;
	static struct _MinHueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorSpectrum, IColorSpectrumStatics>()->_get_MinHueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinHueProperty;
	static struct _MinSaturationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorSpectrum, IColorSpectrumStatics>()->_get_MinSaturationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinSaturationProperty;
	static struct _MinValueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorSpectrum, IColorSpectrumStatics>()->_get_MinValueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinValueProperty;
	static struct _ShapeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorSpectrum, IColorSpectrumStatics>()->_get_ShapeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ShapeProperty;
	static ColorSpectrum *activate(object_ref outer, IInspectable* *inner) { ColorSpectrum *instance; hrcheck(get_activation_factory<ColorSpectrum, IColorSpectrumFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename ColorSpectrum_statics<X>::_ColorProperty ColorSpectrum_statics<X>::ColorProperty;
template<typename X> typename ColorSpectrum_statics<X>::_ComponentsProperty ColorSpectrum_statics<X>::ComponentsProperty;
template<typename X> typename ColorSpectrum_statics<X>::_HsvColorProperty ColorSpectrum_statics<X>::HsvColorProperty;
template<typename X> typename ColorSpectrum_statics<X>::_MaxHueProperty ColorSpectrum_statics<X>::MaxHueProperty;
template<typename X> typename ColorSpectrum_statics<X>::_MaxSaturationProperty ColorSpectrum_statics<X>::MaxSaturationProperty;
template<typename X> typename ColorSpectrum_statics<X>::_MaxValueProperty ColorSpectrum_statics<X>::MaxValueProperty;
template<typename X> typename ColorSpectrum_statics<X>::_MinHueProperty ColorSpectrum_statics<X>::MinHueProperty;
template<typename X> typename ColorSpectrum_statics<X>::_MinSaturationProperty ColorSpectrum_statics<X>::MinSaturationProperty;
template<typename X> typename ColorSpectrum_statics<X>::_MinValueProperty ColorSpectrum_statics<X>::MinValueProperty;
template<typename X> typename ColorSpectrum_statics<X>::_ShapeProperty ColorSpectrum_statics<X>::ShapeProperty;

template<typename X> struct statics<ColorSpectrum, X> : X, Windows::UI::Xaml::Controls::Primitives::ColorSpectrum_statics<void> {
	using Windows::UI::Xaml::Controls::Primitives::ColorSpectrum_statics<void>::activate;
	typedef typename X::root_type ColorSpectrum;
};
struct ColorSpectrum : generate<ColorSpectrum> {};

// IListViewItemPresenterStatics3
struct IListViewItemPresenterStatics3 : IInspectable {
	virtual STDMETHODIMP _get_RevealBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RevealBorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RevealBorderThicknessProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RevealBackgroundShowsAboveContentProperty(DependencyProperty* *value);
};

// IListViewItemPresenterStatics2
struct IListViewItemPresenterStatics2 : IInspectable {
	virtual STDMETHODIMP _get_SelectedPressedBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PressedBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CheckBoxBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FocusSecondaryBorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CheckModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PointerOverForegroundProperty(DependencyProperty* *value);
};

// IListViewItemPresenterFactory
struct IListViewItemPresenterFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ListViewItemPresenter* *instance);
};

// IListViewItemPresenterStatics
struct IListViewItemPresenterStatics : IInspectable {
	virtual STDMETHODIMP _get_SelectionCheckMarkVisualEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CheckHintBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CheckSelectingBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CheckBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DragBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DragForegroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FocusBorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlaceholderBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PointerOverBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedForegroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedPointerOverBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedPointerOverBorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedBorderThicknessProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DisabledOpacityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DragOpacityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ReorderHintOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ListViewItemPresenterHorizontalContentAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ListViewItemPresenterVerticalContentAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ListViewItemPresenterPaddingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PointerOverBackgroundMarginProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentMarginProperty(DependencyProperty* *value);
};

// IListViewItemPresenter3
struct IListViewItemPresenter3_raw : IInspectable {
	virtual STDMETHODIMP _get_RevealBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_RevealBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_RevealBorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_RevealBorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_RevealBorderThickness(Thickness *value);
	virtual STDMETHODIMP _put_RevealBorderThickness(Thickness value);
	virtual STDMETHODIMP _get_RevealBackgroundShowsAboveContent(bool *value);
	virtual STDMETHODIMP _put_RevealBackgroundShowsAboveContent(bool value);
};
template<typename X> struct IListViewItemPresenter3_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter3_adaptor::RevealBackground)->_get_RevealBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter3_adaptor::RevealBackground)->_put_RevealBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} RevealBackground;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IListViewItemPresenter3_adaptor::RevealBackgroundShowsAboveContent)->_get_RevealBackgroundShowsAboveContent(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IListViewItemPresenter3_adaptor::RevealBackgroundShowsAboveContent)->_put_RevealBackgroundShowsAboveContent(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} RevealBackgroundShowsAboveContent;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter3_adaptor::RevealBorderBrush)->_get_RevealBorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter3_adaptor::RevealBorderBrush)->_put_RevealBorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} RevealBorderBrush;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IListViewItemPresenter3_adaptor::RevealBorderThickness)->_get_RevealBorderThickness(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IListViewItemPresenter3_adaptor::RevealBorderThickness)->_put_RevealBorderThickness(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} RevealBorderThickness;
	};
	IListViewItemPresenter3_adaptor() {}
};
template<typename X> struct adapt<IListViewItemPresenter3, X> : Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter3_adaptor<X> { typedef adapt IListViewItemPresenter3; };
struct IListViewItemPresenter3 : IListViewItemPresenter3_raw, generate<IListViewItemPresenter3> {};

// IListViewItemPresenter2
struct IListViewItemPresenter2_raw : IInspectable {
	virtual STDMETHODIMP _get_SelectedPressedBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_SelectedPressedBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_PressedBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_PressedBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_CheckBoxBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_CheckBoxBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_FocusSecondaryBorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_FocusSecondaryBorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_CheckMode(ListViewItemPresenterCheckMode *value);
	virtual STDMETHODIMP _put_CheckMode(ListViewItemPresenterCheckMode value);
	virtual STDMETHODIMP _get_PointerOverForeground(Media::Brush* *value);
	virtual STDMETHODIMP _put_PointerOverForeground(Media::Brush* value);
};
template<typename X> struct IListViewItemPresenter2_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter2_adaptor::CheckBoxBrush)->_get_CheckBoxBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter2_adaptor::CheckBoxBrush)->_put_CheckBoxBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} CheckBoxBrush;
		struct : property {
			ListViewItemPresenterCheckMode get() { ListViewItemPresenterCheckMode value; hrcheck(enc(&IListViewItemPresenter2_adaptor::CheckMode)->_get_CheckMode(&value)); return value; }
			ListViewItemPresenterCheckMode operator()() { return get(); }
			operator ListViewItemPresenterCheckMode () { return get(); }
			void put(ListViewItemPresenterCheckMode value) { hrcheck(enc(&IListViewItemPresenter2_adaptor::CheckMode)->_put_CheckMode(value)); }
			void operator=(ListViewItemPresenterCheckMode value) { put(value); }
			void operator()(ListViewItemPresenterCheckMode value) { put(value); }
		} CheckMode;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter2_adaptor::FocusSecondaryBorderBrush)->_get_FocusSecondaryBorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter2_adaptor::FocusSecondaryBorderBrush)->_put_FocusSecondaryBorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} FocusSecondaryBorderBrush;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter2_adaptor::PointerOverForeground)->_get_PointerOverForeground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter2_adaptor::PointerOverForeground)->_put_PointerOverForeground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} PointerOverForeground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter2_adaptor::PressedBackground)->_get_PressedBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter2_adaptor::PressedBackground)->_put_PressedBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} PressedBackground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter2_adaptor::SelectedPressedBackground)->_get_SelectedPressedBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter2_adaptor::SelectedPressedBackground)->_put_SelectedPressedBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} SelectedPressedBackground;
	};
	IListViewItemPresenter2_adaptor() {}
};
template<typename X> struct adapt<IListViewItemPresenter2, X> : Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter2_adaptor<X> { typedef adapt IListViewItemPresenter2; };
struct IListViewItemPresenter2 : IListViewItemPresenter2_raw, generate<IListViewItemPresenter2> {};

// IListViewItemPresenter
struct IListViewItemPresenter_raw : IInspectable {
	virtual STDMETHODIMP _get_SelectionCheckMarkVisualEnabled(bool *value);
	virtual STDMETHODIMP _put_SelectionCheckMarkVisualEnabled(bool value);
	virtual STDMETHODIMP _get_CheckHintBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_CheckHintBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_CheckSelectingBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_CheckSelectingBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_CheckBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_CheckBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_DragBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_DragBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_DragForeground(Media::Brush* *value);
	virtual STDMETHODIMP _put_DragForeground(Media::Brush* value);
	virtual STDMETHODIMP _get_FocusBorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_FocusBorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_PlaceholderBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_PlaceholderBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_PointerOverBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_PointerOverBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_SelectedBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_SelectedBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_SelectedForeground(Media::Brush* *value);
	virtual STDMETHODIMP _put_SelectedForeground(Media::Brush* value);
	virtual STDMETHODIMP _get_SelectedPointerOverBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_SelectedPointerOverBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_SelectedPointerOverBorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_SelectedPointerOverBorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_SelectedBorderThickness(Thickness *value);
	virtual STDMETHODIMP _put_SelectedBorderThickness(Thickness value);
	virtual STDMETHODIMP _get_DisabledOpacity(double *value);
	virtual STDMETHODIMP _put_DisabledOpacity(double value);
	virtual STDMETHODIMP _get_DragOpacity(double *value);
	virtual STDMETHODIMP _put_DragOpacity(double value);
	virtual STDMETHODIMP _get_ReorderHintOffset(double *value);
	virtual STDMETHODIMP _put_ReorderHintOffset(double value);
	virtual STDMETHODIMP _get_ListViewItemPresenterHorizontalContentAlignment(HorizontalAlignment *value);
	virtual STDMETHODIMP _put_ListViewItemPresenterHorizontalContentAlignment(HorizontalAlignment value);
	virtual STDMETHODIMP _get_ListViewItemPresenterVerticalContentAlignment(VerticalAlignment *value);
	virtual STDMETHODIMP _put_ListViewItemPresenterVerticalContentAlignment(VerticalAlignment value);
	virtual STDMETHODIMP _get_ListViewItemPresenterPadding(Thickness *value);
	virtual STDMETHODIMP _put_ListViewItemPresenterPadding(Thickness value);
	virtual STDMETHODIMP _get_PointerOverBackgroundMargin(Thickness *value);
	virtual STDMETHODIMP _put_PointerOverBackgroundMargin(Thickness value);
	virtual STDMETHODIMP _get_ContentMargin(Thickness *value);
	virtual STDMETHODIMP _put_ContentMargin(Thickness value);
};
template<typename X> struct IListViewItemPresenter_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter_adaptor::CheckBrush)->_get_CheckBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter_adaptor::CheckBrush)->_put_CheckBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} CheckBrush;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter_adaptor::CheckHintBrush)->_get_CheckHintBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter_adaptor::CheckHintBrush)->_put_CheckHintBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} CheckHintBrush;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter_adaptor::CheckSelectingBrush)->_get_CheckSelectingBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter_adaptor::CheckSelectingBrush)->_put_CheckSelectingBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} CheckSelectingBrush;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IListViewItemPresenter_adaptor::ContentMargin)->_get_ContentMargin(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IListViewItemPresenter_adaptor::ContentMargin)->_put_ContentMargin(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} ContentMargin;
		struct : property {
			double get() { double value; hrcheck(enc(&IListViewItemPresenter_adaptor::DisabledOpacity)->_get_DisabledOpacity(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IListViewItemPresenter_adaptor::DisabledOpacity)->_put_DisabledOpacity(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DisabledOpacity;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter_adaptor::DragBackground)->_get_DragBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter_adaptor::DragBackground)->_put_DragBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} DragBackground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter_adaptor::DragForeground)->_get_DragForeground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter_adaptor::DragForeground)->_put_DragForeground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} DragForeground;
		struct : property {
			double get() { double value; hrcheck(enc(&IListViewItemPresenter_adaptor::DragOpacity)->_get_DragOpacity(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IListViewItemPresenter_adaptor::DragOpacity)->_put_DragOpacity(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DragOpacity;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter_adaptor::FocusBorderBrush)->_get_FocusBorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter_adaptor::FocusBorderBrush)->_put_FocusBorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} FocusBorderBrush;
		struct : property {
			HorizontalAlignment get() { HorizontalAlignment value; hrcheck(enc(&IListViewItemPresenter_adaptor::ListViewItemPresenterHorizontalContentAlignment)->_get_ListViewItemPresenterHorizontalContentAlignment(&value)); return value; }
			HorizontalAlignment operator()() { return get(); }
			operator HorizontalAlignment () { return get(); }
			void put(HorizontalAlignment value) { hrcheck(enc(&IListViewItemPresenter_adaptor::ListViewItemPresenterHorizontalContentAlignment)->_put_ListViewItemPresenterHorizontalContentAlignment(value)); }
			void operator=(HorizontalAlignment value) { put(value); }
			void operator()(HorizontalAlignment value) { put(value); }
		} ListViewItemPresenterHorizontalContentAlignment;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IListViewItemPresenter_adaptor::ListViewItemPresenterPadding)->_get_ListViewItemPresenterPadding(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IListViewItemPresenter_adaptor::ListViewItemPresenterPadding)->_put_ListViewItemPresenterPadding(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} ListViewItemPresenterPadding;
		struct : property {
			VerticalAlignment get() { VerticalAlignment value; hrcheck(enc(&IListViewItemPresenter_adaptor::ListViewItemPresenterVerticalContentAlignment)->_get_ListViewItemPresenterVerticalContentAlignment(&value)); return value; }
			VerticalAlignment operator()() { return get(); }
			operator VerticalAlignment () { return get(); }
			void put(VerticalAlignment value) { hrcheck(enc(&IListViewItemPresenter_adaptor::ListViewItemPresenterVerticalContentAlignment)->_put_ListViewItemPresenterVerticalContentAlignment(value)); }
			void operator=(VerticalAlignment value) { put(value); }
			void operator()(VerticalAlignment value) { put(value); }
		} ListViewItemPresenterVerticalContentAlignment;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter_adaptor::PlaceholderBackground)->_get_PlaceholderBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter_adaptor::PlaceholderBackground)->_put_PlaceholderBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} PlaceholderBackground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter_adaptor::PointerOverBackground)->_get_PointerOverBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter_adaptor::PointerOverBackground)->_put_PointerOverBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} PointerOverBackground;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IListViewItemPresenter_adaptor::PointerOverBackgroundMargin)->_get_PointerOverBackgroundMargin(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IListViewItemPresenter_adaptor::PointerOverBackgroundMargin)->_put_PointerOverBackgroundMargin(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} PointerOverBackgroundMargin;
		struct : property {
			double get() { double value; hrcheck(enc(&IListViewItemPresenter_adaptor::ReorderHintOffset)->_get_ReorderHintOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IListViewItemPresenter_adaptor::ReorderHintOffset)->_put_ReorderHintOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ReorderHintOffset;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter_adaptor::SelectedBackground)->_get_SelectedBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter_adaptor::SelectedBackground)->_put_SelectedBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} SelectedBackground;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IListViewItemPresenter_adaptor::SelectedBorderThickness)->_get_SelectedBorderThickness(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IListViewItemPresenter_adaptor::SelectedBorderThickness)->_put_SelectedBorderThickness(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} SelectedBorderThickness;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter_adaptor::SelectedForeground)->_get_SelectedForeground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter_adaptor::SelectedForeground)->_put_SelectedForeground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} SelectedForeground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter_adaptor::SelectedPointerOverBackground)->_get_SelectedPointerOverBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter_adaptor::SelectedPointerOverBackground)->_put_SelectedPointerOverBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} SelectedPointerOverBackground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IListViewItemPresenter_adaptor::SelectedPointerOverBorderBrush)->_get_SelectedPointerOverBorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IListViewItemPresenter_adaptor::SelectedPointerOverBorderBrush)->_put_SelectedPointerOverBorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} SelectedPointerOverBorderBrush;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IListViewItemPresenter_adaptor::SelectionCheckMarkVisualEnabled)->_get_SelectionCheckMarkVisualEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IListViewItemPresenter_adaptor::SelectionCheckMarkVisualEnabled)->_put_SelectionCheckMarkVisualEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} SelectionCheckMarkVisualEnabled;
	};
	IListViewItemPresenter_adaptor() {}
};
template<typename X> struct adapt<IListViewItemPresenter, X> : Windows::UI::Xaml::Controls::Primitives::IListViewItemPresenter_adaptor<X> { typedef adapt IListViewItemPresenter; };
struct IListViewItemPresenter : IListViewItemPresenter_raw, generate<IListViewItemPresenter> {};
}

// IContentPresenterStatics4
struct IContentPresenterStatics4 : IInspectable {
	virtual STDMETHODIMP _get_TextWrappingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxLinesProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_LineStackingStrategyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_LineHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BorderThicknessProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CornerRadiusProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PaddingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalContentAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalContentAlignmentProperty(DependencyProperty* *value);
};

// IContentPresenterStatics3
struct IContentPresenterStatics3 : IInspectable {
	virtual STDMETHODIMP _get_IsTextScaleFactorEnabledProperty(DependencyProperty* *value);
};

// IContentPresenterStatics2
struct IContentPresenterStatics2 : IInspectable {
	virtual STDMETHODIMP _get_OpticalMarginAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextLineBoundsProperty(DependencyProperty* *value);
};

// IContentPresenterFactory
struct IContentPresenterFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ContentPresenter* *instance);
};

// IContentPresenterStatics
struct IContentPresenterStatics : IInspectable {
	virtual STDMETHODIMP _get_ContentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentTemplateSelectorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentTransitionsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontSizeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontFamilyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontWeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontStretchProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CharacterSpacingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ForegroundProperty(DependencyProperty* *value);
};

// IContentPresenter4
struct IContentPresenter4_raw : IInspectable {
	virtual STDMETHODIMP _get_TextWrapping(Xaml::TextWrapping *value);
	virtual STDMETHODIMP _put_TextWrapping(Xaml::TextWrapping value);
	virtual STDMETHODIMP _get_MaxLines(int *value);
	virtual STDMETHODIMP _put_MaxLines(int value);
	virtual STDMETHODIMP _get_LineStackingStrategy(Xaml::LineStackingStrategy *value);
	virtual STDMETHODIMP _put_LineStackingStrategy(Xaml::LineStackingStrategy value);
	virtual STDMETHODIMP _get_LineHeight(double *value);
	virtual STDMETHODIMP _put_LineHeight(double value);
	virtual STDMETHODIMP _get_BorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_BorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_BorderThickness(Thickness *value);
	virtual STDMETHODIMP _put_BorderThickness(Thickness value);
	virtual STDMETHODIMP _get_CornerRadius(Xaml::CornerRadius *value);
	virtual STDMETHODIMP _put_CornerRadius(Xaml::CornerRadius value);
	virtual STDMETHODIMP _get_Padding(Thickness *value);
	virtual STDMETHODIMP _put_Padding(Thickness value);
	virtual STDMETHODIMP _get_Background(Media::Brush* *value);
	virtual STDMETHODIMP _put_Background(Media::Brush* value);
	virtual STDMETHODIMP _get_HorizontalContentAlignment(HorizontalAlignment *value);
	virtual STDMETHODIMP _put_HorizontalContentAlignment(HorizontalAlignment value);
	virtual STDMETHODIMP _get_VerticalContentAlignment(VerticalAlignment *value);
	virtual STDMETHODIMP _put_VerticalContentAlignment(VerticalAlignment value);
};
template<typename X> struct IContentPresenter4_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IContentPresenter4_adaptor::Background)->_get_Background(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IContentPresenter4_adaptor::Background)->_put_Background(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Background;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IContentPresenter4_adaptor::BorderBrush)->_get_BorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IContentPresenter4_adaptor::BorderBrush)->_put_BorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} BorderBrush;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IContentPresenter4_adaptor::BorderThickness)->_get_BorderThickness(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IContentPresenter4_adaptor::BorderThickness)->_put_BorderThickness(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} BorderThickness;
		struct : property {
			Xaml::CornerRadius get() { Xaml::CornerRadius value; hrcheck(enc(&IContentPresenter4_adaptor::CornerRadius)->_get_CornerRadius(&value)); return value; }
			Xaml::CornerRadius operator()() { return get(); }
			operator Xaml::CornerRadius () { return get(); }
			void put(const Xaml::CornerRadius& value) { hrcheck(enc(&IContentPresenter4_adaptor::CornerRadius)->_put_CornerRadius(value)); }
			void operator=(const Xaml::CornerRadius& value) { put(value); }
			void operator()(const Xaml::CornerRadius& value) { put(value); }
		} CornerRadius;
		struct : property {
			HorizontalAlignment get() { HorizontalAlignment value; hrcheck(enc(&IContentPresenter4_adaptor::HorizontalContentAlignment)->_get_HorizontalContentAlignment(&value)); return value; }
			HorizontalAlignment operator()() { return get(); }
			operator HorizontalAlignment () { return get(); }
			void put(HorizontalAlignment value) { hrcheck(enc(&IContentPresenter4_adaptor::HorizontalContentAlignment)->_put_HorizontalContentAlignment(value)); }
			void operator=(HorizontalAlignment value) { put(value); }
			void operator()(HorizontalAlignment value) { put(value); }
		} HorizontalContentAlignment;
		struct : property {
			double get() { double value; hrcheck(enc(&IContentPresenter4_adaptor::LineHeight)->_get_LineHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IContentPresenter4_adaptor::LineHeight)->_put_LineHeight(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} LineHeight;
		struct : property {
			Xaml::LineStackingStrategy get() { Xaml::LineStackingStrategy value; hrcheck(enc(&IContentPresenter4_adaptor::LineStackingStrategy)->_get_LineStackingStrategy(&value)); return value; }
			Xaml::LineStackingStrategy operator()() { return get(); }
			operator Xaml::LineStackingStrategy () { return get(); }
			void put(Xaml::LineStackingStrategy value) { hrcheck(enc(&IContentPresenter4_adaptor::LineStackingStrategy)->_put_LineStackingStrategy(value)); }
			void operator=(Xaml::LineStackingStrategy value) { put(value); }
			void operator()(Xaml::LineStackingStrategy value) { put(value); }
		} LineStackingStrategy;
		struct : property {
			int get() { int value; hrcheck(enc(&IContentPresenter4_adaptor::MaxLines)->_get_MaxLines(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IContentPresenter4_adaptor::MaxLines)->_put_MaxLines(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaxLines;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IContentPresenter4_adaptor::Padding)->_get_Padding(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IContentPresenter4_adaptor::Padding)->_put_Padding(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} Padding;
		struct : property {
			Xaml::TextWrapping get() { Xaml::TextWrapping value; hrcheck(enc(&IContentPresenter4_adaptor::TextWrapping)->_get_TextWrapping(&value)); return value; }
			Xaml::TextWrapping operator()() { return get(); }
			operator Xaml::TextWrapping () { return get(); }
			void put(Xaml::TextWrapping value) { hrcheck(enc(&IContentPresenter4_adaptor::TextWrapping)->_put_TextWrapping(value)); }
			void operator=(Xaml::TextWrapping value) { put(value); }
			void operator()(Xaml::TextWrapping value) { put(value); }
		} TextWrapping;
		struct : property {
			VerticalAlignment get() { VerticalAlignment value; hrcheck(enc(&IContentPresenter4_adaptor::VerticalContentAlignment)->_get_VerticalContentAlignment(&value)); return value; }
			VerticalAlignment operator()() { return get(); }
			operator VerticalAlignment () { return get(); }
			void put(VerticalAlignment value) { hrcheck(enc(&IContentPresenter4_adaptor::VerticalContentAlignment)->_put_VerticalContentAlignment(value)); }
			void operator=(VerticalAlignment value) { put(value); }
			void operator()(VerticalAlignment value) { put(value); }
		} VerticalContentAlignment;
	};
	IContentPresenter4_adaptor() {}
};
template<typename X> struct adapt<IContentPresenter4, X> : Windows::UI::Xaml::Controls::IContentPresenter4_adaptor<X> { typedef adapt IContentPresenter4; };
struct IContentPresenter4 : IContentPresenter4_raw, generate<IContentPresenter4> {};

// IContentPresenter3
struct IContentPresenter3_raw : IInspectable {
	virtual STDMETHODIMP _get_IsTextScaleFactorEnabled(bool *value);
	virtual STDMETHODIMP _put_IsTextScaleFactorEnabled(bool value);
};
template<typename X> struct IContentPresenter3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IContentPresenter3_adaptor::IsTextScaleFactorEnabled)->_get_IsTextScaleFactorEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IContentPresenter3_adaptor::IsTextScaleFactorEnabled)->_put_IsTextScaleFactorEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTextScaleFactorEnabled;
	};
	IContentPresenter3_adaptor() {}
};
template<typename X> struct adapt<IContentPresenter3, X> : Windows::UI::Xaml::Controls::IContentPresenter3_adaptor<X> { typedef adapt IContentPresenter3; };
struct IContentPresenter3 : IContentPresenter3_raw, generate<IContentPresenter3> {};

// IContentPresenter2
struct IContentPresenter2_raw : IInspectable {
	virtual STDMETHODIMP _get_OpticalMarginAlignment(Xaml::OpticalMarginAlignment *value);
	virtual STDMETHODIMP _put_OpticalMarginAlignment(Xaml::OpticalMarginAlignment value);
	virtual STDMETHODIMP _get_TextLineBounds(Xaml::TextLineBounds *value);
	virtual STDMETHODIMP _put_TextLineBounds(Xaml::TextLineBounds value);
};
template<typename X> struct IContentPresenter2_adaptor : X {
	union {
		struct : property {
			Xaml::OpticalMarginAlignment get() { Xaml::OpticalMarginAlignment value; hrcheck(enc(&IContentPresenter2_adaptor::OpticalMarginAlignment)->_get_OpticalMarginAlignment(&value)); return value; }
			Xaml::OpticalMarginAlignment operator()() { return get(); }
			operator Xaml::OpticalMarginAlignment () { return get(); }
			void put(Xaml::OpticalMarginAlignment value) { hrcheck(enc(&IContentPresenter2_adaptor::OpticalMarginAlignment)->_put_OpticalMarginAlignment(value)); }
			void operator=(Xaml::OpticalMarginAlignment value) { put(value); }
			void operator()(Xaml::OpticalMarginAlignment value) { put(value); }
		} OpticalMarginAlignment;
		struct : property {
			Xaml::TextLineBounds get() { Xaml::TextLineBounds value; hrcheck(enc(&IContentPresenter2_adaptor::TextLineBounds)->_get_TextLineBounds(&value)); return value; }
			Xaml::TextLineBounds operator()() { return get(); }
			operator Xaml::TextLineBounds () { return get(); }
			void put(Xaml::TextLineBounds value) { hrcheck(enc(&IContentPresenter2_adaptor::TextLineBounds)->_put_TextLineBounds(value)); }
			void operator=(Xaml::TextLineBounds value) { put(value); }
			void operator()(Xaml::TextLineBounds value) { put(value); }
		} TextLineBounds;
	};
	IContentPresenter2_adaptor() {}
};
template<typename X> struct adapt<IContentPresenter2, X> : Windows::UI::Xaml::Controls::IContentPresenter2_adaptor<X> { typedef adapt IContentPresenter2; };
struct IContentPresenter2 : IContentPresenter2_raw, generate<IContentPresenter2> {};

// IContentPresenterOverrides
struct IContentPresenterOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnContentTemplateChanged(DataTemplate* oldContentTemplate, DataTemplate* newContentTemplate) = 0;
	virtual STDMETHODIMP _OnContentTemplateSelectorChanged(DataTemplateSelector* oldContentTemplateSelector, DataTemplateSelector* newContentTemplateSelector) = 0;
};
template<typename X> struct IContentPresenterOverrides_adaptor : X {
	void OnContentTemplateChanged(pptr<DataTemplate> oldContentTemplate, pptr<DataTemplate> newContentTemplate) { hrcheck(X::get()->_OnContentTemplateChanged(oldContentTemplate, newContentTemplate)); }
	void OnContentTemplateSelectorChanged(pptr<DataTemplateSelector> oldContentTemplateSelector, pptr<DataTemplateSelector> newContentTemplateSelector) { hrcheck(X::get()->_OnContentTemplateSelectorChanged(oldContentTemplateSelector, newContentTemplateSelector)); }
};
template<typename X> struct adapt<IContentPresenterOverrides, X> : Windows::UI::Xaml::Controls::IContentPresenterOverrides_adaptor<X> { typedef adapt IContentPresenterOverrides; };
template<typename X> struct IContentPresenterOverrides_unadaptor : X {
	STDMETHODIMP _OnContentTemplateChanged(DataTemplate* oldContentTemplate, DataTemplate* newContentTemplate) { return hrtry([&, this] { X::get()->OnContentTemplateChanged(oldContentTemplate, newContentTemplate); }); }
	STDMETHODIMP _OnContentTemplateSelectorChanged(DataTemplateSelector* oldContentTemplateSelector, DataTemplateSelector* newContentTemplateSelector) { return hrtry([&, this] { X::get()->OnContentTemplateSelectorChanged(oldContentTemplateSelector, newContentTemplateSelector); }); }
};
template<typename X> struct unadapt<IContentPresenterOverrides, X> : Windows::UI::Xaml::Controls::IContentPresenterOverrides_unadaptor<X> {};
struct IContentPresenterOverrides : IContentPresenterOverrides_raw, generate<IContentPresenterOverrides> {};

// IContentPresenter
struct IContentPresenter_raw : IInspectable {
	virtual STDMETHODIMP _get_Content(IInspectable* *value);
	virtual STDMETHODIMP _put_Content(IInspectable* value);
	virtual STDMETHODIMP _get_ContentTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_ContentTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_ContentTemplateSelector(DataTemplateSelector* *value);
	virtual STDMETHODIMP _put_ContentTemplateSelector(DataTemplateSelector* value);
	virtual STDMETHODIMP _get_ContentTransitions(Media::Animation::TransitionCollection* *value);
	virtual STDMETHODIMP _put_ContentTransitions(Media::Animation::TransitionCollection* value);
	virtual STDMETHODIMP _get_FontSize(double *value);
	virtual STDMETHODIMP _put_FontSize(double value);
	virtual STDMETHODIMP _get_FontFamily(Media::FontFamily* *value);
	virtual STDMETHODIMP _put_FontFamily(Media::FontFamily* value);
	virtual STDMETHODIMP _get_FontWeight(Text::FontWeight *value);
	virtual STDMETHODIMP _put_FontWeight(Text::FontWeight value);
	virtual STDMETHODIMP _get_FontStyle(Text::FontStyle *value);
	virtual STDMETHODIMP _put_FontStyle(Text::FontStyle value);
	virtual STDMETHODIMP _get_FontStretch(Text::FontStretch *value);
	virtual STDMETHODIMP _put_FontStretch(Text::FontStretch value);
	virtual STDMETHODIMP _get_CharacterSpacing(int *value);
	virtual STDMETHODIMP _put_CharacterSpacing(int value);
	virtual STDMETHODIMP _get_Foreground(Media::Brush* *value);
	virtual STDMETHODIMP _put_Foreground(Media::Brush* value);
};
template<typename X> struct IContentPresenter_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IContentPresenter_adaptor::CharacterSpacing)->_get_CharacterSpacing(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IContentPresenter_adaptor::CharacterSpacing)->_put_CharacterSpacing(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} CharacterSpacing;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IContentPresenter_adaptor::Content)->_get_Content(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IContentPresenter_adaptor::Content)->_put_Content(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Content;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IContentPresenter_adaptor::ContentTemplate)->_get_ContentTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IContentPresenter_adaptor::ContentTemplate)->_put_ContentTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} ContentTemplate;
		struct : property {
			ptr<DataTemplateSelector> get() { DataTemplateSelector* value; hrcheck(enc(&IContentPresenter_adaptor::ContentTemplateSelector)->_get_ContentTemplateSelector(&value)); return from_abi(value); }
			ptr<DataTemplateSelector> operator()() { return get(); }
			operator ptr<DataTemplateSelector> () { return get(); }
			ptr<DataTemplateSelector> operator->() { return get(); }
			void put(pptr<DataTemplateSelector> value) { hrcheck(enc(&IContentPresenter_adaptor::ContentTemplateSelector)->_put_ContentTemplateSelector(value)); }
			void operator=(pptr<DataTemplateSelector> value) { put(value); }
			void operator()(pptr<DataTemplateSelector> value) { put(value); }
		} ContentTemplateSelector;
		struct : property {
			ptr<Media::Animation::TransitionCollection> get() { Media::Animation::TransitionCollection* value; hrcheck(enc(&IContentPresenter_adaptor::ContentTransitions)->_get_ContentTransitions(&value)); return from_abi(value); }
			ptr<Media::Animation::TransitionCollection> operator()() { return get(); }
			operator ptr<Media::Animation::TransitionCollection> () { return get(); }
			ptr<Media::Animation::TransitionCollection> operator->() { return get(); }
			void put(pptr<Media::Animation::TransitionCollection> value) { hrcheck(enc(&IContentPresenter_adaptor::ContentTransitions)->_put_ContentTransitions(value)); }
			void operator=(pptr<Media::Animation::TransitionCollection> value) { put(value); }
			void operator()(pptr<Media::Animation::TransitionCollection> value) { put(value); }
		} ContentTransitions;
		struct : property {
			ptr<Media::FontFamily> get() { Media::FontFamily* value; hrcheck(enc(&IContentPresenter_adaptor::FontFamily)->_get_FontFamily(&value)); return from_abi(value); }
			ptr<Media::FontFamily> operator()() { return get(); }
			operator ptr<Media::FontFamily> () { return get(); }
			ptr<Media::FontFamily> operator->() { return get(); }
			void put(pptr<Media::FontFamily> value) { hrcheck(enc(&IContentPresenter_adaptor::FontFamily)->_put_FontFamily(value)); }
			void operator=(pptr<Media::FontFamily> value) { put(value); }
			void operator()(pptr<Media::FontFamily> value) { put(value); }
		} FontFamily;
		struct : property {
			double get() { double value; hrcheck(enc(&IContentPresenter_adaptor::FontSize)->_get_FontSize(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IContentPresenter_adaptor::FontSize)->_put_FontSize(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FontSize;
		struct : property {
			Text::FontStretch get() { Text::FontStretch value; hrcheck(enc(&IContentPresenter_adaptor::FontStretch)->_get_FontStretch(&value)); return value; }
			Text::FontStretch operator()() { return get(); }
			operator Text::FontStretch () { return get(); }
			void put(Text::FontStretch value) { hrcheck(enc(&IContentPresenter_adaptor::FontStretch)->_put_FontStretch(value)); }
			void operator=(Text::FontStretch value) { put(value); }
			void operator()(Text::FontStretch value) { put(value); }
		} FontStretch;
		struct : property {
			Text::FontStyle get() { Text::FontStyle value; hrcheck(enc(&IContentPresenter_adaptor::FontStyle)->_get_FontStyle(&value)); return value; }
			Text::FontStyle operator()() { return get(); }
			operator Text::FontStyle () { return get(); }
			void put(Text::FontStyle value) { hrcheck(enc(&IContentPresenter_adaptor::FontStyle)->_put_FontStyle(value)); }
			void operator=(Text::FontStyle value) { put(value); }
			void operator()(Text::FontStyle value) { put(value); }
		} FontStyle;
		struct : property {
			Text::FontWeight get() { Text::FontWeight value; hrcheck(enc(&IContentPresenter_adaptor::FontWeight)->_get_FontWeight(&value)); return value; }
			Text::FontWeight operator()() { return get(); }
			operator Text::FontWeight () { return get(); }
			void put(const Text::FontWeight& value) { hrcheck(enc(&IContentPresenter_adaptor::FontWeight)->_put_FontWeight(value)); }
			void operator=(const Text::FontWeight& value) { put(value); }
			void operator()(const Text::FontWeight& value) { put(value); }
		} FontWeight;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IContentPresenter_adaptor::Foreground)->_get_Foreground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IContentPresenter_adaptor::Foreground)->_put_Foreground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Foreground;
	};
	IContentPresenter_adaptor() {}
};
template<typename X> struct adapt<IContentPresenter, X> : Windows::UI::Xaml::Controls::IContentPresenter_adaptor<X> { typedef adapt IContentPresenter; };
struct IContentPresenter : IContentPresenter_raw, generate<IContentPresenter> {};

// ContentPresenter
template<typename> struct ContentPresenter_statics {
	static struct _CharacterSpacingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics>()->_get_CharacterSpacingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CharacterSpacingProperty;
	static struct _ContentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics>()->_get_ContentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentProperty;
	static struct _ContentTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics>()->_get_ContentTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentTemplateProperty;
	static struct _ContentTemplateSelectorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics>()->_get_ContentTemplateSelectorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentTemplateSelectorProperty;
	static struct _ContentTransitionsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics>()->_get_ContentTransitionsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentTransitionsProperty;
	static struct _FontFamilyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics>()->_get_FontFamilyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontFamilyProperty;
	static struct _FontSizeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics>()->_get_FontSizeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontSizeProperty;
	static struct _FontStretchProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics>()->_get_FontStretchProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontStretchProperty;
	static struct _FontStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics>()->_get_FontStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontStyleProperty;
	static struct _FontWeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics>()->_get_FontWeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontWeightProperty;
	static struct _ForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics>()->_get_ForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ForegroundProperty;
	static struct _OpticalMarginAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics2>()->_get_OpticalMarginAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OpticalMarginAlignmentProperty;
	static struct _TextLineBoundsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics2>()->_get_TextLineBoundsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextLineBoundsProperty;
	static struct _IsTextScaleFactorEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics3>()->_get_IsTextScaleFactorEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTextScaleFactorEnabledProperty;
	static struct _BackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics4>()->_get_BackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BackgroundProperty;
	static struct _BorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics4>()->_get_BorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BorderBrushProperty;
	static struct _BorderThicknessProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics4>()->_get_BorderThicknessProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BorderThicknessProperty;
	static struct _CornerRadiusProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics4>()->_get_CornerRadiusProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CornerRadiusProperty;
	static struct _HorizontalContentAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics4>()->_get_HorizontalContentAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalContentAlignmentProperty;
	static struct _LineHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics4>()->_get_LineHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LineHeightProperty;
	static struct _LineStackingStrategyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics4>()->_get_LineStackingStrategyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LineStackingStrategyProperty;
	static struct _MaxLinesProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics4>()->_get_MaxLinesProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxLinesProperty;
	static struct _PaddingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics4>()->_get_PaddingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaddingProperty;
	static struct _TextWrappingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics4>()->_get_TextWrappingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextWrappingProperty;
	static struct _VerticalContentAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterStatics4>()->_get_VerticalContentAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalContentAlignmentProperty;
	static ContentPresenter *activate(object_ref outer, IInspectable* *inner) { ContentPresenter *instance; hrcheck(get_activation_factory<ContentPresenter, IContentPresenterFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename ContentPresenter_statics<X>::_CharacterSpacingProperty ContentPresenter_statics<X>::CharacterSpacingProperty;
template<typename X> typename ContentPresenter_statics<X>::_ContentProperty ContentPresenter_statics<X>::ContentProperty;
template<typename X> typename ContentPresenter_statics<X>::_ContentTemplateProperty ContentPresenter_statics<X>::ContentTemplateProperty;
template<typename X> typename ContentPresenter_statics<X>::_ContentTemplateSelectorProperty ContentPresenter_statics<X>::ContentTemplateSelectorProperty;
template<typename X> typename ContentPresenter_statics<X>::_ContentTransitionsProperty ContentPresenter_statics<X>::ContentTransitionsProperty;
template<typename X> typename ContentPresenter_statics<X>::_FontFamilyProperty ContentPresenter_statics<X>::FontFamilyProperty;
template<typename X> typename ContentPresenter_statics<X>::_FontSizeProperty ContentPresenter_statics<X>::FontSizeProperty;
template<typename X> typename ContentPresenter_statics<X>::_FontStretchProperty ContentPresenter_statics<X>::FontStretchProperty;
template<typename X> typename ContentPresenter_statics<X>::_FontStyleProperty ContentPresenter_statics<X>::FontStyleProperty;
template<typename X> typename ContentPresenter_statics<X>::_FontWeightProperty ContentPresenter_statics<X>::FontWeightProperty;
template<typename X> typename ContentPresenter_statics<X>::_ForegroundProperty ContentPresenter_statics<X>::ForegroundProperty;
template<typename X> typename ContentPresenter_statics<X>::_OpticalMarginAlignmentProperty ContentPresenter_statics<X>::OpticalMarginAlignmentProperty;
template<typename X> typename ContentPresenter_statics<X>::_TextLineBoundsProperty ContentPresenter_statics<X>::TextLineBoundsProperty;
template<typename X> typename ContentPresenter_statics<X>::_IsTextScaleFactorEnabledProperty ContentPresenter_statics<X>::IsTextScaleFactorEnabledProperty;
template<typename X> typename ContentPresenter_statics<X>::_BackgroundProperty ContentPresenter_statics<X>::BackgroundProperty;
template<typename X> typename ContentPresenter_statics<X>::_BorderBrushProperty ContentPresenter_statics<X>::BorderBrushProperty;
template<typename X> typename ContentPresenter_statics<X>::_BorderThicknessProperty ContentPresenter_statics<X>::BorderThicknessProperty;
template<typename X> typename ContentPresenter_statics<X>::_CornerRadiusProperty ContentPresenter_statics<X>::CornerRadiusProperty;
template<typename X> typename ContentPresenter_statics<X>::_HorizontalContentAlignmentProperty ContentPresenter_statics<X>::HorizontalContentAlignmentProperty;
template<typename X> typename ContentPresenter_statics<X>::_LineHeightProperty ContentPresenter_statics<X>::LineHeightProperty;
template<typename X> typename ContentPresenter_statics<X>::_LineStackingStrategyProperty ContentPresenter_statics<X>::LineStackingStrategyProperty;
template<typename X> typename ContentPresenter_statics<X>::_MaxLinesProperty ContentPresenter_statics<X>::MaxLinesProperty;
template<typename X> typename ContentPresenter_statics<X>::_PaddingProperty ContentPresenter_statics<X>::PaddingProperty;
template<typename X> typename ContentPresenter_statics<X>::_TextWrappingProperty ContentPresenter_statics<X>::TextWrappingProperty;
template<typename X> typename ContentPresenter_statics<X>::_VerticalContentAlignmentProperty ContentPresenter_statics<X>::VerticalContentAlignmentProperty;

template<typename X> struct statics<ContentPresenter, X> : X, Windows::UI::Xaml::Controls::ContentPresenter_statics<void> {
	using Windows::UI::Xaml::Controls::ContentPresenter_statics<void>::activate;
	typedef typename X::root_type ContentPresenter;
};
struct ContentPresenter : generate<ContentPresenter> {};
namespace Primitives {

// ListViewItemPresenter
template<typename> struct ListViewItemPresenter_statics {
	static struct _CheckBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_CheckBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CheckBrushProperty;
	static struct _CheckHintBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_CheckHintBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CheckHintBrushProperty;
	static struct _CheckSelectingBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_CheckSelectingBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CheckSelectingBrushProperty;
	static struct _ContentMarginProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_ContentMarginProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentMarginProperty;
	static struct _DisabledOpacityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_DisabledOpacityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DisabledOpacityProperty;
	static struct _DragBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_DragBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DragBackgroundProperty;
	static struct _DragForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_DragForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DragForegroundProperty;
	static struct _DragOpacityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_DragOpacityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DragOpacityProperty;
	static struct _FocusBorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_FocusBorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FocusBorderBrushProperty;
	static struct _ListViewItemPresenterHorizontalContentAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_ListViewItemPresenterHorizontalContentAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ListViewItemPresenterHorizontalContentAlignmentProperty;
	static struct _ListViewItemPresenterPaddingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_ListViewItemPresenterPaddingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ListViewItemPresenterPaddingProperty;
	static struct _ListViewItemPresenterVerticalContentAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_ListViewItemPresenterVerticalContentAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ListViewItemPresenterVerticalContentAlignmentProperty;
	static struct _PlaceholderBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_PlaceholderBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlaceholderBackgroundProperty;
	static struct _PointerOverBackgroundMarginProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_PointerOverBackgroundMarginProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PointerOverBackgroundMarginProperty;
	static struct _PointerOverBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_PointerOverBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PointerOverBackgroundProperty;
	static struct _ReorderHintOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_ReorderHintOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ReorderHintOffsetProperty;
	static struct _SelectedBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_SelectedBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedBackgroundProperty;
	static struct _SelectedBorderThicknessProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_SelectedBorderThicknessProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedBorderThicknessProperty;
	static struct _SelectedForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_SelectedForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedForegroundProperty;
	static struct _SelectedPointerOverBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_SelectedPointerOverBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedPointerOverBackgroundProperty;
	static struct _SelectedPointerOverBorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_SelectedPointerOverBorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedPointerOverBorderBrushProperty;
	static struct _SelectionCheckMarkVisualEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics>()->_get_SelectionCheckMarkVisualEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectionCheckMarkVisualEnabledProperty;
	static struct _CheckBoxBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics2>()->_get_CheckBoxBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CheckBoxBrushProperty;
	static struct _CheckModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics2>()->_get_CheckModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CheckModeProperty;
	static struct _FocusSecondaryBorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics2>()->_get_FocusSecondaryBorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FocusSecondaryBorderBrushProperty;
	static struct _PointerOverForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics2>()->_get_PointerOverForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PointerOverForegroundProperty;
	static struct _PressedBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics2>()->_get_PressedBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PressedBackgroundProperty;
	static struct _SelectedPressedBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics2>()->_get_SelectedPressedBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedPressedBackgroundProperty;
	static struct _RevealBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics3>()->_get_RevealBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RevealBackgroundProperty;
	static struct _RevealBackgroundShowsAboveContentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics3>()->_get_RevealBackgroundShowsAboveContentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RevealBackgroundShowsAboveContentProperty;
	static struct _RevealBorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics3>()->_get_RevealBorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RevealBorderBrushProperty;
	static struct _RevealBorderThicknessProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterStatics3>()->_get_RevealBorderThicknessProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RevealBorderThicknessProperty;
	static ListViewItemPresenter *activate(object_ref outer, IInspectable* *inner) { ListViewItemPresenter *instance; hrcheck(get_activation_factory<ListViewItemPresenter, IListViewItemPresenterFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename ListViewItemPresenter_statics<X>::_CheckBrushProperty ListViewItemPresenter_statics<X>::CheckBrushProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_CheckHintBrushProperty ListViewItemPresenter_statics<X>::CheckHintBrushProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_CheckSelectingBrushProperty ListViewItemPresenter_statics<X>::CheckSelectingBrushProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_ContentMarginProperty ListViewItemPresenter_statics<X>::ContentMarginProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_DisabledOpacityProperty ListViewItemPresenter_statics<X>::DisabledOpacityProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_DragBackgroundProperty ListViewItemPresenter_statics<X>::DragBackgroundProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_DragForegroundProperty ListViewItemPresenter_statics<X>::DragForegroundProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_DragOpacityProperty ListViewItemPresenter_statics<X>::DragOpacityProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_FocusBorderBrushProperty ListViewItemPresenter_statics<X>::FocusBorderBrushProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_ListViewItemPresenterHorizontalContentAlignmentProperty ListViewItemPresenter_statics<X>::ListViewItemPresenterHorizontalContentAlignmentProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_ListViewItemPresenterPaddingProperty ListViewItemPresenter_statics<X>::ListViewItemPresenterPaddingProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_ListViewItemPresenterVerticalContentAlignmentProperty ListViewItemPresenter_statics<X>::ListViewItemPresenterVerticalContentAlignmentProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_PlaceholderBackgroundProperty ListViewItemPresenter_statics<X>::PlaceholderBackgroundProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_PointerOverBackgroundMarginProperty ListViewItemPresenter_statics<X>::PointerOverBackgroundMarginProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_PointerOverBackgroundProperty ListViewItemPresenter_statics<X>::PointerOverBackgroundProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_ReorderHintOffsetProperty ListViewItemPresenter_statics<X>::ReorderHintOffsetProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_SelectedBackgroundProperty ListViewItemPresenter_statics<X>::SelectedBackgroundProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_SelectedBorderThicknessProperty ListViewItemPresenter_statics<X>::SelectedBorderThicknessProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_SelectedForegroundProperty ListViewItemPresenter_statics<X>::SelectedForegroundProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_SelectedPointerOverBackgroundProperty ListViewItemPresenter_statics<X>::SelectedPointerOverBackgroundProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_SelectedPointerOverBorderBrushProperty ListViewItemPresenter_statics<X>::SelectedPointerOverBorderBrushProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_SelectionCheckMarkVisualEnabledProperty ListViewItemPresenter_statics<X>::SelectionCheckMarkVisualEnabledProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_CheckBoxBrushProperty ListViewItemPresenter_statics<X>::CheckBoxBrushProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_CheckModeProperty ListViewItemPresenter_statics<X>::CheckModeProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_FocusSecondaryBorderBrushProperty ListViewItemPresenter_statics<X>::FocusSecondaryBorderBrushProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_PointerOverForegroundProperty ListViewItemPresenter_statics<X>::PointerOverForegroundProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_PressedBackgroundProperty ListViewItemPresenter_statics<X>::PressedBackgroundProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_SelectedPressedBackgroundProperty ListViewItemPresenter_statics<X>::SelectedPressedBackgroundProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_RevealBackgroundProperty ListViewItemPresenter_statics<X>::RevealBackgroundProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_RevealBackgroundShowsAboveContentProperty ListViewItemPresenter_statics<X>::RevealBackgroundShowsAboveContentProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_RevealBorderBrushProperty ListViewItemPresenter_statics<X>::RevealBorderBrushProperty;
template<typename X> typename ListViewItemPresenter_statics<X>::_RevealBorderThicknessProperty ListViewItemPresenter_statics<X>::RevealBorderThicknessProperty;

template<typename X> struct statics<ListViewItemPresenter, X> : X, Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter_statics<void> {
	using Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter_statics<void>::activate;
	typedef typename X::root_type ListViewItemPresenter;
};
struct ListViewItemPresenter : generate<ListViewItemPresenter> {};

// IGridViewItemPresenterFactory
struct IGridViewItemPresenterFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, GridViewItemPresenter* *instance);
};

// IGridViewItemPresenterStatics
struct IGridViewItemPresenterStatics : IInspectable {
	virtual STDMETHODIMP _get_SelectionCheckMarkVisualEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CheckHintBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CheckSelectingBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CheckBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DragBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DragForegroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FocusBorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlaceholderBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PointerOverBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedForegroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedPointerOverBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedPointerOverBorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedBorderThicknessProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DisabledOpacityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DragOpacityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ReorderHintOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_GridViewItemPresenterHorizontalContentAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_GridViewItemPresenterVerticalContentAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_GridViewItemPresenterPaddingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PointerOverBackgroundMarginProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentMarginProperty(DependencyProperty* *value);
};

// IGridViewItemPresenter
struct IGridViewItemPresenter_raw : IInspectable {
	virtual STDMETHODIMP _get_SelectionCheckMarkVisualEnabled(bool *value);
	virtual STDMETHODIMP _put_SelectionCheckMarkVisualEnabled(bool value);
	virtual STDMETHODIMP _get_CheckHintBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_CheckHintBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_CheckSelectingBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_CheckSelectingBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_CheckBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_CheckBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_DragBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_DragBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_DragForeground(Media::Brush* *value);
	virtual STDMETHODIMP _put_DragForeground(Media::Brush* value);
	virtual STDMETHODIMP _get_FocusBorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_FocusBorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_PlaceholderBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_PlaceholderBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_PointerOverBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_PointerOverBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_SelectedBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_SelectedBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_SelectedForeground(Media::Brush* *value);
	virtual STDMETHODIMP _put_SelectedForeground(Media::Brush* value);
	virtual STDMETHODIMP _get_SelectedPointerOverBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_SelectedPointerOverBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_SelectedPointerOverBorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_SelectedPointerOverBorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_SelectedBorderThickness(Thickness *value);
	virtual STDMETHODIMP _put_SelectedBorderThickness(Thickness value);
	virtual STDMETHODIMP _get_DisabledOpacity(double *value);
	virtual STDMETHODIMP _put_DisabledOpacity(double value);
	virtual STDMETHODIMP _get_DragOpacity(double *value);
	virtual STDMETHODIMP _put_DragOpacity(double value);
	virtual STDMETHODIMP _get_ReorderHintOffset(double *value);
	virtual STDMETHODIMP _put_ReorderHintOffset(double value);
	virtual STDMETHODIMP _get_GridViewItemPresenterHorizontalContentAlignment(HorizontalAlignment *value);
	virtual STDMETHODIMP _put_GridViewItemPresenterHorizontalContentAlignment(HorizontalAlignment value);
	virtual STDMETHODIMP _get_GridViewItemPresenterVerticalContentAlignment(VerticalAlignment *value);
	virtual STDMETHODIMP _put_GridViewItemPresenterVerticalContentAlignment(VerticalAlignment value);
	virtual STDMETHODIMP _get_GridViewItemPresenterPadding(Thickness *value);
	virtual STDMETHODIMP _put_GridViewItemPresenterPadding(Thickness value);
	virtual STDMETHODIMP _get_PointerOverBackgroundMargin(Thickness *value);
	virtual STDMETHODIMP _put_PointerOverBackgroundMargin(Thickness value);
	virtual STDMETHODIMP _get_ContentMargin(Thickness *value);
	virtual STDMETHODIMP _put_ContentMargin(Thickness value);
};
template<typename X> struct IGridViewItemPresenter_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IGridViewItemPresenter_adaptor::CheckBrush)->_get_CheckBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::CheckBrush)->_put_CheckBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} CheckBrush;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IGridViewItemPresenter_adaptor::CheckHintBrush)->_get_CheckHintBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::CheckHintBrush)->_put_CheckHintBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} CheckHintBrush;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IGridViewItemPresenter_adaptor::CheckSelectingBrush)->_get_CheckSelectingBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::CheckSelectingBrush)->_put_CheckSelectingBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} CheckSelectingBrush;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IGridViewItemPresenter_adaptor::ContentMargin)->_get_ContentMargin(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::ContentMargin)->_put_ContentMargin(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} ContentMargin;
		struct : property {
			double get() { double value; hrcheck(enc(&IGridViewItemPresenter_adaptor::DisabledOpacity)->_get_DisabledOpacity(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::DisabledOpacity)->_put_DisabledOpacity(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DisabledOpacity;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IGridViewItemPresenter_adaptor::DragBackground)->_get_DragBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::DragBackground)->_put_DragBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} DragBackground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IGridViewItemPresenter_adaptor::DragForeground)->_get_DragForeground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::DragForeground)->_put_DragForeground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} DragForeground;
		struct : property {
			double get() { double value; hrcheck(enc(&IGridViewItemPresenter_adaptor::DragOpacity)->_get_DragOpacity(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::DragOpacity)->_put_DragOpacity(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DragOpacity;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IGridViewItemPresenter_adaptor::FocusBorderBrush)->_get_FocusBorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::FocusBorderBrush)->_put_FocusBorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} FocusBorderBrush;
		struct : property {
			HorizontalAlignment get() { HorizontalAlignment value; hrcheck(enc(&IGridViewItemPresenter_adaptor::GridViewItemPresenterHorizontalContentAlignment)->_get_GridViewItemPresenterHorizontalContentAlignment(&value)); return value; }
			HorizontalAlignment operator()() { return get(); }
			operator HorizontalAlignment () { return get(); }
			void put(HorizontalAlignment value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::GridViewItemPresenterHorizontalContentAlignment)->_put_GridViewItemPresenterHorizontalContentAlignment(value)); }
			void operator=(HorizontalAlignment value) { put(value); }
			void operator()(HorizontalAlignment value) { put(value); }
		} GridViewItemPresenterHorizontalContentAlignment;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IGridViewItemPresenter_adaptor::GridViewItemPresenterPadding)->_get_GridViewItemPresenterPadding(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::GridViewItemPresenterPadding)->_put_GridViewItemPresenterPadding(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} GridViewItemPresenterPadding;
		struct : property {
			VerticalAlignment get() { VerticalAlignment value; hrcheck(enc(&IGridViewItemPresenter_adaptor::GridViewItemPresenterVerticalContentAlignment)->_get_GridViewItemPresenterVerticalContentAlignment(&value)); return value; }
			VerticalAlignment operator()() { return get(); }
			operator VerticalAlignment () { return get(); }
			void put(VerticalAlignment value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::GridViewItemPresenterVerticalContentAlignment)->_put_GridViewItemPresenterVerticalContentAlignment(value)); }
			void operator=(VerticalAlignment value) { put(value); }
			void operator()(VerticalAlignment value) { put(value); }
		} GridViewItemPresenterVerticalContentAlignment;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IGridViewItemPresenter_adaptor::PlaceholderBackground)->_get_PlaceholderBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::PlaceholderBackground)->_put_PlaceholderBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} PlaceholderBackground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IGridViewItemPresenter_adaptor::PointerOverBackground)->_get_PointerOverBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::PointerOverBackground)->_put_PointerOverBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} PointerOverBackground;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IGridViewItemPresenter_adaptor::PointerOverBackgroundMargin)->_get_PointerOverBackgroundMargin(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::PointerOverBackgroundMargin)->_put_PointerOverBackgroundMargin(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} PointerOverBackgroundMargin;
		struct : property {
			double get() { double value; hrcheck(enc(&IGridViewItemPresenter_adaptor::ReorderHintOffset)->_get_ReorderHintOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::ReorderHintOffset)->_put_ReorderHintOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ReorderHintOffset;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IGridViewItemPresenter_adaptor::SelectedBackground)->_get_SelectedBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::SelectedBackground)->_put_SelectedBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} SelectedBackground;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IGridViewItemPresenter_adaptor::SelectedBorderThickness)->_get_SelectedBorderThickness(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::SelectedBorderThickness)->_put_SelectedBorderThickness(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} SelectedBorderThickness;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IGridViewItemPresenter_adaptor::SelectedForeground)->_get_SelectedForeground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::SelectedForeground)->_put_SelectedForeground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} SelectedForeground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IGridViewItemPresenter_adaptor::SelectedPointerOverBackground)->_get_SelectedPointerOverBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::SelectedPointerOverBackground)->_put_SelectedPointerOverBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} SelectedPointerOverBackground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IGridViewItemPresenter_adaptor::SelectedPointerOverBorderBrush)->_get_SelectedPointerOverBorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::SelectedPointerOverBorderBrush)->_put_SelectedPointerOverBorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} SelectedPointerOverBorderBrush;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGridViewItemPresenter_adaptor::SelectionCheckMarkVisualEnabled)->_get_SelectionCheckMarkVisualEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IGridViewItemPresenter_adaptor::SelectionCheckMarkVisualEnabled)->_put_SelectionCheckMarkVisualEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} SelectionCheckMarkVisualEnabled;
	};
	IGridViewItemPresenter_adaptor() {}
};
template<typename X> struct adapt<IGridViewItemPresenter, X> : Windows::UI::Xaml::Controls::Primitives::IGridViewItemPresenter_adaptor<X> { typedef adapt IGridViewItemPresenter; };
struct IGridViewItemPresenter : IGridViewItemPresenter_raw, generate<IGridViewItemPresenter> {};

// GridViewItemPresenter
template<typename> struct GridViewItemPresenter_statics {
	static struct _CheckBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_CheckBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CheckBrushProperty;
	static struct _CheckHintBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_CheckHintBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CheckHintBrushProperty;
	static struct _CheckSelectingBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_CheckSelectingBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CheckSelectingBrushProperty;
	static struct _ContentMarginProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_ContentMarginProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentMarginProperty;
	static struct _DisabledOpacityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_DisabledOpacityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DisabledOpacityProperty;
	static struct _DragBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_DragBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DragBackgroundProperty;
	static struct _DragForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_DragForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DragForegroundProperty;
	static struct _DragOpacityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_DragOpacityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DragOpacityProperty;
	static struct _FocusBorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_FocusBorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FocusBorderBrushProperty;
	static struct _GridViewItemPresenterHorizontalContentAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_GridViewItemPresenterHorizontalContentAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GridViewItemPresenterHorizontalContentAlignmentProperty;
	static struct _GridViewItemPresenterPaddingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_GridViewItemPresenterPaddingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GridViewItemPresenterPaddingProperty;
	static struct _GridViewItemPresenterVerticalContentAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_GridViewItemPresenterVerticalContentAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GridViewItemPresenterVerticalContentAlignmentProperty;
	static struct _PlaceholderBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_PlaceholderBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlaceholderBackgroundProperty;
	static struct _PointerOverBackgroundMarginProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_PointerOverBackgroundMarginProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PointerOverBackgroundMarginProperty;
	static struct _PointerOverBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_PointerOverBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PointerOverBackgroundProperty;
	static struct _ReorderHintOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_ReorderHintOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ReorderHintOffsetProperty;
	static struct _SelectedBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_SelectedBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedBackgroundProperty;
	static struct _SelectedBorderThicknessProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_SelectedBorderThicknessProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedBorderThicknessProperty;
	static struct _SelectedForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_SelectedForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedForegroundProperty;
	static struct _SelectedPointerOverBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_SelectedPointerOverBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedPointerOverBackgroundProperty;
	static struct _SelectedPointerOverBorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_SelectedPointerOverBorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedPointerOverBorderBrushProperty;
	static struct _SelectionCheckMarkVisualEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterStatics>()->_get_SelectionCheckMarkVisualEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectionCheckMarkVisualEnabledProperty;
	static GridViewItemPresenter *activate(object_ref outer, IInspectable* *inner) { GridViewItemPresenter *instance; hrcheck(get_activation_factory<GridViewItemPresenter, IGridViewItemPresenterFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename GridViewItemPresenter_statics<X>::_CheckBrushProperty GridViewItemPresenter_statics<X>::CheckBrushProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_CheckHintBrushProperty GridViewItemPresenter_statics<X>::CheckHintBrushProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_CheckSelectingBrushProperty GridViewItemPresenter_statics<X>::CheckSelectingBrushProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_ContentMarginProperty GridViewItemPresenter_statics<X>::ContentMarginProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_DisabledOpacityProperty GridViewItemPresenter_statics<X>::DisabledOpacityProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_DragBackgroundProperty GridViewItemPresenter_statics<X>::DragBackgroundProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_DragForegroundProperty GridViewItemPresenter_statics<X>::DragForegroundProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_DragOpacityProperty GridViewItemPresenter_statics<X>::DragOpacityProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_FocusBorderBrushProperty GridViewItemPresenter_statics<X>::FocusBorderBrushProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_GridViewItemPresenterHorizontalContentAlignmentProperty GridViewItemPresenter_statics<X>::GridViewItemPresenterHorizontalContentAlignmentProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_GridViewItemPresenterPaddingProperty GridViewItemPresenter_statics<X>::GridViewItemPresenterPaddingProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_GridViewItemPresenterVerticalContentAlignmentProperty GridViewItemPresenter_statics<X>::GridViewItemPresenterVerticalContentAlignmentProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_PlaceholderBackgroundProperty GridViewItemPresenter_statics<X>::PlaceholderBackgroundProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_PointerOverBackgroundMarginProperty GridViewItemPresenter_statics<X>::PointerOverBackgroundMarginProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_PointerOverBackgroundProperty GridViewItemPresenter_statics<X>::PointerOverBackgroundProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_ReorderHintOffsetProperty GridViewItemPresenter_statics<X>::ReorderHintOffsetProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_SelectedBackgroundProperty GridViewItemPresenter_statics<X>::SelectedBackgroundProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_SelectedBorderThicknessProperty GridViewItemPresenter_statics<X>::SelectedBorderThicknessProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_SelectedForegroundProperty GridViewItemPresenter_statics<X>::SelectedForegroundProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_SelectedPointerOverBackgroundProperty GridViewItemPresenter_statics<X>::SelectedPointerOverBackgroundProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_SelectedPointerOverBorderBrushProperty GridViewItemPresenter_statics<X>::SelectedPointerOverBorderBrushProperty;
template<typename X> typename GridViewItemPresenter_statics<X>::_SelectionCheckMarkVisualEnabledProperty GridViewItemPresenter_statics<X>::SelectionCheckMarkVisualEnabledProperty;

template<typename X> struct statics<GridViewItemPresenter, X> : X, Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter_statics<void> {
	using Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter_statics<void>::activate;
	typedef typename X::root_type GridViewItemPresenter;
};
struct GridViewItemPresenter : generate<GridViewItemPresenter> {};

// ICalendarPanel
struct ICalendarPanel : IInspectable, generate<ICalendarPanel> {};

// CalendarPanel
template<typename X> struct statics<CalendarPanel, X> : X {
	typedef typename X::root_type CalendarPanel;
};
struct CalendarPanel : generate<CalendarPanel> {};

// IOrientedVirtualizingPanelFactory
struct IOrientedVirtualizingPanelFactory : IInspectable, generate<IOrientedVirtualizingPanelFactory> {};
}

// IInsertionPanel
struct IInsertionPanel_raw : IInspectable {
	virtual STDMETHODIMP _GetInsertionIndexes(Foundation::Point position, int *first, int *second) = 0;
};
template<typename X> struct IInsertionPanel_adaptor : X {
	int GetInsertionIndexes(const Foundation::Point& position, int *first) { int second; hrcheck(X::get()->_GetInsertionIndexes(position, first, &second)); return second; }
};
template<typename X> struct adapt<IInsertionPanel, X> : Windows::UI::Xaml::Controls::IInsertionPanel_adaptor<X> { typedef adapt IInsertionPanel; };
template<typename X> struct IInsertionPanel_unadaptor : X {
	STDMETHODIMP _GetInsertionIndexes(Foundation::Point position, int *first, int *second) { return hrtry([&, this] { *second = X::get()->GetInsertionIndexes(position, first, ); }); }
};
template<typename X> struct unadapt<IInsertionPanel, X> : Windows::UI::Xaml::Controls::IInsertionPanel_unadaptor<X> {};
struct IInsertionPanel : IInsertionPanel_raw, generate<IInsertionPanel> {};
namespace Primitives {

// IOrientedVirtualizingPanel
struct IOrientedVirtualizingPanel_raw : IInspectable {
	virtual STDMETHODIMP _get_CanVerticallyScroll(bool *value);
	virtual STDMETHODIMP _put_CanVerticallyScroll(bool value);
	virtual STDMETHODIMP _get_CanHorizontallyScroll(bool *value);
	virtual STDMETHODIMP _put_CanHorizontallyScroll(bool value);
	virtual STDMETHODIMP _get_ExtentWidth(double *value);
	virtual STDMETHODIMP _get_ExtentHeight(double *value);
	virtual STDMETHODIMP _get_ViewportWidth(double *value);
	virtual STDMETHODIMP _get_ViewportHeight(double *value);
	virtual STDMETHODIMP _get_HorizontalOffset(double *value);
	virtual STDMETHODIMP _get_VerticalOffset(double *value);
	virtual STDMETHODIMP _get_ScrollOwner(IInspectable* *value);
	virtual STDMETHODIMP _put_ScrollOwner(IInspectable* value);
	virtual STDMETHODIMP _LineUp();
	virtual STDMETHODIMP _LineDown();
	virtual STDMETHODIMP _LineLeft();
	virtual STDMETHODIMP _LineRight();
	virtual STDMETHODIMP _PageUp();
	virtual STDMETHODIMP _PageDown();
	virtual STDMETHODIMP _PageLeft();
	virtual STDMETHODIMP _PageRight();
	virtual STDMETHODIMP _MouseWheelUp();
	virtual STDMETHODIMP _MouseWheelDown();
	virtual STDMETHODIMP _MouseWheelLeft();
	virtual STDMETHODIMP _MouseWheelRight();
	virtual STDMETHODIMP _SetHorizontalOffset(double offset);
	virtual STDMETHODIMP _SetVerticalOffset(double offset);
	virtual STDMETHODIMP _MakeVisible(UIElement* visual, Foundation::Rect rectangle, Foundation::Rect *returnValue);
};
template<typename X> struct IOrientedVirtualizingPanel_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IOrientedVirtualizingPanel_adaptor::CanHorizontallyScroll)->_get_CanHorizontallyScroll(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IOrientedVirtualizingPanel_adaptor::CanHorizontallyScroll)->_put_CanHorizontallyScroll(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} CanHorizontallyScroll;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IOrientedVirtualizingPanel_adaptor::CanVerticallyScroll)->_get_CanVerticallyScroll(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IOrientedVirtualizingPanel_adaptor::CanVerticallyScroll)->_put_CanVerticallyScroll(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} CanVerticallyScroll;
		struct : property {
			double get() { double value; hrcheck(enc(&IOrientedVirtualizingPanel_adaptor::ExtentHeight)->_get_ExtentHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ExtentHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IOrientedVirtualizingPanel_adaptor::ExtentWidth)->_get_ExtentWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ExtentWidth;
		struct : property {
			double get() { double value; hrcheck(enc(&IOrientedVirtualizingPanel_adaptor::HorizontalOffset)->_get_HorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} HorizontalOffset;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IOrientedVirtualizingPanel_adaptor::ScrollOwner)->_get_ScrollOwner(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IOrientedVirtualizingPanel_adaptor::ScrollOwner)->_put_ScrollOwner(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} ScrollOwner;
		struct : property {
			double get() { double value; hrcheck(enc(&IOrientedVirtualizingPanel_adaptor::VerticalOffset)->_get_VerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} VerticalOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IOrientedVirtualizingPanel_adaptor::ViewportHeight)->_get_ViewportHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ViewportHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IOrientedVirtualizingPanel_adaptor::ViewportWidth)->_get_ViewportWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ViewportWidth;
	};
	void LineUp() { hrcheck(X::get()->_LineUp()); }
	void LineDown() { hrcheck(X::get()->_LineDown()); }
	void LineLeft() { hrcheck(X::get()->_LineLeft()); }
	void LineRight() { hrcheck(X::get()->_LineRight()); }
	void PageUp() { hrcheck(X::get()->_PageUp()); }
	void PageDown() { hrcheck(X::get()->_PageDown()); }
	void PageLeft() { hrcheck(X::get()->_PageLeft()); }
	void PageRight() { hrcheck(X::get()->_PageRight()); }
	void MouseWheelUp() { hrcheck(X::get()->_MouseWheelUp()); }
	void MouseWheelDown() { hrcheck(X::get()->_MouseWheelDown()); }
	void MouseWheelLeft() { hrcheck(X::get()->_MouseWheelLeft()); }
	void MouseWheelRight() { hrcheck(X::get()->_MouseWheelRight()); }
	void SetHorizontalOffset(double offset) { hrcheck(X::get()->_SetHorizontalOffset(offset)); }
	void SetVerticalOffset(double offset) { hrcheck(X::get()->_SetVerticalOffset(offset)); }
	Foundation::Rect MakeVisible(pptr<UIElement> visual, const Foundation::Rect& rectangle) { Foundation::Rect returnValue; hrcheck(X::get()->_MakeVisible(visual, rectangle, &returnValue)); return returnValue; }
	IOrientedVirtualizingPanel_adaptor() {}
};
template<typename X> struct adapt<IOrientedVirtualizingPanel, X> : Windows::UI::Xaml::Controls::Primitives::IOrientedVirtualizingPanel_adaptor<X> { typedef adapt IOrientedVirtualizingPanel; };
struct IOrientedVirtualizingPanel : IOrientedVirtualizingPanel_raw, generate<IOrientedVirtualizingPanel> {};
}

// IVirtualizingPanelFactory
struct IVirtualizingPanelFactory : IInspectable, generate<IVirtualizingPanelFactory> {};

// IVirtualizingPanelProtected
struct IVirtualizingPanelProtected_raw : IInspectable {
	virtual STDMETHODIMP _AddInternalChild(UIElement* child);
	virtual STDMETHODIMP _InsertInternalChild(int index, UIElement* child);
	virtual STDMETHODIMP _RemoveInternalChildRange(int index, int range);
};
template<typename X> struct IVirtualizingPanelProtected_adaptor : X {
	void AddInternalChild(pptr<UIElement> child) { hrcheck(X::get()->_AddInternalChild(child)); }
	void InsertInternalChild(int index, pptr<UIElement> child) { hrcheck(X::get()->_InsertInternalChild(index, child)); }
	void RemoveInternalChildRange(int index, int range) { hrcheck(X::get()->_RemoveInternalChildRange(index, range)); }
};
template<typename X> struct adapt<IVirtualizingPanelProtected, X> : Windows::UI::Xaml::Controls::IVirtualizingPanelProtected_adaptor<X> { typedef adapt IVirtualizingPanelProtected; };
struct IVirtualizingPanelProtected : IVirtualizingPanelProtected_raw, generate<IVirtualizingPanelProtected> {};

// IVirtualizingPanelOverrides
struct IVirtualizingPanelOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnItemsChanged(IInspectable* sender, Primitives::ItemsChangedEventArgs* args) = 0;
	virtual STDMETHODIMP _OnClearChildren() = 0;
	virtual STDMETHODIMP _BringIndexIntoView(int index) = 0;
};
template<typename X> struct IVirtualizingPanelOverrides_adaptor : X {
	void OnItemsChanged(object_ref sender, pptr<Primitives::ItemsChangedEventArgs> args) { hrcheck(X::get()->_OnItemsChanged(sender, args)); }
	void OnClearChildren() { hrcheck(X::get()->_OnClearChildren()); }
	void BringIndexIntoView(int index) { hrcheck(X::get()->_BringIndexIntoView(index)); }
};
template<typename X> struct adapt<IVirtualizingPanelOverrides, X> : Windows::UI::Xaml::Controls::IVirtualizingPanelOverrides_adaptor<X> { typedef adapt IVirtualizingPanelOverrides; };
template<typename X> struct IVirtualizingPanelOverrides_unadaptor : X {
	STDMETHODIMP _OnItemsChanged(IInspectable* sender, Primitives::ItemsChangedEventArgs* args) { return hrtry([&, this] { X::get()->OnItemsChanged(sender, args); }); }
	STDMETHODIMP _OnClearChildren() { return hrtry([&, this] { X::get()->OnClearChildren(); }); }
	STDMETHODIMP _BringIndexIntoView(int index) { return hrtry([&, this] { X::get()->BringIndexIntoView(index); }); }
};
template<typename X> struct unadapt<IVirtualizingPanelOverrides, X> : Windows::UI::Xaml::Controls::IVirtualizingPanelOverrides_unadaptor<X> {};
struct IVirtualizingPanelOverrides : IVirtualizingPanelOverrides_raw, generate<IVirtualizingPanelOverrides> {};

// IVirtualizingPanel
struct IVirtualizingPanel_raw : IInspectable {
	virtual STDMETHODIMP _get_ItemContainerGenerator(Controls::ItemContainerGenerator* *value);
};
template<typename X> struct IVirtualizingPanel_adaptor : X {
	union {
		struct : property {
			ptr<Controls::ItemContainerGenerator> get() { Controls::ItemContainerGenerator* value; hrcheck(enc(&IVirtualizingPanel_adaptor::ItemContainerGenerator)->_get_ItemContainerGenerator(&value)); return from_abi(value); }
			ptr<Controls::ItemContainerGenerator> operator()() { return get(); }
			operator ptr<Controls::ItemContainerGenerator> () { return get(); }
			ptr<Controls::ItemContainerGenerator> operator->() { return get(); }
		} ItemContainerGenerator;
	};
	IVirtualizingPanel_adaptor() {}
};
template<typename X> struct adapt<IVirtualizingPanel, X> : Windows::UI::Xaml::Controls::IVirtualizingPanel_adaptor<X> { typedef adapt IVirtualizingPanel; };
struct IVirtualizingPanel : IVirtualizingPanel_raw, generate<IVirtualizingPanel> {};

// VirtualizingPanel
template<typename X> struct statics<VirtualizingPanel, X> : X {
	typedef typename X::root_type VirtualizingPanel;
};
struct VirtualizingPanel : generate<VirtualizingPanel> {};
namespace Primitives {

// OrientedVirtualizingPanel
template<typename X> struct statics<OrientedVirtualizingPanel, X> : X {
	typedef typename X::root_type OrientedVirtualizingPanel;
};
struct OrientedVirtualizingPanel : generate<OrientedVirtualizingPanel> {};

// ICarouselPanelFactory
struct ICarouselPanelFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, CarouselPanel* *instance);
};

// ICarouselPanel
struct ICarouselPanel_raw : IInspectable {
	virtual STDMETHODIMP _get_CanVerticallyScroll(bool *value);
	virtual STDMETHODIMP _put_CanVerticallyScroll(bool value);
	virtual STDMETHODIMP _get_CanHorizontallyScroll(bool *value);
	virtual STDMETHODIMP _put_CanHorizontallyScroll(bool value);
	virtual STDMETHODIMP _get_ExtentWidth(double *value);
	virtual STDMETHODIMP _get_ExtentHeight(double *value);
	virtual STDMETHODIMP _get_ViewportWidth(double *value);
	virtual STDMETHODIMP _get_ViewportHeight(double *value);
	virtual STDMETHODIMP _get_HorizontalOffset(double *value);
	virtual STDMETHODIMP _get_VerticalOffset(double *value);
	virtual STDMETHODIMP _get_ScrollOwner(IInspectable* *value);
	virtual STDMETHODIMP _put_ScrollOwner(IInspectable* value);
	virtual STDMETHODIMP _LineUp();
	virtual STDMETHODIMP _LineDown();
	virtual STDMETHODIMP _LineLeft();
	virtual STDMETHODIMP _LineRight();
	virtual STDMETHODIMP _PageUp();
	virtual STDMETHODIMP _PageDown();
	virtual STDMETHODIMP _PageLeft();
	virtual STDMETHODIMP _PageRight();
	virtual STDMETHODIMP _MouseWheelUp();
	virtual STDMETHODIMP _MouseWheelDown();
	virtual STDMETHODIMP _MouseWheelLeft();
	virtual STDMETHODIMP _MouseWheelRight();
	virtual STDMETHODIMP _SetHorizontalOffset(double offset);
	virtual STDMETHODIMP _SetVerticalOffset(double offset);
	virtual STDMETHODIMP _MakeVisible(UIElement* visual, Foundation::Rect rectangle, Foundation::Rect *returnValue);
};
template<typename X> struct ICarouselPanel_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICarouselPanel_adaptor::CanHorizontallyScroll)->_get_CanHorizontallyScroll(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICarouselPanel_adaptor::CanHorizontallyScroll)->_put_CanHorizontallyScroll(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} CanHorizontallyScroll;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICarouselPanel_adaptor::CanVerticallyScroll)->_get_CanVerticallyScroll(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICarouselPanel_adaptor::CanVerticallyScroll)->_put_CanVerticallyScroll(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} CanVerticallyScroll;
		struct : property {
			double get() { double value; hrcheck(enc(&ICarouselPanel_adaptor::ExtentHeight)->_get_ExtentHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ExtentHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&ICarouselPanel_adaptor::ExtentWidth)->_get_ExtentWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ExtentWidth;
		struct : property {
			double get() { double value; hrcheck(enc(&ICarouselPanel_adaptor::HorizontalOffset)->_get_HorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} HorizontalOffset;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ICarouselPanel_adaptor::ScrollOwner)->_get_ScrollOwner(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&ICarouselPanel_adaptor::ScrollOwner)->_put_ScrollOwner(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} ScrollOwner;
		struct : property {
			double get() { double value; hrcheck(enc(&ICarouselPanel_adaptor::VerticalOffset)->_get_VerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} VerticalOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&ICarouselPanel_adaptor::ViewportHeight)->_get_ViewportHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ViewportHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&ICarouselPanel_adaptor::ViewportWidth)->_get_ViewportWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ViewportWidth;
	};
	void LineUp() { hrcheck(X::get()->_LineUp()); }
	void LineDown() { hrcheck(X::get()->_LineDown()); }
	void LineLeft() { hrcheck(X::get()->_LineLeft()); }
	void LineRight() { hrcheck(X::get()->_LineRight()); }
	void PageUp() { hrcheck(X::get()->_PageUp()); }
	void PageDown() { hrcheck(X::get()->_PageDown()); }
	void PageLeft() { hrcheck(X::get()->_PageLeft()); }
	void PageRight() { hrcheck(X::get()->_PageRight()); }
	void MouseWheelUp() { hrcheck(X::get()->_MouseWheelUp()); }
	void MouseWheelDown() { hrcheck(X::get()->_MouseWheelDown()); }
	void MouseWheelLeft() { hrcheck(X::get()->_MouseWheelLeft()); }
	void MouseWheelRight() { hrcheck(X::get()->_MouseWheelRight()); }
	void SetHorizontalOffset(double offset) { hrcheck(X::get()->_SetHorizontalOffset(offset)); }
	void SetVerticalOffset(double offset) { hrcheck(X::get()->_SetVerticalOffset(offset)); }
	Foundation::Rect MakeVisible(pptr<UIElement> visual, const Foundation::Rect& rectangle) { Foundation::Rect returnValue; hrcheck(X::get()->_MakeVisible(visual, rectangle, &returnValue)); return returnValue; }
	ICarouselPanel_adaptor() {}
};
template<typename X> struct adapt<ICarouselPanel, X> : Windows::UI::Xaml::Controls::Primitives::ICarouselPanel_adaptor<X> { typedef adapt ICarouselPanel; };
struct ICarouselPanel : ICarouselPanel_raw, generate<ICarouselPanel> {};

// CarouselPanel
template<typename> struct CarouselPanel_statics {
	static CarouselPanel *activate(object_ref outer, IInspectable* *inner) { CarouselPanel *instance; hrcheck(get_activation_factory<CarouselPanel, ICarouselPanelFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<CarouselPanel, X> : X, Windows::UI::Xaml::Controls::Primitives::CarouselPanel_statics<void> {
	using Windows::UI::Xaml::Controls::Primitives::CarouselPanel_statics<void>::activate;
	typedef typename X::root_type CarouselPanel;
};
struct CarouselPanel : generate<CarouselPanel> {};

// ITickBarStatics
struct ITickBarStatics : IInspectable {
	virtual STDMETHODIMP _get_FillProperty(DependencyProperty* *value);
};

// ITickBar
struct ITickBar_raw : IInspectable {
	virtual STDMETHODIMP _get_Fill(Media::Brush* *value);
	virtual STDMETHODIMP _put_Fill(Media::Brush* value);
};
template<typename X> struct ITickBar_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ITickBar_adaptor::Fill)->_get_Fill(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ITickBar_adaptor::Fill)->_put_Fill(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Fill;
	};
	ITickBar_adaptor() {}
};
template<typename X> struct adapt<ITickBar, X> : Windows::UI::Xaml::Controls::Primitives::ITickBar_adaptor<X> { typedef adapt ITickBar; };
struct ITickBar : ITickBar_raw, generate<ITickBar> {};

// TickBar
template<typename> struct TickBar_statics {
	static struct _FillProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TickBar, ITickBarStatics>()->_get_FillProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FillProperty;
};
template<typename X> typename TickBar_statics<X>::_FillProperty TickBar_statics<X>::FillProperty;

template<typename X> struct statics<TickBar, X> : X, Windows::UI::Xaml::Controls::Primitives::TickBar_statics<void> {
	typedef typename X::root_type TickBar;
};
struct TickBar : generate<TickBar> {};

// IPopupStatics2
struct IPopupStatics2 : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayModeProperty(DependencyProperty* *value);
};

// IPopupStatics
struct IPopupStatics : IInspectable {
	virtual STDMETHODIMP _get_ChildProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsOpenProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ChildTransitionsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsLightDismissEnabledProperty(DependencyProperty* *value);
};

// IPopup2
struct IPopup2_raw : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayMode(Controls::LightDismissOverlayMode *value);
	virtual STDMETHODIMP _put_LightDismissOverlayMode(Controls::LightDismissOverlayMode value);
};
template<typename X> struct IPopup2_adaptor : X {
	union {
		struct : property {
			Controls::LightDismissOverlayMode get() { Controls::LightDismissOverlayMode value; hrcheck(enc(&IPopup2_adaptor::LightDismissOverlayMode)->_get_LightDismissOverlayMode(&value)); return value; }
			Controls::LightDismissOverlayMode operator()() { return get(); }
			operator Controls::LightDismissOverlayMode () { return get(); }
			void put(Controls::LightDismissOverlayMode value) { hrcheck(enc(&IPopup2_adaptor::LightDismissOverlayMode)->_put_LightDismissOverlayMode(value)); }
			void operator=(Controls::LightDismissOverlayMode value) { put(value); }
			void operator()(Controls::LightDismissOverlayMode value) { put(value); }
		} LightDismissOverlayMode;
	};
	IPopup2_adaptor() {}
};
template<typename X> struct adapt<IPopup2, X> : Windows::UI::Xaml::Controls::Primitives::IPopup2_adaptor<X> { typedef adapt IPopup2; };
struct IPopup2 : IPopup2_raw, generate<IPopup2> {};

// IPopup
struct IPopup_raw : IInspectable {
	virtual STDMETHODIMP _get_Child(UIElement* *value);
	virtual STDMETHODIMP _put_Child(UIElement* value);
	virtual STDMETHODIMP _get_IsOpen(bool *value);
	virtual STDMETHODIMP _put_IsOpen(bool value);
	virtual STDMETHODIMP _get_HorizontalOffset(double *value);
	virtual STDMETHODIMP _put_HorizontalOffset(double value);
	virtual STDMETHODIMP _get_VerticalOffset(double *value);
	virtual STDMETHODIMP _put_VerticalOffset(double value);
	virtual STDMETHODIMP _get_ChildTransitions(Media::Animation::TransitionCollection* *value);
	virtual STDMETHODIMP _put_ChildTransitions(Media::Animation::TransitionCollection* value);
	virtual STDMETHODIMP _get_IsLightDismissEnabled(bool *value);
	virtual STDMETHODIMP _put_IsLightDismissEnabled(bool value);
	virtual STDMETHODIMP _add_Opened(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Opened(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Closed(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Closed(Foundation::EventRegistrationToken token);
};
template<typename X> struct IPopup_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IPopup_adaptor::Child)->_get_Child(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IPopup_adaptor::Child)->_put_Child(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} Child;
		struct : property {
			ptr<Media::Animation::TransitionCollection> get() { Media::Animation::TransitionCollection* value; hrcheck(enc(&IPopup_adaptor::ChildTransitions)->_get_ChildTransitions(&value)); return from_abi(value); }
			ptr<Media::Animation::TransitionCollection> operator()() { return get(); }
			operator ptr<Media::Animation::TransitionCollection> () { return get(); }
			ptr<Media::Animation::TransitionCollection> operator->() { return get(); }
			void put(pptr<Media::Animation::TransitionCollection> value) { hrcheck(enc(&IPopup_adaptor::ChildTransitions)->_put_ChildTransitions(value)); }
			void operator=(pptr<Media::Animation::TransitionCollection> value) { put(value); }
			void operator()(pptr<Media::Animation::TransitionCollection> value) { put(value); }
		} ChildTransitions;
		struct : property {
			double get() { double value; hrcheck(enc(&IPopup_adaptor::HorizontalOffset)->_get_HorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPopup_adaptor::HorizontalOffset)->_put_HorizontalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} HorizontalOffset;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPopup_adaptor::IsLightDismissEnabled)->_get_IsLightDismissEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IPopup_adaptor::IsLightDismissEnabled)->_put_IsLightDismissEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsLightDismissEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPopup_adaptor::IsOpen)->_get_IsOpen(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IPopup_adaptor::IsOpen)->_put_IsOpen(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsOpen;
		struct : property {
			double get() { double value; hrcheck(enc(&IPopup_adaptor::VerticalOffset)->_get_VerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IPopup_adaptor::VerticalOffset)->_put_VerticalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} VerticalOffset;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPopup_adaptor::Closed)->_add_Closed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPopup_adaptor::Closed)->_remove_Closed(token)); }
		} Closed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPopup_adaptor::Opened)->_add_Opened(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPopup_adaptor::Opened)->_remove_Opened(token)); }
		} Opened;
	};
	IPopup_adaptor() {}
};
template<typename X> struct adapt<IPopup, X> : Windows::UI::Xaml::Controls::Primitives::IPopup_adaptor<X> { typedef adapt IPopup; };
struct IPopup : IPopup_raw, generate<IPopup> {};

// Popup
template<typename> struct Popup_statics {
	static struct _ChildProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Popup, IPopupStatics>()->_get_ChildProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ChildProperty;
	static struct _ChildTransitionsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Popup, IPopupStatics>()->_get_ChildTransitionsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ChildTransitionsProperty;
	static struct _HorizontalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Popup, IPopupStatics>()->_get_HorizontalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalOffsetProperty;
	static struct _IsLightDismissEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Popup, IPopupStatics>()->_get_IsLightDismissEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsLightDismissEnabledProperty;
	static struct _IsOpenProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Popup, IPopupStatics>()->_get_IsOpenProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsOpenProperty;
	static struct _VerticalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Popup, IPopupStatics>()->_get_VerticalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalOffsetProperty;
	static struct _LightDismissOverlayModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Popup, IPopupStatics2>()->_get_LightDismissOverlayModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LightDismissOverlayModeProperty;
};
template<typename X> typename Popup_statics<X>::_ChildProperty Popup_statics<X>::ChildProperty;
template<typename X> typename Popup_statics<X>::_ChildTransitionsProperty Popup_statics<X>::ChildTransitionsProperty;
template<typename X> typename Popup_statics<X>::_HorizontalOffsetProperty Popup_statics<X>::HorizontalOffsetProperty;
template<typename X> typename Popup_statics<X>::_IsLightDismissEnabledProperty Popup_statics<X>::IsLightDismissEnabledProperty;
template<typename X> typename Popup_statics<X>::_IsOpenProperty Popup_statics<X>::IsOpenProperty;
template<typename X> typename Popup_statics<X>::_VerticalOffsetProperty Popup_statics<X>::VerticalOffsetProperty;
template<typename X> typename Popup_statics<X>::_LightDismissOverlayModeProperty Popup_statics<X>::LightDismissOverlayModeProperty;

template<typename X> struct statics<Popup, X> : X, Windows::UI::Xaml::Controls::Primitives::Popup_statics<void> {
	typedef typename X::root_type Popup;
};
struct Popup : generate<Popup> {};

// IScrollEventArgs
struct IScrollEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_NewValue(double *value);
	virtual STDMETHODIMP _get_ScrollEventType(Primitives::ScrollEventType *value);
};
template<typename X> struct IScrollEventArgs_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollEventArgs_adaptor::NewValue)->_get_NewValue(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} NewValue;
		struct : property {
			Primitives::ScrollEventType get() { Primitives::ScrollEventType value; hrcheck(enc(&IScrollEventArgs_adaptor::ScrollEventType)->_get_ScrollEventType(&value)); return value; }
			Primitives::ScrollEventType operator()() { return get(); }
			operator Primitives::ScrollEventType () { return get(); }
		} ScrollEventType;
	};
	IScrollEventArgs_adaptor() {}
};
template<typename X> struct adapt<IScrollEventArgs, X> : Windows::UI::Xaml::Controls::Primitives::IScrollEventArgs_adaptor<X> { typedef adapt IScrollEventArgs; };
struct IScrollEventArgs : IScrollEventArgs_raw, generate<IScrollEventArgs> {};

// ScrollEventArgs
template<typename X> struct statics<ScrollEventArgs, X> : X {
	typedef typename X::root_type ScrollEventArgs;
};
struct ScrollEventArgs : generate<ScrollEventArgs> {};

// IRangeBaseValueChangedEventArgs
struct IRangeBaseValueChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_OldValue(double *value);
	virtual STDMETHODIMP _get_NewValue(double *value);
};
template<typename X> struct IRangeBaseValueChangedEventArgs_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IRangeBaseValueChangedEventArgs_adaptor::NewValue)->_get_NewValue(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} NewValue;
		struct : property {
			double get() { double value; hrcheck(enc(&IRangeBaseValueChangedEventArgs_adaptor::OldValue)->_get_OldValue(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} OldValue;
	};
	IRangeBaseValueChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IRangeBaseValueChangedEventArgs, X> : Windows::UI::Xaml::Controls::Primitives::IRangeBaseValueChangedEventArgs_adaptor<X> { typedef adapt IRangeBaseValueChangedEventArgs; };
struct IRangeBaseValueChangedEventArgs : IRangeBaseValueChangedEventArgs_raw, generate<IRangeBaseValueChangedEventArgs> {};

// RangeBaseValueChangedEventArgs
template<typename X> struct statics<RangeBaseValueChangedEventArgs, X> : X {
	typedef typename X::root_type RangeBaseValueChangedEventArgs;
};
struct RangeBaseValueChangedEventArgs : generate<RangeBaseValueChangedEventArgs> {};

// IDragStartedEventArgsFactory
struct IDragStartedEventArgsFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithHorizontalOffsetAndVerticalOffset(double horizontalOffset, double verticalOffset, IInspectable* outer, IInspectable* *inner, DragStartedEventArgs* *instance);
};

// IDragStartedEventArgs
struct IDragStartedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_HorizontalOffset(double *value);
	virtual STDMETHODIMP _get_VerticalOffset(double *value);
};
template<typename X> struct IDragStartedEventArgs_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IDragStartedEventArgs_adaptor::HorizontalOffset)->_get_HorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} HorizontalOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IDragStartedEventArgs_adaptor::VerticalOffset)->_get_VerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} VerticalOffset;
	};
	IDragStartedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDragStartedEventArgs, X> : Windows::UI::Xaml::Controls::Primitives::IDragStartedEventArgs_adaptor<X> { typedef adapt IDragStartedEventArgs; };
struct IDragStartedEventArgs : IDragStartedEventArgs_raw, generate<IDragStartedEventArgs> {};

// DragStartedEventArgs
template<typename> struct DragStartedEventArgs_statics {
	static DragStartedEventArgs *activate(double horizontalOffset, double verticalOffset, object_ref outer, IInspectable* *inner) { DragStartedEventArgs *instance; hrcheck(get_activation_factory<DragStartedEventArgs, IDragStartedEventArgsFactory>()->_CreateInstanceWithHorizontalOffsetAndVerticalOffset(horizontalOffset, verticalOffset, outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<DragStartedEventArgs, X> : X, Windows::UI::Xaml::Controls::Primitives::DragStartedEventArgs_statics<void> {
	using Windows::UI::Xaml::Controls::Primitives::DragStartedEventArgs_statics<void>::activate;
	typedef typename X::root_type DragStartedEventArgs;
};
struct DragStartedEventArgs : generate<DragStartedEventArgs> {};

// IDragDeltaEventArgsFactory
struct IDragDeltaEventArgsFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithHorizontalChangeAndVerticalChange(double horizontalChange, double verticalChange, IInspectable* outer, IInspectable* *inner, DragDeltaEventArgs* *instance);
};

// IDragDeltaEventArgs
struct IDragDeltaEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_HorizontalChange(double *value);
	virtual STDMETHODIMP _get_VerticalChange(double *value);
};
template<typename X> struct IDragDeltaEventArgs_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IDragDeltaEventArgs_adaptor::HorizontalChange)->_get_HorizontalChange(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} HorizontalChange;
		struct : property {
			double get() { double value; hrcheck(enc(&IDragDeltaEventArgs_adaptor::VerticalChange)->_get_VerticalChange(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} VerticalChange;
	};
	IDragDeltaEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDragDeltaEventArgs, X> : Windows::UI::Xaml::Controls::Primitives::IDragDeltaEventArgs_adaptor<X> { typedef adapt IDragDeltaEventArgs; };
struct IDragDeltaEventArgs : IDragDeltaEventArgs_raw, generate<IDragDeltaEventArgs> {};

// DragDeltaEventArgs
template<typename> struct DragDeltaEventArgs_statics {
	static DragDeltaEventArgs *activate(double horizontalChange, double verticalChange, object_ref outer, IInspectable* *inner) { DragDeltaEventArgs *instance; hrcheck(get_activation_factory<DragDeltaEventArgs, IDragDeltaEventArgsFactory>()->_CreateInstanceWithHorizontalChangeAndVerticalChange(horizontalChange, verticalChange, outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<DragDeltaEventArgs, X> : X, Windows::UI::Xaml::Controls::Primitives::DragDeltaEventArgs_statics<void> {
	using Windows::UI::Xaml::Controls::Primitives::DragDeltaEventArgs_statics<void>::activate;
	typedef typename X::root_type DragDeltaEventArgs;
};
struct DragDeltaEventArgs : generate<DragDeltaEventArgs> {};

// IDragCompletedEventArgsFactory
struct IDragCompletedEventArgsFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithHorizontalChangeVerticalChangeAndCanceled(double horizontalChange, double verticalChange, bool canceled, IInspectable* outer, IInspectable* *inner, DragCompletedEventArgs* *instance);
};

// IDragCompletedEventArgs
struct IDragCompletedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_HorizontalChange(double *value);
	virtual STDMETHODIMP _get_VerticalChange(double *value);
	virtual STDMETHODIMP _get_Canceled(bool *value);
};
template<typename X> struct IDragCompletedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDragCompletedEventArgs_adaptor::Canceled)->_get_Canceled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Canceled;
		struct : property {
			double get() { double value; hrcheck(enc(&IDragCompletedEventArgs_adaptor::HorizontalChange)->_get_HorizontalChange(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} HorizontalChange;
		struct : property {
			double get() { double value; hrcheck(enc(&IDragCompletedEventArgs_adaptor::VerticalChange)->_get_VerticalChange(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} VerticalChange;
	};
	IDragCompletedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDragCompletedEventArgs, X> : Windows::UI::Xaml::Controls::Primitives::IDragCompletedEventArgs_adaptor<X> { typedef adapt IDragCompletedEventArgs; };
struct IDragCompletedEventArgs : IDragCompletedEventArgs_raw, generate<IDragCompletedEventArgs> {};

// DragCompletedEventArgs
template<typename> struct DragCompletedEventArgs_statics {
	static DragCompletedEventArgs *activate(double horizontalChange, double verticalChange, bool canceled, object_ref outer, IInspectable* *inner) { DragCompletedEventArgs *instance; hrcheck(get_activation_factory<DragCompletedEventArgs, IDragCompletedEventArgsFactory>()->_CreateInstanceWithHorizontalChangeVerticalChangeAndCanceled(horizontalChange, verticalChange, canceled, outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<DragCompletedEventArgs, X> : X, Windows::UI::Xaml::Controls::Primitives::DragCompletedEventArgs_statics<void> {
	using Windows::UI::Xaml::Controls::Primitives::DragCompletedEventArgs_statics<void>::activate;
	typedef typename X::root_type DragCompletedEventArgs;
};
struct DragCompletedEventArgs : generate<DragCompletedEventArgs> {};

// IAppBarToggleButtonTemplateSettings
struct IAppBarToggleButtonTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyboardAcceleratorTextMinWidth(double *value);
};
template<typename X> struct IAppBarToggleButtonTemplateSettings_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IAppBarToggleButtonTemplateSettings_adaptor::KeyboardAcceleratorTextMinWidth)->_get_KeyboardAcceleratorTextMinWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} KeyboardAcceleratorTextMinWidth;
	};
	IAppBarToggleButtonTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<IAppBarToggleButtonTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::IAppBarToggleButtonTemplateSettings_adaptor<X> { typedef adapt IAppBarToggleButtonTemplateSettings; };
struct IAppBarToggleButtonTemplateSettings : IAppBarToggleButtonTemplateSettings_raw, generate<IAppBarToggleButtonTemplateSettings> {};

// AppBarToggleButtonTemplateSettings
template<typename X> struct statics<AppBarToggleButtonTemplateSettings, X> : X {
	typedef typename X::root_type AppBarToggleButtonTemplateSettings;
};
struct AppBarToggleButtonTemplateSettings : generate<AppBarToggleButtonTemplateSettings> {};

// IAppBarButtonTemplateSettings
struct IAppBarButtonTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyboardAcceleratorTextMinWidth(double *value);
};
template<typename X> struct IAppBarButtonTemplateSettings_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IAppBarButtonTemplateSettings_adaptor::KeyboardAcceleratorTextMinWidth)->_get_KeyboardAcceleratorTextMinWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} KeyboardAcceleratorTextMinWidth;
	};
	IAppBarButtonTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<IAppBarButtonTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::IAppBarButtonTemplateSettings_adaptor<X> { typedef adapt IAppBarButtonTemplateSettings; };
struct IAppBarButtonTemplateSettings : IAppBarButtonTemplateSettings_raw, generate<IAppBarButtonTemplateSettings> {};

// AppBarButtonTemplateSettings
template<typename X> struct statics<AppBarButtonTemplateSettings, X> : X {
	typedef typename X::root_type AppBarButtonTemplateSettings;
};
struct AppBarButtonTemplateSettings : generate<AppBarButtonTemplateSettings> {};

// ICommandBarTemplateSettings3
struct ICommandBarTemplateSettings3_raw : IInspectable {
	virtual STDMETHODIMP _get_EffectiveOverflowButtonVisibility(Visibility *value);
};
template<typename X> struct ICommandBarTemplateSettings3_adaptor : X {
	union {
		struct : property {
			Visibility get() { Visibility value; hrcheck(enc(&ICommandBarTemplateSettings3_adaptor::EffectiveOverflowButtonVisibility)->_get_EffectiveOverflowButtonVisibility(&value)); return value; }
			Visibility operator()() { return get(); }
			operator Visibility () { return get(); }
		} EffectiveOverflowButtonVisibility;
	};
	ICommandBarTemplateSettings3_adaptor() {}
};
template<typename X> struct adapt<ICommandBarTemplateSettings3, X> : Windows::UI::Xaml::Controls::Primitives::ICommandBarTemplateSettings3_adaptor<X> { typedef adapt ICommandBarTemplateSettings3; };
struct ICommandBarTemplateSettings3 : ICommandBarTemplateSettings3_raw, generate<ICommandBarTemplateSettings3> {};

// ICommandBarTemplateSettings2
struct ICommandBarTemplateSettings2_raw : IInspectable {
	virtual STDMETHODIMP _get_OverflowContentMaxWidth(double *value);
};
template<typename X> struct ICommandBarTemplateSettings2_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&ICommandBarTemplateSettings2_adaptor::OverflowContentMaxWidth)->_get_OverflowContentMaxWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} OverflowContentMaxWidth;
	};
	ICommandBarTemplateSettings2_adaptor() {}
};
template<typename X> struct adapt<ICommandBarTemplateSettings2, X> : Windows::UI::Xaml::Controls::Primitives::ICommandBarTemplateSettings2_adaptor<X> { typedef adapt ICommandBarTemplateSettings2; };
struct ICommandBarTemplateSettings2 : ICommandBarTemplateSettings2_raw, generate<ICommandBarTemplateSettings2> {};

// ICommandBarTemplateSettings
struct ICommandBarTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_ContentHeight(double *value);
	virtual STDMETHODIMP _get_OverflowContentClipRect(Foundation::Rect *value);
	virtual STDMETHODIMP _get_OverflowContentMinWidth(double *value);
	virtual STDMETHODIMP _get_OverflowContentMaxHeight(double *value);
	virtual STDMETHODIMP _get_OverflowContentHorizontalOffset(double *value);
	virtual STDMETHODIMP _get_OverflowContentHeight(double *value);
	virtual STDMETHODIMP _get_NegativeOverflowContentHeight(double *value);
};
template<typename X> struct ICommandBarTemplateSettings_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&ICommandBarTemplateSettings_adaptor::ContentHeight)->_get_ContentHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ContentHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&ICommandBarTemplateSettings_adaptor::NegativeOverflowContentHeight)->_get_NegativeOverflowContentHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} NegativeOverflowContentHeight;
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&ICommandBarTemplateSettings_adaptor::OverflowContentClipRect)->_get_OverflowContentClipRect(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
		} OverflowContentClipRect;
		struct : property {
			double get() { double value; hrcheck(enc(&ICommandBarTemplateSettings_adaptor::OverflowContentHeight)->_get_OverflowContentHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} OverflowContentHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&ICommandBarTemplateSettings_adaptor::OverflowContentHorizontalOffset)->_get_OverflowContentHorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} OverflowContentHorizontalOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&ICommandBarTemplateSettings_adaptor::OverflowContentMaxHeight)->_get_OverflowContentMaxHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} OverflowContentMaxHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&ICommandBarTemplateSettings_adaptor::OverflowContentMinWidth)->_get_OverflowContentMinWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} OverflowContentMinWidth;
	};
	ICommandBarTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<ICommandBarTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::ICommandBarTemplateSettings_adaptor<X> { typedef adapt ICommandBarTemplateSettings; };
struct ICommandBarTemplateSettings : ICommandBarTemplateSettings_raw, generate<ICommandBarTemplateSettings> {};

// CommandBarTemplateSettings
template<typename X> struct statics<CommandBarTemplateSettings, X> : X {
	typedef typename X::root_type CommandBarTemplateSettings;
};
struct CommandBarTemplateSettings : generate<CommandBarTemplateSettings> {};

// IMenuFlyoutItemTemplateSettings
struct IMenuFlyoutItemTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyboardAcceleratorTextMinWidth(double *value);
};
template<typename X> struct IMenuFlyoutItemTemplateSettings_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IMenuFlyoutItemTemplateSettings_adaptor::KeyboardAcceleratorTextMinWidth)->_get_KeyboardAcceleratorTextMinWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} KeyboardAcceleratorTextMinWidth;
	};
	IMenuFlyoutItemTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<IMenuFlyoutItemTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::IMenuFlyoutItemTemplateSettings_adaptor<X> { typedef adapt IMenuFlyoutItemTemplateSettings; };
struct IMenuFlyoutItemTemplateSettings : IMenuFlyoutItemTemplateSettings_raw, generate<IMenuFlyoutItemTemplateSettings> {};

// MenuFlyoutItemTemplateSettings
template<typename X> struct statics<MenuFlyoutItemTemplateSettings, X> : X {
	typedef typename X::root_type MenuFlyoutItemTemplateSettings;
};
struct MenuFlyoutItemTemplateSettings : generate<MenuFlyoutItemTemplateSettings> {};

// IAppBarTemplateSettings
struct IAppBarTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_ClipRect(Foundation::Rect *value);
	virtual STDMETHODIMP _get_CompactVerticalDelta(double *value);
	virtual STDMETHODIMP _get_CompactRootMargin(Thickness *value);
	virtual STDMETHODIMP _get_MinimalVerticalDelta(double *value);
	virtual STDMETHODIMP _get_MinimalRootMargin(Thickness *value);
	virtual STDMETHODIMP _get_HiddenVerticalDelta(double *value);
	virtual STDMETHODIMP _get_HiddenRootMargin(Thickness *value);
};
template<typename X> struct IAppBarTemplateSettings_adaptor : X {
	union {
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&IAppBarTemplateSettings_adaptor::ClipRect)->_get_ClipRect(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
		} ClipRect;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IAppBarTemplateSettings_adaptor::CompactRootMargin)->_get_CompactRootMargin(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
		} CompactRootMargin;
		struct : property {
			double get() { double value; hrcheck(enc(&IAppBarTemplateSettings_adaptor::CompactVerticalDelta)->_get_CompactVerticalDelta(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} CompactVerticalDelta;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IAppBarTemplateSettings_adaptor::HiddenRootMargin)->_get_HiddenRootMargin(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
		} HiddenRootMargin;
		struct : property {
			double get() { double value; hrcheck(enc(&IAppBarTemplateSettings_adaptor::HiddenVerticalDelta)->_get_HiddenVerticalDelta(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} HiddenVerticalDelta;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IAppBarTemplateSettings_adaptor::MinimalRootMargin)->_get_MinimalRootMargin(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
		} MinimalRootMargin;
		struct : property {
			double get() { double value; hrcheck(enc(&IAppBarTemplateSettings_adaptor::MinimalVerticalDelta)->_get_MinimalVerticalDelta(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} MinimalVerticalDelta;
	};
	IAppBarTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<IAppBarTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::IAppBarTemplateSettings_adaptor<X> { typedef adapt IAppBarTemplateSettings; };
struct IAppBarTemplateSettings : IAppBarTemplateSettings_raw, generate<IAppBarTemplateSettings> {};

// AppBarTemplateSettings
template<typename X> struct statics<AppBarTemplateSettings, X> : X {
	typedef typename X::root_type AppBarTemplateSettings;
};
struct AppBarTemplateSettings : generate<AppBarTemplateSettings> {};

// ISplitViewTemplateSettings
struct ISplitViewTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_OpenPaneLength(double *value);
	virtual STDMETHODIMP _get_NegativeOpenPaneLength(double *value);
	virtual STDMETHODIMP _get_OpenPaneLengthMinusCompactLength(double *value);
	virtual STDMETHODIMP _get_NegativeOpenPaneLengthMinusCompactLength(double *value);
	virtual STDMETHODIMP _get_OpenPaneGridLength(GridLength *value);
	virtual STDMETHODIMP _get_CompactPaneGridLength(GridLength *value);
};
template<typename X> struct ISplitViewTemplateSettings_adaptor : X {
	union {
		struct : property {
			GridLength get() { GridLength value; hrcheck(enc(&ISplitViewTemplateSettings_adaptor::CompactPaneGridLength)->_get_CompactPaneGridLength(&value)); return value; }
			GridLength operator()() { return get(); }
			operator GridLength () { return get(); }
		} CompactPaneGridLength;
		struct : property {
			double get() { double value; hrcheck(enc(&ISplitViewTemplateSettings_adaptor::NegativeOpenPaneLength)->_get_NegativeOpenPaneLength(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} NegativeOpenPaneLength;
		struct : property {
			double get() { double value; hrcheck(enc(&ISplitViewTemplateSettings_adaptor::NegativeOpenPaneLengthMinusCompactLength)->_get_NegativeOpenPaneLengthMinusCompactLength(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} NegativeOpenPaneLengthMinusCompactLength;
		struct : property {
			GridLength get() { GridLength value; hrcheck(enc(&ISplitViewTemplateSettings_adaptor::OpenPaneGridLength)->_get_OpenPaneGridLength(&value)); return value; }
			GridLength operator()() { return get(); }
			operator GridLength () { return get(); }
		} OpenPaneGridLength;
		struct : property {
			double get() { double value; hrcheck(enc(&ISplitViewTemplateSettings_adaptor::OpenPaneLength)->_get_OpenPaneLength(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} OpenPaneLength;
		struct : property {
			double get() { double value; hrcheck(enc(&ISplitViewTemplateSettings_adaptor::OpenPaneLengthMinusCompactLength)->_get_OpenPaneLengthMinusCompactLength(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} OpenPaneLengthMinusCompactLength;
	};
	ISplitViewTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<ISplitViewTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::ISplitViewTemplateSettings_adaptor<X> { typedef adapt ISplitViewTemplateSettings; };
struct ISplitViewTemplateSettings : ISplitViewTemplateSettings_raw, generate<ISplitViewTemplateSettings> {};

// SplitViewTemplateSettings
template<typename X> struct statics<SplitViewTemplateSettings, X> : X {
	typedef typename X::root_type SplitViewTemplateSettings;
};
struct SplitViewTemplateSettings : generate<SplitViewTemplateSettings> {};

// ICalendarViewTemplateSettings
struct ICalendarViewTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_MinViewWidth(double *value);
	virtual STDMETHODIMP _get_HeaderText(HSTRING *value);
	virtual STDMETHODIMP _get_WeekDay1(HSTRING *value);
	virtual STDMETHODIMP _get_WeekDay2(HSTRING *value);
	virtual STDMETHODIMP _get_WeekDay3(HSTRING *value);
	virtual STDMETHODIMP _get_WeekDay4(HSTRING *value);
	virtual STDMETHODIMP _get_WeekDay5(HSTRING *value);
	virtual STDMETHODIMP _get_WeekDay6(HSTRING *value);
	virtual STDMETHODIMP _get_WeekDay7(HSTRING *value);
	virtual STDMETHODIMP _get_HasMoreContentAfter(bool *value);
	virtual STDMETHODIMP _get_HasMoreContentBefore(bool *value);
	virtual STDMETHODIMP _get_HasMoreViews(bool *value);
	virtual STDMETHODIMP _get_ClipRect(Foundation::Rect *value);
	virtual STDMETHODIMP _get_CenterX(double *value);
	virtual STDMETHODIMP _get_CenterY(double *value);
};
template<typename X> struct ICalendarViewTemplateSettings_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&ICalendarViewTemplateSettings_adaptor::CenterX)->_get_CenterX(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} CenterX;
		struct : property {
			double get() { double value; hrcheck(enc(&ICalendarViewTemplateSettings_adaptor::CenterY)->_get_CenterY(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} CenterY;
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&ICalendarViewTemplateSettings_adaptor::ClipRect)->_get_ClipRect(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
		} ClipRect;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICalendarViewTemplateSettings_adaptor::HasMoreContentAfter)->_get_HasMoreContentAfter(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasMoreContentAfter;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICalendarViewTemplateSettings_adaptor::HasMoreContentBefore)->_get_HasMoreContentBefore(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasMoreContentBefore;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICalendarViewTemplateSettings_adaptor::HasMoreViews)->_get_HasMoreViews(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasMoreViews;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICalendarViewTemplateSettings_adaptor::HeaderText)->_get_HeaderText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} HeaderText;
		struct : property {
			double get() { double value; hrcheck(enc(&ICalendarViewTemplateSettings_adaptor::MinViewWidth)->_get_MinViewWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} MinViewWidth;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICalendarViewTemplateSettings_adaptor::WeekDay1)->_get_WeekDay1(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} WeekDay1;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICalendarViewTemplateSettings_adaptor::WeekDay2)->_get_WeekDay2(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} WeekDay2;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICalendarViewTemplateSettings_adaptor::WeekDay3)->_get_WeekDay3(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} WeekDay3;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICalendarViewTemplateSettings_adaptor::WeekDay4)->_get_WeekDay4(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} WeekDay4;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICalendarViewTemplateSettings_adaptor::WeekDay5)->_get_WeekDay5(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} WeekDay5;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICalendarViewTemplateSettings_adaptor::WeekDay6)->_get_WeekDay6(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} WeekDay6;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICalendarViewTemplateSettings_adaptor::WeekDay7)->_get_WeekDay7(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} WeekDay7;
	};
	ICalendarViewTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<ICalendarViewTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::ICalendarViewTemplateSettings_adaptor<X> { typedef adapt ICalendarViewTemplateSettings; };
struct ICalendarViewTemplateSettings : ICalendarViewTemplateSettings_raw, generate<ICalendarViewTemplateSettings> {};

// CalendarViewTemplateSettings
template<typename X> struct statics<CalendarViewTemplateSettings, X> : X {
	typedef typename X::root_type CalendarViewTemplateSettings;
};
struct CalendarViewTemplateSettings : generate<CalendarViewTemplateSettings> {};

// IMenuFlyoutPresenterTemplateSettings
struct IMenuFlyoutPresenterTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_FlyoutContentMinWidth(double *value);
};
template<typename X> struct IMenuFlyoutPresenterTemplateSettings_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IMenuFlyoutPresenterTemplateSettings_adaptor::FlyoutContentMinWidth)->_get_FlyoutContentMinWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} FlyoutContentMinWidth;
	};
	IMenuFlyoutPresenterTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<IMenuFlyoutPresenterTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::IMenuFlyoutPresenterTemplateSettings_adaptor<X> { typedef adapt IMenuFlyoutPresenterTemplateSettings; };
struct IMenuFlyoutPresenterTemplateSettings : IMenuFlyoutPresenterTemplateSettings_raw, generate<IMenuFlyoutPresenterTemplateSettings> {};

// MenuFlyoutPresenterTemplateSettings
template<typename X> struct statics<MenuFlyoutPresenterTemplateSettings, X> : X {
	typedef typename X::root_type MenuFlyoutPresenterTemplateSettings;
};
struct MenuFlyoutPresenterTemplateSettings : generate<MenuFlyoutPresenterTemplateSettings> {};

// IListViewItemTemplateSettings
struct IListViewItemTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_DragItemsCount(int *value);
};
template<typename X> struct IListViewItemTemplateSettings_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IListViewItemTemplateSettings_adaptor::DragItemsCount)->_get_DragItemsCount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} DragItemsCount;
	};
	IListViewItemTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<IListViewItemTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::IListViewItemTemplateSettings_adaptor<X> { typedef adapt IListViewItemTemplateSettings; };
struct IListViewItemTemplateSettings : IListViewItemTemplateSettings_raw, generate<IListViewItemTemplateSettings> {};

// ListViewItemTemplateSettings
template<typename X> struct statics<ListViewItemTemplateSettings, X> : X {
	typedef typename X::root_type ListViewItemTemplateSettings;
};
struct ListViewItemTemplateSettings : generate<ListViewItemTemplateSettings> {};

// IGridViewItemTemplateSettings
struct IGridViewItemTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_DragItemsCount(int *value);
};
template<typename X> struct IGridViewItemTemplateSettings_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IGridViewItemTemplateSettings_adaptor::DragItemsCount)->_get_DragItemsCount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} DragItemsCount;
	};
	IGridViewItemTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<IGridViewItemTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::IGridViewItemTemplateSettings_adaptor<X> { typedef adapt IGridViewItemTemplateSettings; };
struct IGridViewItemTemplateSettings : IGridViewItemTemplateSettings_raw, generate<IGridViewItemTemplateSettings> {};

// GridViewItemTemplateSettings
template<typename X> struct statics<GridViewItemTemplateSettings, X> : X {
	typedef typename X::root_type GridViewItemTemplateSettings;
};
struct GridViewItemTemplateSettings : generate<GridViewItemTemplateSettings> {};

// IComboBoxTemplateSettings2
struct IComboBoxTemplateSettings2_raw : IInspectable {
	virtual STDMETHODIMP _get_DropDownContentMinWidth(double *value);
};
template<typename X> struct IComboBoxTemplateSettings2_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IComboBoxTemplateSettings2_adaptor::DropDownContentMinWidth)->_get_DropDownContentMinWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} DropDownContentMinWidth;
	};
	IComboBoxTemplateSettings2_adaptor() {}
};
template<typename X> struct adapt<IComboBoxTemplateSettings2, X> : Windows::UI::Xaml::Controls::Primitives::IComboBoxTemplateSettings2_adaptor<X> { typedef adapt IComboBoxTemplateSettings2; };
struct IComboBoxTemplateSettings2 : IComboBoxTemplateSettings2_raw, generate<IComboBoxTemplateSettings2> {};

// IComboBoxTemplateSettings
struct IComboBoxTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_DropDownOpenedHeight(double *value);
	virtual STDMETHODIMP _get_DropDownClosedHeight(double *value);
	virtual STDMETHODIMP _get_DropDownOffset(double *value);
	virtual STDMETHODIMP _get_SelectedItemDirection(AnimationDirection *value);
};
template<typename X> struct IComboBoxTemplateSettings_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IComboBoxTemplateSettings_adaptor::DropDownClosedHeight)->_get_DropDownClosedHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} DropDownClosedHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IComboBoxTemplateSettings_adaptor::DropDownOffset)->_get_DropDownOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} DropDownOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IComboBoxTemplateSettings_adaptor::DropDownOpenedHeight)->_get_DropDownOpenedHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} DropDownOpenedHeight;
		struct : property {
			AnimationDirection get() { AnimationDirection value; hrcheck(enc(&IComboBoxTemplateSettings_adaptor::SelectedItemDirection)->_get_SelectedItemDirection(&value)); return value; }
			AnimationDirection operator()() { return get(); }
			operator AnimationDirection () { return get(); }
		} SelectedItemDirection;
	};
	IComboBoxTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<IComboBoxTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::IComboBoxTemplateSettings_adaptor<X> { typedef adapt IComboBoxTemplateSettings; };
struct IComboBoxTemplateSettings : IComboBoxTemplateSettings_raw, generate<IComboBoxTemplateSettings> {};

// ComboBoxTemplateSettings
template<typename X> struct statics<ComboBoxTemplateSettings, X> : X {
	typedef typename X::root_type ComboBoxTemplateSettings;
};
struct ComboBoxTemplateSettings : generate<ComboBoxTemplateSettings> {};

// IToolTipTemplateSettings
struct IToolTipTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_FromHorizontalOffset(double *value);
	virtual STDMETHODIMP _get_FromVerticalOffset(double *value);
};
template<typename X> struct IToolTipTemplateSettings_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IToolTipTemplateSettings_adaptor::FromHorizontalOffset)->_get_FromHorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} FromHorizontalOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IToolTipTemplateSettings_adaptor::FromVerticalOffset)->_get_FromVerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} FromVerticalOffset;
	};
	IToolTipTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<IToolTipTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::IToolTipTemplateSettings_adaptor<X> { typedef adapt IToolTipTemplateSettings; };
struct IToolTipTemplateSettings : IToolTipTemplateSettings_raw, generate<IToolTipTemplateSettings> {};

// ToolTipTemplateSettings
template<typename X> struct statics<ToolTipTemplateSettings, X> : X {
	typedef typename X::root_type ToolTipTemplateSettings;
};
struct ToolTipTemplateSettings : generate<ToolTipTemplateSettings> {};

// ISettingsFlyoutTemplateSettings
struct ISettingsFlyoutTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_HeaderBackground(Media::Brush* *value);
	virtual STDMETHODIMP _get_HeaderForeground(Media::Brush* *value);
	virtual STDMETHODIMP _get_BorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _get_BorderThickness(Thickness *value);
	virtual STDMETHODIMP _get_IconSource(Media::ImageSource* *value);
	virtual STDMETHODIMP _get_ContentTransitions(Media::Animation::TransitionCollection* *value);
};
template<typename X> struct ISettingsFlyoutTemplateSettings_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ISettingsFlyoutTemplateSettings_adaptor::BorderBrush)->_get_BorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
		} BorderBrush;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&ISettingsFlyoutTemplateSettings_adaptor::BorderThickness)->_get_BorderThickness(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
		} BorderThickness;
		struct : property {
			ptr<Media::Animation::TransitionCollection> get() { Media::Animation::TransitionCollection* value; hrcheck(enc(&ISettingsFlyoutTemplateSettings_adaptor::ContentTransitions)->_get_ContentTransitions(&value)); return from_abi(value); }
			ptr<Media::Animation::TransitionCollection> operator()() { return get(); }
			operator ptr<Media::Animation::TransitionCollection> () { return get(); }
			ptr<Media::Animation::TransitionCollection> operator->() { return get(); }
		} ContentTransitions;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ISettingsFlyoutTemplateSettings_adaptor::HeaderBackground)->_get_HeaderBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
		} HeaderBackground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ISettingsFlyoutTemplateSettings_adaptor::HeaderForeground)->_get_HeaderForeground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
		} HeaderForeground;
		struct : property {
			ptr<Media::ImageSource> get() { Media::ImageSource* value; hrcheck(enc(&ISettingsFlyoutTemplateSettings_adaptor::IconSource)->_get_IconSource(&value)); return from_abi(value); }
			ptr<Media::ImageSource> operator()() { return get(); }
			operator ptr<Media::ImageSource> () { return get(); }
			ptr<Media::ImageSource> operator->() { return get(); }
		} IconSource;
	};
	ISettingsFlyoutTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<ISettingsFlyoutTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::ISettingsFlyoutTemplateSettings_adaptor<X> { typedef adapt ISettingsFlyoutTemplateSettings; };
struct ISettingsFlyoutTemplateSettings : ISettingsFlyoutTemplateSettings_raw, generate<ISettingsFlyoutTemplateSettings> {};

// SettingsFlyoutTemplateSettings
template<typename X> struct statics<SettingsFlyoutTemplateSettings, X> : X {
	typedef typename X::root_type SettingsFlyoutTemplateSettings;
};
struct SettingsFlyoutTemplateSettings : generate<SettingsFlyoutTemplateSettings> {};

// IProgressBarTemplateSettings
struct IProgressBarTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_EllipseDiameter(double *value);
	virtual STDMETHODIMP _get_EllipseOffset(double *value);
	virtual STDMETHODIMP _get_EllipseAnimationWellPosition(double *value);
	virtual STDMETHODIMP _get_EllipseAnimationEndPosition(double *value);
	virtual STDMETHODIMP _get_ContainerAnimationStartPosition(double *value);
	virtual STDMETHODIMP _get_ContainerAnimationEndPosition(double *value);
	virtual STDMETHODIMP _get_IndicatorLengthDelta(double *value);
};
template<typename X> struct IProgressBarTemplateSettings_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IProgressBarTemplateSettings_adaptor::ContainerAnimationEndPosition)->_get_ContainerAnimationEndPosition(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ContainerAnimationEndPosition;
		struct : property {
			double get() { double value; hrcheck(enc(&IProgressBarTemplateSettings_adaptor::ContainerAnimationStartPosition)->_get_ContainerAnimationStartPosition(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ContainerAnimationStartPosition;
		struct : property {
			double get() { double value; hrcheck(enc(&IProgressBarTemplateSettings_adaptor::EllipseAnimationEndPosition)->_get_EllipseAnimationEndPosition(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} EllipseAnimationEndPosition;
		struct : property {
			double get() { double value; hrcheck(enc(&IProgressBarTemplateSettings_adaptor::EllipseAnimationWellPosition)->_get_EllipseAnimationWellPosition(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} EllipseAnimationWellPosition;
		struct : property {
			double get() { double value; hrcheck(enc(&IProgressBarTemplateSettings_adaptor::EllipseDiameter)->_get_EllipseDiameter(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} EllipseDiameter;
		struct : property {
			double get() { double value; hrcheck(enc(&IProgressBarTemplateSettings_adaptor::EllipseOffset)->_get_EllipseOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} EllipseOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IProgressBarTemplateSettings_adaptor::IndicatorLengthDelta)->_get_IndicatorLengthDelta(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} IndicatorLengthDelta;
	};
	IProgressBarTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<IProgressBarTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::IProgressBarTemplateSettings_adaptor<X> { typedef adapt IProgressBarTemplateSettings; };
struct IProgressBarTemplateSettings : IProgressBarTemplateSettings_raw, generate<IProgressBarTemplateSettings> {};

// ProgressBarTemplateSettings
template<typename X> struct statics<ProgressBarTemplateSettings, X> : X {
	typedef typename X::root_type ProgressBarTemplateSettings;
};
struct ProgressBarTemplateSettings : generate<ProgressBarTemplateSettings> {};

// IToggleSwitchTemplateSettings
struct IToggleSwitchTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_KnobCurrentToOnOffset(double *value);
	virtual STDMETHODIMP _get_KnobCurrentToOffOffset(double *value);
	virtual STDMETHODIMP _get_KnobOnToOffOffset(double *value);
	virtual STDMETHODIMP _get_KnobOffToOnOffset(double *value);
	virtual STDMETHODIMP _get_CurtainCurrentToOnOffset(double *value);
	virtual STDMETHODIMP _get_CurtainCurrentToOffOffset(double *value);
	virtual STDMETHODIMP _get_CurtainOnToOffOffset(double *value);
	virtual STDMETHODIMP _get_CurtainOffToOnOffset(double *value);
};
template<typename X> struct IToggleSwitchTemplateSettings_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IToggleSwitchTemplateSettings_adaptor::CurtainCurrentToOffOffset)->_get_CurtainCurrentToOffOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} CurtainCurrentToOffOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IToggleSwitchTemplateSettings_adaptor::CurtainCurrentToOnOffset)->_get_CurtainCurrentToOnOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} CurtainCurrentToOnOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IToggleSwitchTemplateSettings_adaptor::CurtainOffToOnOffset)->_get_CurtainOffToOnOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} CurtainOffToOnOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IToggleSwitchTemplateSettings_adaptor::CurtainOnToOffOffset)->_get_CurtainOnToOffOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} CurtainOnToOffOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IToggleSwitchTemplateSettings_adaptor::KnobCurrentToOffOffset)->_get_KnobCurrentToOffOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} KnobCurrentToOffOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IToggleSwitchTemplateSettings_adaptor::KnobCurrentToOnOffset)->_get_KnobCurrentToOnOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} KnobCurrentToOnOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IToggleSwitchTemplateSettings_adaptor::KnobOffToOnOffset)->_get_KnobOffToOnOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} KnobOffToOnOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IToggleSwitchTemplateSettings_adaptor::KnobOnToOffOffset)->_get_KnobOnToOffOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} KnobOnToOffOffset;
	};
	IToggleSwitchTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<IToggleSwitchTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::IToggleSwitchTemplateSettings_adaptor<X> { typedef adapt IToggleSwitchTemplateSettings; };
struct IToggleSwitchTemplateSettings : IToggleSwitchTemplateSettings_raw, generate<IToggleSwitchTemplateSettings> {};

// ToggleSwitchTemplateSettings
template<typename X> struct statics<ToggleSwitchTemplateSettings, X> : X {
	typedef typename X::root_type ToggleSwitchTemplateSettings;
};
struct ToggleSwitchTemplateSettings : generate<ToggleSwitchTemplateSettings> {};

// IProgressRingTemplateSettings
struct IProgressRingTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_EllipseDiameter(double *value);
	virtual STDMETHODIMP _get_EllipseOffset(Thickness *value);
	virtual STDMETHODIMP _get_MaxSideLength(double *value);
};
template<typename X> struct IProgressRingTemplateSettings_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IProgressRingTemplateSettings_adaptor::EllipseDiameter)->_get_EllipseDiameter(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} EllipseDiameter;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IProgressRingTemplateSettings_adaptor::EllipseOffset)->_get_EllipseOffset(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
		} EllipseOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IProgressRingTemplateSettings_adaptor::MaxSideLength)->_get_MaxSideLength(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} MaxSideLength;
	};
	IProgressRingTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<IProgressRingTemplateSettings, X> : Windows::UI::Xaml::Controls::Primitives::IProgressRingTemplateSettings_adaptor<X> { typedef adapt IProgressRingTemplateSettings; };
struct IProgressRingTemplateSettings : IProgressRingTemplateSettings_raw, generate<IProgressRingTemplateSettings> {};

// ProgressRingTemplateSettings
template<typename X> struct statics<ProgressRingTemplateSettings, X> : X {
	typedef typename X::root_type ProgressRingTemplateSettings;
};
struct ProgressRingTemplateSettings : generate<ProgressRingTemplateSettings> {};

// IGeneratorPositionHelperStatics
struct IGeneratorPositionHelperStatics : IInspectable {
	virtual STDMETHODIMP _FromIndexAndOffset(int index, int offset, GeneratorPosition *returnValue);
};

// IGeneratorPositionHelper
struct IGeneratorPositionHelper : IInspectable, generate<IGeneratorPositionHelper> {};

// GeneratorPositionHelper
template<typename> struct GeneratorPositionHelper_statics {
	static GeneratorPosition FromIndexAndOffset(int index, int offset) { GeneratorPosition returnValue; hrcheck(get_activation_factory<GeneratorPositionHelper, IGeneratorPositionHelperStatics>()->_FromIndexAndOffset(index, offset, &returnValue)); return returnValue; }
};

template<typename X> struct statics<GeneratorPositionHelper, X> : X, Windows::UI::Xaml::Controls::Primitives::GeneratorPositionHelper_statics<void> {
	typedef typename X::root_type GeneratorPositionHelper;
};
struct GeneratorPositionHelper : generate<GeneratorPositionHelper> {};

// DragCompletedEventHandler
struct DragCompletedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, DragCompletedEventArgs* e) = 0;
};

// DragDeltaEventHandler
struct DragDeltaEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, DragDeltaEventArgs* e) = 0;
};

// DragStartedEventHandler
struct DragStartedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, DragStartedEventArgs* e) = 0;
};

// ItemsChangedEventHandler
struct ItemsChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, ItemsChangedEventArgs* e) = 0;
};

// IItemsChangedEventArgs
struct IItemsChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Action(int *value);
	virtual STDMETHODIMP _get_Position(GeneratorPosition *value);
	virtual STDMETHODIMP _get_OldPosition(GeneratorPosition *value);
	virtual STDMETHODIMP _get_ItemCount(int *value);
	virtual STDMETHODIMP _get_ItemUICount(int *value);
};
template<typename X> struct IItemsChangedEventArgs_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IItemsChangedEventArgs_adaptor::Action)->_get_Action(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} Action;
		struct : property {
			int get() { int value; hrcheck(enc(&IItemsChangedEventArgs_adaptor::ItemCount)->_get_ItemCount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} ItemCount;
		struct : property {
			int get() { int value; hrcheck(enc(&IItemsChangedEventArgs_adaptor::ItemUICount)->_get_ItemUICount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} ItemUICount;
		struct : property {
			GeneratorPosition get() { GeneratorPosition value; hrcheck(enc(&IItemsChangedEventArgs_adaptor::OldPosition)->_get_OldPosition(&value)); return value; }
			GeneratorPosition operator()() { return get(); }
			operator GeneratorPosition () { return get(); }
		} OldPosition;
		struct : property {
			GeneratorPosition get() { GeneratorPosition value; hrcheck(enc(&IItemsChangedEventArgs_adaptor::Position)->_get_Position(&value)); return value; }
			GeneratorPosition operator()() { return get(); }
			operator GeneratorPosition () { return get(); }
		} Position;
	};
	IItemsChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IItemsChangedEventArgs, X> : Windows::UI::Xaml::Controls::Primitives::IItemsChangedEventArgs_adaptor<X> { typedef adapt IItemsChangedEventArgs; };
struct IItemsChangedEventArgs : IItemsChangedEventArgs_raw, generate<IItemsChangedEventArgs> {};

// ItemsChangedEventArgs
template<typename X> struct statics<ItemsChangedEventArgs, X> : X {
	typedef typename X::root_type ItemsChangedEventArgs;
};
struct ItemsChangedEventArgs : generate<ItemsChangedEventArgs> {};

// RangeBaseValueChangedEventHandler
struct RangeBaseValueChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, RangeBaseValueChangedEventArgs* e) = 0;
};

// ScrollEventHandler
struct ScrollEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, ScrollEventArgs* e) = 0;
};

// ILayoutInformationStatics2
struct ILayoutInformationStatics2 : IInspectable {
	virtual STDMETHODIMP _GetAvailableSize(UIElement* element, Foundation::Size *availableSize);
};

// ILayoutInformationStatics
struct ILayoutInformationStatics : IInspectable {
	virtual STDMETHODIMP _GetLayoutExceptionElement(IInspectable* dispatcher, UIElement* *element);
	virtual STDMETHODIMP _GetLayoutSlot(FrameworkElement* element, Foundation::Rect *slot);
};

// ILayoutInformation
struct ILayoutInformation : IInspectable, generate<ILayoutInformation> {};

// LayoutInformation
template<typename> struct LayoutInformation_statics {
	static Foundation::Size GetAvailableSize(pptr<UIElement> element) { Foundation::Size availableSize; hrcheck(get_activation_factory<LayoutInformation, ILayoutInformationStatics2>()->_GetAvailableSize(element, &availableSize)); return availableSize; }
	static ptr<UIElement> GetLayoutExceptionElement(object_ref dispatcher) { UIElement* element; hrcheck(get_activation_factory<LayoutInformation, ILayoutInformationStatics>()->_GetLayoutExceptionElement(dispatcher, &element)); return from_abi(element); }
	static Foundation::Rect GetLayoutSlot(pptr<FrameworkElement> element) { Foundation::Rect slot; hrcheck(get_activation_factory<LayoutInformation, ILayoutInformationStatics>()->_GetLayoutSlot(element, &slot)); return slot; }
};

template<typename X> struct statics<LayoutInformation, X> : X, Windows::UI::Xaml::Controls::Primitives::LayoutInformation_statics<void> {
	typedef typename X::root_type LayoutInformation;
};
struct LayoutInformation : generate<LayoutInformation> {};
}

// IDragItemsCompletedEventArgs
struct IDragItemsCompletedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Items(Foundation::Collections::IVectorView<IInspectable*>* *value);
	virtual STDMETHODIMP _get_DropResult(ApplicationModel::DataTransfer::DataPackageOperation *value);
};
template<typename X> struct IDragItemsCompletedEventArgs_adaptor : X {
	union {
		struct : property {
			ApplicationModel::DataTransfer::DataPackageOperation get() { ApplicationModel::DataTransfer::DataPackageOperation value; hrcheck(enc(&IDragItemsCompletedEventArgs_adaptor::DropResult)->_get_DropResult(&value)); return value; }
			ApplicationModel::DataTransfer::DataPackageOperation operator()() { return get(); }
			operator ApplicationModel::DataTransfer::DataPackageOperation () { return get(); }
		} DropResult;
		struct : property {
			ptr<Foundation::Collections::IVectorView<object>> get() { Foundation::Collections::IVectorView<IInspectable*>* value; hrcheck(enc(&IDragItemsCompletedEventArgs_adaptor::Items)->_get_Items(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<object>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<object>> operator->() { return get(); }
		} Items;
	};
	IDragItemsCompletedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDragItemsCompletedEventArgs, X> : Windows::UI::Xaml::Controls::IDragItemsCompletedEventArgs_adaptor<X> { typedef adapt IDragItemsCompletedEventArgs; };
struct IDragItemsCompletedEventArgs : IDragItemsCompletedEventArgs_raw, generate<IDragItemsCompletedEventArgs> {};

// DragItemsCompletedEventArgs
template<typename X> struct statics<DragItemsCompletedEventArgs, X> : X {
	typedef typename X::root_type DragItemsCompletedEventArgs;
};
struct DragItemsCompletedEventArgs : generate<DragItemsCompletedEventArgs> {};

// IDragItemsStartingEventArgs
struct IDragItemsStartingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Cancel(bool *value);
	virtual STDMETHODIMP _put_Cancel(bool value);
	virtual STDMETHODIMP _get_Items(Foundation::Collections::IVector<IInspectable*>* *value);
	virtual STDMETHODIMP _get_Data(ApplicationModel::DataTransfer::DataPackage* *value);
};
template<typename X> struct IDragItemsStartingEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDragItemsStartingEventArgs_adaptor::Cancel)->_get_Cancel(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDragItemsStartingEventArgs_adaptor::Cancel)->_put_Cancel(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Cancel;
		struct : property {
			ptr<ApplicationModel::DataTransfer::DataPackage> get() { ApplicationModel::DataTransfer::DataPackage* value; hrcheck(enc(&IDragItemsStartingEventArgs_adaptor::Data)->_get_Data(&value)); return from_abi(value); }
			ptr<ApplicationModel::DataTransfer::DataPackage> operator()() { return get(); }
			operator ptr<ApplicationModel::DataTransfer::DataPackage> () { return get(); }
			ptr<ApplicationModel::DataTransfer::DataPackage> operator->() { return get(); }
		} Data;
		struct : property {
			ptr<Foundation::Collections::IVector<object>> get() { Foundation::Collections::IVector<IInspectable*>* value; hrcheck(enc(&IDragItemsStartingEventArgs_adaptor::Items)->_get_Items(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<object>> () { return get(); }
			ptr<Foundation::Collections::IVector<object>> operator->() { return get(); }
		} Items;
	};
	IDragItemsStartingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDragItemsStartingEventArgs, X> : Windows::UI::Xaml::Controls::IDragItemsStartingEventArgs_adaptor<X> { typedef adapt IDragItemsStartingEventArgs; };
struct IDragItemsStartingEventArgs : IDragItemsStartingEventArgs_raw, generate<IDragItemsStartingEventArgs> {};

// IGroupStyle
struct IGroupStyle_raw : IInspectable {
	virtual STDMETHODIMP _get_Panel(ItemsPanelTemplate* *value);
	virtual STDMETHODIMP _put_Panel(ItemsPanelTemplate* value);
	virtual STDMETHODIMP _get_ContainerStyle(Style* *value);
	virtual STDMETHODIMP _put_ContainerStyle(Style* value);
	virtual STDMETHODIMP _get_ContainerStyleSelector(StyleSelector* *value);
	virtual STDMETHODIMP _put_ContainerStyleSelector(StyleSelector* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_HeaderTemplateSelector(DataTemplateSelector* *value);
	virtual STDMETHODIMP _put_HeaderTemplateSelector(DataTemplateSelector* value);
	virtual STDMETHODIMP _get_HidesIfEmpty(bool *value);
	virtual STDMETHODIMP _put_HidesIfEmpty(bool value);
};
template<typename X> struct IGroupStyle_adaptor : X {
	union {
		struct : property {
			ptr<Style> get() { Style* value; hrcheck(enc(&IGroupStyle_adaptor::ContainerStyle)->_get_ContainerStyle(&value)); return from_abi(value); }
			ptr<Style> operator()() { return get(); }
			operator ptr<Style> () { return get(); }
			ptr<Style> operator->() { return get(); }
			void put(pptr<Style> value) { hrcheck(enc(&IGroupStyle_adaptor::ContainerStyle)->_put_ContainerStyle(value)); }
			void operator=(pptr<Style> value) { put(value); }
			void operator()(pptr<Style> value) { put(value); }
		} ContainerStyle;
		struct : property {
			ptr<StyleSelector> get() { StyleSelector* value; hrcheck(enc(&IGroupStyle_adaptor::ContainerStyleSelector)->_get_ContainerStyleSelector(&value)); return from_abi(value); }
			ptr<StyleSelector> operator()() { return get(); }
			operator ptr<StyleSelector> () { return get(); }
			ptr<StyleSelector> operator->() { return get(); }
			void put(pptr<StyleSelector> value) { hrcheck(enc(&IGroupStyle_adaptor::ContainerStyleSelector)->_put_ContainerStyleSelector(value)); }
			void operator=(pptr<StyleSelector> value) { put(value); }
			void operator()(pptr<StyleSelector> value) { put(value); }
		} ContainerStyleSelector;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IGroupStyle_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IGroupStyle_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
		struct : property {
			ptr<DataTemplateSelector> get() { DataTemplateSelector* value; hrcheck(enc(&IGroupStyle_adaptor::HeaderTemplateSelector)->_get_HeaderTemplateSelector(&value)); return from_abi(value); }
			ptr<DataTemplateSelector> operator()() { return get(); }
			operator ptr<DataTemplateSelector> () { return get(); }
			ptr<DataTemplateSelector> operator->() { return get(); }
			void put(pptr<DataTemplateSelector> value) { hrcheck(enc(&IGroupStyle_adaptor::HeaderTemplateSelector)->_put_HeaderTemplateSelector(value)); }
			void operator=(pptr<DataTemplateSelector> value) { put(value); }
			void operator()(pptr<DataTemplateSelector> value) { put(value); }
		} HeaderTemplateSelector;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGroupStyle_adaptor::HidesIfEmpty)->_get_HidesIfEmpty(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IGroupStyle_adaptor::HidesIfEmpty)->_put_HidesIfEmpty(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} HidesIfEmpty;
		struct : property {
			ptr<ItemsPanelTemplate> get() { ItemsPanelTemplate* value; hrcheck(enc(&IGroupStyle_adaptor::Panel)->_get_Panel(&value)); return from_abi(value); }
			ptr<ItemsPanelTemplate> operator()() { return get(); }
			operator ptr<ItemsPanelTemplate> () { return get(); }
			ptr<ItemsPanelTemplate> operator->() { return get(); }
			void put(pptr<ItemsPanelTemplate> value) { hrcheck(enc(&IGroupStyle_adaptor::Panel)->_put_Panel(value)); }
			void operator=(pptr<ItemsPanelTemplate> value) { put(value); }
			void operator()(pptr<ItemsPanelTemplate> value) { put(value); }
		} Panel;
	};
	IGroupStyle_adaptor() {}
};
template<typename X> struct adapt<IGroupStyle, X> : Windows::UI::Xaml::Controls::IGroupStyle_adaptor<X> { typedef adapt IGroupStyle; };
struct IGroupStyle : IGroupStyle_raw, generate<IGroupStyle> {};

// IStyleSelectorFactory
struct IStyleSelectorFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, StyleSelector* *instance);
};

// IStyleSelectorOverrides
struct IStyleSelectorOverrides_raw : IInspectable {
	virtual STDMETHODIMP _SelectStyleCore(IInspectable* item, DependencyObject* container, Style* *returnValue) = 0;
};
template<typename X> struct IStyleSelectorOverrides_adaptor : X {
	ptr<Style> SelectStyleCore(object_ref item, pptr<DependencyObject> container) { Style* returnValue; hrcheck(X::get()->_SelectStyleCore(item, container, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IStyleSelectorOverrides, X> : Windows::UI::Xaml::Controls::IStyleSelectorOverrides_adaptor<X> { typedef adapt IStyleSelectorOverrides; };
template<typename X> struct IStyleSelectorOverrides_unadaptor : X {
	STDMETHODIMP _SelectStyleCore(IInspectable* item, DependencyObject* container, Style* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->SelectStyleCore(item, container)); }); }
};
template<typename X> struct unadapt<IStyleSelectorOverrides, X> : Windows::UI::Xaml::Controls::IStyleSelectorOverrides_unadaptor<X> {};
struct IStyleSelectorOverrides : IStyleSelectorOverrides_raw, generate<IStyleSelectorOverrides> {};

// IStyleSelector
struct IStyleSelector_raw : IInspectable {
	virtual STDMETHODIMP _SelectStyle(IInspectable* item, DependencyObject* container, Style* *returnValue);
};
template<typename X> struct IStyleSelector_adaptor : X {
	ptr<Style> SelectStyle(object_ref item, pptr<DependencyObject> container) { Style* returnValue; hrcheck(X::get()->_SelectStyle(item, container, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IStyleSelector, X> : Windows::UI::Xaml::Controls::IStyleSelector_adaptor<X> { typedef adapt IStyleSelector; };
struct IStyleSelector : IStyleSelector_raw, generate<IStyleSelector> {};

// StyleSelector
template<typename> struct StyleSelector_statics {
	static StyleSelector *activate(object_ref outer, IInspectable* *inner) { StyleSelector *instance; hrcheck(get_activation_factory<StyleSelector, IStyleSelectorFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<StyleSelector, X> : X, Windows::UI::Xaml::Controls::StyleSelector_statics<void> {
	using Windows::UI::Xaml::Controls::StyleSelector_statics<void>::activate;
	typedef typename X::root_type StyleSelector;
};
struct StyleSelector : generate<StyleSelector> {};

// IGroupStyleFactory
struct IGroupStyleFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, GroupStyle* *instance);
};

// IGroupStyle2
struct IGroupStyle2_raw : IInspectable {
	virtual STDMETHODIMP _get_HeaderContainerStyle(Style* *value);
	virtual STDMETHODIMP _put_HeaderContainerStyle(Style* value);
};
template<typename X> struct IGroupStyle2_adaptor : X {
	union {
		struct : property {
			ptr<Style> get() { Style* value; hrcheck(enc(&IGroupStyle2_adaptor::HeaderContainerStyle)->_get_HeaderContainerStyle(&value)); return from_abi(value); }
			ptr<Style> operator()() { return get(); }
			operator ptr<Style> () { return get(); }
			ptr<Style> operator->() { return get(); }
			void put(pptr<Style> value) { hrcheck(enc(&IGroupStyle2_adaptor::HeaderContainerStyle)->_put_HeaderContainerStyle(value)); }
			void operator=(pptr<Style> value) { put(value); }
			void operator()(pptr<Style> value) { put(value); }
		} HeaderContainerStyle;
	};
	IGroupStyle2_adaptor() {}
};
template<typename X> struct adapt<IGroupStyle2, X> : Windows::UI::Xaml::Controls::IGroupStyle2_adaptor<X> { typedef adapt IGroupStyle2; };
struct IGroupStyle2 : IGroupStyle2_raw, generate<IGroupStyle2> {};

// GroupStyle
template<typename> struct GroupStyle_statics {
	static GroupStyle *activate(object_ref outer, IInspectable* *inner) { GroupStyle *instance; hrcheck(get_activation_factory<GroupStyle, IGroupStyleFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<GroupStyle, X> : X, Windows::UI::Xaml::Controls::GroupStyle_statics<void> {
	using Windows::UI::Xaml::Controls::GroupStyle_statics<void>::activate;
	typedef typename X::root_type GroupStyle;
};
struct GroupStyle : generate<GroupStyle> {};

// IGroupStyleSelector
struct IGroupStyleSelector_raw : IInspectable {
	virtual STDMETHODIMP _SelectGroupStyle(IInspectable* group, unsigned level, GroupStyle* *returnValue);
};
template<typename X> struct IGroupStyleSelector_adaptor : X {
	ptr<GroupStyle> SelectGroupStyle(object_ref group, unsigned level) { GroupStyle* returnValue; hrcheck(X::get()->_SelectGroupStyle(group, level, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IGroupStyleSelector, X> : Windows::UI::Xaml::Controls::IGroupStyleSelector_adaptor<X> { typedef adapt IGroupStyleSelector; };
struct IGroupStyleSelector : IGroupStyleSelector_raw, generate<IGroupStyleSelector> {};

// IGroupStyleSelectorOverrides
struct IGroupStyleSelectorOverrides_raw : IInspectable {
	virtual STDMETHODIMP _SelectGroupStyleCore(IInspectable* group, unsigned level, GroupStyle* *returnValue) = 0;
};
template<typename X> struct IGroupStyleSelectorOverrides_adaptor : X {
	ptr<GroupStyle> SelectGroupStyleCore(object_ref group, unsigned level) { GroupStyle* returnValue; hrcheck(X::get()->_SelectGroupStyleCore(group, level, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IGroupStyleSelectorOverrides, X> : Windows::UI::Xaml::Controls::IGroupStyleSelectorOverrides_adaptor<X> { typedef adapt IGroupStyleSelectorOverrides; };
template<typename X> struct IGroupStyleSelectorOverrides_unadaptor : X {
	STDMETHODIMP _SelectGroupStyleCore(IInspectable* group, unsigned level, GroupStyle* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->SelectGroupStyleCore(group, level)); }); }
};
template<typename X> struct unadapt<IGroupStyleSelectorOverrides, X> : Windows::UI::Xaml::Controls::IGroupStyleSelectorOverrides_unadaptor<X> {};
struct IGroupStyleSelectorOverrides : IGroupStyleSelectorOverrides_raw, generate<IGroupStyleSelectorOverrides> {};

// IGroupStyleSelectorFactory
struct IGroupStyleSelectorFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, GroupStyleSelector* *instance);
};

// GroupStyleSelector
template<typename> struct GroupStyleSelector_statics {
	static GroupStyleSelector *activate(object_ref outer, IInspectable* *inner) { GroupStyleSelector *instance; hrcheck(get_activation_factory<GroupStyleSelector, IGroupStyleSelectorFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<GroupStyleSelector, X> : X, Windows::UI::Xaml::Controls::GroupStyleSelector_statics<void> {
	using Windows::UI::Xaml::Controls::GroupStyleSelector_statics<void>::activate;
	typedef typename X::root_type GroupStyleSelector;
};
struct GroupStyleSelector : generate<GroupStyleSelector> {};

// IHandwritingPanelClosedEventArgs
struct IHandwritingPanelClosedEventArgs : IInspectable, generate<IHandwritingPanelClosedEventArgs> {};

// HandwritingPanelClosedEventArgs
template<typename X> struct statics<HandwritingPanelClosedEventArgs, X> : X {
	typedef typename X::root_type HandwritingPanelClosedEventArgs;
};
struct HandwritingPanelClosedEventArgs : generate<HandwritingPanelClosedEventArgs> {};

// IHandwritingPanelOpenedEventArgs
struct IHandwritingPanelOpenedEventArgs : IInspectable, generate<IHandwritingPanelOpenedEventArgs> {};

// HandwritingPanelOpenedEventArgs
template<typename X> struct statics<HandwritingPanelOpenedEventArgs, X> : X {
	typedef typename X::root_type HandwritingPanelOpenedEventArgs;
};
struct HandwritingPanelOpenedEventArgs : generate<HandwritingPanelOpenedEventArgs> {};

// IIsTextTrimmedChangedEventArgs
struct IIsTextTrimmedChangedEventArgs : IInspectable, generate<IIsTextTrimmedChangedEventArgs> {};

// IsTextTrimmedChangedEventArgs
template<typename X> struct statics<IsTextTrimmedChangedEventArgs, X> : X {
	typedef typename X::root_type IsTextTrimmedChangedEventArgs;
};
struct IsTextTrimmedChangedEventArgs : generate<IsTextTrimmedChangedEventArgs> {};

// ItemCollection
template<typename X> struct statics<ItemCollection, X> : X {
	typedef typename X::root_type ItemCollection;
};
struct ItemCollection : generate<ItemCollection> {};

// IItemContainerGenerator
struct IItemContainerGenerator_raw : IInspectable {
	virtual STDMETHODIMP _add_ItemsChanged(Primitives::ItemsChangedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ItemsChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _ItemFromContainer(DependencyObject* container, IInspectable* *returnValue);
	virtual STDMETHODIMP _ContainerFromItem(IInspectable* item, DependencyObject* *returnValue);
	virtual STDMETHODIMP _IndexFromContainer(DependencyObject* container, int *returnValue);
	virtual STDMETHODIMP _ContainerFromIndex(int index, DependencyObject* *returnValue);
	virtual STDMETHODIMP _GetItemContainerGeneratorForPanel(Panel* panel, ItemContainerGenerator* *returnValue);
	virtual STDMETHODIMP _StartAt(Primitives::GeneratorPosition position, Primitives::GeneratorDirection direction, bool allowStartAtRealizedItem);
	virtual STDMETHODIMP _Stop();
	virtual STDMETHODIMP _GenerateNext(bool *isNewlyRealized, DependencyObject* *returnValue);
	virtual STDMETHODIMP _PrepareItemContainer(DependencyObject* container);
	virtual STDMETHODIMP _RemoveAll();
	virtual STDMETHODIMP _Remove(Primitives::GeneratorPosition position, int count);
	virtual STDMETHODIMP _GeneratorPositionFromIndex(int itemIndex, Primitives::GeneratorPosition *returnValue);
	virtual STDMETHODIMP _IndexFromGeneratorPosition(Primitives::GeneratorPosition position, int *returnValue);
	virtual STDMETHODIMP _Recycle(Primitives::GeneratorPosition position, int count);
};
template<typename X> struct IItemContainerGenerator_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Primitives::ItemsChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IItemContainerGenerator_adaptor::ItemsChanged)->_add_ItemsChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IItemContainerGenerator_adaptor::ItemsChanged)->_remove_ItemsChanged(token)); }
		} ItemsChanged;
	};
	object ItemFromContainer(pptr<DependencyObject> container) { IInspectable* returnValue; hrcheck(X::get()->_ItemFromContainer(container, &returnValue)); return from_abi(returnValue); }
	ptr<DependencyObject> ContainerFromItem(object_ref item) { DependencyObject* returnValue; hrcheck(X::get()->_ContainerFromItem(item, &returnValue)); return from_abi(returnValue); }
	int IndexFromContainer(pptr<DependencyObject> container) { int returnValue; hrcheck(X::get()->_IndexFromContainer(container, &returnValue)); return returnValue; }
	ptr<DependencyObject> ContainerFromIndex(int index) { DependencyObject* returnValue; hrcheck(X::get()->_ContainerFromIndex(index, &returnValue)); return from_abi(returnValue); }
	ptr<ItemContainerGenerator> GetItemContainerGeneratorForPanel(pptr<Panel> panel) { ItemContainerGenerator* returnValue; hrcheck(X::get()->_GetItemContainerGeneratorForPanel(panel, &returnValue)); return from_abi(returnValue); }
	void StartAt(const Primitives::GeneratorPosition& position, Primitives::GeneratorDirection direction, bool allowStartAtRealizedItem) { hrcheck(X::get()->_StartAt(position, direction, allowStartAtRealizedItem)); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	ptr<DependencyObject> GenerateNext(bool *isNewlyRealized) { DependencyObject* returnValue; hrcheck(X::get()->_GenerateNext(isNewlyRealized, &returnValue)); return from_abi(returnValue); }
	void PrepareItemContainer(pptr<DependencyObject> container) { hrcheck(X::get()->_PrepareItemContainer(container)); }
	void RemoveAll() { hrcheck(X::get()->_RemoveAll()); }
	void Remove(const Primitives::GeneratorPosition& position, int count) { hrcheck(X::get()->_Remove(position, count)); }
	Primitives::GeneratorPosition GeneratorPositionFromIndex(int itemIndex) { Primitives::GeneratorPosition returnValue; hrcheck(X::get()->_GeneratorPositionFromIndex(itemIndex, &returnValue)); return returnValue; }
	int IndexFromGeneratorPosition(const Primitives::GeneratorPosition& position) { int returnValue; hrcheck(X::get()->_IndexFromGeneratorPosition(position, &returnValue)); return returnValue; }
	void Recycle(const Primitives::GeneratorPosition& position, int count) { hrcheck(X::get()->_Recycle(position, count)); }
	IItemContainerGenerator_adaptor() {}
};
template<typename X> struct adapt<IItemContainerGenerator, X> : Windows::UI::Xaml::Controls::IItemContainerGenerator_adaptor<X> { typedef adapt IItemContainerGenerator; };
struct IItemContainerGenerator : IItemContainerGenerator_raw, generate<IItemContainerGenerator> {};

// ItemContainerGenerator
template<typename X> struct statics<ItemContainerGenerator, X> : X {
	typedef typename X::root_type ItemContainerGenerator;
};
struct ItemContainerGenerator : generate<ItemContainerGenerator> {};

// IMediaTransportControlsHelper
struct IMediaTransportControlsHelper : IInspectable, generate<IMediaTransportControlsHelper> {};

// IMediaTransportControlsHelperStatics
struct IMediaTransportControlsHelperStatics : IInspectable {
	virtual STDMETHODIMP _get_DropoutOrderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetDropoutOrder(UIElement* element, Foundation::IReference<int>* *value);
	virtual STDMETHODIMP _SetDropoutOrder(UIElement* element, Foundation::IReference<int>* value);
};

// MediaTransportControlsHelper
template<typename> struct MediaTransportControlsHelper_statics {
	static struct _DropoutOrderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControlsHelper, IMediaTransportControlsHelperStatics>()->_get_DropoutOrderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DropoutOrderProperty;
	static ptr<Foundation::IReference<int>> GetDropoutOrder(pptr<UIElement> element) { Foundation::IReference<int>* value; hrcheck(get_activation_factory<MediaTransportControlsHelper, IMediaTransportControlsHelperStatics>()->_GetDropoutOrder(element, &value)); return from_abi(value); }
	static void SetDropoutOrder(pptr<UIElement> element, pptr<Foundation::IReference<int>> value) { hrcheck(get_activation_factory<MediaTransportControlsHelper, IMediaTransportControlsHelperStatics>()->_SetDropoutOrder(element, to_abi(value))); }
};
template<typename X> typename MediaTransportControlsHelper_statics<X>::_DropoutOrderProperty MediaTransportControlsHelper_statics<X>::DropoutOrderProperty;

template<typename X> struct statics<MediaTransportControlsHelper, X> : X, Windows::UI::Xaml::Controls::MediaTransportControlsHelper_statics<void> {
	typedef typename X::root_type MediaTransportControlsHelper;
};
struct MediaTransportControlsHelper : generate<MediaTransportControlsHelper> {};

// INotifyEventArgs
struct INotifyEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Value(HSTRING *value);
};
template<typename X> struct INotifyEventArgs_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&INotifyEventArgs_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Value;
	};
	INotifyEventArgs_adaptor() {}
};
template<typename X> struct adapt<INotifyEventArgs, X> : Windows::UI::Xaml::Controls::INotifyEventArgs_adaptor<X> { typedef adapt INotifyEventArgs; };
struct INotifyEventArgs : INotifyEventArgs_raw, generate<INotifyEventArgs> {};

// INotifyEventArgs2
struct INotifyEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _get_CallingUri(Foundation::Uri* *value);
};
template<typename X> struct INotifyEventArgs2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&INotifyEventArgs2_adaptor::CallingUri)->_get_CallingUri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} CallingUri;
	};
	INotifyEventArgs2_adaptor() {}
};
template<typename X> struct adapt<INotifyEventArgs2, X> : Windows::UI::Xaml::Controls::INotifyEventArgs2_adaptor<X> { typedef adapt INotifyEventArgs2; };
struct INotifyEventArgs2 : INotifyEventArgs2_raw, generate<INotifyEventArgs2> {};

// IPasswordBoxPasswordChangingEventArgs
struct IPasswordBoxPasswordChangingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_IsContentChanging(bool *value);
};
template<typename X> struct IPasswordBoxPasswordChangingEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPasswordBoxPasswordChangingEventArgs_adaptor::IsContentChanging)->_get_IsContentChanging(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsContentChanging;
	};
	IPasswordBoxPasswordChangingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IPasswordBoxPasswordChangingEventArgs, X> : Windows::UI::Xaml::Controls::IPasswordBoxPasswordChangingEventArgs_adaptor<X> { typedef adapt IPasswordBoxPasswordChangingEventArgs; };
struct IPasswordBoxPasswordChangingEventArgs : IPasswordBoxPasswordChangingEventArgs_raw, generate<IPasswordBoxPasswordChangingEventArgs> {};

// PasswordBoxPasswordChangingEventArgs
template<typename X> struct statics<PasswordBoxPasswordChangingEventArgs, X> : X {
	typedef typename X::root_type PasswordBoxPasswordChangingEventArgs;
};
struct PasswordBoxPasswordChangingEventArgs : generate<PasswordBoxPasswordChangingEventArgs> {};

// IRowDefinitionStatics
struct IRowDefinitionStatics : IInspectable {
	virtual STDMETHODIMP _get_HeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinHeightProperty(DependencyProperty* *value);
};

// IRowDefinition
struct IRowDefinition_raw : IInspectable {
	virtual STDMETHODIMP _get_Height(GridLength *value);
	virtual STDMETHODIMP _put_Height(GridLength value);
	virtual STDMETHODIMP _get_MaxHeight(double *value);
	virtual STDMETHODIMP _put_MaxHeight(double value);
	virtual STDMETHODIMP _get_MinHeight(double *value);
	virtual STDMETHODIMP _put_MinHeight(double value);
	virtual STDMETHODIMP _get_ActualHeight(double *value);
};
template<typename X> struct IRowDefinition_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IRowDefinition_adaptor::ActualHeight)->_get_ActualHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ActualHeight;
		struct : property {
			GridLength get() { GridLength value; hrcheck(enc(&IRowDefinition_adaptor::Height)->_get_Height(&value)); return value; }
			GridLength operator()() { return get(); }
			operator GridLength () { return get(); }
			void put(const GridLength& value) { hrcheck(enc(&IRowDefinition_adaptor::Height)->_put_Height(value)); }
			void operator=(const GridLength& value) { put(value); }
			void operator()(const GridLength& value) { put(value); }
		} Height;
		struct : property {
			double get() { double value; hrcheck(enc(&IRowDefinition_adaptor::MaxHeight)->_get_MaxHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRowDefinition_adaptor::MaxHeight)->_put_MaxHeight(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MaxHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IRowDefinition_adaptor::MinHeight)->_get_MinHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRowDefinition_adaptor::MinHeight)->_put_MinHeight(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MinHeight;
	};
	IRowDefinition_adaptor() {}
};
template<typename X> struct adapt<IRowDefinition, X> : Windows::UI::Xaml::Controls::IRowDefinition_adaptor<X> { typedef adapt IRowDefinition; };
struct IRowDefinition : IRowDefinition_raw, generate<IRowDefinition> {};

// RowDefinition
template<typename> struct RowDefinition_statics {
	static struct _HeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RowDefinition, IRowDefinitionStatics>()->_get_HeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeightProperty;
	static struct _MaxHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RowDefinition, IRowDefinitionStatics>()->_get_MaxHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxHeightProperty;
	static struct _MinHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RowDefinition, IRowDefinitionStatics>()->_get_MinHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinHeightProperty;
};
template<typename X> typename RowDefinition_statics<X>::_HeightProperty RowDefinition_statics<X>::HeightProperty;
template<typename X> typename RowDefinition_statics<X>::_MaxHeightProperty RowDefinition_statics<X>::MaxHeightProperty;
template<typename X> typename RowDefinition_statics<X>::_MinHeightProperty RowDefinition_statics<X>::MinHeightProperty;

template<typename X> struct statics<RowDefinition, X> : X, Windows::UI::Xaml::Controls::RowDefinition_statics<void> {
	typedef typename X::root_type RowDefinition;
};
struct RowDefinition : generate<RowDefinition> {};

// RowDefinitionCollection
template<typename X> struct statics<RowDefinitionCollection, X> : X {
	typedef typename X::root_type RowDefinitionCollection;
};
struct RowDefinitionCollection : generate<RowDefinitionCollection> {};

// ISemanticZoomLocation
struct ISemanticZoomLocation_raw : IInspectable {
	virtual STDMETHODIMP _get_Item(IInspectable* *value);
	virtual STDMETHODIMP _put_Item(IInspectable* value);
	virtual STDMETHODIMP _get_Bounds(Foundation::Rect *value);
	virtual STDMETHODIMP _put_Bounds(Foundation::Rect value);
};
template<typename X> struct ISemanticZoomLocation_adaptor : X {
	union {
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&ISemanticZoomLocation_adaptor::Bounds)->_get_Bounds(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
			void put(const Foundation::Rect& value) { hrcheck(enc(&ISemanticZoomLocation_adaptor::Bounds)->_put_Bounds(value)); }
			void operator=(const Foundation::Rect& value) { put(value); }
			void operator()(const Foundation::Rect& value) { put(value); }
		} Bounds;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ISemanticZoomLocation_adaptor::Item)->_get_Item(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&ISemanticZoomLocation_adaptor::Item)->_put_Item(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Item;
	};
	ISemanticZoomLocation_adaptor() {}
};
template<typename X> struct adapt<ISemanticZoomLocation, X> : Windows::UI::Xaml::Controls::ISemanticZoomLocation_adaptor<X> { typedef adapt ISemanticZoomLocation; };
struct ISemanticZoomLocation : ISemanticZoomLocation_raw, generate<ISemanticZoomLocation> {};

// ISemanticZoomViewChangedEventArgs
struct ISemanticZoomViewChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_IsSourceZoomedInView(bool *value);
	virtual STDMETHODIMP _put_IsSourceZoomedInView(bool value);
	virtual STDMETHODIMP _get_SourceItem(SemanticZoomLocation* *value);
	virtual STDMETHODIMP _put_SourceItem(SemanticZoomLocation* value);
	virtual STDMETHODIMP _get_DestinationItem(SemanticZoomLocation* *value);
	virtual STDMETHODIMP _put_DestinationItem(SemanticZoomLocation* value);
};
template<typename X> struct ISemanticZoomViewChangedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<SemanticZoomLocation> get() { SemanticZoomLocation* value; hrcheck(enc(&ISemanticZoomViewChangedEventArgs_adaptor::DestinationItem)->_get_DestinationItem(&value)); return from_abi(value); }
			ptr<SemanticZoomLocation> operator()() { return get(); }
			operator ptr<SemanticZoomLocation> () { return get(); }
			ptr<SemanticZoomLocation> operator->() { return get(); }
			void put(pptr<SemanticZoomLocation> value) { hrcheck(enc(&ISemanticZoomViewChangedEventArgs_adaptor::DestinationItem)->_put_DestinationItem(value)); }
			void operator=(pptr<SemanticZoomLocation> value) { put(value); }
			void operator()(pptr<SemanticZoomLocation> value) { put(value); }
		} DestinationItem;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISemanticZoomViewChangedEventArgs_adaptor::IsSourceZoomedInView)->_get_IsSourceZoomedInView(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISemanticZoomViewChangedEventArgs_adaptor::IsSourceZoomedInView)->_put_IsSourceZoomedInView(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSourceZoomedInView;
		struct : property {
			ptr<SemanticZoomLocation> get() { SemanticZoomLocation* value; hrcheck(enc(&ISemanticZoomViewChangedEventArgs_adaptor::SourceItem)->_get_SourceItem(&value)); return from_abi(value); }
			ptr<SemanticZoomLocation> operator()() { return get(); }
			operator ptr<SemanticZoomLocation> () { return get(); }
			ptr<SemanticZoomLocation> operator->() { return get(); }
			void put(pptr<SemanticZoomLocation> value) { hrcheck(enc(&ISemanticZoomViewChangedEventArgs_adaptor::SourceItem)->_put_SourceItem(value)); }
			void operator=(pptr<SemanticZoomLocation> value) { put(value); }
			void operator()(pptr<SemanticZoomLocation> value) { put(value); }
		} SourceItem;
	};
	ISemanticZoomViewChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISemanticZoomViewChangedEventArgs, X> : Windows::UI::Xaml::Controls::ISemanticZoomViewChangedEventArgs_adaptor<X> { typedef adapt ISemanticZoomViewChangedEventArgs; };
struct ISemanticZoomViewChangedEventArgs : ISemanticZoomViewChangedEventArgs_raw, generate<ISemanticZoomViewChangedEventArgs> {};

// ITextBoxBeforeTextChangingEventArgs
struct ITextBoxBeforeTextChangingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_NewText(HSTRING *value);
	virtual STDMETHODIMP _get_Cancel(bool *value);
	virtual STDMETHODIMP _put_Cancel(bool value);
};
template<typename X> struct ITextBoxBeforeTextChangingEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextBoxBeforeTextChangingEventArgs_adaptor::Cancel)->_get_Cancel(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextBoxBeforeTextChangingEventArgs_adaptor::Cancel)->_put_Cancel(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Cancel;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITextBoxBeforeTextChangingEventArgs_adaptor::NewText)->_get_NewText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} NewText;
	};
	ITextBoxBeforeTextChangingEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITextBoxBeforeTextChangingEventArgs, X> : Windows::UI::Xaml::Controls::ITextBoxBeforeTextChangingEventArgs_adaptor<X> { typedef adapt ITextBoxBeforeTextChangingEventArgs; };
struct ITextBoxBeforeTextChangingEventArgs : ITextBoxBeforeTextChangingEventArgs_raw, generate<ITextBoxBeforeTextChangingEventArgs> {};

// TextBoxBeforeTextChangingEventArgs
template<typename X> struct statics<TextBoxBeforeTextChangingEventArgs, X> : X {
	typedef typename X::root_type TextBoxBeforeTextChangingEventArgs;
};
struct TextBoxBeforeTextChangingEventArgs : generate<TextBoxBeforeTextChangingEventArgs> {};

// ITextBoxTextChangingEventArgs
struct ITextBoxTextChangingEventArgs : IInspectable, generate<ITextBoxTextChangingEventArgs> {};

// ITextBoxTextChangingEventArgs2
struct ITextBoxTextChangingEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsContentChanging(bool *value);
};
template<typename X> struct ITextBoxTextChangingEventArgs2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextBoxTextChangingEventArgs2_adaptor::IsContentChanging)->_get_IsContentChanging(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsContentChanging;
	};
	ITextBoxTextChangingEventArgs2_adaptor() {}
};
template<typename X> struct adapt<ITextBoxTextChangingEventArgs2, X> : Windows::UI::Xaml::Controls::ITextBoxTextChangingEventArgs2_adaptor<X> { typedef adapt ITextBoxTextChangingEventArgs2; };
struct ITextBoxTextChangingEventArgs2 : ITextBoxTextChangingEventArgs2_raw, generate<ITextBoxTextChangingEventArgs2> {};

// TextBoxTextChangingEventArgs
template<typename X> struct statics<TextBoxTextChangingEventArgs, X> : X {
	typedef typename X::root_type TextBoxTextChangingEventArgs;
};
struct TextBoxTextChangingEventArgs : generate<TextBoxTextChangingEventArgs> {};

// ITextCompositionChangedEventArgs
struct ITextCompositionChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_StartIndex(int *value);
	virtual STDMETHODIMP _get_Length(int *value);
};
template<typename X> struct ITextCompositionChangedEventArgs_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&ITextCompositionChangedEventArgs_adaptor::Length)->_get_Length(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} Length;
		struct : property {
			int get() { int value; hrcheck(enc(&ITextCompositionChangedEventArgs_adaptor::StartIndex)->_get_StartIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} StartIndex;
	};
	ITextCompositionChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITextCompositionChangedEventArgs, X> : Windows::UI::Xaml::Controls::ITextCompositionChangedEventArgs_adaptor<X> { typedef adapt ITextCompositionChangedEventArgs; };
struct ITextCompositionChangedEventArgs : ITextCompositionChangedEventArgs_raw, generate<ITextCompositionChangedEventArgs> {};

// TextCompositionChangedEventArgs
template<typename X> struct statics<TextCompositionChangedEventArgs, X> : X {
	typedef typename X::root_type TextCompositionChangedEventArgs;
};
struct TextCompositionChangedEventArgs : generate<TextCompositionChangedEventArgs> {};

// ITextCompositionEndedEventArgs
struct ITextCompositionEndedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_StartIndex(int *value);
	virtual STDMETHODIMP _get_Length(int *value);
};
template<typename X> struct ITextCompositionEndedEventArgs_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&ITextCompositionEndedEventArgs_adaptor::Length)->_get_Length(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} Length;
		struct : property {
			int get() { int value; hrcheck(enc(&ITextCompositionEndedEventArgs_adaptor::StartIndex)->_get_StartIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} StartIndex;
	};
	ITextCompositionEndedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITextCompositionEndedEventArgs, X> : Windows::UI::Xaml::Controls::ITextCompositionEndedEventArgs_adaptor<X> { typedef adapt ITextCompositionEndedEventArgs; };
struct ITextCompositionEndedEventArgs : ITextCompositionEndedEventArgs_raw, generate<ITextCompositionEndedEventArgs> {};

// TextCompositionEndedEventArgs
template<typename X> struct statics<TextCompositionEndedEventArgs, X> : X {
	typedef typename X::root_type TextCompositionEndedEventArgs;
};
struct TextCompositionEndedEventArgs : generate<TextCompositionEndedEventArgs> {};

// ITextCompositionStartedEventArgs
struct ITextCompositionStartedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_StartIndex(int *value);
	virtual STDMETHODIMP _get_Length(int *value);
};
template<typename X> struct ITextCompositionStartedEventArgs_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&ITextCompositionStartedEventArgs_adaptor::Length)->_get_Length(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} Length;
		struct : property {
			int get() { int value; hrcheck(enc(&ITextCompositionStartedEventArgs_adaptor::StartIndex)->_get_StartIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} StartIndex;
	};
	ITextCompositionStartedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITextCompositionStartedEventArgs, X> : Windows::UI::Xaml::Controls::ITextCompositionStartedEventArgs_adaptor<X> { typedef adapt ITextCompositionStartedEventArgs; };
struct ITextCompositionStartedEventArgs : ITextCompositionStartedEventArgs_raw, generate<ITextCompositionStartedEventArgs> {};

// TextCompositionStartedEventArgs
template<typename X> struct statics<TextCompositionStartedEventArgs, X> : X {
	typedef typename X::root_type TextCompositionStartedEventArgs;
};
struct TextCompositionStartedEventArgs : generate<TextCompositionStartedEventArgs> {};

// ITextControlCopyingToClipboardEventArgs
struct ITextControlCopyingToClipboardEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
};
template<typename X> struct ITextControlCopyingToClipboardEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextControlCopyingToClipboardEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextControlCopyingToClipboardEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
	};
	ITextControlCopyingToClipboardEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITextControlCopyingToClipboardEventArgs, X> : Windows::UI::Xaml::Controls::ITextControlCopyingToClipboardEventArgs_adaptor<X> { typedef adapt ITextControlCopyingToClipboardEventArgs; };
struct ITextControlCopyingToClipboardEventArgs : ITextControlCopyingToClipboardEventArgs_raw, generate<ITextControlCopyingToClipboardEventArgs> {};

// TextControlCopyingToClipboardEventArgs
template<typename X> struct statics<TextControlCopyingToClipboardEventArgs, X> : X {
	typedef typename X::root_type TextControlCopyingToClipboardEventArgs;
};
struct TextControlCopyingToClipboardEventArgs : generate<TextControlCopyingToClipboardEventArgs> {};

// ITextControlCuttingToClipboardEventArgs
struct ITextControlCuttingToClipboardEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
};
template<typename X> struct ITextControlCuttingToClipboardEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextControlCuttingToClipboardEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextControlCuttingToClipboardEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
	};
	ITextControlCuttingToClipboardEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITextControlCuttingToClipboardEventArgs, X> : Windows::UI::Xaml::Controls::ITextControlCuttingToClipboardEventArgs_adaptor<X> { typedef adapt ITextControlCuttingToClipboardEventArgs; };
struct ITextControlCuttingToClipboardEventArgs : ITextControlCuttingToClipboardEventArgs_raw, generate<ITextControlCuttingToClipboardEventArgs> {};

// TextControlCuttingToClipboardEventArgs
template<typename X> struct statics<TextControlCuttingToClipboardEventArgs, X> : X {
	typedef typename X::root_type TextControlCuttingToClipboardEventArgs;
};
struct TextControlCuttingToClipboardEventArgs : generate<TextControlCuttingToClipboardEventArgs> {};

// ITextControlPasteEventArgs
struct ITextControlPasteEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
};
template<typename X> struct ITextControlPasteEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextControlPasteEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextControlPasteEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
	};
	ITextControlPasteEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITextControlPasteEventArgs, X> : Windows::UI::Xaml::Controls::ITextControlPasteEventArgs_adaptor<X> { typedef adapt ITextControlPasteEventArgs; };
struct ITextControlPasteEventArgs : ITextControlPasteEventArgs_raw, generate<ITextControlPasteEventArgs> {};

// IToolTipService
struct IToolTipService : IInspectable, generate<IToolTipService> {};

// IToolTipServiceStatics
struct IToolTipServiceStatics : IInspectable {
	virtual STDMETHODIMP _get_PlacementProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetPlacement(DependencyObject* element, Primitives::PlacementMode *value);
	virtual STDMETHODIMP _SetPlacement(DependencyObject* element, Primitives::PlacementMode value);
	virtual STDMETHODIMP _get_PlacementTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetPlacementTarget(DependencyObject* element, UIElement* *value);
	virtual STDMETHODIMP _SetPlacementTarget(DependencyObject* element, UIElement* value);
	virtual STDMETHODIMP _get_ToolTipProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetToolTip(DependencyObject* element, IInspectable* *value);
	virtual STDMETHODIMP _SetToolTip(DependencyObject* element, IInspectable* value);
};

// ToolTipService
template<typename> struct ToolTipService_statics {
	static struct _PlacementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToolTipService, IToolTipServiceStatics>()->_get_PlacementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlacementProperty;
	static struct _PlacementTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToolTipService, IToolTipServiceStatics>()->_get_PlacementTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlacementTargetProperty;
	static struct _ToolTipProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToolTipService, IToolTipServiceStatics>()->_get_ToolTipProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ToolTipProperty;
	static Primitives::PlacementMode GetPlacement(pptr<DependencyObject> element) { Primitives::PlacementMode value; hrcheck(get_activation_factory<ToolTipService, IToolTipServiceStatics>()->_GetPlacement(element, &value)); return value; }
	static void SetPlacement(pptr<DependencyObject> element, Primitives::PlacementMode value) { hrcheck(get_activation_factory<ToolTipService, IToolTipServiceStatics>()->_SetPlacement(element, value)); }
	static ptr<UIElement> GetPlacementTarget(pptr<DependencyObject> element) { UIElement* value; hrcheck(get_activation_factory<ToolTipService, IToolTipServiceStatics>()->_GetPlacementTarget(element, &value)); return from_abi(value); }
	static void SetPlacementTarget(pptr<DependencyObject> element, pptr<UIElement> value) { hrcheck(get_activation_factory<ToolTipService, IToolTipServiceStatics>()->_SetPlacementTarget(element, value)); }
	static object GetToolTip(pptr<DependencyObject> element) { IInspectable* value; hrcheck(get_activation_factory<ToolTipService, IToolTipServiceStatics>()->_GetToolTip(element, &value)); return from_abi(value); }
	static void SetToolTip(pptr<DependencyObject> element, object_ref value) { hrcheck(get_activation_factory<ToolTipService, IToolTipServiceStatics>()->_SetToolTip(element, value)); }
};
template<typename X> typename ToolTipService_statics<X>::_PlacementProperty ToolTipService_statics<X>::PlacementProperty;
template<typename X> typename ToolTipService_statics<X>::_PlacementTargetProperty ToolTipService_statics<X>::PlacementTargetProperty;
template<typename X> typename ToolTipService_statics<X>::_ToolTipProperty ToolTipService_statics<X>::ToolTipProperty;

template<typename X> struct statics<ToolTipService, X> : X, Windows::UI::Xaml::Controls::ToolTipService_statics<void> {
	typedef typename X::root_type ToolTipService;
};
struct ToolTipService : generate<ToolTipService> {};

// ICleanUpVirtualizedItemEventArgs
struct ICleanUpVirtualizedItemEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Value(IInspectable* *value);
	virtual STDMETHODIMP _get_UIElement(Xaml::UIElement* *value);
	virtual STDMETHODIMP _get_Cancel(bool *value);
	virtual STDMETHODIMP _put_Cancel(bool value);
};
template<typename X> struct ICleanUpVirtualizedItemEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICleanUpVirtualizedItemEventArgs_adaptor::Cancel)->_get_Cancel(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICleanUpVirtualizedItemEventArgs_adaptor::Cancel)->_put_Cancel(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Cancel;
		struct : property {
			ptr<Xaml::UIElement> get() { Xaml::UIElement* value; hrcheck(enc(&ICleanUpVirtualizedItemEventArgs_adaptor::UIElement)->_get_UIElement(&value)); return from_abi(value); }
			ptr<Xaml::UIElement> operator()() { return get(); }
			operator ptr<Xaml::UIElement> () { return get(); }
			ptr<Xaml::UIElement> operator->() { return get(); }
		} UIElement;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ICleanUpVirtualizedItemEventArgs_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} Value;
	};
	ICleanUpVirtualizedItemEventArgs_adaptor() {}
};
template<typename X> struct adapt<ICleanUpVirtualizedItemEventArgs, X> : Windows::UI::Xaml::Controls::ICleanUpVirtualizedItemEventArgs_adaptor<X> { typedef adapt ICleanUpVirtualizedItemEventArgs; };
struct ICleanUpVirtualizedItemEventArgs : ICleanUpVirtualizedItemEventArgs_raw, generate<ICleanUpVirtualizedItemEventArgs> {};

// IColumnDefinition
struct IColumnDefinition_raw : IInspectable {
	virtual STDMETHODIMP _get_Width(GridLength *value);
	virtual STDMETHODIMP _put_Width(GridLength value);
	virtual STDMETHODIMP _get_MaxWidth(double *value);
	virtual STDMETHODIMP _put_MaxWidth(double value);
	virtual STDMETHODIMP _get_MinWidth(double *value);
	virtual STDMETHODIMP _put_MinWidth(double value);
	virtual STDMETHODIMP _get_ActualWidth(double *value);
};
template<typename X> struct IColumnDefinition_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IColumnDefinition_adaptor::ActualWidth)->_get_ActualWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ActualWidth;
		struct : property {
			double get() { double value; hrcheck(enc(&IColumnDefinition_adaptor::MaxWidth)->_get_MaxWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IColumnDefinition_adaptor::MaxWidth)->_put_MaxWidth(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MaxWidth;
		struct : property {
			double get() { double value; hrcheck(enc(&IColumnDefinition_adaptor::MinWidth)->_get_MinWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IColumnDefinition_adaptor::MinWidth)->_put_MinWidth(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MinWidth;
		struct : property {
			GridLength get() { GridLength value; hrcheck(enc(&IColumnDefinition_adaptor::Width)->_get_Width(&value)); return value; }
			GridLength operator()() { return get(); }
			operator GridLength () { return get(); }
			void put(const GridLength& value) { hrcheck(enc(&IColumnDefinition_adaptor::Width)->_put_Width(value)); }
			void operator=(const GridLength& value) { put(value); }
			void operator()(const GridLength& value) { put(value); }
		} Width;
	};
	IColumnDefinition_adaptor() {}
};
template<typename X> struct adapt<IColumnDefinition, X> : Windows::UI::Xaml::Controls::IColumnDefinition_adaptor<X> { typedef adapt IColumnDefinition; };
struct IColumnDefinition : IColumnDefinition_raw, generate<IColumnDefinition> {};

// IColumnDefinitionStatics
struct IColumnDefinitionStatics : IInspectable {
	virtual STDMETHODIMP _get_WidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinWidthProperty(DependencyProperty* *value);
};

// IContextMenuEventArgs
struct IContextMenuEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _get_CursorLeft(double *value);
	virtual STDMETHODIMP _get_CursorTop(double *value);
};
template<typename X> struct IContextMenuEventArgs_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IContextMenuEventArgs_adaptor::CursorLeft)->_get_CursorLeft(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} CursorLeft;
		struct : property {
			double get() { double value; hrcheck(enc(&IContextMenuEventArgs_adaptor::CursorTop)->_get_CursorTop(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} CursorTop;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IContextMenuEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IContextMenuEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
	};
	IContextMenuEventArgs_adaptor() {}
};
template<typename X> struct adapt<IContextMenuEventArgs, X> : Windows::UI::Xaml::Controls::IContextMenuEventArgs_adaptor<X> { typedef adapt IContextMenuEventArgs; };
struct IContextMenuEventArgs : IContextMenuEventArgs_raw, generate<IContextMenuEventArgs> {};

// IItemClickEventArgs
struct IItemClickEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ClickedItem(IInspectable* *value);
};
template<typename X> struct IItemClickEventArgs_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IItemClickEventArgs_adaptor::ClickedItem)->_get_ClickedItem(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} ClickedItem;
	};
	IItemClickEventArgs_adaptor() {}
};
template<typename X> struct adapt<IItemClickEventArgs, X> : Windows::UI::Xaml::Controls::IItemClickEventArgs_adaptor<X> { typedef adapt IItemClickEventArgs; };
struct IItemClickEventArgs : IItemClickEventArgs_raw, generate<IItemClickEventArgs> {};

// ISelectionChangedEventArgs
struct ISelectionChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_AddedItems(Foundation::Collections::IVector<IInspectable*>* *value);
	virtual STDMETHODIMP _get_RemovedItems(Foundation::Collections::IVector<IInspectable*>* *value);
};
template<typename X> struct ISelectionChangedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<object>> get() { Foundation::Collections::IVector<IInspectable*>* value; hrcheck(enc(&ISelectionChangedEventArgs_adaptor::AddedItems)->_get_AddedItems(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<object>> () { return get(); }
			ptr<Foundation::Collections::IVector<object>> operator->() { return get(); }
		} AddedItems;
		struct : property {
			ptr<Foundation::Collections::IVector<object>> get() { Foundation::Collections::IVector<IInspectable*>* value; hrcheck(enc(&ISelectionChangedEventArgs_adaptor::RemovedItems)->_get_RemovedItems(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<object>> () { return get(); }
			ptr<Foundation::Collections::IVector<object>> operator->() { return get(); }
		} RemovedItems;
	};
	ISelectionChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISelectionChangedEventArgs, X> : Windows::UI::Xaml::Controls::ISelectionChangedEventArgs_adaptor<X> { typedef adapt ISelectionChangedEventArgs; };
struct ISelectionChangedEventArgs : ISelectionChangedEventArgs_raw, generate<ISelectionChangedEventArgs> {};

// ISelectionChangedEventArgsFactory
struct ISelectionChangedEventArgsFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithRemovedItemsAndAddedItems(Foundation::Collections::IVector<IInspectable*>* removedItems, Foundation::Collections::IVector<IInspectable*>* addedItems, IInspectable* outer, IInspectable* *inner, SelectionChangedEventArgs* *instance);
};

// ITextChangedEventArgs
struct ITextChangedEventArgs : IInspectable, generate<ITextChangedEventArgs> {};

// IItemsPanelTemplate
struct IItemsPanelTemplate : IInspectable, generate<IItemsPanelTemplate> {};

// IBorder
struct IBorder_raw : IInspectable {
	virtual STDMETHODIMP _get_BorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_BorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_BorderThickness(Thickness *value);
	virtual STDMETHODIMP _put_BorderThickness(Thickness value);
	virtual STDMETHODIMP _get_Background(Media::Brush* *value);
	virtual STDMETHODIMP _put_Background(Media::Brush* value);
	virtual STDMETHODIMP _get_CornerRadius(Xaml::CornerRadius *value);
	virtual STDMETHODIMP _put_CornerRadius(Xaml::CornerRadius value);
	virtual STDMETHODIMP _get_Padding(Thickness *value);
	virtual STDMETHODIMP _put_Padding(Thickness value);
	virtual STDMETHODIMP _get_Child(UIElement* *value);
	virtual STDMETHODIMP _put_Child(UIElement* value);
	virtual STDMETHODIMP _get_ChildTransitions(Media::Animation::TransitionCollection* *value);
	virtual STDMETHODIMP _put_ChildTransitions(Media::Animation::TransitionCollection* value);
};
template<typename X> struct IBorder_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IBorder_adaptor::Background)->_get_Background(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IBorder_adaptor::Background)->_put_Background(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Background;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IBorder_adaptor::BorderBrush)->_get_BorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IBorder_adaptor::BorderBrush)->_put_BorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} BorderBrush;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IBorder_adaptor::BorderThickness)->_get_BorderThickness(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IBorder_adaptor::BorderThickness)->_put_BorderThickness(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} BorderThickness;
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IBorder_adaptor::Child)->_get_Child(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IBorder_adaptor::Child)->_put_Child(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} Child;
		struct : property {
			ptr<Media::Animation::TransitionCollection> get() { Media::Animation::TransitionCollection* value; hrcheck(enc(&IBorder_adaptor::ChildTransitions)->_get_ChildTransitions(&value)); return from_abi(value); }
			ptr<Media::Animation::TransitionCollection> operator()() { return get(); }
			operator ptr<Media::Animation::TransitionCollection> () { return get(); }
			ptr<Media::Animation::TransitionCollection> operator->() { return get(); }
			void put(pptr<Media::Animation::TransitionCollection> value) { hrcheck(enc(&IBorder_adaptor::ChildTransitions)->_put_ChildTransitions(value)); }
			void operator=(pptr<Media::Animation::TransitionCollection> value) { put(value); }
			void operator()(pptr<Media::Animation::TransitionCollection> value) { put(value); }
		} ChildTransitions;
		struct : property {
			Xaml::CornerRadius get() { Xaml::CornerRadius value; hrcheck(enc(&IBorder_adaptor::CornerRadius)->_get_CornerRadius(&value)); return value; }
			Xaml::CornerRadius operator()() { return get(); }
			operator Xaml::CornerRadius () { return get(); }
			void put(const Xaml::CornerRadius& value) { hrcheck(enc(&IBorder_adaptor::CornerRadius)->_put_CornerRadius(value)); }
			void operator=(const Xaml::CornerRadius& value) { put(value); }
			void operator()(const Xaml::CornerRadius& value) { put(value); }
		} CornerRadius;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IBorder_adaptor::Padding)->_get_Padding(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IBorder_adaptor::Padding)->_put_Padding(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} Padding;
	};
	IBorder_adaptor() {}
};
template<typename X> struct adapt<IBorder, X> : Windows::UI::Xaml::Controls::IBorder_adaptor<X> { typedef adapt IBorder; };
struct IBorder : IBorder_raw, generate<IBorder> {};

// IBorderStatics
struct IBorderStatics : IInspectable {
	virtual STDMETHODIMP _get_BorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BorderThicknessProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CornerRadiusProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PaddingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ChildTransitionsProperty(DependencyProperty* *value);
};

// ICaptureElement
struct ICaptureElement_raw : IInspectable {
	virtual STDMETHODIMP _get_Source(Windows::Media::Capture::MediaCapture* *value);
	virtual STDMETHODIMP _put_Source(Windows::Media::Capture::MediaCapture* value);
	virtual STDMETHODIMP _get_Stretch(Media::Stretch *value);
	virtual STDMETHODIMP _put_Stretch(Media::Stretch value);
};
template<typename X> struct ICaptureElement_adaptor : X {
	union {
		struct : property {
			ptr<Windows::Media::Capture::MediaCapture> get() { Windows::Media::Capture::MediaCapture* value; hrcheck(enc(&ICaptureElement_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			ptr<Windows::Media::Capture::MediaCapture> operator()() { return get(); }
			operator ptr<Windows::Media::Capture::MediaCapture> () { return get(); }
			ptr<Windows::Media::Capture::MediaCapture> operator->() { return get(); }
			void put(pptr<Windows::Media::Capture::MediaCapture> value) { hrcheck(enc(&ICaptureElement_adaptor::Source)->_put_Source(value)); }
			void operator=(pptr<Windows::Media::Capture::MediaCapture> value) { put(value); }
			void operator()(pptr<Windows::Media::Capture::MediaCapture> value) { put(value); }
		} Source;
		struct : property {
			Media::Stretch get() { Media::Stretch value; hrcheck(enc(&ICaptureElement_adaptor::Stretch)->_get_Stretch(&value)); return value; }
			Media::Stretch operator()() { return get(); }
			operator Media::Stretch () { return get(); }
			void put(Media::Stretch value) { hrcheck(enc(&ICaptureElement_adaptor::Stretch)->_put_Stretch(value)); }
			void operator=(Media::Stretch value) { put(value); }
			void operator()(Media::Stretch value) { put(value); }
		} Stretch;
	};
	ICaptureElement_adaptor() {}
};
template<typename X> struct adapt<ICaptureElement, X> : Windows::UI::Xaml::Controls::ICaptureElement_adaptor<X> { typedef adapt ICaptureElement; };
struct ICaptureElement : ICaptureElement_raw, generate<ICaptureElement> {};

// ICaptureElementStatics
struct ICaptureElementStatics : IInspectable {
	virtual STDMETHODIMP _get_SourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_StretchProperty(DependencyProperty* *value);
};

// IImage
struct IImage_raw : IInspectable {
	virtual STDMETHODIMP _get_Source(Media::ImageSource* *value);
	virtual STDMETHODIMP _put_Source(Media::ImageSource* value);
	virtual STDMETHODIMP _get_Stretch(Media::Stretch *value);
	virtual STDMETHODIMP _put_Stretch(Media::Stretch value);
	virtual STDMETHODIMP _get_NineGrid(Thickness *value);
	virtual STDMETHODIMP _put_NineGrid(Thickness value);
	virtual STDMETHODIMP _get_PlayToSource(Windows::Media::PlayTo::PlayToSource* *value);
	virtual STDMETHODIMP _add_ImageFailed(ExceptionRoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ImageFailed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ImageOpened(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ImageOpened(Foundation::EventRegistrationToken token);
};
template<typename X> struct IImage_adaptor : X {
	union {
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IImage_adaptor::NineGrid)->_get_NineGrid(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IImage_adaptor::NineGrid)->_put_NineGrid(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} NineGrid;
		struct : property {
			ptr<Windows::Media::PlayTo::PlayToSource> get() { Windows::Media::PlayTo::PlayToSource* value; hrcheck(enc(&IImage_adaptor::PlayToSource)->_get_PlayToSource(&value)); return from_abi(value); }
			ptr<Windows::Media::PlayTo::PlayToSource> operator()() { return get(); }
			operator ptr<Windows::Media::PlayTo::PlayToSource> () { return get(); }
			ptr<Windows::Media::PlayTo::PlayToSource> operator->() { return get(); }
		} PlayToSource;
		struct : property {
			ptr<Media::ImageSource> get() { Media::ImageSource* value; hrcheck(enc(&IImage_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			ptr<Media::ImageSource> operator()() { return get(); }
			operator ptr<Media::ImageSource> () { return get(); }
			ptr<Media::ImageSource> operator->() { return get(); }
			void put(pptr<Media::ImageSource> value) { hrcheck(enc(&IImage_adaptor::Source)->_put_Source(value)); }
			void operator=(pptr<Media::ImageSource> value) { put(value); }
			void operator()(pptr<Media::ImageSource> value) { put(value); }
		} Source;
		struct : property {
			Media::Stretch get() { Media::Stretch value; hrcheck(enc(&IImage_adaptor::Stretch)->_get_Stretch(&value)); return value; }
			Media::Stretch operator()() { return get(); }
			operator Media::Stretch () { return get(); }
			void put(Media::Stretch value) { hrcheck(enc(&IImage_adaptor::Stretch)->_put_Stretch(value)); }
			void operator=(Media::Stretch value) { put(value); }
			void operator()(Media::Stretch value) { put(value); }
		} Stretch;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<ExceptionRoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IImage_adaptor::ImageFailed)->_add_ImageFailed(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IImage_adaptor::ImageFailed)->_remove_ImageFailed(token)); }
		} ImageFailed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IImage_adaptor::ImageOpened)->_add_ImageOpened(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IImage_adaptor::ImageOpened)->_remove_ImageOpened(token)); }
		} ImageOpened;
	};
	IImage_adaptor() {}
};
template<typename X> struct adapt<IImage, X> : Windows::UI::Xaml::Controls::IImage_adaptor<X> { typedef adapt IImage; };
struct IImage : IImage_raw, generate<IImage> {};

// IImageStatics
struct IImageStatics : IInspectable {
	virtual STDMETHODIMP _get_SourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_StretchProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_NineGridProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlayToSourceProperty(DependencyProperty* *value);
};

// IImage2
struct IImage2_raw : IInspectable {
	virtual STDMETHODIMP _GetAsCastingSource(Windows::Media::Casting::CastingSource* *returnValue);
};
template<typename X> struct IImage2_adaptor : X {
	ptr<Windows::Media::Casting::CastingSource> GetAsCastingSource() { Windows::Media::Casting::CastingSource* returnValue; hrcheck(X::get()->_GetAsCastingSource(&returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IImage2, X> : Windows::UI::Xaml::Controls::IImage2_adaptor<X> { typedef adapt IImage2; };
struct IImage2 : IImage2_raw, generate<IImage2> {};

// IImage3
struct IImage3_raw : IInspectable {
	virtual STDMETHODIMP _GetAlphaMask(Composition::CompositionBrush* *returnValue);
};
template<typename X> struct IImage3_adaptor : X {
	ptr<Composition::CompositionBrush> GetAlphaMask() { Composition::CompositionBrush* returnValue; hrcheck(X::get()->_GetAlphaMask(&returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IImage3, X> : Windows::UI::Xaml::Controls::IImage3_adaptor<X> { typedef adapt IImage3; };
struct IImage3 : IImage3_raw, generate<IImage3> {};

// IItemsPresenter
struct IItemsPresenter_raw : IInspectable {
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_HeaderTransitions(Media::Animation::TransitionCollection* *value);
	virtual STDMETHODIMP _put_HeaderTransitions(Media::Animation::TransitionCollection* value);
	virtual STDMETHODIMP _get_Padding(Thickness *value);
	virtual STDMETHODIMP _put_Padding(Thickness value);
};
template<typename X> struct IItemsPresenter_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IItemsPresenter_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IItemsPresenter_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IItemsPresenter_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IItemsPresenter_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
		struct : property {
			ptr<Media::Animation::TransitionCollection> get() { Media::Animation::TransitionCollection* value; hrcheck(enc(&IItemsPresenter_adaptor::HeaderTransitions)->_get_HeaderTransitions(&value)); return from_abi(value); }
			ptr<Media::Animation::TransitionCollection> operator()() { return get(); }
			operator ptr<Media::Animation::TransitionCollection> () { return get(); }
			ptr<Media::Animation::TransitionCollection> operator->() { return get(); }
			void put(pptr<Media::Animation::TransitionCollection> value) { hrcheck(enc(&IItemsPresenter_adaptor::HeaderTransitions)->_put_HeaderTransitions(value)); }
			void operator=(pptr<Media::Animation::TransitionCollection> value) { put(value); }
			void operator()(pptr<Media::Animation::TransitionCollection> value) { put(value); }
		} HeaderTransitions;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IItemsPresenter_adaptor::Padding)->_get_Padding(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IItemsPresenter_adaptor::Padding)->_put_Padding(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} Padding;
	};
	IItemsPresenter_adaptor() {}
};
template<typename X> struct adapt<IItemsPresenter, X> : Windows::UI::Xaml::Controls::IItemsPresenter_adaptor<X> { typedef adapt IItemsPresenter; };
struct IItemsPresenter : IItemsPresenter_raw, generate<IItemsPresenter> {};

// IItemsPresenterStatics
struct IItemsPresenterStatics : IInspectable {
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTransitionsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PaddingProperty(DependencyProperty* *value);
};

// IItemsPresenter2
struct IItemsPresenter2_raw : IInspectable {
	virtual STDMETHODIMP _get_Footer(IInspectable* *value);
	virtual STDMETHODIMP _put_Footer(IInspectable* value);
	virtual STDMETHODIMP _get_FooterTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_FooterTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_FooterTransitions(Media::Animation::TransitionCollection* *value);
	virtual STDMETHODIMP _put_FooterTransitions(Media::Animation::TransitionCollection* value);
};
template<typename X> struct IItemsPresenter2_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IItemsPresenter2_adaptor::Footer)->_get_Footer(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IItemsPresenter2_adaptor::Footer)->_put_Footer(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Footer;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IItemsPresenter2_adaptor::FooterTemplate)->_get_FooterTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IItemsPresenter2_adaptor::FooterTemplate)->_put_FooterTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} FooterTemplate;
		struct : property {
			ptr<Media::Animation::TransitionCollection> get() { Media::Animation::TransitionCollection* value; hrcheck(enc(&IItemsPresenter2_adaptor::FooterTransitions)->_get_FooterTransitions(&value)); return from_abi(value); }
			ptr<Media::Animation::TransitionCollection> operator()() { return get(); }
			operator ptr<Media::Animation::TransitionCollection> () { return get(); }
			ptr<Media::Animation::TransitionCollection> operator->() { return get(); }
			void put(pptr<Media::Animation::TransitionCollection> value) { hrcheck(enc(&IItemsPresenter2_adaptor::FooterTransitions)->_put_FooterTransitions(value)); }
			void operator=(pptr<Media::Animation::TransitionCollection> value) { put(value); }
			void operator()(pptr<Media::Animation::TransitionCollection> value) { put(value); }
		} FooterTransitions;
	};
	IItemsPresenter2_adaptor() {}
};
template<typename X> struct adapt<IItemsPresenter2, X> : Windows::UI::Xaml::Controls::IItemsPresenter2_adaptor<X> { typedef adapt IItemsPresenter2; };
struct IItemsPresenter2 : IItemsPresenter2_raw, generate<IItemsPresenter2> {};

// IItemsPresenterStatics2
struct IItemsPresenterStatics2 : IInspectable {
	virtual STDMETHODIMP _get_FooterProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FooterTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FooterTransitionsProperty(DependencyProperty* *value);
};

// IRichTextBlock
struct IRichTextBlock_raw : IInspectable {
	virtual STDMETHODIMP _get_FontSize(double *value);
	virtual STDMETHODIMP _put_FontSize(double value);
	virtual STDMETHODIMP _get_FontFamily(Media::FontFamily* *value);
	virtual STDMETHODIMP _put_FontFamily(Media::FontFamily* value);
	virtual STDMETHODIMP _get_FontWeight(Text::FontWeight *value);
	virtual STDMETHODIMP _put_FontWeight(Text::FontWeight value);
	virtual STDMETHODIMP _get_FontStyle(Text::FontStyle *value);
	virtual STDMETHODIMP _put_FontStyle(Text::FontStyle value);
	virtual STDMETHODIMP _get_FontStretch(Text::FontStretch *value);
	virtual STDMETHODIMP _put_FontStretch(Text::FontStretch value);
	virtual STDMETHODIMP _get_Foreground(Media::Brush* *value);
	virtual STDMETHODIMP _put_Foreground(Media::Brush* value);
	virtual STDMETHODIMP _get_TextWrapping(Xaml::TextWrapping *value);
	virtual STDMETHODIMP _put_TextWrapping(Xaml::TextWrapping value);
	virtual STDMETHODIMP _get_TextTrimming(Xaml::TextTrimming *value);
	virtual STDMETHODIMP _put_TextTrimming(Xaml::TextTrimming value);
	virtual STDMETHODIMP _get_TextAlignment(Xaml::TextAlignment *value);
	virtual STDMETHODIMP _put_TextAlignment(Xaml::TextAlignment value);
	virtual STDMETHODIMP _get_Blocks(Documents::BlockCollection* *value);
	virtual STDMETHODIMP _get_Padding(Thickness *value);
	virtual STDMETHODIMP _put_Padding(Thickness value);
	virtual STDMETHODIMP _get_LineHeight(double *value);
	virtual STDMETHODIMP _put_LineHeight(double value);
	virtual STDMETHODIMP _get_LineStackingStrategy(Xaml::LineStackingStrategy *value);
	virtual STDMETHODIMP _put_LineStackingStrategy(Xaml::LineStackingStrategy value);
	virtual STDMETHODIMP _get_CharacterSpacing(int *value);
	virtual STDMETHODIMP _put_CharacterSpacing(int value);
	virtual STDMETHODIMP _get_OverflowContentTarget(RichTextBlockOverflow* *value);
	virtual STDMETHODIMP _put_OverflowContentTarget(RichTextBlockOverflow* value);
	virtual STDMETHODIMP _get_IsTextSelectionEnabled(bool *value);
	virtual STDMETHODIMP _put_IsTextSelectionEnabled(bool value);
	virtual STDMETHODIMP _get_HasOverflowContent(bool *value);
	virtual STDMETHODIMP _get_SelectedText(HSTRING *value);
	virtual STDMETHODIMP _get_ContentStart(Documents::TextPointer* *value);
	virtual STDMETHODIMP _get_ContentEnd(Documents::TextPointer* *value);
	virtual STDMETHODIMP _get_SelectionStart(Documents::TextPointer* *value);
	virtual STDMETHODIMP _get_SelectionEnd(Documents::TextPointer* *value);
	virtual STDMETHODIMP _get_BaselineOffset(double *value);
	virtual STDMETHODIMP _add_SelectionChanged(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SelectionChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ContextMenuOpening(ContextMenuOpeningEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ContextMenuOpening(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _SelectAll();
	virtual STDMETHODIMP _Select(Documents::TextPointer* start, Documents::TextPointer* end);
	virtual STDMETHODIMP _GetPositionFromPoint(Foundation::Point point, Documents::TextPointer* *returnValue);
	virtual STDMETHODIMP _Focus(FocusState value, bool *returnValue);
	virtual STDMETHODIMP _get_TextIndent(double *value);
	virtual STDMETHODIMP _put_TextIndent(double value);
};
template<typename X> struct IRichTextBlock_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IRichTextBlock_adaptor::BaselineOffset)->_get_BaselineOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} BaselineOffset;
		struct : property {
			ptr<Documents::BlockCollection> get() { Documents::BlockCollection* value; hrcheck(enc(&IRichTextBlock_adaptor::Blocks)->_get_Blocks(&value)); return from_abi(value); }
			ptr<Documents::BlockCollection> operator()() { return get(); }
			operator ptr<Documents::BlockCollection> () { return get(); }
			ptr<Documents::BlockCollection> operator->() { return get(); }
		} Blocks;
		struct : property {
			int get() { int value; hrcheck(enc(&IRichTextBlock_adaptor::CharacterSpacing)->_get_CharacterSpacing(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IRichTextBlock_adaptor::CharacterSpacing)->_put_CharacterSpacing(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} CharacterSpacing;
		struct : property {
			ptr<Documents::TextPointer> get() { Documents::TextPointer* value; hrcheck(enc(&IRichTextBlock_adaptor::ContentEnd)->_get_ContentEnd(&value)); return from_abi(value); }
			ptr<Documents::TextPointer> operator()() { return get(); }
			operator ptr<Documents::TextPointer> () { return get(); }
			ptr<Documents::TextPointer> operator->() { return get(); }
		} ContentEnd;
		struct : property {
			ptr<Documents::TextPointer> get() { Documents::TextPointer* value; hrcheck(enc(&IRichTextBlock_adaptor::ContentStart)->_get_ContentStart(&value)); return from_abi(value); }
			ptr<Documents::TextPointer> operator()() { return get(); }
			operator ptr<Documents::TextPointer> () { return get(); }
			ptr<Documents::TextPointer> operator->() { return get(); }
		} ContentStart;
		struct : property {
			ptr<Media::FontFamily> get() { Media::FontFamily* value; hrcheck(enc(&IRichTextBlock_adaptor::FontFamily)->_get_FontFamily(&value)); return from_abi(value); }
			ptr<Media::FontFamily> operator()() { return get(); }
			operator ptr<Media::FontFamily> () { return get(); }
			ptr<Media::FontFamily> operator->() { return get(); }
			void put(pptr<Media::FontFamily> value) { hrcheck(enc(&IRichTextBlock_adaptor::FontFamily)->_put_FontFamily(value)); }
			void operator=(pptr<Media::FontFamily> value) { put(value); }
			void operator()(pptr<Media::FontFamily> value) { put(value); }
		} FontFamily;
		struct : property {
			double get() { double value; hrcheck(enc(&IRichTextBlock_adaptor::FontSize)->_get_FontSize(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRichTextBlock_adaptor::FontSize)->_put_FontSize(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FontSize;
		struct : property {
			Text::FontStretch get() { Text::FontStretch value; hrcheck(enc(&IRichTextBlock_adaptor::FontStretch)->_get_FontStretch(&value)); return value; }
			Text::FontStretch operator()() { return get(); }
			operator Text::FontStretch () { return get(); }
			void put(Text::FontStretch value) { hrcheck(enc(&IRichTextBlock_adaptor::FontStretch)->_put_FontStretch(value)); }
			void operator=(Text::FontStretch value) { put(value); }
			void operator()(Text::FontStretch value) { put(value); }
		} FontStretch;
		struct : property {
			Text::FontStyle get() { Text::FontStyle value; hrcheck(enc(&IRichTextBlock_adaptor::FontStyle)->_get_FontStyle(&value)); return value; }
			Text::FontStyle operator()() { return get(); }
			operator Text::FontStyle () { return get(); }
			void put(Text::FontStyle value) { hrcheck(enc(&IRichTextBlock_adaptor::FontStyle)->_put_FontStyle(value)); }
			void operator=(Text::FontStyle value) { put(value); }
			void operator()(Text::FontStyle value) { put(value); }
		} FontStyle;
		struct : property {
			Text::FontWeight get() { Text::FontWeight value; hrcheck(enc(&IRichTextBlock_adaptor::FontWeight)->_get_FontWeight(&value)); return value; }
			Text::FontWeight operator()() { return get(); }
			operator Text::FontWeight () { return get(); }
			void put(const Text::FontWeight& value) { hrcheck(enc(&IRichTextBlock_adaptor::FontWeight)->_put_FontWeight(value)); }
			void operator=(const Text::FontWeight& value) { put(value); }
			void operator()(const Text::FontWeight& value) { put(value); }
		} FontWeight;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IRichTextBlock_adaptor::Foreground)->_get_Foreground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IRichTextBlock_adaptor::Foreground)->_put_Foreground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Foreground;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRichTextBlock_adaptor::HasOverflowContent)->_get_HasOverflowContent(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasOverflowContent;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRichTextBlock_adaptor::IsTextSelectionEnabled)->_get_IsTextSelectionEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IRichTextBlock_adaptor::IsTextSelectionEnabled)->_put_IsTextSelectionEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTextSelectionEnabled;
		struct : property {
			double get() { double value; hrcheck(enc(&IRichTextBlock_adaptor::LineHeight)->_get_LineHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRichTextBlock_adaptor::LineHeight)->_put_LineHeight(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} LineHeight;
		struct : property {
			Xaml::LineStackingStrategy get() { Xaml::LineStackingStrategy value; hrcheck(enc(&IRichTextBlock_adaptor::LineStackingStrategy)->_get_LineStackingStrategy(&value)); return value; }
			Xaml::LineStackingStrategy operator()() { return get(); }
			operator Xaml::LineStackingStrategy () { return get(); }
			void put(Xaml::LineStackingStrategy value) { hrcheck(enc(&IRichTextBlock_adaptor::LineStackingStrategy)->_put_LineStackingStrategy(value)); }
			void operator=(Xaml::LineStackingStrategy value) { put(value); }
			void operator()(Xaml::LineStackingStrategy value) { put(value); }
		} LineStackingStrategy;
		struct : property {
			ptr<RichTextBlockOverflow> get() { RichTextBlockOverflow* value; hrcheck(enc(&IRichTextBlock_adaptor::OverflowContentTarget)->_get_OverflowContentTarget(&value)); return from_abi(value); }
			ptr<RichTextBlockOverflow> operator()() { return get(); }
			operator ptr<RichTextBlockOverflow> () { return get(); }
			ptr<RichTextBlockOverflow> operator->() { return get(); }
			void put(pptr<RichTextBlockOverflow> value) { hrcheck(enc(&IRichTextBlock_adaptor::OverflowContentTarget)->_put_OverflowContentTarget(value)); }
			void operator=(pptr<RichTextBlockOverflow> value) { put(value); }
			void operator()(pptr<RichTextBlockOverflow> value) { put(value); }
		} OverflowContentTarget;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IRichTextBlock_adaptor::Padding)->_get_Padding(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IRichTextBlock_adaptor::Padding)->_put_Padding(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} Padding;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRichTextBlock_adaptor::SelectedText)->_get_SelectedText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} SelectedText;
		struct : property {
			ptr<Documents::TextPointer> get() { Documents::TextPointer* value; hrcheck(enc(&IRichTextBlock_adaptor::SelectionEnd)->_get_SelectionEnd(&value)); return from_abi(value); }
			ptr<Documents::TextPointer> operator()() { return get(); }
			operator ptr<Documents::TextPointer> () { return get(); }
			ptr<Documents::TextPointer> operator->() { return get(); }
		} SelectionEnd;
		struct : property {
			ptr<Documents::TextPointer> get() { Documents::TextPointer* value; hrcheck(enc(&IRichTextBlock_adaptor::SelectionStart)->_get_SelectionStart(&value)); return from_abi(value); }
			ptr<Documents::TextPointer> operator()() { return get(); }
			operator ptr<Documents::TextPointer> () { return get(); }
			ptr<Documents::TextPointer> operator->() { return get(); }
		} SelectionStart;
		struct : property {
			Xaml::TextAlignment get() { Xaml::TextAlignment value; hrcheck(enc(&IRichTextBlock_adaptor::TextAlignment)->_get_TextAlignment(&value)); return value; }
			Xaml::TextAlignment operator()() { return get(); }
			operator Xaml::TextAlignment () { return get(); }
			void put(Xaml::TextAlignment value) { hrcheck(enc(&IRichTextBlock_adaptor::TextAlignment)->_put_TextAlignment(value)); }
			void operator=(Xaml::TextAlignment value) { put(value); }
			void operator()(Xaml::TextAlignment value) { put(value); }
		} TextAlignment;
		struct : property {
			double get() { double value; hrcheck(enc(&IRichTextBlock_adaptor::TextIndent)->_get_TextIndent(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRichTextBlock_adaptor::TextIndent)->_put_TextIndent(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} TextIndent;
		struct : property {
			Xaml::TextTrimming get() { Xaml::TextTrimming value; hrcheck(enc(&IRichTextBlock_adaptor::TextTrimming)->_get_TextTrimming(&value)); return value; }
			Xaml::TextTrimming operator()() { return get(); }
			operator Xaml::TextTrimming () { return get(); }
			void put(Xaml::TextTrimming value) { hrcheck(enc(&IRichTextBlock_adaptor::TextTrimming)->_put_TextTrimming(value)); }
			void operator=(Xaml::TextTrimming value) { put(value); }
			void operator()(Xaml::TextTrimming value) { put(value); }
		} TextTrimming;
		struct : property {
			Xaml::TextWrapping get() { Xaml::TextWrapping value; hrcheck(enc(&IRichTextBlock_adaptor::TextWrapping)->_get_TextWrapping(&value)); return value; }
			Xaml::TextWrapping operator()() { return get(); }
			operator Xaml::TextWrapping () { return get(); }
			void put(Xaml::TextWrapping value) { hrcheck(enc(&IRichTextBlock_adaptor::TextWrapping)->_put_TextWrapping(value)); }
			void operator=(Xaml::TextWrapping value) { put(value); }
			void operator()(Xaml::TextWrapping value) { put(value); }
		} TextWrapping;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<ContextMenuOpeningEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichTextBlock_adaptor::ContextMenuOpening)->_add_ContextMenuOpening(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichTextBlock_adaptor::ContextMenuOpening)->_remove_ContextMenuOpening(token)); }
		} ContextMenuOpening;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichTextBlock_adaptor::SelectionChanged)->_add_SelectionChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichTextBlock_adaptor::SelectionChanged)->_remove_SelectionChanged(token)); }
		} SelectionChanged;
	};
	void SelectAll() { hrcheck(X::get()->_SelectAll()); }
	void Select(pptr<Documents::TextPointer> start, pptr<Documents::TextPointer> end) { hrcheck(X::get()->_Select(start, end)); }
	ptr<Documents::TextPointer> GetPositionFromPoint(const Foundation::Point& point) { Documents::TextPointer* returnValue; hrcheck(X::get()->_GetPositionFromPoint(point, &returnValue)); return from_abi(returnValue); }
	bool Focus(FocusState value) { bool returnValue; hrcheck(X::get()->_Focus(value, &returnValue)); return returnValue; }
	IRichTextBlock_adaptor() {}
};
template<typename X> struct adapt<IRichTextBlock, X> : Windows::UI::Xaml::Controls::IRichTextBlock_adaptor<X> { typedef adapt IRichTextBlock; };
struct IRichTextBlock : IRichTextBlock_raw, generate<IRichTextBlock> {};

// IRichTextBlockStatics
struct IRichTextBlockStatics : IInspectable {
	virtual STDMETHODIMP _get_FontSizeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontFamilyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontWeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontStretchProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ForegroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextWrappingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextTrimmingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PaddingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_LineHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_LineStackingStrategyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CharacterSpacingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OverflowContentTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsTextSelectionEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HasOverflowContentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedTextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextIndentProperty(DependencyProperty* *value);
};

// IRichTextBlock2
struct IRichTextBlock2_raw : IInspectable {
	virtual STDMETHODIMP _get_MaxLines(int *value);
	virtual STDMETHODIMP _put_MaxLines(int value);
	virtual STDMETHODIMP _get_TextLineBounds(Xaml::TextLineBounds *value);
	virtual STDMETHODIMP _put_TextLineBounds(Xaml::TextLineBounds value);
	virtual STDMETHODIMP _get_SelectionHighlightColor(Media::SolidColorBrush* *value);
	virtual STDMETHODIMP _put_SelectionHighlightColor(Media::SolidColorBrush* value);
	virtual STDMETHODIMP _get_OpticalMarginAlignment(Xaml::OpticalMarginAlignment *value);
	virtual STDMETHODIMP _put_OpticalMarginAlignment(Xaml::OpticalMarginAlignment value);
	virtual STDMETHODIMP _get_IsColorFontEnabled(bool *value);
	virtual STDMETHODIMP _put_IsColorFontEnabled(bool value);
	virtual STDMETHODIMP _get_TextReadingOrder(Xaml::TextReadingOrder *value);
	virtual STDMETHODIMP _put_TextReadingOrder(Xaml::TextReadingOrder value);
};
template<typename X> struct IRichTextBlock2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRichTextBlock2_adaptor::IsColorFontEnabled)->_get_IsColorFontEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IRichTextBlock2_adaptor::IsColorFontEnabled)->_put_IsColorFontEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsColorFontEnabled;
		struct : property {
			int get() { int value; hrcheck(enc(&IRichTextBlock2_adaptor::MaxLines)->_get_MaxLines(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IRichTextBlock2_adaptor::MaxLines)->_put_MaxLines(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaxLines;
		struct : property {
			Xaml::OpticalMarginAlignment get() { Xaml::OpticalMarginAlignment value; hrcheck(enc(&IRichTextBlock2_adaptor::OpticalMarginAlignment)->_get_OpticalMarginAlignment(&value)); return value; }
			Xaml::OpticalMarginAlignment operator()() { return get(); }
			operator Xaml::OpticalMarginAlignment () { return get(); }
			void put(Xaml::OpticalMarginAlignment value) { hrcheck(enc(&IRichTextBlock2_adaptor::OpticalMarginAlignment)->_put_OpticalMarginAlignment(value)); }
			void operator=(Xaml::OpticalMarginAlignment value) { put(value); }
			void operator()(Xaml::OpticalMarginAlignment value) { put(value); }
		} OpticalMarginAlignment;
		struct : property {
			ptr<Media::SolidColorBrush> get() { Media::SolidColorBrush* value; hrcheck(enc(&IRichTextBlock2_adaptor::SelectionHighlightColor)->_get_SelectionHighlightColor(&value)); return from_abi(value); }
			ptr<Media::SolidColorBrush> operator()() { return get(); }
			operator ptr<Media::SolidColorBrush> () { return get(); }
			ptr<Media::SolidColorBrush> operator->() { return get(); }
			void put(pptr<Media::SolidColorBrush> value) { hrcheck(enc(&IRichTextBlock2_adaptor::SelectionHighlightColor)->_put_SelectionHighlightColor(value)); }
			void operator=(pptr<Media::SolidColorBrush> value) { put(value); }
			void operator()(pptr<Media::SolidColorBrush> value) { put(value); }
		} SelectionHighlightColor;
		struct : property {
			Xaml::TextLineBounds get() { Xaml::TextLineBounds value; hrcheck(enc(&IRichTextBlock2_adaptor::TextLineBounds)->_get_TextLineBounds(&value)); return value; }
			Xaml::TextLineBounds operator()() { return get(); }
			operator Xaml::TextLineBounds () { return get(); }
			void put(Xaml::TextLineBounds value) { hrcheck(enc(&IRichTextBlock2_adaptor::TextLineBounds)->_put_TextLineBounds(value)); }
			void operator=(Xaml::TextLineBounds value) { put(value); }
			void operator()(Xaml::TextLineBounds value) { put(value); }
		} TextLineBounds;
		struct : property {
			Xaml::TextReadingOrder get() { Xaml::TextReadingOrder value; hrcheck(enc(&IRichTextBlock2_adaptor::TextReadingOrder)->_get_TextReadingOrder(&value)); return value; }
			Xaml::TextReadingOrder operator()() { return get(); }
			operator Xaml::TextReadingOrder () { return get(); }
			void put(Xaml::TextReadingOrder value) { hrcheck(enc(&IRichTextBlock2_adaptor::TextReadingOrder)->_put_TextReadingOrder(value)); }
			void operator=(Xaml::TextReadingOrder value) { put(value); }
			void operator()(Xaml::TextReadingOrder value) { put(value); }
		} TextReadingOrder;
	};
	IRichTextBlock2_adaptor() {}
};
template<typename X> struct adapt<IRichTextBlock2, X> : Windows::UI::Xaml::Controls::IRichTextBlock2_adaptor<X> { typedef adapt IRichTextBlock2; };
struct IRichTextBlock2 : IRichTextBlock2_raw, generate<IRichTextBlock2> {};

// IRichTextBlockStatics2
struct IRichTextBlockStatics2 : IInspectable {
	virtual STDMETHODIMP _get_MaxLinesProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextLineBoundsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectionHighlightColorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OpticalMarginAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsColorFontEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextReadingOrderProperty(DependencyProperty* *value);
};

// IRichTextBlock3
struct IRichTextBlock3_raw : IInspectable {
	virtual STDMETHODIMP _get_IsTextScaleFactorEnabled(bool *value);
	virtual STDMETHODIMP _put_IsTextScaleFactorEnabled(bool value);
};
template<typename X> struct IRichTextBlock3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRichTextBlock3_adaptor::IsTextScaleFactorEnabled)->_get_IsTextScaleFactorEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IRichTextBlock3_adaptor::IsTextScaleFactorEnabled)->_put_IsTextScaleFactorEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTextScaleFactorEnabled;
	};
	IRichTextBlock3_adaptor() {}
};
template<typename X> struct adapt<IRichTextBlock3, X> : Windows::UI::Xaml::Controls::IRichTextBlock3_adaptor<X> { typedef adapt IRichTextBlock3; };
struct IRichTextBlock3 : IRichTextBlock3_raw, generate<IRichTextBlock3> {};

// IRichTextBlockStatics3
struct IRichTextBlockStatics3 : IInspectable {
	virtual STDMETHODIMP _get_IsTextScaleFactorEnabledProperty(DependencyProperty* *value);
};

// IRichTextBlock4
struct IRichTextBlock4_raw : IInspectable {
	virtual STDMETHODIMP _get_TextDecorations(Text::TextDecorations *value);
	virtual STDMETHODIMP _put_TextDecorations(Text::TextDecorations value);
};
template<typename X> struct IRichTextBlock4_adaptor : X {
	union {
		struct : property {
			Text::TextDecorations get() { Text::TextDecorations value; hrcheck(enc(&IRichTextBlock4_adaptor::TextDecorations)->_get_TextDecorations(&value)); return value; }
			Text::TextDecorations operator()() { return get(); }
			operator Text::TextDecorations () { return get(); }
			void put(Text::TextDecorations value) { hrcheck(enc(&IRichTextBlock4_adaptor::TextDecorations)->_put_TextDecorations(value)); }
			void operator=(Text::TextDecorations value) { put(value); }
			void operator()(Text::TextDecorations value) { put(value); }
		} TextDecorations;
	};
	IRichTextBlock4_adaptor() {}
};
template<typename X> struct adapt<IRichTextBlock4, X> : Windows::UI::Xaml::Controls::IRichTextBlock4_adaptor<X> { typedef adapt IRichTextBlock4; };
struct IRichTextBlock4 : IRichTextBlock4_raw, generate<IRichTextBlock4> {};

// IRichTextBlockStatics4
struct IRichTextBlockStatics4 : IInspectable {
	virtual STDMETHODIMP _get_TextDecorationsProperty(DependencyProperty* *value);
};

// IRichTextBlock5
struct IRichTextBlock5_raw : IInspectable {
	virtual STDMETHODIMP _get_IsTextTrimmed(bool *value);
	virtual STDMETHODIMP _get_HorizontalTextAlignment(TextAlignment *value);
	virtual STDMETHODIMP _put_HorizontalTextAlignment(TextAlignment value);
	virtual STDMETHODIMP _get_TextHighlighters(Foundation::Collections::IVector<Documents::TextHighlighter*>* *value);
	virtual STDMETHODIMP _add_IsTextTrimmedChanged(Foundation::TypedEventHandler<RichTextBlock*, IsTextTrimmedChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_IsTextTrimmedChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IRichTextBlock5_adaptor : X {
	union {
		struct : property {
			TextAlignment get() { TextAlignment value; hrcheck(enc(&IRichTextBlock5_adaptor::HorizontalTextAlignment)->_get_HorizontalTextAlignment(&value)); return value; }
			TextAlignment operator()() { return get(); }
			operator TextAlignment () { return get(); }
			void put(TextAlignment value) { hrcheck(enc(&IRichTextBlock5_adaptor::HorizontalTextAlignment)->_put_HorizontalTextAlignment(value)); }
			void operator=(TextAlignment value) { put(value); }
			void operator()(TextAlignment value) { put(value); }
		} HorizontalTextAlignment;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRichTextBlock5_adaptor::IsTextTrimmed)->_get_IsTextTrimmed(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsTextTrimmed;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Documents::TextHighlighter>>> get() { Foundation::Collections::IVector<Documents::TextHighlighter*>* value; hrcheck(enc(&IRichTextBlock5_adaptor::TextHighlighters)->_get_TextHighlighters(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Documents::TextHighlighter>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Documents::TextHighlighter>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Documents::TextHighlighter>>> operator->() { return get(); }
		} TextHighlighters;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<RichTextBlock>, ptr<IsTextTrimmedChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichTextBlock5_adaptor::IsTextTrimmedChanged)->_add_IsTextTrimmedChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichTextBlock5_adaptor::IsTextTrimmedChanged)->_remove_IsTextTrimmedChanged(token)); }
		} IsTextTrimmedChanged;
	};
	IRichTextBlock5_adaptor() {}
};
template<typename X> struct adapt<IRichTextBlock5, X> : Windows::UI::Xaml::Controls::IRichTextBlock5_adaptor<X> { typedef adapt IRichTextBlock5; };
struct IRichTextBlock5 : IRichTextBlock5_raw, generate<IRichTextBlock5> {};

// IRichTextBlockStatics5
struct IRichTextBlockStatics5 : IInspectable {
	virtual STDMETHODIMP _get_IsTextTrimmedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalTextAlignmentProperty(DependencyProperty* *value);
};

// IRichTextBlockOverflow
struct IRichTextBlockOverflow_raw : IInspectable {
	virtual STDMETHODIMP _get_OverflowContentTarget(RichTextBlockOverflow* *value);
	virtual STDMETHODIMP _put_OverflowContentTarget(RichTextBlockOverflow* value);
	virtual STDMETHODIMP _get_Padding(Thickness *value);
	virtual STDMETHODIMP _put_Padding(Thickness value);
	virtual STDMETHODIMP _get_ContentSource(RichTextBlock* *value);
	virtual STDMETHODIMP _get_HasOverflowContent(bool *value);
	virtual STDMETHODIMP _get_ContentStart(Documents::TextPointer* *value);
	virtual STDMETHODIMP _get_ContentEnd(Documents::TextPointer* *value);
	virtual STDMETHODIMP _get_BaselineOffset(double *value);
	virtual STDMETHODIMP _GetPositionFromPoint(Foundation::Point point, Documents::TextPointer* *returnValue);
	virtual STDMETHODIMP _Focus(FocusState value, bool *returnValue);
};
template<typename X> struct IRichTextBlockOverflow_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IRichTextBlockOverflow_adaptor::BaselineOffset)->_get_BaselineOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} BaselineOffset;
		struct : property {
			ptr<Documents::TextPointer> get() { Documents::TextPointer* value; hrcheck(enc(&IRichTextBlockOverflow_adaptor::ContentEnd)->_get_ContentEnd(&value)); return from_abi(value); }
			ptr<Documents::TextPointer> operator()() { return get(); }
			operator ptr<Documents::TextPointer> () { return get(); }
			ptr<Documents::TextPointer> operator->() { return get(); }
		} ContentEnd;
		struct : property {
			ptr<RichTextBlock> get() { RichTextBlock* value; hrcheck(enc(&IRichTextBlockOverflow_adaptor::ContentSource)->_get_ContentSource(&value)); return from_abi(value); }
			ptr<RichTextBlock> operator()() { return get(); }
			operator ptr<RichTextBlock> () { return get(); }
			ptr<RichTextBlock> operator->() { return get(); }
		} ContentSource;
		struct : property {
			ptr<Documents::TextPointer> get() { Documents::TextPointer* value; hrcheck(enc(&IRichTextBlockOverflow_adaptor::ContentStart)->_get_ContentStart(&value)); return from_abi(value); }
			ptr<Documents::TextPointer> operator()() { return get(); }
			operator ptr<Documents::TextPointer> () { return get(); }
			ptr<Documents::TextPointer> operator->() { return get(); }
		} ContentStart;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRichTextBlockOverflow_adaptor::HasOverflowContent)->_get_HasOverflowContent(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasOverflowContent;
		struct : property {
			ptr<RichTextBlockOverflow> get() { RichTextBlockOverflow* value; hrcheck(enc(&IRichTextBlockOverflow_adaptor::OverflowContentTarget)->_get_OverflowContentTarget(&value)); return from_abi(value); }
			ptr<RichTextBlockOverflow> operator()() { return get(); }
			operator ptr<RichTextBlockOverflow> () { return get(); }
			ptr<RichTextBlockOverflow> operator->() { return get(); }
			void put(pptr<RichTextBlockOverflow> value) { hrcheck(enc(&IRichTextBlockOverflow_adaptor::OverflowContentTarget)->_put_OverflowContentTarget(value)); }
			void operator=(pptr<RichTextBlockOverflow> value) { put(value); }
			void operator()(pptr<RichTextBlockOverflow> value) { put(value); }
		} OverflowContentTarget;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IRichTextBlockOverflow_adaptor::Padding)->_get_Padding(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IRichTextBlockOverflow_adaptor::Padding)->_put_Padding(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} Padding;
	};
	ptr<Documents::TextPointer> GetPositionFromPoint(const Foundation::Point& point) { Documents::TextPointer* returnValue; hrcheck(X::get()->_GetPositionFromPoint(point, &returnValue)); return from_abi(returnValue); }
	bool Focus(FocusState value) { bool returnValue; hrcheck(X::get()->_Focus(value, &returnValue)); return returnValue; }
	IRichTextBlockOverflow_adaptor() {}
};
template<typename X> struct adapt<IRichTextBlockOverflow, X> : Windows::UI::Xaml::Controls::IRichTextBlockOverflow_adaptor<X> { typedef adapt IRichTextBlockOverflow; };
struct IRichTextBlockOverflow : IRichTextBlockOverflow_raw, generate<IRichTextBlockOverflow> {};

// IRichTextBlockOverflowStatics
struct IRichTextBlockOverflowStatics : IInspectable {
	virtual STDMETHODIMP _get_OverflowContentTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PaddingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HasOverflowContentProperty(DependencyProperty* *value);
};

// IRichTextBlockOverflow2
struct IRichTextBlockOverflow2_raw : IInspectable {
	virtual STDMETHODIMP _get_MaxLines(int *value);
	virtual STDMETHODIMP _put_MaxLines(int value);
};
template<typename X> struct IRichTextBlockOverflow2_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IRichTextBlockOverflow2_adaptor::MaxLines)->_get_MaxLines(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IRichTextBlockOverflow2_adaptor::MaxLines)->_put_MaxLines(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaxLines;
	};
	IRichTextBlockOverflow2_adaptor() {}
};
template<typename X> struct adapt<IRichTextBlockOverflow2, X> : Windows::UI::Xaml::Controls::IRichTextBlockOverflow2_adaptor<X> { typedef adapt IRichTextBlockOverflow2; };
struct IRichTextBlockOverflow2 : IRichTextBlockOverflow2_raw, generate<IRichTextBlockOverflow2> {};

// IRichTextBlockOverflowStatics2
struct IRichTextBlockOverflowStatics2 : IInspectable {
	virtual STDMETHODIMP _get_MaxLinesProperty(DependencyProperty* *value);
};

// IRichTextBlockOverflow3
struct IRichTextBlockOverflow3_raw : IInspectable {
	virtual STDMETHODIMP _get_IsTextTrimmed(bool *value);
	virtual STDMETHODIMP _add_IsTextTrimmedChanged(Foundation::TypedEventHandler<RichTextBlockOverflow*, IsTextTrimmedChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_IsTextTrimmedChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IRichTextBlockOverflow3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRichTextBlockOverflow3_adaptor::IsTextTrimmed)->_get_IsTextTrimmed(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsTextTrimmed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<RichTextBlockOverflow>, ptr<IsTextTrimmedChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichTextBlockOverflow3_adaptor::IsTextTrimmedChanged)->_add_IsTextTrimmedChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichTextBlockOverflow3_adaptor::IsTextTrimmedChanged)->_remove_IsTextTrimmedChanged(token)); }
		} IsTextTrimmedChanged;
	};
	IRichTextBlockOverflow3_adaptor() {}
};
template<typename X> struct adapt<IRichTextBlockOverflow3, X> : Windows::UI::Xaml::Controls::IRichTextBlockOverflow3_adaptor<X> { typedef adapt IRichTextBlockOverflow3; };
struct IRichTextBlockOverflow3 : IRichTextBlockOverflow3_raw, generate<IRichTextBlockOverflow3> {};

// IRichTextBlockOverflowStatics3
struct IRichTextBlockOverflowStatics3 : IInspectable {
	virtual STDMETHODIMP _get_IsTextTrimmedProperty(DependencyProperty* *value);
};

// ITextBlock
struct ITextBlock_raw : IInspectable {
	virtual STDMETHODIMP _get_FontSize(double *value);
	virtual STDMETHODIMP _put_FontSize(double value);
	virtual STDMETHODIMP _get_FontFamily(Media::FontFamily* *value);
	virtual STDMETHODIMP _put_FontFamily(Media::FontFamily* value);
	virtual STDMETHODIMP _get_FontWeight(Text::FontWeight *value);
	virtual STDMETHODIMP _put_FontWeight(Text::FontWeight value);
	virtual STDMETHODIMP _get_FontStyle(Text::FontStyle *value);
	virtual STDMETHODIMP _put_FontStyle(Text::FontStyle value);
	virtual STDMETHODIMP _get_FontStretch(Text::FontStretch *value);
	virtual STDMETHODIMP _put_FontStretch(Text::FontStretch value);
	virtual STDMETHODIMP _get_CharacterSpacing(int *value);
	virtual STDMETHODIMP _put_CharacterSpacing(int value);
	virtual STDMETHODIMP _get_Foreground(Media::Brush* *value);
	virtual STDMETHODIMP _put_Foreground(Media::Brush* value);
	virtual STDMETHODIMP _get_TextWrapping(Xaml::TextWrapping *value);
	virtual STDMETHODIMP _put_TextWrapping(Xaml::TextWrapping value);
	virtual STDMETHODIMP _get_TextTrimming(Xaml::TextTrimming *value);
	virtual STDMETHODIMP _put_TextTrimming(Xaml::TextTrimming value);
	virtual STDMETHODIMP _get_TextAlignment(Xaml::TextAlignment *value);
	virtual STDMETHODIMP _put_TextAlignment(Xaml::TextAlignment value);
	virtual STDMETHODIMP _get_Text(HSTRING *value);
	virtual STDMETHODIMP _put_Text(HSTRING value);
	virtual STDMETHODIMP _get_Inlines(Documents::InlineCollection* *value);
	virtual STDMETHODIMP _get_Padding(Thickness *value);
	virtual STDMETHODIMP _put_Padding(Thickness value);
	virtual STDMETHODIMP _get_LineHeight(double *value);
	virtual STDMETHODIMP _put_LineHeight(double value);
	virtual STDMETHODIMP _get_LineStackingStrategy(Xaml::LineStackingStrategy *value);
	virtual STDMETHODIMP _put_LineStackingStrategy(Xaml::LineStackingStrategy value);
	virtual STDMETHODIMP _get_IsTextSelectionEnabled(bool *value);
	virtual STDMETHODIMP _put_IsTextSelectionEnabled(bool value);
	virtual STDMETHODIMP _get_SelectedText(HSTRING *value);
	virtual STDMETHODIMP _get_ContentStart(Documents::TextPointer* *value);
	virtual STDMETHODIMP _get_ContentEnd(Documents::TextPointer* *value);
	virtual STDMETHODIMP _get_SelectionStart(Documents::TextPointer* *value);
	virtual STDMETHODIMP _get_SelectionEnd(Documents::TextPointer* *value);
	virtual STDMETHODIMP _get_BaselineOffset(double *value);
	virtual STDMETHODIMP _add_SelectionChanged(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SelectionChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ContextMenuOpening(ContextMenuOpeningEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ContextMenuOpening(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _SelectAll();
	virtual STDMETHODIMP _Select(Documents::TextPointer* start, Documents::TextPointer* end);
	virtual STDMETHODIMP _Focus(FocusState value, bool *returnValue);
};
template<typename X> struct ITextBlock_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&ITextBlock_adaptor::BaselineOffset)->_get_BaselineOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} BaselineOffset;
		struct : property {
			int get() { int value; hrcheck(enc(&ITextBlock_adaptor::CharacterSpacing)->_get_CharacterSpacing(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ITextBlock_adaptor::CharacterSpacing)->_put_CharacterSpacing(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} CharacterSpacing;
		struct : property {
			ptr<Documents::TextPointer> get() { Documents::TextPointer* value; hrcheck(enc(&ITextBlock_adaptor::ContentEnd)->_get_ContentEnd(&value)); return from_abi(value); }
			ptr<Documents::TextPointer> operator()() { return get(); }
			operator ptr<Documents::TextPointer> () { return get(); }
			ptr<Documents::TextPointer> operator->() { return get(); }
		} ContentEnd;
		struct : property {
			ptr<Documents::TextPointer> get() { Documents::TextPointer* value; hrcheck(enc(&ITextBlock_adaptor::ContentStart)->_get_ContentStart(&value)); return from_abi(value); }
			ptr<Documents::TextPointer> operator()() { return get(); }
			operator ptr<Documents::TextPointer> () { return get(); }
			ptr<Documents::TextPointer> operator->() { return get(); }
		} ContentStart;
		struct : property {
			ptr<Media::FontFamily> get() { Media::FontFamily* value; hrcheck(enc(&ITextBlock_adaptor::FontFamily)->_get_FontFamily(&value)); return from_abi(value); }
			ptr<Media::FontFamily> operator()() { return get(); }
			operator ptr<Media::FontFamily> () { return get(); }
			ptr<Media::FontFamily> operator->() { return get(); }
			void put(pptr<Media::FontFamily> value) { hrcheck(enc(&ITextBlock_adaptor::FontFamily)->_put_FontFamily(value)); }
			void operator=(pptr<Media::FontFamily> value) { put(value); }
			void operator()(pptr<Media::FontFamily> value) { put(value); }
		} FontFamily;
		struct : property {
			double get() { double value; hrcheck(enc(&ITextBlock_adaptor::FontSize)->_get_FontSize(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ITextBlock_adaptor::FontSize)->_put_FontSize(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FontSize;
		struct : property {
			Text::FontStretch get() { Text::FontStretch value; hrcheck(enc(&ITextBlock_adaptor::FontStretch)->_get_FontStretch(&value)); return value; }
			Text::FontStretch operator()() { return get(); }
			operator Text::FontStretch () { return get(); }
			void put(Text::FontStretch value) { hrcheck(enc(&ITextBlock_adaptor::FontStretch)->_put_FontStretch(value)); }
			void operator=(Text::FontStretch value) { put(value); }
			void operator()(Text::FontStretch value) { put(value); }
		} FontStretch;
		struct : property {
			Text::FontStyle get() { Text::FontStyle value; hrcheck(enc(&ITextBlock_adaptor::FontStyle)->_get_FontStyle(&value)); return value; }
			Text::FontStyle operator()() { return get(); }
			operator Text::FontStyle () { return get(); }
			void put(Text::FontStyle value) { hrcheck(enc(&ITextBlock_adaptor::FontStyle)->_put_FontStyle(value)); }
			void operator=(Text::FontStyle value) { put(value); }
			void operator()(Text::FontStyle value) { put(value); }
		} FontStyle;
		struct : property {
			Text::FontWeight get() { Text::FontWeight value; hrcheck(enc(&ITextBlock_adaptor::FontWeight)->_get_FontWeight(&value)); return value; }
			Text::FontWeight operator()() { return get(); }
			operator Text::FontWeight () { return get(); }
			void put(const Text::FontWeight& value) { hrcheck(enc(&ITextBlock_adaptor::FontWeight)->_put_FontWeight(value)); }
			void operator=(const Text::FontWeight& value) { put(value); }
			void operator()(const Text::FontWeight& value) { put(value); }
		} FontWeight;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ITextBlock_adaptor::Foreground)->_get_Foreground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ITextBlock_adaptor::Foreground)->_put_Foreground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Foreground;
		struct : property {
			ptr<Documents::InlineCollection> get() { Documents::InlineCollection* value; hrcheck(enc(&ITextBlock_adaptor::Inlines)->_get_Inlines(&value)); return from_abi(value); }
			ptr<Documents::InlineCollection> operator()() { return get(); }
			operator ptr<Documents::InlineCollection> () { return get(); }
			ptr<Documents::InlineCollection> operator->() { return get(); }
		} Inlines;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextBlock_adaptor::IsTextSelectionEnabled)->_get_IsTextSelectionEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextBlock_adaptor::IsTextSelectionEnabled)->_put_IsTextSelectionEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTextSelectionEnabled;
		struct : property {
			double get() { double value; hrcheck(enc(&ITextBlock_adaptor::LineHeight)->_get_LineHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ITextBlock_adaptor::LineHeight)->_put_LineHeight(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} LineHeight;
		struct : property {
			Xaml::LineStackingStrategy get() { Xaml::LineStackingStrategy value; hrcheck(enc(&ITextBlock_adaptor::LineStackingStrategy)->_get_LineStackingStrategy(&value)); return value; }
			Xaml::LineStackingStrategy operator()() { return get(); }
			operator Xaml::LineStackingStrategy () { return get(); }
			void put(Xaml::LineStackingStrategy value) { hrcheck(enc(&ITextBlock_adaptor::LineStackingStrategy)->_put_LineStackingStrategy(value)); }
			void operator=(Xaml::LineStackingStrategy value) { put(value); }
			void operator()(Xaml::LineStackingStrategy value) { put(value); }
		} LineStackingStrategy;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&ITextBlock_adaptor::Padding)->_get_Padding(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&ITextBlock_adaptor::Padding)->_put_Padding(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} Padding;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITextBlock_adaptor::SelectedText)->_get_SelectedText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} SelectedText;
		struct : property {
			ptr<Documents::TextPointer> get() { Documents::TextPointer* value; hrcheck(enc(&ITextBlock_adaptor::SelectionEnd)->_get_SelectionEnd(&value)); return from_abi(value); }
			ptr<Documents::TextPointer> operator()() { return get(); }
			operator ptr<Documents::TextPointer> () { return get(); }
			ptr<Documents::TextPointer> operator->() { return get(); }
		} SelectionEnd;
		struct : property {
			ptr<Documents::TextPointer> get() { Documents::TextPointer* value; hrcheck(enc(&ITextBlock_adaptor::SelectionStart)->_get_SelectionStart(&value)); return from_abi(value); }
			ptr<Documents::TextPointer> operator()() { return get(); }
			operator ptr<Documents::TextPointer> () { return get(); }
			ptr<Documents::TextPointer> operator->() { return get(); }
		} SelectionStart;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITextBlock_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITextBlock_adaptor::Text)->_put_Text(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Text;
		struct : property {
			Xaml::TextAlignment get() { Xaml::TextAlignment value; hrcheck(enc(&ITextBlock_adaptor::TextAlignment)->_get_TextAlignment(&value)); return value; }
			Xaml::TextAlignment operator()() { return get(); }
			operator Xaml::TextAlignment () { return get(); }
			void put(Xaml::TextAlignment value) { hrcheck(enc(&ITextBlock_adaptor::TextAlignment)->_put_TextAlignment(value)); }
			void operator=(Xaml::TextAlignment value) { put(value); }
			void operator()(Xaml::TextAlignment value) { put(value); }
		} TextAlignment;
		struct : property {
			Xaml::TextTrimming get() { Xaml::TextTrimming value; hrcheck(enc(&ITextBlock_adaptor::TextTrimming)->_get_TextTrimming(&value)); return value; }
			Xaml::TextTrimming operator()() { return get(); }
			operator Xaml::TextTrimming () { return get(); }
			void put(Xaml::TextTrimming value) { hrcheck(enc(&ITextBlock_adaptor::TextTrimming)->_put_TextTrimming(value)); }
			void operator=(Xaml::TextTrimming value) { put(value); }
			void operator()(Xaml::TextTrimming value) { put(value); }
		} TextTrimming;
		struct : property {
			Xaml::TextWrapping get() { Xaml::TextWrapping value; hrcheck(enc(&ITextBlock_adaptor::TextWrapping)->_get_TextWrapping(&value)); return value; }
			Xaml::TextWrapping operator()() { return get(); }
			operator Xaml::TextWrapping () { return get(); }
			void put(Xaml::TextWrapping value) { hrcheck(enc(&ITextBlock_adaptor::TextWrapping)->_put_TextWrapping(value)); }
			void operator=(Xaml::TextWrapping value) { put(value); }
			void operator()(Xaml::TextWrapping value) { put(value); }
		} TextWrapping;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<ContextMenuOpeningEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITextBlock_adaptor::ContextMenuOpening)->_add_ContextMenuOpening(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITextBlock_adaptor::ContextMenuOpening)->_remove_ContextMenuOpening(token)); }
		} ContextMenuOpening;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITextBlock_adaptor::SelectionChanged)->_add_SelectionChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITextBlock_adaptor::SelectionChanged)->_remove_SelectionChanged(token)); }
		} SelectionChanged;
	};
	void SelectAll() { hrcheck(X::get()->_SelectAll()); }
	void Select(pptr<Documents::TextPointer> start, pptr<Documents::TextPointer> end) { hrcheck(X::get()->_Select(start, end)); }
	bool Focus(FocusState value) { bool returnValue; hrcheck(X::get()->_Focus(value, &returnValue)); return returnValue; }
	ITextBlock_adaptor() {}
};
template<typename X> struct adapt<ITextBlock, X> : Windows::UI::Xaml::Controls::ITextBlock_adaptor<X> { typedef adapt ITextBlock; };
struct ITextBlock : ITextBlock_raw, generate<ITextBlock> {};

// ITextBlockStatics
struct ITextBlockStatics : IInspectable {
	virtual STDMETHODIMP _get_FontSizeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontFamilyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontWeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontStretchProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CharacterSpacingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ForegroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextWrappingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextTrimmingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PaddingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_LineHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_LineStackingStrategyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsTextSelectionEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedTextProperty(DependencyProperty* *value);
};

// ITextBlock2
struct ITextBlock2_raw : IInspectable {
	virtual STDMETHODIMP _get_SelectionHighlightColor(Media::SolidColorBrush* *value);
	virtual STDMETHODIMP _put_SelectionHighlightColor(Media::SolidColorBrush* value);
	virtual STDMETHODIMP _get_MaxLines(int *value);
	virtual STDMETHODIMP _put_MaxLines(int value);
	virtual STDMETHODIMP _get_TextLineBounds(Xaml::TextLineBounds *value);
	virtual STDMETHODIMP _put_TextLineBounds(Xaml::TextLineBounds value);
	virtual STDMETHODIMP _get_OpticalMarginAlignment(Xaml::OpticalMarginAlignment *value);
	virtual STDMETHODIMP _put_OpticalMarginAlignment(Xaml::OpticalMarginAlignment value);
	virtual STDMETHODIMP _get_IsColorFontEnabled(bool *value);
	virtual STDMETHODIMP _put_IsColorFontEnabled(bool value);
	virtual STDMETHODIMP _get_TextReadingOrder(Xaml::TextReadingOrder *value);
	virtual STDMETHODIMP _put_TextReadingOrder(Xaml::TextReadingOrder value);
};
template<typename X> struct ITextBlock2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextBlock2_adaptor::IsColorFontEnabled)->_get_IsColorFontEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextBlock2_adaptor::IsColorFontEnabled)->_put_IsColorFontEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsColorFontEnabled;
		struct : property {
			int get() { int value; hrcheck(enc(&ITextBlock2_adaptor::MaxLines)->_get_MaxLines(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ITextBlock2_adaptor::MaxLines)->_put_MaxLines(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaxLines;
		struct : property {
			Xaml::OpticalMarginAlignment get() { Xaml::OpticalMarginAlignment value; hrcheck(enc(&ITextBlock2_adaptor::OpticalMarginAlignment)->_get_OpticalMarginAlignment(&value)); return value; }
			Xaml::OpticalMarginAlignment operator()() { return get(); }
			operator Xaml::OpticalMarginAlignment () { return get(); }
			void put(Xaml::OpticalMarginAlignment value) { hrcheck(enc(&ITextBlock2_adaptor::OpticalMarginAlignment)->_put_OpticalMarginAlignment(value)); }
			void operator=(Xaml::OpticalMarginAlignment value) { put(value); }
			void operator()(Xaml::OpticalMarginAlignment value) { put(value); }
		} OpticalMarginAlignment;
		struct : property {
			ptr<Media::SolidColorBrush> get() { Media::SolidColorBrush* value; hrcheck(enc(&ITextBlock2_adaptor::SelectionHighlightColor)->_get_SelectionHighlightColor(&value)); return from_abi(value); }
			ptr<Media::SolidColorBrush> operator()() { return get(); }
			operator ptr<Media::SolidColorBrush> () { return get(); }
			ptr<Media::SolidColorBrush> operator->() { return get(); }
			void put(pptr<Media::SolidColorBrush> value) { hrcheck(enc(&ITextBlock2_adaptor::SelectionHighlightColor)->_put_SelectionHighlightColor(value)); }
			void operator=(pptr<Media::SolidColorBrush> value) { put(value); }
			void operator()(pptr<Media::SolidColorBrush> value) { put(value); }
		} SelectionHighlightColor;
		struct : property {
			Xaml::TextLineBounds get() { Xaml::TextLineBounds value; hrcheck(enc(&ITextBlock2_adaptor::TextLineBounds)->_get_TextLineBounds(&value)); return value; }
			Xaml::TextLineBounds operator()() { return get(); }
			operator Xaml::TextLineBounds () { return get(); }
			void put(Xaml::TextLineBounds value) { hrcheck(enc(&ITextBlock2_adaptor::TextLineBounds)->_put_TextLineBounds(value)); }
			void operator=(Xaml::TextLineBounds value) { put(value); }
			void operator()(Xaml::TextLineBounds value) { put(value); }
		} TextLineBounds;
		struct : property {
			Xaml::TextReadingOrder get() { Xaml::TextReadingOrder value; hrcheck(enc(&ITextBlock2_adaptor::TextReadingOrder)->_get_TextReadingOrder(&value)); return value; }
			Xaml::TextReadingOrder operator()() { return get(); }
			operator Xaml::TextReadingOrder () { return get(); }
			void put(Xaml::TextReadingOrder value) { hrcheck(enc(&ITextBlock2_adaptor::TextReadingOrder)->_put_TextReadingOrder(value)); }
			void operator=(Xaml::TextReadingOrder value) { put(value); }
			void operator()(Xaml::TextReadingOrder value) { put(value); }
		} TextReadingOrder;
	};
	ITextBlock2_adaptor() {}
};
template<typename X> struct adapt<ITextBlock2, X> : Windows::UI::Xaml::Controls::ITextBlock2_adaptor<X> { typedef adapt ITextBlock2; };
struct ITextBlock2 : ITextBlock2_raw, generate<ITextBlock2> {};

// ITextBlockStatics2
struct ITextBlockStatics2 : IInspectable {
	virtual STDMETHODIMP _get_SelectionHighlightColorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxLinesProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextLineBoundsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OpticalMarginAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsColorFontEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextReadingOrderProperty(DependencyProperty* *value);
};

// ITextBlock3
struct ITextBlock3_raw : IInspectable {
	virtual STDMETHODIMP _get_IsTextScaleFactorEnabled(bool *value);
	virtual STDMETHODIMP _put_IsTextScaleFactorEnabled(bool value);
};
template<typename X> struct ITextBlock3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextBlock3_adaptor::IsTextScaleFactorEnabled)->_get_IsTextScaleFactorEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextBlock3_adaptor::IsTextScaleFactorEnabled)->_put_IsTextScaleFactorEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTextScaleFactorEnabled;
	};
	ITextBlock3_adaptor() {}
};
template<typename X> struct adapt<ITextBlock3, X> : Windows::UI::Xaml::Controls::ITextBlock3_adaptor<X> { typedef adapt ITextBlock3; };
struct ITextBlock3 : ITextBlock3_raw, generate<ITextBlock3> {};

// ITextBlockStatics3
struct ITextBlockStatics3 : IInspectable {
	virtual STDMETHODIMP _get_IsTextScaleFactorEnabledProperty(DependencyProperty* *value);
};

// ITextBlock4
struct ITextBlock4_raw : IInspectable {
	virtual STDMETHODIMP _GetAlphaMask(Composition::CompositionBrush* *returnValue);
};
template<typename X> struct ITextBlock4_adaptor : X {
	ptr<Composition::CompositionBrush> GetAlphaMask() { Composition::CompositionBrush* returnValue; hrcheck(X::get()->_GetAlphaMask(&returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<ITextBlock4, X> : Windows::UI::Xaml::Controls::ITextBlock4_adaptor<X> { typedef adapt ITextBlock4; };
struct ITextBlock4 : ITextBlock4_raw, generate<ITextBlock4> {};

// ITextBlock5
struct ITextBlock5_raw : IInspectable {
	virtual STDMETHODIMP _get_TextDecorations(Text::TextDecorations *value);
	virtual STDMETHODIMP _put_TextDecorations(Text::TextDecorations value);
};
template<typename X> struct ITextBlock5_adaptor : X {
	union {
		struct : property {
			Text::TextDecorations get() { Text::TextDecorations value; hrcheck(enc(&ITextBlock5_adaptor::TextDecorations)->_get_TextDecorations(&value)); return value; }
			Text::TextDecorations operator()() { return get(); }
			operator Text::TextDecorations () { return get(); }
			void put(Text::TextDecorations value) { hrcheck(enc(&ITextBlock5_adaptor::TextDecorations)->_put_TextDecorations(value)); }
			void operator=(Text::TextDecorations value) { put(value); }
			void operator()(Text::TextDecorations value) { put(value); }
		} TextDecorations;
	};
	ITextBlock5_adaptor() {}
};
template<typename X> struct adapt<ITextBlock5, X> : Windows::UI::Xaml::Controls::ITextBlock5_adaptor<X> { typedef adapt ITextBlock5; };
struct ITextBlock5 : ITextBlock5_raw, generate<ITextBlock5> {};

// ITextBlockStatics5
struct ITextBlockStatics5 : IInspectable {
	virtual STDMETHODIMP _get_TextDecorationsProperty(DependencyProperty* *value);
};

// ITextBlock6
struct ITextBlock6_raw : IInspectable {
	virtual STDMETHODIMP _get_IsTextTrimmed(bool *value);
	virtual STDMETHODIMP _get_HorizontalTextAlignment(TextAlignment *value);
	virtual STDMETHODIMP _put_HorizontalTextAlignment(TextAlignment value);
	virtual STDMETHODIMP _get_TextHighlighters(Foundation::Collections::IVector<Documents::TextHighlighter*>* *value);
	virtual STDMETHODIMP _add_IsTextTrimmedChanged(Foundation::TypedEventHandler<TextBlock*, IsTextTrimmedChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_IsTextTrimmedChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct ITextBlock6_adaptor : X {
	union {
		struct : property {
			TextAlignment get() { TextAlignment value; hrcheck(enc(&ITextBlock6_adaptor::HorizontalTextAlignment)->_get_HorizontalTextAlignment(&value)); return value; }
			TextAlignment operator()() { return get(); }
			operator TextAlignment () { return get(); }
			void put(TextAlignment value) { hrcheck(enc(&ITextBlock6_adaptor::HorizontalTextAlignment)->_put_HorizontalTextAlignment(value)); }
			void operator=(TextAlignment value) { put(value); }
			void operator()(TextAlignment value) { put(value); }
		} HorizontalTextAlignment;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextBlock6_adaptor::IsTextTrimmed)->_get_IsTextTrimmed(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsTextTrimmed;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Documents::TextHighlighter>>> get() { Foundation::Collections::IVector<Documents::TextHighlighter*>* value; hrcheck(enc(&ITextBlock6_adaptor::TextHighlighters)->_get_TextHighlighters(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Documents::TextHighlighter>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Documents::TextHighlighter>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Documents::TextHighlighter>>> operator->() { return get(); }
		} TextHighlighters;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TextBlock>, ptr<IsTextTrimmedChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITextBlock6_adaptor::IsTextTrimmedChanged)->_add_IsTextTrimmedChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITextBlock6_adaptor::IsTextTrimmedChanged)->_remove_IsTextTrimmedChanged(token)); }
		} IsTextTrimmedChanged;
	};
	ITextBlock6_adaptor() {}
};
template<typename X> struct adapt<ITextBlock6, X> : Windows::UI::Xaml::Controls::ITextBlock6_adaptor<X> { typedef adapt ITextBlock6; };
struct ITextBlock6 : ITextBlock6_raw, generate<ITextBlock6> {};

// ITextBlockStatics6
struct ITextBlockStatics6 : IInspectable {
	virtual STDMETHODIMP _get_IsTextTrimmedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalTextAlignmentProperty(DependencyProperty* *value);
};

// IViewbox
struct IViewbox_raw : IInspectable {
	virtual STDMETHODIMP _get_Child(UIElement* *value);
	virtual STDMETHODIMP _put_Child(UIElement* value);
	virtual STDMETHODIMP _get_Stretch(Media::Stretch *value);
	virtual STDMETHODIMP _put_Stretch(Media::Stretch value);
	virtual STDMETHODIMP _get_StretchDirection(Controls::StretchDirection *value);
	virtual STDMETHODIMP _put_StretchDirection(Controls::StretchDirection value);
};
template<typename X> struct IViewbox_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IViewbox_adaptor::Child)->_get_Child(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IViewbox_adaptor::Child)->_put_Child(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} Child;
		struct : property {
			Media::Stretch get() { Media::Stretch value; hrcheck(enc(&IViewbox_adaptor::Stretch)->_get_Stretch(&value)); return value; }
			Media::Stretch operator()() { return get(); }
			operator Media::Stretch () { return get(); }
			void put(Media::Stretch value) { hrcheck(enc(&IViewbox_adaptor::Stretch)->_put_Stretch(value)); }
			void operator=(Media::Stretch value) { put(value); }
			void operator()(Media::Stretch value) { put(value); }
		} Stretch;
		struct : property {
			Controls::StretchDirection get() { Controls::StretchDirection value; hrcheck(enc(&IViewbox_adaptor::StretchDirection)->_get_StretchDirection(&value)); return value; }
			Controls::StretchDirection operator()() { return get(); }
			operator Controls::StretchDirection () { return get(); }
			void put(Controls::StretchDirection value) { hrcheck(enc(&IViewbox_adaptor::StretchDirection)->_put_StretchDirection(value)); }
			void operator=(Controls::StretchDirection value) { put(value); }
			void operator()(Controls::StretchDirection value) { put(value); }
		} StretchDirection;
	};
	IViewbox_adaptor() {}
};
template<typename X> struct adapt<IViewbox, X> : Windows::UI::Xaml::Controls::IViewbox_adaptor<X> { typedef adapt IViewbox; };
struct IViewbox : IViewbox_raw, generate<IViewbox> {};

// IViewboxStatics
struct IViewboxStatics : IInspectable {
	virtual STDMETHODIMP _get_StretchProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_StretchDirectionProperty(DependencyProperty* *value);
};

// IGrid
struct IGrid_raw : IInspectable {
	virtual STDMETHODIMP _get_RowDefinitions(RowDefinitionCollection* *value);
	virtual STDMETHODIMP _get_ColumnDefinitions(ColumnDefinitionCollection* *value);
};
template<typename X> struct IGrid_adaptor : X {
	union {
		struct : property {
			ptr<ColumnDefinitionCollection> get() { ColumnDefinitionCollection* value; hrcheck(enc(&IGrid_adaptor::ColumnDefinitions)->_get_ColumnDefinitions(&value)); return from_abi(value); }
			ptr<ColumnDefinitionCollection> operator()() { return get(); }
			operator ptr<ColumnDefinitionCollection> () { return get(); }
			ptr<ColumnDefinitionCollection> operator->() { return get(); }
		} ColumnDefinitions;
		struct : property {
			ptr<RowDefinitionCollection> get() { RowDefinitionCollection* value; hrcheck(enc(&IGrid_adaptor::RowDefinitions)->_get_RowDefinitions(&value)); return from_abi(value); }
			ptr<RowDefinitionCollection> operator()() { return get(); }
			operator ptr<RowDefinitionCollection> () { return get(); }
			ptr<RowDefinitionCollection> operator->() { return get(); }
		} RowDefinitions;
	};
	IGrid_adaptor() {}
};
template<typename X> struct adapt<IGrid, X> : Windows::UI::Xaml::Controls::IGrid_adaptor<X> { typedef adapt IGrid; };
struct IGrid : IGrid_raw, generate<IGrid> {};

// IGridStatics
struct IGridStatics : IInspectable {
	virtual STDMETHODIMP _get_RowProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetRow(FrameworkElement* element, int *value);
	virtual STDMETHODIMP _SetRow(FrameworkElement* element, int value);
	virtual STDMETHODIMP _get_ColumnProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetColumn(FrameworkElement* element, int *value);
	virtual STDMETHODIMP _SetColumn(FrameworkElement* element, int value);
	virtual STDMETHODIMP _get_RowSpanProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetRowSpan(FrameworkElement* element, int *value);
	virtual STDMETHODIMP _SetRowSpan(FrameworkElement* element, int value);
	virtual STDMETHODIMP _get_ColumnSpanProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetColumnSpan(FrameworkElement* element, int *value);
	virtual STDMETHODIMP _SetColumnSpan(FrameworkElement* element, int value);
};

// IGridFactory
struct IGridFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Grid* *instance);
};

// IGrid2
struct IGrid2_raw : IInspectable {
	virtual STDMETHODIMP _get_BorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_BorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_BorderThickness(Thickness *value);
	virtual STDMETHODIMP _put_BorderThickness(Thickness value);
	virtual STDMETHODIMP _get_CornerRadius(Xaml::CornerRadius *value);
	virtual STDMETHODIMP _put_CornerRadius(Xaml::CornerRadius value);
	virtual STDMETHODIMP _get_Padding(Thickness *value);
	virtual STDMETHODIMP _put_Padding(Thickness value);
};
template<typename X> struct IGrid2_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IGrid2_adaptor::BorderBrush)->_get_BorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IGrid2_adaptor::BorderBrush)->_put_BorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} BorderBrush;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IGrid2_adaptor::BorderThickness)->_get_BorderThickness(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IGrid2_adaptor::BorderThickness)->_put_BorderThickness(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} BorderThickness;
		struct : property {
			Xaml::CornerRadius get() { Xaml::CornerRadius value; hrcheck(enc(&IGrid2_adaptor::CornerRadius)->_get_CornerRadius(&value)); return value; }
			Xaml::CornerRadius operator()() { return get(); }
			operator Xaml::CornerRadius () { return get(); }
			void put(const Xaml::CornerRadius& value) { hrcheck(enc(&IGrid2_adaptor::CornerRadius)->_put_CornerRadius(value)); }
			void operator=(const Xaml::CornerRadius& value) { put(value); }
			void operator()(const Xaml::CornerRadius& value) { put(value); }
		} CornerRadius;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IGrid2_adaptor::Padding)->_get_Padding(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IGrid2_adaptor::Padding)->_put_Padding(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} Padding;
	};
	IGrid2_adaptor() {}
};
template<typename X> struct adapt<IGrid2, X> : Windows::UI::Xaml::Controls::IGrid2_adaptor<X> { typedef adapt IGrid2; };
struct IGrid2 : IGrid2_raw, generate<IGrid2> {};

// IGridStatics2
struct IGridStatics2 : IInspectable {
	virtual STDMETHODIMP _get_BorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BorderThicknessProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CornerRadiusProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PaddingProperty(DependencyProperty* *value);
};

// IGrid3
struct IGrid3_raw : IInspectable {
	virtual STDMETHODIMP _get_RowSpacing(double *value);
	virtual STDMETHODIMP _put_RowSpacing(double value);
	virtual STDMETHODIMP _get_ColumnSpacing(double *value);
	virtual STDMETHODIMP _put_ColumnSpacing(double value);
};
template<typename X> struct IGrid3_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IGrid3_adaptor::ColumnSpacing)->_get_ColumnSpacing(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IGrid3_adaptor::ColumnSpacing)->_put_ColumnSpacing(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ColumnSpacing;
		struct : property {
			double get() { double value; hrcheck(enc(&IGrid3_adaptor::RowSpacing)->_get_RowSpacing(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IGrid3_adaptor::RowSpacing)->_put_RowSpacing(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} RowSpacing;
	};
	IGrid3_adaptor() {}
};
template<typename X> struct adapt<IGrid3, X> : Windows::UI::Xaml::Controls::IGrid3_adaptor<X> { typedef adapt IGrid3; };
struct IGrid3 : IGrid3_raw, generate<IGrid3> {};

// IGridStatics3
struct IGridStatics3 : IInspectable {
	virtual STDMETHODIMP _get_RowSpacingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ColumnSpacingProperty(DependencyProperty* *value);
};

// IHandwritingView
struct IHandwritingView_raw : IInspectable {
	virtual STDMETHODIMP _get_PlacementTarget(UIElement* *value);
	virtual STDMETHODIMP _put_PlacementTarget(UIElement* value);
	virtual STDMETHODIMP _get_PlacementAlignment(HandwritingPanelPlacementAlignment *value);
	virtual STDMETHODIMP _put_PlacementAlignment(HandwritingPanelPlacementAlignment value);
	virtual STDMETHODIMP _get_IsOpen(bool *value);
	virtual STDMETHODIMP _get_AreCandidatesEnabled(bool *value);
	virtual STDMETHODIMP _put_AreCandidatesEnabled(bool value);
	virtual STDMETHODIMP _add_Opened(Foundation::TypedEventHandler<HandwritingView*, HandwritingPanelOpenedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Opened(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Closed(Foundation::TypedEventHandler<HandwritingView*, HandwritingPanelClosedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Closed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _TryClose(bool *result);
	virtual STDMETHODIMP _TryOpen(bool *result);
};
template<typename X> struct IHandwritingView_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IHandwritingView_adaptor::AreCandidatesEnabled)->_get_AreCandidatesEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IHandwritingView_adaptor::AreCandidatesEnabled)->_put_AreCandidatesEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AreCandidatesEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IHandwritingView_adaptor::IsOpen)->_get_IsOpen(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsOpen;
		struct : property {
			HandwritingPanelPlacementAlignment get() { HandwritingPanelPlacementAlignment value; hrcheck(enc(&IHandwritingView_adaptor::PlacementAlignment)->_get_PlacementAlignment(&value)); return value; }
			HandwritingPanelPlacementAlignment operator()() { return get(); }
			operator HandwritingPanelPlacementAlignment () { return get(); }
			void put(HandwritingPanelPlacementAlignment value) { hrcheck(enc(&IHandwritingView_adaptor::PlacementAlignment)->_put_PlacementAlignment(value)); }
			void operator=(HandwritingPanelPlacementAlignment value) { put(value); }
			void operator()(HandwritingPanelPlacementAlignment value) { put(value); }
		} PlacementAlignment;
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IHandwritingView_adaptor::PlacementTarget)->_get_PlacementTarget(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IHandwritingView_adaptor::PlacementTarget)->_put_PlacementTarget(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} PlacementTarget;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<HandwritingView>, ptr<HandwritingPanelClosedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IHandwritingView_adaptor::Closed)->_add_Closed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IHandwritingView_adaptor::Closed)->_remove_Closed(token)); }
		} Closed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<HandwritingView>, ptr<HandwritingPanelOpenedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IHandwritingView_adaptor::Opened)->_add_Opened(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IHandwritingView_adaptor::Opened)->_remove_Opened(token)); }
		} Opened;
	};
	bool TryClose() { bool result; hrcheck(X::get()->_TryClose(&result)); return result; }
	bool TryOpen() { bool result; hrcheck(X::get()->_TryOpen(&result)); return result; }
	IHandwritingView_adaptor() {}
};
template<typename X> struct adapt<IHandwritingView, X> : Windows::UI::Xaml::Controls::IHandwritingView_adaptor<X> { typedef adapt IHandwritingView; };
struct IHandwritingView : IHandwritingView_raw, generate<IHandwritingView> {};

// IHandwritingViewStatics
struct IHandwritingViewStatics : IInspectable {
	virtual STDMETHODIMP _get_PlacementTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlacementAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsOpenProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AreCandidatesEnabledProperty(DependencyProperty* *value);
};

// IHandwritingViewFactory
struct IHandwritingViewFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, HandwritingView* *instance);
};

// IMediaTransportControls
struct IMediaTransportControls_raw : IInspectable {
	virtual STDMETHODIMP _get_IsFullWindowButtonVisible(bool *value);
	virtual STDMETHODIMP _put_IsFullWindowButtonVisible(bool value);
	virtual STDMETHODIMP _get_IsFullWindowEnabled(bool *value);
	virtual STDMETHODIMP _put_IsFullWindowEnabled(bool value);
	virtual STDMETHODIMP _get_IsZoomButtonVisible(bool *value);
	virtual STDMETHODIMP _put_IsZoomButtonVisible(bool value);
	virtual STDMETHODIMP _get_IsZoomEnabled(bool *value);
	virtual STDMETHODIMP _put_IsZoomEnabled(bool value);
	virtual STDMETHODIMP _get_IsFastForwardButtonVisible(bool *value);
	virtual STDMETHODIMP _put_IsFastForwardButtonVisible(bool value);
	virtual STDMETHODIMP _get_IsFastForwardEnabled(bool *value);
	virtual STDMETHODIMP _put_IsFastForwardEnabled(bool value);
	virtual STDMETHODIMP _get_IsFastRewindButtonVisible(bool *value);
	virtual STDMETHODIMP _put_IsFastRewindButtonVisible(bool value);
	virtual STDMETHODIMP _get_IsFastRewindEnabled(bool *value);
	virtual STDMETHODIMP _put_IsFastRewindEnabled(bool value);
	virtual STDMETHODIMP _get_IsStopButtonVisible(bool *value);
	virtual STDMETHODIMP _put_IsStopButtonVisible(bool value);
	virtual STDMETHODIMP _get_IsStopEnabled(bool *value);
	virtual STDMETHODIMP _put_IsStopEnabled(bool value);
	virtual STDMETHODIMP _get_IsVolumeButtonVisible(bool *value);
	virtual STDMETHODIMP _put_IsVolumeButtonVisible(bool value);
	virtual STDMETHODIMP _get_IsVolumeEnabled(bool *value);
	virtual STDMETHODIMP _put_IsVolumeEnabled(bool value);
	virtual STDMETHODIMP _get_IsPlaybackRateButtonVisible(bool *value);
	virtual STDMETHODIMP _put_IsPlaybackRateButtonVisible(bool value);
	virtual STDMETHODIMP _get_IsPlaybackRateEnabled(bool *value);
	virtual STDMETHODIMP _put_IsPlaybackRateEnabled(bool value);
	virtual STDMETHODIMP _get_IsSeekBarVisible(bool *value);
	virtual STDMETHODIMP _put_IsSeekBarVisible(bool value);
	virtual STDMETHODIMP _get_IsSeekEnabled(bool *value);
	virtual STDMETHODIMP _put_IsSeekEnabled(bool value);
	virtual STDMETHODIMP _get_IsCompact(bool *value);
	virtual STDMETHODIMP _put_IsCompact(bool value);
};
template<typename X> struct IMediaTransportControls_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsCompact)->_get_IsCompact(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsCompact)->_put_IsCompact(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsCompact;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsFastForwardButtonVisible)->_get_IsFastForwardButtonVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsFastForwardButtonVisible)->_put_IsFastForwardButtonVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsFastForwardButtonVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsFastForwardEnabled)->_get_IsFastForwardEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsFastForwardEnabled)->_put_IsFastForwardEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsFastForwardEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsFastRewindButtonVisible)->_get_IsFastRewindButtonVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsFastRewindButtonVisible)->_put_IsFastRewindButtonVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsFastRewindButtonVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsFastRewindEnabled)->_get_IsFastRewindEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsFastRewindEnabled)->_put_IsFastRewindEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsFastRewindEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsFullWindowButtonVisible)->_get_IsFullWindowButtonVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsFullWindowButtonVisible)->_put_IsFullWindowButtonVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsFullWindowButtonVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsFullWindowEnabled)->_get_IsFullWindowEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsFullWindowEnabled)->_put_IsFullWindowEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsFullWindowEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsPlaybackRateButtonVisible)->_get_IsPlaybackRateButtonVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsPlaybackRateButtonVisible)->_put_IsPlaybackRateButtonVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsPlaybackRateButtonVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsPlaybackRateEnabled)->_get_IsPlaybackRateEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsPlaybackRateEnabled)->_put_IsPlaybackRateEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsPlaybackRateEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsSeekBarVisible)->_get_IsSeekBarVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsSeekBarVisible)->_put_IsSeekBarVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSeekBarVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsSeekEnabled)->_get_IsSeekEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsSeekEnabled)->_put_IsSeekEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSeekEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsStopButtonVisible)->_get_IsStopButtonVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsStopButtonVisible)->_put_IsStopButtonVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsStopButtonVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsStopEnabled)->_get_IsStopEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsStopEnabled)->_put_IsStopEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsStopEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsVolumeButtonVisible)->_get_IsVolumeButtonVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsVolumeButtonVisible)->_put_IsVolumeButtonVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsVolumeButtonVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsVolumeEnabled)->_get_IsVolumeEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsVolumeEnabled)->_put_IsVolumeEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsVolumeEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsZoomButtonVisible)->_get_IsZoomButtonVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsZoomButtonVisible)->_put_IsZoomButtonVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsZoomButtonVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls_adaptor::IsZoomEnabled)->_get_IsZoomEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls_adaptor::IsZoomEnabled)->_put_IsZoomEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsZoomEnabled;
	};
	IMediaTransportControls_adaptor() {}
};
template<typename X> struct adapt<IMediaTransportControls, X> : Windows::UI::Xaml::Controls::IMediaTransportControls_adaptor<X> { typedef adapt IMediaTransportControls; };
struct IMediaTransportControls : IMediaTransportControls_raw, generate<IMediaTransportControls> {};

// IMediaTransportControlsStatics
struct IMediaTransportControlsStatics : IInspectable {
	virtual STDMETHODIMP _get_IsFullWindowButtonVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsFullWindowEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsZoomButtonVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsZoomEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsFastForwardButtonVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsFastForwardEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsFastRewindButtonVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsFastRewindEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsStopButtonVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsStopEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsVolumeButtonVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsVolumeEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsPlaybackRateButtonVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsPlaybackRateEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsSeekBarVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsSeekEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsCompactProperty(DependencyProperty* *value);
};

// IMediaTransportControlsFactory
struct IMediaTransportControlsFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, MediaTransportControls* *instance);
};

// IMediaTransportControls2
struct IMediaTransportControls2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsSkipForwardButtonVisible(bool *value);
	virtual STDMETHODIMP _put_IsSkipForwardButtonVisible(bool value);
	virtual STDMETHODIMP _get_IsSkipForwardEnabled(bool *value);
	virtual STDMETHODIMP _put_IsSkipForwardEnabled(bool value);
	virtual STDMETHODIMP _get_IsSkipBackwardButtonVisible(bool *value);
	virtual STDMETHODIMP _put_IsSkipBackwardButtonVisible(bool value);
	virtual STDMETHODIMP _get_IsSkipBackwardEnabled(bool *value);
	virtual STDMETHODIMP _put_IsSkipBackwardEnabled(bool value);
	virtual STDMETHODIMP _get_IsNextTrackButtonVisible(bool *value);
	virtual STDMETHODIMP _put_IsNextTrackButtonVisible(bool value);
	virtual STDMETHODIMP _get_IsPreviousTrackButtonVisible(bool *value);
	virtual STDMETHODIMP _put_IsPreviousTrackButtonVisible(bool value);
	virtual STDMETHODIMP _get_FastPlayFallbackBehaviour(Media::FastPlayFallbackBehaviour *value);
	virtual STDMETHODIMP _put_FastPlayFallbackBehaviour(Media::FastPlayFallbackBehaviour value);
	virtual STDMETHODIMP _add_ThumbnailRequested(Foundation::TypedEventHandler<MediaTransportControls*, Media::MediaTransportControlsThumbnailRequestedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ThumbnailRequested(Foundation::EventRegistrationToken token);
};
template<typename X> struct IMediaTransportControls2_adaptor : X {
	union {
		struct : property {
			Media::FastPlayFallbackBehaviour get() { Media::FastPlayFallbackBehaviour value; hrcheck(enc(&IMediaTransportControls2_adaptor::FastPlayFallbackBehaviour)->_get_FastPlayFallbackBehaviour(&value)); return value; }
			Media::FastPlayFallbackBehaviour operator()() { return get(); }
			operator Media::FastPlayFallbackBehaviour () { return get(); }
			void put(Media::FastPlayFallbackBehaviour value) { hrcheck(enc(&IMediaTransportControls2_adaptor::FastPlayFallbackBehaviour)->_put_FastPlayFallbackBehaviour(value)); }
			void operator=(Media::FastPlayFallbackBehaviour value) { put(value); }
			void operator()(Media::FastPlayFallbackBehaviour value) { put(value); }
		} FastPlayFallbackBehaviour;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls2_adaptor::IsNextTrackButtonVisible)->_get_IsNextTrackButtonVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls2_adaptor::IsNextTrackButtonVisible)->_put_IsNextTrackButtonVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsNextTrackButtonVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls2_adaptor::IsPreviousTrackButtonVisible)->_get_IsPreviousTrackButtonVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls2_adaptor::IsPreviousTrackButtonVisible)->_put_IsPreviousTrackButtonVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsPreviousTrackButtonVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls2_adaptor::IsSkipBackwardButtonVisible)->_get_IsSkipBackwardButtonVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls2_adaptor::IsSkipBackwardButtonVisible)->_put_IsSkipBackwardButtonVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSkipBackwardButtonVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls2_adaptor::IsSkipBackwardEnabled)->_get_IsSkipBackwardEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls2_adaptor::IsSkipBackwardEnabled)->_put_IsSkipBackwardEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSkipBackwardEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls2_adaptor::IsSkipForwardButtonVisible)->_get_IsSkipForwardButtonVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls2_adaptor::IsSkipForwardButtonVisible)->_put_IsSkipForwardButtonVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSkipForwardButtonVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls2_adaptor::IsSkipForwardEnabled)->_get_IsSkipForwardEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls2_adaptor::IsSkipForwardEnabled)->_put_IsSkipForwardEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSkipForwardEnabled;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaTransportControls>, ptr<Media::MediaTransportControlsThumbnailRequestedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaTransportControls2_adaptor::ThumbnailRequested)->_add_ThumbnailRequested(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaTransportControls2_adaptor::ThumbnailRequested)->_remove_ThumbnailRequested(token)); }
		} ThumbnailRequested;
	};
	IMediaTransportControls2_adaptor() {}
};
template<typename X> struct adapt<IMediaTransportControls2, X> : Windows::UI::Xaml::Controls::IMediaTransportControls2_adaptor<X> { typedef adapt IMediaTransportControls2; };
struct IMediaTransportControls2 : IMediaTransportControls2_raw, generate<IMediaTransportControls2> {};

// IMediaTransportControlsStatics2
struct IMediaTransportControlsStatics2 : IInspectable {
	virtual STDMETHODIMP _get_IsSkipForwardButtonVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsSkipForwardEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsSkipBackwardButtonVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsSkipBackwardEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsNextTrackButtonVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsPreviousTrackButtonVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FastPlayFallbackBehaviourProperty(DependencyProperty* *value);
};

// IMediaTransportControls3
struct IMediaTransportControls3_raw : IInspectable {
	virtual STDMETHODIMP _get_ShowAndHideAutomatically(bool *value);
	virtual STDMETHODIMP _put_ShowAndHideAutomatically(bool value);
	virtual STDMETHODIMP _get_IsRepeatEnabled(bool *value);
	virtual STDMETHODIMP _put_IsRepeatEnabled(bool value);
	virtual STDMETHODIMP _get_IsRepeatButtonVisible(bool *value);
	virtual STDMETHODIMP _put_IsRepeatButtonVisible(bool value);
	virtual STDMETHODIMP _Show();
	virtual STDMETHODIMP _Hide();
};
template<typename X> struct IMediaTransportControls3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls3_adaptor::IsRepeatButtonVisible)->_get_IsRepeatButtonVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls3_adaptor::IsRepeatButtonVisible)->_put_IsRepeatButtonVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsRepeatButtonVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls3_adaptor::IsRepeatEnabled)->_get_IsRepeatEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls3_adaptor::IsRepeatEnabled)->_put_IsRepeatEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsRepeatEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls3_adaptor::ShowAndHideAutomatically)->_get_ShowAndHideAutomatically(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls3_adaptor::ShowAndHideAutomatically)->_put_ShowAndHideAutomatically(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ShowAndHideAutomatically;
	};
	void Show() { hrcheck(X::get()->_Show()); }
	void Hide() { hrcheck(X::get()->_Hide()); }
	IMediaTransportControls3_adaptor() {}
};
template<typename X> struct adapt<IMediaTransportControls3, X> : Windows::UI::Xaml::Controls::IMediaTransportControls3_adaptor<X> { typedef adapt IMediaTransportControls3; };
struct IMediaTransportControls3 : IMediaTransportControls3_raw, generate<IMediaTransportControls3> {};

// IMediaTransportControlsStatics3
struct IMediaTransportControlsStatics3 : IInspectable {
	virtual STDMETHODIMP _get_ShowAndHideAutomaticallyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsRepeatEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsRepeatButtonVisibleProperty(DependencyProperty* *value);
};

// IMediaTransportControls4
struct IMediaTransportControls4_raw : IInspectable {
	virtual STDMETHODIMP _get_IsCompactOverlayButtonVisible(bool *value);
	virtual STDMETHODIMP _put_IsCompactOverlayButtonVisible(bool value);
	virtual STDMETHODIMP _get_IsCompactOverlayEnabled(bool *value);
	virtual STDMETHODIMP _put_IsCompactOverlayEnabled(bool value);
};
template<typename X> struct IMediaTransportControls4_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls4_adaptor::IsCompactOverlayButtonVisible)->_get_IsCompactOverlayButtonVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls4_adaptor::IsCompactOverlayButtonVisible)->_put_IsCompactOverlayButtonVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsCompactOverlayButtonVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaTransportControls4_adaptor::IsCompactOverlayEnabled)->_get_IsCompactOverlayEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaTransportControls4_adaptor::IsCompactOverlayEnabled)->_put_IsCompactOverlayEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsCompactOverlayEnabled;
	};
	IMediaTransportControls4_adaptor() {}
};
template<typename X> struct adapt<IMediaTransportControls4, X> : Windows::UI::Xaml::Controls::IMediaTransportControls4_adaptor<X> { typedef adapt IMediaTransportControls4; };
struct IMediaTransportControls4 : IMediaTransportControls4_raw, generate<IMediaTransportControls4> {};

// IMediaTransportControlsStatics4
struct IMediaTransportControlsStatics4 : IInspectable {
	virtual STDMETHODIMP _get_IsCompactOverlayButtonVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsCompactOverlayEnabledProperty(DependencyProperty* *value);
};

// IPasswordBox
struct IPasswordBox_raw : IInspectable {
	virtual STDMETHODIMP _get_Password(HSTRING *value);
	virtual STDMETHODIMP _put_Password(HSTRING value);
	virtual STDMETHODIMP _get_PasswordChar(HSTRING *value);
	virtual STDMETHODIMP _put_PasswordChar(HSTRING value);
	virtual STDMETHODIMP _get_IsPasswordRevealButtonEnabled(bool *value);
	virtual STDMETHODIMP _put_IsPasswordRevealButtonEnabled(bool value);
	virtual STDMETHODIMP _get_MaxLength(int *value);
	virtual STDMETHODIMP _put_MaxLength(int value);
	virtual STDMETHODIMP _add_PasswordChanged(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PasswordChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ContextMenuOpening(ContextMenuOpeningEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ContextMenuOpening(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _SelectAll();
};
template<typename X> struct IPasswordBox_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPasswordBox_adaptor::IsPasswordRevealButtonEnabled)->_get_IsPasswordRevealButtonEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IPasswordBox_adaptor::IsPasswordRevealButtonEnabled)->_put_IsPasswordRevealButtonEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsPasswordRevealButtonEnabled;
		struct : property {
			int get() { int value; hrcheck(enc(&IPasswordBox_adaptor::MaxLength)->_get_MaxLength(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IPasswordBox_adaptor::MaxLength)->_put_MaxLength(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaxLength;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPasswordBox_adaptor::Password)->_get_Password(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPasswordBox_adaptor::Password)->_put_Password(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Password;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPasswordBox_adaptor::PasswordChar)->_get_PasswordChar(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPasswordBox_adaptor::PasswordChar)->_put_PasswordChar(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PasswordChar;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<ContextMenuOpeningEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPasswordBox_adaptor::ContextMenuOpening)->_add_ContextMenuOpening(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPasswordBox_adaptor::ContextMenuOpening)->_remove_ContextMenuOpening(token)); }
		} ContextMenuOpening;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPasswordBox_adaptor::PasswordChanged)->_add_PasswordChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPasswordBox_adaptor::PasswordChanged)->_remove_PasswordChanged(token)); }
		} PasswordChanged;
	};
	void SelectAll() { hrcheck(X::get()->_SelectAll()); }
	IPasswordBox_adaptor() {}
};
template<typename X> struct adapt<IPasswordBox, X> : Windows::UI::Xaml::Controls::IPasswordBox_adaptor<X> { typedef adapt IPasswordBox; };
struct IPasswordBox : IPasswordBox_raw, generate<IPasswordBox> {};

// IPasswordBoxStatics
struct IPasswordBoxStatics : IInspectable {
	virtual STDMETHODIMP _get_PasswordProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PasswordCharProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsPasswordRevealButtonEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxLengthProperty(DependencyProperty* *value);
};

// IPasswordBox2
struct IPasswordBox2_raw : IInspectable {
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_PlaceholderText(HSTRING *value);
	virtual STDMETHODIMP _put_PlaceholderText(HSTRING value);
	virtual STDMETHODIMP _get_SelectionHighlightColor(Media::SolidColorBrush* *value);
	virtual STDMETHODIMP _put_SelectionHighlightColor(Media::SolidColorBrush* value);
	virtual STDMETHODIMP _get_PreventKeyboardDisplayOnProgrammaticFocus(bool *value);
	virtual STDMETHODIMP _put_PreventKeyboardDisplayOnProgrammaticFocus(bool value);
	virtual STDMETHODIMP _add_Paste(TextControlPasteEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Paste(Foundation::EventRegistrationToken token);
};
template<typename X> struct IPasswordBox2_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IPasswordBox2_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IPasswordBox2_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IPasswordBox2_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IPasswordBox2_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPasswordBox2_adaptor::PlaceholderText)->_get_PlaceholderText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPasswordBox2_adaptor::PlaceholderText)->_put_PlaceholderText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PlaceholderText;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPasswordBox2_adaptor::PreventKeyboardDisplayOnProgrammaticFocus)->_get_PreventKeyboardDisplayOnProgrammaticFocus(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IPasswordBox2_adaptor::PreventKeyboardDisplayOnProgrammaticFocus)->_put_PreventKeyboardDisplayOnProgrammaticFocus(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} PreventKeyboardDisplayOnProgrammaticFocus;
		struct : property {
			ptr<Media::SolidColorBrush> get() { Media::SolidColorBrush* value; hrcheck(enc(&IPasswordBox2_adaptor::SelectionHighlightColor)->_get_SelectionHighlightColor(&value)); return from_abi(value); }
			ptr<Media::SolidColorBrush> operator()() { return get(); }
			operator ptr<Media::SolidColorBrush> () { return get(); }
			ptr<Media::SolidColorBrush> operator->() { return get(); }
			void put(pptr<Media::SolidColorBrush> value) { hrcheck(enc(&IPasswordBox2_adaptor::SelectionHighlightColor)->_put_SelectionHighlightColor(value)); }
			void operator=(pptr<Media::SolidColorBrush> value) { put(value); }
			void operator()(pptr<Media::SolidColorBrush> value) { put(value); }
		} SelectionHighlightColor;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<TextControlPasteEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPasswordBox2_adaptor::Paste)->_add_Paste(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPasswordBox2_adaptor::Paste)->_remove_Paste(token)); }
		} Paste;
	};
	IPasswordBox2_adaptor() {}
};
template<typename X> struct adapt<IPasswordBox2, X> : Windows::UI::Xaml::Controls::IPasswordBox2_adaptor<X> { typedef adapt IPasswordBox2; };
struct IPasswordBox2 : IPasswordBox2_raw, generate<IPasswordBox2> {};

// IPasswordBoxStatics2
struct IPasswordBoxStatics2 : IInspectable {
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlaceholderTextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectionHighlightColorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PreventKeyboardDisplayOnProgrammaticFocusProperty(DependencyProperty* *value);
};

// IPasswordBox3
struct IPasswordBox3_raw : IInspectable {
	virtual STDMETHODIMP _get_PasswordRevealMode(Controls::PasswordRevealMode *value);
	virtual STDMETHODIMP _put_PasswordRevealMode(Controls::PasswordRevealMode value);
	virtual STDMETHODIMP _get_TextReadingOrder(Xaml::TextReadingOrder *value);
	virtual STDMETHODIMP _put_TextReadingOrder(Xaml::TextReadingOrder value);
	virtual STDMETHODIMP _get_InputScope(Input::InputScope* *value);
	virtual STDMETHODIMP _put_InputScope(Input::InputScope* value);
};
template<typename X> struct IPasswordBox3_adaptor : X {
	union {
		struct : property {
			ptr<Input::InputScope> get() { Input::InputScope* value; hrcheck(enc(&IPasswordBox3_adaptor::InputScope)->_get_InputScope(&value)); return from_abi(value); }
			ptr<Input::InputScope> operator()() { return get(); }
			operator ptr<Input::InputScope> () { return get(); }
			ptr<Input::InputScope> operator->() { return get(); }
			void put(pptr<Input::InputScope> value) { hrcheck(enc(&IPasswordBox3_adaptor::InputScope)->_put_InputScope(value)); }
			void operator=(pptr<Input::InputScope> value) { put(value); }
			void operator()(pptr<Input::InputScope> value) { put(value); }
		} InputScope;
		struct : property {
			Controls::PasswordRevealMode get() { Controls::PasswordRevealMode value; hrcheck(enc(&IPasswordBox3_adaptor::PasswordRevealMode)->_get_PasswordRevealMode(&value)); return value; }
			Controls::PasswordRevealMode operator()() { return get(); }
			operator Controls::PasswordRevealMode () { return get(); }
			void put(Controls::PasswordRevealMode value) { hrcheck(enc(&IPasswordBox3_adaptor::PasswordRevealMode)->_put_PasswordRevealMode(value)); }
			void operator=(Controls::PasswordRevealMode value) { put(value); }
			void operator()(Controls::PasswordRevealMode value) { put(value); }
		} PasswordRevealMode;
		struct : property {
			Xaml::TextReadingOrder get() { Xaml::TextReadingOrder value; hrcheck(enc(&IPasswordBox3_adaptor::TextReadingOrder)->_get_TextReadingOrder(&value)); return value; }
			Xaml::TextReadingOrder operator()() { return get(); }
			operator Xaml::TextReadingOrder () { return get(); }
			void put(Xaml::TextReadingOrder value) { hrcheck(enc(&IPasswordBox3_adaptor::TextReadingOrder)->_put_TextReadingOrder(value)); }
			void operator=(Xaml::TextReadingOrder value) { put(value); }
			void operator()(Xaml::TextReadingOrder value) { put(value); }
		} TextReadingOrder;
	};
	IPasswordBox3_adaptor() {}
};
template<typename X> struct adapt<IPasswordBox3, X> : Windows::UI::Xaml::Controls::IPasswordBox3_adaptor<X> { typedef adapt IPasswordBox3; };
struct IPasswordBox3 : IPasswordBox3_raw, generate<IPasswordBox3> {};

// IPasswordBoxStatics3
struct IPasswordBoxStatics3 : IInspectable {
	virtual STDMETHODIMP _get_PasswordRevealModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextReadingOrderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_InputScopeProperty(DependencyProperty* *value);
};

// IPasswordBox4
struct IPasswordBox4_raw : IInspectable {
	virtual STDMETHODIMP _add_PasswordChanging(Foundation::TypedEventHandler<PasswordBox*, PasswordBoxPasswordChangingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PasswordChanging(Foundation::EventRegistrationToken token);
};
template<typename X> struct IPasswordBox4_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<PasswordBox>, ptr<PasswordBoxPasswordChangingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPasswordBox4_adaptor::PasswordChanging)->_add_PasswordChanging(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPasswordBox4_adaptor::PasswordChanging)->_remove_PasswordChanging(token)); }
		} PasswordChanging;
	};
	IPasswordBox4_adaptor() {}
};
template<typename X> struct adapt<IPasswordBox4, X> : Windows::UI::Xaml::Controls::IPasswordBox4_adaptor<X> { typedef adapt IPasswordBox4; };
struct IPasswordBox4 : IPasswordBox4_raw, generate<IPasswordBox4> {};

// IProgressRing
struct IProgressRing_raw : IInspectable {
	virtual STDMETHODIMP _get_IsActive(bool *value);
	virtual STDMETHODIMP _put_IsActive(bool value);
	virtual STDMETHODIMP _get_TemplateSettings(Primitives::ProgressRingTemplateSettings* *value);
};
template<typename X> struct IProgressRing_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IProgressRing_adaptor::IsActive)->_get_IsActive(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IProgressRing_adaptor::IsActive)->_put_IsActive(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsActive;
		struct : property {
			ptr<Primitives::ProgressRingTemplateSettings> get() { Primitives::ProgressRingTemplateSettings* value; hrcheck(enc(&IProgressRing_adaptor::TemplateSettings)->_get_TemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::ProgressRingTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::ProgressRingTemplateSettings> () { return get(); }
			ptr<Primitives::ProgressRingTemplateSettings> operator->() { return get(); }
		} TemplateSettings;
	};
	IProgressRing_adaptor() {}
};
template<typename X> struct adapt<IProgressRing, X> : Windows::UI::Xaml::Controls::IProgressRing_adaptor<X> { typedef adapt IProgressRing; };
struct IProgressRing : IProgressRing_raw, generate<IProgressRing> {};

// IProgressRingStatics
struct IProgressRingStatics : IInspectable {
	virtual STDMETHODIMP _get_IsActiveProperty(DependencyProperty* *value);
};

// IRelativePanel
struct IRelativePanel_raw : IInspectable {
	virtual STDMETHODIMP _get_BorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_BorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_BorderThickness(Thickness *value);
	virtual STDMETHODIMP _put_BorderThickness(Thickness value);
	virtual STDMETHODIMP _get_CornerRadius(Xaml::CornerRadius *value);
	virtual STDMETHODIMP _put_CornerRadius(Xaml::CornerRadius value);
	virtual STDMETHODIMP _get_Padding(Thickness *value);
	virtual STDMETHODIMP _put_Padding(Thickness value);
};
template<typename X> struct IRelativePanel_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IRelativePanel_adaptor::BorderBrush)->_get_BorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IRelativePanel_adaptor::BorderBrush)->_put_BorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} BorderBrush;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IRelativePanel_adaptor::BorderThickness)->_get_BorderThickness(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IRelativePanel_adaptor::BorderThickness)->_put_BorderThickness(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} BorderThickness;
		struct : property {
			Xaml::CornerRadius get() { Xaml::CornerRadius value; hrcheck(enc(&IRelativePanel_adaptor::CornerRadius)->_get_CornerRadius(&value)); return value; }
			Xaml::CornerRadius operator()() { return get(); }
			operator Xaml::CornerRadius () { return get(); }
			void put(const Xaml::CornerRadius& value) { hrcheck(enc(&IRelativePanel_adaptor::CornerRadius)->_put_CornerRadius(value)); }
			void operator=(const Xaml::CornerRadius& value) { put(value); }
			void operator()(const Xaml::CornerRadius& value) { put(value); }
		} CornerRadius;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IRelativePanel_adaptor::Padding)->_get_Padding(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IRelativePanel_adaptor::Padding)->_put_Padding(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} Padding;
	};
	IRelativePanel_adaptor() {}
};
template<typename X> struct adapt<IRelativePanel, X> : Windows::UI::Xaml::Controls::IRelativePanel_adaptor<X> { typedef adapt IRelativePanel; };
struct IRelativePanel : IRelativePanel_raw, generate<IRelativePanel> {};

// IRelativePanelStatics
struct IRelativePanelStatics : IInspectable {
	virtual STDMETHODIMP _get_LeftOfProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetLeftOf(UIElement* element, IInspectable* *value);
	virtual STDMETHODIMP _SetLeftOf(UIElement* element, IInspectable* value);
	virtual STDMETHODIMP _get_AboveProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetAbove(UIElement* element, IInspectable* *value);
	virtual STDMETHODIMP _SetAbove(UIElement* element, IInspectable* value);
	virtual STDMETHODIMP _get_RightOfProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetRightOf(UIElement* element, IInspectable* *value);
	virtual STDMETHODIMP _SetRightOf(UIElement* element, IInspectable* value);
	virtual STDMETHODIMP _get_BelowProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetBelow(UIElement* element, IInspectable* *value);
	virtual STDMETHODIMP _SetBelow(UIElement* element, IInspectable* value);
	virtual STDMETHODIMP _get_AlignHorizontalCenterWithProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetAlignHorizontalCenterWith(UIElement* element, IInspectable* *value);
	virtual STDMETHODIMP _SetAlignHorizontalCenterWith(UIElement* element, IInspectable* value);
	virtual STDMETHODIMP _get_AlignVerticalCenterWithProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetAlignVerticalCenterWith(UIElement* element, IInspectable* *value);
	virtual STDMETHODIMP _SetAlignVerticalCenterWith(UIElement* element, IInspectable* value);
	virtual STDMETHODIMP _get_AlignLeftWithProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetAlignLeftWith(UIElement* element, IInspectable* *value);
	virtual STDMETHODIMP _SetAlignLeftWith(UIElement* element, IInspectable* value);
	virtual STDMETHODIMP _get_AlignTopWithProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetAlignTopWith(UIElement* element, IInspectable* *value);
	virtual STDMETHODIMP _SetAlignTopWith(UIElement* element, IInspectable* value);
	virtual STDMETHODIMP _get_AlignRightWithProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetAlignRightWith(UIElement* element, IInspectable* *value);
	virtual STDMETHODIMP _SetAlignRightWith(UIElement* element, IInspectable* value);
	virtual STDMETHODIMP _get_AlignBottomWithProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetAlignBottomWith(UIElement* element, IInspectable* *value);
	virtual STDMETHODIMP _SetAlignBottomWith(UIElement* element, IInspectable* value);
	virtual STDMETHODIMP _get_AlignLeftWithPanelProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetAlignLeftWithPanel(UIElement* element, bool *value);
	virtual STDMETHODIMP _SetAlignLeftWithPanel(UIElement* element, bool value);
	virtual STDMETHODIMP _get_AlignTopWithPanelProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetAlignTopWithPanel(UIElement* element, bool *value);
	virtual STDMETHODIMP _SetAlignTopWithPanel(UIElement* element, bool value);
	virtual STDMETHODIMP _get_AlignRightWithPanelProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetAlignRightWithPanel(UIElement* element, bool *value);
	virtual STDMETHODIMP _SetAlignRightWithPanel(UIElement* element, bool value);
	virtual STDMETHODIMP _get_AlignBottomWithPanelProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetAlignBottomWithPanel(UIElement* element, bool *value);
	virtual STDMETHODIMP _SetAlignBottomWithPanel(UIElement* element, bool value);
	virtual STDMETHODIMP _get_AlignHorizontalCenterWithPanelProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetAlignHorizontalCenterWithPanel(UIElement* element, bool *value);
	virtual STDMETHODIMP _SetAlignHorizontalCenterWithPanel(UIElement* element, bool value);
	virtual STDMETHODIMP _get_AlignVerticalCenterWithPanelProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetAlignVerticalCenterWithPanel(UIElement* element, bool *value);
	virtual STDMETHODIMP _SetAlignVerticalCenterWithPanel(UIElement* element, bool value);
	virtual STDMETHODIMP _get_BorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BorderThicknessProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CornerRadiusProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PaddingProperty(DependencyProperty* *value);
};

// IRelativePanelFactory
struct IRelativePanelFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, RelativePanel* *instance);
};

// ISemanticZoom
struct ISemanticZoom_raw : IInspectable {
	virtual STDMETHODIMP _get_ZoomedInView(ISemanticZoomInformation* *value);
	virtual STDMETHODIMP _put_ZoomedInView(ISemanticZoomInformation* value);
	virtual STDMETHODIMP _get_ZoomedOutView(ISemanticZoomInformation* *value);
	virtual STDMETHODIMP _put_ZoomedOutView(ISemanticZoomInformation* value);
	virtual STDMETHODIMP _get_IsZoomedInViewActive(bool *value);
	virtual STDMETHODIMP _put_IsZoomedInViewActive(bool value);
	virtual STDMETHODIMP _get_CanChangeViews(bool *value);
	virtual STDMETHODIMP _put_CanChangeViews(bool value);
	virtual STDMETHODIMP _add_ViewChangeStarted(SemanticZoomViewChangedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ViewChangeStarted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ViewChangeCompleted(SemanticZoomViewChangedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ViewChangeCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _ToggleActiveView();
	virtual STDMETHODIMP _get_IsZoomOutButtonEnabled(bool *value);
	virtual STDMETHODIMP _put_IsZoomOutButtonEnabled(bool value);
};
template<typename X> struct ISemanticZoom_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISemanticZoom_adaptor::CanChangeViews)->_get_CanChangeViews(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISemanticZoom_adaptor::CanChangeViews)->_put_CanChangeViews(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} CanChangeViews;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISemanticZoom_adaptor::IsZoomOutButtonEnabled)->_get_IsZoomOutButtonEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISemanticZoom_adaptor::IsZoomOutButtonEnabled)->_put_IsZoomOutButtonEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsZoomOutButtonEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISemanticZoom_adaptor::IsZoomedInViewActive)->_get_IsZoomedInViewActive(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISemanticZoom_adaptor::IsZoomedInViewActive)->_put_IsZoomedInViewActive(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsZoomedInViewActive;
		struct : property {
			ptr<ISemanticZoomInformation> get() { ISemanticZoomInformation* value; hrcheck(enc(&ISemanticZoom_adaptor::ZoomedInView)->_get_ZoomedInView(&value)); return from_abi(value); }
			ptr<ISemanticZoomInformation> operator()() { return get(); }
			operator ptr<ISemanticZoomInformation> () { return get(); }
			ptr<ISemanticZoomInformation> operator->() { return get(); }
			void put(pptr<ISemanticZoomInformation> value) { hrcheck(enc(&ISemanticZoom_adaptor::ZoomedInView)->_put_ZoomedInView(value)); }
			void operator=(pptr<ISemanticZoomInformation> value) { put(value); }
			void operator()(pptr<ISemanticZoomInformation> value) { put(value); }
		} ZoomedInView;
		struct : property {
			ptr<ISemanticZoomInformation> get() { ISemanticZoomInformation* value; hrcheck(enc(&ISemanticZoom_adaptor::ZoomedOutView)->_get_ZoomedOutView(&value)); return from_abi(value); }
			ptr<ISemanticZoomInformation> operator()() { return get(); }
			operator ptr<ISemanticZoomInformation> () { return get(); }
			ptr<ISemanticZoomInformation> operator->() { return get(); }
			void put(pptr<ISemanticZoomInformation> value) { hrcheck(enc(&ISemanticZoom_adaptor::ZoomedOutView)->_put_ZoomedOutView(value)); }
			void operator=(pptr<ISemanticZoomInformation> value) { put(value); }
			void operator()(pptr<ISemanticZoomInformation> value) { put(value); }
		} ZoomedOutView;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<SemanticZoomViewChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISemanticZoom_adaptor::ViewChangeCompleted)->_add_ViewChangeCompleted(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISemanticZoom_adaptor::ViewChangeCompleted)->_remove_ViewChangeCompleted(token)); }
		} ViewChangeCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<SemanticZoomViewChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISemanticZoom_adaptor::ViewChangeStarted)->_add_ViewChangeStarted(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISemanticZoom_adaptor::ViewChangeStarted)->_remove_ViewChangeStarted(token)); }
		} ViewChangeStarted;
	};
	void ToggleActiveView() { hrcheck(X::get()->_ToggleActiveView()); }
	ISemanticZoom_adaptor() {}
};
template<typename X> struct adapt<ISemanticZoom, X> : Windows::UI::Xaml::Controls::ISemanticZoom_adaptor<X> { typedef adapt ISemanticZoom; };
struct ISemanticZoom : ISemanticZoom_raw, generate<ISemanticZoom> {};

// ISemanticZoomStatics
struct ISemanticZoomStatics : IInspectable {
	virtual STDMETHODIMP _get_ZoomedInViewProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ZoomedOutViewProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsZoomedInViewActiveProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CanChangeViewsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsZoomOutButtonEnabledProperty(DependencyProperty* *value);
};

// IStackPanel
struct IStackPanel_raw : IInspectable {
	virtual STDMETHODIMP _get_AreScrollSnapPointsRegular(bool *value);
	virtual STDMETHODIMP _put_AreScrollSnapPointsRegular(bool value);
	virtual STDMETHODIMP _get_Orientation(Controls::Orientation *value);
	virtual STDMETHODIMP _put_Orientation(Controls::Orientation value);
};
template<typename X> struct IStackPanel_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStackPanel_adaptor::AreScrollSnapPointsRegular)->_get_AreScrollSnapPointsRegular(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IStackPanel_adaptor::AreScrollSnapPointsRegular)->_put_AreScrollSnapPointsRegular(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AreScrollSnapPointsRegular;
		struct : property {
			Controls::Orientation get() { Controls::Orientation value; hrcheck(enc(&IStackPanel_adaptor::Orientation)->_get_Orientation(&value)); return value; }
			Controls::Orientation operator()() { return get(); }
			operator Controls::Orientation () { return get(); }
			void put(Controls::Orientation value) { hrcheck(enc(&IStackPanel_adaptor::Orientation)->_put_Orientation(value)); }
			void operator=(Controls::Orientation value) { put(value); }
			void operator()(Controls::Orientation value) { put(value); }
		} Orientation;
	};
	IStackPanel_adaptor() {}
};
template<typename X> struct adapt<IStackPanel, X> : Windows::UI::Xaml::Controls::IStackPanel_adaptor<X> { typedef adapt IStackPanel; };
struct IStackPanel : IStackPanel_raw, generate<IStackPanel> {};

// IStackPanelStatics
struct IStackPanelStatics : IInspectable {
	virtual STDMETHODIMP _get_AreScrollSnapPointsRegularProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OrientationProperty(DependencyProperty* *value);
};

// IStackPanelFactory
struct IStackPanelFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, StackPanel* *instance);
};

// IStackPanel2
struct IStackPanel2_raw : IInspectable {
	virtual STDMETHODIMP _get_BorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_BorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_BorderThickness(Thickness *value);
	virtual STDMETHODIMP _put_BorderThickness(Thickness value);
	virtual STDMETHODIMP _get_CornerRadius(Xaml::CornerRadius *value);
	virtual STDMETHODIMP _put_CornerRadius(Xaml::CornerRadius value);
	virtual STDMETHODIMP _get_Padding(Thickness *value);
	virtual STDMETHODIMP _put_Padding(Thickness value);
};
template<typename X> struct IStackPanel2_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IStackPanel2_adaptor::BorderBrush)->_get_BorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IStackPanel2_adaptor::BorderBrush)->_put_BorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} BorderBrush;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IStackPanel2_adaptor::BorderThickness)->_get_BorderThickness(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IStackPanel2_adaptor::BorderThickness)->_put_BorderThickness(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} BorderThickness;
		struct : property {
			Xaml::CornerRadius get() { Xaml::CornerRadius value; hrcheck(enc(&IStackPanel2_adaptor::CornerRadius)->_get_CornerRadius(&value)); return value; }
			Xaml::CornerRadius operator()() { return get(); }
			operator Xaml::CornerRadius () { return get(); }
			void put(const Xaml::CornerRadius& value) { hrcheck(enc(&IStackPanel2_adaptor::CornerRadius)->_put_CornerRadius(value)); }
			void operator=(const Xaml::CornerRadius& value) { put(value); }
			void operator()(const Xaml::CornerRadius& value) { put(value); }
		} CornerRadius;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IStackPanel2_adaptor::Padding)->_get_Padding(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IStackPanel2_adaptor::Padding)->_put_Padding(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} Padding;
	};
	IStackPanel2_adaptor() {}
};
template<typename X> struct adapt<IStackPanel2, X> : Windows::UI::Xaml::Controls::IStackPanel2_adaptor<X> { typedef adapt IStackPanel2; };
struct IStackPanel2 : IStackPanel2_raw, generate<IStackPanel2> {};

// IStackPanelStatics2
struct IStackPanelStatics2 : IInspectable {
	virtual STDMETHODIMP _get_BorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BorderThicknessProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CornerRadiusProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PaddingProperty(DependencyProperty* *value);
};

// IStackPanel4
struct IStackPanel4_raw : IInspectable {
	virtual STDMETHODIMP _get_Spacing(double *value);
	virtual STDMETHODIMP _put_Spacing(double value);
};
template<typename X> struct IStackPanel4_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IStackPanel4_adaptor::Spacing)->_get_Spacing(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IStackPanel4_adaptor::Spacing)->_put_Spacing(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Spacing;
	};
	IStackPanel4_adaptor() {}
};
template<typename X> struct adapt<IStackPanel4, X> : Windows::UI::Xaml::Controls::IStackPanel4_adaptor<X> { typedef adapt IStackPanel4; };
struct IStackPanel4 : IStackPanel4_raw, generate<IStackPanel4> {};

// IStackPanelStatics4
struct IStackPanelStatics4 : IInspectable {
	virtual STDMETHODIMP _get_SpacingProperty(DependencyProperty* *value);
};

// ITextBox
struct ITextBox_raw : IInspectable {
	virtual STDMETHODIMP _get_Text(HSTRING *value);
	virtual STDMETHODIMP _put_Text(HSTRING value);
	virtual STDMETHODIMP _get_SelectedText(HSTRING *value);
	virtual STDMETHODIMP _put_SelectedText(HSTRING value);
	virtual STDMETHODIMP _get_SelectionLength(int *value);
	virtual STDMETHODIMP _put_SelectionLength(int value);
	virtual STDMETHODIMP _get_SelectionStart(int *value);
	virtual STDMETHODIMP _put_SelectionStart(int value);
	virtual STDMETHODIMP _get_MaxLength(int *value);
	virtual STDMETHODIMP _put_MaxLength(int value);
	virtual STDMETHODIMP _get_IsReadOnly(bool *value);
	virtual STDMETHODIMP _put_IsReadOnly(bool value);
	virtual STDMETHODIMP _get_AcceptsReturn(bool *value);
	virtual STDMETHODIMP _put_AcceptsReturn(bool value);
	virtual STDMETHODIMP _get_TextAlignment(Xaml::TextAlignment *value);
	virtual STDMETHODIMP _put_TextAlignment(Xaml::TextAlignment value);
	virtual STDMETHODIMP _get_TextWrapping(Xaml::TextWrapping *value);
	virtual STDMETHODIMP _put_TextWrapping(Xaml::TextWrapping value);
	virtual STDMETHODIMP _get_IsSpellCheckEnabled(bool *value);
	virtual STDMETHODIMP _put_IsSpellCheckEnabled(bool value);
	virtual STDMETHODIMP _get_IsTextPredictionEnabled(bool *value);
	virtual STDMETHODIMP _put_IsTextPredictionEnabled(bool value);
	virtual STDMETHODIMP _get_InputScope(Input::InputScope* *value);
	virtual STDMETHODIMP _put_InputScope(Input::InputScope* value);
	virtual STDMETHODIMP _add_TextChanged(TextChangedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_TextChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_SelectionChanged(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SelectionChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ContextMenuOpening(ContextMenuOpeningEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ContextMenuOpening(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _Select(int start, int length);
	virtual STDMETHODIMP _SelectAll();
	virtual STDMETHODIMP _GetRectFromCharacterIndex(int charIndex, bool trailingEdge, Foundation::Rect *returnValue);
};
template<typename X> struct ITextBox_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextBox_adaptor::AcceptsReturn)->_get_AcceptsReturn(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextBox_adaptor::AcceptsReturn)->_put_AcceptsReturn(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AcceptsReturn;
		struct : property {
			ptr<Input::InputScope> get() { Input::InputScope* value; hrcheck(enc(&ITextBox_adaptor::InputScope)->_get_InputScope(&value)); return from_abi(value); }
			ptr<Input::InputScope> operator()() { return get(); }
			operator ptr<Input::InputScope> () { return get(); }
			ptr<Input::InputScope> operator->() { return get(); }
			void put(pptr<Input::InputScope> value) { hrcheck(enc(&ITextBox_adaptor::InputScope)->_put_InputScope(value)); }
			void operator=(pptr<Input::InputScope> value) { put(value); }
			void operator()(pptr<Input::InputScope> value) { put(value); }
		} InputScope;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextBox_adaptor::IsReadOnly)->_get_IsReadOnly(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextBox_adaptor::IsReadOnly)->_put_IsReadOnly(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsReadOnly;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextBox_adaptor::IsSpellCheckEnabled)->_get_IsSpellCheckEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextBox_adaptor::IsSpellCheckEnabled)->_put_IsSpellCheckEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSpellCheckEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextBox_adaptor::IsTextPredictionEnabled)->_get_IsTextPredictionEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextBox_adaptor::IsTextPredictionEnabled)->_put_IsTextPredictionEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTextPredictionEnabled;
		struct : property {
			int get() { int value; hrcheck(enc(&ITextBox_adaptor::MaxLength)->_get_MaxLength(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ITextBox_adaptor::MaxLength)->_put_MaxLength(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaxLength;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITextBox_adaptor::SelectedText)->_get_SelectedText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITextBox_adaptor::SelectedText)->_put_SelectedText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} SelectedText;
		struct : property {
			int get() { int value; hrcheck(enc(&ITextBox_adaptor::SelectionLength)->_get_SelectionLength(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ITextBox_adaptor::SelectionLength)->_put_SelectionLength(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} SelectionLength;
		struct : property {
			int get() { int value; hrcheck(enc(&ITextBox_adaptor::SelectionStart)->_get_SelectionStart(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ITextBox_adaptor::SelectionStart)->_put_SelectionStart(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} SelectionStart;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITextBox_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITextBox_adaptor::Text)->_put_Text(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Text;
		struct : property {
			Xaml::TextAlignment get() { Xaml::TextAlignment value; hrcheck(enc(&ITextBox_adaptor::TextAlignment)->_get_TextAlignment(&value)); return value; }
			Xaml::TextAlignment operator()() { return get(); }
			operator Xaml::TextAlignment () { return get(); }
			void put(Xaml::TextAlignment value) { hrcheck(enc(&ITextBox_adaptor::TextAlignment)->_put_TextAlignment(value)); }
			void operator=(Xaml::TextAlignment value) { put(value); }
			void operator()(Xaml::TextAlignment value) { put(value); }
		} TextAlignment;
		struct : property {
			Xaml::TextWrapping get() { Xaml::TextWrapping value; hrcheck(enc(&ITextBox_adaptor::TextWrapping)->_get_TextWrapping(&value)); return value; }
			Xaml::TextWrapping operator()() { return get(); }
			operator Xaml::TextWrapping () { return get(); }
			void put(Xaml::TextWrapping value) { hrcheck(enc(&ITextBox_adaptor::TextWrapping)->_put_TextWrapping(value)); }
			void operator=(Xaml::TextWrapping value) { put(value); }
			void operator()(Xaml::TextWrapping value) { put(value); }
		} TextWrapping;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<ContextMenuOpeningEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITextBox_adaptor::ContextMenuOpening)->_add_ContextMenuOpening(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITextBox_adaptor::ContextMenuOpening)->_remove_ContextMenuOpening(token)); }
		} ContextMenuOpening;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITextBox_adaptor::SelectionChanged)->_add_SelectionChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITextBox_adaptor::SelectionChanged)->_remove_SelectionChanged(token)); }
		} SelectionChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<TextChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITextBox_adaptor::TextChanged)->_add_TextChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITextBox_adaptor::TextChanged)->_remove_TextChanged(token)); }
		} TextChanged;
	};
	void Select(int start, int length) { hrcheck(X::get()->_Select(start, length)); }
	void SelectAll() { hrcheck(X::get()->_SelectAll()); }
	Foundation::Rect GetRectFromCharacterIndex(int charIndex, bool trailingEdge) { Foundation::Rect returnValue; hrcheck(X::get()->_GetRectFromCharacterIndex(charIndex, trailingEdge, &returnValue)); return returnValue; }
	ITextBox_adaptor() {}
};
template<typename X> struct adapt<ITextBox, X> : Windows::UI::Xaml::Controls::ITextBox_adaptor<X> { typedef adapt ITextBox; };
struct ITextBox : ITextBox_raw, generate<ITextBox> {};

// ITextBoxStatics
struct ITextBoxStatics : IInspectable {
	virtual STDMETHODIMP _get_TextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxLengthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsReadOnlyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AcceptsReturnProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextWrappingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsSpellCheckEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsTextPredictionEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_InputScopeProperty(DependencyProperty* *value);
};

// ITextBoxFactory
struct ITextBoxFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, TextBox* *instance);
};

// ITextBox2
struct ITextBox2_raw : IInspectable {
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_PlaceholderText(HSTRING *value);
	virtual STDMETHODIMP _put_PlaceholderText(HSTRING value);
	virtual STDMETHODIMP _get_SelectionHighlightColor(Media::SolidColorBrush* *value);
	virtual STDMETHODIMP _put_SelectionHighlightColor(Media::SolidColorBrush* value);
	virtual STDMETHODIMP _get_PreventKeyboardDisplayOnProgrammaticFocus(bool *value);
	virtual STDMETHODIMP _put_PreventKeyboardDisplayOnProgrammaticFocus(bool value);
	virtual STDMETHODIMP _get_IsColorFontEnabled(bool *value);
	virtual STDMETHODIMP _put_IsColorFontEnabled(bool value);
	virtual STDMETHODIMP _add_Paste(TextControlPasteEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Paste(Foundation::EventRegistrationToken token);
};
template<typename X> struct ITextBox2_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ITextBox2_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&ITextBox2_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&ITextBox2_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&ITextBox2_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextBox2_adaptor::IsColorFontEnabled)->_get_IsColorFontEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextBox2_adaptor::IsColorFontEnabled)->_put_IsColorFontEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsColorFontEnabled;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITextBox2_adaptor::PlaceholderText)->_get_PlaceholderText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITextBox2_adaptor::PlaceholderText)->_put_PlaceholderText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PlaceholderText;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextBox2_adaptor::PreventKeyboardDisplayOnProgrammaticFocus)->_get_PreventKeyboardDisplayOnProgrammaticFocus(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextBox2_adaptor::PreventKeyboardDisplayOnProgrammaticFocus)->_put_PreventKeyboardDisplayOnProgrammaticFocus(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} PreventKeyboardDisplayOnProgrammaticFocus;
		struct : property {
			ptr<Media::SolidColorBrush> get() { Media::SolidColorBrush* value; hrcheck(enc(&ITextBox2_adaptor::SelectionHighlightColor)->_get_SelectionHighlightColor(&value)); return from_abi(value); }
			ptr<Media::SolidColorBrush> operator()() { return get(); }
			operator ptr<Media::SolidColorBrush> () { return get(); }
			ptr<Media::SolidColorBrush> operator->() { return get(); }
			void put(pptr<Media::SolidColorBrush> value) { hrcheck(enc(&ITextBox2_adaptor::SelectionHighlightColor)->_put_SelectionHighlightColor(value)); }
			void operator=(pptr<Media::SolidColorBrush> value) { put(value); }
			void operator()(pptr<Media::SolidColorBrush> value) { put(value); }
		} SelectionHighlightColor;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<TextControlPasteEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITextBox2_adaptor::Paste)->_add_Paste(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITextBox2_adaptor::Paste)->_remove_Paste(token)); }
		} Paste;
	};
	ITextBox2_adaptor() {}
};
template<typename X> struct adapt<ITextBox2, X> : Windows::UI::Xaml::Controls::ITextBox2_adaptor<X> { typedef adapt ITextBox2; };
struct ITextBox2 : ITextBox2_raw, generate<ITextBox2> {};

// ITextBoxStatics2
struct ITextBoxStatics2 : IInspectable {
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlaceholderTextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectionHighlightColorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PreventKeyboardDisplayOnProgrammaticFocusProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsColorFontEnabledProperty(DependencyProperty* *value);
};

// ITextBox3
struct ITextBox3_raw : IInspectable {
	virtual STDMETHODIMP _add_TextCompositionStarted(Foundation::TypedEventHandler<TextBox*, TextCompositionStartedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_TextCompositionStarted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_TextCompositionChanged(Foundation::TypedEventHandler<TextBox*, TextCompositionChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_TextCompositionChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_TextCompositionEnded(Foundation::TypedEventHandler<TextBox*, TextCompositionEndedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_TextCompositionEnded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_TextReadingOrder(Xaml::TextReadingOrder *value);
	virtual STDMETHODIMP _put_TextReadingOrder(Xaml::TextReadingOrder value);
	virtual STDMETHODIMP _get_DesiredCandidateWindowAlignment(CandidateWindowAlignment *value);
	virtual STDMETHODIMP _put_DesiredCandidateWindowAlignment(CandidateWindowAlignment value);
	virtual STDMETHODIMP _add_CandidateWindowBoundsChanged(Foundation::TypedEventHandler<TextBox*, CandidateWindowBoundsChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CandidateWindowBoundsChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_TextChanging(Foundation::TypedEventHandler<TextBox*, TextBoxTextChangingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_TextChanging(Foundation::EventRegistrationToken token);
};
template<typename X> struct ITextBox3_adaptor : X {
	union {
		struct : property {
			CandidateWindowAlignment get() { CandidateWindowAlignment value; hrcheck(enc(&ITextBox3_adaptor::DesiredCandidateWindowAlignment)->_get_DesiredCandidateWindowAlignment(&value)); return value; }
			CandidateWindowAlignment operator()() { return get(); }
			operator CandidateWindowAlignment () { return get(); }
			void put(CandidateWindowAlignment value) { hrcheck(enc(&ITextBox3_adaptor::DesiredCandidateWindowAlignment)->_put_DesiredCandidateWindowAlignment(value)); }
			void operator=(CandidateWindowAlignment value) { put(value); }
			void operator()(CandidateWindowAlignment value) { put(value); }
		} DesiredCandidateWindowAlignment;
		struct : property {
			Xaml::TextReadingOrder get() { Xaml::TextReadingOrder value; hrcheck(enc(&ITextBox3_adaptor::TextReadingOrder)->_get_TextReadingOrder(&value)); return value; }
			Xaml::TextReadingOrder operator()() { return get(); }
			operator Xaml::TextReadingOrder () { return get(); }
			void put(Xaml::TextReadingOrder value) { hrcheck(enc(&ITextBox3_adaptor::TextReadingOrder)->_put_TextReadingOrder(value)); }
			void operator=(Xaml::TextReadingOrder value) { put(value); }
			void operator()(Xaml::TextReadingOrder value) { put(value); }
		} TextReadingOrder;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TextBox>, ptr<CandidateWindowBoundsChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITextBox3_adaptor::CandidateWindowBoundsChanged)->_add_CandidateWindowBoundsChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITextBox3_adaptor::CandidateWindowBoundsChanged)->_remove_CandidateWindowBoundsChanged(token)); }
		} CandidateWindowBoundsChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TextBox>, ptr<TextBoxTextChangingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITextBox3_adaptor::TextChanging)->_add_TextChanging(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITextBox3_adaptor::TextChanging)->_remove_TextChanging(token)); }
		} TextChanging;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TextBox>, ptr<TextCompositionChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITextBox3_adaptor::TextCompositionChanged)->_add_TextCompositionChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITextBox3_adaptor::TextCompositionChanged)->_remove_TextCompositionChanged(token)); }
		} TextCompositionChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TextBox>, ptr<TextCompositionEndedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITextBox3_adaptor::TextCompositionEnded)->_add_TextCompositionEnded(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITextBox3_adaptor::TextCompositionEnded)->_remove_TextCompositionEnded(token)); }
		} TextCompositionEnded;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TextBox>, ptr<TextCompositionStartedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITextBox3_adaptor::TextCompositionStarted)->_add_TextCompositionStarted(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITextBox3_adaptor::TextCompositionStarted)->_remove_TextCompositionStarted(token)); }
		} TextCompositionStarted;
	};
	ITextBox3_adaptor() {}
};
template<typename X> struct adapt<ITextBox3, X> : Windows::UI::Xaml::Controls::ITextBox3_adaptor<X> { typedef adapt ITextBox3; };
struct ITextBox3 : ITextBox3_raw, generate<ITextBox3> {};

// ITextBoxStatics3
struct ITextBoxStatics3 : IInspectable {
	virtual STDMETHODIMP _get_DesiredCandidateWindowAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextReadingOrderProperty(DependencyProperty* *value);
};

// ITextBox4
struct ITextBox4_raw : IInspectable {
	virtual STDMETHODIMP _GetLinguisticAlternativesAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<HSTRING>*>* *returnValue);
};
template<typename X> struct ITextBox4_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<hstring>>>> GetLinguisticAlternativesAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<HSTRING>*>* returnValue; hrcheck(X::get()->_GetLinguisticAlternativesAsync(&returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<ITextBox4, X> : Windows::UI::Xaml::Controls::ITextBox4_adaptor<X> { typedef adapt ITextBox4; };
struct ITextBox4 : ITextBox4_raw, generate<ITextBox4> {};

// ITextBox5
struct ITextBox5_raw : IInspectable {
	virtual STDMETHODIMP _get_SelectionHighlightColorWhenNotFocused(Media::SolidColorBrush* *value);
	virtual STDMETHODIMP _put_SelectionHighlightColorWhenNotFocused(Media::SolidColorBrush* value);
};
template<typename X> struct ITextBox5_adaptor : X {
	union {
		struct : property {
			ptr<Media::SolidColorBrush> get() { Media::SolidColorBrush* value; hrcheck(enc(&ITextBox5_adaptor::SelectionHighlightColorWhenNotFocused)->_get_SelectionHighlightColorWhenNotFocused(&value)); return from_abi(value); }
			ptr<Media::SolidColorBrush> operator()() { return get(); }
			operator ptr<Media::SolidColorBrush> () { return get(); }
			ptr<Media::SolidColorBrush> operator->() { return get(); }
			void put(pptr<Media::SolidColorBrush> value) { hrcheck(enc(&ITextBox5_adaptor::SelectionHighlightColorWhenNotFocused)->_put_SelectionHighlightColorWhenNotFocused(value)); }
			void operator=(pptr<Media::SolidColorBrush> value) { put(value); }
			void operator()(pptr<Media::SolidColorBrush> value) { put(value); }
		} SelectionHighlightColorWhenNotFocused;
	};
	ITextBox5_adaptor() {}
};
template<typename X> struct adapt<ITextBox5, X> : Windows::UI::Xaml::Controls::ITextBox5_adaptor<X> { typedef adapt ITextBox5; };
struct ITextBox5 : ITextBox5_raw, generate<ITextBox5> {};

// ITextBoxStatics5
struct ITextBoxStatics5 : IInspectable {
	virtual STDMETHODIMP _get_SelectionHighlightColorWhenNotFocusedProperty(DependencyProperty* *value);
};

// ITextBox6
struct ITextBox6_raw : IInspectable {
	virtual STDMETHODIMP _get_HorizontalTextAlignment(TextAlignment *value);
	virtual STDMETHODIMP _put_HorizontalTextAlignment(TextAlignment value);
	virtual STDMETHODIMP _get_CharacterCasing(Controls::CharacterCasing *value);
	virtual STDMETHODIMP _put_CharacterCasing(Controls::CharacterCasing value);
	virtual STDMETHODIMP _get_PlaceholderForeground(Media::Brush* *value);
	virtual STDMETHODIMP _put_PlaceholderForeground(Media::Brush* value);
	virtual STDMETHODIMP _add_CopyingToClipboard(Foundation::TypedEventHandler<TextBox*, TextControlCopyingToClipboardEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CopyingToClipboard(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_CuttingToClipboard(Foundation::TypedEventHandler<TextBox*, TextControlCuttingToClipboardEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CuttingToClipboard(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_BeforeTextChanging(Foundation::TypedEventHandler<TextBox*, TextBoxBeforeTextChangingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_BeforeTextChanging(Foundation::EventRegistrationToken token);
};
template<typename X> struct ITextBox6_adaptor : X {
	union {
		struct : property {
			Controls::CharacterCasing get() { Controls::CharacterCasing value; hrcheck(enc(&ITextBox6_adaptor::CharacterCasing)->_get_CharacterCasing(&value)); return value; }
			Controls::CharacterCasing operator()() { return get(); }
			operator Controls::CharacterCasing () { return get(); }
			void put(Controls::CharacterCasing value) { hrcheck(enc(&ITextBox6_adaptor::CharacterCasing)->_put_CharacterCasing(value)); }
			void operator=(Controls::CharacterCasing value) { put(value); }
			void operator()(Controls::CharacterCasing value) { put(value); }
		} CharacterCasing;
		struct : property {
			TextAlignment get() { TextAlignment value; hrcheck(enc(&ITextBox6_adaptor::HorizontalTextAlignment)->_get_HorizontalTextAlignment(&value)); return value; }
			TextAlignment operator()() { return get(); }
			operator TextAlignment () { return get(); }
			void put(TextAlignment value) { hrcheck(enc(&ITextBox6_adaptor::HorizontalTextAlignment)->_put_HorizontalTextAlignment(value)); }
			void operator=(TextAlignment value) { put(value); }
			void operator()(TextAlignment value) { put(value); }
		} HorizontalTextAlignment;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ITextBox6_adaptor::PlaceholderForeground)->_get_PlaceholderForeground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ITextBox6_adaptor::PlaceholderForeground)->_put_PlaceholderForeground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} PlaceholderForeground;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TextBox>, ptr<TextBoxBeforeTextChangingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITextBox6_adaptor::BeforeTextChanging)->_add_BeforeTextChanging(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITextBox6_adaptor::BeforeTextChanging)->_remove_BeforeTextChanging(token)); }
		} BeforeTextChanging;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TextBox>, ptr<TextControlCopyingToClipboardEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITextBox6_adaptor::CopyingToClipboard)->_add_CopyingToClipboard(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITextBox6_adaptor::CopyingToClipboard)->_remove_CopyingToClipboard(token)); }
		} CopyingToClipboard;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TextBox>, ptr<TextControlCuttingToClipboardEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITextBox6_adaptor::CuttingToClipboard)->_add_CuttingToClipboard(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITextBox6_adaptor::CuttingToClipboard)->_remove_CuttingToClipboard(token)); }
		} CuttingToClipboard;
	};
	ITextBox6_adaptor() {}
};
template<typename X> struct adapt<ITextBox6, X> : Windows::UI::Xaml::Controls::ITextBox6_adaptor<X> { typedef adapt ITextBox6; };
struct ITextBox6 : ITextBox6_raw, generate<ITextBox6> {};

// ITextBoxStatics6
struct ITextBoxStatics6 : IInspectable {
	virtual STDMETHODIMP _get_HorizontalTextAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CharacterCasingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlaceholderForegroundProperty(DependencyProperty* *value);
};

// ITextBox7
struct ITextBox7_raw : IInspectable {
	virtual STDMETHODIMP _get_HandwritingView(Controls::HandwritingView* *value);
	virtual STDMETHODIMP _put_HandwritingView(Controls::HandwritingView* value);
	virtual STDMETHODIMP _get_IsHandwritingViewEnabled(bool *value);
	virtual STDMETHODIMP _put_IsHandwritingViewEnabled(bool value);
};
template<typename X> struct ITextBox7_adaptor : X {
	union {
		struct : property {
			ptr<Controls::HandwritingView> get() { Controls::HandwritingView* value; hrcheck(enc(&ITextBox7_adaptor::HandwritingView)->_get_HandwritingView(&value)); return from_abi(value); }
			ptr<Controls::HandwritingView> operator()() { return get(); }
			operator ptr<Controls::HandwritingView> () { return get(); }
			ptr<Controls::HandwritingView> operator->() { return get(); }
			void put(pptr<Controls::HandwritingView> value) { hrcheck(enc(&ITextBox7_adaptor::HandwritingView)->_put_HandwritingView(value)); }
			void operator=(pptr<Controls::HandwritingView> value) { put(value); }
			void operator()(pptr<Controls::HandwritingView> value) { put(value); }
		} HandwritingView;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITextBox7_adaptor::IsHandwritingViewEnabled)->_get_IsHandwritingViewEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITextBox7_adaptor::IsHandwritingViewEnabled)->_put_IsHandwritingViewEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsHandwritingViewEnabled;
	};
	ITextBox7_adaptor() {}
};
template<typename X> struct adapt<ITextBox7, X> : Windows::UI::Xaml::Controls::ITextBox7_adaptor<X> { typedef adapt ITextBox7; };
struct ITextBox7 : ITextBox7_raw, generate<ITextBox7> {};

// ITextBoxStatics7
struct ITextBoxStatics7 : IInspectable {
	virtual STDMETHODIMP _get_HandwritingViewProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsHandwritingViewEnabledProperty(DependencyProperty* *value);
};

// IToggleSwitch
struct IToggleSwitch_raw : IInspectable {
	virtual STDMETHODIMP _get_IsOn(bool *value);
	virtual STDMETHODIMP _put_IsOn(bool value);
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_OnContent(IInspectable* *value);
	virtual STDMETHODIMP _put_OnContent(IInspectable* value);
	virtual STDMETHODIMP _get_OnContentTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_OnContentTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_OffContent(IInspectable* *value);
	virtual STDMETHODIMP _put_OffContent(IInspectable* value);
	virtual STDMETHODIMP _get_OffContentTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_OffContentTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_TemplateSettings(Primitives::ToggleSwitchTemplateSettings* *value);
	virtual STDMETHODIMP _add_Toggled(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Toggled(Foundation::EventRegistrationToken token);
};
template<typename X> struct IToggleSwitch_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IToggleSwitch_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IToggleSwitch_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IToggleSwitch_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IToggleSwitch_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IToggleSwitch_adaptor::IsOn)->_get_IsOn(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IToggleSwitch_adaptor::IsOn)->_put_IsOn(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsOn;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IToggleSwitch_adaptor::OffContent)->_get_OffContent(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IToggleSwitch_adaptor::OffContent)->_put_OffContent(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} OffContent;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IToggleSwitch_adaptor::OffContentTemplate)->_get_OffContentTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IToggleSwitch_adaptor::OffContentTemplate)->_put_OffContentTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} OffContentTemplate;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IToggleSwitch_adaptor::OnContent)->_get_OnContent(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IToggleSwitch_adaptor::OnContent)->_put_OnContent(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} OnContent;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IToggleSwitch_adaptor::OnContentTemplate)->_get_OnContentTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IToggleSwitch_adaptor::OnContentTemplate)->_put_OnContentTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} OnContentTemplate;
		struct : property {
			ptr<Primitives::ToggleSwitchTemplateSettings> get() { Primitives::ToggleSwitchTemplateSettings* value; hrcheck(enc(&IToggleSwitch_adaptor::TemplateSettings)->_get_TemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::ToggleSwitchTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::ToggleSwitchTemplateSettings> () { return get(); }
			ptr<Primitives::ToggleSwitchTemplateSettings> operator->() { return get(); }
		} TemplateSettings;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IToggleSwitch_adaptor::Toggled)->_add_Toggled(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IToggleSwitch_adaptor::Toggled)->_remove_Toggled(token)); }
		} Toggled;
	};
	IToggleSwitch_adaptor() {}
};
template<typename X> struct adapt<IToggleSwitch, X> : Windows::UI::Xaml::Controls::IToggleSwitch_adaptor<X> { typedef adapt IToggleSwitch; };
struct IToggleSwitch : IToggleSwitch_raw, generate<IToggleSwitch> {};

// IToggleSwitchOverrides
struct IToggleSwitchOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnToggled() = 0;
	virtual STDMETHODIMP _OnOnContentChanged(IInspectable* oldContent, IInspectable* newContent) = 0;
	virtual STDMETHODIMP _OnOffContentChanged(IInspectable* oldContent, IInspectable* newContent) = 0;
	virtual STDMETHODIMP _OnHeaderChanged(IInspectable* oldContent, IInspectable* newContent) = 0;
};
template<typename X> struct IToggleSwitchOverrides_adaptor : X {
	void OnToggled() { hrcheck(X::get()->_OnToggled()); }
	void OnOnContentChanged(object_ref oldContent, object_ref newContent) { hrcheck(X::get()->_OnOnContentChanged(oldContent, newContent)); }
	void OnOffContentChanged(object_ref oldContent, object_ref newContent) { hrcheck(X::get()->_OnOffContentChanged(oldContent, newContent)); }
	void OnHeaderChanged(object_ref oldContent, object_ref newContent) { hrcheck(X::get()->_OnHeaderChanged(oldContent, newContent)); }
};
template<typename X> struct adapt<IToggleSwitchOverrides, X> : Windows::UI::Xaml::Controls::IToggleSwitchOverrides_adaptor<X> { typedef adapt IToggleSwitchOverrides; };
template<typename X> struct IToggleSwitchOverrides_unadaptor : X {
	STDMETHODIMP _OnToggled() { return hrtry([&, this] { X::get()->OnToggled(); }); }
	STDMETHODIMP _OnOnContentChanged(IInspectable* oldContent, IInspectable* newContent) { return hrtry([&, this] { X::get()->OnOnContentChanged(oldContent, newContent); }); }
	STDMETHODIMP _OnOffContentChanged(IInspectable* oldContent, IInspectable* newContent) { return hrtry([&, this] { X::get()->OnOffContentChanged(oldContent, newContent); }); }
	STDMETHODIMP _OnHeaderChanged(IInspectable* oldContent, IInspectable* newContent) { return hrtry([&, this] { X::get()->OnHeaderChanged(oldContent, newContent); }); }
};
template<typename X> struct unadapt<IToggleSwitchOverrides, X> : Windows::UI::Xaml::Controls::IToggleSwitchOverrides_unadaptor<X> {};
struct IToggleSwitchOverrides : IToggleSwitchOverrides_raw, generate<IToggleSwitchOverrides> {};

// IToggleSwitchStatics
struct IToggleSwitchStatics : IInspectable {
	virtual STDMETHODIMP _get_IsOnProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OnContentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OnContentTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OffContentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OffContentTemplateProperty(DependencyProperty* *value);
};

// IUserControl
struct IUserControl_raw : IInspectable {
	virtual STDMETHODIMP _get_Content(UIElement* *value);
	virtual STDMETHODIMP _put_Content(UIElement* value);
};
template<typename X> struct IUserControl_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IUserControl_adaptor::Content)->_get_Content(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IUserControl_adaptor::Content)->_put_Content(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} Content;
	};
	IUserControl_adaptor() {}
};
template<typename X> struct adapt<IUserControl, X> : Windows::UI::Xaml::Controls::IUserControl_adaptor<X> { typedef adapt IUserControl; };
struct IUserControl : IUserControl_raw, generate<IUserControl> {};

// IUserControlStatics
struct IUserControlStatics : IInspectable {
	virtual STDMETHODIMP _get_ContentProperty(DependencyProperty* *value);
};

// IUserControlFactory
struct IUserControlFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, UserControl* *instance);
};

// IVariableSizedWrapGrid
struct IVariableSizedWrapGrid_raw : IInspectable {
	virtual STDMETHODIMP _get_ItemHeight(double *value);
	virtual STDMETHODIMP _put_ItemHeight(double value);
	virtual STDMETHODIMP _get_ItemWidth(double *value);
	virtual STDMETHODIMP _put_ItemWidth(double value);
	virtual STDMETHODIMP _get_Orientation(Controls::Orientation *value);
	virtual STDMETHODIMP _put_Orientation(Controls::Orientation value);
	virtual STDMETHODIMP _get_HorizontalChildrenAlignment(HorizontalAlignment *value);
	virtual STDMETHODIMP _put_HorizontalChildrenAlignment(HorizontalAlignment value);
	virtual STDMETHODIMP _get_VerticalChildrenAlignment(VerticalAlignment *value);
	virtual STDMETHODIMP _put_VerticalChildrenAlignment(VerticalAlignment value);
	virtual STDMETHODIMP _get_MaximumRowsOrColumns(int *value);
	virtual STDMETHODIMP _put_MaximumRowsOrColumns(int value);
};
template<typename X> struct IVariableSizedWrapGrid_adaptor : X {
	union {
		struct : property {
			HorizontalAlignment get() { HorizontalAlignment value; hrcheck(enc(&IVariableSizedWrapGrid_adaptor::HorizontalChildrenAlignment)->_get_HorizontalChildrenAlignment(&value)); return value; }
			HorizontalAlignment operator()() { return get(); }
			operator HorizontalAlignment () { return get(); }
			void put(HorizontalAlignment value) { hrcheck(enc(&IVariableSizedWrapGrid_adaptor::HorizontalChildrenAlignment)->_put_HorizontalChildrenAlignment(value)); }
			void operator=(HorizontalAlignment value) { put(value); }
			void operator()(HorizontalAlignment value) { put(value); }
		} HorizontalChildrenAlignment;
		struct : property {
			double get() { double value; hrcheck(enc(&IVariableSizedWrapGrid_adaptor::ItemHeight)->_get_ItemHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IVariableSizedWrapGrid_adaptor::ItemHeight)->_put_ItemHeight(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ItemHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IVariableSizedWrapGrid_adaptor::ItemWidth)->_get_ItemWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IVariableSizedWrapGrid_adaptor::ItemWidth)->_put_ItemWidth(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ItemWidth;
		struct : property {
			int get() { int value; hrcheck(enc(&IVariableSizedWrapGrid_adaptor::MaximumRowsOrColumns)->_get_MaximumRowsOrColumns(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IVariableSizedWrapGrid_adaptor::MaximumRowsOrColumns)->_put_MaximumRowsOrColumns(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaximumRowsOrColumns;
		struct : property {
			Controls::Orientation get() { Controls::Orientation value; hrcheck(enc(&IVariableSizedWrapGrid_adaptor::Orientation)->_get_Orientation(&value)); return value; }
			Controls::Orientation operator()() { return get(); }
			operator Controls::Orientation () { return get(); }
			void put(Controls::Orientation value) { hrcheck(enc(&IVariableSizedWrapGrid_adaptor::Orientation)->_put_Orientation(value)); }
			void operator=(Controls::Orientation value) { put(value); }
			void operator()(Controls::Orientation value) { put(value); }
		} Orientation;
		struct : property {
			VerticalAlignment get() { VerticalAlignment value; hrcheck(enc(&IVariableSizedWrapGrid_adaptor::VerticalChildrenAlignment)->_get_VerticalChildrenAlignment(&value)); return value; }
			VerticalAlignment operator()() { return get(); }
			operator VerticalAlignment () { return get(); }
			void put(VerticalAlignment value) { hrcheck(enc(&IVariableSizedWrapGrid_adaptor::VerticalChildrenAlignment)->_put_VerticalChildrenAlignment(value)); }
			void operator=(VerticalAlignment value) { put(value); }
			void operator()(VerticalAlignment value) { put(value); }
		} VerticalChildrenAlignment;
	};
	IVariableSizedWrapGrid_adaptor() {}
};
template<typename X> struct adapt<IVariableSizedWrapGrid, X> : Windows::UI::Xaml::Controls::IVariableSizedWrapGrid_adaptor<X> { typedef adapt IVariableSizedWrapGrid; };
struct IVariableSizedWrapGrid : IVariableSizedWrapGrid_raw, generate<IVariableSizedWrapGrid> {};

// IVariableSizedWrapGridStatics
struct IVariableSizedWrapGridStatics : IInspectable {
	virtual STDMETHODIMP _get_ItemHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OrientationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalChildrenAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalChildrenAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaximumRowsOrColumnsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RowSpanProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetRowSpan(UIElement* element, int *value);
	virtual STDMETHODIMP _SetRowSpan(UIElement* element, int value);
	virtual STDMETHODIMP _get_ColumnSpanProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetColumnSpan(UIElement* element, int *value);
	virtual STDMETHODIMP _SetColumnSpan(UIElement* element, int value);
};

// IGroupItem
struct IGroupItem : IInspectable, generate<IGroupItem> {};

// IGroupItemFactory
struct IGroupItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, GroupItem* *instance);
};

// IListViewBaseHeaderItem
struct IListViewBaseHeaderItem : IInspectable, generate<IListViewBaseHeaderItem> {};

// IListViewBaseHeaderItemFactory
struct IListViewBaseHeaderItemFactory : IInspectable, generate<IListViewBaseHeaderItemFactory> {};

// IProgressBar
struct IProgressBar_raw : IInspectable {
	virtual STDMETHODIMP _get_IsIndeterminate(bool *value);
	virtual STDMETHODIMP _put_IsIndeterminate(bool value);
	virtual STDMETHODIMP _get_ShowError(bool *value);
	virtual STDMETHODIMP _put_ShowError(bool value);
	virtual STDMETHODIMP _get_ShowPaused(bool *value);
	virtual STDMETHODIMP _put_ShowPaused(bool value);
	virtual STDMETHODIMP _get_TemplateSettings(Primitives::ProgressBarTemplateSettings* *value);
};
template<typename X> struct IProgressBar_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IProgressBar_adaptor::IsIndeterminate)->_get_IsIndeterminate(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IProgressBar_adaptor::IsIndeterminate)->_put_IsIndeterminate(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsIndeterminate;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IProgressBar_adaptor::ShowError)->_get_ShowError(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IProgressBar_adaptor::ShowError)->_put_ShowError(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ShowError;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IProgressBar_adaptor::ShowPaused)->_get_ShowPaused(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IProgressBar_adaptor::ShowPaused)->_put_ShowPaused(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ShowPaused;
		struct : property {
			ptr<Primitives::ProgressBarTemplateSettings> get() { Primitives::ProgressBarTemplateSettings* value; hrcheck(enc(&IProgressBar_adaptor::TemplateSettings)->_get_TemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::ProgressBarTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::ProgressBarTemplateSettings> () { return get(); }
			ptr<Primitives::ProgressBarTemplateSettings> operator->() { return get(); }
		} TemplateSettings;
	};
	IProgressBar_adaptor() {}
};
template<typename X> struct adapt<IProgressBar, X> : Windows::UI::Xaml::Controls::IProgressBar_adaptor<X> { typedef adapt IProgressBar; };
struct IProgressBar : IProgressBar_raw, generate<IProgressBar> {};

// IProgressBarStatics
struct IProgressBarStatics : IInspectable {
	virtual STDMETHODIMP _get_IsIndeterminateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ShowErrorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ShowPausedProperty(DependencyProperty* *value);
};

// IProgressBarFactory
struct IProgressBarFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ProgressBar* *instance);
};

// ISettingsFlyout
struct ISettingsFlyout_raw : IInspectable {
	virtual STDMETHODIMP _get_Title(HSTRING *value);
	virtual STDMETHODIMP _put_Title(HSTRING value);
	virtual STDMETHODIMP _get_HeaderBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_HeaderBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_HeaderForeground(Media::Brush* *value);
	virtual STDMETHODIMP _put_HeaderForeground(Media::Brush* value);
	virtual STDMETHODIMP _get_IconSource(Media::ImageSource* *value);
	virtual STDMETHODIMP _put_IconSource(Media::ImageSource* value);
	virtual STDMETHODIMP _get_TemplateSettings(Primitives::SettingsFlyoutTemplateSettings* *value);
	virtual STDMETHODIMP _add_BackClick(BackClickEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_BackClick(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _Show();
	virtual STDMETHODIMP _ShowIndependent();
	virtual STDMETHODIMP _Hide();
};
template<typename X> struct ISettingsFlyout_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ISettingsFlyout_adaptor::HeaderBackground)->_get_HeaderBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ISettingsFlyout_adaptor::HeaderBackground)->_put_HeaderBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} HeaderBackground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ISettingsFlyout_adaptor::HeaderForeground)->_get_HeaderForeground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ISettingsFlyout_adaptor::HeaderForeground)->_put_HeaderForeground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} HeaderForeground;
		struct : property {
			ptr<Media::ImageSource> get() { Media::ImageSource* value; hrcheck(enc(&ISettingsFlyout_adaptor::IconSource)->_get_IconSource(&value)); return from_abi(value); }
			ptr<Media::ImageSource> operator()() { return get(); }
			operator ptr<Media::ImageSource> () { return get(); }
			ptr<Media::ImageSource> operator->() { return get(); }
			void put(pptr<Media::ImageSource> value) { hrcheck(enc(&ISettingsFlyout_adaptor::IconSource)->_put_IconSource(value)); }
			void operator=(pptr<Media::ImageSource> value) { put(value); }
			void operator()(pptr<Media::ImageSource> value) { put(value); }
		} IconSource;
		struct : property {
			ptr<Primitives::SettingsFlyoutTemplateSettings> get() { Primitives::SettingsFlyoutTemplateSettings* value; hrcheck(enc(&ISettingsFlyout_adaptor::TemplateSettings)->_get_TemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::SettingsFlyoutTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::SettingsFlyoutTemplateSettings> () { return get(); }
			ptr<Primitives::SettingsFlyoutTemplateSettings> operator->() { return get(); }
		} TemplateSettings;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISettingsFlyout_adaptor::Title)->_get_Title(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISettingsFlyout_adaptor::Title)->_put_Title(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Title;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<BackClickEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISettingsFlyout_adaptor::BackClick)->_add_BackClick(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISettingsFlyout_adaptor::BackClick)->_remove_BackClick(token)); }
		} BackClick;
	};
	void Show() { hrcheck(X::get()->_Show()); }
	void ShowIndependent() { hrcheck(X::get()->_ShowIndependent()); }
	void Hide() { hrcheck(X::get()->_Hide()); }
	ISettingsFlyout_adaptor() {}
};
template<typename X> struct adapt<ISettingsFlyout, X> : Windows::UI::Xaml::Controls::ISettingsFlyout_adaptor<X> { typedef adapt ISettingsFlyout; };
struct ISettingsFlyout : ISettingsFlyout_raw, generate<ISettingsFlyout> {};

// ISettingsFlyoutStatics
struct ISettingsFlyoutStatics : IInspectable {
	virtual STDMETHODIMP _get_TitleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderForegroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IconSourceProperty(DependencyProperty* *value);
};

// ISettingsFlyoutFactory
struct ISettingsFlyoutFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, SettingsFlyout* *instance);
};

// IToolTip
struct IToolTip_raw : IInspectable {
	virtual STDMETHODIMP _get_HorizontalOffset(double *value);
	virtual STDMETHODIMP _put_HorizontalOffset(double value);
	virtual STDMETHODIMP _get_IsOpen(bool *value);
	virtual STDMETHODIMP _put_IsOpen(bool value);
	virtual STDMETHODIMP _get_Placement(Primitives::PlacementMode *value);
	virtual STDMETHODIMP _put_Placement(Primitives::PlacementMode value);
	virtual STDMETHODIMP _get_PlacementTarget(UIElement* *value);
	virtual STDMETHODIMP _put_PlacementTarget(UIElement* value);
	virtual STDMETHODIMP _get_VerticalOffset(double *value);
	virtual STDMETHODIMP _put_VerticalOffset(double value);
	virtual STDMETHODIMP _get_TemplateSettings(Primitives::ToolTipTemplateSettings* *value);
	virtual STDMETHODIMP _add_Closed(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Closed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Opened(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Opened(Foundation::EventRegistrationToken token);
};
template<typename X> struct IToolTip_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IToolTip_adaptor::HorizontalOffset)->_get_HorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IToolTip_adaptor::HorizontalOffset)->_put_HorizontalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} HorizontalOffset;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IToolTip_adaptor::IsOpen)->_get_IsOpen(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IToolTip_adaptor::IsOpen)->_put_IsOpen(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsOpen;
		struct : property {
			Primitives::PlacementMode get() { Primitives::PlacementMode value; hrcheck(enc(&IToolTip_adaptor::Placement)->_get_Placement(&value)); return value; }
			Primitives::PlacementMode operator()() { return get(); }
			operator Primitives::PlacementMode () { return get(); }
			void put(Primitives::PlacementMode value) { hrcheck(enc(&IToolTip_adaptor::Placement)->_put_Placement(value)); }
			void operator=(Primitives::PlacementMode value) { put(value); }
			void operator()(Primitives::PlacementMode value) { put(value); }
		} Placement;
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IToolTip_adaptor::PlacementTarget)->_get_PlacementTarget(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IToolTip_adaptor::PlacementTarget)->_put_PlacementTarget(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} PlacementTarget;
		struct : property {
			ptr<Primitives::ToolTipTemplateSettings> get() { Primitives::ToolTipTemplateSettings* value; hrcheck(enc(&IToolTip_adaptor::TemplateSettings)->_get_TemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::ToolTipTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::ToolTipTemplateSettings> () { return get(); }
			ptr<Primitives::ToolTipTemplateSettings> operator->() { return get(); }
		} TemplateSettings;
		struct : property {
			double get() { double value; hrcheck(enc(&IToolTip_adaptor::VerticalOffset)->_get_VerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IToolTip_adaptor::VerticalOffset)->_put_VerticalOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} VerticalOffset;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IToolTip_adaptor::Closed)->_add_Closed(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IToolTip_adaptor::Closed)->_remove_Closed(token)); }
		} Closed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IToolTip_adaptor::Opened)->_add_Opened(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IToolTip_adaptor::Opened)->_remove_Opened(token)); }
		} Opened;
	};
	IToolTip_adaptor() {}
};
template<typename X> struct adapt<IToolTip, X> : Windows::UI::Xaml::Controls::IToolTip_adaptor<X> { typedef adapt IToolTip; };
struct IToolTip : IToolTip_raw, generate<IToolTip> {};

// IToolTipStatics
struct IToolTipStatics : IInspectable {
	virtual STDMETHODIMP _get_HorizontalOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsOpenProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlacementProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlacementTargetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalOffsetProperty(DependencyProperty* *value);
};

// IToolTipFactory
struct IToolTipFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ToolTip* *instance);
};

// IButton
struct IButton : IInspectable, generate<IButton> {};

// IButtonFactory
struct IButtonFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Button* *instance);
};

// IButtonWithFlyout
struct IButtonWithFlyout_raw : IInspectable {
	virtual STDMETHODIMP _get_Flyout(Primitives::FlyoutBase* *value);
	virtual STDMETHODIMP _put_Flyout(Primitives::FlyoutBase* value);
};
template<typename X> struct IButtonWithFlyout_adaptor : X {
	union {
		struct : property {
			ptr<Primitives::FlyoutBase> get() { Primitives::FlyoutBase* value; hrcheck(enc(&IButtonWithFlyout_adaptor::Flyout)->_get_Flyout(&value)); return from_abi(value); }
			ptr<Primitives::FlyoutBase> operator()() { return get(); }
			operator ptr<Primitives::FlyoutBase> () { return get(); }
			ptr<Primitives::FlyoutBase> operator->() { return get(); }
			void put(pptr<Primitives::FlyoutBase> value) { hrcheck(enc(&IButtonWithFlyout_adaptor::Flyout)->_put_Flyout(value)); }
			void operator=(pptr<Primitives::FlyoutBase> value) { put(value); }
			void operator()(pptr<Primitives::FlyoutBase> value) { put(value); }
		} Flyout;
	};
	IButtonWithFlyout_adaptor() {}
};
template<typename X> struct adapt<IButtonWithFlyout, X> : Windows::UI::Xaml::Controls::IButtonWithFlyout_adaptor<X> { typedef adapt IButtonWithFlyout; };
struct IButtonWithFlyout : IButtonWithFlyout_raw, generate<IButtonWithFlyout> {};

// IButtonStaticsWithFlyout
struct IButtonStaticsWithFlyout : IInspectable {
	virtual STDMETHODIMP _get_FlyoutProperty(DependencyProperty* *value);
};

// IComboBox
struct IComboBox_raw : IInspectable {
	virtual STDMETHODIMP _get_IsDropDownOpen(bool *value);
	virtual STDMETHODIMP _put_IsDropDownOpen(bool value);
	virtual STDMETHODIMP _get_IsEditable(bool *value);
	virtual STDMETHODIMP _get_IsSelectionBoxHighlighted(bool *value);
	virtual STDMETHODIMP _get_MaxDropDownHeight(double *value);
	virtual STDMETHODIMP _put_MaxDropDownHeight(double value);
	virtual STDMETHODIMP _get_SelectionBoxItem(IInspectable* *value);
	virtual STDMETHODIMP _get_SelectionBoxItemTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _get_TemplateSettings(Primitives::ComboBoxTemplateSettings* *value);
	virtual STDMETHODIMP _add_DropDownClosed(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DropDownClosed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DropDownOpened(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DropDownOpened(Foundation::EventRegistrationToken token);
};
template<typename X> struct IComboBox_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IComboBox_adaptor::IsDropDownOpen)->_get_IsDropDownOpen(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IComboBox_adaptor::IsDropDownOpen)->_put_IsDropDownOpen(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsDropDownOpen;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IComboBox_adaptor::IsEditable)->_get_IsEditable(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsEditable;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IComboBox_adaptor::IsSelectionBoxHighlighted)->_get_IsSelectionBoxHighlighted(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsSelectionBoxHighlighted;
		struct : property {
			double get() { double value; hrcheck(enc(&IComboBox_adaptor::MaxDropDownHeight)->_get_MaxDropDownHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IComboBox_adaptor::MaxDropDownHeight)->_put_MaxDropDownHeight(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MaxDropDownHeight;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IComboBox_adaptor::SelectionBoxItem)->_get_SelectionBoxItem(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} SelectionBoxItem;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IComboBox_adaptor::SelectionBoxItemTemplate)->_get_SelectionBoxItemTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
		} SelectionBoxItemTemplate;
		struct : property {
			ptr<Primitives::ComboBoxTemplateSettings> get() { Primitives::ComboBoxTemplateSettings* value; hrcheck(enc(&IComboBox_adaptor::TemplateSettings)->_get_TemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::ComboBoxTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::ComboBoxTemplateSettings> () { return get(); }
			ptr<Primitives::ComboBoxTemplateSettings> operator->() { return get(); }
		} TemplateSettings;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IComboBox_adaptor::DropDownClosed)->_add_DropDownClosed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IComboBox_adaptor::DropDownClosed)->_remove_DropDownClosed(token)); }
		} DropDownClosed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IComboBox_adaptor::DropDownOpened)->_add_DropDownOpened(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IComboBox_adaptor::DropDownOpened)->_remove_DropDownOpened(token)); }
		} DropDownOpened;
	};
	IComboBox_adaptor() {}
};
template<typename X> struct adapt<IComboBox, X> : Windows::UI::Xaml::Controls::IComboBox_adaptor<X> { typedef adapt IComboBox; };
struct IComboBox : IComboBox_raw, generate<IComboBox> {};

// IComboBoxOverrides
struct IComboBoxOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnDropDownClosed(IInspectable* e) = 0;
	virtual STDMETHODIMP _OnDropDownOpened(IInspectable* e) = 0;
};
template<typename X> struct IComboBoxOverrides_adaptor : X {
	void OnDropDownClosed(object_ref e) { hrcheck(X::get()->_OnDropDownClosed(e)); }
	void OnDropDownOpened(object_ref e) { hrcheck(X::get()->_OnDropDownOpened(e)); }
};
template<typename X> struct adapt<IComboBoxOverrides, X> : Windows::UI::Xaml::Controls::IComboBoxOverrides_adaptor<X> { typedef adapt IComboBoxOverrides; };
template<typename X> struct IComboBoxOverrides_unadaptor : X {
	STDMETHODIMP _OnDropDownClosed(IInspectable* e) { return hrtry([&, this] { X::get()->OnDropDownClosed(e); }); }
	STDMETHODIMP _OnDropDownOpened(IInspectable* e) { return hrtry([&, this] { X::get()->OnDropDownOpened(e); }); }
};
template<typename X> struct unadapt<IComboBoxOverrides, X> : Windows::UI::Xaml::Controls::IComboBoxOverrides_unadaptor<X> {};
struct IComboBoxOverrides : IComboBoxOverrides_raw, generate<IComboBoxOverrides> {};

// IComboBoxStatics
struct IComboBoxStatics : IInspectable {
	virtual STDMETHODIMP _get_IsDropDownOpenProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxDropDownHeightProperty(DependencyProperty* *value);
};

// IComboBoxFactory
struct IComboBoxFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ComboBox* *instance);
};

// IComboBox2
struct IComboBox2_raw : IInspectable {
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_PlaceholderText(HSTRING *value);
	virtual STDMETHODIMP _put_PlaceholderText(HSTRING value);
};
template<typename X> struct IComboBox2_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IComboBox2_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IComboBox2_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IComboBox2_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IComboBox2_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IComboBox2_adaptor::PlaceholderText)->_get_PlaceholderText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IComboBox2_adaptor::PlaceholderText)->_put_PlaceholderText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PlaceholderText;
	};
	IComboBox2_adaptor() {}
};
template<typename X> struct adapt<IComboBox2, X> : Windows::UI::Xaml::Controls::IComboBox2_adaptor<X> { typedef adapt IComboBox2; };
struct IComboBox2 : IComboBox2_raw, generate<IComboBox2> {};

// IComboBoxStatics2
struct IComboBoxStatics2 : IInspectable {
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlaceholderTextProperty(DependencyProperty* *value);
};

// IComboBox3
struct IComboBox3_raw : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayMode(Controls::LightDismissOverlayMode *value);
	virtual STDMETHODIMP _put_LightDismissOverlayMode(Controls::LightDismissOverlayMode value);
	virtual STDMETHODIMP _get_IsTextSearchEnabled(bool *value);
	virtual STDMETHODIMP _put_IsTextSearchEnabled(bool value);
};
template<typename X> struct IComboBox3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IComboBox3_adaptor::IsTextSearchEnabled)->_get_IsTextSearchEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IComboBox3_adaptor::IsTextSearchEnabled)->_put_IsTextSearchEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTextSearchEnabled;
		struct : property {
			Controls::LightDismissOverlayMode get() { Controls::LightDismissOverlayMode value; hrcheck(enc(&IComboBox3_adaptor::LightDismissOverlayMode)->_get_LightDismissOverlayMode(&value)); return value; }
			Controls::LightDismissOverlayMode operator()() { return get(); }
			operator Controls::LightDismissOverlayMode () { return get(); }
			void put(Controls::LightDismissOverlayMode value) { hrcheck(enc(&IComboBox3_adaptor::LightDismissOverlayMode)->_put_LightDismissOverlayMode(value)); }
			void operator=(Controls::LightDismissOverlayMode value) { put(value); }
			void operator()(Controls::LightDismissOverlayMode value) { put(value); }
		} LightDismissOverlayMode;
	};
	IComboBox3_adaptor() {}
};
template<typename X> struct adapt<IComboBox3, X> : Windows::UI::Xaml::Controls::IComboBox3_adaptor<X> { typedef adapt IComboBox3; };
struct IComboBox3 : IComboBox3_raw, generate<IComboBox3> {};

// IComboBoxStatics3
struct IComboBoxStatics3 : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsTextSearchEnabledProperty(DependencyProperty* *value);
};

// IComboBox4
struct IComboBox4_raw : IInspectable {
	virtual STDMETHODIMP _get_SelectionChangedTrigger(ComboBoxSelectionChangedTrigger *value);
	virtual STDMETHODIMP _put_SelectionChangedTrigger(ComboBoxSelectionChangedTrigger value);
};
template<typename X> struct IComboBox4_adaptor : X {
	union {
		struct : property {
			ComboBoxSelectionChangedTrigger get() { ComboBoxSelectionChangedTrigger value; hrcheck(enc(&IComboBox4_adaptor::SelectionChangedTrigger)->_get_SelectionChangedTrigger(&value)); return value; }
			ComboBoxSelectionChangedTrigger operator()() { return get(); }
			operator ComboBoxSelectionChangedTrigger () { return get(); }
			void put(ComboBoxSelectionChangedTrigger value) { hrcheck(enc(&IComboBox4_adaptor::SelectionChangedTrigger)->_put_SelectionChangedTrigger(value)); }
			void operator=(ComboBoxSelectionChangedTrigger value) { put(value); }
			void operator()(ComboBoxSelectionChangedTrigger value) { put(value); }
		} SelectionChangedTrigger;
	};
	IComboBox4_adaptor() {}
};
template<typename X> struct adapt<IComboBox4, X> : Windows::UI::Xaml::Controls::IComboBox4_adaptor<X> { typedef adapt IComboBox4; };
struct IComboBox4 : IComboBox4_raw, generate<IComboBox4> {};

// IComboBoxStatics4
struct IComboBoxStatics4 : IInspectable {
	virtual STDMETHODIMP _get_SelectionChangedTriggerProperty(DependencyProperty* *value);
};

// IComboBox5
struct IComboBox5_raw : IInspectable {
	virtual STDMETHODIMP _get_PlaceholderForeground(Media::Brush* *value);
	virtual STDMETHODIMP _put_PlaceholderForeground(Media::Brush* value);
};
template<typename X> struct IComboBox5_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IComboBox5_adaptor::PlaceholderForeground)->_get_PlaceholderForeground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IComboBox5_adaptor::PlaceholderForeground)->_put_PlaceholderForeground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} PlaceholderForeground;
	};
	IComboBox5_adaptor() {}
};
template<typename X> struct adapt<IComboBox5, X> : Windows::UI::Xaml::Controls::IComboBox5_adaptor<X> { typedef adapt IComboBox5; };
struct IComboBox5 : IComboBox5_raw, generate<IComboBox5> {};

// IComboBoxStatics5
struct IComboBoxStatics5 : IInspectable {
	virtual STDMETHODIMP _get_PlaceholderForegroundProperty(DependencyProperty* *value);
};

// IComboBoxItem
struct IComboBoxItem : IInspectable, generate<IComboBoxItem> {};

// IComboBoxItemFactory
struct IComboBoxItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ComboBoxItem* *instance);
};

// IFlipView
struct IFlipView : IInspectable, generate<IFlipView> {};

// IFlipViewFactory
struct IFlipViewFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, FlipView* *instance);
};

// IFlipView2
struct IFlipView2_raw : IInspectable {
	virtual STDMETHODIMP _get_UseTouchAnimationsForAllNavigation(bool *value);
	virtual STDMETHODIMP _put_UseTouchAnimationsForAllNavigation(bool value);
};
template<typename X> struct IFlipView2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFlipView2_adaptor::UseTouchAnimationsForAllNavigation)->_get_UseTouchAnimationsForAllNavigation(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IFlipView2_adaptor::UseTouchAnimationsForAllNavigation)->_put_UseTouchAnimationsForAllNavigation(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} UseTouchAnimationsForAllNavigation;
	};
	IFlipView2_adaptor() {}
};
template<typename X> struct adapt<IFlipView2, X> : Windows::UI::Xaml::Controls::IFlipView2_adaptor<X> { typedef adapt IFlipView2; };
struct IFlipView2 : IFlipView2_raw, generate<IFlipView2> {};

// IFlipViewStatics2
struct IFlipViewStatics2 : IInspectable {
	virtual STDMETHODIMP _get_UseTouchAnimationsForAllNavigationProperty(DependencyProperty* *value);
};

// IFlipViewItem
struct IFlipViewItem : IInspectable, generate<IFlipViewItem> {};

// IFlipViewItemFactory
struct IFlipViewItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, FlipViewItem* *instance);
};

// IHyperlinkButton
struct IHyperlinkButton_raw : IInspectable {
	virtual STDMETHODIMP _get_NavigateUri(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_NavigateUri(Foundation::Uri* value);
};
template<typename X> struct IHyperlinkButton_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IHyperlinkButton_adaptor::NavigateUri)->_get_NavigateUri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IHyperlinkButton_adaptor::NavigateUri)->_put_NavigateUri(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} NavigateUri;
	};
	IHyperlinkButton_adaptor() {}
};
template<typename X> struct adapt<IHyperlinkButton, X> : Windows::UI::Xaml::Controls::IHyperlinkButton_adaptor<X> { typedef adapt IHyperlinkButton; };
struct IHyperlinkButton : IHyperlinkButton_raw, generate<IHyperlinkButton> {};

// IHyperlinkButtonStatics
struct IHyperlinkButtonStatics : IInspectable {
	virtual STDMETHODIMP _get_NavigateUriProperty(DependencyProperty* *value);
};

// IHyperlinkButtonFactory
struct IHyperlinkButtonFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, HyperlinkButton* *instance);
};

// IListBox
struct IListBox_raw : IInspectable {
	virtual STDMETHODIMP _get_SelectedItems(Foundation::Collections::IVector<IInspectable*>* *value);
	virtual STDMETHODIMP _get_SelectionMode(Controls::SelectionMode *value);
	virtual STDMETHODIMP _put_SelectionMode(Controls::SelectionMode value);
	virtual STDMETHODIMP _ScrollIntoView(IInspectable* item);
	virtual STDMETHODIMP _SelectAll();
};
template<typename X> struct IListBox_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<object>> get() { Foundation::Collections::IVector<IInspectable*>* value; hrcheck(enc(&IListBox_adaptor::SelectedItems)->_get_SelectedItems(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<object>> () { return get(); }
			ptr<Foundation::Collections::IVector<object>> operator->() { return get(); }
		} SelectedItems;
		struct : property {
			Controls::SelectionMode get() { Controls::SelectionMode value; hrcheck(enc(&IListBox_adaptor::SelectionMode)->_get_SelectionMode(&value)); return value; }
			Controls::SelectionMode operator()() { return get(); }
			operator Controls::SelectionMode () { return get(); }
			void put(Controls::SelectionMode value) { hrcheck(enc(&IListBox_adaptor::SelectionMode)->_put_SelectionMode(value)); }
			void operator=(Controls::SelectionMode value) { put(value); }
			void operator()(Controls::SelectionMode value) { put(value); }
		} SelectionMode;
	};
	void ScrollIntoView(object_ref item) { hrcheck(X::get()->_ScrollIntoView(item)); }
	void SelectAll() { hrcheck(X::get()->_SelectAll()); }
	IListBox_adaptor() {}
};
template<typename X> struct adapt<IListBox, X> : Windows::UI::Xaml::Controls::IListBox_adaptor<X> { typedef adapt IListBox; };
struct IListBox : IListBox_raw, generate<IListBox> {};

// IListBoxStatics
struct IListBoxStatics : IInspectable {
	virtual STDMETHODIMP _get_SelectionModeProperty(DependencyProperty* *value);
};

// IListBoxFactory
struct IListBoxFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ListBox* *instance);
};

// IListBox2
struct IListBox2_raw : IInspectable {
	virtual STDMETHODIMP _get_SingleSelectionFollowsFocus(bool *value);
	virtual STDMETHODIMP _put_SingleSelectionFollowsFocus(bool value);
};
template<typename X> struct IListBox2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IListBox2_adaptor::SingleSelectionFollowsFocus)->_get_SingleSelectionFollowsFocus(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IListBox2_adaptor::SingleSelectionFollowsFocus)->_put_SingleSelectionFollowsFocus(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} SingleSelectionFollowsFocus;
	};
	IListBox2_adaptor() {}
};
template<typename X> struct adapt<IListBox2, X> : Windows::UI::Xaml::Controls::IListBox2_adaptor<X> { typedef adapt IListBox2; };
struct IListBox2 : IListBox2_raw, generate<IListBox2> {};

// IListBoxStatics2
struct IListBoxStatics2 : IInspectable {
	virtual STDMETHODIMP _get_SingleSelectionFollowsFocusProperty(DependencyProperty* *value);
};

// IListBoxItem
struct IListBoxItem : IInspectable, generate<IListBoxItem> {};

// IListBoxItemFactory
struct IListBoxItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ListBoxItem* *instance);
};

// IListViewBase
struct IListViewBase_raw : IInspectable {
	virtual STDMETHODIMP _get_SelectedItems(Foundation::Collections::IVector<IInspectable*>* *value);
	virtual STDMETHODIMP _get_SelectionMode(ListViewSelectionMode *value);
	virtual STDMETHODIMP _put_SelectionMode(ListViewSelectionMode value);
	virtual STDMETHODIMP _get_IsSwipeEnabled(bool *value);
	virtual STDMETHODIMP _put_IsSwipeEnabled(bool value);
	virtual STDMETHODIMP _get_CanDragItems(bool *value);
	virtual STDMETHODIMP _put_CanDragItems(bool value);
	virtual STDMETHODIMP _get_CanReorderItems(bool *value);
	virtual STDMETHODIMP _put_CanReorderItems(bool value);
	virtual STDMETHODIMP _get_IsItemClickEnabled(bool *value);
	virtual STDMETHODIMP _put_IsItemClickEnabled(bool value);
	virtual STDMETHODIMP _get_DataFetchSize(double *value);
	virtual STDMETHODIMP _put_DataFetchSize(double value);
	virtual STDMETHODIMP _get_IncrementalLoadingThreshold(double *value);
	virtual STDMETHODIMP _put_IncrementalLoadingThreshold(double value);
	virtual STDMETHODIMP _get_IncrementalLoadingTrigger(Controls::IncrementalLoadingTrigger *value);
	virtual STDMETHODIMP _put_IncrementalLoadingTrigger(Controls::IncrementalLoadingTrigger value);
	virtual STDMETHODIMP _add_ItemClick(ItemClickEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ItemClick(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DragItemsStarting(DragItemsStartingEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DragItemsStarting(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _ScrollIntoView(IInspectable* item);
	virtual STDMETHODIMP _SelectAll();
	virtual STDMETHODIMP _LoadMoreItemsAsync(Foundation::IAsyncOperation<Data::LoadMoreItemsResult>* *returnValue);
	virtual STDMETHODIMP _ScrollIntoViewWithAlignment(IInspectable* item, ScrollIntoViewAlignment alignment);
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_HeaderTransitions(Media::Animation::TransitionCollection* *value);
	virtual STDMETHODIMP _put_HeaderTransitions(Media::Animation::TransitionCollection* value);
};
template<typename X> struct IListViewBase_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IListViewBase_adaptor::CanDragItems)->_get_CanDragItems(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IListViewBase_adaptor::CanDragItems)->_put_CanDragItems(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} CanDragItems;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IListViewBase_adaptor::CanReorderItems)->_get_CanReorderItems(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IListViewBase_adaptor::CanReorderItems)->_put_CanReorderItems(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} CanReorderItems;
		struct : property {
			double get() { double value; hrcheck(enc(&IListViewBase_adaptor::DataFetchSize)->_get_DataFetchSize(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IListViewBase_adaptor::DataFetchSize)->_put_DataFetchSize(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DataFetchSize;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IListViewBase_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IListViewBase_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IListViewBase_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IListViewBase_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
		struct : property {
			ptr<Media::Animation::TransitionCollection> get() { Media::Animation::TransitionCollection* value; hrcheck(enc(&IListViewBase_adaptor::HeaderTransitions)->_get_HeaderTransitions(&value)); return from_abi(value); }
			ptr<Media::Animation::TransitionCollection> operator()() { return get(); }
			operator ptr<Media::Animation::TransitionCollection> () { return get(); }
			ptr<Media::Animation::TransitionCollection> operator->() { return get(); }
			void put(pptr<Media::Animation::TransitionCollection> value) { hrcheck(enc(&IListViewBase_adaptor::HeaderTransitions)->_put_HeaderTransitions(value)); }
			void operator=(pptr<Media::Animation::TransitionCollection> value) { put(value); }
			void operator()(pptr<Media::Animation::TransitionCollection> value) { put(value); }
		} HeaderTransitions;
		struct : property {
			double get() { double value; hrcheck(enc(&IListViewBase_adaptor::IncrementalLoadingThreshold)->_get_IncrementalLoadingThreshold(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IListViewBase_adaptor::IncrementalLoadingThreshold)->_put_IncrementalLoadingThreshold(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} IncrementalLoadingThreshold;
		struct : property {
			Controls::IncrementalLoadingTrigger get() { Controls::IncrementalLoadingTrigger value; hrcheck(enc(&IListViewBase_adaptor::IncrementalLoadingTrigger)->_get_IncrementalLoadingTrigger(&value)); return value; }
			Controls::IncrementalLoadingTrigger operator()() { return get(); }
			operator Controls::IncrementalLoadingTrigger () { return get(); }
			void put(Controls::IncrementalLoadingTrigger value) { hrcheck(enc(&IListViewBase_adaptor::IncrementalLoadingTrigger)->_put_IncrementalLoadingTrigger(value)); }
			void operator=(Controls::IncrementalLoadingTrigger value) { put(value); }
			void operator()(Controls::IncrementalLoadingTrigger value) { put(value); }
		} IncrementalLoadingTrigger;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IListViewBase_adaptor::IsItemClickEnabled)->_get_IsItemClickEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IListViewBase_adaptor::IsItemClickEnabled)->_put_IsItemClickEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsItemClickEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IListViewBase_adaptor::IsSwipeEnabled)->_get_IsSwipeEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IListViewBase_adaptor::IsSwipeEnabled)->_put_IsSwipeEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSwipeEnabled;
		struct : property {
			ptr<Foundation::Collections::IVector<object>> get() { Foundation::Collections::IVector<IInspectable*>* value; hrcheck(enc(&IListViewBase_adaptor::SelectedItems)->_get_SelectedItems(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<object>> () { return get(); }
			ptr<Foundation::Collections::IVector<object>> operator->() { return get(); }
		} SelectedItems;
		struct : property {
			ListViewSelectionMode get() { ListViewSelectionMode value; hrcheck(enc(&IListViewBase_adaptor::SelectionMode)->_get_SelectionMode(&value)); return value; }
			ListViewSelectionMode operator()() { return get(); }
			operator ListViewSelectionMode () { return get(); }
			void put(ListViewSelectionMode value) { hrcheck(enc(&IListViewBase_adaptor::SelectionMode)->_put_SelectionMode(value)); }
			void operator=(ListViewSelectionMode value) { put(value); }
			void operator()(ListViewSelectionMode value) { put(value); }
		} SelectionMode;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<DragItemsStartingEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IListViewBase_adaptor::DragItemsStarting)->_add_DragItemsStarting(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IListViewBase_adaptor::DragItemsStarting)->_remove_DragItemsStarting(token)); }
		} DragItemsStarting;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<ItemClickEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IListViewBase_adaptor::ItemClick)->_add_ItemClick(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IListViewBase_adaptor::ItemClick)->_remove_ItemClick(token)); }
		} ItemClick;
	};
	void ScrollIntoView(object_ref item) { hrcheck(X::get()->_ScrollIntoView(item)); }
	void SelectAll() { hrcheck(X::get()->_SelectAll()); }
	ptr<Foundation::IAsyncOperation<Data::LoadMoreItemsResult>> LoadMoreItemsAsync() { Foundation::IAsyncOperation<Data::LoadMoreItemsResult>* returnValue; hrcheck(X::get()->_LoadMoreItemsAsync(&returnValue)); return from_abi(returnValue); }
	void ScrollIntoView(object_ref item, ScrollIntoViewAlignment alignment) { hrcheck(X::get()->_ScrollIntoViewWithAlignment(item, alignment)); }
	IListViewBase_adaptor() {}
};
template<typename X> struct adapt<IListViewBase, X> : Windows::UI::Xaml::Controls::IListViewBase_adaptor<X> { typedef adapt IListViewBase; };
struct IListViewBase : IListViewBase_raw, generate<IListViewBase> {};

// IListViewBaseStatics
struct IListViewBaseStatics : IInspectable {
	virtual STDMETHODIMP _get_SelectionModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsSwipeEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CanDragItemsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CanReorderItemsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsItemClickEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DataFetchSizeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IncrementalLoadingThresholdProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IncrementalLoadingTriggerProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SemanticZoomOwnerProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsActiveViewProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsZoomedInViewProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTransitionsProperty(DependencyProperty* *value);
};

// IListViewBaseFactory
struct IListViewBaseFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ListViewBase* *instance);
};

// IListViewBase2
struct IListViewBase2_raw : IInspectable {
	virtual STDMETHODIMP _get_ShowsScrollingPlaceholders(bool *value);
	virtual STDMETHODIMP _put_ShowsScrollingPlaceholders(bool value);
	virtual STDMETHODIMP _add_ContainerContentChanging(Foundation::TypedEventHandler<ListViewBase*, ContainerContentChangingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ContainerContentChanging(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _SetDesiredContainerUpdateDuration(Foundation::TimeSpan duration);
	virtual STDMETHODIMP _get_Footer(IInspectable* *value);
	virtual STDMETHODIMP _put_Footer(IInspectable* value);
	virtual STDMETHODIMP _get_FooterTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_FooterTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_FooterTransitions(Media::Animation::TransitionCollection* *value);
	virtual STDMETHODIMP _put_FooterTransitions(Media::Animation::TransitionCollection* value);
};
template<typename X> struct IListViewBase2_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IListViewBase2_adaptor::Footer)->_get_Footer(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IListViewBase2_adaptor::Footer)->_put_Footer(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Footer;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IListViewBase2_adaptor::FooterTemplate)->_get_FooterTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IListViewBase2_adaptor::FooterTemplate)->_put_FooterTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} FooterTemplate;
		struct : property {
			ptr<Media::Animation::TransitionCollection> get() { Media::Animation::TransitionCollection* value; hrcheck(enc(&IListViewBase2_adaptor::FooterTransitions)->_get_FooterTransitions(&value)); return from_abi(value); }
			ptr<Media::Animation::TransitionCollection> operator()() { return get(); }
			operator ptr<Media::Animation::TransitionCollection> () { return get(); }
			ptr<Media::Animation::TransitionCollection> operator->() { return get(); }
			void put(pptr<Media::Animation::TransitionCollection> value) { hrcheck(enc(&IListViewBase2_adaptor::FooterTransitions)->_put_FooterTransitions(value)); }
			void operator=(pptr<Media::Animation::TransitionCollection> value) { put(value); }
			void operator()(pptr<Media::Animation::TransitionCollection> value) { put(value); }
		} FooterTransitions;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IListViewBase2_adaptor::ShowsScrollingPlaceholders)->_get_ShowsScrollingPlaceholders(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IListViewBase2_adaptor::ShowsScrollingPlaceholders)->_put_ShowsScrollingPlaceholders(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ShowsScrollingPlaceholders;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ListViewBase>, ptr<ContainerContentChangingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IListViewBase2_adaptor::ContainerContentChanging)->_add_ContainerContentChanging(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IListViewBase2_adaptor::ContainerContentChanging)->_remove_ContainerContentChanging(token)); }
		} ContainerContentChanging;
	};
	void SetDesiredContainerUpdateDuration(const Foundation::TimeSpan& duration) { hrcheck(X::get()->_SetDesiredContainerUpdateDuration(duration)); }
	IListViewBase2_adaptor() {}
};
template<typename X> struct adapt<IListViewBase2, X> : Windows::UI::Xaml::Controls::IListViewBase2_adaptor<X> { typedef adapt IListViewBase2; };
struct IListViewBase2 : IListViewBase2_raw, generate<IListViewBase2> {};

// IListViewBaseStatics2
struct IListViewBaseStatics2 : IInspectable {
	virtual STDMETHODIMP _get_ShowsScrollingPlaceholdersProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FooterProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FooterTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FooterTransitionsProperty(DependencyProperty* *value);
};

// IListViewBase3
struct IListViewBase3_raw : IInspectable {
	virtual STDMETHODIMP _get_ReorderMode(ListViewReorderMode *value);
	virtual STDMETHODIMP _put_ReorderMode(ListViewReorderMode value);
};
template<typename X> struct IListViewBase3_adaptor : X {
	union {
		struct : property {
			ListViewReorderMode get() { ListViewReorderMode value; hrcheck(enc(&IListViewBase3_adaptor::ReorderMode)->_get_ReorderMode(&value)); return value; }
			ListViewReorderMode operator()() { return get(); }
			operator ListViewReorderMode () { return get(); }
			void put(ListViewReorderMode value) { hrcheck(enc(&IListViewBase3_adaptor::ReorderMode)->_put_ReorderMode(value)); }
			void operator=(ListViewReorderMode value) { put(value); }
			void operator()(ListViewReorderMode value) { put(value); }
		} ReorderMode;
	};
	IListViewBase3_adaptor() {}
};
template<typename X> struct adapt<IListViewBase3, X> : Windows::UI::Xaml::Controls::IListViewBase3_adaptor<X> { typedef adapt IListViewBase3; };
struct IListViewBase3 : IListViewBase3_raw, generate<IListViewBase3> {};

// IListViewBaseStatics3
struct IListViewBaseStatics3 : IInspectable {
	virtual STDMETHODIMP _get_ReorderModeProperty(DependencyProperty* *value);
};

// IListViewBase4
struct IListViewBase4_raw : IInspectable {
	virtual STDMETHODIMP _get_SelectedRanges(Foundation::Collections::IVectorView<Data::ItemIndexRange*>* *value);
	virtual STDMETHODIMP _get_IsMultiSelectCheckBoxEnabled(bool *value);
	virtual STDMETHODIMP _put_IsMultiSelectCheckBoxEnabled(bool value);
	virtual STDMETHODIMP _add_DragItemsCompleted(Foundation::TypedEventHandler<ListViewBase*, DragItemsCompletedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DragItemsCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ChoosingItemContainer(Foundation::TypedEventHandler<ListViewBase*, ChoosingItemContainerEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ChoosingItemContainer(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ChoosingGroupHeaderContainer(Foundation::TypedEventHandler<ListViewBase*, ChoosingGroupHeaderContainerEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ChoosingGroupHeaderContainer(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _SelectRange(Data::ItemIndexRange* itemIndexRange);
	virtual STDMETHODIMP _DeselectRange(Data::ItemIndexRange* itemIndexRange);
};
template<typename X> struct IListViewBase4_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IListViewBase4_adaptor::IsMultiSelectCheckBoxEnabled)->_get_IsMultiSelectCheckBoxEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IListViewBase4_adaptor::IsMultiSelectCheckBoxEnabled)->_put_IsMultiSelectCheckBoxEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsMultiSelectCheckBoxEnabled;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Data::ItemIndexRange>>> get() { Foundation::Collections::IVectorView<Data::ItemIndexRange*>* value; hrcheck(enc(&IListViewBase4_adaptor::SelectedRanges)->_get_SelectedRanges(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Data::ItemIndexRange>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Data::ItemIndexRange>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Data::ItemIndexRange>>> operator->() { return get(); }
		} SelectedRanges;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ListViewBase>, ptr<ChoosingGroupHeaderContainerEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IListViewBase4_adaptor::ChoosingGroupHeaderContainer)->_add_ChoosingGroupHeaderContainer(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IListViewBase4_adaptor::ChoosingGroupHeaderContainer)->_remove_ChoosingGroupHeaderContainer(token)); }
		} ChoosingGroupHeaderContainer;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ListViewBase>, ptr<ChoosingItemContainerEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IListViewBase4_adaptor::ChoosingItemContainer)->_add_ChoosingItemContainer(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IListViewBase4_adaptor::ChoosingItemContainer)->_remove_ChoosingItemContainer(token)); }
		} ChoosingItemContainer;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ListViewBase>, ptr<DragItemsCompletedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IListViewBase4_adaptor::DragItemsCompleted)->_add_DragItemsCompleted(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IListViewBase4_adaptor::DragItemsCompleted)->_remove_DragItemsCompleted(token)); }
		} DragItemsCompleted;
	};
	void SelectRange(pptr<Data::ItemIndexRange> itemIndexRange) { hrcheck(X::get()->_SelectRange(itemIndexRange)); }
	void DeselectRange(pptr<Data::ItemIndexRange> itemIndexRange) { hrcheck(X::get()->_DeselectRange(itemIndexRange)); }
	IListViewBase4_adaptor() {}
};
template<typename X> struct adapt<IListViewBase4, X> : Windows::UI::Xaml::Controls::IListViewBase4_adaptor<X> { typedef adapt IListViewBase4; };
struct IListViewBase4 : IListViewBase4_raw, generate<IListViewBase4> {};

// IListViewBaseStatics4
struct IListViewBaseStatics4 : IInspectable {
	virtual STDMETHODIMP _get_IsMultiSelectCheckBoxEnabledProperty(DependencyProperty* *value);
};

// IListViewBase5
struct IListViewBase5_raw : IInspectable {
	virtual STDMETHODIMP _get_SingleSelectionFollowsFocus(bool *value);
	virtual STDMETHODIMP _put_SingleSelectionFollowsFocus(bool value);
	virtual STDMETHODIMP _IsDragSource(bool *returnValue);
};
template<typename X> struct IListViewBase5_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IListViewBase5_adaptor::SingleSelectionFollowsFocus)->_get_SingleSelectionFollowsFocus(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IListViewBase5_adaptor::SingleSelectionFollowsFocus)->_put_SingleSelectionFollowsFocus(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} SingleSelectionFollowsFocus;
	};
	bool IsDragSource() { bool returnValue; hrcheck(X::get()->_IsDragSource(&returnValue)); return returnValue; }
	IListViewBase5_adaptor() {}
};
template<typename X> struct adapt<IListViewBase5, X> : Windows::UI::Xaml::Controls::IListViewBase5_adaptor<X> { typedef adapt IListViewBase5; };
struct IListViewBase5 : IListViewBase5_raw, generate<IListViewBase5> {};

// IListViewBaseStatics5
struct IListViewBaseStatics5 : IInspectable {
	virtual STDMETHODIMP _get_SingleSelectionFollowsFocusProperty(DependencyProperty* *value);
};

// IListViewBase6
struct IListViewBase6_raw : IInspectable {
	virtual STDMETHODIMP _TryStartConnectedAnimationAsync(Media::Animation::ConnectedAnimation* animation, IInspectable* item, HSTRING elementName, Foundation::IAsyncOperation<bool>* *returnValue);
	virtual STDMETHODIMP _PrepareConnectedAnimation(HSTRING key, IInspectable* item, HSTRING elementName, Media::Animation::ConnectedAnimation* *returnValue);
};
template<typename X> struct IListViewBase6_adaptor : X {
	ptr<Foundation::IAsyncOperation<bool>> TryStartConnectedAnimationAsync(pptr<Media::Animation::ConnectedAnimation> animation, object_ref item, hstring_ref elementName) { Foundation::IAsyncOperation<bool>* returnValue; hrcheck(X::get()->_TryStartConnectedAnimationAsync(animation, item, elementName, &returnValue)); return from_abi(returnValue); }
	ptr<Media::Animation::ConnectedAnimation> PrepareConnectedAnimation(hstring_ref key, object_ref item, hstring_ref elementName) { Media::Animation::ConnectedAnimation* returnValue; hrcheck(X::get()->_PrepareConnectedAnimation(key, item, elementName, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IListViewBase6, X> : Windows::UI::Xaml::Controls::IListViewBase6_adaptor<X> { typedef adapt IListViewBase6; };
struct IListViewBase6 : IListViewBase6_raw, generate<IListViewBase6> {};

// IVirtualizingStackPanel
struct IVirtualizingStackPanel_raw : IInspectable {
	virtual STDMETHODIMP _get_AreScrollSnapPointsRegular(bool *value);
	virtual STDMETHODIMP _put_AreScrollSnapPointsRegular(bool value);
	virtual STDMETHODIMP _get_Orientation(Controls::Orientation *value);
	virtual STDMETHODIMP _put_Orientation(Controls::Orientation value);
	virtual STDMETHODIMP _add_CleanUpVirtualizedItemEvent(CleanUpVirtualizedItemEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CleanUpVirtualizedItemEvent(Foundation::EventRegistrationToken token);
};
template<typename X> struct IVirtualizingStackPanel_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVirtualizingStackPanel_adaptor::AreScrollSnapPointsRegular)->_get_AreScrollSnapPointsRegular(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVirtualizingStackPanel_adaptor::AreScrollSnapPointsRegular)->_put_AreScrollSnapPointsRegular(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AreScrollSnapPointsRegular;
		struct : property {
			Controls::Orientation get() { Controls::Orientation value; hrcheck(enc(&IVirtualizingStackPanel_adaptor::Orientation)->_get_Orientation(&value)); return value; }
			Controls::Orientation operator()() { return get(); }
			operator Controls::Orientation () { return get(); }
			void put(Controls::Orientation value) { hrcheck(enc(&IVirtualizingStackPanel_adaptor::Orientation)->_put_Orientation(value)); }
			void operator=(Controls::Orientation value) { put(value); }
			void operator()(Controls::Orientation value) { put(value); }
		} Orientation;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<CleanUpVirtualizedItemEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IVirtualizingStackPanel_adaptor::CleanUpVirtualizedItemEvent)->_add_CleanUpVirtualizedItemEvent(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IVirtualizingStackPanel_adaptor::CleanUpVirtualizedItemEvent)->_remove_CleanUpVirtualizedItemEvent(token)); }
		} CleanUpVirtualizedItemEvent;
	};
	IVirtualizingStackPanel_adaptor() {}
};
template<typename X> struct adapt<IVirtualizingStackPanel, X> : Windows::UI::Xaml::Controls::IVirtualizingStackPanel_adaptor<X> { typedef adapt IVirtualizingStackPanel; };
struct IVirtualizingStackPanel : IVirtualizingStackPanel_raw, generate<IVirtualizingStackPanel> {};

// IVirtualizingStackPanelOverrides
struct IVirtualizingStackPanelOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnCleanUpVirtualizedItem(CleanUpVirtualizedItemEventArgs* e) = 0;
};
template<typename X> struct IVirtualizingStackPanelOverrides_adaptor : X {
	void OnCleanUpVirtualizedItem(pptr<CleanUpVirtualizedItemEventArgs> e) { hrcheck(X::get()->_OnCleanUpVirtualizedItem(e)); }
};
template<typename X> struct adapt<IVirtualizingStackPanelOverrides, X> : Windows::UI::Xaml::Controls::IVirtualizingStackPanelOverrides_adaptor<X> { typedef adapt IVirtualizingStackPanelOverrides; };
template<typename X> struct IVirtualizingStackPanelOverrides_unadaptor : X {
	STDMETHODIMP _OnCleanUpVirtualizedItem(CleanUpVirtualizedItemEventArgs* e) { return hrtry([&, this] { X::get()->OnCleanUpVirtualizedItem(e); }); }
};
template<typename X> struct unadapt<IVirtualizingStackPanelOverrides, X> : Windows::UI::Xaml::Controls::IVirtualizingStackPanelOverrides_unadaptor<X> {};
struct IVirtualizingStackPanelOverrides : IVirtualizingStackPanelOverrides_raw, generate<IVirtualizingStackPanelOverrides> {};

// IVirtualizingStackPanelStatics
struct IVirtualizingStackPanelStatics : IInspectable {
	virtual STDMETHODIMP _get_AreScrollSnapPointsRegularProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OrientationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VirtualizationModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetVirtualizationMode(DependencyObject* element, VirtualizationMode *value);
	virtual STDMETHODIMP _SetVirtualizationMode(DependencyObject* element, VirtualizationMode value);
	virtual STDMETHODIMP _get_IsVirtualizingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsVirtualizing(DependencyObject* o, bool *value);
};

// ICheckBox
struct ICheckBox : IInspectable, generate<ICheckBox> {};

// ICheckBoxFactory
struct ICheckBoxFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, CheckBox* *instance);
};

// IRadioButton
struct IRadioButton_raw : IInspectable {
	virtual STDMETHODIMP _get_GroupName(HSTRING *value);
	virtual STDMETHODIMP _put_GroupName(HSTRING value);
};
template<typename X> struct IRadioButton_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRadioButton_adaptor::GroupName)->_get_GroupName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IRadioButton_adaptor::GroupName)->_put_GroupName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} GroupName;
	};
	IRadioButton_adaptor() {}
};
template<typename X> struct adapt<IRadioButton, X> : Windows::UI::Xaml::Controls::IRadioButton_adaptor<X> { typedef adapt IRadioButton; };
struct IRadioButton : IRadioButton_raw, generate<IRadioButton> {};

// IRadioButtonStatics
struct IRadioButtonStatics : IInspectable {
	virtual STDMETHODIMP _get_GroupNameProperty(DependencyProperty* *value);
};

// IRadioButtonFactory
struct IRadioButtonFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, RadioButton* *instance);
};

// IDataTemplateSelectorOverrides2
struct IDataTemplateSelectorOverrides2_raw : IInspectable {
	virtual STDMETHODIMP _SelectTemplateForItemCore(IInspectable* item, DataTemplate* *returnValue) = 0;
};
template<typename X> struct IDataTemplateSelectorOverrides2_adaptor : X {
	ptr<DataTemplate> SelectTemplateCore(object_ref item) { DataTemplate* returnValue; hrcheck(X::get()->_SelectTemplateForItemCore(item, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IDataTemplateSelectorOverrides2, X> : Windows::UI::Xaml::Controls::IDataTemplateSelectorOverrides2_adaptor<X> { typedef adapt IDataTemplateSelectorOverrides2; };
template<typename X> struct IDataTemplateSelectorOverrides2_unadaptor : X {
	STDMETHODIMP _SelectTemplateForItemCore(IInspectable* item, DataTemplate* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->SelectTemplateCore(item)); }); }
};
template<typename X> struct unadapt<IDataTemplateSelectorOverrides2, X> : Windows::UI::Xaml::Controls::IDataTemplateSelectorOverrides2_unadaptor<X> {};
struct IDataTemplateSelectorOverrides2 : IDataTemplateSelectorOverrides2_raw, generate<IDataTemplateSelectorOverrides2> {};

// IDataTemplateSelector2
struct IDataTemplateSelector2_raw : IInspectable {
	virtual STDMETHODIMP _SelectTemplateForItem(IInspectable* item, DataTemplate* *returnValue);
};
template<typename X> struct IDataTemplateSelector2_adaptor : X {
	ptr<DataTemplate> SelectTemplate(object_ref item) { DataTemplate* returnValue; hrcheck(X::get()->_SelectTemplateForItem(item, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IDataTemplateSelector2, X> : Windows::UI::Xaml::Controls::IDataTemplateSelector2_adaptor<X> { typedef adapt IDataTemplateSelector2; };
struct IDataTemplateSelector2 : IDataTemplateSelector2_raw, generate<IDataTemplateSelector2> {};

// IDataTemplateSelectorFactory
struct IDataTemplateSelectorFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, DataTemplateSelector* *instance);
};

// IDataTemplateSelectorOverrides
struct IDataTemplateSelectorOverrides_raw : IInspectable {
	virtual STDMETHODIMP _SelectTemplateCore(IInspectable* item, DependencyObject* container, DataTemplate* *returnValue) = 0;
};
template<typename X> struct IDataTemplateSelectorOverrides_adaptor : X {
	ptr<DataTemplate> SelectTemplateCore(object_ref item, pptr<DependencyObject> container) { DataTemplate* returnValue; hrcheck(X::get()->_SelectTemplateCore(item, container, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IDataTemplateSelectorOverrides, X> : Windows::UI::Xaml::Controls::IDataTemplateSelectorOverrides_adaptor<X> { typedef adapt IDataTemplateSelectorOverrides; };
template<typename X> struct IDataTemplateSelectorOverrides_unadaptor : X {
	STDMETHODIMP _SelectTemplateCore(IInspectable* item, DependencyObject* container, DataTemplate* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->SelectTemplateCore(item, container)); }); }
};
template<typename X> struct unadapt<IDataTemplateSelectorOverrides, X> : Windows::UI::Xaml::Controls::IDataTemplateSelectorOverrides_unadaptor<X> {};
struct IDataTemplateSelectorOverrides : IDataTemplateSelectorOverrides_raw, generate<IDataTemplateSelectorOverrides> {};

// IDataTemplateSelector
struct IDataTemplateSelector_raw : IInspectable {
	virtual STDMETHODIMP _SelectTemplate(IInspectable* item, DependencyObject* container, DataTemplate* *returnValue);
};
template<typename X> struct IDataTemplateSelector_adaptor : X {
	ptr<DataTemplate> SelectTemplate(object_ref item, pptr<DependencyObject> container) { DataTemplate* returnValue; hrcheck(X::get()->_SelectTemplate(item, container, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IDataTemplateSelector, X> : Windows::UI::Xaml::Controls::IDataTemplateSelector_adaptor<X> { typedef adapt IDataTemplateSelector; };
struct IDataTemplateSelector : IDataTemplateSelector_raw, generate<IDataTemplateSelector> {};

// DataTemplateSelector
template<typename> struct DataTemplateSelector_statics {
	static DataTemplateSelector *activate(object_ref outer, IInspectable* *inner) { DataTemplateSelector *instance; hrcheck(get_activation_factory<DataTemplateSelector, IDataTemplateSelectorFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<DataTemplateSelector, X> : X, Windows::UI::Xaml::Controls::DataTemplateSelector_statics<void> {
	using Windows::UI::Xaml::Controls::DataTemplateSelector_statics<void>::activate;
	typedef typename X::root_type DataTemplateSelector;
};
struct DataTemplateSelector : generate<DataTemplateSelector> {
	using IDataTemplateSelectorOverrides::SelectTemplateCore;
	using IDataTemplateSelectorOverrides2::SelectTemplateCore;
	using IDataTemplateSelector2::SelectTemplate;
	using IDataTemplateSelector::SelectTemplate;
};

// IContainerContentChangingEventArgs
struct IContainerContentChangingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ItemContainer(Primitives::SelectorItem* *value);
	virtual STDMETHODIMP _get_InRecycleQueue(bool *value);
	virtual STDMETHODIMP _get_ItemIndex(int *value);
	virtual STDMETHODIMP _get_Item(IInspectable* *value);
	virtual STDMETHODIMP _get_Phase(unsigned *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _RegisterUpdateCallback(Foundation::TypedEventHandler<ListViewBase*, ContainerContentChangingEventArgs*>* callback);
	virtual STDMETHODIMP _RegisterUpdateCallbackWithPhase(unsigned callbackPhase, Foundation::TypedEventHandler<ListViewBase*, ContainerContentChangingEventArgs*>* callback);
};
template<typename X> struct IContainerContentChangingEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IContainerContentChangingEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IContainerContentChangingEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IContainerContentChangingEventArgs_adaptor::InRecycleQueue)->_get_InRecycleQueue(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} InRecycleQueue;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IContainerContentChangingEventArgs_adaptor::Item)->_get_Item(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} Item;
		struct : property {
			ptr<Primitives::SelectorItem> get() { Primitives::SelectorItem* value; hrcheck(enc(&IContainerContentChangingEventArgs_adaptor::ItemContainer)->_get_ItemContainer(&value)); return from_abi(value); }
			ptr<Primitives::SelectorItem> operator()() { return get(); }
			operator ptr<Primitives::SelectorItem> () { return get(); }
			ptr<Primitives::SelectorItem> operator->() { return get(); }
		} ItemContainer;
		struct : property {
			int get() { int value; hrcheck(enc(&IContainerContentChangingEventArgs_adaptor::ItemIndex)->_get_ItemIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} ItemIndex;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IContainerContentChangingEventArgs_adaptor::Phase)->_get_Phase(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Phase;
	};
	void RegisterUpdateCallback(handler_ref<Foundation::TypedEventHandler<ptr<ListViewBase>, ptr<ContainerContentChangingEventArgs>>> callback) { hrcheck(X::get()->_RegisterUpdateCallback(to_abi(callback))); }
	void RegisterUpdateCallback(unsigned callbackPhase, handler_ref<Foundation::TypedEventHandler<ptr<ListViewBase>, ptr<ContainerContentChangingEventArgs>>> callback) { hrcheck(X::get()->_RegisterUpdateCallbackWithPhase(callbackPhase, to_abi(callback))); }
	IContainerContentChangingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IContainerContentChangingEventArgs, X> : Windows::UI::Xaml::Controls::IContainerContentChangingEventArgs_adaptor<X> { typedef adapt IContainerContentChangingEventArgs; };
struct IContainerContentChangingEventArgs : IContainerContentChangingEventArgs_raw, generate<IContainerContentChangingEventArgs> {};

// ColumnDefinition
template<typename> struct ColumnDefinition_statics {
	static struct _MaxWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColumnDefinition, IColumnDefinitionStatics>()->_get_MaxWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxWidthProperty;
	static struct _MinWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColumnDefinition, IColumnDefinitionStatics>()->_get_MinWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinWidthProperty;
	static struct _WidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColumnDefinition, IColumnDefinitionStatics>()->_get_WidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} WidthProperty;
};
template<typename X> typename ColumnDefinition_statics<X>::_MaxWidthProperty ColumnDefinition_statics<X>::MaxWidthProperty;
template<typename X> typename ColumnDefinition_statics<X>::_MinWidthProperty ColumnDefinition_statics<X>::MinWidthProperty;
template<typename X> typename ColumnDefinition_statics<X>::_WidthProperty ColumnDefinition_statics<X>::WidthProperty;

template<typename X> struct statics<ColumnDefinition, X> : X, Windows::UI::Xaml::Controls::ColumnDefinition_statics<void> {
	typedef typename X::root_type ColumnDefinition;
};
struct ColumnDefinition : generate<ColumnDefinition> {};

// ColumnDefinitionCollection
template<typename X> struct statics<ColumnDefinitionCollection, X> : X {
	typedef typename X::root_type ColumnDefinitionCollection;
};
struct ColumnDefinitionCollection : generate<ColumnDefinitionCollection> {};

// IChoosingItemContainerEventArgs
struct IChoosingItemContainerEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ItemIndex(int *value);
	virtual STDMETHODIMP _get_Item(IInspectable* *value);
	virtual STDMETHODIMP _get_ItemContainer(Primitives::SelectorItem* *value);
	virtual STDMETHODIMP _put_ItemContainer(Primitives::SelectorItem* value);
	virtual STDMETHODIMP _get_IsContainerPrepared(bool *value);
	virtual STDMETHODIMP _put_IsContainerPrepared(bool value);
};
template<typename X> struct IChoosingItemContainerEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IChoosingItemContainerEventArgs_adaptor::IsContainerPrepared)->_get_IsContainerPrepared(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IChoosingItemContainerEventArgs_adaptor::IsContainerPrepared)->_put_IsContainerPrepared(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsContainerPrepared;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IChoosingItemContainerEventArgs_adaptor::Item)->_get_Item(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} Item;
		struct : property {
			ptr<Primitives::SelectorItem> get() { Primitives::SelectorItem* value; hrcheck(enc(&IChoosingItemContainerEventArgs_adaptor::ItemContainer)->_get_ItemContainer(&value)); return from_abi(value); }
			ptr<Primitives::SelectorItem> operator()() { return get(); }
			operator ptr<Primitives::SelectorItem> () { return get(); }
			ptr<Primitives::SelectorItem> operator->() { return get(); }
			void put(pptr<Primitives::SelectorItem> value) { hrcheck(enc(&IChoosingItemContainerEventArgs_adaptor::ItemContainer)->_put_ItemContainer(value)); }
			void operator=(pptr<Primitives::SelectorItem> value) { put(value); }
			void operator()(pptr<Primitives::SelectorItem> value) { put(value); }
		} ItemContainer;
		struct : property {
			int get() { int value; hrcheck(enc(&IChoosingItemContainerEventArgs_adaptor::ItemIndex)->_get_ItemIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} ItemIndex;
	};
	IChoosingItemContainerEventArgs_adaptor() {}
};
template<typename X> struct adapt<IChoosingItemContainerEventArgs, X> : Windows::UI::Xaml::Controls::IChoosingItemContainerEventArgs_adaptor<X> { typedef adapt IChoosingItemContainerEventArgs; };
struct IChoosingItemContainerEventArgs : IChoosingItemContainerEventArgs_raw, generate<IChoosingItemContainerEventArgs> {};

// ChoosingItemContainerEventArgs
template<typename X> struct statics<ChoosingItemContainerEventArgs, X> : X {
	typedef typename X::root_type ChoosingItemContainerEventArgs;
};
struct ChoosingItemContainerEventArgs : generate<ChoosingItemContainerEventArgs> {};

// IChoosingGroupHeaderContainerEventArgs
struct IChoosingGroupHeaderContainerEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_GroupHeaderContainer(ListViewBaseHeaderItem* *value);
	virtual STDMETHODIMP _put_GroupHeaderContainer(ListViewBaseHeaderItem* value);
	virtual STDMETHODIMP _get_GroupIndex(int *value);
	virtual STDMETHODIMP _get_Group(IInspectable* *value);
};
template<typename X> struct IChoosingGroupHeaderContainerEventArgs_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IChoosingGroupHeaderContainerEventArgs_adaptor::Group)->_get_Group(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} Group;
		struct : property {
			ptr<ListViewBaseHeaderItem> get() { ListViewBaseHeaderItem* value; hrcheck(enc(&IChoosingGroupHeaderContainerEventArgs_adaptor::GroupHeaderContainer)->_get_GroupHeaderContainer(&value)); return from_abi(value); }
			ptr<ListViewBaseHeaderItem> operator()() { return get(); }
			operator ptr<ListViewBaseHeaderItem> () { return get(); }
			ptr<ListViewBaseHeaderItem> operator->() { return get(); }
			void put(pptr<ListViewBaseHeaderItem> value) { hrcheck(enc(&IChoosingGroupHeaderContainerEventArgs_adaptor::GroupHeaderContainer)->_put_GroupHeaderContainer(value)); }
			void operator=(pptr<ListViewBaseHeaderItem> value) { put(value); }
			void operator()(pptr<ListViewBaseHeaderItem> value) { put(value); }
		} GroupHeaderContainer;
		struct : property {
			int get() { int value; hrcheck(enc(&IChoosingGroupHeaderContainerEventArgs_adaptor::GroupIndex)->_get_GroupIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} GroupIndex;
	};
	IChoosingGroupHeaderContainerEventArgs_adaptor() {}
};
template<typename X> struct adapt<IChoosingGroupHeaderContainerEventArgs, X> : Windows::UI::Xaml::Controls::IChoosingGroupHeaderContainerEventArgs_adaptor<X> { typedef adapt IChoosingGroupHeaderContainerEventArgs; };
struct IChoosingGroupHeaderContainerEventArgs : IChoosingGroupHeaderContainerEventArgs_raw, generate<IChoosingGroupHeaderContainerEventArgs> {};

// ChoosingGroupHeaderContainerEventArgs
template<typename X> struct statics<ChoosingGroupHeaderContainerEventArgs, X> : X {
	typedef typename X::root_type ChoosingGroupHeaderContainerEventArgs;
};
struct ChoosingGroupHeaderContainerEventArgs : generate<ChoosingGroupHeaderContainerEventArgs> {};

// ICandidateWindowBoundsChangedEventArgs
struct ICandidateWindowBoundsChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Bounds(Foundation::Rect *value);
};
template<typename X> struct ICandidateWindowBoundsChangedEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&ICandidateWindowBoundsChangedEventArgs_adaptor::Bounds)->_get_Bounds(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
		} Bounds;
	};
	ICandidateWindowBoundsChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ICandidateWindowBoundsChangedEventArgs, X> : Windows::UI::Xaml::Controls::ICandidateWindowBoundsChangedEventArgs_adaptor<X> { typedef adapt ICandidateWindowBoundsChangedEventArgs; };
struct ICandidateWindowBoundsChangedEventArgs : ICandidateWindowBoundsChangedEventArgs_raw, generate<ICandidateWindowBoundsChangedEventArgs> {};

// CandidateWindowBoundsChangedEventArgs
template<typename X> struct statics<CandidateWindowBoundsChangedEventArgs, X> : X {
	typedef typename X::root_type CandidateWindowBoundsChangedEventArgs;
};
struct CandidateWindowBoundsChangedEventArgs : generate<CandidateWindowBoundsChangedEventArgs> {};

// IBackClickEventArgs
struct IBackClickEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
};
template<typename X> struct IBackClickEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBackClickEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IBackClickEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
	};
	IBackClickEventArgs_adaptor() {}
};
template<typename X> struct adapt<IBackClickEventArgs, X> : Windows::UI::Xaml::Controls::IBackClickEventArgs_adaptor<X> { typedef adapt IBackClickEventArgs; };
struct IBackClickEventArgs : IBackClickEventArgs_raw, generate<IBackClickEventArgs> {};

// SemanticZoomLocation
template<typename X> struct statics<SemanticZoomLocation, X> : X {
	typedef typename X::root_type SemanticZoomLocation;
};
struct SemanticZoomLocation : generate<SemanticZoomLocation> {};

// ISemanticZoomInformation
struct ISemanticZoomInformation_raw : IInspectable {
	virtual STDMETHODIMP _get_SemanticZoomOwner(SemanticZoom* *value) = 0;
	virtual STDMETHODIMP _put_SemanticZoomOwner(SemanticZoom* value) = 0;
	virtual STDMETHODIMP _get_IsActiveView(bool *value) = 0;
	virtual STDMETHODIMP _put_IsActiveView(bool value) = 0;
	virtual STDMETHODIMP _get_IsZoomedInView(bool *value) = 0;
	virtual STDMETHODIMP _put_IsZoomedInView(bool value) = 0;
	virtual STDMETHODIMP _InitializeViewChange() = 0;
	virtual STDMETHODIMP _CompleteViewChange() = 0;
	virtual STDMETHODIMP _MakeVisible(SemanticZoomLocation* item) = 0;
	virtual STDMETHODIMP _StartViewChangeFrom(SemanticZoomLocation* source, SemanticZoomLocation* destination) = 0;
	virtual STDMETHODIMP _StartViewChangeTo(SemanticZoomLocation* source, SemanticZoomLocation* destination) = 0;
	virtual STDMETHODIMP _CompleteViewChangeFrom(SemanticZoomLocation* source, SemanticZoomLocation* destination) = 0;
	virtual STDMETHODIMP _CompleteViewChangeTo(SemanticZoomLocation* source, SemanticZoomLocation* destination) = 0;
};
template<typename X> struct ISemanticZoomInformation_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISemanticZoomInformation_adaptor::IsActiveView)->_get_IsActiveView(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISemanticZoomInformation_adaptor::IsActiveView)->_put_IsActiveView(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsActiveView;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISemanticZoomInformation_adaptor::IsZoomedInView)->_get_IsZoomedInView(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISemanticZoomInformation_adaptor::IsZoomedInView)->_put_IsZoomedInView(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsZoomedInView;
		struct : property {
			ptr<SemanticZoom> get() { SemanticZoom* value; hrcheck(enc(&ISemanticZoomInformation_adaptor::SemanticZoomOwner)->_get_SemanticZoomOwner(&value)); return from_abi(value); }
			ptr<SemanticZoom> operator()() { return get(); }
			operator ptr<SemanticZoom> () { return get(); }
			ptr<SemanticZoom> operator->() { return get(); }
			void put(pptr<SemanticZoom> value) { hrcheck(enc(&ISemanticZoomInformation_adaptor::SemanticZoomOwner)->_put_SemanticZoomOwner(value)); }
			void operator=(pptr<SemanticZoom> value) { put(value); }
			void operator()(pptr<SemanticZoom> value) { put(value); }
		} SemanticZoomOwner;
	};
	void InitializeViewChange() { hrcheck(X::get()->_InitializeViewChange()); }
	void CompleteViewChange() { hrcheck(X::get()->_CompleteViewChange()); }
	void MakeVisible(pptr<SemanticZoomLocation> item) { hrcheck(X::get()->_MakeVisible(item)); }
	void StartViewChangeFrom(pptr<SemanticZoomLocation> source, pptr<SemanticZoomLocation> destination) { hrcheck(X::get()->_StartViewChangeFrom(source, destination)); }
	void StartViewChangeTo(pptr<SemanticZoomLocation> source, pptr<SemanticZoomLocation> destination) { hrcheck(X::get()->_StartViewChangeTo(source, destination)); }
	void CompleteViewChangeFrom(pptr<SemanticZoomLocation> source, pptr<SemanticZoomLocation> destination) { hrcheck(X::get()->_CompleteViewChangeFrom(source, destination)); }
	void CompleteViewChangeTo(pptr<SemanticZoomLocation> source, pptr<SemanticZoomLocation> destination) { hrcheck(X::get()->_CompleteViewChangeTo(source, destination)); }
	ISemanticZoomInformation_adaptor() {}
};
template<typename X> struct adapt<ISemanticZoomInformation, X> : Windows::UI::Xaml::Controls::ISemanticZoomInformation_adaptor<X> { typedef adapt ISemanticZoomInformation; };
template<typename X> struct ISemanticZoomInformation_unadaptor : X {
	STDMETHODIMP _get_SemanticZoomOwner(SemanticZoom* *value) { return hrtry([&, this] { get_prop(value, SemanticZoomOwner); }); }
	STDMETHODIMP _put_SemanticZoomOwner(SemanticZoom* value) { return hrtry([&, this] { put_prop(value, SemanticZoomOwner); }); }
	STDMETHODIMP _get_IsActiveView(bool *value) { return hrtry([&, this] { get_prop(value, IsActiveView); }); }
	STDMETHODIMP _put_IsActiveView(bool value) { return hrtry([&, this] { put_prop(value, IsActiveView); }); }
	STDMETHODIMP _get_IsZoomedInView(bool *value) { return hrtry([&, this] { get_prop(value, IsZoomedInView); }); }
	STDMETHODIMP _put_IsZoomedInView(bool value) { return hrtry([&, this] { put_prop(value, IsZoomedInView); }); }
	STDMETHODIMP _InitializeViewChange() { return hrtry([&, this] { X::get()->InitializeViewChange(); }); }
	STDMETHODIMP _CompleteViewChange() { return hrtry([&, this] { X::get()->CompleteViewChange(); }); }
	STDMETHODIMP _MakeVisible(SemanticZoomLocation* item) { return hrtry([&, this] { X::get()->MakeVisible(item); }); }
	STDMETHODIMP _StartViewChangeFrom(SemanticZoomLocation* source, SemanticZoomLocation* destination) { return hrtry([&, this] { X::get()->StartViewChangeFrom(source, destination); }); }
	STDMETHODIMP _StartViewChangeTo(SemanticZoomLocation* source, SemanticZoomLocation* destination) { return hrtry([&, this] { X::get()->StartViewChangeTo(source, destination); }); }
	STDMETHODIMP _CompleteViewChangeFrom(SemanticZoomLocation* source, SemanticZoomLocation* destination) { return hrtry([&, this] { X::get()->CompleteViewChangeFrom(source, destination); }); }
	STDMETHODIMP _CompleteViewChangeTo(SemanticZoomLocation* source, SemanticZoomLocation* destination) { return hrtry([&, this] { X::get()->CompleteViewChangeTo(source, destination); }); }
};
template<typename X> struct unadapt<ISemanticZoomInformation, X> : Windows::UI::Xaml::Controls::ISemanticZoomInformation_unadaptor<X> {};
struct ISemanticZoomInformation : ISemanticZoomInformation_raw, generate<ISemanticZoomInformation> {};

// INavigate
struct INavigate_raw : IInspectable {
	virtual STDMETHODIMP _Navigate(Interop::TypeName sourcePageType, bool *returnValue) = 0;
};
template<typename X> struct INavigate_adaptor : X {
	bool Navigate(const Interop::TypeName& sourcePageType) { bool returnValue; hrcheck(X::get()->_Navigate(sourcePageType, &returnValue)); return returnValue; }
};
template<typename X> struct adapt<INavigate, X> : Windows::UI::Xaml::Controls::INavigate_adaptor<X> { typedef adapt INavigate; };
template<typename X> struct INavigate_unadaptor : X {
	STDMETHODIMP _Navigate(Interop::TypeName sourcePageType, bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->Navigate(sourcePageType); }); }
};
template<typename X> struct unadapt<INavigate, X> : Windows::UI::Xaml::Controls::INavigate_unadaptor<X> {};
struct INavigate : INavigate_raw, generate<INavigate> {};

// ContainerContentChangingEventArgs
template<typename X> struct statics<ContainerContentChangingEventArgs, X> : X {
	typedef typename X::root_type ContainerContentChangingEventArgs;
};
struct ContainerContentChangingEventArgs : generate<ContainerContentChangingEventArgs> {
	using IContainerContentChangingEventArgs::RegisterUpdateCallback;
};

// TextControlPasteEventArgs
template<typename X> struct statics<TextControlPasteEventArgs, X> : X {
	typedef typename X::root_type TextControlPasteEventArgs;
};
struct TextControlPasteEventArgs : generate<TextControlPasteEventArgs> {};

// TextControlPasteEventHandler
struct TextControlPasteEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, TextControlPasteEventArgs* e) = 0;
};

// TextChangedEventHandler
struct TextChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, TextChangedEventArgs* e) = 0;
};

// SemanticZoomViewChangedEventArgs
template<typename X> struct statics<SemanticZoomViewChangedEventArgs, X> : X {
	typedef typename X::root_type SemanticZoomViewChangedEventArgs;
};
struct SemanticZoomViewChangedEventArgs : generate<SemanticZoomViewChangedEventArgs> {};

// SemanticZoomViewChangedEventHandler
struct SemanticZoomViewChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, SemanticZoomViewChangedEventArgs* e) = 0;
};

// SelectionChangedEventHandler
struct SelectionChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, SelectionChangedEventArgs* e) = 0;
};

// NotifyEventArgs
template<typename X> struct statics<NotifyEventArgs, X> : X {
	typedef typename X::root_type NotifyEventArgs;
};
struct NotifyEventArgs : generate<NotifyEventArgs> {};

// NotifyEventHandler
struct NotifyEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, NotifyEventArgs* e) = 0;
};

// ItemClickEventHandler
struct ItemClickEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, ItemClickEventArgs* e) = 0;
};

// DragItemsStartingEventArgs
template<typename X> struct statics<DragItemsStartingEventArgs, X> : X {
	typedef typename X::root_type DragItemsStartingEventArgs;
};
struct DragItemsStartingEventArgs : generate<DragItemsStartingEventArgs> {};

// DragItemsStartingEventHandler
struct DragItemsStartingEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, DragItemsStartingEventArgs* e) = 0;
};

// ContextMenuOpeningEventHandler
struct ContextMenuOpeningEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, ContextMenuEventArgs* e) = 0;
};

// CleanUpVirtualizedItemEventHandler
struct CleanUpVirtualizedItemEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, CleanUpVirtualizedItemEventArgs* e) = 0;
};

// BackClickEventArgs
template<typename X> struct statics<BackClickEventArgs, X> : X {
	typedef typename X::root_type BackClickEventArgs;
};
struct BackClickEventArgs : generate<BackClickEventArgs> {};

// BackClickEventHandler
struct BackClickEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, BackClickEventArgs* e) = 0;
};

// CalendarViewDayItemChangingEventHandler
struct CalendarViewDayItemChangingEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(CalendarView* sender, CalendarViewDayItemChangingEventArgs* e) = 0;
};

// ICalendarViewDayItemChangingEventArgs
struct ICalendarViewDayItemChangingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_InRecycleQueue(bool *value);
	virtual STDMETHODIMP _get_Item(CalendarViewDayItem* *value);
	virtual STDMETHODIMP _get_Phase(unsigned *value);
	virtual STDMETHODIMP _RegisterUpdateCallback(Foundation::TypedEventHandler<CalendarView*, CalendarViewDayItemChangingEventArgs*>* callback);
	virtual STDMETHODIMP _RegisterUpdateCallbackWithPhase(unsigned callbackPhase, Foundation::TypedEventHandler<CalendarView*, CalendarViewDayItemChangingEventArgs*>* callback);
};
template<typename X> struct ICalendarViewDayItemChangingEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICalendarViewDayItemChangingEventArgs_adaptor::InRecycleQueue)->_get_InRecycleQueue(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} InRecycleQueue;
		struct : property {
			ptr<CalendarViewDayItem> get() { CalendarViewDayItem* value; hrcheck(enc(&ICalendarViewDayItemChangingEventArgs_adaptor::Item)->_get_Item(&value)); return from_abi(value); }
			ptr<CalendarViewDayItem> operator()() { return get(); }
			operator ptr<CalendarViewDayItem> () { return get(); }
			ptr<CalendarViewDayItem> operator->() { return get(); }
		} Item;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&ICalendarViewDayItemChangingEventArgs_adaptor::Phase)->_get_Phase(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Phase;
	};
	void RegisterUpdateCallback(handler_ref<Foundation::TypedEventHandler<ptr<CalendarView>, ptr<CalendarViewDayItemChangingEventArgs>>> callback) { hrcheck(X::get()->_RegisterUpdateCallback(to_abi(callback))); }
	void RegisterUpdateCallback(unsigned callbackPhase, handler_ref<Foundation::TypedEventHandler<ptr<CalendarView>, ptr<CalendarViewDayItemChangingEventArgs>>> callback) { hrcheck(X::get()->_RegisterUpdateCallbackWithPhase(callbackPhase, to_abi(callback))); }
	ICalendarViewDayItemChangingEventArgs_adaptor() {}
};
template<typename X> struct adapt<ICalendarViewDayItemChangingEventArgs, X> : Windows::UI::Xaml::Controls::ICalendarViewDayItemChangingEventArgs_adaptor<X> { typedef adapt ICalendarViewDayItemChangingEventArgs; };
struct ICalendarViewDayItemChangingEventArgs : ICalendarViewDayItemChangingEventArgs_raw, generate<ICalendarViewDayItemChangingEventArgs> {};

// CalendarViewDayItemChangingEventArgs
template<typename X> struct statics<CalendarViewDayItemChangingEventArgs, X> : X {
	typedef typename X::root_type CalendarViewDayItemChangingEventArgs;
};
struct CalendarViewDayItemChangingEventArgs : generate<CalendarViewDayItemChangingEventArgs> {
	using ICalendarViewDayItemChangingEventArgs::RegisterUpdateCallback;
};

// HubSectionHeaderClickEventHandler
struct HubSectionHeaderClickEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, HubSectionHeaderClickEventArgs* e) = 0;
};

// IHubSectionHeaderClickEventArgs
struct IHubSectionHeaderClickEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Section(HubSection* *value);
};
template<typename X> struct IHubSectionHeaderClickEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<HubSection> get() { HubSection* value; hrcheck(enc(&IHubSectionHeaderClickEventArgs_adaptor::Section)->_get_Section(&value)); return from_abi(value); }
			ptr<HubSection> operator()() { return get(); }
			operator ptr<HubSection> () { return get(); }
			ptr<HubSection> operator->() { return get(); }
		} Section;
	};
	IHubSectionHeaderClickEventArgs_adaptor() {}
};
template<typename X> struct adapt<IHubSectionHeaderClickEventArgs, X> : Windows::UI::Xaml::Controls::IHubSectionHeaderClickEventArgs_adaptor<X> { typedef adapt IHubSectionHeaderClickEventArgs; };
struct IHubSectionHeaderClickEventArgs : IHubSectionHeaderClickEventArgs_raw, generate<IHubSectionHeaderClickEventArgs> {};

// HubSectionHeaderClickEventArgs
template<typename X> struct statics<HubSectionHeaderClickEventArgs, X> : X {
	typedef typename X::root_type HubSectionHeaderClickEventArgs;
};
struct HubSectionHeaderClickEventArgs : generate<HubSectionHeaderClickEventArgs> {};

// ListViewItemToKeyHandler
struct ListViewItemToKeyHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* item, HSTRING *returnValue) = 0;
};

// ListViewKeyToItemHandler
struct ListViewKeyToItemHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(HSTRING key, Foundation::IAsyncOperation<IInspectable*>* *returnValue) = 0;
};

// SectionsInViewChangedEventHandler
struct SectionsInViewChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, SectionsInViewChangedEventArgs* e) = 0;
};

// ISectionsInViewChangedEventArgsFactory
struct ISectionsInViewChangedEventArgsFactory : IInspectable, generate<ISectionsInViewChangedEventArgsFactory> {};

// ISectionsInViewChangedEventArgs
struct ISectionsInViewChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_AddedSections(Foundation::Collections::IVector<HubSection*>* *value);
	virtual STDMETHODIMP _get_RemovedSections(Foundation::Collections::IVector<HubSection*>* *value);
};
template<typename X> struct ISectionsInViewChangedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<HubSection>>> get() { Foundation::Collections::IVector<HubSection*>* value; hrcheck(enc(&ISectionsInViewChangedEventArgs_adaptor::AddedSections)->_get_AddedSections(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<HubSection>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<HubSection>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<HubSection>>> operator->() { return get(); }
		} AddedSections;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<HubSection>>> get() { Foundation::Collections::IVector<HubSection*>* value; hrcheck(enc(&ISectionsInViewChangedEventArgs_adaptor::RemovedSections)->_get_RemovedSections(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<HubSection>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<HubSection>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<HubSection>>> operator->() { return get(); }
		} RemovedSections;
	};
	ISectionsInViewChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISectionsInViewChangedEventArgs, X> : Windows::UI::Xaml::Controls::ISectionsInViewChangedEventArgs_adaptor<X> { typedef adapt ISectionsInViewChangedEventArgs; };
struct ISectionsInViewChangedEventArgs : ISectionsInViewChangedEventArgs_raw, generate<ISectionsInViewChangedEventArgs> {};

// SectionsInViewChangedEventArgs
template<typename X> struct statics<SectionsInViewChangedEventArgs, X> : X {
	typedef typename X::root_type SectionsInViewChangedEventArgs;
};
struct SectionsInViewChangedEventArgs : generate<SectionsInViewChangedEventArgs> {};

// WebViewNavigationFailedEventHandler
struct WebViewNavigationFailedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, WebViewNavigationFailedEventArgs* e) = 0;
};

// IWebViewNavigationFailedEventArgs
struct IWebViewNavigationFailedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_WebErrorStatus(Web::WebErrorStatus *value);
};
template<typename X> struct IWebViewNavigationFailedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IWebViewNavigationFailedEventArgs_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
		struct : property {
			Web::WebErrorStatus get() { Web::WebErrorStatus value; hrcheck(enc(&IWebViewNavigationFailedEventArgs_adaptor::WebErrorStatus)->_get_WebErrorStatus(&value)); return value; }
			Web::WebErrorStatus operator()() { return get(); }
			operator Web::WebErrorStatus () { return get(); }
		} WebErrorStatus;
	};
	IWebViewNavigationFailedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IWebViewNavigationFailedEventArgs, X> : Windows::UI::Xaml::Controls::IWebViewNavigationFailedEventArgs_adaptor<X> { typedef adapt IWebViewNavigationFailedEventArgs; };
struct IWebViewNavigationFailedEventArgs : IWebViewNavigationFailedEventArgs_raw, generate<IWebViewNavigationFailedEventArgs> {};

// WebViewNavigationFailedEventArgs
template<typename X> struct statics<WebViewNavigationFailedEventArgs, X> : X {
	typedef typename X::root_type WebViewNavigationFailedEventArgs;
};
struct WebViewNavigationFailedEventArgs : generate<WebViewNavigationFailedEventArgs> {};

// ICommandBarElement
struct ICommandBarElement_raw : IInspectable {
	virtual STDMETHODIMP _get_IsCompact(bool *value) = 0;
	virtual STDMETHODIMP _put_IsCompact(bool value) = 0;
};
template<typename X> struct ICommandBarElement_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICommandBarElement_adaptor::IsCompact)->_get_IsCompact(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICommandBarElement_adaptor::IsCompact)->_put_IsCompact(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsCompact;
	};
	ICommandBarElement_adaptor() {}
};
template<typename X> struct adapt<ICommandBarElement, X> : Windows::UI::Xaml::Controls::ICommandBarElement_adaptor<X> { typedef adapt ICommandBarElement; };
template<typename X> struct ICommandBarElement_unadaptor : X {
	STDMETHODIMP _get_IsCompact(bool *value) { return hrtry([&, this] { get_prop(value, IsCompact); }); }
	STDMETHODIMP _put_IsCompact(bool value) { return hrtry([&, this] { put_prop(value, IsCompact); }); }
};
template<typename X> struct unadapt<ICommandBarElement, X> : Windows::UI::Xaml::Controls::ICommandBarElement_unadaptor<X> {};
struct ICommandBarElement : ICommandBarElement_raw, generate<ICommandBarElement> {};

// ICommandBarElement2
struct ICommandBarElement2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsInOverflow(bool *value) = 0;
	virtual STDMETHODIMP _get_DynamicOverflowOrder(int *value) = 0;
	virtual STDMETHODIMP _put_DynamicOverflowOrder(int value) = 0;
};
template<typename X> struct ICommandBarElement2_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&ICommandBarElement2_adaptor::DynamicOverflowOrder)->_get_DynamicOverflowOrder(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ICommandBarElement2_adaptor::DynamicOverflowOrder)->_put_DynamicOverflowOrder(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} DynamicOverflowOrder;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICommandBarElement2_adaptor::IsInOverflow)->_get_IsInOverflow(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsInOverflow;
	};
	ICommandBarElement2_adaptor() {}
};
template<typename X> struct adapt<ICommandBarElement2, X> : Windows::UI::Xaml::Controls::ICommandBarElement2_adaptor<X> { typedef adapt ICommandBarElement2; };
template<typename X> struct ICommandBarElement2_unadaptor : X {
	STDMETHODIMP _get_IsInOverflow(bool *value) { return hrtry([&, this] { get_prop(value, IsInOverflow); }); }
	STDMETHODIMP _get_DynamicOverflowOrder(int *value) { return hrtry([&, this] { get_prop(value, DynamicOverflowOrder); }); }
	STDMETHODIMP _put_DynamicOverflowOrder(int value) { return hrtry([&, this] { put_prop(value, DynamicOverflowOrder); }); }
};
template<typename X> struct unadapt<ICommandBarElement2, X> : Windows::UI::Xaml::Controls::ICommandBarElement2_unadaptor<X> {};
struct ICommandBarElement2 : ICommandBarElement2_raw, generate<ICommandBarElement2> {};

// ICalendarDatePickerDateChangedEventArgs
struct ICalendarDatePickerDateChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_NewDate(Foundation::IReference<Foundation::DateTime>* *value);
	virtual STDMETHODIMP _get_OldDate(Foundation::IReference<Foundation::DateTime>* *value);
};
template<typename X> struct ICalendarDatePickerDateChangedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Foundation::DateTime>> get() { Foundation::IReference<Foundation::DateTime>* value; hrcheck(enc(&ICalendarDatePickerDateChangedEventArgs_adaptor::NewDate)->_get_NewDate(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator->() { return get(); }
		} NewDate;
		struct : property {
			ptr<Foundation::IReference<Foundation::DateTime>> get() { Foundation::IReference<Foundation::DateTime>* value; hrcheck(enc(&ICalendarDatePickerDateChangedEventArgs_adaptor::OldDate)->_get_OldDate(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator->() { return get(); }
		} OldDate;
	};
	ICalendarDatePickerDateChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ICalendarDatePickerDateChangedEventArgs, X> : Windows::UI::Xaml::Controls::ICalendarDatePickerDateChangedEventArgs_adaptor<X> { typedef adapt ICalendarDatePickerDateChangedEventArgs; };
struct ICalendarDatePickerDateChangedEventArgs : ICalendarDatePickerDateChangedEventArgs_raw, generate<ICalendarDatePickerDateChangedEventArgs> {};

// CalendarDatePickerDateChangedEventArgs
template<typename X> struct statics<CalendarDatePickerDateChangedEventArgs, X> : X {
	typedef typename X::root_type CalendarDatePickerDateChangedEventArgs;
};
struct CalendarDatePickerDateChangedEventArgs : generate<CalendarDatePickerDateChangedEventArgs> {};

// ICalendarViewSelectedDatesChangedEventArgs
struct ICalendarViewSelectedDatesChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_AddedDates(Foundation::Collections::IVectorView<Foundation::DateTime>* *value);
	virtual STDMETHODIMP _get_RemovedDates(Foundation::Collections::IVectorView<Foundation::DateTime>* *value);
};
template<typename X> struct ICalendarViewSelectedDatesChangedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<Foundation::DateTime>> get() { Foundation::Collections::IVectorView<Foundation::DateTime>* value; hrcheck(enc(&ICalendarViewSelectedDatesChangedEventArgs_adaptor::AddedDates)->_get_AddedDates(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<Foundation::DateTime>> operator->() { return get(); }
		} AddedDates;
		struct : property {
			ptr<Foundation::Collections::IVectorView<Foundation::DateTime>> get() { Foundation::Collections::IVectorView<Foundation::DateTime>* value; hrcheck(enc(&ICalendarViewSelectedDatesChangedEventArgs_adaptor::RemovedDates)->_get_RemovedDates(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<Foundation::DateTime>> operator->() { return get(); }
		} RemovedDates;
	};
	ICalendarViewSelectedDatesChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ICalendarViewSelectedDatesChangedEventArgs, X> : Windows::UI::Xaml::Controls::ICalendarViewSelectedDatesChangedEventArgs_adaptor<X> { typedef adapt ICalendarViewSelectedDatesChangedEventArgs; };
struct ICalendarViewSelectedDatesChangedEventArgs : ICalendarViewSelectedDatesChangedEventArgs_raw, generate<ICalendarViewSelectedDatesChangedEventArgs> {};

// CalendarViewSelectedDatesChangedEventArgs
template<typename X> struct statics<CalendarViewSelectedDatesChangedEventArgs, X> : X {
	typedef typename X::root_type CalendarViewSelectedDatesChangedEventArgs;
};
struct CalendarViewSelectedDatesChangedEventArgs : generate<CalendarViewSelectedDatesChangedEventArgs> {};

// IContentDialogButtonClickDeferral
struct IContentDialogButtonClickDeferral_raw : IInspectable {
	virtual STDMETHODIMP _Complete();
};
template<typename X> struct IContentDialogButtonClickDeferral_adaptor : X {
	void Complete() { hrcheck(X::get()->_Complete()); }
};
template<typename X> struct adapt<IContentDialogButtonClickDeferral, X> : Windows::UI::Xaml::Controls::IContentDialogButtonClickDeferral_adaptor<X> { typedef adapt IContentDialogButtonClickDeferral; };
struct IContentDialogButtonClickDeferral : IContentDialogButtonClickDeferral_raw, generate<IContentDialogButtonClickDeferral> {};

// ContentDialogButtonClickDeferral
template<typename X> struct statics<ContentDialogButtonClickDeferral, X> : X {
	typedef typename X::root_type ContentDialogButtonClickDeferral;
};
struct ContentDialogButtonClickDeferral : generate<ContentDialogButtonClickDeferral> {};

// IContentDialogButtonClickEventArgs
struct IContentDialogButtonClickEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Cancel(bool *value);
	virtual STDMETHODIMP _put_Cancel(bool value);
	virtual STDMETHODIMP _GetDeferral(ContentDialogButtonClickDeferral* *returnValue);
};
template<typename X> struct IContentDialogButtonClickEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IContentDialogButtonClickEventArgs_adaptor::Cancel)->_get_Cancel(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IContentDialogButtonClickEventArgs_adaptor::Cancel)->_put_Cancel(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Cancel;
	};
	ptr<ContentDialogButtonClickDeferral> GetDeferral() { ContentDialogButtonClickDeferral* returnValue; hrcheck(X::get()->_GetDeferral(&returnValue)); return from_abi(returnValue); }
	IContentDialogButtonClickEventArgs_adaptor() {}
};
template<typename X> struct adapt<IContentDialogButtonClickEventArgs, X> : Windows::UI::Xaml::Controls::IContentDialogButtonClickEventArgs_adaptor<X> { typedef adapt IContentDialogButtonClickEventArgs; };
struct IContentDialogButtonClickEventArgs : IContentDialogButtonClickEventArgs_raw, generate<IContentDialogButtonClickEventArgs> {};

// ContentDialogButtonClickEventArgs
template<typename X> struct statics<ContentDialogButtonClickEventArgs, X> : X {
	typedef typename X::root_type ContentDialogButtonClickEventArgs;
};
struct ContentDialogButtonClickEventArgs : generate<ContentDialogButtonClickEventArgs> {};

// IContentDialogClosedEventArgs
struct IContentDialogClosedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Result(ContentDialogResult *value);
};
template<typename X> struct IContentDialogClosedEventArgs_adaptor : X {
	union {
		struct : property {
			ContentDialogResult get() { ContentDialogResult value; hrcheck(enc(&IContentDialogClosedEventArgs_adaptor::Result)->_get_Result(&value)); return value; }
			ContentDialogResult operator()() { return get(); }
			operator ContentDialogResult () { return get(); }
		} Result;
	};
	IContentDialogClosedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IContentDialogClosedEventArgs, X> : Windows::UI::Xaml::Controls::IContentDialogClosedEventArgs_adaptor<X> { typedef adapt IContentDialogClosedEventArgs; };
struct IContentDialogClosedEventArgs : IContentDialogClosedEventArgs_raw, generate<IContentDialogClosedEventArgs> {};

// ContentDialogClosedEventArgs
template<typename X> struct statics<ContentDialogClosedEventArgs, X> : X {
	typedef typename X::root_type ContentDialogClosedEventArgs;
};
struct ContentDialogClosedEventArgs : generate<ContentDialogClosedEventArgs> {};

// IContentDialogClosingDeferral
struct IContentDialogClosingDeferral_raw : IInspectable {
	virtual STDMETHODIMP _Complete();
};
template<typename X> struct IContentDialogClosingDeferral_adaptor : X {
	void Complete() { hrcheck(X::get()->_Complete()); }
};
template<typename X> struct adapt<IContentDialogClosingDeferral, X> : Windows::UI::Xaml::Controls::IContentDialogClosingDeferral_adaptor<X> { typedef adapt IContentDialogClosingDeferral; };
struct IContentDialogClosingDeferral : IContentDialogClosingDeferral_raw, generate<IContentDialogClosingDeferral> {};

// ContentDialogClosingDeferral
template<typename X> struct statics<ContentDialogClosingDeferral, X> : X {
	typedef typename X::root_type ContentDialogClosingDeferral;
};
struct ContentDialogClosingDeferral : generate<ContentDialogClosingDeferral> {};

// IContentDialogClosingEventArgs
struct IContentDialogClosingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Result(ContentDialogResult *value);
	virtual STDMETHODIMP _get_Cancel(bool *value);
	virtual STDMETHODIMP _put_Cancel(bool value);
	virtual STDMETHODIMP _GetDeferral(ContentDialogClosingDeferral* *returnValue);
};
template<typename X> struct IContentDialogClosingEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IContentDialogClosingEventArgs_adaptor::Cancel)->_get_Cancel(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IContentDialogClosingEventArgs_adaptor::Cancel)->_put_Cancel(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Cancel;
		struct : property {
			ContentDialogResult get() { ContentDialogResult value; hrcheck(enc(&IContentDialogClosingEventArgs_adaptor::Result)->_get_Result(&value)); return value; }
			ContentDialogResult operator()() { return get(); }
			operator ContentDialogResult () { return get(); }
		} Result;
	};
	ptr<ContentDialogClosingDeferral> GetDeferral() { ContentDialogClosingDeferral* returnValue; hrcheck(X::get()->_GetDeferral(&returnValue)); return from_abi(returnValue); }
	IContentDialogClosingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IContentDialogClosingEventArgs, X> : Windows::UI::Xaml::Controls::IContentDialogClosingEventArgs_adaptor<X> { typedef adapt IContentDialogClosingEventArgs; };
struct IContentDialogClosingEventArgs : IContentDialogClosingEventArgs_raw, generate<IContentDialogClosingEventArgs> {};

// ContentDialogClosingEventArgs
template<typename X> struct statics<ContentDialogClosingEventArgs, X> : X {
	typedef typename X::root_type ContentDialogClosingEventArgs;
};
struct ContentDialogClosingEventArgs : generate<ContentDialogClosingEventArgs> {};

// IContentDialogOpenedEventArgs
struct IContentDialogOpenedEventArgs : IInspectable, generate<IContentDialogOpenedEventArgs> {};

// ContentDialogOpenedEventArgs
template<typename X> struct statics<ContentDialogOpenedEventArgs, X> : X {
	typedef typename X::root_type ContentDialogOpenedEventArgs;
};
struct ContentDialogOpenedEventArgs : generate<ContentDialogOpenedEventArgs> {};

// IContentLinkChangedEventArgs
struct IContentLinkChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ChangeKind(ContentLinkChangeKind *value);
	virtual STDMETHODIMP _get_ContentLinkInfo(Text::ContentLinkInfo* *value);
	virtual STDMETHODIMP _get_TextRange(Documents::TextRange *value);
};
template<typename X> struct IContentLinkChangedEventArgs_adaptor : X {
	union {
		struct : property {
			ContentLinkChangeKind get() { ContentLinkChangeKind value; hrcheck(enc(&IContentLinkChangedEventArgs_adaptor::ChangeKind)->_get_ChangeKind(&value)); return value; }
			ContentLinkChangeKind operator()() { return get(); }
			operator ContentLinkChangeKind () { return get(); }
		} ChangeKind;
		struct : property {
			ptr<Text::ContentLinkInfo> get() { Text::ContentLinkInfo* value; hrcheck(enc(&IContentLinkChangedEventArgs_adaptor::ContentLinkInfo)->_get_ContentLinkInfo(&value)); return from_abi(value); }
			ptr<Text::ContentLinkInfo> operator()() { return get(); }
			operator ptr<Text::ContentLinkInfo> () { return get(); }
			ptr<Text::ContentLinkInfo> operator->() { return get(); }
		} ContentLinkInfo;
		struct : property {
			Documents::TextRange get() { Documents::TextRange value; hrcheck(enc(&IContentLinkChangedEventArgs_adaptor::TextRange)->_get_TextRange(&value)); return value; }
			Documents::TextRange operator()() { return get(); }
			operator Documents::TextRange () { return get(); }
		} TextRange;
	};
	IContentLinkChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IContentLinkChangedEventArgs, X> : Windows::UI::Xaml::Controls::IContentLinkChangedEventArgs_adaptor<X> { typedef adapt IContentLinkChangedEventArgs; };
struct IContentLinkChangedEventArgs : IContentLinkChangedEventArgs_raw, generate<IContentLinkChangedEventArgs> {};

// ContentLinkChangedEventArgs
template<typename X> struct statics<ContentLinkChangedEventArgs, X> : X {
	typedef typename X::root_type ContentLinkChangedEventArgs;
};
struct ContentLinkChangedEventArgs : generate<ContentLinkChangedEventArgs> {};

// IDatePickerValueChangedEventArgs
struct IDatePickerValueChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_OldDate(Foundation::DateTime *value);
	virtual STDMETHODIMP _get_NewDate(Foundation::DateTime *value);
};
template<typename X> struct IDatePickerValueChangedEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IDatePickerValueChangedEventArgs_adaptor::NewDate)->_get_NewDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} NewDate;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IDatePickerValueChangedEventArgs_adaptor::OldDate)->_get_OldDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} OldDate;
	};
	IDatePickerValueChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDatePickerValueChangedEventArgs, X> : Windows::UI::Xaml::Controls::IDatePickerValueChangedEventArgs_adaptor<X> { typedef adapt IDatePickerValueChangedEventArgs; };
struct IDatePickerValueChangedEventArgs : IDatePickerValueChangedEventArgs_raw, generate<IDatePickerValueChangedEventArgs> {};

// DatePickerValueChangedEventArgs
template<typename X> struct statics<DatePickerValueChangedEventArgs, X> : X {
	typedef typename X::root_type DatePickerValueChangedEventArgs;
};
struct DatePickerValueChangedEventArgs : generate<DatePickerValueChangedEventArgs> {};

// IDynamicOverflowItemsChangingEventArgs
struct IDynamicOverflowItemsChangingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Action(CommandBarDynamicOverflowAction *value);
};
template<typename X> struct IDynamicOverflowItemsChangingEventArgs_adaptor : X {
	union {
		struct : property {
			CommandBarDynamicOverflowAction get() { CommandBarDynamicOverflowAction value; hrcheck(enc(&IDynamicOverflowItemsChangingEventArgs_adaptor::Action)->_get_Action(&value)); return value; }
			CommandBarDynamicOverflowAction operator()() { return get(); }
			operator CommandBarDynamicOverflowAction () { return get(); }
		} Action;
	};
	IDynamicOverflowItemsChangingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDynamicOverflowItemsChangingEventArgs, X> : Windows::UI::Xaml::Controls::IDynamicOverflowItemsChangingEventArgs_adaptor<X> { typedef adapt IDynamicOverflowItemsChangingEventArgs; };
struct IDynamicOverflowItemsChangingEventArgs : IDynamicOverflowItemsChangingEventArgs_raw, generate<IDynamicOverflowItemsChangingEventArgs> {};

// DynamicOverflowItemsChangingEventArgs
template<typename X> struct statics<DynamicOverflowItemsChangingEventArgs, X> : X {
	typedef typename X::root_type DynamicOverflowItemsChangingEventArgs;
};
struct DynamicOverflowItemsChangingEventArgs : generate<DynamicOverflowItemsChangingEventArgs> {};

// IHubSectionFactory
struct IHubSectionFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, HubSection* *instance);
};

// IHubSectionStatics
struct IHubSectionStatics : IInspectable {
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsHeaderInteractiveProperty(DependencyProperty* *value);
};

// IHubSection
struct IHubSection_raw : IInspectable {
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_ContentTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_ContentTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_IsHeaderInteractive(bool *value);
	virtual STDMETHODIMP _put_IsHeaderInteractive(bool value);
};
template<typename X> struct IHubSection_adaptor : X {
	union {
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IHubSection_adaptor::ContentTemplate)->_get_ContentTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IHubSection_adaptor::ContentTemplate)->_put_ContentTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} ContentTemplate;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IHubSection_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IHubSection_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IHubSection_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IHubSection_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IHubSection_adaptor::IsHeaderInteractive)->_get_IsHeaderInteractive(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IHubSection_adaptor::IsHeaderInteractive)->_put_IsHeaderInteractive(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsHeaderInteractive;
	};
	IHubSection_adaptor() {}
};
template<typename X> struct adapt<IHubSection, X> : Windows::UI::Xaml::Controls::IHubSection_adaptor<X> { typedef adapt IHubSection; };
struct IHubSection : IHubSection_raw, generate<IHubSection> {};

// HubSection
template<typename> struct HubSection_statics {
	static struct _ContentTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<HubSection, IHubSectionStatics>()->_get_ContentTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentTemplateProperty;
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<HubSection, IHubSectionStatics>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static struct _HeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<HubSection, IHubSectionStatics>()->_get_HeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTemplateProperty;
	static struct _IsHeaderInteractiveProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<HubSection, IHubSectionStatics>()->_get_IsHeaderInteractiveProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsHeaderInteractiveProperty;
	static HubSection *activate(object_ref outer, IInspectable* *inner) { HubSection *instance; hrcheck(get_activation_factory<HubSection, IHubSectionFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename HubSection_statics<X>::_ContentTemplateProperty HubSection_statics<X>::ContentTemplateProperty;
template<typename X> typename HubSection_statics<X>::_HeaderProperty HubSection_statics<X>::HeaderProperty;
template<typename X> typename HubSection_statics<X>::_HeaderTemplateProperty HubSection_statics<X>::HeaderTemplateProperty;
template<typename X> typename HubSection_statics<X>::_IsHeaderInteractiveProperty HubSection_statics<X>::IsHeaderInteractiveProperty;

template<typename X> struct statics<HubSection, X> : X, Windows::UI::Xaml::Controls::HubSection_statics<void> {
	using Windows::UI::Xaml::Controls::HubSection_statics<void>::activate;
	typedef typename X::root_type HubSection;
};
struct HubSection : generate<HubSection> {};

// HubSectionCollection
template<typename X> struct statics<HubSectionCollection, X> : X {
	typedef typename X::root_type HubSectionCollection;
};
struct HubSectionCollection : generate<HubSectionCollection> {};

// IListViewPersistenceHelper
struct IListViewPersistenceHelper : IInspectable, generate<IListViewPersistenceHelper> {};

// IListViewPersistenceHelperStatics
struct IListViewPersistenceHelperStatics : IInspectable {
	virtual STDMETHODIMP _GetRelativeScrollPosition(ListViewBase* listViewBase, ListViewItemToKeyHandler* itemToKeyHandler, HSTRING *returnValue);
	virtual STDMETHODIMP _SetRelativeScrollPositionAsync(ListViewBase* listViewBase, HSTRING relativeScrollPosition, ListViewKeyToItemHandler* keyToItemHandler, Foundation::IAsyncAction* *returnValue);
};

// ListViewPersistenceHelper
template<typename> struct ListViewPersistenceHelper_statics {
	static hstring GetRelativeScrollPosition(pptr<ListViewBase> listViewBase, handler_ref<ListViewItemToKeyHandler> itemToKeyHandler) { HSTRING returnValue; hrcheck(get_activation_factory<ListViewPersistenceHelper, IListViewPersistenceHelperStatics>()->_GetRelativeScrollPosition(listViewBase, itemToKeyHandler, &returnValue)); return from_abi(returnValue); }
	static ptr<Foundation::IAsyncAction> SetRelativeScrollPositionAsync(pptr<ListViewBase> listViewBase, hstring_ref relativeScrollPosition, handler_ref<ListViewKeyToItemHandler> keyToItemHandler) { Foundation::IAsyncAction* returnValue; hrcheck(get_activation_factory<ListViewPersistenceHelper, IListViewPersistenceHelperStatics>()->_SetRelativeScrollPositionAsync(listViewBase, relativeScrollPosition, keyToItemHandler, &returnValue)); return from_abi(returnValue); }
};

template<typename X> struct statics<ListViewPersistenceHelper, X> : X, Windows::UI::Xaml::Controls::ListViewPersistenceHelper_statics<void> {
	typedef typename X::root_type ListViewPersistenceHelper;
};
struct ListViewPersistenceHelper : generate<ListViewPersistenceHelper> {};

// IRichEditBoxTextChangingEventArgs
struct IRichEditBoxTextChangingEventArgs : IInspectable, generate<IRichEditBoxTextChangingEventArgs> {};

// IRichEditBoxTextChangingEventArgs2
struct IRichEditBoxTextChangingEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsContentChanging(bool *value);
};
template<typename X> struct IRichEditBoxTextChangingEventArgs2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRichEditBoxTextChangingEventArgs2_adaptor::IsContentChanging)->_get_IsContentChanging(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsContentChanging;
	};
	IRichEditBoxTextChangingEventArgs2_adaptor() {}
};
template<typename X> struct adapt<IRichEditBoxTextChangingEventArgs2, X> : Windows::UI::Xaml::Controls::IRichEditBoxTextChangingEventArgs2_adaptor<X> { typedef adapt IRichEditBoxTextChangingEventArgs2; };
struct IRichEditBoxTextChangingEventArgs2 : IRichEditBoxTextChangingEventArgs2_raw, generate<IRichEditBoxTextChangingEventArgs2> {};

// RichEditBoxTextChangingEventArgs
template<typename X> struct statics<RichEditBoxTextChangingEventArgs, X> : X {
	typedef typename X::root_type RichEditBoxTextChangingEventArgs;
};
struct RichEditBoxTextChangingEventArgs : generate<RichEditBoxTextChangingEventArgs> {};

// IScrollViewerView
struct IScrollViewerView_raw : IInspectable {
	virtual STDMETHODIMP _get_HorizontalOffset(double *value);
	virtual STDMETHODIMP _get_VerticalOffset(double *value);
	virtual STDMETHODIMP _get_ZoomFactor(float *value);
};
template<typename X> struct IScrollViewerView_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollViewerView_adaptor::HorizontalOffset)->_get_HorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} HorizontalOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollViewerView_adaptor::VerticalOffset)->_get_VerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} VerticalOffset;
		struct : property {
			float get() { float value; hrcheck(enc(&IScrollViewerView_adaptor::ZoomFactor)->_get_ZoomFactor(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} ZoomFactor;
	};
	IScrollViewerView_adaptor() {}
};
template<typename X> struct adapt<IScrollViewerView, X> : Windows::UI::Xaml::Controls::IScrollViewerView_adaptor<X> { typedef adapt IScrollViewerView; };
struct IScrollViewerView : IScrollViewerView_raw, generate<IScrollViewerView> {};

// ScrollViewerView
template<typename X> struct statics<ScrollViewerView, X> : X {
	typedef typename X::root_type ScrollViewerView;
};
struct ScrollViewerView : generate<ScrollViewerView> {};

// IScrollViewerViewChangedEventArgs
struct IScrollViewerViewChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_IsIntermediate(bool *value);
};
template<typename X> struct IScrollViewerViewChangedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollViewerViewChangedEventArgs_adaptor::IsIntermediate)->_get_IsIntermediate(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsIntermediate;
	};
	IScrollViewerViewChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IScrollViewerViewChangedEventArgs, X> : Windows::UI::Xaml::Controls::IScrollViewerViewChangedEventArgs_adaptor<X> { typedef adapt IScrollViewerViewChangedEventArgs; };
struct IScrollViewerViewChangedEventArgs : IScrollViewerViewChangedEventArgs_raw, generate<IScrollViewerViewChangedEventArgs> {};

// ScrollViewerViewChangedEventArgs
template<typename X> struct statics<ScrollViewerViewChangedEventArgs, X> : X {
	typedef typename X::root_type ScrollViewerViewChangedEventArgs;
};
struct ScrollViewerViewChangedEventArgs : generate<ScrollViewerViewChangedEventArgs> {};

// IScrollViewerViewChangingEventArgs
struct IScrollViewerViewChangingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_NextView(ScrollViewerView* *value);
	virtual STDMETHODIMP _get_FinalView(ScrollViewerView* *value);
	virtual STDMETHODIMP _get_IsInertial(bool *value);
};
template<typename X> struct IScrollViewerViewChangingEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<ScrollViewerView> get() { ScrollViewerView* value; hrcheck(enc(&IScrollViewerViewChangingEventArgs_adaptor::FinalView)->_get_FinalView(&value)); return from_abi(value); }
			ptr<ScrollViewerView> operator()() { return get(); }
			operator ptr<ScrollViewerView> () { return get(); }
			ptr<ScrollViewerView> operator->() { return get(); }
		} FinalView;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollViewerViewChangingEventArgs_adaptor::IsInertial)->_get_IsInertial(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsInertial;
		struct : property {
			ptr<ScrollViewerView> get() { ScrollViewerView* value; hrcheck(enc(&IScrollViewerViewChangingEventArgs_adaptor::NextView)->_get_NextView(&value)); return from_abi(value); }
			ptr<ScrollViewerView> operator()() { return get(); }
			operator ptr<ScrollViewerView> () { return get(); }
			ptr<ScrollViewerView> operator->() { return get(); }
		} NextView;
	};
	IScrollViewerViewChangingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IScrollViewerViewChangingEventArgs, X> : Windows::UI::Xaml::Controls::IScrollViewerViewChangingEventArgs_adaptor<X> { typedef adapt IScrollViewerViewChangingEventArgs; };
struct IScrollViewerViewChangingEventArgs : IScrollViewerViewChangingEventArgs_raw, generate<IScrollViewerViewChangingEventArgs> {};

// ScrollViewerViewChangingEventArgs
template<typename X> struct statics<ScrollViewerViewChangingEventArgs, X> : X {
	typedef typename X::root_type ScrollViewerViewChangingEventArgs;
};
struct ScrollViewerViewChangingEventArgs : generate<ScrollViewerViewChangingEventArgs> {};

// ISearchBoxQueryChangedEventArgs
struct ISearchBoxQueryChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_QueryText(HSTRING *value);
	virtual STDMETHODIMP _get_Language(HSTRING *value);
	virtual STDMETHODIMP _get_LinguisticDetails(ApplicationModel::Search::SearchQueryLinguisticDetails* *value);
};
template<typename X> struct ISearchBoxQueryChangedEventArgs_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISearchBoxQueryChangedEventArgs_adaptor::Language)->_get_Language(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Language;
		struct : property {
			ptr<ApplicationModel::Search::SearchQueryLinguisticDetails> get() { ApplicationModel::Search::SearchQueryLinguisticDetails* value; hrcheck(enc(&ISearchBoxQueryChangedEventArgs_adaptor::LinguisticDetails)->_get_LinguisticDetails(&value)); return from_abi(value); }
			ptr<ApplicationModel::Search::SearchQueryLinguisticDetails> operator()() { return get(); }
			operator ptr<ApplicationModel::Search::SearchQueryLinguisticDetails> () { return get(); }
			ptr<ApplicationModel::Search::SearchQueryLinguisticDetails> operator->() { return get(); }
		} LinguisticDetails;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISearchBoxQueryChangedEventArgs_adaptor::QueryText)->_get_QueryText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} QueryText;
	};
	ISearchBoxQueryChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISearchBoxQueryChangedEventArgs, X> : Windows::UI::Xaml::Controls::ISearchBoxQueryChangedEventArgs_adaptor<X> { typedef adapt ISearchBoxQueryChangedEventArgs; };
struct ISearchBoxQueryChangedEventArgs : ISearchBoxQueryChangedEventArgs_raw, generate<ISearchBoxQueryChangedEventArgs> {};

// SearchBoxQueryChangedEventArgs
template<typename X> struct statics<SearchBoxQueryChangedEventArgs, X> : X {
	typedef typename X::root_type SearchBoxQueryChangedEventArgs;
};
struct SearchBoxQueryChangedEventArgs : generate<SearchBoxQueryChangedEventArgs> {};

// ISearchBoxQuerySubmittedEventArgs
struct ISearchBoxQuerySubmittedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_QueryText(HSTRING *value);
	virtual STDMETHODIMP _get_Language(HSTRING *value);
	virtual STDMETHODIMP _get_LinguisticDetails(ApplicationModel::Search::SearchQueryLinguisticDetails* *value);
	virtual STDMETHODIMP _get_KeyModifiers(System::VirtualKeyModifiers *value);
};
template<typename X> struct ISearchBoxQuerySubmittedEventArgs_adaptor : X {
	union {
		struct : property {
			System::VirtualKeyModifiers get() { System::VirtualKeyModifiers value; hrcheck(enc(&ISearchBoxQuerySubmittedEventArgs_adaptor::KeyModifiers)->_get_KeyModifiers(&value)); return value; }
			System::VirtualKeyModifiers operator()() { return get(); }
			operator System::VirtualKeyModifiers () { return get(); }
		} KeyModifiers;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISearchBoxQuerySubmittedEventArgs_adaptor::Language)->_get_Language(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Language;
		struct : property {
			ptr<ApplicationModel::Search::SearchQueryLinguisticDetails> get() { ApplicationModel::Search::SearchQueryLinguisticDetails* value; hrcheck(enc(&ISearchBoxQuerySubmittedEventArgs_adaptor::LinguisticDetails)->_get_LinguisticDetails(&value)); return from_abi(value); }
			ptr<ApplicationModel::Search::SearchQueryLinguisticDetails> operator()() { return get(); }
			operator ptr<ApplicationModel::Search::SearchQueryLinguisticDetails> () { return get(); }
			ptr<ApplicationModel::Search::SearchQueryLinguisticDetails> operator->() { return get(); }
		} LinguisticDetails;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISearchBoxQuerySubmittedEventArgs_adaptor::QueryText)->_get_QueryText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} QueryText;
	};
	ISearchBoxQuerySubmittedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISearchBoxQuerySubmittedEventArgs, X> : Windows::UI::Xaml::Controls::ISearchBoxQuerySubmittedEventArgs_adaptor<X> { typedef adapt ISearchBoxQuerySubmittedEventArgs; };
struct ISearchBoxQuerySubmittedEventArgs : ISearchBoxQuerySubmittedEventArgs_raw, generate<ISearchBoxQuerySubmittedEventArgs> {};

// SearchBoxQuerySubmittedEventArgs
template<typename X> struct statics<SearchBoxQuerySubmittedEventArgs, X> : X {
	typedef typename X::root_type SearchBoxQuerySubmittedEventArgs;
};
struct SearchBoxQuerySubmittedEventArgs : generate<SearchBoxQuerySubmittedEventArgs> {};

// ISearchBoxResultSuggestionChosenEventArgs
struct ISearchBoxResultSuggestionChosenEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Tag(HSTRING *value);
	virtual STDMETHODIMP _get_KeyModifiers(System::VirtualKeyModifiers *value);
};
template<typename X> struct ISearchBoxResultSuggestionChosenEventArgs_adaptor : X {
	union {
		struct : property {
			System::VirtualKeyModifiers get() { System::VirtualKeyModifiers value; hrcheck(enc(&ISearchBoxResultSuggestionChosenEventArgs_adaptor::KeyModifiers)->_get_KeyModifiers(&value)); return value; }
			System::VirtualKeyModifiers operator()() { return get(); }
			operator System::VirtualKeyModifiers () { return get(); }
		} KeyModifiers;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISearchBoxResultSuggestionChosenEventArgs_adaptor::Tag)->_get_Tag(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Tag;
	};
	ISearchBoxResultSuggestionChosenEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISearchBoxResultSuggestionChosenEventArgs, X> : Windows::UI::Xaml::Controls::ISearchBoxResultSuggestionChosenEventArgs_adaptor<X> { typedef adapt ISearchBoxResultSuggestionChosenEventArgs; };
struct ISearchBoxResultSuggestionChosenEventArgs : ISearchBoxResultSuggestionChosenEventArgs_raw, generate<ISearchBoxResultSuggestionChosenEventArgs> {};

// SearchBoxResultSuggestionChosenEventArgs
template<typename X> struct statics<SearchBoxResultSuggestionChosenEventArgs, X> : X {
	typedef typename X::root_type SearchBoxResultSuggestionChosenEventArgs;
};
struct SearchBoxResultSuggestionChosenEventArgs : generate<SearchBoxResultSuggestionChosenEventArgs> {};

// ISearchBoxSuggestionsRequestedEventArgs
struct ISearchBoxSuggestionsRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_QueryText(HSTRING *value);
	virtual STDMETHODIMP _get_Language(HSTRING *value);
	virtual STDMETHODIMP _get_LinguisticDetails(ApplicationModel::Search::SearchQueryLinguisticDetails* *value);
	virtual STDMETHODIMP _get_Request(ApplicationModel::Search::SearchSuggestionsRequest* *value);
};
template<typename X> struct ISearchBoxSuggestionsRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISearchBoxSuggestionsRequestedEventArgs_adaptor::Language)->_get_Language(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Language;
		struct : property {
			ptr<ApplicationModel::Search::SearchQueryLinguisticDetails> get() { ApplicationModel::Search::SearchQueryLinguisticDetails* value; hrcheck(enc(&ISearchBoxSuggestionsRequestedEventArgs_adaptor::LinguisticDetails)->_get_LinguisticDetails(&value)); return from_abi(value); }
			ptr<ApplicationModel::Search::SearchQueryLinguisticDetails> operator()() { return get(); }
			operator ptr<ApplicationModel::Search::SearchQueryLinguisticDetails> () { return get(); }
			ptr<ApplicationModel::Search::SearchQueryLinguisticDetails> operator->() { return get(); }
		} LinguisticDetails;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISearchBoxSuggestionsRequestedEventArgs_adaptor::QueryText)->_get_QueryText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} QueryText;
		struct : property {
			ptr<ApplicationModel::Search::SearchSuggestionsRequest> get() { ApplicationModel::Search::SearchSuggestionsRequest* value; hrcheck(enc(&ISearchBoxSuggestionsRequestedEventArgs_adaptor::Request)->_get_Request(&value)); return from_abi(value); }
			ptr<ApplicationModel::Search::SearchSuggestionsRequest> operator()() { return get(); }
			operator ptr<ApplicationModel::Search::SearchSuggestionsRequest> () { return get(); }
			ptr<ApplicationModel::Search::SearchSuggestionsRequest> operator->() { return get(); }
		} Request;
	};
	ISearchBoxSuggestionsRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISearchBoxSuggestionsRequestedEventArgs, X> : Windows::UI::Xaml::Controls::ISearchBoxSuggestionsRequestedEventArgs_adaptor<X> { typedef adapt ISearchBoxSuggestionsRequestedEventArgs; };
struct ISearchBoxSuggestionsRequestedEventArgs : ISearchBoxSuggestionsRequestedEventArgs_raw, generate<ISearchBoxSuggestionsRequestedEventArgs> {};

// SearchBoxSuggestionsRequestedEventArgs
template<typename X> struct statics<SearchBoxSuggestionsRequestedEventArgs, X> : X {
	typedef typename X::root_type SearchBoxSuggestionsRequestedEventArgs;
};
struct SearchBoxSuggestionsRequestedEventArgs : generate<SearchBoxSuggestionsRequestedEventArgs> {};

// ISplitViewPaneClosingEventArgs
struct ISplitViewPaneClosingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Cancel(bool *value);
	virtual STDMETHODIMP _put_Cancel(bool value);
};
template<typename X> struct ISplitViewPaneClosingEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISplitViewPaneClosingEventArgs_adaptor::Cancel)->_get_Cancel(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISplitViewPaneClosingEventArgs_adaptor::Cancel)->_put_Cancel(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Cancel;
	};
	ISplitViewPaneClosingEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISplitViewPaneClosingEventArgs, X> : Windows::UI::Xaml::Controls::ISplitViewPaneClosingEventArgs_adaptor<X> { typedef adapt ISplitViewPaneClosingEventArgs; };
struct ISplitViewPaneClosingEventArgs : ISplitViewPaneClosingEventArgs_raw, generate<ISplitViewPaneClosingEventArgs> {};

// SplitViewPaneClosingEventArgs
template<typename X> struct statics<SplitViewPaneClosingEventArgs, X> : X {
	typedef typename X::root_type SplitViewPaneClosingEventArgs;
};
struct SplitViewPaneClosingEventArgs : generate<SplitViewPaneClosingEventArgs> {};

// ITimePickerValueChangedEventArgs
struct ITimePickerValueChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_OldTime(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_NewTime(Foundation::TimeSpan *value);
};
template<typename X> struct ITimePickerValueChangedEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ITimePickerValueChangedEventArgs_adaptor::NewTime)->_get_NewTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} NewTime;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ITimePickerValueChangedEventArgs_adaptor::OldTime)->_get_OldTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} OldTime;
	};
	ITimePickerValueChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITimePickerValueChangedEventArgs, X> : Windows::UI::Xaml::Controls::ITimePickerValueChangedEventArgs_adaptor<X> { typedef adapt ITimePickerValueChangedEventArgs; };
struct ITimePickerValueChangedEventArgs : ITimePickerValueChangedEventArgs_raw, generate<ITimePickerValueChangedEventArgs> {};

// TimePickerValueChangedEventArgs
template<typename X> struct statics<TimePickerValueChangedEventArgs, X> : X {
	typedef typename X::root_type TimePickerValueChangedEventArgs;
};
struct TimePickerValueChangedEventArgs : generate<TimePickerValueChangedEventArgs> {};

// IWebViewContentLoadingEventArgs
struct IWebViewContentLoadingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value);
};
template<typename X> struct IWebViewContentLoadingEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IWebViewContentLoadingEventArgs_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
	};
	IWebViewContentLoadingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IWebViewContentLoadingEventArgs, X> : Windows::UI::Xaml::Controls::IWebViewContentLoadingEventArgs_adaptor<X> { typedef adapt IWebViewContentLoadingEventArgs; };
struct IWebViewContentLoadingEventArgs : IWebViewContentLoadingEventArgs_raw, generate<IWebViewContentLoadingEventArgs> {};

// WebViewContentLoadingEventArgs
template<typename X> struct statics<WebViewContentLoadingEventArgs, X> : X {
	typedef typename X::root_type WebViewContentLoadingEventArgs;
};
struct WebViewContentLoadingEventArgs : generate<WebViewContentLoadingEventArgs> {};

// IWebViewDeferredPermissionRequest
struct IWebViewDeferredPermissionRequest_raw : IInspectable {
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_PermissionType(WebViewPermissionType *value);
	virtual STDMETHODIMP _get_Id(unsigned *value);
	virtual STDMETHODIMP _Allow();
	virtual STDMETHODIMP _Deny();
};
template<typename X> struct IWebViewDeferredPermissionRequest_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IWebViewDeferredPermissionRequest_adaptor::Id)->_get_Id(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Id;
		struct : property {
			WebViewPermissionType get() { WebViewPermissionType value; hrcheck(enc(&IWebViewDeferredPermissionRequest_adaptor::PermissionType)->_get_PermissionType(&value)); return value; }
			WebViewPermissionType operator()() { return get(); }
			operator WebViewPermissionType () { return get(); }
		} PermissionType;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IWebViewDeferredPermissionRequest_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
	};
	void Allow() { hrcheck(X::get()->_Allow()); }
	void Deny() { hrcheck(X::get()->_Deny()); }
	IWebViewDeferredPermissionRequest_adaptor() {}
};
template<typename X> struct adapt<IWebViewDeferredPermissionRequest, X> : Windows::UI::Xaml::Controls::IWebViewDeferredPermissionRequest_adaptor<X> { typedef adapt IWebViewDeferredPermissionRequest; };
struct IWebViewDeferredPermissionRequest : IWebViewDeferredPermissionRequest_raw, generate<IWebViewDeferredPermissionRequest> {};

// WebViewDeferredPermissionRequest
template<typename X> struct statics<WebViewDeferredPermissionRequest, X> : X {
	typedef typename X::root_type WebViewDeferredPermissionRequest;
};
struct WebViewDeferredPermissionRequest : generate<WebViewDeferredPermissionRequest> {};

// IWebViewDOMContentLoadedEventArgs
struct IWebViewDOMContentLoadedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value);
};
template<typename X> struct IWebViewDOMContentLoadedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IWebViewDOMContentLoadedEventArgs_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
	};
	IWebViewDOMContentLoadedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IWebViewDOMContentLoadedEventArgs, X> : Windows::UI::Xaml::Controls::IWebViewDOMContentLoadedEventArgs_adaptor<X> { typedef adapt IWebViewDOMContentLoadedEventArgs; };
struct IWebViewDOMContentLoadedEventArgs : IWebViewDOMContentLoadedEventArgs_raw, generate<IWebViewDOMContentLoadedEventArgs> {};

// WebViewDOMContentLoadedEventArgs
template<typename X> struct statics<WebViewDOMContentLoadedEventArgs, X> : X {
	typedef typename X::root_type WebViewDOMContentLoadedEventArgs;
};
struct WebViewDOMContentLoadedEventArgs : generate<WebViewDOMContentLoadedEventArgs> {};

// IWebViewLongRunningScriptDetectedEventArgs
struct IWebViewLongRunningScriptDetectedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ExecutionTime(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_StopPageScriptExecution(bool *value);
	virtual STDMETHODIMP _put_StopPageScriptExecution(bool value);
};
template<typename X> struct IWebViewLongRunningScriptDetectedEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IWebViewLongRunningScriptDetectedEventArgs_adaptor::ExecutionTime)->_get_ExecutionTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} ExecutionTime;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IWebViewLongRunningScriptDetectedEventArgs_adaptor::StopPageScriptExecution)->_get_StopPageScriptExecution(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IWebViewLongRunningScriptDetectedEventArgs_adaptor::StopPageScriptExecution)->_put_StopPageScriptExecution(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} StopPageScriptExecution;
	};
	IWebViewLongRunningScriptDetectedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IWebViewLongRunningScriptDetectedEventArgs, X> : Windows::UI::Xaml::Controls::IWebViewLongRunningScriptDetectedEventArgs_adaptor<X> { typedef adapt IWebViewLongRunningScriptDetectedEventArgs; };
struct IWebViewLongRunningScriptDetectedEventArgs : IWebViewLongRunningScriptDetectedEventArgs_raw, generate<IWebViewLongRunningScriptDetectedEventArgs> {};

// WebViewLongRunningScriptDetectedEventArgs
template<typename X> struct statics<WebViewLongRunningScriptDetectedEventArgs, X> : X {
	typedef typename X::root_type WebViewLongRunningScriptDetectedEventArgs;
};
struct WebViewLongRunningScriptDetectedEventArgs : generate<WebViewLongRunningScriptDetectedEventArgs> {};

// IWebViewNavigationCompletedEventArgs
struct IWebViewNavigationCompletedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_IsSuccess(bool *value);
	virtual STDMETHODIMP _get_WebErrorStatus(Web::WebErrorStatus *value);
};
template<typename X> struct IWebViewNavigationCompletedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IWebViewNavigationCompletedEventArgs_adaptor::IsSuccess)->_get_IsSuccess(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsSuccess;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IWebViewNavigationCompletedEventArgs_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
		struct : property {
			Web::WebErrorStatus get() { Web::WebErrorStatus value; hrcheck(enc(&IWebViewNavigationCompletedEventArgs_adaptor::WebErrorStatus)->_get_WebErrorStatus(&value)); return value; }
			Web::WebErrorStatus operator()() { return get(); }
			operator Web::WebErrorStatus () { return get(); }
		} WebErrorStatus;
	};
	IWebViewNavigationCompletedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IWebViewNavigationCompletedEventArgs, X> : Windows::UI::Xaml::Controls::IWebViewNavigationCompletedEventArgs_adaptor<X> { typedef adapt IWebViewNavigationCompletedEventArgs; };
struct IWebViewNavigationCompletedEventArgs : IWebViewNavigationCompletedEventArgs_raw, generate<IWebViewNavigationCompletedEventArgs> {};

// WebViewNavigationCompletedEventArgs
template<typename X> struct statics<WebViewNavigationCompletedEventArgs, X> : X {
	typedef typename X::root_type WebViewNavigationCompletedEventArgs;
};
struct WebViewNavigationCompletedEventArgs : generate<WebViewNavigationCompletedEventArgs> {};

// IWebViewNavigationStartingEventArgs
struct IWebViewNavigationStartingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_Cancel(bool *value);
	virtual STDMETHODIMP _put_Cancel(bool value);
};
template<typename X> struct IWebViewNavigationStartingEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IWebViewNavigationStartingEventArgs_adaptor::Cancel)->_get_Cancel(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IWebViewNavigationStartingEventArgs_adaptor::Cancel)->_put_Cancel(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Cancel;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IWebViewNavigationStartingEventArgs_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
	};
	IWebViewNavigationStartingEventArgs_adaptor() {}
};
template<typename X> struct adapt<IWebViewNavigationStartingEventArgs, X> : Windows::UI::Xaml::Controls::IWebViewNavigationStartingEventArgs_adaptor<X> { typedef adapt IWebViewNavigationStartingEventArgs; };
struct IWebViewNavigationStartingEventArgs : IWebViewNavigationStartingEventArgs_raw, generate<IWebViewNavigationStartingEventArgs> {};

// WebViewNavigationStartingEventArgs
template<typename X> struct statics<WebViewNavigationStartingEventArgs, X> : X {
	typedef typename X::root_type WebViewNavigationStartingEventArgs;
};
struct WebViewNavigationStartingEventArgs : generate<WebViewNavigationStartingEventArgs> {};

// IWebViewNewWindowRequestedEventArgs
struct IWebViewNewWindowRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_Referrer(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
};
template<typename X> struct IWebViewNewWindowRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IWebViewNewWindowRequestedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IWebViewNewWindowRequestedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IWebViewNewWindowRequestedEventArgs_adaptor::Referrer)->_get_Referrer(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Referrer;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IWebViewNewWindowRequestedEventArgs_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
	};
	IWebViewNewWindowRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IWebViewNewWindowRequestedEventArgs, X> : Windows::UI::Xaml::Controls::IWebViewNewWindowRequestedEventArgs_adaptor<X> { typedef adapt IWebViewNewWindowRequestedEventArgs; };
struct IWebViewNewWindowRequestedEventArgs : IWebViewNewWindowRequestedEventArgs_raw, generate<IWebViewNewWindowRequestedEventArgs> {};

// WebViewNewWindowRequestedEventArgs
template<typename X> struct statics<WebViewNewWindowRequestedEventArgs, X> : X {
	typedef typename X::root_type WebViewNewWindowRequestedEventArgs;
};
struct WebViewNewWindowRequestedEventArgs : generate<WebViewNewWindowRequestedEventArgs> {};

// IWebViewPermissionRequest
struct IWebViewPermissionRequest_raw : IInspectable {
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_PermissionType(WebViewPermissionType *value);
	virtual STDMETHODIMP _get_Id(unsigned *value);
	virtual STDMETHODIMP _get_State(WebViewPermissionState *value);
	virtual STDMETHODIMP _Defer();
	virtual STDMETHODIMP _Allow();
	virtual STDMETHODIMP _Deny();
};
template<typename X> struct IWebViewPermissionRequest_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IWebViewPermissionRequest_adaptor::Id)->_get_Id(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Id;
		struct : property {
			WebViewPermissionType get() { WebViewPermissionType value; hrcheck(enc(&IWebViewPermissionRequest_adaptor::PermissionType)->_get_PermissionType(&value)); return value; }
			WebViewPermissionType operator()() { return get(); }
			operator WebViewPermissionType () { return get(); }
		} PermissionType;
		struct : property {
			WebViewPermissionState get() { WebViewPermissionState value; hrcheck(enc(&IWebViewPermissionRequest_adaptor::State)->_get_State(&value)); return value; }
			WebViewPermissionState operator()() { return get(); }
			operator WebViewPermissionState () { return get(); }
		} State;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IWebViewPermissionRequest_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
	};
	void Defer() { hrcheck(X::get()->_Defer()); }
	void Allow() { hrcheck(X::get()->_Allow()); }
	void Deny() { hrcheck(X::get()->_Deny()); }
	IWebViewPermissionRequest_adaptor() {}
};
template<typename X> struct adapt<IWebViewPermissionRequest, X> : Windows::UI::Xaml::Controls::IWebViewPermissionRequest_adaptor<X> { typedef adapt IWebViewPermissionRequest; };
struct IWebViewPermissionRequest : IWebViewPermissionRequest_raw, generate<IWebViewPermissionRequest> {};

// WebViewPermissionRequest
template<typename X> struct statics<WebViewPermissionRequest, X> : X {
	typedef typename X::root_type WebViewPermissionRequest;
};
struct WebViewPermissionRequest : generate<WebViewPermissionRequest> {};

// IWebViewPermissionRequestedEventArgs
struct IWebViewPermissionRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_PermissionRequest(WebViewPermissionRequest* *value);
};
template<typename X> struct IWebViewPermissionRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<WebViewPermissionRequest> get() { WebViewPermissionRequest* value; hrcheck(enc(&IWebViewPermissionRequestedEventArgs_adaptor::PermissionRequest)->_get_PermissionRequest(&value)); return from_abi(value); }
			ptr<WebViewPermissionRequest> operator()() { return get(); }
			operator ptr<WebViewPermissionRequest> () { return get(); }
			ptr<WebViewPermissionRequest> operator->() { return get(); }
		} PermissionRequest;
	};
	IWebViewPermissionRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IWebViewPermissionRequestedEventArgs, X> : Windows::UI::Xaml::Controls::IWebViewPermissionRequestedEventArgs_adaptor<X> { typedef adapt IWebViewPermissionRequestedEventArgs; };
struct IWebViewPermissionRequestedEventArgs : IWebViewPermissionRequestedEventArgs_raw, generate<IWebViewPermissionRequestedEventArgs> {};

// WebViewPermissionRequestedEventArgs
template<typename X> struct statics<WebViewPermissionRequestedEventArgs, X> : X {
	typedef typename X::root_type WebViewPermissionRequestedEventArgs;
};
struct WebViewPermissionRequestedEventArgs : generate<WebViewPermissionRequestedEventArgs> {};

// IWebViewSeparateProcessLostEventArgs
struct IWebViewSeparateProcessLostEventArgs : IInspectable, generate<IWebViewSeparateProcessLostEventArgs> {};

// WebViewSeparateProcessLostEventArgs
template<typename X> struct statics<WebViewSeparateProcessLostEventArgs, X> : X {
	typedef typename X::root_type WebViewSeparateProcessLostEventArgs;
};
struct WebViewSeparateProcessLostEventArgs : generate<WebViewSeparateProcessLostEventArgs> {};

// IWebViewSettings
struct IWebViewSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_IsJavaScriptEnabled(bool *value);
	virtual STDMETHODIMP _put_IsJavaScriptEnabled(bool value);
	virtual STDMETHODIMP _get_IsIndexedDBEnabled(bool *value);
	virtual STDMETHODIMP _put_IsIndexedDBEnabled(bool value);
};
template<typename X> struct IWebViewSettings_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IWebViewSettings_adaptor::IsIndexedDBEnabled)->_get_IsIndexedDBEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IWebViewSettings_adaptor::IsIndexedDBEnabled)->_put_IsIndexedDBEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsIndexedDBEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IWebViewSettings_adaptor::IsJavaScriptEnabled)->_get_IsJavaScriptEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IWebViewSettings_adaptor::IsJavaScriptEnabled)->_put_IsJavaScriptEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsJavaScriptEnabled;
	};
	IWebViewSettings_adaptor() {}
};
template<typename X> struct adapt<IWebViewSettings, X> : Windows::UI::Xaml::Controls::IWebViewSettings_adaptor<X> { typedef adapt IWebViewSettings; };
struct IWebViewSettings : IWebViewSettings_raw, generate<IWebViewSettings> {};

// WebViewSettings
template<typename X> struct statics<WebViewSettings, X> : X {
	typedef typename X::root_type WebViewSettings;
};
struct WebViewSettings : generate<WebViewSettings> {};

// IWebViewUnsupportedUriSchemeIdentifiedEventArgs
struct IWebViewUnsupportedUriSchemeIdentifiedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
};
template<typename X> struct IWebViewUnsupportedUriSchemeIdentifiedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IWebViewUnsupportedUriSchemeIdentifiedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IWebViewUnsupportedUriSchemeIdentifiedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IWebViewUnsupportedUriSchemeIdentifiedEventArgs_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
	};
	IWebViewUnsupportedUriSchemeIdentifiedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IWebViewUnsupportedUriSchemeIdentifiedEventArgs, X> : Windows::UI::Xaml::Controls::IWebViewUnsupportedUriSchemeIdentifiedEventArgs_adaptor<X> { typedef adapt IWebViewUnsupportedUriSchemeIdentifiedEventArgs; };
struct IWebViewUnsupportedUriSchemeIdentifiedEventArgs : IWebViewUnsupportedUriSchemeIdentifiedEventArgs_raw, generate<IWebViewUnsupportedUriSchemeIdentifiedEventArgs> {};

// WebViewUnsupportedUriSchemeIdentifiedEventArgs
template<typename X> struct statics<WebViewUnsupportedUriSchemeIdentifiedEventArgs, X> : X {
	typedef typename X::root_type WebViewUnsupportedUriSchemeIdentifiedEventArgs;
};
struct WebViewUnsupportedUriSchemeIdentifiedEventArgs : generate<WebViewUnsupportedUriSchemeIdentifiedEventArgs> {};

// IWebViewUnviewableContentIdentifiedEventArgs
struct IWebViewUnviewableContentIdentifiedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_Referrer(Foundation::Uri* *value);
};
template<typename X> struct IWebViewUnviewableContentIdentifiedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IWebViewUnviewableContentIdentifiedEventArgs_adaptor::Referrer)->_get_Referrer(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Referrer;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IWebViewUnviewableContentIdentifiedEventArgs_adaptor::Uri)->_get_Uri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
	};
	IWebViewUnviewableContentIdentifiedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IWebViewUnviewableContentIdentifiedEventArgs, X> : Windows::UI::Xaml::Controls::IWebViewUnviewableContentIdentifiedEventArgs_adaptor<X> { typedef adapt IWebViewUnviewableContentIdentifiedEventArgs; };
struct IWebViewUnviewableContentIdentifiedEventArgs : IWebViewUnviewableContentIdentifiedEventArgs_raw, generate<IWebViewUnviewableContentIdentifiedEventArgs> {};

// IWebViewUnviewableContentIdentifiedEventArgs2
struct IWebViewUnviewableContentIdentifiedEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _get_MediaType(HSTRING *value);
};
template<typename X> struct IWebViewUnviewableContentIdentifiedEventArgs2_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IWebViewUnviewableContentIdentifiedEventArgs2_adaptor::MediaType)->_get_MediaType(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} MediaType;
	};
	IWebViewUnviewableContentIdentifiedEventArgs2_adaptor() {}
};
template<typename X> struct adapt<IWebViewUnviewableContentIdentifiedEventArgs2, X> : Windows::UI::Xaml::Controls::IWebViewUnviewableContentIdentifiedEventArgs2_adaptor<X> { typedef adapt IWebViewUnviewableContentIdentifiedEventArgs2; };
struct IWebViewUnviewableContentIdentifiedEventArgs2 : IWebViewUnviewableContentIdentifiedEventArgs2_raw, generate<IWebViewUnviewableContentIdentifiedEventArgs2> {};

// WebViewUnviewableContentIdentifiedEventArgs
template<typename X> struct statics<WebViewUnviewableContentIdentifiedEventArgs, X> : X {
	typedef typename X::root_type WebViewUnviewableContentIdentifiedEventArgs;
};
struct WebViewUnviewableContentIdentifiedEventArgs : generate<WebViewUnviewableContentIdentifiedEventArgs> {};

// IAutoSuggestBoxQuerySubmittedEventArgs
struct IAutoSuggestBoxQuerySubmittedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_QueryText(HSTRING *value);
	virtual STDMETHODIMP _get_ChosenSuggestion(IInspectable* *value);
};
template<typename X> struct IAutoSuggestBoxQuerySubmittedEventArgs_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IAutoSuggestBoxQuerySubmittedEventArgs_adaptor::ChosenSuggestion)->_get_ChosenSuggestion(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} ChosenSuggestion;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAutoSuggestBoxQuerySubmittedEventArgs_adaptor::QueryText)->_get_QueryText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} QueryText;
	};
	IAutoSuggestBoxQuerySubmittedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IAutoSuggestBoxQuerySubmittedEventArgs, X> : Windows::UI::Xaml::Controls::IAutoSuggestBoxQuerySubmittedEventArgs_adaptor<X> { typedef adapt IAutoSuggestBoxQuerySubmittedEventArgs; };
struct IAutoSuggestBoxQuerySubmittedEventArgs : IAutoSuggestBoxQuerySubmittedEventArgs_raw, generate<IAutoSuggestBoxQuerySubmittedEventArgs> {};

// IAutoSuggestBoxSuggestionChosenEventArgs
struct IAutoSuggestBoxSuggestionChosenEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_SelectedItem(IInspectable* *value);
};
template<typename X> struct IAutoSuggestBoxSuggestionChosenEventArgs_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IAutoSuggestBoxSuggestionChosenEventArgs_adaptor::SelectedItem)->_get_SelectedItem(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} SelectedItem;
	};
	IAutoSuggestBoxSuggestionChosenEventArgs_adaptor() {}
};
template<typename X> struct adapt<IAutoSuggestBoxSuggestionChosenEventArgs, X> : Windows::UI::Xaml::Controls::IAutoSuggestBoxSuggestionChosenEventArgs_adaptor<X> { typedef adapt IAutoSuggestBoxSuggestionChosenEventArgs; };
struct IAutoSuggestBoxSuggestionChosenEventArgs : IAutoSuggestBoxSuggestionChosenEventArgs_raw, generate<IAutoSuggestBoxSuggestionChosenEventArgs> {};

// IAutoSuggestBoxTextChangedEventArgs
struct IAutoSuggestBoxTextChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Reason(AutoSuggestionBoxTextChangeReason *value);
	virtual STDMETHODIMP _put_Reason(AutoSuggestionBoxTextChangeReason value);
	virtual STDMETHODIMP _CheckCurrent(bool *returnValue);
};
template<typename X> struct IAutoSuggestBoxTextChangedEventArgs_adaptor : X {
	union {
		struct : property {
			AutoSuggestionBoxTextChangeReason get() { AutoSuggestionBoxTextChangeReason value; hrcheck(enc(&IAutoSuggestBoxTextChangedEventArgs_adaptor::Reason)->_get_Reason(&value)); return value; }
			AutoSuggestionBoxTextChangeReason operator()() { return get(); }
			operator AutoSuggestionBoxTextChangeReason () { return get(); }
			void put(AutoSuggestionBoxTextChangeReason value) { hrcheck(enc(&IAutoSuggestBoxTextChangedEventArgs_adaptor::Reason)->_put_Reason(value)); }
			void operator=(AutoSuggestionBoxTextChangeReason value) { put(value); }
			void operator()(AutoSuggestionBoxTextChangeReason value) { put(value); }
		} Reason;
	};
	bool CheckCurrent() { bool returnValue; hrcheck(X::get()->_CheckCurrent(&returnValue)); return returnValue; }
	IAutoSuggestBoxTextChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IAutoSuggestBoxTextChangedEventArgs, X> : Windows::UI::Xaml::Controls::IAutoSuggestBoxTextChangedEventArgs_adaptor<X> { typedef adapt IAutoSuggestBoxTextChangedEventArgs; };
struct IAutoSuggestBoxTextChangedEventArgs : IAutoSuggestBoxTextChangedEventArgs_raw, generate<IAutoSuggestBoxTextChangedEventArgs> {};

// IAutoSuggestBoxTextChangedEventArgsStatics
struct IAutoSuggestBoxTextChangedEventArgsStatics : IInspectable {
	virtual STDMETHODIMP _get_ReasonProperty(DependencyProperty* *value);
};

// IIconSource
struct IIconSource_raw : IInspectable {
	virtual STDMETHODIMP _get_Foreground(Media::Brush* *value);
	virtual STDMETHODIMP _put_Foreground(Media::Brush* value);
};
template<typename X> struct IIconSource_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IIconSource_adaptor::Foreground)->_get_Foreground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IIconSource_adaptor::Foreground)->_put_Foreground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Foreground;
	};
	IIconSource_adaptor() {}
};
template<typename X> struct adapt<IIconSource, X> : Windows::UI::Xaml::Controls::IIconSource_adaptor<X> { typedef adapt IIconSource; };
struct IIconSource : IIconSource_raw, generate<IIconSource> {};

// IIconSourceStatics
struct IIconSourceStatics : IInspectable {
	virtual STDMETHODIMP _get_ForegroundProperty(DependencyProperty* *value);
};

// IIconSourceFactory
struct IIconSourceFactory : IInspectable, generate<IIconSourceFactory> {};

// IBitmapIconSourceStatics
struct IBitmapIconSourceStatics : IInspectable {
	virtual STDMETHODIMP _get_UriSourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ShowAsMonochromeProperty(DependencyProperty* *value);
};

// IBitmapIconSourceFactory
struct IBitmapIconSourceFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, BitmapIconSource* *instance);
};

// IFlyout
struct IFlyout_raw : IInspectable {
	virtual STDMETHODIMP _get_Content(UIElement* *value);
	virtual STDMETHODIMP _put_Content(UIElement* value);
	virtual STDMETHODIMP _get_FlyoutPresenterStyle(Style* *value);
	virtual STDMETHODIMP _put_FlyoutPresenterStyle(Style* value);
};
template<typename X> struct IFlyout_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IFlyout_adaptor::Content)->_get_Content(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IFlyout_adaptor::Content)->_put_Content(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} Content;
		struct : property {
			ptr<Style> get() { Style* value; hrcheck(enc(&IFlyout_adaptor::FlyoutPresenterStyle)->_get_FlyoutPresenterStyle(&value)); return from_abi(value); }
			ptr<Style> operator()() { return get(); }
			operator ptr<Style> () { return get(); }
			ptr<Style> operator->() { return get(); }
			void put(pptr<Style> value) { hrcheck(enc(&IFlyout_adaptor::FlyoutPresenterStyle)->_put_FlyoutPresenterStyle(value)); }
			void operator=(pptr<Style> value) { put(value); }
			void operator()(pptr<Style> value) { put(value); }
		} FlyoutPresenterStyle;
	};
	IFlyout_adaptor() {}
};
template<typename X> struct adapt<IFlyout, X> : Windows::UI::Xaml::Controls::IFlyout_adaptor<X> { typedef adapt IFlyout; };
struct IFlyout : IFlyout_raw, generate<IFlyout> {};

// IFlyoutStatics
struct IFlyoutStatics : IInspectable {
	virtual STDMETHODIMP _get_ContentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FlyoutPresenterStyleProperty(DependencyProperty* *value);
};

// IFlyoutFactory
struct IFlyoutFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Flyout* *instance);
};

// IFontIconSource
struct IFontIconSource_raw : IInspectable {
	virtual STDMETHODIMP _get_Glyph(HSTRING *value);
	virtual STDMETHODIMP _put_Glyph(HSTRING value);
	virtual STDMETHODIMP _get_FontSize(double *value);
	virtual STDMETHODIMP _put_FontSize(double value);
	virtual STDMETHODIMP _get_FontFamily(Media::FontFamily* *value);
	virtual STDMETHODIMP _put_FontFamily(Media::FontFamily* value);
	virtual STDMETHODIMP _get_FontWeight(Text::FontWeight *value);
	virtual STDMETHODIMP _put_FontWeight(Text::FontWeight value);
	virtual STDMETHODIMP _get_FontStyle(Text::FontStyle *value);
	virtual STDMETHODIMP _put_FontStyle(Text::FontStyle value);
	virtual STDMETHODIMP _get_IsTextScaleFactorEnabled(bool *value);
	virtual STDMETHODIMP _put_IsTextScaleFactorEnabled(bool value);
	virtual STDMETHODIMP _get_MirroredWhenRightToLeft(bool *value);
	virtual STDMETHODIMP _put_MirroredWhenRightToLeft(bool value);
};
template<typename X> struct IFontIconSource_adaptor : X {
	union {
		struct : property {
			ptr<Media::FontFamily> get() { Media::FontFamily* value; hrcheck(enc(&IFontIconSource_adaptor::FontFamily)->_get_FontFamily(&value)); return from_abi(value); }
			ptr<Media::FontFamily> operator()() { return get(); }
			operator ptr<Media::FontFamily> () { return get(); }
			ptr<Media::FontFamily> operator->() { return get(); }
			void put(pptr<Media::FontFamily> value) { hrcheck(enc(&IFontIconSource_adaptor::FontFamily)->_put_FontFamily(value)); }
			void operator=(pptr<Media::FontFamily> value) { put(value); }
			void operator()(pptr<Media::FontFamily> value) { put(value); }
		} FontFamily;
		struct : property {
			double get() { double value; hrcheck(enc(&IFontIconSource_adaptor::FontSize)->_get_FontSize(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IFontIconSource_adaptor::FontSize)->_put_FontSize(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FontSize;
		struct : property {
			Text::FontStyle get() { Text::FontStyle value; hrcheck(enc(&IFontIconSource_adaptor::FontStyle)->_get_FontStyle(&value)); return value; }
			Text::FontStyle operator()() { return get(); }
			operator Text::FontStyle () { return get(); }
			void put(Text::FontStyle value) { hrcheck(enc(&IFontIconSource_adaptor::FontStyle)->_put_FontStyle(value)); }
			void operator=(Text::FontStyle value) { put(value); }
			void operator()(Text::FontStyle value) { put(value); }
		} FontStyle;
		struct : property {
			Text::FontWeight get() { Text::FontWeight value; hrcheck(enc(&IFontIconSource_adaptor::FontWeight)->_get_FontWeight(&value)); return value; }
			Text::FontWeight operator()() { return get(); }
			operator Text::FontWeight () { return get(); }
			void put(const Text::FontWeight& value) { hrcheck(enc(&IFontIconSource_adaptor::FontWeight)->_put_FontWeight(value)); }
			void operator=(const Text::FontWeight& value) { put(value); }
			void operator()(const Text::FontWeight& value) { put(value); }
		} FontWeight;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IFontIconSource_adaptor::Glyph)->_get_Glyph(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IFontIconSource_adaptor::Glyph)->_put_Glyph(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Glyph;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFontIconSource_adaptor::IsTextScaleFactorEnabled)->_get_IsTextScaleFactorEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IFontIconSource_adaptor::IsTextScaleFactorEnabled)->_put_IsTextScaleFactorEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTextScaleFactorEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFontIconSource_adaptor::MirroredWhenRightToLeft)->_get_MirroredWhenRightToLeft(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IFontIconSource_adaptor::MirroredWhenRightToLeft)->_put_MirroredWhenRightToLeft(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} MirroredWhenRightToLeft;
	};
	IFontIconSource_adaptor() {}
};
template<typename X> struct adapt<IFontIconSource, X> : Windows::UI::Xaml::Controls::IFontIconSource_adaptor<X> { typedef adapt IFontIconSource; };
struct IFontIconSource : IFontIconSource_raw, generate<IFontIconSource> {};

// IFontIconSourceStatics
struct IFontIconSourceStatics : IInspectable {
	virtual STDMETHODIMP _get_GlyphProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontSizeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontFamilyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontWeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsTextScaleFactorEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MirroredWhenRightToLeftProperty(DependencyProperty* *value);
};

// IFontIconSourceFactory
struct IFontIconSourceFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, FontIconSource* *instance);
};

// IMenuFlyout
struct IMenuFlyout_raw : IInspectable {
	virtual STDMETHODIMP _get_Items(Foundation::Collections::IVector<MenuFlyoutItemBase*>* *value);
	virtual STDMETHODIMP _get_MenuFlyoutPresenterStyle(Style* *value);
	virtual STDMETHODIMP _put_MenuFlyoutPresenterStyle(Style* value);
};
template<typename X> struct IMenuFlyout_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<MenuFlyoutItemBase>>> get() { Foundation::Collections::IVector<MenuFlyoutItemBase*>* value; hrcheck(enc(&IMenuFlyout_adaptor::Items)->_get_Items(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<MenuFlyoutItemBase>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<MenuFlyoutItemBase>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<MenuFlyoutItemBase>>> operator->() { return get(); }
		} Items;
		struct : property {
			ptr<Style> get() { Style* value; hrcheck(enc(&IMenuFlyout_adaptor::MenuFlyoutPresenterStyle)->_get_MenuFlyoutPresenterStyle(&value)); return from_abi(value); }
			ptr<Style> operator()() { return get(); }
			operator ptr<Style> () { return get(); }
			ptr<Style> operator->() { return get(); }
			void put(pptr<Style> value) { hrcheck(enc(&IMenuFlyout_adaptor::MenuFlyoutPresenterStyle)->_put_MenuFlyoutPresenterStyle(value)); }
			void operator=(pptr<Style> value) { put(value); }
			void operator()(pptr<Style> value) { put(value); }
		} MenuFlyoutPresenterStyle;
	};
	IMenuFlyout_adaptor() {}
};
template<typename X> struct adapt<IMenuFlyout, X> : Windows::UI::Xaml::Controls::IMenuFlyout_adaptor<X> { typedef adapt IMenuFlyout; };
struct IMenuFlyout : IMenuFlyout_raw, generate<IMenuFlyout> {};

// IMenuFlyoutStatics
struct IMenuFlyoutStatics : IInspectable {
	virtual STDMETHODIMP _get_MenuFlyoutPresenterStyleProperty(DependencyProperty* *value);
};

// IMenuFlyoutFactory
struct IMenuFlyoutFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, MenuFlyout* *instance);
};

// IMenuFlyout2
struct IMenuFlyout2_raw : IInspectable {
	virtual STDMETHODIMP _ShowAt(UIElement* targetElement, Foundation::Point point);
};
template<typename X> struct IMenuFlyout2_adaptor : X {
	void ShowAt(pptr<UIElement> targetElement, const Foundation::Point& point) { hrcheck(X::get()->_ShowAt(targetElement, point)); }
};
template<typename X> struct adapt<IMenuFlyout2, X> : Windows::UI::Xaml::Controls::IMenuFlyout2_adaptor<X> { typedef adapt IMenuFlyout2; };
struct IMenuFlyout2 : IMenuFlyout2_raw, generate<IMenuFlyout2> {};

// IPathIconSource
struct IPathIconSource_raw : IInspectable {
	virtual STDMETHODIMP _get_Data(Media::Geometry* *value);
	virtual STDMETHODIMP _put_Data(Media::Geometry* value);
};
template<typename X> struct IPathIconSource_adaptor : X {
	union {
		struct : property {
			ptr<Media::Geometry> get() { Media::Geometry* value; hrcheck(enc(&IPathIconSource_adaptor::Data)->_get_Data(&value)); return from_abi(value); }
			ptr<Media::Geometry> operator()() { return get(); }
			operator ptr<Media::Geometry> () { return get(); }
			ptr<Media::Geometry> operator->() { return get(); }
			void put(pptr<Media::Geometry> value) { hrcheck(enc(&IPathIconSource_adaptor::Data)->_put_Data(value)); }
			void operator=(pptr<Media::Geometry> value) { put(value); }
			void operator()(pptr<Media::Geometry> value) { put(value); }
		} Data;
	};
	IPathIconSource_adaptor() {}
};
template<typename X> struct adapt<IPathIconSource, X> : Windows::UI::Xaml::Controls::IPathIconSource_adaptor<X> { typedef adapt IPathIconSource; };
struct IPathIconSource : IPathIconSource_raw, generate<IPathIconSource> {};

// IPathIconSourceStatics
struct IPathIconSourceStatics : IInspectable {
	virtual STDMETHODIMP _get_DataProperty(DependencyProperty* *value);
};

// IPathIconSourceFactory
struct IPathIconSourceFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, PathIconSource* *instance);
};

// ISymbolIconSource
struct ISymbolIconSource_raw : IInspectable {
	virtual STDMETHODIMP _get_Symbol(Controls::Symbol *value);
	virtual STDMETHODIMP _put_Symbol(Controls::Symbol value);
};
template<typename X> struct ISymbolIconSource_adaptor : X {
	union {
		struct : property {
			Controls::Symbol get() { Controls::Symbol value; hrcheck(enc(&ISymbolIconSource_adaptor::Symbol)->_get_Symbol(&value)); return value; }
			Controls::Symbol operator()() { return get(); }
			operator Controls::Symbol () { return get(); }
			void put(Controls::Symbol value) { hrcheck(enc(&ISymbolIconSource_adaptor::Symbol)->_put_Symbol(value)); }
			void operator=(Controls::Symbol value) { put(value); }
			void operator()(Controls::Symbol value) { put(value); }
		} Symbol;
	};
	ISymbolIconSource_adaptor() {}
};
template<typename X> struct adapt<ISymbolIconSource, X> : Windows::UI::Xaml::Controls::ISymbolIconSource_adaptor<X> { typedef adapt ISymbolIconSource; };
struct ISymbolIconSource : ISymbolIconSource_raw, generate<ISymbolIconSource> {};

// ISymbolIconSourceStatics
struct ISymbolIconSourceStatics : IInspectable {
	virtual STDMETHODIMP _get_SymbolProperty(DependencyProperty* *value);
};

// ISymbolIconSourceFactory
struct ISymbolIconSourceFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, SymbolIconSource* *instance);
};

// IIconElement
struct IIconElement_raw : IInspectable {
	virtual STDMETHODIMP _get_Foreground(Media::Brush* *value);
	virtual STDMETHODIMP _put_Foreground(Media::Brush* value);
};
template<typename X> struct IIconElement_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IIconElement_adaptor::Foreground)->_get_Foreground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&IIconElement_adaptor::Foreground)->_put_Foreground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Foreground;
	};
	IIconElement_adaptor() {}
};
template<typename X> struct adapt<IIconElement, X> : Windows::UI::Xaml::Controls::IIconElement_adaptor<X> { typedef adapt IIconElement; };
struct IIconElement : IIconElement_raw, generate<IIconElement> {};

// IIconElementStatics
struct IIconElementStatics : IInspectable {
	virtual STDMETHODIMP _get_ForegroundProperty(DependencyProperty* *value);
};

// IIconElementFactory
struct IIconElementFactory : IInspectable, generate<IIconElementFactory> {};

// IInkCanvas
struct IInkCanvas_raw : IInspectable {
	virtual STDMETHODIMP _get_InkPresenter(UI::Input::Inking::InkPresenter* *value);
};
template<typename X> struct IInkCanvas_adaptor : X {
	union {
		struct : property {
			ptr<UI::Input::Inking::InkPresenter> get() { UI::Input::Inking::InkPresenter* value; hrcheck(enc(&IInkCanvas_adaptor::InkPresenter)->_get_InkPresenter(&value)); return from_abi(value); }
			ptr<UI::Input::Inking::InkPresenter> operator()() { return get(); }
			operator ptr<UI::Input::Inking::InkPresenter> () { return get(); }
			ptr<UI::Input::Inking::InkPresenter> operator->() { return get(); }
		} InkPresenter;
	};
	IInkCanvas_adaptor() {}
};
template<typename X> struct adapt<IInkCanvas, X> : Windows::UI::Xaml::Controls::IInkCanvas_adaptor<X> { typedef adapt IInkCanvas; };
struct IInkCanvas : IInkCanvas_raw, generate<IInkCanvas> {};

// IInkCanvasFactory
struct IInkCanvasFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, InkCanvas* *instance);
};

// IMediaElement
struct IMediaElement_raw : IInspectable {
	virtual STDMETHODIMP _get_PosterSource(Media::ImageSource* *value);
	virtual STDMETHODIMP _put_PosterSource(Media::ImageSource* value);
	virtual STDMETHODIMP _get_Source(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_Source(Foundation::Uri* value);
	virtual STDMETHODIMP _get_IsMuted(bool *value);
	virtual STDMETHODIMP _put_IsMuted(bool value);
	virtual STDMETHODIMP _get_IsAudioOnly(bool *value);
	virtual STDMETHODIMP _get_AutoPlay(bool *value);
	virtual STDMETHODIMP _put_AutoPlay(bool value);
	virtual STDMETHODIMP _get_Volume(double *value);
	virtual STDMETHODIMP _put_Volume(double value);
	virtual STDMETHODIMP _get_Balance(double *value);
	virtual STDMETHODIMP _put_Balance(double value);
	virtual STDMETHODIMP _get_NaturalVideoHeight(int *value);
	virtual STDMETHODIMP _get_NaturalVideoWidth(int *value);
	virtual STDMETHODIMP _get_NaturalDuration(Duration *value);
	virtual STDMETHODIMP _get_Position(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_Position(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_DownloadProgress(double *value);
	virtual STDMETHODIMP _get_BufferingProgress(double *value);
	virtual STDMETHODIMP _get_DownloadProgressOffset(double *value);
	virtual STDMETHODIMP _get_CurrentState(Media::MediaElementState *value);
	virtual STDMETHODIMP _get_Markers(Media::TimelineMarkerCollection* *value);
	virtual STDMETHODIMP _get_CanSeek(bool *value);
	virtual STDMETHODIMP _get_CanPause(bool *value);
	virtual STDMETHODIMP _get_AudioStreamCount(int *value);
	virtual STDMETHODIMP _get_AudioStreamIndex(Foundation::IReference<int>* *value);
	virtual STDMETHODIMP _put_AudioStreamIndex(Foundation::IReference<int>* value);
	virtual STDMETHODIMP _get_PlaybackRate(double *value);
	virtual STDMETHODIMP _put_PlaybackRate(double value);
	virtual STDMETHODIMP _get_IsLooping(bool *value);
	virtual STDMETHODIMP _put_IsLooping(bool value);
	virtual STDMETHODIMP _get_PlayToSource(Windows::Media::PlayTo::PlayToSource* *value);
	virtual STDMETHODIMP _get_DefaultPlaybackRate(double *value);
	virtual STDMETHODIMP _put_DefaultPlaybackRate(double value);
	virtual STDMETHODIMP _get_AspectRatioWidth(int *value);
	virtual STDMETHODIMP _get_AspectRatioHeight(int *value);
	virtual STDMETHODIMP _get_RealTimePlayback(bool *value);
	virtual STDMETHODIMP _put_RealTimePlayback(bool value);
	virtual STDMETHODIMP _get_AudioCategory(Media::AudioCategory *value);
	virtual STDMETHODIMP _put_AudioCategory(Media::AudioCategory value);
	virtual STDMETHODIMP _get_AudioDeviceType(Media::AudioDeviceType *value);
	virtual STDMETHODIMP _put_AudioDeviceType(Media::AudioDeviceType value);
	virtual STDMETHODIMP _get_ProtectionManager(Windows::Media::Protection::MediaProtectionManager* *value);
	virtual STDMETHODIMP _put_ProtectionManager(Windows::Media::Protection::MediaProtectionManager* value);
	virtual STDMETHODIMP _get_Stereo3DVideoPackingMode(Media::Stereo3DVideoPackingMode *value);
	virtual STDMETHODIMP _put_Stereo3DVideoPackingMode(Media::Stereo3DVideoPackingMode value);
	virtual STDMETHODIMP _get_Stereo3DVideoRenderMode(Media::Stereo3DVideoRenderMode *value);
	virtual STDMETHODIMP _put_Stereo3DVideoRenderMode(Media::Stereo3DVideoRenderMode value);
	virtual STDMETHODIMP _get_IsStereo3DVideo(bool *value);
	virtual STDMETHODIMP _add_MediaOpened(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_MediaOpened(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_MediaEnded(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_MediaEnded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_MediaFailed(ExceptionRoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_MediaFailed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DownloadProgressChanged(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DownloadProgressChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_BufferingProgressChanged(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_BufferingProgressChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_CurrentStateChanged(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CurrentStateChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_MarkerReached(Media::TimelineMarkerRoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_MarkerReached(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_RateChanged(Media::RateChangedRoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_RateChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_VolumeChanged(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_VolumeChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_SeekCompleted(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SeekCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _Stop();
	virtual STDMETHODIMP _Play();
	virtual STDMETHODIMP _Pause();
	virtual STDMETHODIMP _CanPlayType(HSTRING type, Media::MediaCanPlayResponse *returnValue);
	virtual STDMETHODIMP _SetSource(Storage::Streams::IRandomAccessStream* stream, HSTRING mimeType);
	virtual STDMETHODIMP _GetAudioStreamLanguage(Foundation::IReference<int>* index, HSTRING *returnValue);
	virtual STDMETHODIMP _AddAudioEffect(HSTRING effectID, bool effectOptional, Foundation::Collections::IPropertySet* effectConfiguration);
	virtual STDMETHODIMP _AddVideoEffect(HSTRING effectID, bool effectOptional, Foundation::Collections::IPropertySet* effectConfiguration);
	virtual STDMETHODIMP _RemoveAllEffects();
	virtual STDMETHODIMP _get_ActualStereo3DVideoPackingMode(Media::Stereo3DVideoPackingMode *value);
};
template<typename X> struct IMediaElement_adaptor : X {
	union {
		struct : property {
			Media::Stereo3DVideoPackingMode get() { Media::Stereo3DVideoPackingMode value; hrcheck(enc(&IMediaElement_adaptor::ActualStereo3DVideoPackingMode)->_get_ActualStereo3DVideoPackingMode(&value)); return value; }
			Media::Stereo3DVideoPackingMode operator()() { return get(); }
			operator Media::Stereo3DVideoPackingMode () { return get(); }
		} ActualStereo3DVideoPackingMode;
		struct : property {
			int get() { int value; hrcheck(enc(&IMediaElement_adaptor::AspectRatioHeight)->_get_AspectRatioHeight(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} AspectRatioHeight;
		struct : property {
			int get() { int value; hrcheck(enc(&IMediaElement_adaptor::AspectRatioWidth)->_get_AspectRatioWidth(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} AspectRatioWidth;
		struct : property {
			Media::AudioCategory get() { Media::AudioCategory value; hrcheck(enc(&IMediaElement_adaptor::AudioCategory)->_get_AudioCategory(&value)); return value; }
			Media::AudioCategory operator()() { return get(); }
			operator Media::AudioCategory () { return get(); }
			void put(Media::AudioCategory value) { hrcheck(enc(&IMediaElement_adaptor::AudioCategory)->_put_AudioCategory(value)); }
			void operator=(Media::AudioCategory value) { put(value); }
			void operator()(Media::AudioCategory value) { put(value); }
		} AudioCategory;
		struct : property {
			Media::AudioDeviceType get() { Media::AudioDeviceType value; hrcheck(enc(&IMediaElement_adaptor::AudioDeviceType)->_get_AudioDeviceType(&value)); return value; }
			Media::AudioDeviceType operator()() { return get(); }
			operator Media::AudioDeviceType () { return get(); }
			void put(Media::AudioDeviceType value) { hrcheck(enc(&IMediaElement_adaptor::AudioDeviceType)->_put_AudioDeviceType(value)); }
			void operator=(Media::AudioDeviceType value) { put(value); }
			void operator()(Media::AudioDeviceType value) { put(value); }
		} AudioDeviceType;
		struct : property {
			int get() { int value; hrcheck(enc(&IMediaElement_adaptor::AudioStreamCount)->_get_AudioStreamCount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} AudioStreamCount;
		struct : property {
			ptr<Foundation::IReference<int>> get() { Foundation::IReference<int>* value; hrcheck(enc(&IMediaElement_adaptor::AudioStreamIndex)->_get_AudioStreamIndex(&value)); return from_abi(value); }
			ptr<Foundation::IReference<int>> operator()() { return get(); }
			operator ptr<Foundation::IReference<int>> () { return get(); }
			ptr<Foundation::IReference<int>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<int>> value) { hrcheck(enc(&IMediaElement_adaptor::AudioStreamIndex)->_put_AudioStreamIndex(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<int>> value) { put(to_abi(value)); }
		} AudioStreamIndex;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaElement_adaptor::AutoPlay)->_get_AutoPlay(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaElement_adaptor::AutoPlay)->_put_AutoPlay(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AutoPlay;
		struct : property {
			double get() { double value; hrcheck(enc(&IMediaElement_adaptor::Balance)->_get_Balance(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IMediaElement_adaptor::Balance)->_put_Balance(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Balance;
		struct : property {
			double get() { double value; hrcheck(enc(&IMediaElement_adaptor::BufferingProgress)->_get_BufferingProgress(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} BufferingProgress;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaElement_adaptor::CanPause)->_get_CanPause(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanPause;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaElement_adaptor::CanSeek)->_get_CanSeek(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanSeek;
		struct : property {
			Media::MediaElementState get() { Media::MediaElementState value; hrcheck(enc(&IMediaElement_adaptor::CurrentState)->_get_CurrentState(&value)); return value; }
			Media::MediaElementState operator()() { return get(); }
			operator Media::MediaElementState () { return get(); }
		} CurrentState;
		struct : property {
			double get() { double value; hrcheck(enc(&IMediaElement_adaptor::DefaultPlaybackRate)->_get_DefaultPlaybackRate(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IMediaElement_adaptor::DefaultPlaybackRate)->_put_DefaultPlaybackRate(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DefaultPlaybackRate;
		struct : property {
			double get() { double value; hrcheck(enc(&IMediaElement_adaptor::DownloadProgress)->_get_DownloadProgress(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} DownloadProgress;
		struct : property {
			double get() { double value; hrcheck(enc(&IMediaElement_adaptor::DownloadProgressOffset)->_get_DownloadProgressOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} DownloadProgressOffset;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaElement_adaptor::IsAudioOnly)->_get_IsAudioOnly(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsAudioOnly;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaElement_adaptor::IsLooping)->_get_IsLooping(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaElement_adaptor::IsLooping)->_put_IsLooping(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsLooping;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaElement_adaptor::IsMuted)->_get_IsMuted(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaElement_adaptor::IsMuted)->_put_IsMuted(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsMuted;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaElement_adaptor::IsStereo3DVideo)->_get_IsStereo3DVideo(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsStereo3DVideo;
		struct : property {
			ptr<Media::TimelineMarkerCollection> get() { Media::TimelineMarkerCollection* value; hrcheck(enc(&IMediaElement_adaptor::Markers)->_get_Markers(&value)); return from_abi(value); }
			ptr<Media::TimelineMarkerCollection> operator()() { return get(); }
			operator ptr<Media::TimelineMarkerCollection> () { return get(); }
			ptr<Media::TimelineMarkerCollection> operator->() { return get(); }
		} Markers;
		struct : property {
			Duration get() { Duration value; hrcheck(enc(&IMediaElement_adaptor::NaturalDuration)->_get_NaturalDuration(&value)); return value; }
			Duration operator()() { return get(); }
			operator Duration () { return get(); }
		} NaturalDuration;
		struct : property {
			int get() { int value; hrcheck(enc(&IMediaElement_adaptor::NaturalVideoHeight)->_get_NaturalVideoHeight(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} NaturalVideoHeight;
		struct : property {
			int get() { int value; hrcheck(enc(&IMediaElement_adaptor::NaturalVideoWidth)->_get_NaturalVideoWidth(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} NaturalVideoWidth;
		struct : property {
			ptr<Windows::Media::PlayTo::PlayToSource> get() { Windows::Media::PlayTo::PlayToSource* value; hrcheck(enc(&IMediaElement_adaptor::PlayToSource)->_get_PlayToSource(&value)); return from_abi(value); }
			ptr<Windows::Media::PlayTo::PlayToSource> operator()() { return get(); }
			operator ptr<Windows::Media::PlayTo::PlayToSource> () { return get(); }
			ptr<Windows::Media::PlayTo::PlayToSource> operator->() { return get(); }
		} PlayToSource;
		struct : property {
			double get() { double value; hrcheck(enc(&IMediaElement_adaptor::PlaybackRate)->_get_PlaybackRate(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IMediaElement_adaptor::PlaybackRate)->_put_PlaybackRate(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} PlaybackRate;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMediaElement_adaptor::Position)->_get_Position(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMediaElement_adaptor::Position)->_put_Position(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Position;
		struct : property {
			ptr<Media::ImageSource> get() { Media::ImageSource* value; hrcheck(enc(&IMediaElement_adaptor::PosterSource)->_get_PosterSource(&value)); return from_abi(value); }
			ptr<Media::ImageSource> operator()() { return get(); }
			operator ptr<Media::ImageSource> () { return get(); }
			ptr<Media::ImageSource> operator->() { return get(); }
			void put(pptr<Media::ImageSource> value) { hrcheck(enc(&IMediaElement_adaptor::PosterSource)->_put_PosterSource(value)); }
			void operator=(pptr<Media::ImageSource> value) { put(value); }
			void operator()(pptr<Media::ImageSource> value) { put(value); }
		} PosterSource;
		struct : property {
			ptr<Windows::Media::Protection::MediaProtectionManager> get() { Windows::Media::Protection::MediaProtectionManager* value; hrcheck(enc(&IMediaElement_adaptor::ProtectionManager)->_get_ProtectionManager(&value)); return from_abi(value); }
			ptr<Windows::Media::Protection::MediaProtectionManager> operator()() { return get(); }
			operator ptr<Windows::Media::Protection::MediaProtectionManager> () { return get(); }
			ptr<Windows::Media::Protection::MediaProtectionManager> operator->() { return get(); }
			void put(pptr<Windows::Media::Protection::MediaProtectionManager> value) { hrcheck(enc(&IMediaElement_adaptor::ProtectionManager)->_put_ProtectionManager(value)); }
			void operator=(pptr<Windows::Media::Protection::MediaProtectionManager> value) { put(value); }
			void operator()(pptr<Windows::Media::Protection::MediaProtectionManager> value) { put(value); }
		} ProtectionManager;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaElement_adaptor::RealTimePlayback)->_get_RealTimePlayback(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaElement_adaptor::RealTimePlayback)->_put_RealTimePlayback(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} RealTimePlayback;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IMediaElement_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IMediaElement_adaptor::Source)->_put_Source(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} Source;
		struct : property {
			Media::Stereo3DVideoPackingMode get() { Media::Stereo3DVideoPackingMode value; hrcheck(enc(&IMediaElement_adaptor::Stereo3DVideoPackingMode)->_get_Stereo3DVideoPackingMode(&value)); return value; }
			Media::Stereo3DVideoPackingMode operator()() { return get(); }
			operator Media::Stereo3DVideoPackingMode () { return get(); }
			void put(Media::Stereo3DVideoPackingMode value) { hrcheck(enc(&IMediaElement_adaptor::Stereo3DVideoPackingMode)->_put_Stereo3DVideoPackingMode(value)); }
			void operator=(Media::Stereo3DVideoPackingMode value) { put(value); }
			void operator()(Media::Stereo3DVideoPackingMode value) { put(value); }
		} Stereo3DVideoPackingMode;
		struct : property {
			Media::Stereo3DVideoRenderMode get() { Media::Stereo3DVideoRenderMode value; hrcheck(enc(&IMediaElement_adaptor::Stereo3DVideoRenderMode)->_get_Stereo3DVideoRenderMode(&value)); return value; }
			Media::Stereo3DVideoRenderMode operator()() { return get(); }
			operator Media::Stereo3DVideoRenderMode () { return get(); }
			void put(Media::Stereo3DVideoRenderMode value) { hrcheck(enc(&IMediaElement_adaptor::Stereo3DVideoRenderMode)->_put_Stereo3DVideoRenderMode(value)); }
			void operator=(Media::Stereo3DVideoRenderMode value) { put(value); }
			void operator()(Media::Stereo3DVideoRenderMode value) { put(value); }
		} Stereo3DVideoRenderMode;
		struct : property {
			double get() { double value; hrcheck(enc(&IMediaElement_adaptor::Volume)->_get_Volume(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IMediaElement_adaptor::Volume)->_put_Volume(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Volume;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaElement_adaptor::BufferingProgressChanged)->_add_BufferingProgressChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaElement_adaptor::BufferingProgressChanged)->_remove_BufferingProgressChanged(token)); }
		} BufferingProgressChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaElement_adaptor::CurrentStateChanged)->_add_CurrentStateChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaElement_adaptor::CurrentStateChanged)->_remove_CurrentStateChanged(token)); }
		} CurrentStateChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaElement_adaptor::DownloadProgressChanged)->_add_DownloadProgressChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaElement_adaptor::DownloadProgressChanged)->_remove_DownloadProgressChanged(token)); }
		} DownloadProgressChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Media::TimelineMarkerRoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaElement_adaptor::MarkerReached)->_add_MarkerReached(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaElement_adaptor::MarkerReached)->_remove_MarkerReached(token)); }
		} MarkerReached;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaElement_adaptor::MediaEnded)->_add_MediaEnded(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaElement_adaptor::MediaEnded)->_remove_MediaEnded(token)); }
		} MediaEnded;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<ExceptionRoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaElement_adaptor::MediaFailed)->_add_MediaFailed(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaElement_adaptor::MediaFailed)->_remove_MediaFailed(token)); }
		} MediaFailed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaElement_adaptor::MediaOpened)->_add_MediaOpened(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaElement_adaptor::MediaOpened)->_remove_MediaOpened(token)); }
		} MediaOpened;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Media::RateChangedRoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaElement_adaptor::RateChanged)->_add_RateChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaElement_adaptor::RateChanged)->_remove_RateChanged(token)); }
		} RateChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaElement_adaptor::SeekCompleted)->_add_SeekCompleted(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaElement_adaptor::SeekCompleted)->_remove_SeekCompleted(token)); }
		} SeekCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaElement_adaptor::VolumeChanged)->_add_VolumeChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaElement_adaptor::VolumeChanged)->_remove_VolumeChanged(token)); }
		} VolumeChanged;
	};
	void Stop() { hrcheck(X::get()->_Stop()); }
	void Play() { hrcheck(X::get()->_Play()); }
	void Pause() { hrcheck(X::get()->_Pause()); }
	Media::MediaCanPlayResponse CanPlayType(hstring_ref type) { Media::MediaCanPlayResponse returnValue; hrcheck(X::get()->_CanPlayType(type, &returnValue)); return returnValue; }
	void SetSource(pptr<Storage::Streams::IRandomAccessStream> stream, hstring_ref mimeType) { hrcheck(X::get()->_SetSource(stream, mimeType)); }
	hstring GetAudioStreamLanguage(pptr<Foundation::IReference<int>> index) { HSTRING returnValue; hrcheck(X::get()->_GetAudioStreamLanguage(to_abi(index), &returnValue)); return from_abi(returnValue); }
	void AddAudioEffect(hstring_ref effectID, bool effectOptional, pptr<Foundation::Collections::IPropertySet> effectConfiguration) { hrcheck(X::get()->_AddAudioEffect(effectID, effectOptional, effectConfiguration)); }
	void AddVideoEffect(hstring_ref effectID, bool effectOptional, pptr<Foundation::Collections::IPropertySet> effectConfiguration) { hrcheck(X::get()->_AddVideoEffect(effectID, effectOptional, effectConfiguration)); }
	void RemoveAllEffects() { hrcheck(X::get()->_RemoveAllEffects()); }
	IMediaElement_adaptor() {}
};
template<typename X> struct adapt<IMediaElement, X> : Windows::UI::Xaml::Controls::IMediaElement_adaptor<X> { typedef adapt IMediaElement; };
struct IMediaElement : IMediaElement_raw, generate<IMediaElement> {};

// IMediaElementStatics
struct IMediaElementStatics : IInspectable {
	virtual STDMETHODIMP _get_PosterSourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsMutedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsAudioOnlyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AutoPlayProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VolumeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BalanceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_NaturalVideoHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_NaturalVideoWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_NaturalDurationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PositionProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DownloadProgressProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BufferingProgressProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DownloadProgressOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CurrentStateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CanSeekProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CanPauseProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AudioStreamCountProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AudioStreamIndexProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlaybackRateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsLoopingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlayToSourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DefaultPlaybackRateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AspectRatioWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AspectRatioHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RealTimePlaybackProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AudioCategoryProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AudioDeviceTypeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ProtectionManagerProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_Stereo3DVideoPackingModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_Stereo3DVideoRenderModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsStereo3DVideoProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ActualStereo3DVideoPackingModeProperty(DependencyProperty* *value);
};

// IMediaElement2
struct IMediaElement2_raw : IInspectable {
	virtual STDMETHODIMP _get_AreTransportControlsEnabled(bool *value);
	virtual STDMETHODIMP _put_AreTransportControlsEnabled(bool value);
	virtual STDMETHODIMP _get_Stretch(Media::Stretch *value);
	virtual STDMETHODIMP _put_Stretch(Media::Stretch value);
	virtual STDMETHODIMP _get_IsFullWindow(bool *value);
	virtual STDMETHODIMP _put_IsFullWindow(bool value);
	virtual STDMETHODIMP _SetMediaStreamSource(Windows::Media::Core::IMediaSource* source);
	virtual STDMETHODIMP _get_PlayToPreferredSourceUri(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_PlayToPreferredSourceUri(Foundation::Uri* value);
};
template<typename X> struct IMediaElement2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaElement2_adaptor::AreTransportControlsEnabled)->_get_AreTransportControlsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaElement2_adaptor::AreTransportControlsEnabled)->_put_AreTransportControlsEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AreTransportControlsEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaElement2_adaptor::IsFullWindow)->_get_IsFullWindow(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaElement2_adaptor::IsFullWindow)->_put_IsFullWindow(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsFullWindow;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IMediaElement2_adaptor::PlayToPreferredSourceUri)->_get_PlayToPreferredSourceUri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IMediaElement2_adaptor::PlayToPreferredSourceUri)->_put_PlayToPreferredSourceUri(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} PlayToPreferredSourceUri;
		struct : property {
			Media::Stretch get() { Media::Stretch value; hrcheck(enc(&IMediaElement2_adaptor::Stretch)->_get_Stretch(&value)); return value; }
			Media::Stretch operator()() { return get(); }
			operator Media::Stretch () { return get(); }
			void put(Media::Stretch value) { hrcheck(enc(&IMediaElement2_adaptor::Stretch)->_put_Stretch(value)); }
			void operator=(Media::Stretch value) { put(value); }
			void operator()(Media::Stretch value) { put(value); }
		} Stretch;
	};
	void SetMediaStreamSource(pptr<Windows::Media::Core::IMediaSource> source) { hrcheck(X::get()->_SetMediaStreamSource(source)); }
	IMediaElement2_adaptor() {}
};
template<typename X> struct adapt<IMediaElement2, X> : Windows::UI::Xaml::Controls::IMediaElement2_adaptor<X> { typedef adapt IMediaElement2; };
struct IMediaElement2 : IMediaElement2_raw, generate<IMediaElement2> {};

// IMediaElementStatics2
struct IMediaElementStatics2 : IInspectable {
	virtual STDMETHODIMP _get_AreTransportControlsEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_StretchProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsFullWindowProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlayToPreferredSourceUriProperty(DependencyProperty* *value);
};

// IMediaElement3
struct IMediaElement3_raw : IInspectable {
	virtual STDMETHODIMP _get_TransportControls(MediaTransportControls* *value);
	virtual STDMETHODIMP _put_TransportControls(MediaTransportControls* value);
	virtual STDMETHODIMP _add_PartialMediaFailureDetected(Foundation::TypedEventHandler<MediaElement*, Media::PartialMediaFailureDetectedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PartialMediaFailureDetected(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _SetPlaybackSource(Windows::Media::Playback::IMediaPlaybackSource* source);
	virtual STDMETHODIMP _GetAsCastingSource(Windows::Media::Casting::CastingSource* *returnValue);
};
template<typename X> struct IMediaElement3_adaptor : X {
	union {
		struct : property {
			ptr<MediaTransportControls> get() { MediaTransportControls* value; hrcheck(enc(&IMediaElement3_adaptor::TransportControls)->_get_TransportControls(&value)); return from_abi(value); }
			ptr<MediaTransportControls> operator()() { return get(); }
			operator ptr<MediaTransportControls> () { return get(); }
			ptr<MediaTransportControls> operator->() { return get(); }
			void put(pptr<MediaTransportControls> value) { hrcheck(enc(&IMediaElement3_adaptor::TransportControls)->_put_TransportControls(value)); }
			void operator=(pptr<MediaTransportControls> value) { put(value); }
			void operator()(pptr<MediaTransportControls> value) { put(value); }
		} TransportControls;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MediaElement>, ptr<Media::PartialMediaFailureDetectedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMediaElement3_adaptor::PartialMediaFailureDetected)->_add_PartialMediaFailureDetected(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMediaElement3_adaptor::PartialMediaFailureDetected)->_remove_PartialMediaFailureDetected(token)); }
		} PartialMediaFailureDetected;
	};
	void SetPlaybackSource(pptr<Windows::Media::Playback::IMediaPlaybackSource> source) { hrcheck(X::get()->_SetPlaybackSource(source)); }
	ptr<Windows::Media::Casting::CastingSource> GetAsCastingSource() { Windows::Media::Casting::CastingSource* returnValue; hrcheck(X::get()->_GetAsCastingSource(&returnValue)); return from_abi(returnValue); }
	IMediaElement3_adaptor() {}
};
template<typename X> struct adapt<IMediaElement3, X> : Windows::UI::Xaml::Controls::IMediaElement3_adaptor<X> { typedef adapt IMediaElement3; };
struct IMediaElement3 : IMediaElement3_raw, generate<IMediaElement3> {};

// IMediaPlayerPresenter
struct IMediaPlayerPresenter_raw : IInspectable {
	virtual STDMETHODIMP _get_MediaPlayer(Windows::Media::Playback::MediaPlayer* *value);
	virtual STDMETHODIMP _put_MediaPlayer(Windows::Media::Playback::MediaPlayer* value);
	virtual STDMETHODIMP _get_Stretch(Media::Stretch *value);
	virtual STDMETHODIMP _put_Stretch(Media::Stretch value);
	virtual STDMETHODIMP _get_IsFullWindow(bool *value);
	virtual STDMETHODIMP _put_IsFullWindow(bool value);
};
template<typename X> struct IMediaPlayerPresenter_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaPlayerPresenter_adaptor::IsFullWindow)->_get_IsFullWindow(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaPlayerPresenter_adaptor::IsFullWindow)->_put_IsFullWindow(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsFullWindow;
		struct : property {
			ptr<Windows::Media::Playback::MediaPlayer> get() { Windows::Media::Playback::MediaPlayer* value; hrcheck(enc(&IMediaPlayerPresenter_adaptor::MediaPlayer)->_get_MediaPlayer(&value)); return from_abi(value); }
			ptr<Windows::Media::Playback::MediaPlayer> operator()() { return get(); }
			operator ptr<Windows::Media::Playback::MediaPlayer> () { return get(); }
			ptr<Windows::Media::Playback::MediaPlayer> operator->() { return get(); }
			void put(pptr<Windows::Media::Playback::MediaPlayer> value) { hrcheck(enc(&IMediaPlayerPresenter_adaptor::MediaPlayer)->_put_MediaPlayer(value)); }
			void operator=(pptr<Windows::Media::Playback::MediaPlayer> value) { put(value); }
			void operator()(pptr<Windows::Media::Playback::MediaPlayer> value) { put(value); }
		} MediaPlayer;
		struct : property {
			Media::Stretch get() { Media::Stretch value; hrcheck(enc(&IMediaPlayerPresenter_adaptor::Stretch)->_get_Stretch(&value)); return value; }
			Media::Stretch operator()() { return get(); }
			operator Media::Stretch () { return get(); }
			void put(Media::Stretch value) { hrcheck(enc(&IMediaPlayerPresenter_adaptor::Stretch)->_put_Stretch(value)); }
			void operator=(Media::Stretch value) { put(value); }
			void operator()(Media::Stretch value) { put(value); }
		} Stretch;
	};
	IMediaPlayerPresenter_adaptor() {}
};
template<typename X> struct adapt<IMediaPlayerPresenter, X> : Windows::UI::Xaml::Controls::IMediaPlayerPresenter_adaptor<X> { typedef adapt IMediaPlayerPresenter; };
struct IMediaPlayerPresenter : IMediaPlayerPresenter_raw, generate<IMediaPlayerPresenter> {};

// IMediaPlayerPresenterStatics
struct IMediaPlayerPresenterStatics : IInspectable {
	virtual STDMETHODIMP _get_MediaPlayerProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_StretchProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsFullWindowProperty(DependencyProperty* *value);
};

// IMediaPlayerPresenterFactory
struct IMediaPlayerPresenterFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, MediaPlayerPresenter* *instance);
};

// IWebView
struct IWebView_raw : IInspectable {
	virtual STDMETHODIMP _get_Source(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_Source(Foundation::Uri* value);
	virtual STDMETHODIMP _get_AllowedScriptNotifyUris(Foundation::Collections::IVector<Foundation::Uri*>* *value);
	virtual STDMETHODIMP _put_AllowedScriptNotifyUris(Foundation::Collections::IVector<Foundation::Uri*>* value);
	virtual STDMETHODIMP _get_DataTransferPackage(ApplicationModel::DataTransfer::DataPackage* *value);
	virtual STDMETHODIMP _add_LoadCompleted(Navigation::LoadCompletedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_LoadCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ScriptNotify(NotifyEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ScriptNotify(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_NavigationFailed(WebViewNavigationFailedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_NavigationFailed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _InvokeScript(HSTRING scriptName, unsigned argumentsSize, HSTRING *arguments, HSTRING *returnValue);
	virtual STDMETHODIMP _Navigate(Foundation::Uri* source);
	virtual STDMETHODIMP _NavigateToString(HSTRING text);
};
template<typename X> struct IWebView_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> get() { Foundation::Collections::IVector<Foundation::Uri*>* value; hrcheck(enc(&IWebView_adaptor::AllowedScriptNotifyUris)->_get_AllowedScriptNotifyUris(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> operator->() { return get(); }
			void put(pptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> value) { hrcheck(enc(&IWebView_adaptor::AllowedScriptNotifyUris)->_put_AllowedScriptNotifyUris(to_abi(value))); }
			void operator=(pptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> value) { put(to_abi(value)); }
		} AllowedScriptNotifyUris;
		struct : property {
			ptr<ApplicationModel::DataTransfer::DataPackage> get() { ApplicationModel::DataTransfer::DataPackage* value; hrcheck(enc(&IWebView_adaptor::DataTransferPackage)->_get_DataTransferPackage(&value)); return from_abi(value); }
			ptr<ApplicationModel::DataTransfer::DataPackage> operator()() { return get(); }
			operator ptr<ApplicationModel::DataTransfer::DataPackage> () { return get(); }
			ptr<ApplicationModel::DataTransfer::DataPackage> operator->() { return get(); }
		} DataTransferPackage;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IWebView_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IWebView_adaptor::Source)->_put_Source(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} Source;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Navigation::LoadCompletedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView_adaptor::LoadCompleted)->_add_LoadCompleted(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView_adaptor::LoadCompleted)->_remove_LoadCompleted(token)); }
		} LoadCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<WebViewNavigationFailedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView_adaptor::NavigationFailed)->_add_NavigationFailed(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView_adaptor::NavigationFailed)->_remove_NavigationFailed(token)); }
		} NavigationFailed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<NotifyEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView_adaptor::ScriptNotify)->_add_ScriptNotify(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView_adaptor::ScriptNotify)->_remove_ScriptNotify(token)); }
		} ScriptNotify;
	};
	hstring InvokeScript(hstring_ref scriptName, const szarray<hstring>& arguments) { HSTRING returnValue; hrcheck(X::get()->_InvokeScript(scriptName, arguments.size, to_abi(arguments.p), &returnValue)); return from_abi(returnValue); }
	void Navigate(pptr<Foundation::Uri> source) { hrcheck(X::get()->_Navigate(source)); }
	void NavigateToString(hstring_ref text) { hrcheck(X::get()->_NavigateToString(text)); }
	IWebView_adaptor() {}
};
template<typename X> struct adapt<IWebView, X> : Windows::UI::Xaml::Controls::IWebView_adaptor<X> { typedef adapt IWebView; };
struct IWebView : IWebView_raw, generate<IWebView> {};

// IWebViewStatics
struct IWebViewStatics : IInspectable {
	virtual STDMETHODIMP _get_AnyScriptNotifyUri(Foundation::Collections::IVector<Foundation::Uri*>* *value);
	virtual STDMETHODIMP _get_SourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AllowedScriptNotifyUrisProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DataTransferPackageProperty(DependencyProperty* *value);
};

// IWebView2
struct IWebView2_raw : IInspectable {
	virtual STDMETHODIMP _get_CanGoBack(bool *value);
	virtual STDMETHODIMP _get_CanGoForward(bool *value);
	virtual STDMETHODIMP _get_DocumentTitle(HSTRING *value);
	virtual STDMETHODIMP _add_NavigationStarting(Foundation::TypedEventHandler<WebView*, WebViewNavigationStartingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_NavigationStarting(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ContentLoading(Foundation::TypedEventHandler<WebView*, WebViewContentLoadingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ContentLoading(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DOMContentLoaded(Foundation::TypedEventHandler<WebView*, WebViewDOMContentLoadedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DOMContentLoaded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _GoForward();
	virtual STDMETHODIMP _GoBack();
	virtual STDMETHODIMP _Refresh();
	virtual STDMETHODIMP _Stop();
	virtual STDMETHODIMP _CapturePreviewToStreamAsync(Storage::Streams::IRandomAccessStream* stream, Foundation::IAsyncAction* *returnValue);
	virtual STDMETHODIMP _InvokeScriptAsync(HSTRING scriptName, Foundation::Collections::IIterable<HSTRING>* arguments, Foundation::IAsyncOperation<HSTRING>* *returnValue);
	virtual STDMETHODIMP _CaptureSelectedContentToDataPackageAsync(Foundation::IAsyncOperation<ApplicationModel::DataTransfer::DataPackage*>* *returnValue);
	virtual STDMETHODIMP _NavigateToLocalStreamUri(Foundation::Uri* source, Web::IUriToStreamResolver* streamResolver);
	virtual STDMETHODIMP _BuildLocalStreamUri(HSTRING contentIdentifier, HSTRING relativePath, Foundation::Uri* *returnValue);
	virtual STDMETHODIMP _get_DefaultBackgroundColor(Color *value);
	virtual STDMETHODIMP _put_DefaultBackgroundColor(Color value);
	virtual STDMETHODIMP _add_NavigationCompleted(Foundation::TypedEventHandler<WebView*, WebViewNavigationCompletedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_NavigationCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_FrameNavigationStarting(Foundation::TypedEventHandler<WebView*, WebViewNavigationStartingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_FrameNavigationStarting(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_FrameContentLoading(Foundation::TypedEventHandler<WebView*, WebViewContentLoadingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_FrameContentLoading(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_FrameDOMContentLoaded(Foundation::TypedEventHandler<WebView*, WebViewDOMContentLoadedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_FrameDOMContentLoaded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_FrameNavigationCompleted(Foundation::TypedEventHandler<WebView*, WebViewNavigationCompletedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_FrameNavigationCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_LongRunningScriptDetected(Foundation::TypedEventHandler<WebView*, WebViewLongRunningScriptDetectedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_LongRunningScriptDetected(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_UnsafeContentWarningDisplaying(Foundation::TypedEventHandler<WebView*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_UnsafeContentWarningDisplaying(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_UnviewableContentIdentified(Foundation::TypedEventHandler<WebView*, WebViewUnviewableContentIdentifiedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_UnviewableContentIdentified(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _NavigateWithHttpRequestMessage(Web::Http::HttpRequestMessage* requestMessage);
	virtual STDMETHODIMP _Focus(FocusState value, bool *returnValue);
};
template<typename X> struct IWebView2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IWebView2_adaptor::CanGoBack)->_get_CanGoBack(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanGoBack;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IWebView2_adaptor::CanGoForward)->_get_CanGoForward(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanGoForward;
		struct : property {
			Color get() { Color value; hrcheck(enc(&IWebView2_adaptor::DefaultBackgroundColor)->_get_DefaultBackgroundColor(&value)); return value; }
			Color operator()() { return get(); }
			operator Color () { return get(); }
			void put(const Color& value) { hrcheck(enc(&IWebView2_adaptor::DefaultBackgroundColor)->_put_DefaultBackgroundColor(value)); }
			void operator=(const Color& value) { put(value); }
			void operator()(const Color& value) { put(value); }
		} DefaultBackgroundColor;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IWebView2_adaptor::DocumentTitle)->_get_DocumentTitle(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DocumentTitle;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, ptr<WebViewContentLoadingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView2_adaptor::ContentLoading)->_add_ContentLoading(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView2_adaptor::ContentLoading)->_remove_ContentLoading(token)); }
		} ContentLoading;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, ptr<WebViewDOMContentLoadedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView2_adaptor::DOMContentLoaded)->_add_DOMContentLoaded(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView2_adaptor::DOMContentLoaded)->_remove_DOMContentLoaded(token)); }
		} DOMContentLoaded;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, ptr<WebViewContentLoadingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView2_adaptor::FrameContentLoading)->_add_FrameContentLoading(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView2_adaptor::FrameContentLoading)->_remove_FrameContentLoading(token)); }
		} FrameContentLoading;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, ptr<WebViewDOMContentLoadedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView2_adaptor::FrameDOMContentLoaded)->_add_FrameDOMContentLoaded(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView2_adaptor::FrameDOMContentLoaded)->_remove_FrameDOMContentLoaded(token)); }
		} FrameDOMContentLoaded;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, ptr<WebViewNavigationCompletedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView2_adaptor::FrameNavigationCompleted)->_add_FrameNavigationCompleted(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView2_adaptor::FrameNavigationCompleted)->_remove_FrameNavigationCompleted(token)); }
		} FrameNavigationCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, ptr<WebViewNavigationStartingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView2_adaptor::FrameNavigationStarting)->_add_FrameNavigationStarting(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView2_adaptor::FrameNavigationStarting)->_remove_FrameNavigationStarting(token)); }
		} FrameNavigationStarting;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, ptr<WebViewLongRunningScriptDetectedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView2_adaptor::LongRunningScriptDetected)->_add_LongRunningScriptDetected(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView2_adaptor::LongRunningScriptDetected)->_remove_LongRunningScriptDetected(token)); }
		} LongRunningScriptDetected;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, ptr<WebViewNavigationCompletedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView2_adaptor::NavigationCompleted)->_add_NavigationCompleted(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView2_adaptor::NavigationCompleted)->_remove_NavigationCompleted(token)); }
		} NavigationCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, ptr<WebViewNavigationStartingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView2_adaptor::NavigationStarting)->_add_NavigationStarting(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView2_adaptor::NavigationStarting)->_remove_NavigationStarting(token)); }
		} NavigationStarting;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView2_adaptor::UnsafeContentWarningDisplaying)->_add_UnsafeContentWarningDisplaying(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView2_adaptor::UnsafeContentWarningDisplaying)->_remove_UnsafeContentWarningDisplaying(token)); }
		} UnsafeContentWarningDisplaying;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, ptr<WebViewUnviewableContentIdentifiedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView2_adaptor::UnviewableContentIdentified)->_add_UnviewableContentIdentified(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView2_adaptor::UnviewableContentIdentified)->_remove_UnviewableContentIdentified(token)); }
		} UnviewableContentIdentified;
	};
	void GoForward() { hrcheck(X::get()->_GoForward()); }
	void GoBack() { hrcheck(X::get()->_GoBack()); }
	void Refresh() { hrcheck(X::get()->_Refresh()); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	ptr<Foundation::IAsyncAction> CapturePreviewToStreamAsync(pptr<Storage::Streams::IRandomAccessStream> stream) { Foundation::IAsyncAction* returnValue; hrcheck(X::get()->_CapturePreviewToStreamAsync(stream, &returnValue)); return from_abi(returnValue); }
	ptr<Foundation::IAsyncOperation<hstring>> InvokeScriptAsync(hstring_ref scriptName, pptr<Foundation::Collections::IIterable<hstring>> arguments) { Foundation::IAsyncOperation<HSTRING>* returnValue; hrcheck(X::get()->_InvokeScriptAsync(scriptName, to_abi(arguments), &returnValue)); return from_abi(returnValue); }
	ptr<Foundation::IAsyncOperation<ptr<ApplicationModel::DataTransfer::DataPackage>>> CaptureSelectedContentToDataPackageAsync() { Foundation::IAsyncOperation<ApplicationModel::DataTransfer::DataPackage*>* returnValue; hrcheck(X::get()->_CaptureSelectedContentToDataPackageAsync(&returnValue)); return from_abi(returnValue); }
	void NavigateToLocalStreamUri(pptr<Foundation::Uri> source, pptr<Web::IUriToStreamResolver> streamResolver) { hrcheck(X::get()->_NavigateToLocalStreamUri(source, streamResolver)); }
	ptr<Foundation::Uri> BuildLocalStreamUri(hstring_ref contentIdentifier, hstring_ref relativePath) { Foundation::Uri* returnValue; hrcheck(X::get()->_BuildLocalStreamUri(contentIdentifier, relativePath, &returnValue)); return from_abi(returnValue); }
	void NavigateWithHttpRequestMessage(pptr<Web::Http::HttpRequestMessage> requestMessage) { hrcheck(X::get()->_NavigateWithHttpRequestMessage(requestMessage)); }
	bool Focus(FocusState value) { bool returnValue; hrcheck(X::get()->_Focus(value, &returnValue)); return returnValue; }
	IWebView2_adaptor() {}
};
template<typename X> struct adapt<IWebView2, X> : Windows::UI::Xaml::Controls::IWebView2_adaptor<X> { typedef adapt IWebView2; };
struct IWebView2 : IWebView2_raw, generate<IWebView2> {};

// IWebViewStatics2
struct IWebViewStatics2 : IInspectable {
	virtual STDMETHODIMP _get_CanGoBackProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CanGoForwardProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DocumentTitleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DefaultBackgroundColorProperty(DependencyProperty* *value);
};

// IWebView3
struct IWebView3_raw : IInspectable {
	virtual STDMETHODIMP _get_ContainsFullScreenElement(bool *value);
	virtual STDMETHODIMP _add_ContainsFullScreenElementChanged(Foundation::TypedEventHandler<WebView*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ContainsFullScreenElementChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IWebView3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IWebView3_adaptor::ContainsFullScreenElement)->_get_ContainsFullScreenElement(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} ContainsFullScreenElement;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView3_adaptor::ContainsFullScreenElementChanged)->_add_ContainsFullScreenElementChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView3_adaptor::ContainsFullScreenElementChanged)->_remove_ContainsFullScreenElementChanged(token)); }
		} ContainsFullScreenElementChanged;
	};
	IWebView3_adaptor() {}
};
template<typename X> struct adapt<IWebView3, X> : Windows::UI::Xaml::Controls::IWebView3_adaptor<X> { typedef adapt IWebView3; };
struct IWebView3 : IWebView3_raw, generate<IWebView3> {};

// IWebViewStatics3
struct IWebViewStatics3 : IInspectable {
	virtual STDMETHODIMP _get_ContainsFullScreenElementProperty(DependencyProperty* *value);
};

// IWebView4
struct IWebView4_raw : IInspectable {
	virtual STDMETHODIMP _get_ExecutionMode(WebViewExecutionMode *value);
	virtual STDMETHODIMP _get_DeferredPermissionRequests(Foundation::Collections::IVector<WebViewDeferredPermissionRequest*>* *value);
	virtual STDMETHODIMP _get_Settings(WebViewSettings* *value);
	virtual STDMETHODIMP _add_UnsupportedUriSchemeIdentified(Foundation::TypedEventHandler<WebView*, WebViewUnsupportedUriSchemeIdentifiedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_UnsupportedUriSchemeIdentified(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_NewWindowRequested(Foundation::TypedEventHandler<WebView*, WebViewNewWindowRequestedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_NewWindowRequested(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PermissionRequested(Foundation::TypedEventHandler<WebView*, WebViewPermissionRequestedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PermissionRequested(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _AddWebAllowedObject(HSTRING name, IInspectable* pObject);
	virtual STDMETHODIMP _DeferredPermissionRequestById(unsigned id, WebViewDeferredPermissionRequest* *returnValue);
};
template<typename X> struct IWebView4_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<WebViewDeferredPermissionRequest>>> get() { Foundation::Collections::IVector<WebViewDeferredPermissionRequest*>* value; hrcheck(enc(&IWebView4_adaptor::DeferredPermissionRequests)->_get_DeferredPermissionRequests(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<WebViewDeferredPermissionRequest>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<WebViewDeferredPermissionRequest>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<WebViewDeferredPermissionRequest>>> operator->() { return get(); }
		} DeferredPermissionRequests;
		struct : property {
			WebViewExecutionMode get() { WebViewExecutionMode value; hrcheck(enc(&IWebView4_adaptor::ExecutionMode)->_get_ExecutionMode(&value)); return value; }
			WebViewExecutionMode operator()() { return get(); }
			operator WebViewExecutionMode () { return get(); }
		} ExecutionMode;
		struct : property {
			ptr<WebViewSettings> get() { WebViewSettings* value; hrcheck(enc(&IWebView4_adaptor::Settings)->_get_Settings(&value)); return from_abi(value); }
			ptr<WebViewSettings> operator()() { return get(); }
			operator ptr<WebViewSettings> () { return get(); }
			ptr<WebViewSettings> operator->() { return get(); }
		} Settings;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, ptr<WebViewNewWindowRequestedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView4_adaptor::NewWindowRequested)->_add_NewWindowRequested(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView4_adaptor::NewWindowRequested)->_remove_NewWindowRequested(token)); }
		} NewWindowRequested;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, ptr<WebViewPermissionRequestedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView4_adaptor::PermissionRequested)->_add_PermissionRequested(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView4_adaptor::PermissionRequested)->_remove_PermissionRequested(token)); }
		} PermissionRequested;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, ptr<WebViewUnsupportedUriSchemeIdentifiedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView4_adaptor::UnsupportedUriSchemeIdentified)->_add_UnsupportedUriSchemeIdentified(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView4_adaptor::UnsupportedUriSchemeIdentified)->_remove_UnsupportedUriSchemeIdentified(token)); }
		} UnsupportedUriSchemeIdentified;
	};
	void AddWebAllowedObject(hstring_ref name, object_ref pObject) { hrcheck(X::get()->_AddWebAllowedObject(name, pObject)); }
	ptr<WebViewDeferredPermissionRequest> DeferredPermissionRequestById(unsigned id) { WebViewDeferredPermissionRequest* returnValue; hrcheck(X::get()->_DeferredPermissionRequestById(id, &returnValue)); return from_abi(returnValue); }
	IWebView4_adaptor() {}
};
template<typename X> struct adapt<IWebView4, X> : Windows::UI::Xaml::Controls::IWebView4_adaptor<X> { typedef adapt IWebView4; };
struct IWebView4 : IWebView4_raw, generate<IWebView4> {};

// IWebViewStatics4
struct IWebViewStatics4 : IInspectable {
	virtual STDMETHODIMP _get_DefaultExecutionMode(WebViewExecutionMode *value);
	virtual STDMETHODIMP _ClearTemporaryWebDataAsync(Foundation::IAsyncAction* *returnValue);
};

// IWebViewFactory4
struct IWebViewFactory4 : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithExecutionMode(WebViewExecutionMode executionMode, WebView* *instance);
};

// IWebView5
struct IWebView5_raw : IInspectable {
	virtual STDMETHODIMP _get_XYFocusLeft(DependencyObject* *value);
	virtual STDMETHODIMP _put_XYFocusLeft(DependencyObject* value);
	virtual STDMETHODIMP _get_XYFocusRight(DependencyObject* *value);
	virtual STDMETHODIMP _put_XYFocusRight(DependencyObject* value);
	virtual STDMETHODIMP _get_XYFocusUp(DependencyObject* *value);
	virtual STDMETHODIMP _put_XYFocusUp(DependencyObject* value);
	virtual STDMETHODIMP _get_XYFocusDown(DependencyObject* *value);
	virtual STDMETHODIMP _put_XYFocusDown(DependencyObject* value);
};
template<typename X> struct IWebView5_adaptor : X {
	union {
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IWebView5_adaptor::XYFocusDown)->_get_XYFocusDown(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IWebView5_adaptor::XYFocusDown)->_put_XYFocusDown(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} XYFocusDown;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IWebView5_adaptor::XYFocusLeft)->_get_XYFocusLeft(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IWebView5_adaptor::XYFocusLeft)->_put_XYFocusLeft(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} XYFocusLeft;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IWebView5_adaptor::XYFocusRight)->_get_XYFocusRight(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IWebView5_adaptor::XYFocusRight)->_put_XYFocusRight(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} XYFocusRight;
		struct : property {
			ptr<DependencyObject> get() { DependencyObject* value; hrcheck(enc(&IWebView5_adaptor::XYFocusUp)->_get_XYFocusUp(&value)); return from_abi(value); }
			ptr<DependencyObject> operator()() { return get(); }
			operator ptr<DependencyObject> () { return get(); }
			ptr<DependencyObject> operator->() { return get(); }
			void put(pptr<DependencyObject> value) { hrcheck(enc(&IWebView5_adaptor::XYFocusUp)->_put_XYFocusUp(value)); }
			void operator=(pptr<DependencyObject> value) { put(value); }
			void operator()(pptr<DependencyObject> value) { put(value); }
		} XYFocusUp;
	};
	IWebView5_adaptor() {}
};
template<typename X> struct adapt<IWebView5, X> : Windows::UI::Xaml::Controls::IWebView5_adaptor<X> { typedef adapt IWebView5; };
struct IWebView5 : IWebView5_raw, generate<IWebView5> {};

// IWebViewStatics5
struct IWebViewStatics5 : IInspectable {
	virtual STDMETHODIMP _get_XYFocusLeftProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_XYFocusRightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_XYFocusUpProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_XYFocusDownProperty(DependencyProperty* *value);
};

// IWebView6
struct IWebView6_raw : IInspectable {
	virtual STDMETHODIMP _add_SeparateProcessLost(Foundation::TypedEventHandler<WebView*, WebViewSeparateProcessLostEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SeparateProcessLost(Foundation::EventRegistrationToken token);
};
template<typename X> struct IWebView6_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<WebView>, ptr<WebViewSeparateProcessLostEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IWebView6_adaptor::SeparateProcessLost)->_add_SeparateProcessLost(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IWebView6_adaptor::SeparateProcessLost)->_remove_SeparateProcessLost(token)); }
		} SeparateProcessLost;
	};
	IWebView6_adaptor() {}
};
template<typename X> struct adapt<IWebView6, X> : Windows::UI::Xaml::Controls::IWebView6_adaptor<X> { typedef adapt IWebView6; };
struct IWebView6 : IWebView6_raw, generate<IWebView6> {};

// IWebViewBrush
struct IWebViewBrush_raw : IInspectable {
	virtual STDMETHODIMP _get_SourceName(HSTRING *value);
	virtual STDMETHODIMP _put_SourceName(HSTRING value);
	virtual STDMETHODIMP _Redraw();
	virtual STDMETHODIMP _SetSource(WebView* source);
};
template<typename X> struct IWebViewBrush_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IWebViewBrush_adaptor::SourceName)->_get_SourceName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IWebViewBrush_adaptor::SourceName)->_put_SourceName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} SourceName;
	};
	void Redraw() { hrcheck(X::get()->_Redraw()); }
	void SetSource(pptr<WebView> source) { hrcheck(X::get()->_SetSource(source)); }
	IWebViewBrush_adaptor() {}
};
template<typename X> struct adapt<IWebViewBrush, X> : Windows::UI::Xaml::Controls::IWebViewBrush_adaptor<X> { typedef adapt IWebViewBrush; };
struct IWebViewBrush : IWebViewBrush_raw, generate<IWebViewBrush> {};

// IWebViewBrushStatics
struct IWebViewBrushStatics : IInspectable {
	virtual STDMETHODIMP _get_SourceNameProperty(DependencyProperty* *value);
};

// IAppBarSeparator
struct IAppBarSeparator : IInspectable, generate<IAppBarSeparator> {};

// IAppBarSeparatorStatics
struct IAppBarSeparatorStatics : IInspectable {
	virtual STDMETHODIMP _get_IsCompactProperty(DependencyProperty* *value);
};

// IAppBarSeparatorFactory
struct IAppBarSeparatorFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, AppBarSeparator* *instance);
};

// IAppBarSeparatorStatics3
struct IAppBarSeparatorStatics3 : IInspectable {
	virtual STDMETHODIMP _get_IsInOverflowProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DynamicOverflowOrderProperty(DependencyProperty* *value);
};

// IBitmapIcon
struct IBitmapIcon_raw : IInspectable {
	virtual STDMETHODIMP _get_UriSource(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_UriSource(Foundation::Uri* value);
};
template<typename X> struct IBitmapIcon_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IBitmapIcon_adaptor::UriSource)->_get_UriSource(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IBitmapIcon_adaptor::UriSource)->_put_UriSource(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} UriSource;
	};
	IBitmapIcon_adaptor() {}
};
template<typename X> struct adapt<IBitmapIcon, X> : Windows::UI::Xaml::Controls::IBitmapIcon_adaptor<X> { typedef adapt IBitmapIcon; };
struct IBitmapIcon : IBitmapIcon_raw, generate<IBitmapIcon> {};

// IBitmapIconStatics
struct IBitmapIconStatics : IInspectable {
	virtual STDMETHODIMP _get_UriSourceProperty(DependencyProperty* *value);
};

// IBitmapIconFactory
struct IBitmapIconFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, BitmapIcon* *instance);
};

// IBitmapIcon2
struct IBitmapIcon2_raw : IInspectable {
	virtual STDMETHODIMP _get_ShowAsMonochrome(bool *value);
	virtual STDMETHODIMP _put_ShowAsMonochrome(bool value);
};
template<typename X> struct IBitmapIcon2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBitmapIcon2_adaptor::ShowAsMonochrome)->_get_ShowAsMonochrome(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IBitmapIcon2_adaptor::ShowAsMonochrome)->_put_ShowAsMonochrome(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ShowAsMonochrome;
	};
	IBitmapIcon2_adaptor() {}
};
template<typename X> struct adapt<IBitmapIcon2, X> : Windows::UI::Xaml::Controls::IBitmapIcon2_adaptor<X> { typedef adapt IBitmapIcon2; };
struct IBitmapIcon2 : IBitmapIcon2_raw, generate<IBitmapIcon2> {};

// IBitmapIconStatics2
struct IBitmapIconStatics2 : IInspectable {
	virtual STDMETHODIMP _get_ShowAsMonochromeProperty(DependencyProperty* *value);
};

// ICalendarDatePicker
struct ICalendarDatePicker_raw : IInspectable {
	virtual STDMETHODIMP _get_Date(Foundation::IReference<Foundation::DateTime>* *value);
	virtual STDMETHODIMP _put_Date(Foundation::IReference<Foundation::DateTime>* value);
	virtual STDMETHODIMP _get_IsCalendarOpen(bool *value);
	virtual STDMETHODIMP _put_IsCalendarOpen(bool value);
	virtual STDMETHODIMP _get_DateFormat(HSTRING *value);
	virtual STDMETHODIMP _put_DateFormat(HSTRING value);
	virtual STDMETHODIMP _get_PlaceholderText(HSTRING *value);
	virtual STDMETHODIMP _put_PlaceholderText(HSTRING value);
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_CalendarViewStyle(Style* *value);
	virtual STDMETHODIMP _put_CalendarViewStyle(Style* value);
	virtual STDMETHODIMP _get_MinDate(Foundation::DateTime *value);
	virtual STDMETHODIMP _put_MinDate(Foundation::DateTime value);
	virtual STDMETHODIMP _get_MaxDate(Foundation::DateTime *value);
	virtual STDMETHODIMP _put_MaxDate(Foundation::DateTime value);
	virtual STDMETHODIMP _get_IsTodayHighlighted(bool *value);
	virtual STDMETHODIMP _put_IsTodayHighlighted(bool value);
	virtual STDMETHODIMP _get_DisplayMode(CalendarViewDisplayMode *value);
	virtual STDMETHODIMP _put_DisplayMode(CalendarViewDisplayMode value);
	virtual STDMETHODIMP _get_FirstDayOfWeek(Globalization::DayOfWeek *value);
	virtual STDMETHODIMP _put_FirstDayOfWeek(Globalization::DayOfWeek value);
	virtual STDMETHODIMP _get_DayOfWeekFormat(HSTRING *value);
	virtual STDMETHODIMP _put_DayOfWeekFormat(HSTRING value);
	virtual STDMETHODIMP _get_CalendarIdentifier(HSTRING *value);
	virtual STDMETHODIMP _put_CalendarIdentifier(HSTRING value);
	virtual STDMETHODIMP _get_IsOutOfScopeEnabled(bool *value);
	virtual STDMETHODIMP _put_IsOutOfScopeEnabled(bool value);
	virtual STDMETHODIMP _get_IsGroupLabelVisible(bool *value);
	virtual STDMETHODIMP _put_IsGroupLabelVisible(bool value);
	virtual STDMETHODIMP _add_CalendarViewDayItemChanging(CalendarViewDayItemChangingEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CalendarViewDayItemChanging(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DateChanged(Foundation::TypedEventHandler<CalendarDatePicker*, CalendarDatePickerDateChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DateChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Opened(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Opened(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Closed(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Closed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _SetDisplayDate(Foundation::DateTime date);
	virtual STDMETHODIMP _SetYearDecadeDisplayDimensions(int columns, int rows);
};
template<typename X> struct ICalendarDatePicker_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICalendarDatePicker_adaptor::CalendarIdentifier)->_get_CalendarIdentifier(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICalendarDatePicker_adaptor::CalendarIdentifier)->_put_CalendarIdentifier(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} CalendarIdentifier;
		struct : property {
			ptr<Style> get() { Style* value; hrcheck(enc(&ICalendarDatePicker_adaptor::CalendarViewStyle)->_get_CalendarViewStyle(&value)); return from_abi(value); }
			ptr<Style> operator()() { return get(); }
			operator ptr<Style> () { return get(); }
			ptr<Style> operator->() { return get(); }
			void put(pptr<Style> value) { hrcheck(enc(&ICalendarDatePicker_adaptor::CalendarViewStyle)->_put_CalendarViewStyle(value)); }
			void operator=(pptr<Style> value) { put(value); }
			void operator()(pptr<Style> value) { put(value); }
		} CalendarViewStyle;
		struct : property {
			ptr<Foundation::IReference<Foundation::DateTime>> get() { Foundation::IReference<Foundation::DateTime>* value; hrcheck(enc(&ICalendarDatePicker_adaptor::Date)->_get_Date(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<Foundation::DateTime>> value) { hrcheck(enc(&ICalendarDatePicker_adaptor::Date)->_put_Date(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<Foundation::DateTime>> value) { put(to_abi(value)); }
		} Date;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICalendarDatePicker_adaptor::DateFormat)->_get_DateFormat(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICalendarDatePicker_adaptor::DateFormat)->_put_DateFormat(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DateFormat;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICalendarDatePicker_adaptor::DayOfWeekFormat)->_get_DayOfWeekFormat(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICalendarDatePicker_adaptor::DayOfWeekFormat)->_put_DayOfWeekFormat(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DayOfWeekFormat;
		struct : property {
			CalendarViewDisplayMode get() { CalendarViewDisplayMode value; hrcheck(enc(&ICalendarDatePicker_adaptor::DisplayMode)->_get_DisplayMode(&value)); return value; }
			CalendarViewDisplayMode operator()() { return get(); }
			operator CalendarViewDisplayMode () { return get(); }
			void put(CalendarViewDisplayMode value) { hrcheck(enc(&ICalendarDatePicker_adaptor::DisplayMode)->_put_DisplayMode(value)); }
			void operator=(CalendarViewDisplayMode value) { put(value); }
			void operator()(CalendarViewDisplayMode value) { put(value); }
		} DisplayMode;
		struct : property {
			Globalization::DayOfWeek get() { Globalization::DayOfWeek value; hrcheck(enc(&ICalendarDatePicker_adaptor::FirstDayOfWeek)->_get_FirstDayOfWeek(&value)); return value; }
			Globalization::DayOfWeek operator()() { return get(); }
			operator Globalization::DayOfWeek () { return get(); }
			void put(Globalization::DayOfWeek value) { hrcheck(enc(&ICalendarDatePicker_adaptor::FirstDayOfWeek)->_put_FirstDayOfWeek(value)); }
			void operator=(Globalization::DayOfWeek value) { put(value); }
			void operator()(Globalization::DayOfWeek value) { put(value); }
		} FirstDayOfWeek;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ICalendarDatePicker_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&ICalendarDatePicker_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&ICalendarDatePicker_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&ICalendarDatePicker_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICalendarDatePicker_adaptor::IsCalendarOpen)->_get_IsCalendarOpen(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICalendarDatePicker_adaptor::IsCalendarOpen)->_put_IsCalendarOpen(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsCalendarOpen;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICalendarDatePicker_adaptor::IsGroupLabelVisible)->_get_IsGroupLabelVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICalendarDatePicker_adaptor::IsGroupLabelVisible)->_put_IsGroupLabelVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsGroupLabelVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICalendarDatePicker_adaptor::IsOutOfScopeEnabled)->_get_IsOutOfScopeEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICalendarDatePicker_adaptor::IsOutOfScopeEnabled)->_put_IsOutOfScopeEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsOutOfScopeEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICalendarDatePicker_adaptor::IsTodayHighlighted)->_get_IsTodayHighlighted(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICalendarDatePicker_adaptor::IsTodayHighlighted)->_put_IsTodayHighlighted(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTodayHighlighted;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&ICalendarDatePicker_adaptor::MaxDate)->_get_MaxDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
			void put(const Foundation::DateTime& value) { hrcheck(enc(&ICalendarDatePicker_adaptor::MaxDate)->_put_MaxDate(value)); }
			void operator=(const Foundation::DateTime& value) { put(value); }
			void operator()(const Foundation::DateTime& value) { put(value); }
		} MaxDate;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&ICalendarDatePicker_adaptor::MinDate)->_get_MinDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
			void put(const Foundation::DateTime& value) { hrcheck(enc(&ICalendarDatePicker_adaptor::MinDate)->_put_MinDate(value)); }
			void operator=(const Foundation::DateTime& value) { put(value); }
			void operator()(const Foundation::DateTime& value) { put(value); }
		} MinDate;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICalendarDatePicker_adaptor::PlaceholderText)->_get_PlaceholderText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICalendarDatePicker_adaptor::PlaceholderText)->_put_PlaceholderText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PlaceholderText;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<CalendarViewDayItemChangingEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICalendarDatePicker_adaptor::CalendarViewDayItemChanging)->_add_CalendarViewDayItemChanging(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICalendarDatePicker_adaptor::CalendarViewDayItemChanging)->_remove_CalendarViewDayItemChanging(token)); }
		} CalendarViewDayItemChanging;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICalendarDatePicker_adaptor::Closed)->_add_Closed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICalendarDatePicker_adaptor::Closed)->_remove_Closed(token)); }
		} Closed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<CalendarDatePicker>, ptr<CalendarDatePickerDateChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICalendarDatePicker_adaptor::DateChanged)->_add_DateChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICalendarDatePicker_adaptor::DateChanged)->_remove_DateChanged(token)); }
		} DateChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICalendarDatePicker_adaptor::Opened)->_add_Opened(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICalendarDatePicker_adaptor::Opened)->_remove_Opened(token)); }
		} Opened;
	};
	void SetDisplayDate(const Foundation::DateTime& date) { hrcheck(X::get()->_SetDisplayDate(date)); }
	void SetYearDecadeDisplayDimensions(int columns, int rows) { hrcheck(X::get()->_SetYearDecadeDisplayDimensions(columns, rows)); }
	ICalendarDatePicker_adaptor() {}
};
template<typename X> struct adapt<ICalendarDatePicker, X> : Windows::UI::Xaml::Controls::ICalendarDatePicker_adaptor<X> { typedef adapt ICalendarDatePicker; };
struct ICalendarDatePicker : ICalendarDatePicker_raw, generate<ICalendarDatePicker> {};

// ICalendarDatePickerStatics
struct ICalendarDatePickerStatics : IInspectable {
	virtual STDMETHODIMP _get_DateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsCalendarOpenProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DateFormatProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlaceholderTextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CalendarViewStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinDateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxDateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsTodayHighlightedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DisplayModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FirstDayOfWeekProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DayOfWeekFormatProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CalendarIdentifierProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsOutOfScopeEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsGroupLabelVisibleProperty(DependencyProperty* *value);
};

// ICalendarDatePickerFactory
struct ICalendarDatePickerFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, CalendarDatePicker* *instance);
};

// ICalendarDatePicker2
struct ICalendarDatePicker2_raw : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayMode(Controls::LightDismissOverlayMode *value);
	virtual STDMETHODIMP _put_LightDismissOverlayMode(Controls::LightDismissOverlayMode value);
};
template<typename X> struct ICalendarDatePicker2_adaptor : X {
	union {
		struct : property {
			Controls::LightDismissOverlayMode get() { Controls::LightDismissOverlayMode value; hrcheck(enc(&ICalendarDatePicker2_adaptor::LightDismissOverlayMode)->_get_LightDismissOverlayMode(&value)); return value; }
			Controls::LightDismissOverlayMode operator()() { return get(); }
			operator Controls::LightDismissOverlayMode () { return get(); }
			void put(Controls::LightDismissOverlayMode value) { hrcheck(enc(&ICalendarDatePicker2_adaptor::LightDismissOverlayMode)->_put_LightDismissOverlayMode(value)); }
			void operator=(Controls::LightDismissOverlayMode value) { put(value); }
			void operator()(Controls::LightDismissOverlayMode value) { put(value); }
		} LightDismissOverlayMode;
	};
	ICalendarDatePicker2_adaptor() {}
};
template<typename X> struct adapt<ICalendarDatePicker2, X> : Windows::UI::Xaml::Controls::ICalendarDatePicker2_adaptor<X> { typedef adapt ICalendarDatePicker2; };
struct ICalendarDatePicker2 : ICalendarDatePicker2_raw, generate<ICalendarDatePicker2> {};

// ICalendarDatePickerStatics2
struct ICalendarDatePickerStatics2 : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayModeProperty(DependencyProperty* *value);
};

// ICalendarView
struct ICalendarView_raw : IInspectable {
	virtual STDMETHODIMP _get_CalendarIdentifier(HSTRING *value);
	virtual STDMETHODIMP _put_CalendarIdentifier(HSTRING value);
	virtual STDMETHODIMP _get_DayOfWeekFormat(HSTRING *value);
	virtual STDMETHODIMP _put_DayOfWeekFormat(HSTRING value);
	virtual STDMETHODIMP _get_IsGroupLabelVisible(bool *value);
	virtual STDMETHODIMP _put_IsGroupLabelVisible(bool value);
	virtual STDMETHODIMP _get_DisplayMode(CalendarViewDisplayMode *value);
	virtual STDMETHODIMP _put_DisplayMode(CalendarViewDisplayMode value);
	virtual STDMETHODIMP _get_FirstDayOfWeek(Globalization::DayOfWeek *value);
	virtual STDMETHODIMP _put_FirstDayOfWeek(Globalization::DayOfWeek value);
	virtual STDMETHODIMP _get_IsOutOfScopeEnabled(bool *value);
	virtual STDMETHODIMP _put_IsOutOfScopeEnabled(bool value);
	virtual STDMETHODIMP _get_IsTodayHighlighted(bool *value);
	virtual STDMETHODIMP _put_IsTodayHighlighted(bool value);
	virtual STDMETHODIMP _get_MaxDate(Foundation::DateTime *value);
	virtual STDMETHODIMP _put_MaxDate(Foundation::DateTime value);
	virtual STDMETHODIMP _get_MinDate(Foundation::DateTime *value);
	virtual STDMETHODIMP _put_MinDate(Foundation::DateTime value);
	virtual STDMETHODIMP _get_NumberOfWeeksInView(int *value);
	virtual STDMETHODIMP _put_NumberOfWeeksInView(int value);
	virtual STDMETHODIMP _get_SelectedDates(Foundation::Collections::IVector<Foundation::DateTime>* *value);
	virtual STDMETHODIMP _get_SelectionMode(CalendarViewSelectionMode *value);
	virtual STDMETHODIMP _put_SelectionMode(CalendarViewSelectionMode value);
	virtual STDMETHODIMP _get_TemplateSettings(Primitives::CalendarViewTemplateSettings* *value);
	virtual STDMETHODIMP _get_FocusBorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_FocusBorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_SelectedHoverBorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_SelectedHoverBorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_SelectedPressedBorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_SelectedPressedBorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_SelectedBorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_SelectedBorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_HoverBorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_HoverBorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_PressedBorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_PressedBorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_CalendarItemBorderBrush(Media::Brush* *value);
	virtual STDMETHODIMP _put_CalendarItemBorderBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_OutOfScopeBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_OutOfScopeBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_CalendarItemBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_CalendarItemBackground(Media::Brush* value);
	virtual STDMETHODIMP _get_PressedForeground(Media::Brush* *value);
	virtual STDMETHODIMP _put_PressedForeground(Media::Brush* value);
	virtual STDMETHODIMP _get_TodayForeground(Media::Brush* *value);
	virtual STDMETHODIMP _put_TodayForeground(Media::Brush* value);
	virtual STDMETHODIMP _get_BlackoutForeground(Media::Brush* *value);
	virtual STDMETHODIMP _put_BlackoutForeground(Media::Brush* value);
	virtual STDMETHODIMP _get_SelectedForeground(Media::Brush* *value);
	virtual STDMETHODIMP _put_SelectedForeground(Media::Brush* value);
	virtual STDMETHODIMP _get_OutOfScopeForeground(Media::Brush* *value);
	virtual STDMETHODIMP _put_OutOfScopeForeground(Media::Brush* value);
	virtual STDMETHODIMP _get_CalendarItemForeground(Media::Brush* *value);
	virtual STDMETHODIMP _put_CalendarItemForeground(Media::Brush* value);
	virtual STDMETHODIMP _get_DayItemFontFamily(Media::FontFamily* *value);
	virtual STDMETHODIMP _put_DayItemFontFamily(Media::FontFamily* value);
	virtual STDMETHODIMP _get_DayItemFontSize(double *value);
	virtual STDMETHODIMP _put_DayItemFontSize(double value);
	virtual STDMETHODIMP _get_DayItemFontStyle(Text::FontStyle *value);
	virtual STDMETHODIMP _put_DayItemFontStyle(Text::FontStyle value);
	virtual STDMETHODIMP _get_DayItemFontWeight(Text::FontWeight *value);
	virtual STDMETHODIMP _put_DayItemFontWeight(Text::FontWeight value);
	virtual STDMETHODIMP _get_TodayFontWeight(Text::FontWeight *value);
	virtual STDMETHODIMP _put_TodayFontWeight(Text::FontWeight value);
	virtual STDMETHODIMP _get_FirstOfMonthLabelFontFamily(Media::FontFamily* *value);
	virtual STDMETHODIMP _put_FirstOfMonthLabelFontFamily(Media::FontFamily* value);
	virtual STDMETHODIMP _get_FirstOfMonthLabelFontSize(double *value);
	virtual STDMETHODIMP _put_FirstOfMonthLabelFontSize(double value);
	virtual STDMETHODIMP _get_FirstOfMonthLabelFontStyle(Text::FontStyle *value);
	virtual STDMETHODIMP _put_FirstOfMonthLabelFontStyle(Text::FontStyle value);
	virtual STDMETHODIMP _get_FirstOfMonthLabelFontWeight(Text::FontWeight *value);
	virtual STDMETHODIMP _put_FirstOfMonthLabelFontWeight(Text::FontWeight value);
	virtual STDMETHODIMP _get_MonthYearItemFontFamily(Media::FontFamily* *value);
	virtual STDMETHODIMP _put_MonthYearItemFontFamily(Media::FontFamily* value);
	virtual STDMETHODIMP _get_MonthYearItemFontSize(double *value);
	virtual STDMETHODIMP _put_MonthYearItemFontSize(double value);
	virtual STDMETHODIMP _get_MonthYearItemFontStyle(Text::FontStyle *value);
	virtual STDMETHODIMP _put_MonthYearItemFontStyle(Text::FontStyle value);
	virtual STDMETHODIMP _get_MonthYearItemFontWeight(Text::FontWeight *value);
	virtual STDMETHODIMP _put_MonthYearItemFontWeight(Text::FontWeight value);
	virtual STDMETHODIMP _get_FirstOfYearDecadeLabelFontFamily(Media::FontFamily* *value);
	virtual STDMETHODIMP _put_FirstOfYearDecadeLabelFontFamily(Media::FontFamily* value);
	virtual STDMETHODIMP _get_FirstOfYearDecadeLabelFontSize(double *value);
	virtual STDMETHODIMP _put_FirstOfYearDecadeLabelFontSize(double value);
	virtual STDMETHODIMP _get_FirstOfYearDecadeLabelFontStyle(Text::FontStyle *value);
	virtual STDMETHODIMP _put_FirstOfYearDecadeLabelFontStyle(Text::FontStyle value);
	virtual STDMETHODIMP _get_FirstOfYearDecadeLabelFontWeight(Text::FontWeight *value);
	virtual STDMETHODIMP _put_FirstOfYearDecadeLabelFontWeight(Text::FontWeight value);
	virtual STDMETHODIMP _get_HorizontalDayItemAlignment(HorizontalAlignment *value);
	virtual STDMETHODIMP _put_HorizontalDayItemAlignment(HorizontalAlignment value);
	virtual STDMETHODIMP _get_VerticalDayItemAlignment(VerticalAlignment *value);
	virtual STDMETHODIMP _put_VerticalDayItemAlignment(VerticalAlignment value);
	virtual STDMETHODIMP _get_HorizontalFirstOfMonthLabelAlignment(HorizontalAlignment *value);
	virtual STDMETHODIMP _put_HorizontalFirstOfMonthLabelAlignment(HorizontalAlignment value);
	virtual STDMETHODIMP _get_VerticalFirstOfMonthLabelAlignment(VerticalAlignment *value);
	virtual STDMETHODIMP _put_VerticalFirstOfMonthLabelAlignment(VerticalAlignment value);
	virtual STDMETHODIMP _get_CalendarItemBorderThickness(Thickness *value);
	virtual STDMETHODIMP _put_CalendarItemBorderThickness(Thickness value);
	virtual STDMETHODIMP _get_CalendarViewDayItemStyle(Style* *value);
	virtual STDMETHODIMP _put_CalendarViewDayItemStyle(Style* value);
	virtual STDMETHODIMP _add_CalendarViewDayItemChanging(Foundation::TypedEventHandler<CalendarView*, CalendarViewDayItemChangingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CalendarViewDayItemChanging(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_SelectedDatesChanged(Foundation::TypedEventHandler<CalendarView*, CalendarViewSelectedDatesChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SelectedDatesChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _SetDisplayDate(Foundation::DateTime date);
	virtual STDMETHODIMP _SetYearDecadeDisplayDimensions(int columns, int rows);
};
template<typename X> struct ICalendarView_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ICalendarView_adaptor::BlackoutForeground)->_get_BlackoutForeground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ICalendarView_adaptor::BlackoutForeground)->_put_BlackoutForeground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} BlackoutForeground;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICalendarView_adaptor::CalendarIdentifier)->_get_CalendarIdentifier(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICalendarView_adaptor::CalendarIdentifier)->_put_CalendarIdentifier(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} CalendarIdentifier;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ICalendarView_adaptor::CalendarItemBackground)->_get_CalendarItemBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ICalendarView_adaptor::CalendarItemBackground)->_put_CalendarItemBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} CalendarItemBackground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ICalendarView_adaptor::CalendarItemBorderBrush)->_get_CalendarItemBorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ICalendarView_adaptor::CalendarItemBorderBrush)->_put_CalendarItemBorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} CalendarItemBorderBrush;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&ICalendarView_adaptor::CalendarItemBorderThickness)->_get_CalendarItemBorderThickness(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&ICalendarView_adaptor::CalendarItemBorderThickness)->_put_CalendarItemBorderThickness(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} CalendarItemBorderThickness;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ICalendarView_adaptor::CalendarItemForeground)->_get_CalendarItemForeground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ICalendarView_adaptor::CalendarItemForeground)->_put_CalendarItemForeground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} CalendarItemForeground;
		struct : property {
			ptr<Style> get() { Style* value; hrcheck(enc(&ICalendarView_adaptor::CalendarViewDayItemStyle)->_get_CalendarViewDayItemStyle(&value)); return from_abi(value); }
			ptr<Style> operator()() { return get(); }
			operator ptr<Style> () { return get(); }
			ptr<Style> operator->() { return get(); }
			void put(pptr<Style> value) { hrcheck(enc(&ICalendarView_adaptor::CalendarViewDayItemStyle)->_put_CalendarViewDayItemStyle(value)); }
			void operator=(pptr<Style> value) { put(value); }
			void operator()(pptr<Style> value) { put(value); }
		} CalendarViewDayItemStyle;
		struct : property {
			ptr<Media::FontFamily> get() { Media::FontFamily* value; hrcheck(enc(&ICalendarView_adaptor::DayItemFontFamily)->_get_DayItemFontFamily(&value)); return from_abi(value); }
			ptr<Media::FontFamily> operator()() { return get(); }
			operator ptr<Media::FontFamily> () { return get(); }
			ptr<Media::FontFamily> operator->() { return get(); }
			void put(pptr<Media::FontFamily> value) { hrcheck(enc(&ICalendarView_adaptor::DayItemFontFamily)->_put_DayItemFontFamily(value)); }
			void operator=(pptr<Media::FontFamily> value) { put(value); }
			void operator()(pptr<Media::FontFamily> value) { put(value); }
		} DayItemFontFamily;
		struct : property {
			double get() { double value; hrcheck(enc(&ICalendarView_adaptor::DayItemFontSize)->_get_DayItemFontSize(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ICalendarView_adaptor::DayItemFontSize)->_put_DayItemFontSize(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} DayItemFontSize;
		struct : property {
			Text::FontStyle get() { Text::FontStyle value; hrcheck(enc(&ICalendarView_adaptor::DayItemFontStyle)->_get_DayItemFontStyle(&value)); return value; }
			Text::FontStyle operator()() { return get(); }
			operator Text::FontStyle () { return get(); }
			void put(Text::FontStyle value) { hrcheck(enc(&ICalendarView_adaptor::DayItemFontStyle)->_put_DayItemFontStyle(value)); }
			void operator=(Text::FontStyle value) { put(value); }
			void operator()(Text::FontStyle value) { put(value); }
		} DayItemFontStyle;
		struct : property {
			Text::FontWeight get() { Text::FontWeight value; hrcheck(enc(&ICalendarView_adaptor::DayItemFontWeight)->_get_DayItemFontWeight(&value)); return value; }
			Text::FontWeight operator()() { return get(); }
			operator Text::FontWeight () { return get(); }
			void put(const Text::FontWeight& value) { hrcheck(enc(&ICalendarView_adaptor::DayItemFontWeight)->_put_DayItemFontWeight(value)); }
			void operator=(const Text::FontWeight& value) { put(value); }
			void operator()(const Text::FontWeight& value) { put(value); }
		} DayItemFontWeight;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICalendarView_adaptor::DayOfWeekFormat)->_get_DayOfWeekFormat(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICalendarView_adaptor::DayOfWeekFormat)->_put_DayOfWeekFormat(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DayOfWeekFormat;
		struct : property {
			CalendarViewDisplayMode get() { CalendarViewDisplayMode value; hrcheck(enc(&ICalendarView_adaptor::DisplayMode)->_get_DisplayMode(&value)); return value; }
			CalendarViewDisplayMode operator()() { return get(); }
			operator CalendarViewDisplayMode () { return get(); }
			void put(CalendarViewDisplayMode value) { hrcheck(enc(&ICalendarView_adaptor::DisplayMode)->_put_DisplayMode(value)); }
			void operator=(CalendarViewDisplayMode value) { put(value); }
			void operator()(CalendarViewDisplayMode value) { put(value); }
		} DisplayMode;
		struct : property {
			Globalization::DayOfWeek get() { Globalization::DayOfWeek value; hrcheck(enc(&ICalendarView_adaptor::FirstDayOfWeek)->_get_FirstDayOfWeek(&value)); return value; }
			Globalization::DayOfWeek operator()() { return get(); }
			operator Globalization::DayOfWeek () { return get(); }
			void put(Globalization::DayOfWeek value) { hrcheck(enc(&ICalendarView_adaptor::FirstDayOfWeek)->_put_FirstDayOfWeek(value)); }
			void operator=(Globalization::DayOfWeek value) { put(value); }
			void operator()(Globalization::DayOfWeek value) { put(value); }
		} FirstDayOfWeek;
		struct : property {
			ptr<Media::FontFamily> get() { Media::FontFamily* value; hrcheck(enc(&ICalendarView_adaptor::FirstOfMonthLabelFontFamily)->_get_FirstOfMonthLabelFontFamily(&value)); return from_abi(value); }
			ptr<Media::FontFamily> operator()() { return get(); }
			operator ptr<Media::FontFamily> () { return get(); }
			ptr<Media::FontFamily> operator->() { return get(); }
			void put(pptr<Media::FontFamily> value) { hrcheck(enc(&ICalendarView_adaptor::FirstOfMonthLabelFontFamily)->_put_FirstOfMonthLabelFontFamily(value)); }
			void operator=(pptr<Media::FontFamily> value) { put(value); }
			void operator()(pptr<Media::FontFamily> value) { put(value); }
		} FirstOfMonthLabelFontFamily;
		struct : property {
			double get() { double value; hrcheck(enc(&ICalendarView_adaptor::FirstOfMonthLabelFontSize)->_get_FirstOfMonthLabelFontSize(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ICalendarView_adaptor::FirstOfMonthLabelFontSize)->_put_FirstOfMonthLabelFontSize(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FirstOfMonthLabelFontSize;
		struct : property {
			Text::FontStyle get() { Text::FontStyle value; hrcheck(enc(&ICalendarView_adaptor::FirstOfMonthLabelFontStyle)->_get_FirstOfMonthLabelFontStyle(&value)); return value; }
			Text::FontStyle operator()() { return get(); }
			operator Text::FontStyle () { return get(); }
			void put(Text::FontStyle value) { hrcheck(enc(&ICalendarView_adaptor::FirstOfMonthLabelFontStyle)->_put_FirstOfMonthLabelFontStyle(value)); }
			void operator=(Text::FontStyle value) { put(value); }
			void operator()(Text::FontStyle value) { put(value); }
		} FirstOfMonthLabelFontStyle;
		struct : property {
			Text::FontWeight get() { Text::FontWeight value; hrcheck(enc(&ICalendarView_adaptor::FirstOfMonthLabelFontWeight)->_get_FirstOfMonthLabelFontWeight(&value)); return value; }
			Text::FontWeight operator()() { return get(); }
			operator Text::FontWeight () { return get(); }
			void put(const Text::FontWeight& value) { hrcheck(enc(&ICalendarView_adaptor::FirstOfMonthLabelFontWeight)->_put_FirstOfMonthLabelFontWeight(value)); }
			void operator=(const Text::FontWeight& value) { put(value); }
			void operator()(const Text::FontWeight& value) { put(value); }
		} FirstOfMonthLabelFontWeight;
		struct : property {
			ptr<Media::FontFamily> get() { Media::FontFamily* value; hrcheck(enc(&ICalendarView_adaptor::FirstOfYearDecadeLabelFontFamily)->_get_FirstOfYearDecadeLabelFontFamily(&value)); return from_abi(value); }
			ptr<Media::FontFamily> operator()() { return get(); }
			operator ptr<Media::FontFamily> () { return get(); }
			ptr<Media::FontFamily> operator->() { return get(); }
			void put(pptr<Media::FontFamily> value) { hrcheck(enc(&ICalendarView_adaptor::FirstOfYearDecadeLabelFontFamily)->_put_FirstOfYearDecadeLabelFontFamily(value)); }
			void operator=(pptr<Media::FontFamily> value) { put(value); }
			void operator()(pptr<Media::FontFamily> value) { put(value); }
		} FirstOfYearDecadeLabelFontFamily;
		struct : property {
			double get() { double value; hrcheck(enc(&ICalendarView_adaptor::FirstOfYearDecadeLabelFontSize)->_get_FirstOfYearDecadeLabelFontSize(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ICalendarView_adaptor::FirstOfYearDecadeLabelFontSize)->_put_FirstOfYearDecadeLabelFontSize(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FirstOfYearDecadeLabelFontSize;
		struct : property {
			Text::FontStyle get() { Text::FontStyle value; hrcheck(enc(&ICalendarView_adaptor::FirstOfYearDecadeLabelFontStyle)->_get_FirstOfYearDecadeLabelFontStyle(&value)); return value; }
			Text::FontStyle operator()() { return get(); }
			operator Text::FontStyle () { return get(); }
			void put(Text::FontStyle value) { hrcheck(enc(&ICalendarView_adaptor::FirstOfYearDecadeLabelFontStyle)->_put_FirstOfYearDecadeLabelFontStyle(value)); }
			void operator=(Text::FontStyle value) { put(value); }
			void operator()(Text::FontStyle value) { put(value); }
		} FirstOfYearDecadeLabelFontStyle;
		struct : property {
			Text::FontWeight get() { Text::FontWeight value; hrcheck(enc(&ICalendarView_adaptor::FirstOfYearDecadeLabelFontWeight)->_get_FirstOfYearDecadeLabelFontWeight(&value)); return value; }
			Text::FontWeight operator()() { return get(); }
			operator Text::FontWeight () { return get(); }
			void put(const Text::FontWeight& value) { hrcheck(enc(&ICalendarView_adaptor::FirstOfYearDecadeLabelFontWeight)->_put_FirstOfYearDecadeLabelFontWeight(value)); }
			void operator=(const Text::FontWeight& value) { put(value); }
			void operator()(const Text::FontWeight& value) { put(value); }
		} FirstOfYearDecadeLabelFontWeight;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ICalendarView_adaptor::FocusBorderBrush)->_get_FocusBorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ICalendarView_adaptor::FocusBorderBrush)->_put_FocusBorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} FocusBorderBrush;
		struct : property {
			HorizontalAlignment get() { HorizontalAlignment value; hrcheck(enc(&ICalendarView_adaptor::HorizontalDayItemAlignment)->_get_HorizontalDayItemAlignment(&value)); return value; }
			HorizontalAlignment operator()() { return get(); }
			operator HorizontalAlignment () { return get(); }
			void put(HorizontalAlignment value) { hrcheck(enc(&ICalendarView_adaptor::HorizontalDayItemAlignment)->_put_HorizontalDayItemAlignment(value)); }
			void operator=(HorizontalAlignment value) { put(value); }
			void operator()(HorizontalAlignment value) { put(value); }
		} HorizontalDayItemAlignment;
		struct : property {
			HorizontalAlignment get() { HorizontalAlignment value; hrcheck(enc(&ICalendarView_adaptor::HorizontalFirstOfMonthLabelAlignment)->_get_HorizontalFirstOfMonthLabelAlignment(&value)); return value; }
			HorizontalAlignment operator()() { return get(); }
			operator HorizontalAlignment () { return get(); }
			void put(HorizontalAlignment value) { hrcheck(enc(&ICalendarView_adaptor::HorizontalFirstOfMonthLabelAlignment)->_put_HorizontalFirstOfMonthLabelAlignment(value)); }
			void operator=(HorizontalAlignment value) { put(value); }
			void operator()(HorizontalAlignment value) { put(value); }
		} HorizontalFirstOfMonthLabelAlignment;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ICalendarView_adaptor::HoverBorderBrush)->_get_HoverBorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ICalendarView_adaptor::HoverBorderBrush)->_put_HoverBorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} HoverBorderBrush;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICalendarView_adaptor::IsGroupLabelVisible)->_get_IsGroupLabelVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICalendarView_adaptor::IsGroupLabelVisible)->_put_IsGroupLabelVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsGroupLabelVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICalendarView_adaptor::IsOutOfScopeEnabled)->_get_IsOutOfScopeEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICalendarView_adaptor::IsOutOfScopeEnabled)->_put_IsOutOfScopeEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsOutOfScopeEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICalendarView_adaptor::IsTodayHighlighted)->_get_IsTodayHighlighted(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICalendarView_adaptor::IsTodayHighlighted)->_put_IsTodayHighlighted(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTodayHighlighted;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&ICalendarView_adaptor::MaxDate)->_get_MaxDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
			void put(const Foundation::DateTime& value) { hrcheck(enc(&ICalendarView_adaptor::MaxDate)->_put_MaxDate(value)); }
			void operator=(const Foundation::DateTime& value) { put(value); }
			void operator()(const Foundation::DateTime& value) { put(value); }
		} MaxDate;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&ICalendarView_adaptor::MinDate)->_get_MinDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
			void put(const Foundation::DateTime& value) { hrcheck(enc(&ICalendarView_adaptor::MinDate)->_put_MinDate(value)); }
			void operator=(const Foundation::DateTime& value) { put(value); }
			void operator()(const Foundation::DateTime& value) { put(value); }
		} MinDate;
		struct : property {
			ptr<Media::FontFamily> get() { Media::FontFamily* value; hrcheck(enc(&ICalendarView_adaptor::MonthYearItemFontFamily)->_get_MonthYearItemFontFamily(&value)); return from_abi(value); }
			ptr<Media::FontFamily> operator()() { return get(); }
			operator ptr<Media::FontFamily> () { return get(); }
			ptr<Media::FontFamily> operator->() { return get(); }
			void put(pptr<Media::FontFamily> value) { hrcheck(enc(&ICalendarView_adaptor::MonthYearItemFontFamily)->_put_MonthYearItemFontFamily(value)); }
			void operator=(pptr<Media::FontFamily> value) { put(value); }
			void operator()(pptr<Media::FontFamily> value) { put(value); }
		} MonthYearItemFontFamily;
		struct : property {
			double get() { double value; hrcheck(enc(&ICalendarView_adaptor::MonthYearItemFontSize)->_get_MonthYearItemFontSize(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ICalendarView_adaptor::MonthYearItemFontSize)->_put_MonthYearItemFontSize(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MonthYearItemFontSize;
		struct : property {
			Text::FontStyle get() { Text::FontStyle value; hrcheck(enc(&ICalendarView_adaptor::MonthYearItemFontStyle)->_get_MonthYearItemFontStyle(&value)); return value; }
			Text::FontStyle operator()() { return get(); }
			operator Text::FontStyle () { return get(); }
			void put(Text::FontStyle value) { hrcheck(enc(&ICalendarView_adaptor::MonthYearItemFontStyle)->_put_MonthYearItemFontStyle(value)); }
			void operator=(Text::FontStyle value) { put(value); }
			void operator()(Text::FontStyle value) { put(value); }
		} MonthYearItemFontStyle;
		struct : property {
			Text::FontWeight get() { Text::FontWeight value; hrcheck(enc(&ICalendarView_adaptor::MonthYearItemFontWeight)->_get_MonthYearItemFontWeight(&value)); return value; }
			Text::FontWeight operator()() { return get(); }
			operator Text::FontWeight () { return get(); }
			void put(const Text::FontWeight& value) { hrcheck(enc(&ICalendarView_adaptor::MonthYearItemFontWeight)->_put_MonthYearItemFontWeight(value)); }
			void operator=(const Text::FontWeight& value) { put(value); }
			void operator()(const Text::FontWeight& value) { put(value); }
		} MonthYearItemFontWeight;
		struct : property {
			int get() { int value; hrcheck(enc(&ICalendarView_adaptor::NumberOfWeeksInView)->_get_NumberOfWeeksInView(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ICalendarView_adaptor::NumberOfWeeksInView)->_put_NumberOfWeeksInView(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} NumberOfWeeksInView;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ICalendarView_adaptor::OutOfScopeBackground)->_get_OutOfScopeBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ICalendarView_adaptor::OutOfScopeBackground)->_put_OutOfScopeBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} OutOfScopeBackground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ICalendarView_adaptor::OutOfScopeForeground)->_get_OutOfScopeForeground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ICalendarView_adaptor::OutOfScopeForeground)->_put_OutOfScopeForeground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} OutOfScopeForeground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ICalendarView_adaptor::PressedBorderBrush)->_get_PressedBorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ICalendarView_adaptor::PressedBorderBrush)->_put_PressedBorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} PressedBorderBrush;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ICalendarView_adaptor::PressedForeground)->_get_PressedForeground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ICalendarView_adaptor::PressedForeground)->_put_PressedForeground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} PressedForeground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ICalendarView_adaptor::SelectedBorderBrush)->_get_SelectedBorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ICalendarView_adaptor::SelectedBorderBrush)->_put_SelectedBorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} SelectedBorderBrush;
		struct : property {
			ptr<Foundation::Collections::IVector<Foundation::DateTime>> get() { Foundation::Collections::IVector<Foundation::DateTime>* value; hrcheck(enc(&ICalendarView_adaptor::SelectedDates)->_get_SelectedDates(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::Collections::IVector<Foundation::DateTime>> operator->() { return get(); }
		} SelectedDates;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ICalendarView_adaptor::SelectedForeground)->_get_SelectedForeground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ICalendarView_adaptor::SelectedForeground)->_put_SelectedForeground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} SelectedForeground;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ICalendarView_adaptor::SelectedHoverBorderBrush)->_get_SelectedHoverBorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ICalendarView_adaptor::SelectedHoverBorderBrush)->_put_SelectedHoverBorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} SelectedHoverBorderBrush;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ICalendarView_adaptor::SelectedPressedBorderBrush)->_get_SelectedPressedBorderBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ICalendarView_adaptor::SelectedPressedBorderBrush)->_put_SelectedPressedBorderBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} SelectedPressedBorderBrush;
		struct : property {
			CalendarViewSelectionMode get() { CalendarViewSelectionMode value; hrcheck(enc(&ICalendarView_adaptor::SelectionMode)->_get_SelectionMode(&value)); return value; }
			CalendarViewSelectionMode operator()() { return get(); }
			operator CalendarViewSelectionMode () { return get(); }
			void put(CalendarViewSelectionMode value) { hrcheck(enc(&ICalendarView_adaptor::SelectionMode)->_put_SelectionMode(value)); }
			void operator=(CalendarViewSelectionMode value) { put(value); }
			void operator()(CalendarViewSelectionMode value) { put(value); }
		} SelectionMode;
		struct : property {
			ptr<Primitives::CalendarViewTemplateSettings> get() { Primitives::CalendarViewTemplateSettings* value; hrcheck(enc(&ICalendarView_adaptor::TemplateSettings)->_get_TemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::CalendarViewTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::CalendarViewTemplateSettings> () { return get(); }
			ptr<Primitives::CalendarViewTemplateSettings> operator->() { return get(); }
		} TemplateSettings;
		struct : property {
			Text::FontWeight get() { Text::FontWeight value; hrcheck(enc(&ICalendarView_adaptor::TodayFontWeight)->_get_TodayFontWeight(&value)); return value; }
			Text::FontWeight operator()() { return get(); }
			operator Text::FontWeight () { return get(); }
			void put(const Text::FontWeight& value) { hrcheck(enc(&ICalendarView_adaptor::TodayFontWeight)->_put_TodayFontWeight(value)); }
			void operator=(const Text::FontWeight& value) { put(value); }
			void operator()(const Text::FontWeight& value) { put(value); }
		} TodayFontWeight;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ICalendarView_adaptor::TodayForeground)->_get_TodayForeground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ICalendarView_adaptor::TodayForeground)->_put_TodayForeground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} TodayForeground;
		struct : property {
			VerticalAlignment get() { VerticalAlignment value; hrcheck(enc(&ICalendarView_adaptor::VerticalDayItemAlignment)->_get_VerticalDayItemAlignment(&value)); return value; }
			VerticalAlignment operator()() { return get(); }
			operator VerticalAlignment () { return get(); }
			void put(VerticalAlignment value) { hrcheck(enc(&ICalendarView_adaptor::VerticalDayItemAlignment)->_put_VerticalDayItemAlignment(value)); }
			void operator=(VerticalAlignment value) { put(value); }
			void operator()(VerticalAlignment value) { put(value); }
		} VerticalDayItemAlignment;
		struct : property {
			VerticalAlignment get() { VerticalAlignment value; hrcheck(enc(&ICalendarView_adaptor::VerticalFirstOfMonthLabelAlignment)->_get_VerticalFirstOfMonthLabelAlignment(&value)); return value; }
			VerticalAlignment operator()() { return get(); }
			operator VerticalAlignment () { return get(); }
			void put(VerticalAlignment value) { hrcheck(enc(&ICalendarView_adaptor::VerticalFirstOfMonthLabelAlignment)->_put_VerticalFirstOfMonthLabelAlignment(value)); }
			void operator=(VerticalAlignment value) { put(value); }
			void operator()(VerticalAlignment value) { put(value); }
		} VerticalFirstOfMonthLabelAlignment;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<CalendarView>, ptr<CalendarViewDayItemChangingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICalendarView_adaptor::CalendarViewDayItemChanging)->_add_CalendarViewDayItemChanging(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICalendarView_adaptor::CalendarViewDayItemChanging)->_remove_CalendarViewDayItemChanging(token)); }
		} CalendarViewDayItemChanging;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<CalendarView>, ptr<CalendarViewSelectedDatesChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICalendarView_adaptor::SelectedDatesChanged)->_add_SelectedDatesChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICalendarView_adaptor::SelectedDatesChanged)->_remove_SelectedDatesChanged(token)); }
		} SelectedDatesChanged;
	};
	void SetDisplayDate(const Foundation::DateTime& date) { hrcheck(X::get()->_SetDisplayDate(date)); }
	void SetYearDecadeDisplayDimensions(int columns, int rows) { hrcheck(X::get()->_SetYearDecadeDisplayDimensions(columns, rows)); }
	ICalendarView_adaptor() {}
};
template<typename X> struct adapt<ICalendarView, X> : Windows::UI::Xaml::Controls::ICalendarView_adaptor<X> { typedef adapt ICalendarView; };
struct ICalendarView : ICalendarView_raw, generate<ICalendarView> {};

// ICalendarViewStatics
struct ICalendarViewStatics : IInspectable {
	virtual STDMETHODIMP _get_CalendarIdentifierProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DayOfWeekFormatProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsGroupLabelVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DisplayModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FirstDayOfWeekProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsOutOfScopeEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsTodayHighlightedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxDateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinDateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_NumberOfWeeksInViewProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedDatesProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectionModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TemplateSettingsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FocusBorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedHoverBorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedPressedBorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedBorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HoverBorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PressedBorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CalendarItemBorderBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OutOfScopeBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CalendarItemBackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PressedForegroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TodayForegroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BlackoutForegroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedForegroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OutOfScopeForegroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CalendarItemForegroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DayItemFontFamilyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DayItemFontSizeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DayItemFontStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DayItemFontWeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TodayFontWeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FirstOfMonthLabelFontFamilyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FirstOfMonthLabelFontSizeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FirstOfMonthLabelFontStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FirstOfMonthLabelFontWeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MonthYearItemFontFamilyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MonthYearItemFontSizeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MonthYearItemFontStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MonthYearItemFontWeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FirstOfYearDecadeLabelFontFamilyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FirstOfYearDecadeLabelFontSizeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FirstOfYearDecadeLabelFontStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FirstOfYearDecadeLabelFontWeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalDayItemAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalDayItemAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalFirstOfMonthLabelAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalFirstOfMonthLabelAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CalendarItemBorderThicknessProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CalendarViewDayItemStyleProperty(DependencyProperty* *value);
};

// ICalendarViewFactory
struct ICalendarViewFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, CalendarView* *instance);
};

// ICalendarViewDayItem
struct ICalendarViewDayItem_raw : IInspectable {
	virtual STDMETHODIMP _get_IsBlackout(bool *value);
	virtual STDMETHODIMP _put_IsBlackout(bool value);
	virtual STDMETHODIMP _get_Date(Foundation::DateTime *value);
	virtual STDMETHODIMP _SetDensityColors(Foundation::Collections::IIterable<Color>* colors);
};
template<typename X> struct ICalendarViewDayItem_adaptor : X {
	union {
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&ICalendarViewDayItem_adaptor::Date)->_get_Date(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} Date;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICalendarViewDayItem_adaptor::IsBlackout)->_get_IsBlackout(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICalendarViewDayItem_adaptor::IsBlackout)->_put_IsBlackout(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsBlackout;
	};
	void SetDensityColors(pptr<Foundation::Collections::IIterable<Color>> colors) { hrcheck(X::get()->_SetDensityColors(to_abi(colors))); }
	ICalendarViewDayItem_adaptor() {}
};
template<typename X> struct adapt<ICalendarViewDayItem, X> : Windows::UI::Xaml::Controls::ICalendarViewDayItem_adaptor<X> { typedef adapt ICalendarViewDayItem; };
struct ICalendarViewDayItem : ICalendarViewDayItem_raw, generate<ICalendarViewDayItem> {};

// ICalendarViewDayItemStatics
struct ICalendarViewDayItemStatics : IInspectable {
	virtual STDMETHODIMP _get_IsBlackoutProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DateProperty(DependencyProperty* *value);
};

// ICalendarViewDayItemFactory
struct ICalendarViewDayItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, CalendarViewDayItem* *instance);
};

// IDatePicker
struct IDatePicker_raw : IInspectable {
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_CalendarIdentifier(HSTRING *value);
	virtual STDMETHODIMP _put_CalendarIdentifier(HSTRING value);
	virtual STDMETHODIMP _get_Date(Foundation::DateTime *value);
	virtual STDMETHODIMP _put_Date(Foundation::DateTime value);
	virtual STDMETHODIMP _get_DayVisible(bool *value);
	virtual STDMETHODIMP _put_DayVisible(bool value);
	virtual STDMETHODIMP _get_MonthVisible(bool *value);
	virtual STDMETHODIMP _put_MonthVisible(bool value);
	virtual STDMETHODIMP _get_YearVisible(bool *value);
	virtual STDMETHODIMP _put_YearVisible(bool value);
	virtual STDMETHODIMP _get_DayFormat(HSTRING *value);
	virtual STDMETHODIMP _put_DayFormat(HSTRING value);
	virtual STDMETHODIMP _get_MonthFormat(HSTRING *value);
	virtual STDMETHODIMP _put_MonthFormat(HSTRING value);
	virtual STDMETHODIMP _get_YearFormat(HSTRING *value);
	virtual STDMETHODIMP _put_YearFormat(HSTRING value);
	virtual STDMETHODIMP _get_MinYear(Foundation::DateTime *value);
	virtual STDMETHODIMP _put_MinYear(Foundation::DateTime value);
	virtual STDMETHODIMP _get_MaxYear(Foundation::DateTime *value);
	virtual STDMETHODIMP _put_MaxYear(Foundation::DateTime value);
	virtual STDMETHODIMP _get_Orientation(Controls::Orientation *value);
	virtual STDMETHODIMP _put_Orientation(Controls::Orientation value);
	virtual STDMETHODIMP _add_DateChanged(Foundation::EventHandler<DatePickerValueChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DateChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IDatePicker_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDatePicker_adaptor::CalendarIdentifier)->_get_CalendarIdentifier(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDatePicker_adaptor::CalendarIdentifier)->_put_CalendarIdentifier(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} CalendarIdentifier;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IDatePicker_adaptor::Date)->_get_Date(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
			void put(const Foundation::DateTime& value) { hrcheck(enc(&IDatePicker_adaptor::Date)->_put_Date(value)); }
			void operator=(const Foundation::DateTime& value) { put(value); }
			void operator()(const Foundation::DateTime& value) { put(value); }
		} Date;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDatePicker_adaptor::DayFormat)->_get_DayFormat(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDatePicker_adaptor::DayFormat)->_put_DayFormat(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DayFormat;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDatePicker_adaptor::DayVisible)->_get_DayVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDatePicker_adaptor::DayVisible)->_put_DayVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} DayVisible;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IDatePicker_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IDatePicker_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IDatePicker_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IDatePicker_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IDatePicker_adaptor::MaxYear)->_get_MaxYear(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
			void put(const Foundation::DateTime& value) { hrcheck(enc(&IDatePicker_adaptor::MaxYear)->_put_MaxYear(value)); }
			void operator=(const Foundation::DateTime& value) { put(value); }
			void operator()(const Foundation::DateTime& value) { put(value); }
		} MaxYear;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IDatePicker_adaptor::MinYear)->_get_MinYear(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
			void put(const Foundation::DateTime& value) { hrcheck(enc(&IDatePicker_adaptor::MinYear)->_put_MinYear(value)); }
			void operator=(const Foundation::DateTime& value) { put(value); }
			void operator()(const Foundation::DateTime& value) { put(value); }
		} MinYear;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDatePicker_adaptor::MonthFormat)->_get_MonthFormat(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDatePicker_adaptor::MonthFormat)->_put_MonthFormat(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} MonthFormat;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDatePicker_adaptor::MonthVisible)->_get_MonthVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDatePicker_adaptor::MonthVisible)->_put_MonthVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} MonthVisible;
		struct : property {
			Controls::Orientation get() { Controls::Orientation value; hrcheck(enc(&IDatePicker_adaptor::Orientation)->_get_Orientation(&value)); return value; }
			Controls::Orientation operator()() { return get(); }
			operator Controls::Orientation () { return get(); }
			void put(Controls::Orientation value) { hrcheck(enc(&IDatePicker_adaptor::Orientation)->_put_Orientation(value)); }
			void operator=(Controls::Orientation value) { put(value); }
			void operator()(Controls::Orientation value) { put(value); }
		} Orientation;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDatePicker_adaptor::YearFormat)->_get_YearFormat(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDatePicker_adaptor::YearFormat)->_put_YearFormat(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} YearFormat;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDatePicker_adaptor::YearVisible)->_get_YearVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDatePicker_adaptor::YearVisible)->_put_YearVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} YearVisible;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<DatePickerValueChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDatePicker_adaptor::DateChanged)->_add_DateChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDatePicker_adaptor::DateChanged)->_remove_DateChanged(token)); }
		} DateChanged;
	};
	IDatePicker_adaptor() {}
};
template<typename X> struct adapt<IDatePicker, X> : Windows::UI::Xaml::Controls::IDatePicker_adaptor<X> { typedef adapt IDatePicker; };
struct IDatePicker : IDatePicker_raw, generate<IDatePicker> {};

// IDatePickerStatics
struct IDatePickerStatics : IInspectable {
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CalendarIdentifierProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DayVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MonthVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_YearVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DayFormatProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MonthFormatProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_YearFormatProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinYearProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxYearProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OrientationProperty(DependencyProperty* *value);
};

// IDatePickerFactory
struct IDatePickerFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, DatePicker* *instance);
};

// IDatePicker2
struct IDatePicker2_raw : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayMode(Controls::LightDismissOverlayMode *value);
	virtual STDMETHODIMP _put_LightDismissOverlayMode(Controls::LightDismissOverlayMode value);
};
template<typename X> struct IDatePicker2_adaptor : X {
	union {
		struct : property {
			Controls::LightDismissOverlayMode get() { Controls::LightDismissOverlayMode value; hrcheck(enc(&IDatePicker2_adaptor::LightDismissOverlayMode)->_get_LightDismissOverlayMode(&value)); return value; }
			Controls::LightDismissOverlayMode operator()() { return get(); }
			operator Controls::LightDismissOverlayMode () { return get(); }
			void put(Controls::LightDismissOverlayMode value) { hrcheck(enc(&IDatePicker2_adaptor::LightDismissOverlayMode)->_put_LightDismissOverlayMode(value)); }
			void operator=(Controls::LightDismissOverlayMode value) { put(value); }
			void operator()(Controls::LightDismissOverlayMode value) { put(value); }
		} LightDismissOverlayMode;
	};
	IDatePicker2_adaptor() {}
};
template<typename X> struct adapt<IDatePicker2, X> : Windows::UI::Xaml::Controls::IDatePicker2_adaptor<X> { typedef adapt IDatePicker2; };
struct IDatePicker2 : IDatePicker2_raw, generate<IDatePicker2> {};

// IDatePickerStatics2
struct IDatePickerStatics2 : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayModeProperty(DependencyProperty* *value);
};

// IFontIcon
struct IFontIcon_raw : IInspectable {
	virtual STDMETHODIMP _get_Glyph(HSTRING *value);
	virtual STDMETHODIMP _put_Glyph(HSTRING value);
	virtual STDMETHODIMP _get_FontSize(double *value);
	virtual STDMETHODIMP _put_FontSize(double value);
	virtual STDMETHODIMP _get_FontFamily(Media::FontFamily* *value);
	virtual STDMETHODIMP _put_FontFamily(Media::FontFamily* value);
	virtual STDMETHODIMP _get_FontWeight(Text::FontWeight *value);
	virtual STDMETHODIMP _put_FontWeight(Text::FontWeight value);
	virtual STDMETHODIMP _get_FontStyle(Text::FontStyle *value);
	virtual STDMETHODIMP _put_FontStyle(Text::FontStyle value);
};
template<typename X> struct IFontIcon_adaptor : X {
	union {
		struct : property {
			ptr<Media::FontFamily> get() { Media::FontFamily* value; hrcheck(enc(&IFontIcon_adaptor::FontFamily)->_get_FontFamily(&value)); return from_abi(value); }
			ptr<Media::FontFamily> operator()() { return get(); }
			operator ptr<Media::FontFamily> () { return get(); }
			ptr<Media::FontFamily> operator->() { return get(); }
			void put(pptr<Media::FontFamily> value) { hrcheck(enc(&IFontIcon_adaptor::FontFamily)->_put_FontFamily(value)); }
			void operator=(pptr<Media::FontFamily> value) { put(value); }
			void operator()(pptr<Media::FontFamily> value) { put(value); }
		} FontFamily;
		struct : property {
			double get() { double value; hrcheck(enc(&IFontIcon_adaptor::FontSize)->_get_FontSize(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IFontIcon_adaptor::FontSize)->_put_FontSize(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} FontSize;
		struct : property {
			Text::FontStyle get() { Text::FontStyle value; hrcheck(enc(&IFontIcon_adaptor::FontStyle)->_get_FontStyle(&value)); return value; }
			Text::FontStyle operator()() { return get(); }
			operator Text::FontStyle () { return get(); }
			void put(Text::FontStyle value) { hrcheck(enc(&IFontIcon_adaptor::FontStyle)->_put_FontStyle(value)); }
			void operator=(Text::FontStyle value) { put(value); }
			void operator()(Text::FontStyle value) { put(value); }
		} FontStyle;
		struct : property {
			Text::FontWeight get() { Text::FontWeight value; hrcheck(enc(&IFontIcon_adaptor::FontWeight)->_get_FontWeight(&value)); return value; }
			Text::FontWeight operator()() { return get(); }
			operator Text::FontWeight () { return get(); }
			void put(const Text::FontWeight& value) { hrcheck(enc(&IFontIcon_adaptor::FontWeight)->_put_FontWeight(value)); }
			void operator=(const Text::FontWeight& value) { put(value); }
			void operator()(const Text::FontWeight& value) { put(value); }
		} FontWeight;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IFontIcon_adaptor::Glyph)->_get_Glyph(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IFontIcon_adaptor::Glyph)->_put_Glyph(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Glyph;
	};
	IFontIcon_adaptor() {}
};
template<typename X> struct adapt<IFontIcon, X> : Windows::UI::Xaml::Controls::IFontIcon_adaptor<X> { typedef adapt IFontIcon; };
struct IFontIcon : IFontIcon_raw, generate<IFontIcon> {};

// IFontIconStatics
struct IFontIconStatics : IInspectable {
	virtual STDMETHODIMP _get_GlyphProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontSizeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontFamilyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontWeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FontStyleProperty(DependencyProperty* *value);
};

// IFontIconFactory
struct IFontIconFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, FontIcon* *instance);
};

// IFontIcon2
struct IFontIcon2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsTextScaleFactorEnabled(bool *value);
	virtual STDMETHODIMP _put_IsTextScaleFactorEnabled(bool value);
};
template<typename X> struct IFontIcon2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFontIcon2_adaptor::IsTextScaleFactorEnabled)->_get_IsTextScaleFactorEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IFontIcon2_adaptor::IsTextScaleFactorEnabled)->_put_IsTextScaleFactorEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTextScaleFactorEnabled;
	};
	IFontIcon2_adaptor() {}
};
template<typename X> struct adapt<IFontIcon2, X> : Windows::UI::Xaml::Controls::IFontIcon2_adaptor<X> { typedef adapt IFontIcon2; };
struct IFontIcon2 : IFontIcon2_raw, generate<IFontIcon2> {};

// IFontIconStatics2
struct IFontIconStatics2 : IInspectable {
	virtual STDMETHODIMP _get_IsTextScaleFactorEnabledProperty(DependencyProperty* *value);
};

// IFontIcon3
struct IFontIcon3_raw : IInspectable {
	virtual STDMETHODIMP _get_MirroredWhenRightToLeft(bool *value);
	virtual STDMETHODIMP _put_MirroredWhenRightToLeft(bool value);
};
template<typename X> struct IFontIcon3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFontIcon3_adaptor::MirroredWhenRightToLeft)->_get_MirroredWhenRightToLeft(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IFontIcon3_adaptor::MirroredWhenRightToLeft)->_put_MirroredWhenRightToLeft(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} MirroredWhenRightToLeft;
	};
	IFontIcon3_adaptor() {}
};
template<typename X> struct adapt<IFontIcon3, X> : Windows::UI::Xaml::Controls::IFontIcon3_adaptor<X> { typedef adapt IFontIcon3; };
struct IFontIcon3 : IFontIcon3_raw, generate<IFontIcon3> {};

// IFontIconStatics3
struct IFontIconStatics3 : IInspectable {
	virtual STDMETHODIMP _get_MirroredWhenRightToLeftProperty(DependencyProperty* *value);
};

// IHub
struct IHub_raw : IInspectable {
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_Orientation(Controls::Orientation *value);
	virtual STDMETHODIMP _put_Orientation(Controls::Orientation value);
	virtual STDMETHODIMP _get_DefaultSectionIndex(int *value);
	virtual STDMETHODIMP _put_DefaultSectionIndex(int value);
	virtual STDMETHODIMP _get_Sections(Foundation::Collections::IVector<HubSection*>* *value);
	virtual STDMETHODIMP _get_SectionsInView(Foundation::Collections::IVector<HubSection*>* *value);
	virtual STDMETHODIMP _get_SectionHeaders(Foundation::Collections::IObservableVector<IInspectable*>* *value);
	virtual STDMETHODIMP _add_SectionHeaderClick(HubSectionHeaderClickEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SectionHeaderClick(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_SectionsInViewChanged(SectionsInViewChangedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SectionsInViewChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _ScrollToSection(HubSection* section);
};
template<typename X> struct IHub_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IHub_adaptor::DefaultSectionIndex)->_get_DefaultSectionIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IHub_adaptor::DefaultSectionIndex)->_put_DefaultSectionIndex(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} DefaultSectionIndex;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IHub_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IHub_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IHub_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IHub_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
		struct : property {
			Controls::Orientation get() { Controls::Orientation value; hrcheck(enc(&IHub_adaptor::Orientation)->_get_Orientation(&value)); return value; }
			Controls::Orientation operator()() { return get(); }
			operator Controls::Orientation () { return get(); }
			void put(Controls::Orientation value) { hrcheck(enc(&IHub_adaptor::Orientation)->_put_Orientation(value)); }
			void operator=(Controls::Orientation value) { put(value); }
			void operator()(Controls::Orientation value) { put(value); }
		} Orientation;
		struct : property {
			ptr<Foundation::Collections::IObservableVector<object>> get() { Foundation::Collections::IObservableVector<IInspectable*>* value; hrcheck(enc(&IHub_adaptor::SectionHeaders)->_get_SectionHeaders(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IObservableVector<object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IObservableVector<object>> () { return get(); }
			ptr<Foundation::Collections::IObservableVector<object>> operator->() { return get(); }
		} SectionHeaders;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<HubSection>>> get() { Foundation::Collections::IVector<HubSection*>* value; hrcheck(enc(&IHub_adaptor::Sections)->_get_Sections(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<HubSection>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<HubSection>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<HubSection>>> operator->() { return get(); }
		} Sections;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<HubSection>>> get() { Foundation::Collections::IVector<HubSection*>* value; hrcheck(enc(&IHub_adaptor::SectionsInView)->_get_SectionsInView(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<HubSection>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<HubSection>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<HubSection>>> operator->() { return get(); }
		} SectionsInView;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<HubSectionHeaderClickEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IHub_adaptor::SectionHeaderClick)->_add_SectionHeaderClick(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IHub_adaptor::SectionHeaderClick)->_remove_SectionHeaderClick(token)); }
		} SectionHeaderClick;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<SectionsInViewChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IHub_adaptor::SectionsInViewChanged)->_add_SectionsInViewChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IHub_adaptor::SectionsInViewChanged)->_remove_SectionsInViewChanged(token)); }
		} SectionsInViewChanged;
	};
	void ScrollToSection(pptr<HubSection> section) { hrcheck(X::get()->_ScrollToSection(section)); }
	IHub_adaptor() {}
};
template<typename X> struct adapt<IHub, X> : Windows::UI::Xaml::Controls::IHub_adaptor<X> { typedef adapt IHub; };
struct IHub : IHub_raw, generate<IHub> {};

// IHubStatics
struct IHubStatics : IInspectable {
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OrientationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DefaultSectionIndexProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SemanticZoomOwnerProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsActiveViewProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsZoomedInViewProperty(DependencyProperty* *value);
};

// IHubFactory
struct IHubFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Hub* *instance);
};

// IItemsStackPanel
struct IItemsStackPanel_raw : IInspectable {
	virtual STDMETHODIMP _get_GroupPadding(Thickness *value);
	virtual STDMETHODIMP _put_GroupPadding(Thickness value);
	virtual STDMETHODIMP _get_Orientation(Controls::Orientation *value);
	virtual STDMETHODIMP _put_Orientation(Controls::Orientation value);
	virtual STDMETHODIMP _get_FirstCacheIndex(int *value);
	virtual STDMETHODIMP _get_FirstVisibleIndex(int *value);
	virtual STDMETHODIMP _get_LastVisibleIndex(int *value);
	virtual STDMETHODIMP _get_LastCacheIndex(int *value);
	virtual STDMETHODIMP _get_ScrollingDirection(PanelScrollingDirection *value);
	virtual STDMETHODIMP _get_GroupHeaderPlacement(Primitives::GroupHeaderPlacement *value);
	virtual STDMETHODIMP _put_GroupHeaderPlacement(Primitives::GroupHeaderPlacement value);
	virtual STDMETHODIMP _get_ItemsUpdatingScrollMode(Controls::ItemsUpdatingScrollMode *value);
	virtual STDMETHODIMP _put_ItemsUpdatingScrollMode(Controls::ItemsUpdatingScrollMode value);
	virtual STDMETHODIMP _get_CacheLength(double *value);
	virtual STDMETHODIMP _put_CacheLength(double value);
};
template<typename X> struct IItemsStackPanel_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IItemsStackPanel_adaptor::CacheLength)->_get_CacheLength(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IItemsStackPanel_adaptor::CacheLength)->_put_CacheLength(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CacheLength;
		struct : property {
			int get() { int value; hrcheck(enc(&IItemsStackPanel_adaptor::FirstCacheIndex)->_get_FirstCacheIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} FirstCacheIndex;
		struct : property {
			int get() { int value; hrcheck(enc(&IItemsStackPanel_adaptor::FirstVisibleIndex)->_get_FirstVisibleIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} FirstVisibleIndex;
		struct : property {
			Primitives::GroupHeaderPlacement get() { Primitives::GroupHeaderPlacement value; hrcheck(enc(&IItemsStackPanel_adaptor::GroupHeaderPlacement)->_get_GroupHeaderPlacement(&value)); return value; }
			Primitives::GroupHeaderPlacement operator()() { return get(); }
			operator Primitives::GroupHeaderPlacement () { return get(); }
			void put(Primitives::GroupHeaderPlacement value) { hrcheck(enc(&IItemsStackPanel_adaptor::GroupHeaderPlacement)->_put_GroupHeaderPlacement(value)); }
			void operator=(Primitives::GroupHeaderPlacement value) { put(value); }
			void operator()(Primitives::GroupHeaderPlacement value) { put(value); }
		} GroupHeaderPlacement;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IItemsStackPanel_adaptor::GroupPadding)->_get_GroupPadding(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IItemsStackPanel_adaptor::GroupPadding)->_put_GroupPadding(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} GroupPadding;
		struct : property {
			Controls::ItemsUpdatingScrollMode get() { Controls::ItemsUpdatingScrollMode value; hrcheck(enc(&IItemsStackPanel_adaptor::ItemsUpdatingScrollMode)->_get_ItemsUpdatingScrollMode(&value)); return value; }
			Controls::ItemsUpdatingScrollMode operator()() { return get(); }
			operator Controls::ItemsUpdatingScrollMode () { return get(); }
			void put(Controls::ItemsUpdatingScrollMode value) { hrcheck(enc(&IItemsStackPanel_adaptor::ItemsUpdatingScrollMode)->_put_ItemsUpdatingScrollMode(value)); }
			void operator=(Controls::ItemsUpdatingScrollMode value) { put(value); }
			void operator()(Controls::ItemsUpdatingScrollMode value) { put(value); }
		} ItemsUpdatingScrollMode;
		struct : property {
			int get() { int value; hrcheck(enc(&IItemsStackPanel_adaptor::LastCacheIndex)->_get_LastCacheIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} LastCacheIndex;
		struct : property {
			int get() { int value; hrcheck(enc(&IItemsStackPanel_adaptor::LastVisibleIndex)->_get_LastVisibleIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} LastVisibleIndex;
		struct : property {
			Controls::Orientation get() { Controls::Orientation value; hrcheck(enc(&IItemsStackPanel_adaptor::Orientation)->_get_Orientation(&value)); return value; }
			Controls::Orientation operator()() { return get(); }
			operator Controls::Orientation () { return get(); }
			void put(Controls::Orientation value) { hrcheck(enc(&IItemsStackPanel_adaptor::Orientation)->_put_Orientation(value)); }
			void operator=(Controls::Orientation value) { put(value); }
			void operator()(Controls::Orientation value) { put(value); }
		} Orientation;
		struct : property {
			PanelScrollingDirection get() { PanelScrollingDirection value; hrcheck(enc(&IItemsStackPanel_adaptor::ScrollingDirection)->_get_ScrollingDirection(&value)); return value; }
			PanelScrollingDirection operator()() { return get(); }
			operator PanelScrollingDirection () { return get(); }
		} ScrollingDirection;
	};
	IItemsStackPanel_adaptor() {}
};
template<typename X> struct adapt<IItemsStackPanel, X> : Windows::UI::Xaml::Controls::IItemsStackPanel_adaptor<X> { typedef adapt IItemsStackPanel; };
struct IItemsStackPanel : IItemsStackPanel_raw, generate<IItemsStackPanel> {};

// IItemsStackPanelStatics
struct IItemsStackPanelStatics : IInspectable {
	virtual STDMETHODIMP _get_GroupPaddingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OrientationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_GroupHeaderPlacementProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CacheLengthProperty(DependencyProperty* *value);
};

// IItemsStackPanel2
struct IItemsStackPanel2_raw : IInspectable {
	virtual STDMETHODIMP _get_AreStickyGroupHeadersEnabled(bool *value);
	virtual STDMETHODIMP _put_AreStickyGroupHeadersEnabled(bool value);
};
template<typename X> struct IItemsStackPanel2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IItemsStackPanel2_adaptor::AreStickyGroupHeadersEnabled)->_get_AreStickyGroupHeadersEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IItemsStackPanel2_adaptor::AreStickyGroupHeadersEnabled)->_put_AreStickyGroupHeadersEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AreStickyGroupHeadersEnabled;
	};
	IItemsStackPanel2_adaptor() {}
};
template<typename X> struct adapt<IItemsStackPanel2, X> : Windows::UI::Xaml::Controls::IItemsStackPanel2_adaptor<X> { typedef adapt IItemsStackPanel2; };
struct IItemsStackPanel2 : IItemsStackPanel2_raw, generate<IItemsStackPanel2> {};

// IItemsStackPanelStatics2
struct IItemsStackPanelStatics2 : IInspectable {
	virtual STDMETHODIMP _get_AreStickyGroupHeadersEnabledProperty(DependencyProperty* *value);
};

// IItemsWrapGrid
struct IItemsWrapGrid_raw : IInspectable {
	virtual STDMETHODIMP _get_GroupPadding(Thickness *value);
	virtual STDMETHODIMP _put_GroupPadding(Thickness value);
	virtual STDMETHODIMP _get_Orientation(Controls::Orientation *value);
	virtual STDMETHODIMP _put_Orientation(Controls::Orientation value);
	virtual STDMETHODIMP _get_MaximumRowsOrColumns(int *value);
	virtual STDMETHODIMP _put_MaximumRowsOrColumns(int value);
	virtual STDMETHODIMP _get_ItemWidth(double *value);
	virtual STDMETHODIMP _put_ItemWidth(double value);
	virtual STDMETHODIMP _get_ItemHeight(double *value);
	virtual STDMETHODIMP _put_ItemHeight(double value);
	virtual STDMETHODIMP _get_FirstCacheIndex(int *value);
	virtual STDMETHODIMP _get_FirstVisibleIndex(int *value);
	virtual STDMETHODIMP _get_LastVisibleIndex(int *value);
	virtual STDMETHODIMP _get_LastCacheIndex(int *value);
	virtual STDMETHODIMP _get_ScrollingDirection(PanelScrollingDirection *value);
	virtual STDMETHODIMP _get_GroupHeaderPlacement(Primitives::GroupHeaderPlacement *value);
	virtual STDMETHODIMP _put_GroupHeaderPlacement(Primitives::GroupHeaderPlacement value);
	virtual STDMETHODIMP _get_CacheLength(double *value);
	virtual STDMETHODIMP _put_CacheLength(double value);
};
template<typename X> struct IItemsWrapGrid_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IItemsWrapGrid_adaptor::CacheLength)->_get_CacheLength(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IItemsWrapGrid_adaptor::CacheLength)->_put_CacheLength(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CacheLength;
		struct : property {
			int get() { int value; hrcheck(enc(&IItemsWrapGrid_adaptor::FirstCacheIndex)->_get_FirstCacheIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} FirstCacheIndex;
		struct : property {
			int get() { int value; hrcheck(enc(&IItemsWrapGrid_adaptor::FirstVisibleIndex)->_get_FirstVisibleIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} FirstVisibleIndex;
		struct : property {
			Primitives::GroupHeaderPlacement get() { Primitives::GroupHeaderPlacement value; hrcheck(enc(&IItemsWrapGrid_adaptor::GroupHeaderPlacement)->_get_GroupHeaderPlacement(&value)); return value; }
			Primitives::GroupHeaderPlacement operator()() { return get(); }
			operator Primitives::GroupHeaderPlacement () { return get(); }
			void put(Primitives::GroupHeaderPlacement value) { hrcheck(enc(&IItemsWrapGrid_adaptor::GroupHeaderPlacement)->_put_GroupHeaderPlacement(value)); }
			void operator=(Primitives::GroupHeaderPlacement value) { put(value); }
			void operator()(Primitives::GroupHeaderPlacement value) { put(value); }
		} GroupHeaderPlacement;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&IItemsWrapGrid_adaptor::GroupPadding)->_get_GroupPadding(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
			void put(const Thickness& value) { hrcheck(enc(&IItemsWrapGrid_adaptor::GroupPadding)->_put_GroupPadding(value)); }
			void operator=(const Thickness& value) { put(value); }
			void operator()(const Thickness& value) { put(value); }
		} GroupPadding;
		struct : property {
			double get() { double value; hrcheck(enc(&IItemsWrapGrid_adaptor::ItemHeight)->_get_ItemHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IItemsWrapGrid_adaptor::ItemHeight)->_put_ItemHeight(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ItemHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IItemsWrapGrid_adaptor::ItemWidth)->_get_ItemWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IItemsWrapGrid_adaptor::ItemWidth)->_put_ItemWidth(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ItemWidth;
		struct : property {
			int get() { int value; hrcheck(enc(&IItemsWrapGrid_adaptor::LastCacheIndex)->_get_LastCacheIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} LastCacheIndex;
		struct : property {
			int get() { int value; hrcheck(enc(&IItemsWrapGrid_adaptor::LastVisibleIndex)->_get_LastVisibleIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} LastVisibleIndex;
		struct : property {
			int get() { int value; hrcheck(enc(&IItemsWrapGrid_adaptor::MaximumRowsOrColumns)->_get_MaximumRowsOrColumns(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IItemsWrapGrid_adaptor::MaximumRowsOrColumns)->_put_MaximumRowsOrColumns(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaximumRowsOrColumns;
		struct : property {
			Controls::Orientation get() { Controls::Orientation value; hrcheck(enc(&IItemsWrapGrid_adaptor::Orientation)->_get_Orientation(&value)); return value; }
			Controls::Orientation operator()() { return get(); }
			operator Controls::Orientation () { return get(); }
			void put(Controls::Orientation value) { hrcheck(enc(&IItemsWrapGrid_adaptor::Orientation)->_put_Orientation(value)); }
			void operator=(Controls::Orientation value) { put(value); }
			void operator()(Controls::Orientation value) { put(value); }
		} Orientation;
		struct : property {
			PanelScrollingDirection get() { PanelScrollingDirection value; hrcheck(enc(&IItemsWrapGrid_adaptor::ScrollingDirection)->_get_ScrollingDirection(&value)); return value; }
			PanelScrollingDirection operator()() { return get(); }
			operator PanelScrollingDirection () { return get(); }
		} ScrollingDirection;
	};
	IItemsWrapGrid_adaptor() {}
};
template<typename X> struct adapt<IItemsWrapGrid, X> : Windows::UI::Xaml::Controls::IItemsWrapGrid_adaptor<X> { typedef adapt IItemsWrapGrid; };
struct IItemsWrapGrid : IItemsWrapGrid_raw, generate<IItemsWrapGrid> {};

// IItemsWrapGridStatics
struct IItemsWrapGridStatics : IInspectable {
	virtual STDMETHODIMP _get_GroupPaddingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OrientationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaximumRowsOrColumnsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_GroupHeaderPlacementProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CacheLengthProperty(DependencyProperty* *value);
};

// IItemsWrapGrid2
struct IItemsWrapGrid2_raw : IInspectable {
	virtual STDMETHODIMP _get_AreStickyGroupHeadersEnabled(bool *value);
	virtual STDMETHODIMP _put_AreStickyGroupHeadersEnabled(bool value);
};
template<typename X> struct IItemsWrapGrid2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IItemsWrapGrid2_adaptor::AreStickyGroupHeadersEnabled)->_get_AreStickyGroupHeadersEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IItemsWrapGrid2_adaptor::AreStickyGroupHeadersEnabled)->_put_AreStickyGroupHeadersEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AreStickyGroupHeadersEnabled;
	};
	IItemsWrapGrid2_adaptor() {}
};
template<typename X> struct adapt<IItemsWrapGrid2, X> : Windows::UI::Xaml::Controls::IItemsWrapGrid2_adaptor<X> { typedef adapt IItemsWrapGrid2; };
struct IItemsWrapGrid2 : IItemsWrapGrid2_raw, generate<IItemsWrapGrid2> {};

// IItemsWrapGridStatics2
struct IItemsWrapGridStatics2 : IInspectable {
	virtual STDMETHODIMP _get_AreStickyGroupHeadersEnabledProperty(DependencyProperty* *value);
};

// IMediaPlayerElement
struct IMediaPlayerElement_raw : IInspectable {
	virtual STDMETHODIMP _get_Source(Windows::Media::Playback::IMediaPlaybackSource* *value);
	virtual STDMETHODIMP _put_Source(Windows::Media::Playback::IMediaPlaybackSource* value);
	virtual STDMETHODIMP _get_TransportControls(MediaTransportControls* *value);
	virtual STDMETHODIMP _put_TransportControls(MediaTransportControls* value);
	virtual STDMETHODIMP _get_AreTransportControlsEnabled(bool *value);
	virtual STDMETHODIMP _put_AreTransportControlsEnabled(bool value);
	virtual STDMETHODIMP _get_PosterSource(Media::ImageSource* *value);
	virtual STDMETHODIMP _put_PosterSource(Media::ImageSource* value);
	virtual STDMETHODIMP _get_Stretch(Media::Stretch *value);
	virtual STDMETHODIMP _put_Stretch(Media::Stretch value);
	virtual STDMETHODIMP _get_AutoPlay(bool *value);
	virtual STDMETHODIMP _put_AutoPlay(bool value);
	virtual STDMETHODIMP _get_IsFullWindow(bool *value);
	virtual STDMETHODIMP _put_IsFullWindow(bool value);
	virtual STDMETHODIMP _get_MediaPlayer(Windows::Media::Playback::MediaPlayer* *value);
	virtual STDMETHODIMP _SetMediaPlayer(Windows::Media::Playback::MediaPlayer* mediaPlayer);
};
template<typename X> struct IMediaPlayerElement_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaPlayerElement_adaptor::AreTransportControlsEnabled)->_get_AreTransportControlsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaPlayerElement_adaptor::AreTransportControlsEnabled)->_put_AreTransportControlsEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AreTransportControlsEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaPlayerElement_adaptor::AutoPlay)->_get_AutoPlay(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaPlayerElement_adaptor::AutoPlay)->_put_AutoPlay(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AutoPlay;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMediaPlayerElement_adaptor::IsFullWindow)->_get_IsFullWindow(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IMediaPlayerElement_adaptor::IsFullWindow)->_put_IsFullWindow(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsFullWindow;
		struct : property {
			ptr<Windows::Media::Playback::MediaPlayer> get() { Windows::Media::Playback::MediaPlayer* value; hrcheck(enc(&IMediaPlayerElement_adaptor::MediaPlayer)->_get_MediaPlayer(&value)); return from_abi(value); }
			ptr<Windows::Media::Playback::MediaPlayer> operator()() { return get(); }
			operator ptr<Windows::Media::Playback::MediaPlayer> () { return get(); }
			ptr<Windows::Media::Playback::MediaPlayer> operator->() { return get(); }
		} MediaPlayer;
		struct : property {
			ptr<Media::ImageSource> get() { Media::ImageSource* value; hrcheck(enc(&IMediaPlayerElement_adaptor::PosterSource)->_get_PosterSource(&value)); return from_abi(value); }
			ptr<Media::ImageSource> operator()() { return get(); }
			operator ptr<Media::ImageSource> () { return get(); }
			ptr<Media::ImageSource> operator->() { return get(); }
			void put(pptr<Media::ImageSource> value) { hrcheck(enc(&IMediaPlayerElement_adaptor::PosterSource)->_put_PosterSource(value)); }
			void operator=(pptr<Media::ImageSource> value) { put(value); }
			void operator()(pptr<Media::ImageSource> value) { put(value); }
		} PosterSource;
		struct : property {
			ptr<Windows::Media::Playback::IMediaPlaybackSource> get() { Windows::Media::Playback::IMediaPlaybackSource* value; hrcheck(enc(&IMediaPlayerElement_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			ptr<Windows::Media::Playback::IMediaPlaybackSource> operator()() { return get(); }
			operator ptr<Windows::Media::Playback::IMediaPlaybackSource> () { return get(); }
			ptr<Windows::Media::Playback::IMediaPlaybackSource> operator->() { return get(); }
			void put(pptr<Windows::Media::Playback::IMediaPlaybackSource> value) { hrcheck(enc(&IMediaPlayerElement_adaptor::Source)->_put_Source(value)); }
			void operator=(pptr<Windows::Media::Playback::IMediaPlaybackSource> value) { put(value); }
			void operator()(pptr<Windows::Media::Playback::IMediaPlaybackSource> value) { put(value); }
		} Source;
		struct : property {
			Media::Stretch get() { Media::Stretch value; hrcheck(enc(&IMediaPlayerElement_adaptor::Stretch)->_get_Stretch(&value)); return value; }
			Media::Stretch operator()() { return get(); }
			operator Media::Stretch () { return get(); }
			void put(Media::Stretch value) { hrcheck(enc(&IMediaPlayerElement_adaptor::Stretch)->_put_Stretch(value)); }
			void operator=(Media::Stretch value) { put(value); }
			void operator()(Media::Stretch value) { put(value); }
		} Stretch;
		struct : property {
			ptr<MediaTransportControls> get() { MediaTransportControls* value; hrcheck(enc(&IMediaPlayerElement_adaptor::TransportControls)->_get_TransportControls(&value)); return from_abi(value); }
			ptr<MediaTransportControls> operator()() { return get(); }
			operator ptr<MediaTransportControls> () { return get(); }
			ptr<MediaTransportControls> operator->() { return get(); }
			void put(pptr<MediaTransportControls> value) { hrcheck(enc(&IMediaPlayerElement_adaptor::TransportControls)->_put_TransportControls(value)); }
			void operator=(pptr<MediaTransportControls> value) { put(value); }
			void operator()(pptr<MediaTransportControls> value) { put(value); }
		} TransportControls;
	};
	void SetMediaPlayer(pptr<Windows::Media::Playback::MediaPlayer> mediaPlayer) { hrcheck(X::get()->_SetMediaPlayer(mediaPlayer)); }
	IMediaPlayerElement_adaptor() {}
};
template<typename X> struct adapt<IMediaPlayerElement, X> : Windows::UI::Xaml::Controls::IMediaPlayerElement_adaptor<X> { typedef adapt IMediaPlayerElement; };
struct IMediaPlayerElement : IMediaPlayerElement_raw, generate<IMediaPlayerElement> {};

// IMediaPlayerElementStatics
struct IMediaPlayerElementStatics : IInspectable {
	virtual STDMETHODIMP _get_SourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AreTransportControlsEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PosterSourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_StretchProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AutoPlayProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsFullWindowProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MediaPlayerProperty(DependencyProperty* *value);
};

// IMediaPlayerElementFactory
struct IMediaPlayerElementFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, MediaPlayerElement* *instance);
};

// IMenuFlyoutItemBase
struct IMenuFlyoutItemBase : IInspectable, generate<IMenuFlyoutItemBase> {};

// IMenuFlyoutItemBaseFactory
struct IMenuFlyoutItemBaseFactory : IInspectable, generate<IMenuFlyoutItemBaseFactory> {};

// IPathIcon
struct IPathIcon_raw : IInspectable {
	virtual STDMETHODIMP _get_Data(Media::Geometry* *value);
	virtual STDMETHODIMP _put_Data(Media::Geometry* value);
};
template<typename X> struct IPathIcon_adaptor : X {
	union {
		struct : property {
			ptr<Media::Geometry> get() { Media::Geometry* value; hrcheck(enc(&IPathIcon_adaptor::Data)->_get_Data(&value)); return from_abi(value); }
			ptr<Media::Geometry> operator()() { return get(); }
			operator ptr<Media::Geometry> () { return get(); }
			ptr<Media::Geometry> operator->() { return get(); }
			void put(pptr<Media::Geometry> value) { hrcheck(enc(&IPathIcon_adaptor::Data)->_put_Data(value)); }
			void operator=(pptr<Media::Geometry> value) { put(value); }
			void operator()(pptr<Media::Geometry> value) { put(value); }
		} Data;
	};
	IPathIcon_adaptor() {}
};
template<typename X> struct adapt<IPathIcon, X> : Windows::UI::Xaml::Controls::IPathIcon_adaptor<X> { typedef adapt IPathIcon; };
struct IPathIcon : IPathIcon_raw, generate<IPathIcon> {};

// IPathIconStatics
struct IPathIconStatics : IInspectable {
	virtual STDMETHODIMP _get_DataProperty(DependencyProperty* *value);
};

// IPathIconFactory
struct IPathIconFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, PathIcon* *instance);
};

// IRichEditBox
struct IRichEditBox_raw : IInspectable {
	virtual STDMETHODIMP _get_IsReadOnly(bool *value);
	virtual STDMETHODIMP _put_IsReadOnly(bool value);
	virtual STDMETHODIMP _get_AcceptsReturn(bool *value);
	virtual STDMETHODIMP _put_AcceptsReturn(bool value);
	virtual STDMETHODIMP _get_TextAlignment(Xaml::TextAlignment *value);
	virtual STDMETHODIMP _put_TextAlignment(Xaml::TextAlignment value);
	virtual STDMETHODIMP _get_TextWrapping(Xaml::TextWrapping *value);
	virtual STDMETHODIMP _put_TextWrapping(Xaml::TextWrapping value);
	virtual STDMETHODIMP _get_IsSpellCheckEnabled(bool *value);
	virtual STDMETHODIMP _put_IsSpellCheckEnabled(bool value);
	virtual STDMETHODIMP _get_IsTextPredictionEnabled(bool *value);
	virtual STDMETHODIMP _put_IsTextPredictionEnabled(bool value);
	virtual STDMETHODIMP _get_Document(Text::ITextDocument* *value);
	virtual STDMETHODIMP _get_InputScope(Input::InputScope* *value);
	virtual STDMETHODIMP _put_InputScope(Input::InputScope* value);
	virtual STDMETHODIMP _add_TextChanged(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_TextChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_SelectionChanged(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SelectionChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ContextMenuOpening(ContextMenuOpeningEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ContextMenuOpening(Foundation::EventRegistrationToken token);
};
template<typename X> struct IRichEditBox_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRichEditBox_adaptor::AcceptsReturn)->_get_AcceptsReturn(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IRichEditBox_adaptor::AcceptsReturn)->_put_AcceptsReturn(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AcceptsReturn;
		struct : property {
			ptr<Text::ITextDocument> get() { Text::ITextDocument* value; hrcheck(enc(&IRichEditBox_adaptor::Document)->_get_Document(&value)); return from_abi(value); }
			ptr<Text::ITextDocument> operator()() { return get(); }
			operator ptr<Text::ITextDocument> () { return get(); }
			ptr<Text::ITextDocument> operator->() { return get(); }
		} Document;
		struct : property {
			ptr<Input::InputScope> get() { Input::InputScope* value; hrcheck(enc(&IRichEditBox_adaptor::InputScope)->_get_InputScope(&value)); return from_abi(value); }
			ptr<Input::InputScope> operator()() { return get(); }
			operator ptr<Input::InputScope> () { return get(); }
			ptr<Input::InputScope> operator->() { return get(); }
			void put(pptr<Input::InputScope> value) { hrcheck(enc(&IRichEditBox_adaptor::InputScope)->_put_InputScope(value)); }
			void operator=(pptr<Input::InputScope> value) { put(value); }
			void operator()(pptr<Input::InputScope> value) { put(value); }
		} InputScope;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRichEditBox_adaptor::IsReadOnly)->_get_IsReadOnly(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IRichEditBox_adaptor::IsReadOnly)->_put_IsReadOnly(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsReadOnly;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRichEditBox_adaptor::IsSpellCheckEnabled)->_get_IsSpellCheckEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IRichEditBox_adaptor::IsSpellCheckEnabled)->_put_IsSpellCheckEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSpellCheckEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRichEditBox_adaptor::IsTextPredictionEnabled)->_get_IsTextPredictionEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IRichEditBox_adaptor::IsTextPredictionEnabled)->_put_IsTextPredictionEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTextPredictionEnabled;
		struct : property {
			Xaml::TextAlignment get() { Xaml::TextAlignment value; hrcheck(enc(&IRichEditBox_adaptor::TextAlignment)->_get_TextAlignment(&value)); return value; }
			Xaml::TextAlignment operator()() { return get(); }
			operator Xaml::TextAlignment () { return get(); }
			void put(Xaml::TextAlignment value) { hrcheck(enc(&IRichEditBox_adaptor::TextAlignment)->_put_TextAlignment(value)); }
			void operator=(Xaml::TextAlignment value) { put(value); }
			void operator()(Xaml::TextAlignment value) { put(value); }
		} TextAlignment;
		struct : property {
			Xaml::TextWrapping get() { Xaml::TextWrapping value; hrcheck(enc(&IRichEditBox_adaptor::TextWrapping)->_get_TextWrapping(&value)); return value; }
			Xaml::TextWrapping operator()() { return get(); }
			operator Xaml::TextWrapping () { return get(); }
			void put(Xaml::TextWrapping value) { hrcheck(enc(&IRichEditBox_adaptor::TextWrapping)->_put_TextWrapping(value)); }
			void operator=(Xaml::TextWrapping value) { put(value); }
			void operator()(Xaml::TextWrapping value) { put(value); }
		} TextWrapping;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<ContextMenuOpeningEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichEditBox_adaptor::ContextMenuOpening)->_add_ContextMenuOpening(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichEditBox_adaptor::ContextMenuOpening)->_remove_ContextMenuOpening(token)); }
		} ContextMenuOpening;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichEditBox_adaptor::SelectionChanged)->_add_SelectionChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichEditBox_adaptor::SelectionChanged)->_remove_SelectionChanged(token)); }
		} SelectionChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichEditBox_adaptor::TextChanged)->_add_TextChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichEditBox_adaptor::TextChanged)->_remove_TextChanged(token)); }
		} TextChanged;
	};
	IRichEditBox_adaptor() {}
};
template<typename X> struct adapt<IRichEditBox, X> : Windows::UI::Xaml::Controls::IRichEditBox_adaptor<X> { typedef adapt IRichEditBox; };
struct IRichEditBox : IRichEditBox_raw, generate<IRichEditBox> {};

// IRichEditBoxStatics
struct IRichEditBoxStatics : IInspectable {
	virtual STDMETHODIMP _get_IsReadOnlyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AcceptsReturnProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextWrappingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsSpellCheckEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsTextPredictionEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_InputScopeProperty(DependencyProperty* *value);
};

// IRichEditBoxFactory
struct IRichEditBoxFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, RichEditBox* *instance);
};

// IRichEditBox2
struct IRichEditBox2_raw : IInspectable {
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_PlaceholderText(HSTRING *value);
	virtual STDMETHODIMP _put_PlaceholderText(HSTRING value);
	virtual STDMETHODIMP _get_SelectionHighlightColor(Media::SolidColorBrush* *value);
	virtual STDMETHODIMP _put_SelectionHighlightColor(Media::SolidColorBrush* value);
	virtual STDMETHODIMP _get_PreventKeyboardDisplayOnProgrammaticFocus(bool *value);
	virtual STDMETHODIMP _put_PreventKeyboardDisplayOnProgrammaticFocus(bool value);
	virtual STDMETHODIMP _get_IsColorFontEnabled(bool *value);
	virtual STDMETHODIMP _put_IsColorFontEnabled(bool value);
	virtual STDMETHODIMP _add_Paste(TextControlPasteEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Paste(Foundation::EventRegistrationToken token);
};
template<typename X> struct IRichEditBox2_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IRichEditBox2_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IRichEditBox2_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IRichEditBox2_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IRichEditBox2_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRichEditBox2_adaptor::IsColorFontEnabled)->_get_IsColorFontEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IRichEditBox2_adaptor::IsColorFontEnabled)->_put_IsColorFontEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsColorFontEnabled;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRichEditBox2_adaptor::PlaceholderText)->_get_PlaceholderText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IRichEditBox2_adaptor::PlaceholderText)->_put_PlaceholderText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PlaceholderText;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRichEditBox2_adaptor::PreventKeyboardDisplayOnProgrammaticFocus)->_get_PreventKeyboardDisplayOnProgrammaticFocus(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IRichEditBox2_adaptor::PreventKeyboardDisplayOnProgrammaticFocus)->_put_PreventKeyboardDisplayOnProgrammaticFocus(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} PreventKeyboardDisplayOnProgrammaticFocus;
		struct : property {
			ptr<Media::SolidColorBrush> get() { Media::SolidColorBrush* value; hrcheck(enc(&IRichEditBox2_adaptor::SelectionHighlightColor)->_get_SelectionHighlightColor(&value)); return from_abi(value); }
			ptr<Media::SolidColorBrush> operator()() { return get(); }
			operator ptr<Media::SolidColorBrush> () { return get(); }
			ptr<Media::SolidColorBrush> operator->() { return get(); }
			void put(pptr<Media::SolidColorBrush> value) { hrcheck(enc(&IRichEditBox2_adaptor::SelectionHighlightColor)->_put_SelectionHighlightColor(value)); }
			void operator=(pptr<Media::SolidColorBrush> value) { put(value); }
			void operator()(pptr<Media::SolidColorBrush> value) { put(value); }
		} SelectionHighlightColor;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<TextControlPasteEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichEditBox2_adaptor::Paste)->_add_Paste(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichEditBox2_adaptor::Paste)->_remove_Paste(token)); }
		} Paste;
	};
	IRichEditBox2_adaptor() {}
};
template<typename X> struct adapt<IRichEditBox2, X> : Windows::UI::Xaml::Controls::IRichEditBox2_adaptor<X> { typedef adapt IRichEditBox2; };
struct IRichEditBox2 : IRichEditBox2_raw, generate<IRichEditBox2> {};

// IRichEditBoxStatics2
struct IRichEditBoxStatics2 : IInspectable {
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlaceholderTextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectionHighlightColorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PreventKeyboardDisplayOnProgrammaticFocusProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsColorFontEnabledProperty(DependencyProperty* *value);
};

// IRichEditBox3
struct IRichEditBox3_raw : IInspectable {
	virtual STDMETHODIMP _add_TextCompositionStarted(Foundation::TypedEventHandler<RichEditBox*, TextCompositionStartedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_TextCompositionStarted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_TextCompositionChanged(Foundation::TypedEventHandler<RichEditBox*, TextCompositionChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_TextCompositionChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_TextCompositionEnded(Foundation::TypedEventHandler<RichEditBox*, TextCompositionEndedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_TextCompositionEnded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_TextReadingOrder(Xaml::TextReadingOrder *value);
	virtual STDMETHODIMP _put_TextReadingOrder(Xaml::TextReadingOrder value);
	virtual STDMETHODIMP _get_DesiredCandidateWindowAlignment(CandidateWindowAlignment *value);
	virtual STDMETHODIMP _put_DesiredCandidateWindowAlignment(CandidateWindowAlignment value);
	virtual STDMETHODIMP _add_CandidateWindowBoundsChanged(Foundation::TypedEventHandler<RichEditBox*, CandidateWindowBoundsChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CandidateWindowBoundsChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_TextChanging(Foundation::TypedEventHandler<RichEditBox*, RichEditBoxTextChangingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_TextChanging(Foundation::EventRegistrationToken token);
};
template<typename X> struct IRichEditBox3_adaptor : X {
	union {
		struct : property {
			CandidateWindowAlignment get() { CandidateWindowAlignment value; hrcheck(enc(&IRichEditBox3_adaptor::DesiredCandidateWindowAlignment)->_get_DesiredCandidateWindowAlignment(&value)); return value; }
			CandidateWindowAlignment operator()() { return get(); }
			operator CandidateWindowAlignment () { return get(); }
			void put(CandidateWindowAlignment value) { hrcheck(enc(&IRichEditBox3_adaptor::DesiredCandidateWindowAlignment)->_put_DesiredCandidateWindowAlignment(value)); }
			void operator=(CandidateWindowAlignment value) { put(value); }
			void operator()(CandidateWindowAlignment value) { put(value); }
		} DesiredCandidateWindowAlignment;
		struct : property {
			Xaml::TextReadingOrder get() { Xaml::TextReadingOrder value; hrcheck(enc(&IRichEditBox3_adaptor::TextReadingOrder)->_get_TextReadingOrder(&value)); return value; }
			Xaml::TextReadingOrder operator()() { return get(); }
			operator Xaml::TextReadingOrder () { return get(); }
			void put(Xaml::TextReadingOrder value) { hrcheck(enc(&IRichEditBox3_adaptor::TextReadingOrder)->_put_TextReadingOrder(value)); }
			void operator=(Xaml::TextReadingOrder value) { put(value); }
			void operator()(Xaml::TextReadingOrder value) { put(value); }
		} TextReadingOrder;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<RichEditBox>, ptr<CandidateWindowBoundsChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichEditBox3_adaptor::CandidateWindowBoundsChanged)->_add_CandidateWindowBoundsChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichEditBox3_adaptor::CandidateWindowBoundsChanged)->_remove_CandidateWindowBoundsChanged(token)); }
		} CandidateWindowBoundsChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<RichEditBox>, ptr<RichEditBoxTextChangingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichEditBox3_adaptor::TextChanging)->_add_TextChanging(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichEditBox3_adaptor::TextChanging)->_remove_TextChanging(token)); }
		} TextChanging;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<RichEditBox>, ptr<TextCompositionChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichEditBox3_adaptor::TextCompositionChanged)->_add_TextCompositionChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichEditBox3_adaptor::TextCompositionChanged)->_remove_TextCompositionChanged(token)); }
		} TextCompositionChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<RichEditBox>, ptr<TextCompositionEndedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichEditBox3_adaptor::TextCompositionEnded)->_add_TextCompositionEnded(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichEditBox3_adaptor::TextCompositionEnded)->_remove_TextCompositionEnded(token)); }
		} TextCompositionEnded;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<RichEditBox>, ptr<TextCompositionStartedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichEditBox3_adaptor::TextCompositionStarted)->_add_TextCompositionStarted(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichEditBox3_adaptor::TextCompositionStarted)->_remove_TextCompositionStarted(token)); }
		} TextCompositionStarted;
	};
	IRichEditBox3_adaptor() {}
};
template<typename X> struct adapt<IRichEditBox3, X> : Windows::UI::Xaml::Controls::IRichEditBox3_adaptor<X> { typedef adapt IRichEditBox3; };
struct IRichEditBox3 : IRichEditBox3_raw, generate<IRichEditBox3> {};

// IRichEditBoxStatics3
struct IRichEditBoxStatics3 : IInspectable {
	virtual STDMETHODIMP _get_DesiredCandidateWindowAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextReadingOrderProperty(DependencyProperty* *value);
};

// IRichEditBox4
struct IRichEditBox4_raw : IInspectable {
	virtual STDMETHODIMP _GetLinguisticAlternativesAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<HSTRING>*>* *returnValue);
	virtual STDMETHODIMP _get_ClipboardCopyFormat(RichEditClipboardFormat *value);
	virtual STDMETHODIMP _put_ClipboardCopyFormat(RichEditClipboardFormat value);
};
template<typename X> struct IRichEditBox4_adaptor : X {
	union {
		struct : property {
			RichEditClipboardFormat get() { RichEditClipboardFormat value; hrcheck(enc(&IRichEditBox4_adaptor::ClipboardCopyFormat)->_get_ClipboardCopyFormat(&value)); return value; }
			RichEditClipboardFormat operator()() { return get(); }
			operator RichEditClipboardFormat () { return get(); }
			void put(RichEditClipboardFormat value) { hrcheck(enc(&IRichEditBox4_adaptor::ClipboardCopyFormat)->_put_ClipboardCopyFormat(value)); }
			void operator=(RichEditClipboardFormat value) { put(value); }
			void operator()(RichEditClipboardFormat value) { put(value); }
		} ClipboardCopyFormat;
	};
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<hstring>>>> GetLinguisticAlternativesAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<HSTRING>*>* returnValue; hrcheck(X::get()->_GetLinguisticAlternativesAsync(&returnValue)); return from_abi(returnValue); }
	IRichEditBox4_adaptor() {}
};
template<typename X> struct adapt<IRichEditBox4, X> : Windows::UI::Xaml::Controls::IRichEditBox4_adaptor<X> { typedef adapt IRichEditBox4; };
struct IRichEditBox4 : IRichEditBox4_raw, generate<IRichEditBox4> {};

// IRichEditBoxStatics4
struct IRichEditBoxStatics4 : IInspectable {
	virtual STDMETHODIMP _get_ClipboardCopyFormatProperty(DependencyProperty* *value);
};

// IRichEditBox5
struct IRichEditBox5_raw : IInspectable {
	virtual STDMETHODIMP _get_SelectionHighlightColorWhenNotFocused(Media::SolidColorBrush* *value);
	virtual STDMETHODIMP _put_SelectionHighlightColorWhenNotFocused(Media::SolidColorBrush* value);
	virtual STDMETHODIMP _get_MaxLength(int *value);
	virtual STDMETHODIMP _put_MaxLength(int value);
};
template<typename X> struct IRichEditBox5_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IRichEditBox5_adaptor::MaxLength)->_get_MaxLength(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IRichEditBox5_adaptor::MaxLength)->_put_MaxLength(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaxLength;
		struct : property {
			ptr<Media::SolidColorBrush> get() { Media::SolidColorBrush* value; hrcheck(enc(&IRichEditBox5_adaptor::SelectionHighlightColorWhenNotFocused)->_get_SelectionHighlightColorWhenNotFocused(&value)); return from_abi(value); }
			ptr<Media::SolidColorBrush> operator()() { return get(); }
			operator ptr<Media::SolidColorBrush> () { return get(); }
			ptr<Media::SolidColorBrush> operator->() { return get(); }
			void put(pptr<Media::SolidColorBrush> value) { hrcheck(enc(&IRichEditBox5_adaptor::SelectionHighlightColorWhenNotFocused)->_put_SelectionHighlightColorWhenNotFocused(value)); }
			void operator=(pptr<Media::SolidColorBrush> value) { put(value); }
			void operator()(pptr<Media::SolidColorBrush> value) { put(value); }
		} SelectionHighlightColorWhenNotFocused;
	};
	IRichEditBox5_adaptor() {}
};
template<typename X> struct adapt<IRichEditBox5, X> : Windows::UI::Xaml::Controls::IRichEditBox5_adaptor<X> { typedef adapt IRichEditBox5; };
struct IRichEditBox5 : IRichEditBox5_raw, generate<IRichEditBox5> {};

// IRichEditBoxStatics5
struct IRichEditBoxStatics5 : IInspectable {
	virtual STDMETHODIMP _get_SelectionHighlightColorWhenNotFocusedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxLengthProperty(DependencyProperty* *value);
};

// IRichEditBox6
struct IRichEditBox6_raw : IInspectable {
	virtual STDMETHODIMP _get_HorizontalTextAlignment(TextAlignment *value);
	virtual STDMETHODIMP _put_HorizontalTextAlignment(TextAlignment value);
	virtual STDMETHODIMP _get_CharacterCasing(Controls::CharacterCasing *value);
	virtual STDMETHODIMP _put_CharacterCasing(Controls::CharacterCasing value);
	virtual STDMETHODIMP _get_DisabledFormattingAccelerators(Controls::DisabledFormattingAccelerators *value);
	virtual STDMETHODIMP _put_DisabledFormattingAccelerators(Controls::DisabledFormattingAccelerators value);
	virtual STDMETHODIMP _add_CopyingToClipboard(Foundation::TypedEventHandler<RichEditBox*, TextControlCopyingToClipboardEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CopyingToClipboard(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_CuttingToClipboard(Foundation::TypedEventHandler<RichEditBox*, TextControlCuttingToClipboardEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CuttingToClipboard(Foundation::EventRegistrationToken token);
};
template<typename X> struct IRichEditBox6_adaptor : X {
	union {
		struct : property {
			Controls::CharacterCasing get() { Controls::CharacterCasing value; hrcheck(enc(&IRichEditBox6_adaptor::CharacterCasing)->_get_CharacterCasing(&value)); return value; }
			Controls::CharacterCasing operator()() { return get(); }
			operator Controls::CharacterCasing () { return get(); }
			void put(Controls::CharacterCasing value) { hrcheck(enc(&IRichEditBox6_adaptor::CharacterCasing)->_put_CharacterCasing(value)); }
			void operator=(Controls::CharacterCasing value) { put(value); }
			void operator()(Controls::CharacterCasing value) { put(value); }
		} CharacterCasing;
		struct : property {
			Controls::DisabledFormattingAccelerators get() { Controls::DisabledFormattingAccelerators value; hrcheck(enc(&IRichEditBox6_adaptor::DisabledFormattingAccelerators)->_get_DisabledFormattingAccelerators(&value)); return value; }
			Controls::DisabledFormattingAccelerators operator()() { return get(); }
			operator Controls::DisabledFormattingAccelerators () { return get(); }
			void put(Controls::DisabledFormattingAccelerators value) { hrcheck(enc(&IRichEditBox6_adaptor::DisabledFormattingAccelerators)->_put_DisabledFormattingAccelerators(value)); }
			void operator=(Controls::DisabledFormattingAccelerators value) { put(value); }
			void operator()(Controls::DisabledFormattingAccelerators value) { put(value); }
		} DisabledFormattingAccelerators;
		struct : property {
			TextAlignment get() { TextAlignment value; hrcheck(enc(&IRichEditBox6_adaptor::HorizontalTextAlignment)->_get_HorizontalTextAlignment(&value)); return value; }
			TextAlignment operator()() { return get(); }
			operator TextAlignment () { return get(); }
			void put(TextAlignment value) { hrcheck(enc(&IRichEditBox6_adaptor::HorizontalTextAlignment)->_put_HorizontalTextAlignment(value)); }
			void operator=(TextAlignment value) { put(value); }
			void operator()(TextAlignment value) { put(value); }
		} HorizontalTextAlignment;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<RichEditBox>, ptr<TextControlCopyingToClipboardEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichEditBox6_adaptor::CopyingToClipboard)->_add_CopyingToClipboard(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichEditBox6_adaptor::CopyingToClipboard)->_remove_CopyingToClipboard(token)); }
		} CopyingToClipboard;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<RichEditBox>, ptr<TextControlCuttingToClipboardEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichEditBox6_adaptor::CuttingToClipboard)->_add_CuttingToClipboard(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichEditBox6_adaptor::CuttingToClipboard)->_remove_CuttingToClipboard(token)); }
		} CuttingToClipboard;
	};
	IRichEditBox6_adaptor() {}
};
template<typename X> struct adapt<IRichEditBox6, X> : Windows::UI::Xaml::Controls::IRichEditBox6_adaptor<X> { typedef adapt IRichEditBox6; };
struct IRichEditBox6 : IRichEditBox6_raw, generate<IRichEditBox6> {};

// IRichEditBoxStatics6
struct IRichEditBoxStatics6 : IInspectable {
	virtual STDMETHODIMP _get_HorizontalTextAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CharacterCasingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DisabledFormattingAcceleratorsProperty(DependencyProperty* *value);
};

// IRichEditBox7
struct IRichEditBox7_raw : IInspectable {
	virtual STDMETHODIMP _get_ContentLinkForegroundColor(Media::SolidColorBrush* *value);
	virtual STDMETHODIMP _put_ContentLinkForegroundColor(Media::SolidColorBrush* value);
	virtual STDMETHODIMP _get_ContentLinkBackgroundColor(Media::SolidColorBrush* *value);
	virtual STDMETHODIMP _put_ContentLinkBackgroundColor(Media::SolidColorBrush* value);
	virtual STDMETHODIMP _get_ContentLinkProviders(Documents::ContentLinkProviderCollection* *value);
	virtual STDMETHODIMP _put_ContentLinkProviders(Documents::ContentLinkProviderCollection* value);
	virtual STDMETHODIMP _get_HandwritingView(Controls::HandwritingView* *value);
	virtual STDMETHODIMP _put_HandwritingView(Controls::HandwritingView* value);
	virtual STDMETHODIMP _get_IsHandwritingViewEnabled(bool *value);
	virtual STDMETHODIMP _put_IsHandwritingViewEnabled(bool value);
	virtual STDMETHODIMP _add_ContentLinkChanged(Foundation::TypedEventHandler<RichEditBox*, ContentLinkChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ContentLinkChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ContentLinkInvoked(Foundation::TypedEventHandler<RichEditBox*, Documents::ContentLinkInvokedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ContentLinkInvoked(Foundation::EventRegistrationToken token);
};
template<typename X> struct IRichEditBox7_adaptor : X {
	union {
		struct : property {
			ptr<Media::SolidColorBrush> get() { Media::SolidColorBrush* value; hrcheck(enc(&IRichEditBox7_adaptor::ContentLinkBackgroundColor)->_get_ContentLinkBackgroundColor(&value)); return from_abi(value); }
			ptr<Media::SolidColorBrush> operator()() { return get(); }
			operator ptr<Media::SolidColorBrush> () { return get(); }
			ptr<Media::SolidColorBrush> operator->() { return get(); }
			void put(pptr<Media::SolidColorBrush> value) { hrcheck(enc(&IRichEditBox7_adaptor::ContentLinkBackgroundColor)->_put_ContentLinkBackgroundColor(value)); }
			void operator=(pptr<Media::SolidColorBrush> value) { put(value); }
			void operator()(pptr<Media::SolidColorBrush> value) { put(value); }
		} ContentLinkBackgroundColor;
		struct : property {
			ptr<Media::SolidColorBrush> get() { Media::SolidColorBrush* value; hrcheck(enc(&IRichEditBox7_adaptor::ContentLinkForegroundColor)->_get_ContentLinkForegroundColor(&value)); return from_abi(value); }
			ptr<Media::SolidColorBrush> operator()() { return get(); }
			operator ptr<Media::SolidColorBrush> () { return get(); }
			ptr<Media::SolidColorBrush> operator->() { return get(); }
			void put(pptr<Media::SolidColorBrush> value) { hrcheck(enc(&IRichEditBox7_adaptor::ContentLinkForegroundColor)->_put_ContentLinkForegroundColor(value)); }
			void operator=(pptr<Media::SolidColorBrush> value) { put(value); }
			void operator()(pptr<Media::SolidColorBrush> value) { put(value); }
		} ContentLinkForegroundColor;
		struct : property {
			ptr<Documents::ContentLinkProviderCollection> get() { Documents::ContentLinkProviderCollection* value; hrcheck(enc(&IRichEditBox7_adaptor::ContentLinkProviders)->_get_ContentLinkProviders(&value)); return from_abi(value); }
			ptr<Documents::ContentLinkProviderCollection> operator()() { return get(); }
			operator ptr<Documents::ContentLinkProviderCollection> () { return get(); }
			ptr<Documents::ContentLinkProviderCollection> operator->() { return get(); }
			void put(pptr<Documents::ContentLinkProviderCollection> value) { hrcheck(enc(&IRichEditBox7_adaptor::ContentLinkProviders)->_put_ContentLinkProviders(value)); }
			void operator=(pptr<Documents::ContentLinkProviderCollection> value) { put(value); }
			void operator()(pptr<Documents::ContentLinkProviderCollection> value) { put(value); }
		} ContentLinkProviders;
		struct : property {
			ptr<Controls::HandwritingView> get() { Controls::HandwritingView* value; hrcheck(enc(&IRichEditBox7_adaptor::HandwritingView)->_get_HandwritingView(&value)); return from_abi(value); }
			ptr<Controls::HandwritingView> operator()() { return get(); }
			operator ptr<Controls::HandwritingView> () { return get(); }
			ptr<Controls::HandwritingView> operator->() { return get(); }
			void put(pptr<Controls::HandwritingView> value) { hrcheck(enc(&IRichEditBox7_adaptor::HandwritingView)->_put_HandwritingView(value)); }
			void operator=(pptr<Controls::HandwritingView> value) { put(value); }
			void operator()(pptr<Controls::HandwritingView> value) { put(value); }
		} HandwritingView;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRichEditBox7_adaptor::IsHandwritingViewEnabled)->_get_IsHandwritingViewEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IRichEditBox7_adaptor::IsHandwritingViewEnabled)->_put_IsHandwritingViewEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsHandwritingViewEnabled;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<RichEditBox>, ptr<ContentLinkChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichEditBox7_adaptor::ContentLinkChanged)->_add_ContentLinkChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichEditBox7_adaptor::ContentLinkChanged)->_remove_ContentLinkChanged(token)); }
		} ContentLinkChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<RichEditBox>, ptr<Documents::ContentLinkInvokedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRichEditBox7_adaptor::ContentLinkInvoked)->_add_ContentLinkInvoked(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRichEditBox7_adaptor::ContentLinkInvoked)->_remove_ContentLinkInvoked(token)); }
		} ContentLinkInvoked;
	};
	IRichEditBox7_adaptor() {}
};
template<typename X> struct adapt<IRichEditBox7, X> : Windows::UI::Xaml::Controls::IRichEditBox7_adaptor<X> { typedef adapt IRichEditBox7; };
struct IRichEditBox7 : IRichEditBox7_raw, generate<IRichEditBox7> {};

// IRichEditBoxStatics7
struct IRichEditBoxStatics7 : IInspectable {
	virtual STDMETHODIMP _get_ContentLinkForegroundColorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentLinkBackgroundColorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentLinkProvidersProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HandwritingViewProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsHandwritingViewEnabledProperty(DependencyProperty* *value);
};

// IScrollContentPresenter
struct IScrollContentPresenter_raw : IInspectable {
	virtual STDMETHODIMP _get_CanVerticallyScroll(bool *value);
	virtual STDMETHODIMP _put_CanVerticallyScroll(bool value);
	virtual STDMETHODIMP _get_CanHorizontallyScroll(bool *value);
	virtual STDMETHODIMP _put_CanHorizontallyScroll(bool value);
	virtual STDMETHODIMP _get_ExtentWidth(double *value);
	virtual STDMETHODIMP _get_ExtentHeight(double *value);
	virtual STDMETHODIMP _get_ViewportWidth(double *value);
	virtual STDMETHODIMP _get_ViewportHeight(double *value);
	virtual STDMETHODIMP _get_HorizontalOffset(double *value);
	virtual STDMETHODIMP _get_VerticalOffset(double *value);
	virtual STDMETHODIMP _get_ScrollOwner(IInspectable* *value);
	virtual STDMETHODIMP _put_ScrollOwner(IInspectable* value);
	virtual STDMETHODIMP _LineUp();
	virtual STDMETHODIMP _LineDown();
	virtual STDMETHODIMP _LineLeft();
	virtual STDMETHODIMP _LineRight();
	virtual STDMETHODIMP _PageUp();
	virtual STDMETHODIMP _PageDown();
	virtual STDMETHODIMP _PageLeft();
	virtual STDMETHODIMP _PageRight();
	virtual STDMETHODIMP _MouseWheelUp();
	virtual STDMETHODIMP _MouseWheelDown();
	virtual STDMETHODIMP _MouseWheelLeft();
	virtual STDMETHODIMP _MouseWheelRight();
	virtual STDMETHODIMP _SetHorizontalOffset(double offset);
	virtual STDMETHODIMP _SetVerticalOffset(double offset);
	virtual STDMETHODIMP _MakeVisible(UIElement* visual, Foundation::Rect rectangle, Foundation::Rect *returnValue);
};
template<typename X> struct IScrollContentPresenter_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollContentPresenter_adaptor::CanHorizontallyScroll)->_get_CanHorizontallyScroll(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IScrollContentPresenter_adaptor::CanHorizontallyScroll)->_put_CanHorizontallyScroll(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} CanHorizontallyScroll;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollContentPresenter_adaptor::CanVerticallyScroll)->_get_CanVerticallyScroll(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IScrollContentPresenter_adaptor::CanVerticallyScroll)->_put_CanVerticallyScroll(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} CanVerticallyScroll;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollContentPresenter_adaptor::ExtentHeight)->_get_ExtentHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ExtentHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollContentPresenter_adaptor::ExtentWidth)->_get_ExtentWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ExtentWidth;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollContentPresenter_adaptor::HorizontalOffset)->_get_HorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} HorizontalOffset;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IScrollContentPresenter_adaptor::ScrollOwner)->_get_ScrollOwner(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IScrollContentPresenter_adaptor::ScrollOwner)->_put_ScrollOwner(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} ScrollOwner;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollContentPresenter_adaptor::VerticalOffset)->_get_VerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} VerticalOffset;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollContentPresenter_adaptor::ViewportHeight)->_get_ViewportHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ViewportHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollContentPresenter_adaptor::ViewportWidth)->_get_ViewportWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ViewportWidth;
	};
	void LineUp() { hrcheck(X::get()->_LineUp()); }
	void LineDown() { hrcheck(X::get()->_LineDown()); }
	void LineLeft() { hrcheck(X::get()->_LineLeft()); }
	void LineRight() { hrcheck(X::get()->_LineRight()); }
	void PageUp() { hrcheck(X::get()->_PageUp()); }
	void PageDown() { hrcheck(X::get()->_PageDown()); }
	void PageLeft() { hrcheck(X::get()->_PageLeft()); }
	void PageRight() { hrcheck(X::get()->_PageRight()); }
	void MouseWheelUp() { hrcheck(X::get()->_MouseWheelUp()); }
	void MouseWheelDown() { hrcheck(X::get()->_MouseWheelDown()); }
	void MouseWheelLeft() { hrcheck(X::get()->_MouseWheelLeft()); }
	void MouseWheelRight() { hrcheck(X::get()->_MouseWheelRight()); }
	void SetHorizontalOffset(double offset) { hrcheck(X::get()->_SetHorizontalOffset(offset)); }
	void SetVerticalOffset(double offset) { hrcheck(X::get()->_SetVerticalOffset(offset)); }
	Foundation::Rect MakeVisible(pptr<UIElement> visual, const Foundation::Rect& rectangle) { Foundation::Rect returnValue; hrcheck(X::get()->_MakeVisible(visual, rectangle, &returnValue)); return returnValue; }
	IScrollContentPresenter_adaptor() {}
};
template<typename X> struct adapt<IScrollContentPresenter, X> : Windows::UI::Xaml::Controls::IScrollContentPresenter_adaptor<X> { typedef adapt IScrollContentPresenter; };
struct IScrollContentPresenter : IScrollContentPresenter_raw, generate<IScrollContentPresenter> {};

// ISearchBox
struct ISearchBox_raw : IInspectable {
	virtual STDMETHODIMP _get_SearchHistoryEnabled(bool *value);
	virtual STDMETHODIMP _put_SearchHistoryEnabled(bool value);
	virtual STDMETHODIMP _get_SearchHistoryContext(HSTRING *value);
	virtual STDMETHODIMP _put_SearchHistoryContext(HSTRING value);
	virtual STDMETHODIMP _get_PlaceholderText(HSTRING *value);
	virtual STDMETHODIMP _put_PlaceholderText(HSTRING value);
	virtual STDMETHODIMP _get_QueryText(HSTRING *value);
	virtual STDMETHODIMP _put_QueryText(HSTRING value);
	virtual STDMETHODIMP _get_FocusOnKeyboardInput(bool *value);
	virtual STDMETHODIMP _put_FocusOnKeyboardInput(bool value);
	virtual STDMETHODIMP _get_ChooseSuggestionOnEnter(bool *value);
	virtual STDMETHODIMP _put_ChooseSuggestionOnEnter(bool value);
	virtual STDMETHODIMP _add_QueryChanged(Foundation::TypedEventHandler<SearchBox*, SearchBoxQueryChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_QueryChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_SuggestionsRequested(Foundation::TypedEventHandler<SearchBox*, SearchBoxSuggestionsRequestedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SuggestionsRequested(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_QuerySubmitted(Foundation::TypedEventHandler<SearchBox*, SearchBoxQuerySubmittedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_QuerySubmitted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ResultSuggestionChosen(Foundation::TypedEventHandler<SearchBox*, SearchBoxResultSuggestionChosenEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ResultSuggestionChosen(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PrepareForFocusOnKeyboardInput(Foundation::TypedEventHandler<SearchBox*, RoutedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PrepareForFocusOnKeyboardInput(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _SetLocalContentSuggestionSettings(ApplicationModel::Search::LocalContentSuggestionSettings* settings);
};
template<typename X> struct ISearchBox_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISearchBox_adaptor::ChooseSuggestionOnEnter)->_get_ChooseSuggestionOnEnter(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISearchBox_adaptor::ChooseSuggestionOnEnter)->_put_ChooseSuggestionOnEnter(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ChooseSuggestionOnEnter;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISearchBox_adaptor::FocusOnKeyboardInput)->_get_FocusOnKeyboardInput(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISearchBox_adaptor::FocusOnKeyboardInput)->_put_FocusOnKeyboardInput(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} FocusOnKeyboardInput;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISearchBox_adaptor::PlaceholderText)->_get_PlaceholderText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISearchBox_adaptor::PlaceholderText)->_put_PlaceholderText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PlaceholderText;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISearchBox_adaptor::QueryText)->_get_QueryText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISearchBox_adaptor::QueryText)->_put_QueryText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} QueryText;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISearchBox_adaptor::SearchHistoryContext)->_get_SearchHistoryContext(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISearchBox_adaptor::SearchHistoryContext)->_put_SearchHistoryContext(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} SearchHistoryContext;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISearchBox_adaptor::SearchHistoryEnabled)->_get_SearchHistoryEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISearchBox_adaptor::SearchHistoryEnabled)->_put_SearchHistoryEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} SearchHistoryEnabled;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SearchBox>, ptr<RoutedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISearchBox_adaptor::PrepareForFocusOnKeyboardInput)->_add_PrepareForFocusOnKeyboardInput(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISearchBox_adaptor::PrepareForFocusOnKeyboardInput)->_remove_PrepareForFocusOnKeyboardInput(token)); }
		} PrepareForFocusOnKeyboardInput;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SearchBox>, ptr<SearchBoxQueryChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISearchBox_adaptor::QueryChanged)->_add_QueryChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISearchBox_adaptor::QueryChanged)->_remove_QueryChanged(token)); }
		} QueryChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SearchBox>, ptr<SearchBoxQuerySubmittedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISearchBox_adaptor::QuerySubmitted)->_add_QuerySubmitted(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISearchBox_adaptor::QuerySubmitted)->_remove_QuerySubmitted(token)); }
		} QuerySubmitted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SearchBox>, ptr<SearchBoxResultSuggestionChosenEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISearchBox_adaptor::ResultSuggestionChosen)->_add_ResultSuggestionChosen(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISearchBox_adaptor::ResultSuggestionChosen)->_remove_ResultSuggestionChosen(token)); }
		} ResultSuggestionChosen;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SearchBox>, ptr<SearchBoxSuggestionsRequestedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISearchBox_adaptor::SuggestionsRequested)->_add_SuggestionsRequested(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISearchBox_adaptor::SuggestionsRequested)->_remove_SuggestionsRequested(token)); }
		} SuggestionsRequested;
	};
	void SetLocalContentSuggestionSettings(pptr<ApplicationModel::Search::LocalContentSuggestionSettings> settings) { hrcheck(X::get()->_SetLocalContentSuggestionSettings(settings)); }
	ISearchBox_adaptor() {}
};
template<typename X> struct adapt<ISearchBox, X> : Windows::UI::Xaml::Controls::ISearchBox_adaptor<X> { typedef adapt ISearchBox; };
struct ISearchBox : ISearchBox_raw, generate<ISearchBox> {};

// ISearchBoxStatics
struct ISearchBoxStatics : IInspectable {
	virtual STDMETHODIMP _get_SearchHistoryEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SearchHistoryContextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlaceholderTextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_QueryTextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FocusOnKeyboardInputProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ChooseSuggestionOnEnterProperty(DependencyProperty* *value);
};

// ISearchBoxFactory
struct ISearchBoxFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, SearchBox* *instance);
};

// ISplitView
struct ISplitView_raw : IInspectable {
	virtual STDMETHODIMP _get_Content(UIElement* *value);
	virtual STDMETHODIMP _put_Content(UIElement* value);
	virtual STDMETHODIMP _get_Pane(UIElement* *value);
	virtual STDMETHODIMP _put_Pane(UIElement* value);
	virtual STDMETHODIMP _get_IsPaneOpen(bool *value);
	virtual STDMETHODIMP _put_IsPaneOpen(bool value);
	virtual STDMETHODIMP _get_OpenPaneLength(double *value);
	virtual STDMETHODIMP _put_OpenPaneLength(double value);
	virtual STDMETHODIMP _get_CompactPaneLength(double *value);
	virtual STDMETHODIMP _put_CompactPaneLength(double value);
	virtual STDMETHODIMP _get_PanePlacement(SplitViewPanePlacement *value);
	virtual STDMETHODIMP _put_PanePlacement(SplitViewPanePlacement value);
	virtual STDMETHODIMP _get_DisplayMode(SplitViewDisplayMode *value);
	virtual STDMETHODIMP _put_DisplayMode(SplitViewDisplayMode value);
	virtual STDMETHODIMP _get_TemplateSettings(Primitives::SplitViewTemplateSettings* *value);
	virtual STDMETHODIMP _get_PaneBackground(Media::Brush* *value);
	virtual STDMETHODIMP _put_PaneBackground(Media::Brush* value);
	virtual STDMETHODIMP _add_PaneClosing(Foundation::TypedEventHandler<SplitView*, SplitViewPaneClosingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PaneClosing(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PaneClosed(Foundation::TypedEventHandler<SplitView*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PaneClosed(Foundation::EventRegistrationToken token);
};
template<typename X> struct ISplitView_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&ISplitView_adaptor::CompactPaneLength)->_get_CompactPaneLength(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISplitView_adaptor::CompactPaneLength)->_put_CompactPaneLength(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CompactPaneLength;
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&ISplitView_adaptor::Content)->_get_Content(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&ISplitView_adaptor::Content)->_put_Content(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} Content;
		struct : property {
			SplitViewDisplayMode get() { SplitViewDisplayMode value; hrcheck(enc(&ISplitView_adaptor::DisplayMode)->_get_DisplayMode(&value)); return value; }
			SplitViewDisplayMode operator()() { return get(); }
			operator SplitViewDisplayMode () { return get(); }
			void put(SplitViewDisplayMode value) { hrcheck(enc(&ISplitView_adaptor::DisplayMode)->_put_DisplayMode(value)); }
			void operator=(SplitViewDisplayMode value) { put(value); }
			void operator()(SplitViewDisplayMode value) { put(value); }
		} DisplayMode;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISplitView_adaptor::IsPaneOpen)->_get_IsPaneOpen(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISplitView_adaptor::IsPaneOpen)->_put_IsPaneOpen(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsPaneOpen;
		struct : property {
			double get() { double value; hrcheck(enc(&ISplitView_adaptor::OpenPaneLength)->_get_OpenPaneLength(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISplitView_adaptor::OpenPaneLength)->_put_OpenPaneLength(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} OpenPaneLength;
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&ISplitView_adaptor::Pane)->_get_Pane(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&ISplitView_adaptor::Pane)->_put_Pane(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} Pane;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ISplitView_adaptor::PaneBackground)->_get_PaneBackground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ISplitView_adaptor::PaneBackground)->_put_PaneBackground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} PaneBackground;
		struct : property {
			SplitViewPanePlacement get() { SplitViewPanePlacement value; hrcheck(enc(&ISplitView_adaptor::PanePlacement)->_get_PanePlacement(&value)); return value; }
			SplitViewPanePlacement operator()() { return get(); }
			operator SplitViewPanePlacement () { return get(); }
			void put(SplitViewPanePlacement value) { hrcheck(enc(&ISplitView_adaptor::PanePlacement)->_put_PanePlacement(value)); }
			void operator=(SplitViewPanePlacement value) { put(value); }
			void operator()(SplitViewPanePlacement value) { put(value); }
		} PanePlacement;
		struct : property {
			ptr<Primitives::SplitViewTemplateSettings> get() { Primitives::SplitViewTemplateSettings* value; hrcheck(enc(&ISplitView_adaptor::TemplateSettings)->_get_TemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::SplitViewTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::SplitViewTemplateSettings> () { return get(); }
			ptr<Primitives::SplitViewTemplateSettings> operator->() { return get(); }
		} TemplateSettings;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SplitView>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISplitView_adaptor::PaneClosed)->_add_PaneClosed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISplitView_adaptor::PaneClosed)->_remove_PaneClosed(token)); }
		} PaneClosed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SplitView>, ptr<SplitViewPaneClosingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISplitView_adaptor::PaneClosing)->_add_PaneClosing(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISplitView_adaptor::PaneClosing)->_remove_PaneClosing(token)); }
		} PaneClosing;
	};
	ISplitView_adaptor() {}
};
template<typename X> struct adapt<ISplitView, X> : Windows::UI::Xaml::Controls::ISplitView_adaptor<X> { typedef adapt ISplitView; };
struct ISplitView : ISplitView_raw, generate<ISplitView> {};

// ISplitViewStatics
struct ISplitViewStatics : IInspectable {
	virtual STDMETHODIMP _get_ContentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PaneProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsPaneOpenProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OpenPaneLengthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CompactPaneLengthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PanePlacementProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DisplayModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TemplateSettingsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PaneBackgroundProperty(DependencyProperty* *value);
};

// ISplitViewFactory
struct ISplitViewFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, SplitView* *instance);
};

// ISplitView2
struct ISplitView2_raw : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayMode(Controls::LightDismissOverlayMode *value);
	virtual STDMETHODIMP _put_LightDismissOverlayMode(Controls::LightDismissOverlayMode value);
};
template<typename X> struct ISplitView2_adaptor : X {
	union {
		struct : property {
			Controls::LightDismissOverlayMode get() { Controls::LightDismissOverlayMode value; hrcheck(enc(&ISplitView2_adaptor::LightDismissOverlayMode)->_get_LightDismissOverlayMode(&value)); return value; }
			Controls::LightDismissOverlayMode operator()() { return get(); }
			operator Controls::LightDismissOverlayMode () { return get(); }
			void put(Controls::LightDismissOverlayMode value) { hrcheck(enc(&ISplitView2_adaptor::LightDismissOverlayMode)->_put_LightDismissOverlayMode(value)); }
			void operator=(Controls::LightDismissOverlayMode value) { put(value); }
			void operator()(Controls::LightDismissOverlayMode value) { put(value); }
		} LightDismissOverlayMode;
	};
	ISplitView2_adaptor() {}
};
template<typename X> struct adapt<ISplitView2, X> : Windows::UI::Xaml::Controls::ISplitView2_adaptor<X> { typedef adapt ISplitView2; };
struct ISplitView2 : ISplitView2_raw, generate<ISplitView2> {};

// ISplitViewStatics2
struct ISplitViewStatics2 : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayModeProperty(DependencyProperty* *value);
};

// ISplitView3
struct ISplitView3_raw : IInspectable {
	virtual STDMETHODIMP _add_PaneOpening(Foundation::TypedEventHandler<SplitView*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PaneOpening(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PaneOpened(Foundation::TypedEventHandler<SplitView*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PaneOpened(Foundation::EventRegistrationToken token);
};
template<typename X> struct ISplitView3_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SplitView>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISplitView3_adaptor::PaneOpened)->_add_PaneOpened(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISplitView3_adaptor::PaneOpened)->_remove_PaneOpened(token)); }
		} PaneOpened;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SplitView>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISplitView3_adaptor::PaneOpening)->_add_PaneOpening(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISplitView3_adaptor::PaneOpening)->_remove_PaneOpening(token)); }
		} PaneOpening;
	};
	ISplitView3_adaptor() {}
};
template<typename X> struct adapt<ISplitView3, X> : Windows::UI::Xaml::Controls::ISplitView3_adaptor<X> { typedef adapt ISplitView3; };
struct ISplitView3 : ISplitView3_raw, generate<ISplitView3> {};

// ISymbolIcon
struct ISymbolIcon_raw : IInspectable {
	virtual STDMETHODIMP _get_Symbol(Controls::Symbol *value);
	virtual STDMETHODIMP _put_Symbol(Controls::Symbol value);
};
template<typename X> struct ISymbolIcon_adaptor : X {
	union {
		struct : property {
			Controls::Symbol get() { Controls::Symbol value; hrcheck(enc(&ISymbolIcon_adaptor::Symbol)->_get_Symbol(&value)); return value; }
			Controls::Symbol operator()() { return get(); }
			operator Controls::Symbol () { return get(); }
			void put(Controls::Symbol value) { hrcheck(enc(&ISymbolIcon_adaptor::Symbol)->_put_Symbol(value)); }
			void operator=(Controls::Symbol value) { put(value); }
			void operator()(Controls::Symbol value) { put(value); }
		} Symbol;
	};
	ISymbolIcon_adaptor() {}
};
template<typename X> struct adapt<ISymbolIcon, X> : Windows::UI::Xaml::Controls::ISymbolIcon_adaptor<X> { typedef adapt ISymbolIcon; };
struct ISymbolIcon : ISymbolIcon_raw, generate<ISymbolIcon> {};

// ISymbolIconStatics
struct ISymbolIconStatics : IInspectable {
	virtual STDMETHODIMP _get_SymbolProperty(DependencyProperty* *value);
};

// ISymbolIconFactory
struct ISymbolIconFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithSymbol(Symbol symbol, SymbolIcon* *instance);
};

// ITimePicker
struct ITimePicker_raw : IInspectable {
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_ClockIdentifier(HSTRING *value);
	virtual STDMETHODIMP _put_ClockIdentifier(HSTRING value);
	virtual STDMETHODIMP _get_MinuteIncrement(int *value);
	virtual STDMETHODIMP _put_MinuteIncrement(int value);
	virtual STDMETHODIMP _get_Time(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_Time(Foundation::TimeSpan value);
	virtual STDMETHODIMP _add_TimeChanged(Foundation::EventHandler<TimePickerValueChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_TimeChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct ITimePicker_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITimePicker_adaptor::ClockIdentifier)->_get_ClockIdentifier(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITimePicker_adaptor::ClockIdentifier)->_put_ClockIdentifier(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ClockIdentifier;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ITimePicker_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&ITimePicker_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&ITimePicker_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&ITimePicker_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
		struct : property {
			int get() { int value; hrcheck(enc(&ITimePicker_adaptor::MinuteIncrement)->_get_MinuteIncrement(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ITimePicker_adaptor::MinuteIncrement)->_put_MinuteIncrement(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MinuteIncrement;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ITimePicker_adaptor::Time)->_get_Time(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ITimePicker_adaptor::Time)->_put_Time(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Time;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<TimePickerValueChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITimePicker_adaptor::TimeChanged)->_add_TimeChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITimePicker_adaptor::TimeChanged)->_remove_TimeChanged(token)); }
		} TimeChanged;
	};
	ITimePicker_adaptor() {}
};
template<typename X> struct adapt<ITimePicker, X> : Windows::UI::Xaml::Controls::ITimePicker_adaptor<X> { typedef adapt ITimePicker; };
struct ITimePicker : ITimePicker_raw, generate<ITimePicker> {};

// ITimePickerStatics
struct ITimePickerStatics : IInspectable {
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ClockIdentifierProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinuteIncrementProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TimeProperty(DependencyProperty* *value);
};

// ITimePickerFactory
struct ITimePickerFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, TimePicker* *instance);
};

// ITimePicker2
struct ITimePicker2_raw : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayMode(Controls::LightDismissOverlayMode *value);
	virtual STDMETHODIMP _put_LightDismissOverlayMode(Controls::LightDismissOverlayMode value);
};
template<typename X> struct ITimePicker2_adaptor : X {
	union {
		struct : property {
			Controls::LightDismissOverlayMode get() { Controls::LightDismissOverlayMode value; hrcheck(enc(&ITimePicker2_adaptor::LightDismissOverlayMode)->_get_LightDismissOverlayMode(&value)); return value; }
			Controls::LightDismissOverlayMode operator()() { return get(); }
			operator Controls::LightDismissOverlayMode () { return get(); }
			void put(Controls::LightDismissOverlayMode value) { hrcheck(enc(&ITimePicker2_adaptor::LightDismissOverlayMode)->_put_LightDismissOverlayMode(value)); }
			void operator=(Controls::LightDismissOverlayMode value) { put(value); }
			void operator()(Controls::LightDismissOverlayMode value) { put(value); }
		} LightDismissOverlayMode;
	};
	ITimePicker2_adaptor() {}
};
template<typename X> struct adapt<ITimePicker2, X> : Windows::UI::Xaml::Controls::ITimePicker2_adaptor<X> { typedef adapt ITimePicker2; };
struct ITimePicker2 : ITimePicker2_raw, generate<ITimePicker2> {};

// ITimePickerStatics2
struct ITimePickerStatics2 : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayModeProperty(DependencyProperty* *value);
};

// IAppBar
struct IAppBar_raw : IInspectable {
	virtual STDMETHODIMP _get_IsOpen(bool *value);
	virtual STDMETHODIMP _put_IsOpen(bool value);
	virtual STDMETHODIMP _get_IsSticky(bool *value);
	virtual STDMETHODIMP _put_IsSticky(bool value);
	virtual STDMETHODIMP _add_Opened(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Opened(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Closed(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Closed(Foundation::EventRegistrationToken token);
};
template<typename X> struct IAppBar_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppBar_adaptor::IsOpen)->_get_IsOpen(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IAppBar_adaptor::IsOpen)->_put_IsOpen(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsOpen;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppBar_adaptor::IsSticky)->_get_IsSticky(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IAppBar_adaptor::IsSticky)->_put_IsSticky(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSticky;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppBar_adaptor::Closed)->_add_Closed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppBar_adaptor::Closed)->_remove_Closed(token)); }
		} Closed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppBar_adaptor::Opened)->_add_Opened(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppBar_adaptor::Opened)->_remove_Opened(token)); }
		} Opened;
	};
	IAppBar_adaptor() {}
};
template<typename X> struct adapt<IAppBar, X> : Windows::UI::Xaml::Controls::IAppBar_adaptor<X> { typedef adapt IAppBar; };
struct IAppBar : IAppBar_raw, generate<IAppBar> {};

// IAppBarOverrides
struct IAppBarOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnClosed(IInspectable* e) = 0;
	virtual STDMETHODIMP _OnOpened(IInspectable* e) = 0;
};
template<typename X> struct IAppBarOverrides_adaptor : X {
	void OnClosed(object_ref e) { hrcheck(X::get()->_OnClosed(e)); }
	void OnOpened(object_ref e) { hrcheck(X::get()->_OnOpened(e)); }
};
template<typename X> struct adapt<IAppBarOverrides, X> : Windows::UI::Xaml::Controls::IAppBarOverrides_adaptor<X> { typedef adapt IAppBarOverrides; };
template<typename X> struct IAppBarOverrides_unadaptor : X {
	STDMETHODIMP _OnClosed(IInspectable* e) { return hrtry([&, this] { X::get()->OnClosed(e); }); }
	STDMETHODIMP _OnOpened(IInspectable* e) { return hrtry([&, this] { X::get()->OnOpened(e); }); }
};
template<typename X> struct unadapt<IAppBarOverrides, X> : Windows::UI::Xaml::Controls::IAppBarOverrides_unadaptor<X> {};
struct IAppBarOverrides : IAppBarOverrides_raw, generate<IAppBarOverrides> {};

// IAppBarStatics
struct IAppBarStatics : IInspectable {
	virtual STDMETHODIMP _get_IsOpenProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsStickyProperty(DependencyProperty* *value);
};

// IAppBarFactory
struct IAppBarFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, AppBar* *instance);
};

// IAppBar2
struct IAppBar2_raw : IInspectable {
	virtual STDMETHODIMP _get_ClosedDisplayMode(AppBarClosedDisplayMode *value);
	virtual STDMETHODIMP _put_ClosedDisplayMode(AppBarClosedDisplayMode value);
};
template<typename X> struct IAppBar2_adaptor : X {
	union {
		struct : property {
			AppBarClosedDisplayMode get() { AppBarClosedDisplayMode value; hrcheck(enc(&IAppBar2_adaptor::ClosedDisplayMode)->_get_ClosedDisplayMode(&value)); return value; }
			AppBarClosedDisplayMode operator()() { return get(); }
			operator AppBarClosedDisplayMode () { return get(); }
			void put(AppBarClosedDisplayMode value) { hrcheck(enc(&IAppBar2_adaptor::ClosedDisplayMode)->_put_ClosedDisplayMode(value)); }
			void operator=(AppBarClosedDisplayMode value) { put(value); }
			void operator()(AppBarClosedDisplayMode value) { put(value); }
		} ClosedDisplayMode;
	};
	IAppBar2_adaptor() {}
};
template<typename X> struct adapt<IAppBar2, X> : Windows::UI::Xaml::Controls::IAppBar2_adaptor<X> { typedef adapt IAppBar2; };
struct IAppBar2 : IAppBar2_raw, generate<IAppBar2> {};

// IAppBarStatics2
struct IAppBarStatics2 : IInspectable {
	virtual STDMETHODIMP _get_ClosedDisplayModeProperty(DependencyProperty* *value);
};

// IAppBar3
struct IAppBar3_raw : IInspectable {
	virtual STDMETHODIMP _get_TemplateSettings(Primitives::AppBarTemplateSettings* *value);
	virtual STDMETHODIMP _add_Opening(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Opening(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Closing(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Closing(Foundation::EventRegistrationToken token);
};
template<typename X> struct IAppBar3_adaptor : X {
	union {
		struct : property {
			ptr<Primitives::AppBarTemplateSettings> get() { Primitives::AppBarTemplateSettings* value; hrcheck(enc(&IAppBar3_adaptor::TemplateSettings)->_get_TemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::AppBarTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::AppBarTemplateSettings> () { return get(); }
			ptr<Primitives::AppBarTemplateSettings> operator->() { return get(); }
		} TemplateSettings;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppBar3_adaptor::Closing)->_add_Closing(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppBar3_adaptor::Closing)->_remove_Closing(token)); }
		} Closing;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppBar3_adaptor::Opening)->_add_Opening(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppBar3_adaptor::Opening)->_remove_Opening(token)); }
		} Opening;
	};
	IAppBar3_adaptor() {}
};
template<typename X> struct adapt<IAppBar3, X> : Windows::UI::Xaml::Controls::IAppBar3_adaptor<X> { typedef adapt IAppBar3; };
struct IAppBar3 : IAppBar3_raw, generate<IAppBar3> {};

// IAppBarOverrides3
struct IAppBarOverrides3_raw : IInspectable {
	virtual STDMETHODIMP _OnClosing(IInspectable* e) = 0;
	virtual STDMETHODIMP _OnOpening(IInspectable* e) = 0;
};
template<typename X> struct IAppBarOverrides3_adaptor : X {
	void OnClosing(object_ref e) { hrcheck(X::get()->_OnClosing(e)); }
	void OnOpening(object_ref e) { hrcheck(X::get()->_OnOpening(e)); }
};
template<typename X> struct adapt<IAppBarOverrides3, X> : Windows::UI::Xaml::Controls::IAppBarOverrides3_adaptor<X> { typedef adapt IAppBarOverrides3; };
template<typename X> struct IAppBarOverrides3_unadaptor : X {
	STDMETHODIMP _OnClosing(IInspectable* e) { return hrtry([&, this] { X::get()->OnClosing(e); }); }
	STDMETHODIMP _OnOpening(IInspectable* e) { return hrtry([&, this] { X::get()->OnOpening(e); }); }
};
template<typename X> struct unadapt<IAppBarOverrides3, X> : Windows::UI::Xaml::Controls::IAppBarOverrides3_unadaptor<X> {};
struct IAppBarOverrides3 : IAppBarOverrides3_raw, generate<IAppBarOverrides3> {};

// IAppBar4
struct IAppBar4_raw : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayMode(Controls::LightDismissOverlayMode *value);
	virtual STDMETHODIMP _put_LightDismissOverlayMode(Controls::LightDismissOverlayMode value);
};
template<typename X> struct IAppBar4_adaptor : X {
	union {
		struct : property {
			Controls::LightDismissOverlayMode get() { Controls::LightDismissOverlayMode value; hrcheck(enc(&IAppBar4_adaptor::LightDismissOverlayMode)->_get_LightDismissOverlayMode(&value)); return value; }
			Controls::LightDismissOverlayMode operator()() { return get(); }
			operator Controls::LightDismissOverlayMode () { return get(); }
			void put(Controls::LightDismissOverlayMode value) { hrcheck(enc(&IAppBar4_adaptor::LightDismissOverlayMode)->_put_LightDismissOverlayMode(value)); }
			void operator=(Controls::LightDismissOverlayMode value) { put(value); }
			void operator()(Controls::LightDismissOverlayMode value) { put(value); }
		} LightDismissOverlayMode;
	};
	IAppBar4_adaptor() {}
};
template<typename X> struct adapt<IAppBar4, X> : Windows::UI::Xaml::Controls::IAppBar4_adaptor<X> { typedef adapt IAppBar4; };
struct IAppBar4 : IAppBar4_raw, generate<IAppBar4> {};

// IAppBarStatics4
struct IAppBarStatics4 : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayModeProperty(DependencyProperty* *value);
};

// IAutoSuggestBox
struct IAutoSuggestBox_raw : IInspectable {
	virtual STDMETHODIMP _get_MaxSuggestionListHeight(double *value);
	virtual STDMETHODIMP _put_MaxSuggestionListHeight(double value);
	virtual STDMETHODIMP _get_IsSuggestionListOpen(bool *value);
	virtual STDMETHODIMP _put_IsSuggestionListOpen(bool value);
	virtual STDMETHODIMP _get_TextMemberPath(HSTRING *value);
	virtual STDMETHODIMP _put_TextMemberPath(HSTRING value);
	virtual STDMETHODIMP _get_Text(HSTRING *value);
	virtual STDMETHODIMP _put_Text(HSTRING value);
	virtual STDMETHODIMP _get_UpdateTextOnSelect(bool *value);
	virtual STDMETHODIMP _put_UpdateTextOnSelect(bool value);
	virtual STDMETHODIMP _get_PlaceholderText(HSTRING *value);
	virtual STDMETHODIMP _put_PlaceholderText(HSTRING value);
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
	virtual STDMETHODIMP _get_AutoMaximizeSuggestionArea(bool *value);
	virtual STDMETHODIMP _put_AutoMaximizeSuggestionArea(bool value);
	virtual STDMETHODIMP _get_TextBoxStyle(Style* *value);
	virtual STDMETHODIMP _put_TextBoxStyle(Style* value);
	virtual STDMETHODIMP _add_SuggestionChosen(Foundation::TypedEventHandler<AutoSuggestBox*, AutoSuggestBoxSuggestionChosenEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SuggestionChosen(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_TextChanged(Foundation::TypedEventHandler<AutoSuggestBox*, AutoSuggestBoxTextChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_TextChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IAutoSuggestBox_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAutoSuggestBox_adaptor::AutoMaximizeSuggestionArea)->_get_AutoMaximizeSuggestionArea(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IAutoSuggestBox_adaptor::AutoMaximizeSuggestionArea)->_put_AutoMaximizeSuggestionArea(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AutoMaximizeSuggestionArea;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IAutoSuggestBox_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IAutoSuggestBox_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAutoSuggestBox_adaptor::IsSuggestionListOpen)->_get_IsSuggestionListOpen(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IAutoSuggestBox_adaptor::IsSuggestionListOpen)->_put_IsSuggestionListOpen(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSuggestionListOpen;
		struct : property {
			double get() { double value; hrcheck(enc(&IAutoSuggestBox_adaptor::MaxSuggestionListHeight)->_get_MaxSuggestionListHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IAutoSuggestBox_adaptor::MaxSuggestionListHeight)->_put_MaxSuggestionListHeight(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MaxSuggestionListHeight;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAutoSuggestBox_adaptor::PlaceholderText)->_get_PlaceholderText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IAutoSuggestBox_adaptor::PlaceholderText)->_put_PlaceholderText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PlaceholderText;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAutoSuggestBox_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IAutoSuggestBox_adaptor::Text)->_put_Text(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Text;
		struct : property {
			ptr<Style> get() { Style* value; hrcheck(enc(&IAutoSuggestBox_adaptor::TextBoxStyle)->_get_TextBoxStyle(&value)); return from_abi(value); }
			ptr<Style> operator()() { return get(); }
			operator ptr<Style> () { return get(); }
			ptr<Style> operator->() { return get(); }
			void put(pptr<Style> value) { hrcheck(enc(&IAutoSuggestBox_adaptor::TextBoxStyle)->_put_TextBoxStyle(value)); }
			void operator=(pptr<Style> value) { put(value); }
			void operator()(pptr<Style> value) { put(value); }
		} TextBoxStyle;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAutoSuggestBox_adaptor::TextMemberPath)->_get_TextMemberPath(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IAutoSuggestBox_adaptor::TextMemberPath)->_put_TextMemberPath(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} TextMemberPath;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAutoSuggestBox_adaptor::UpdateTextOnSelect)->_get_UpdateTextOnSelect(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IAutoSuggestBox_adaptor::UpdateTextOnSelect)->_put_UpdateTextOnSelect(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} UpdateTextOnSelect;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AutoSuggestBox>, ptr<AutoSuggestBoxSuggestionChosenEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAutoSuggestBox_adaptor::SuggestionChosen)->_add_SuggestionChosen(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAutoSuggestBox_adaptor::SuggestionChosen)->_remove_SuggestionChosen(token)); }
		} SuggestionChosen;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AutoSuggestBox>, ptr<AutoSuggestBoxTextChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAutoSuggestBox_adaptor::TextChanged)->_add_TextChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAutoSuggestBox_adaptor::TextChanged)->_remove_TextChanged(token)); }
		} TextChanged;
	};
	IAutoSuggestBox_adaptor() {}
};
template<typename X> struct adapt<IAutoSuggestBox, X> : Windows::UI::Xaml::Controls::IAutoSuggestBox_adaptor<X> { typedef adapt IAutoSuggestBox; };
struct IAutoSuggestBox : IAutoSuggestBox_raw, generate<IAutoSuggestBox> {};

// IAutoSuggestBoxStatics
struct IAutoSuggestBoxStatics : IInspectable {
	virtual STDMETHODIMP _get_MaxSuggestionListHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsSuggestionListOpenProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextMemberPathProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_UpdateTextOnSelectProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlaceholderTextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AutoMaximizeSuggestionAreaProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextBoxStyleProperty(DependencyProperty* *value);
};

// IAutoSuggestBox2
struct IAutoSuggestBox2_raw : IInspectable {
	virtual STDMETHODIMP _get_QueryIcon(IconElement* *value);
	virtual STDMETHODIMP _put_QueryIcon(IconElement* value);
	virtual STDMETHODIMP _add_QuerySubmitted(Foundation::TypedEventHandler<AutoSuggestBox*, AutoSuggestBoxQuerySubmittedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_QuerySubmitted(Foundation::EventRegistrationToken token);
};
template<typename X> struct IAutoSuggestBox2_adaptor : X {
	union {
		struct : property {
			ptr<IconElement> get() { IconElement* value; hrcheck(enc(&IAutoSuggestBox2_adaptor::QueryIcon)->_get_QueryIcon(&value)); return from_abi(value); }
			ptr<IconElement> operator()() { return get(); }
			operator ptr<IconElement> () { return get(); }
			ptr<IconElement> operator->() { return get(); }
			void put(pptr<IconElement> value) { hrcheck(enc(&IAutoSuggestBox2_adaptor::QueryIcon)->_put_QueryIcon(value)); }
			void operator=(pptr<IconElement> value) { put(value); }
			void operator()(pptr<IconElement> value) { put(value); }
		} QueryIcon;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AutoSuggestBox>, ptr<AutoSuggestBoxQuerySubmittedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAutoSuggestBox2_adaptor::QuerySubmitted)->_add_QuerySubmitted(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAutoSuggestBox2_adaptor::QuerySubmitted)->_remove_QuerySubmitted(token)); }
		} QuerySubmitted;
	};
	IAutoSuggestBox2_adaptor() {}
};
template<typename X> struct adapt<IAutoSuggestBox2, X> : Windows::UI::Xaml::Controls::IAutoSuggestBox2_adaptor<X> { typedef adapt IAutoSuggestBox2; };
struct IAutoSuggestBox2 : IAutoSuggestBox2_raw, generate<IAutoSuggestBox2> {};

// IAutoSuggestBoxStatics2
struct IAutoSuggestBoxStatics2 : IInspectable {
	virtual STDMETHODIMP _get_QueryIconProperty(DependencyProperty* *value);
};

// IAutoSuggestBox3
struct IAutoSuggestBox3_raw : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayMode(Controls::LightDismissOverlayMode *value);
	virtual STDMETHODIMP _put_LightDismissOverlayMode(Controls::LightDismissOverlayMode value);
};
template<typename X> struct IAutoSuggestBox3_adaptor : X {
	union {
		struct : property {
			Controls::LightDismissOverlayMode get() { Controls::LightDismissOverlayMode value; hrcheck(enc(&IAutoSuggestBox3_adaptor::LightDismissOverlayMode)->_get_LightDismissOverlayMode(&value)); return value; }
			Controls::LightDismissOverlayMode operator()() { return get(); }
			operator Controls::LightDismissOverlayMode () { return get(); }
			void put(Controls::LightDismissOverlayMode value) { hrcheck(enc(&IAutoSuggestBox3_adaptor::LightDismissOverlayMode)->_put_LightDismissOverlayMode(value)); }
			void operator=(Controls::LightDismissOverlayMode value) { put(value); }
			void operator()(Controls::LightDismissOverlayMode value) { put(value); }
		} LightDismissOverlayMode;
	};
	IAutoSuggestBox3_adaptor() {}
};
template<typename X> struct adapt<IAutoSuggestBox3, X> : Windows::UI::Xaml::Controls::IAutoSuggestBox3_adaptor<X> { typedef adapt IAutoSuggestBox3; };
struct IAutoSuggestBox3 : IAutoSuggestBox3_raw, generate<IAutoSuggestBox3> {};

// IAutoSuggestBoxStatics3
struct IAutoSuggestBoxStatics3 : IInspectable {
	virtual STDMETHODIMP _get_LightDismissOverlayModeProperty(DependencyProperty* *value);
};

// ICommandBarOverflowPresenter
struct ICommandBarOverflowPresenter : IInspectable, generate<ICommandBarOverflowPresenter> {};

// ICommandBarOverflowPresenterFactory
struct ICommandBarOverflowPresenterFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, CommandBarOverflowPresenter* *instance);
};

// IContentDialog
struct IContentDialog_raw : IInspectable {
	virtual STDMETHODIMP _get_Title(IInspectable* *value);
	virtual STDMETHODIMP _put_Title(IInspectable* value);
	virtual STDMETHODIMP _get_TitleTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_TitleTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_FullSizeDesired(bool *value);
	virtual STDMETHODIMP _put_FullSizeDesired(bool value);
	virtual STDMETHODIMP _get_PrimaryButtonText(HSTRING *value);
	virtual STDMETHODIMP _put_PrimaryButtonText(HSTRING value);
	virtual STDMETHODIMP _get_SecondaryButtonText(HSTRING *value);
	virtual STDMETHODIMP _put_SecondaryButtonText(HSTRING value);
	virtual STDMETHODIMP _get_PrimaryButtonCommand(Input::ICommand* *value);
	virtual STDMETHODIMP _put_PrimaryButtonCommand(Input::ICommand* value);
	virtual STDMETHODIMP _get_SecondaryButtonCommand(Input::ICommand* *value);
	virtual STDMETHODIMP _put_SecondaryButtonCommand(Input::ICommand* value);
	virtual STDMETHODIMP _get_PrimaryButtonCommandParameter(IInspectable* *value);
	virtual STDMETHODIMP _put_PrimaryButtonCommandParameter(IInspectable* value);
	virtual STDMETHODIMP _get_SecondaryButtonCommandParameter(IInspectable* *value);
	virtual STDMETHODIMP _put_SecondaryButtonCommandParameter(IInspectable* value);
	virtual STDMETHODIMP _get_IsPrimaryButtonEnabled(bool *value);
	virtual STDMETHODIMP _put_IsPrimaryButtonEnabled(bool value);
	virtual STDMETHODIMP _get_IsSecondaryButtonEnabled(bool *value);
	virtual STDMETHODIMP _put_IsSecondaryButtonEnabled(bool value);
	virtual STDMETHODIMP _add_Closing(Foundation::TypedEventHandler<ContentDialog*, ContentDialogClosingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Closing(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Closed(Foundation::TypedEventHandler<ContentDialog*, ContentDialogClosedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Closed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Opened(Foundation::TypedEventHandler<ContentDialog*, ContentDialogOpenedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Opened(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PrimaryButtonClick(Foundation::TypedEventHandler<ContentDialog*, ContentDialogButtonClickEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PrimaryButtonClick(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_SecondaryButtonClick(Foundation::TypedEventHandler<ContentDialog*, ContentDialogButtonClickEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SecondaryButtonClick(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _Hide();
	virtual STDMETHODIMP _ShowAsync(Foundation::IAsyncOperation<ContentDialogResult>* *returnValue);
};
template<typename X> struct IContentDialog_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IContentDialog_adaptor::FullSizeDesired)->_get_FullSizeDesired(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IContentDialog_adaptor::FullSizeDesired)->_put_FullSizeDesired(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} FullSizeDesired;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IContentDialog_adaptor::IsPrimaryButtonEnabled)->_get_IsPrimaryButtonEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IContentDialog_adaptor::IsPrimaryButtonEnabled)->_put_IsPrimaryButtonEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsPrimaryButtonEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IContentDialog_adaptor::IsSecondaryButtonEnabled)->_get_IsSecondaryButtonEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IContentDialog_adaptor::IsSecondaryButtonEnabled)->_put_IsSecondaryButtonEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSecondaryButtonEnabled;
		struct : property {
			ptr<Input::ICommand> get() { Input::ICommand* value; hrcheck(enc(&IContentDialog_adaptor::PrimaryButtonCommand)->_get_PrimaryButtonCommand(&value)); return from_abi(value); }
			ptr<Input::ICommand> operator()() { return get(); }
			operator ptr<Input::ICommand> () { return get(); }
			ptr<Input::ICommand> operator->() { return get(); }
			void put(pptr<Input::ICommand> value) { hrcheck(enc(&IContentDialog_adaptor::PrimaryButtonCommand)->_put_PrimaryButtonCommand(value)); }
			void operator=(pptr<Input::ICommand> value) { put(value); }
			void operator()(pptr<Input::ICommand> value) { put(value); }
		} PrimaryButtonCommand;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IContentDialog_adaptor::PrimaryButtonCommandParameter)->_get_PrimaryButtonCommandParameter(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IContentDialog_adaptor::PrimaryButtonCommandParameter)->_put_PrimaryButtonCommandParameter(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} PrimaryButtonCommandParameter;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IContentDialog_adaptor::PrimaryButtonText)->_get_PrimaryButtonText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IContentDialog_adaptor::PrimaryButtonText)->_put_PrimaryButtonText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PrimaryButtonText;
		struct : property {
			ptr<Input::ICommand> get() { Input::ICommand* value; hrcheck(enc(&IContentDialog_adaptor::SecondaryButtonCommand)->_get_SecondaryButtonCommand(&value)); return from_abi(value); }
			ptr<Input::ICommand> operator()() { return get(); }
			operator ptr<Input::ICommand> () { return get(); }
			ptr<Input::ICommand> operator->() { return get(); }
			void put(pptr<Input::ICommand> value) { hrcheck(enc(&IContentDialog_adaptor::SecondaryButtonCommand)->_put_SecondaryButtonCommand(value)); }
			void operator=(pptr<Input::ICommand> value) { put(value); }
			void operator()(pptr<Input::ICommand> value) { put(value); }
		} SecondaryButtonCommand;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IContentDialog_adaptor::SecondaryButtonCommandParameter)->_get_SecondaryButtonCommandParameter(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IContentDialog_adaptor::SecondaryButtonCommandParameter)->_put_SecondaryButtonCommandParameter(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} SecondaryButtonCommandParameter;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IContentDialog_adaptor::SecondaryButtonText)->_get_SecondaryButtonText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IContentDialog_adaptor::SecondaryButtonText)->_put_SecondaryButtonText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} SecondaryButtonText;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IContentDialog_adaptor::Title)->_get_Title(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IContentDialog_adaptor::Title)->_put_Title(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Title;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IContentDialog_adaptor::TitleTemplate)->_get_TitleTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IContentDialog_adaptor::TitleTemplate)->_put_TitleTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} TitleTemplate;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ContentDialog>, ptr<ContentDialogClosedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IContentDialog_adaptor::Closed)->_add_Closed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IContentDialog_adaptor::Closed)->_remove_Closed(token)); }
		} Closed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ContentDialog>, ptr<ContentDialogClosingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IContentDialog_adaptor::Closing)->_add_Closing(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IContentDialog_adaptor::Closing)->_remove_Closing(token)); }
		} Closing;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ContentDialog>, ptr<ContentDialogOpenedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IContentDialog_adaptor::Opened)->_add_Opened(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IContentDialog_adaptor::Opened)->_remove_Opened(token)); }
		} Opened;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ContentDialog>, ptr<ContentDialogButtonClickEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IContentDialog_adaptor::PrimaryButtonClick)->_add_PrimaryButtonClick(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IContentDialog_adaptor::PrimaryButtonClick)->_remove_PrimaryButtonClick(token)); }
		} PrimaryButtonClick;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ContentDialog>, ptr<ContentDialogButtonClickEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IContentDialog_adaptor::SecondaryButtonClick)->_add_SecondaryButtonClick(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IContentDialog_adaptor::SecondaryButtonClick)->_remove_SecondaryButtonClick(token)); }
		} SecondaryButtonClick;
	};
	void Hide() { hrcheck(X::get()->_Hide()); }
	ptr<Foundation::IAsyncOperation<ContentDialogResult>> ShowAsync() { Foundation::IAsyncOperation<ContentDialogResult>* returnValue; hrcheck(X::get()->_ShowAsync(&returnValue)); return from_abi(returnValue); }
	IContentDialog_adaptor() {}
};
template<typename X> struct adapt<IContentDialog, X> : Windows::UI::Xaml::Controls::IContentDialog_adaptor<X> { typedef adapt IContentDialog; };
struct IContentDialog : IContentDialog_raw, generate<IContentDialog> {};

// IContentDialogStatics
struct IContentDialogStatics : IInspectable {
	virtual STDMETHODIMP _get_TitleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TitleTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_FullSizeDesiredProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PrimaryButtonTextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SecondaryButtonTextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PrimaryButtonCommandProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SecondaryButtonCommandProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PrimaryButtonCommandParameterProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SecondaryButtonCommandParameterProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsPrimaryButtonEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsSecondaryButtonEnabledProperty(DependencyProperty* *value);
};

// IContentDialogFactory
struct IContentDialogFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ContentDialog* *instance);
};

// IContentDialog2
struct IContentDialog2_raw : IInspectable {
	virtual STDMETHODIMP _get_CloseButtonText(HSTRING *value);
	virtual STDMETHODIMP _put_CloseButtonText(HSTRING value);
	virtual STDMETHODIMP _get_CloseButtonCommand(Input::ICommand* *value);
	virtual STDMETHODIMP _put_CloseButtonCommand(Input::ICommand* value);
	virtual STDMETHODIMP _get_CloseButtonCommandParameter(IInspectable* *value);
	virtual STDMETHODIMP _put_CloseButtonCommandParameter(IInspectable* value);
	virtual STDMETHODIMP _get_PrimaryButtonStyle(Style* *value);
	virtual STDMETHODIMP _put_PrimaryButtonStyle(Style* value);
	virtual STDMETHODIMP _get_SecondaryButtonStyle(Style* *value);
	virtual STDMETHODIMP _put_SecondaryButtonStyle(Style* value);
	virtual STDMETHODIMP _get_CloseButtonStyle(Style* *value);
	virtual STDMETHODIMP _put_CloseButtonStyle(Style* value);
	virtual STDMETHODIMP _get_DefaultButton(ContentDialogButton *value);
	virtual STDMETHODIMP _put_DefaultButton(ContentDialogButton value);
	virtual STDMETHODIMP _add_CloseButtonClick(Foundation::TypedEventHandler<ContentDialog*, ContentDialogButtonClickEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CloseButtonClick(Foundation::EventRegistrationToken token);
};
template<typename X> struct IContentDialog2_adaptor : X {
	union {
		struct : property {
			ptr<Input::ICommand> get() { Input::ICommand* value; hrcheck(enc(&IContentDialog2_adaptor::CloseButtonCommand)->_get_CloseButtonCommand(&value)); return from_abi(value); }
			ptr<Input::ICommand> operator()() { return get(); }
			operator ptr<Input::ICommand> () { return get(); }
			ptr<Input::ICommand> operator->() { return get(); }
			void put(pptr<Input::ICommand> value) { hrcheck(enc(&IContentDialog2_adaptor::CloseButtonCommand)->_put_CloseButtonCommand(value)); }
			void operator=(pptr<Input::ICommand> value) { put(value); }
			void operator()(pptr<Input::ICommand> value) { put(value); }
		} CloseButtonCommand;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IContentDialog2_adaptor::CloseButtonCommandParameter)->_get_CloseButtonCommandParameter(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IContentDialog2_adaptor::CloseButtonCommandParameter)->_put_CloseButtonCommandParameter(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} CloseButtonCommandParameter;
		struct : property {
			ptr<Style> get() { Style* value; hrcheck(enc(&IContentDialog2_adaptor::CloseButtonStyle)->_get_CloseButtonStyle(&value)); return from_abi(value); }
			ptr<Style> operator()() { return get(); }
			operator ptr<Style> () { return get(); }
			ptr<Style> operator->() { return get(); }
			void put(pptr<Style> value) { hrcheck(enc(&IContentDialog2_adaptor::CloseButtonStyle)->_put_CloseButtonStyle(value)); }
			void operator=(pptr<Style> value) { put(value); }
			void operator()(pptr<Style> value) { put(value); }
		} CloseButtonStyle;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IContentDialog2_adaptor::CloseButtonText)->_get_CloseButtonText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IContentDialog2_adaptor::CloseButtonText)->_put_CloseButtonText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} CloseButtonText;
		struct : property {
			ContentDialogButton get() { ContentDialogButton value; hrcheck(enc(&IContentDialog2_adaptor::DefaultButton)->_get_DefaultButton(&value)); return value; }
			ContentDialogButton operator()() { return get(); }
			operator ContentDialogButton () { return get(); }
			void put(ContentDialogButton value) { hrcheck(enc(&IContentDialog2_adaptor::DefaultButton)->_put_DefaultButton(value)); }
			void operator=(ContentDialogButton value) { put(value); }
			void operator()(ContentDialogButton value) { put(value); }
		} DefaultButton;
		struct : property {
			ptr<Style> get() { Style* value; hrcheck(enc(&IContentDialog2_adaptor::PrimaryButtonStyle)->_get_PrimaryButtonStyle(&value)); return from_abi(value); }
			ptr<Style> operator()() { return get(); }
			operator ptr<Style> () { return get(); }
			ptr<Style> operator->() { return get(); }
			void put(pptr<Style> value) { hrcheck(enc(&IContentDialog2_adaptor::PrimaryButtonStyle)->_put_PrimaryButtonStyle(value)); }
			void operator=(pptr<Style> value) { put(value); }
			void operator()(pptr<Style> value) { put(value); }
		} PrimaryButtonStyle;
		struct : property {
			ptr<Style> get() { Style* value; hrcheck(enc(&IContentDialog2_adaptor::SecondaryButtonStyle)->_get_SecondaryButtonStyle(&value)); return from_abi(value); }
			ptr<Style> operator()() { return get(); }
			operator ptr<Style> () { return get(); }
			ptr<Style> operator->() { return get(); }
			void put(pptr<Style> value) { hrcheck(enc(&IContentDialog2_adaptor::SecondaryButtonStyle)->_put_SecondaryButtonStyle(value)); }
			void operator=(pptr<Style> value) { put(value); }
			void operator()(pptr<Style> value) { put(value); }
		} SecondaryButtonStyle;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ContentDialog>, ptr<ContentDialogButtonClickEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IContentDialog2_adaptor::CloseButtonClick)->_add_CloseButtonClick(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IContentDialog2_adaptor::CloseButtonClick)->_remove_CloseButtonClick(token)); }
		} CloseButtonClick;
	};
	IContentDialog2_adaptor() {}
};
template<typename X> struct adapt<IContentDialog2, X> : Windows::UI::Xaml::Controls::IContentDialog2_adaptor<X> { typedef adapt IContentDialog2; };
struct IContentDialog2 : IContentDialog2_raw, generate<IContentDialog2> {};

// IContentDialogStatics2
struct IContentDialogStatics2 : IInspectable {
	virtual STDMETHODIMP _get_CloseButtonTextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CloseButtonCommandProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CloseButtonCommandParameterProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PrimaryButtonStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SecondaryButtonStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CloseButtonStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DefaultButtonProperty(DependencyProperty* *value);
};

// IContentDialog3
struct IContentDialog3_raw : IInspectable {
	virtual STDMETHODIMP _ShowAsyncWithPlacement(ContentDialogPlacement placement, Foundation::IAsyncOperation<ContentDialogResult>* *returnValue);
};
template<typename X> struct IContentDialog3_adaptor : X {
	ptr<Foundation::IAsyncOperation<ContentDialogResult>> ShowAsync(ContentDialogPlacement placement) { Foundation::IAsyncOperation<ContentDialogResult>* returnValue; hrcheck(X::get()->_ShowAsyncWithPlacement(placement, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IContentDialog3, X> : Windows::UI::Xaml::Controls::IContentDialog3_adaptor<X> { typedef adapt IContentDialog3; };
struct IContentDialog3 : IContentDialog3_raw, generate<IContentDialog3> {};

// IFlyoutPresenter
struct IFlyoutPresenter : IInspectable, generate<IFlyoutPresenter> {};

// IFlyoutPresenterFactory
struct IFlyoutPresenterFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, FlyoutPresenter* *instance);
};

// IFrame
struct IFrame_raw : IInspectable {
	virtual STDMETHODIMP _get_CacheSize(int *value);
	virtual STDMETHODIMP _put_CacheSize(int value);
	virtual STDMETHODIMP _get_CanGoBack(bool *value);
	virtual STDMETHODIMP _get_CanGoForward(bool *value);
	virtual STDMETHODIMP _get_CurrentSourcePageType(Interop::TypeName *value);
	virtual STDMETHODIMP _get_SourcePageType(Interop::TypeName *value);
	virtual STDMETHODIMP _put_SourcePageType(Interop::TypeName value);
	virtual STDMETHODIMP _get_BackStackDepth(int *value);
	virtual STDMETHODIMP _add_Navigated(Navigation::NavigatedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Navigated(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Navigating(Navigation::NavigatingCancelEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Navigating(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_NavigationFailed(Navigation::NavigationFailedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_NavigationFailed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_NavigationStopped(Navigation::NavigationStoppedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_NavigationStopped(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _GoBack();
	virtual STDMETHODIMP _GoForward();
	virtual STDMETHODIMP _Navigate(Interop::TypeName sourcePageType, IInspectable* parameter, bool *returnValue);
	virtual STDMETHODIMP _GetNavigationState(HSTRING *returnValue);
	virtual STDMETHODIMP _SetNavigationState(HSTRING navigationState);
};
template<typename X> struct IFrame_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IFrame_adaptor::BackStackDepth)->_get_BackStackDepth(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} BackStackDepth;
		struct : property {
			int get() { int value; hrcheck(enc(&IFrame_adaptor::CacheSize)->_get_CacheSize(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IFrame_adaptor::CacheSize)->_put_CacheSize(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} CacheSize;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFrame_adaptor::CanGoBack)->_get_CanGoBack(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanGoBack;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFrame_adaptor::CanGoForward)->_get_CanGoForward(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanGoForward;
		struct : property {
			Interop::TypeName get() { Interop::TypeName value; hrcheck(enc(&IFrame_adaptor::CurrentSourcePageType)->_get_CurrentSourcePageType(&value)); return value; }
			Interop::TypeName operator()() { return get(); }
			operator Interop::TypeName () { return get(); }
		} CurrentSourcePageType;
		struct : property {
			Interop::TypeName get() { Interop::TypeName value; hrcheck(enc(&IFrame_adaptor::SourcePageType)->_get_SourcePageType(&value)); return value; }
			Interop::TypeName operator()() { return get(); }
			operator Interop::TypeName () { return get(); }
			void put(const Interop::TypeName& value) { hrcheck(enc(&IFrame_adaptor::SourcePageType)->_put_SourcePageType(value)); }
			void operator=(const Interop::TypeName& value) { put(value); }
			void operator()(const Interop::TypeName& value) { put(value); }
		} SourcePageType;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Navigation::NavigatedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IFrame_adaptor::Navigated)->_add_Navigated(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IFrame_adaptor::Navigated)->_remove_Navigated(token)); }
		} Navigated;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Navigation::NavigatingCancelEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IFrame_adaptor::Navigating)->_add_Navigating(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IFrame_adaptor::Navigating)->_remove_Navigating(token)); }
		} Navigating;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Navigation::NavigationFailedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IFrame_adaptor::NavigationFailed)->_add_NavigationFailed(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IFrame_adaptor::NavigationFailed)->_remove_NavigationFailed(token)); }
		} NavigationFailed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Navigation::NavigationStoppedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IFrame_adaptor::NavigationStopped)->_add_NavigationStopped(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IFrame_adaptor::NavigationStopped)->_remove_NavigationStopped(token)); }
		} NavigationStopped;
	};
	void GoBack() { hrcheck(X::get()->_GoBack()); }
	void GoForward() { hrcheck(X::get()->_GoForward()); }
	bool Navigate(const Interop::TypeName& sourcePageType, object_ref parameter) { bool returnValue; hrcheck(X::get()->_Navigate(sourcePageType, parameter, &returnValue)); return returnValue; }
	hstring GetNavigationState() { HSTRING returnValue; hrcheck(X::get()->_GetNavigationState(&returnValue)); return from_abi(returnValue); }
	void SetNavigationState(hstring_ref navigationState) { hrcheck(X::get()->_SetNavigationState(navigationState)); }
	IFrame_adaptor() {}
};
template<typename X> struct adapt<IFrame, X> : Windows::UI::Xaml::Controls::IFrame_adaptor<X> { typedef adapt IFrame; };
struct IFrame : IFrame_raw, generate<IFrame> {};

// IFrameStatics
struct IFrameStatics : IInspectable {
	virtual STDMETHODIMP _get_CacheSizeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CanGoBackProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CanGoForwardProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CurrentSourcePageTypeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SourcePageTypeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BackStackDepthProperty(DependencyProperty* *value);
};

// IFrameFactory
struct IFrameFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Frame* *instance);
};

// IFrame2
struct IFrame2_raw : IInspectable {
	virtual STDMETHODIMP _get_BackStack(Foundation::Collections::IVector<Navigation::PageStackEntry*>* *value);
	virtual STDMETHODIMP _get_ForwardStack(Foundation::Collections::IVector<Navigation::PageStackEntry*>* *value);
	virtual STDMETHODIMP _Navigate(Interop::TypeName sourcePageType, IInspectable* parameter, Media::Animation::NavigationTransitionInfo* infoOverride, bool *returnValue);
};
template<typename X> struct IFrame2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Navigation::PageStackEntry>>> get() { Foundation::Collections::IVector<Navigation::PageStackEntry*>* value; hrcheck(enc(&IFrame2_adaptor::BackStack)->_get_BackStack(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Navigation::PageStackEntry>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Navigation::PageStackEntry>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Navigation::PageStackEntry>>> operator->() { return get(); }
		} BackStack;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Navigation::PageStackEntry>>> get() { Foundation::Collections::IVector<Navigation::PageStackEntry*>* value; hrcheck(enc(&IFrame2_adaptor::ForwardStack)->_get_ForwardStack(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Navigation::PageStackEntry>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Navigation::PageStackEntry>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Navigation::PageStackEntry>>> operator->() { return get(); }
		} ForwardStack;
	};
	bool Navigate(const Interop::TypeName& sourcePageType, object_ref parameter, pptr<Media::Animation::NavigationTransitionInfo> infoOverride) { bool returnValue; hrcheck(X::get()->_Navigate(sourcePageType, parameter, infoOverride, &returnValue)); return returnValue; }
	IFrame2_adaptor() {}
};
template<typename X> struct adapt<IFrame2, X> : Windows::UI::Xaml::Controls::IFrame2_adaptor<X> { typedef adapt IFrame2; };
struct IFrame2 : IFrame2_raw, generate<IFrame2> {};

// IFrameStatics2
struct IFrameStatics2 : IInspectable {
	virtual STDMETHODIMP _get_BackStackProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ForwardStackProperty(DependencyProperty* *value);
};

// IFrame3
struct IFrame3_raw : IInspectable {
	virtual STDMETHODIMP _GoBack(Media::Animation::NavigationTransitionInfo* transitionInfoOverride);
};
template<typename X> struct IFrame3_adaptor : X {
	void GoBack(pptr<Media::Animation::NavigationTransitionInfo> transitionInfoOverride) { hrcheck(X::get()->_GoBack(transitionInfoOverride)); }
};
template<typename X> struct adapt<IFrame3, X> : Windows::UI::Xaml::Controls::IFrame3_adaptor<X> { typedef adapt IFrame3; };
struct IFrame3 : IFrame3_raw, generate<IFrame3> {};

// IFrame4
struct IFrame4_raw : IInspectable {
	virtual STDMETHODIMP _SetNavigationStateWithNavigationControl(HSTRING navigationState, bool suppressNavigate);
};
template<typename X> struct IFrame4_adaptor : X {
	void SetNavigationState(hstring_ref navigationState, bool suppressNavigate) { hrcheck(X::get()->_SetNavigationStateWithNavigationControl(navigationState, suppressNavigate)); }
};
template<typename X> struct adapt<IFrame4, X> : Windows::UI::Xaml::Controls::IFrame4_adaptor<X> { typedef adapt IFrame4; };
struct IFrame4 : IFrame4_raw, generate<IFrame4> {};

// IMenuFlyoutItem
struct IMenuFlyoutItem_raw : IInspectable {
	virtual STDMETHODIMP _get_Text(HSTRING *value);
	virtual STDMETHODIMP _put_Text(HSTRING value);
	virtual STDMETHODIMP _get_Command(Input::ICommand* *value);
	virtual STDMETHODIMP _put_Command(Input::ICommand* value);
	virtual STDMETHODIMP _get_CommandParameter(IInspectable* *value);
	virtual STDMETHODIMP _put_CommandParameter(IInspectable* value);
	virtual STDMETHODIMP _add_Click(RoutedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Click(Foundation::EventRegistrationToken token);
};
template<typename X> struct IMenuFlyoutItem_adaptor : X {
	union {
		struct : property {
			ptr<Input::ICommand> get() { Input::ICommand* value; hrcheck(enc(&IMenuFlyoutItem_adaptor::Command)->_get_Command(&value)); return from_abi(value); }
			ptr<Input::ICommand> operator()() { return get(); }
			operator ptr<Input::ICommand> () { return get(); }
			ptr<Input::ICommand> operator->() { return get(); }
			void put(pptr<Input::ICommand> value) { hrcheck(enc(&IMenuFlyoutItem_adaptor::Command)->_put_Command(value)); }
			void operator=(pptr<Input::ICommand> value) { put(value); }
			void operator()(pptr<Input::ICommand> value) { put(value); }
		} Command;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IMenuFlyoutItem_adaptor::CommandParameter)->_get_CommandParameter(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IMenuFlyoutItem_adaptor::CommandParameter)->_put_CommandParameter(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} CommandParameter;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMenuFlyoutItem_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IMenuFlyoutItem_adaptor::Text)->_put_Text(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Text;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RoutedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IMenuFlyoutItem_adaptor::Click)->_add_Click(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IMenuFlyoutItem_adaptor::Click)->_remove_Click(token)); }
		} Click;
	};
	IMenuFlyoutItem_adaptor() {}
};
template<typename X> struct adapt<IMenuFlyoutItem, X> : Windows::UI::Xaml::Controls::IMenuFlyoutItem_adaptor<X> { typedef adapt IMenuFlyoutItem; };
struct IMenuFlyoutItem : IMenuFlyoutItem_raw, generate<IMenuFlyoutItem> {};

// IMenuFlyoutItemStatics
struct IMenuFlyoutItemStatics : IInspectable {
	virtual STDMETHODIMP _get_TextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CommandProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CommandParameterProperty(DependencyProperty* *value);
};

// IMenuFlyoutItemFactory
struct IMenuFlyoutItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, MenuFlyoutItem* *instance);
};

// IMenuFlyoutItem2
struct IMenuFlyoutItem2_raw : IInspectable {
	virtual STDMETHODIMP _get_Icon(IconElement* *value);
	virtual STDMETHODIMP _put_Icon(IconElement* value);
};
template<typename X> struct IMenuFlyoutItem2_adaptor : X {
	union {
		struct : property {
			ptr<IconElement> get() { IconElement* value; hrcheck(enc(&IMenuFlyoutItem2_adaptor::Icon)->_get_Icon(&value)); return from_abi(value); }
			ptr<IconElement> operator()() { return get(); }
			operator ptr<IconElement> () { return get(); }
			ptr<IconElement> operator->() { return get(); }
			void put(pptr<IconElement> value) { hrcheck(enc(&IMenuFlyoutItem2_adaptor::Icon)->_put_Icon(value)); }
			void operator=(pptr<IconElement> value) { put(value); }
			void operator()(pptr<IconElement> value) { put(value); }
		} Icon;
	};
	IMenuFlyoutItem2_adaptor() {}
};
template<typename X> struct adapt<IMenuFlyoutItem2, X> : Windows::UI::Xaml::Controls::IMenuFlyoutItem2_adaptor<X> { typedef adapt IMenuFlyoutItem2; };
struct IMenuFlyoutItem2 : IMenuFlyoutItem2_raw, generate<IMenuFlyoutItem2> {};

// IMenuFlyoutItemStatics2
struct IMenuFlyoutItemStatics2 : IInspectable {
	virtual STDMETHODIMP _get_IconProperty(DependencyProperty* *value);
};

// IMenuFlyoutItem3
struct IMenuFlyoutItem3_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyboardAcceleratorTextOverride(HSTRING *value);
	virtual STDMETHODIMP _put_KeyboardAcceleratorTextOverride(HSTRING value);
	virtual STDMETHODIMP _get_TemplateSettings(Primitives::MenuFlyoutItemTemplateSettings* *value);
};
template<typename X> struct IMenuFlyoutItem3_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMenuFlyoutItem3_adaptor::KeyboardAcceleratorTextOverride)->_get_KeyboardAcceleratorTextOverride(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IMenuFlyoutItem3_adaptor::KeyboardAcceleratorTextOverride)->_put_KeyboardAcceleratorTextOverride(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} KeyboardAcceleratorTextOverride;
		struct : property {
			ptr<Primitives::MenuFlyoutItemTemplateSettings> get() { Primitives::MenuFlyoutItemTemplateSettings* value; hrcheck(enc(&IMenuFlyoutItem3_adaptor::TemplateSettings)->_get_TemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::MenuFlyoutItemTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::MenuFlyoutItemTemplateSettings> () { return get(); }
			ptr<Primitives::MenuFlyoutItemTemplateSettings> operator->() { return get(); }
		} TemplateSettings;
	};
	IMenuFlyoutItem3_adaptor() {}
};
template<typename X> struct adapt<IMenuFlyoutItem3, X> : Windows::UI::Xaml::Controls::IMenuFlyoutItem3_adaptor<X> { typedef adapt IMenuFlyoutItem3; };
struct IMenuFlyoutItem3 : IMenuFlyoutItem3_raw, generate<IMenuFlyoutItem3> {};

// IMenuFlyoutItemStatics3
struct IMenuFlyoutItemStatics3 : IInspectable {
	virtual STDMETHODIMP _get_KeyboardAcceleratorTextOverrideProperty(DependencyProperty* *value);
};

// IMenuFlyoutPresenter
struct IMenuFlyoutPresenter : IInspectable, generate<IMenuFlyoutPresenter> {};

// IMenuFlyoutPresenterFactory
struct IMenuFlyoutPresenterFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, MenuFlyoutPresenter* *instance);
};

// IMenuFlyoutPresenter2
struct IMenuFlyoutPresenter2_raw : IInspectable {
	virtual STDMETHODIMP _get_TemplateSettings(Primitives::MenuFlyoutPresenterTemplateSettings* *value);
};
template<typename X> struct IMenuFlyoutPresenter2_adaptor : X {
	union {
		struct : property {
			ptr<Primitives::MenuFlyoutPresenterTemplateSettings> get() { Primitives::MenuFlyoutPresenterTemplateSettings* value; hrcheck(enc(&IMenuFlyoutPresenter2_adaptor::TemplateSettings)->_get_TemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::MenuFlyoutPresenterTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::MenuFlyoutPresenterTemplateSettings> () { return get(); }
			ptr<Primitives::MenuFlyoutPresenterTemplateSettings> operator->() { return get(); }
		} TemplateSettings;
	};
	IMenuFlyoutPresenter2_adaptor() {}
};
template<typename X> struct adapt<IMenuFlyoutPresenter2, X> : Windows::UI::Xaml::Controls::IMenuFlyoutPresenter2_adaptor<X> { typedef adapt IMenuFlyoutPresenter2; };
struct IMenuFlyoutPresenter2 : IMenuFlyoutPresenter2_raw, generate<IMenuFlyoutPresenter2> {};

// IMenuFlyoutSeparator
struct IMenuFlyoutSeparator : IInspectable, generate<IMenuFlyoutSeparator> {};

// IMenuFlyoutSeparatorFactory
struct IMenuFlyoutSeparatorFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, MenuFlyoutSeparator* *instance);
};

// IMenuFlyoutSubItem
struct IMenuFlyoutSubItem_raw : IInspectable {
	virtual STDMETHODIMP _get_Items(Foundation::Collections::IVector<MenuFlyoutItemBase*>* *value);
	virtual STDMETHODIMP _get_Text(HSTRING *value);
	virtual STDMETHODIMP _put_Text(HSTRING value);
};
template<typename X> struct IMenuFlyoutSubItem_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<MenuFlyoutItemBase>>> get() { Foundation::Collections::IVector<MenuFlyoutItemBase*>* value; hrcheck(enc(&IMenuFlyoutSubItem_adaptor::Items)->_get_Items(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<MenuFlyoutItemBase>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<MenuFlyoutItemBase>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<MenuFlyoutItemBase>>> operator->() { return get(); }
		} Items;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IMenuFlyoutSubItem_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IMenuFlyoutSubItem_adaptor::Text)->_put_Text(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Text;
	};
	IMenuFlyoutSubItem_adaptor() {}
};
template<typename X> struct adapt<IMenuFlyoutSubItem, X> : Windows::UI::Xaml::Controls::IMenuFlyoutSubItem_adaptor<X> { typedef adapt IMenuFlyoutSubItem; };
struct IMenuFlyoutSubItem : IMenuFlyoutSubItem_raw, generate<IMenuFlyoutSubItem> {};

// IMenuFlyoutSubItemStatics
struct IMenuFlyoutSubItemStatics : IInspectable {
	virtual STDMETHODIMP _get_TextProperty(DependencyProperty* *value);
};

// IMenuFlyoutSubItem2
struct IMenuFlyoutSubItem2_raw : IInspectable {
	virtual STDMETHODIMP _get_Icon(IconElement* *value);
	virtual STDMETHODIMP _put_Icon(IconElement* value);
};
template<typename X> struct IMenuFlyoutSubItem2_adaptor : X {
	union {
		struct : property {
			ptr<IconElement> get() { IconElement* value; hrcheck(enc(&IMenuFlyoutSubItem2_adaptor::Icon)->_get_Icon(&value)); return from_abi(value); }
			ptr<IconElement> operator()() { return get(); }
			operator ptr<IconElement> () { return get(); }
			ptr<IconElement> operator->() { return get(); }
			void put(pptr<IconElement> value) { hrcheck(enc(&IMenuFlyoutSubItem2_adaptor::Icon)->_put_Icon(value)); }
			void operator=(pptr<IconElement> value) { put(value); }
			void operator()(pptr<IconElement> value) { put(value); }
		} Icon;
	};
	IMenuFlyoutSubItem2_adaptor() {}
};
template<typename X> struct adapt<IMenuFlyoutSubItem2, X> : Windows::UI::Xaml::Controls::IMenuFlyoutSubItem2_adaptor<X> { typedef adapt IMenuFlyoutSubItem2; };
struct IMenuFlyoutSubItem2 : IMenuFlyoutSubItem2_raw, generate<IMenuFlyoutSubItem2> {};

// IMenuFlyoutSubItemStatics2
struct IMenuFlyoutSubItemStatics2 : IInspectable {
	virtual STDMETHODIMP _get_IconProperty(DependencyProperty* *value);
};

// IPage
struct IPage_raw : IInspectable {
	virtual STDMETHODIMP _get_Frame(Controls::Frame* *value);
	virtual STDMETHODIMP _get_NavigationCacheMode(Navigation::NavigationCacheMode *value);
	virtual STDMETHODIMP _put_NavigationCacheMode(Navigation::NavigationCacheMode value);
	virtual STDMETHODIMP _get_TopAppBar(AppBar* *value);
	virtual STDMETHODIMP _put_TopAppBar(AppBar* value);
	virtual STDMETHODIMP _get_BottomAppBar(AppBar* *value);
	virtual STDMETHODIMP _put_BottomAppBar(AppBar* value);
};
template<typename X> struct IPage_adaptor : X {
	union {
		struct : property {
			ptr<AppBar> get() { AppBar* value; hrcheck(enc(&IPage_adaptor::BottomAppBar)->_get_BottomAppBar(&value)); return from_abi(value); }
			ptr<AppBar> operator()() { return get(); }
			operator ptr<AppBar> () { return get(); }
			ptr<AppBar> operator->() { return get(); }
			void put(pptr<AppBar> value) { hrcheck(enc(&IPage_adaptor::BottomAppBar)->_put_BottomAppBar(value)); }
			void operator=(pptr<AppBar> value) { put(value); }
			void operator()(pptr<AppBar> value) { put(value); }
		} BottomAppBar;
		struct : property {
			ptr<Controls::Frame> get() { Controls::Frame* value; hrcheck(enc(&IPage_adaptor::Frame)->_get_Frame(&value)); return from_abi(value); }
			ptr<Controls::Frame> operator()() { return get(); }
			operator ptr<Controls::Frame> () { return get(); }
			ptr<Controls::Frame> operator->() { return get(); }
		} Frame;
		struct : property {
			Navigation::NavigationCacheMode get() { Navigation::NavigationCacheMode value; hrcheck(enc(&IPage_adaptor::NavigationCacheMode)->_get_NavigationCacheMode(&value)); return value; }
			Navigation::NavigationCacheMode operator()() { return get(); }
			operator Navigation::NavigationCacheMode () { return get(); }
			void put(Navigation::NavigationCacheMode value) { hrcheck(enc(&IPage_adaptor::NavigationCacheMode)->_put_NavigationCacheMode(value)); }
			void operator=(Navigation::NavigationCacheMode value) { put(value); }
			void operator()(Navigation::NavigationCacheMode value) { put(value); }
		} NavigationCacheMode;
		struct : property {
			ptr<AppBar> get() { AppBar* value; hrcheck(enc(&IPage_adaptor::TopAppBar)->_get_TopAppBar(&value)); return from_abi(value); }
			ptr<AppBar> operator()() { return get(); }
			operator ptr<AppBar> () { return get(); }
			ptr<AppBar> operator->() { return get(); }
			void put(pptr<AppBar> value) { hrcheck(enc(&IPage_adaptor::TopAppBar)->_put_TopAppBar(value)); }
			void operator=(pptr<AppBar> value) { put(value); }
			void operator()(pptr<AppBar> value) { put(value); }
		} TopAppBar;
	};
	IPage_adaptor() {}
};
template<typename X> struct adapt<IPage, X> : Windows::UI::Xaml::Controls::IPage_adaptor<X> { typedef adapt IPage; };
struct IPage : IPage_raw, generate<IPage> {};

// IPageOverrides
struct IPageOverrides_raw : IInspectable {
	virtual STDMETHODIMP _OnNavigatedFrom(Navigation::NavigationEventArgs* e) = 0;
	virtual STDMETHODIMP _OnNavigatedTo(Navigation::NavigationEventArgs* e) = 0;
	virtual STDMETHODIMP _OnNavigatingFrom(Navigation::NavigatingCancelEventArgs* e) = 0;
};
template<typename X> struct IPageOverrides_adaptor : X {
	void OnNavigatedFrom(pptr<Navigation::NavigationEventArgs> e) { hrcheck(X::get()->_OnNavigatedFrom(e)); }
	void OnNavigatedTo(pptr<Navigation::NavigationEventArgs> e) { hrcheck(X::get()->_OnNavigatedTo(e)); }
	void OnNavigatingFrom(pptr<Navigation::NavigatingCancelEventArgs> e) { hrcheck(X::get()->_OnNavigatingFrom(e)); }
};
template<typename X> struct adapt<IPageOverrides, X> : Windows::UI::Xaml::Controls::IPageOverrides_adaptor<X> { typedef adapt IPageOverrides; };
template<typename X> struct IPageOverrides_unadaptor : X {
	STDMETHODIMP _OnNavigatedFrom(Navigation::NavigationEventArgs* e) { return hrtry([&, this] { X::get()->OnNavigatedFrom(e); }); }
	STDMETHODIMP _OnNavigatedTo(Navigation::NavigationEventArgs* e) { return hrtry([&, this] { X::get()->OnNavigatedTo(e); }); }
	STDMETHODIMP _OnNavigatingFrom(Navigation::NavigatingCancelEventArgs* e) { return hrtry([&, this] { X::get()->OnNavigatingFrom(e); }); }
};
template<typename X> struct unadapt<IPageOverrides, X> : Windows::UI::Xaml::Controls::IPageOverrides_unadaptor<X> {};
struct IPageOverrides : IPageOverrides_raw, generate<IPageOverrides> {};

// IPageStatics
struct IPageStatics : IInspectable {
	virtual STDMETHODIMP _get_FrameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TopAppBarProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BottomAppBarProperty(DependencyProperty* *value);
};

// IPageFactory
struct IPageFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Page* *instance);
};

// IScrollViewer
struct IScrollViewer_raw : IInspectable {
	virtual STDMETHODIMP _get_HorizontalScrollBarVisibility(ScrollBarVisibility *value);
	virtual STDMETHODIMP _put_HorizontalScrollBarVisibility(ScrollBarVisibility value);
	virtual STDMETHODIMP _get_VerticalScrollBarVisibility(ScrollBarVisibility *value);
	virtual STDMETHODIMP _put_VerticalScrollBarVisibility(ScrollBarVisibility value);
	virtual STDMETHODIMP _get_IsHorizontalRailEnabled(bool *value);
	virtual STDMETHODIMP _put_IsHorizontalRailEnabled(bool value);
	virtual STDMETHODIMP _get_IsVerticalRailEnabled(bool *value);
	virtual STDMETHODIMP _put_IsVerticalRailEnabled(bool value);
	virtual STDMETHODIMP _get_IsHorizontalScrollChainingEnabled(bool *value);
	virtual STDMETHODIMP _put_IsHorizontalScrollChainingEnabled(bool value);
	virtual STDMETHODIMP _get_IsVerticalScrollChainingEnabled(bool *value);
	virtual STDMETHODIMP _put_IsVerticalScrollChainingEnabled(bool value);
	virtual STDMETHODIMP _get_IsZoomChainingEnabled(bool *value);
	virtual STDMETHODIMP _put_IsZoomChainingEnabled(bool value);
	virtual STDMETHODIMP _get_IsScrollInertiaEnabled(bool *value);
	virtual STDMETHODIMP _put_IsScrollInertiaEnabled(bool value);
	virtual STDMETHODIMP _get_IsZoomInertiaEnabled(bool *value);
	virtual STDMETHODIMP _put_IsZoomInertiaEnabled(bool value);
	virtual STDMETHODIMP _get_HorizontalScrollMode(ScrollMode *value);
	virtual STDMETHODIMP _put_HorizontalScrollMode(ScrollMode value);
	virtual STDMETHODIMP _get_VerticalScrollMode(ScrollMode *value);
	virtual STDMETHODIMP _put_VerticalScrollMode(ScrollMode value);
	virtual STDMETHODIMP _get_ZoomMode(Controls::ZoomMode *value);
	virtual STDMETHODIMP _put_ZoomMode(Controls::ZoomMode value);
	virtual STDMETHODIMP _get_HorizontalSnapPointsAlignment(Primitives::SnapPointsAlignment *value);
	virtual STDMETHODIMP _put_HorizontalSnapPointsAlignment(Primitives::SnapPointsAlignment value);
	virtual STDMETHODIMP _get_VerticalSnapPointsAlignment(Primitives::SnapPointsAlignment *value);
	virtual STDMETHODIMP _put_VerticalSnapPointsAlignment(Primitives::SnapPointsAlignment value);
	virtual STDMETHODIMP _get_HorizontalSnapPointsType(SnapPointsType *value);
	virtual STDMETHODIMP _put_HorizontalSnapPointsType(SnapPointsType value);
	virtual STDMETHODIMP _get_VerticalSnapPointsType(SnapPointsType *value);
	virtual STDMETHODIMP _put_VerticalSnapPointsType(SnapPointsType value);
	virtual STDMETHODIMP _get_ZoomSnapPointsType(SnapPointsType *value);
	virtual STDMETHODIMP _put_ZoomSnapPointsType(SnapPointsType value);
	virtual STDMETHODIMP _get_HorizontalOffset(double *value);
	virtual STDMETHODIMP _get_ViewportWidth(double *value);
	virtual STDMETHODIMP _get_ScrollableWidth(double *value);
	virtual STDMETHODIMP _get_ComputedHorizontalScrollBarVisibility(Visibility *value);
	virtual STDMETHODIMP _get_ExtentWidth(double *value);
	virtual STDMETHODIMP _get_VerticalOffset(double *value);
	virtual STDMETHODIMP _get_ViewportHeight(double *value);
	virtual STDMETHODIMP _get_ScrollableHeight(double *value);
	virtual STDMETHODIMP _get_ComputedVerticalScrollBarVisibility(Visibility *value);
	virtual STDMETHODIMP _get_ExtentHeight(double *value);
	virtual STDMETHODIMP _get_MinZoomFactor(float *value);
	virtual STDMETHODIMP _put_MinZoomFactor(float value);
	virtual STDMETHODIMP _get_MaxZoomFactor(float *value);
	virtual STDMETHODIMP _put_MaxZoomFactor(float value);
	virtual STDMETHODIMP _get_ZoomFactor(float *value);
	virtual STDMETHODIMP _get_ZoomSnapPoints(Foundation::Collections::IVector<float>* *value);
	virtual STDMETHODIMP _add_ViewChanged(Foundation::EventHandler<ScrollViewerViewChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ViewChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _ScrollToHorizontalOffset(double offset);
	virtual STDMETHODIMP _ScrollToVerticalOffset(double offset);
	virtual STDMETHODIMP _ZoomToFactor(float factor);
	virtual STDMETHODIMP _InvalidateScrollInfo();
	virtual STDMETHODIMP _get_IsDeferredScrollingEnabled(bool *value);
	virtual STDMETHODIMP _put_IsDeferredScrollingEnabled(bool value);
	virtual STDMETHODIMP _get_BringIntoViewOnFocusChange(bool *value);
	virtual STDMETHODIMP _put_BringIntoViewOnFocusChange(bool value);
};
template<typename X> struct IScrollViewer_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollViewer_adaptor::BringIntoViewOnFocusChange)->_get_BringIntoViewOnFocusChange(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IScrollViewer_adaptor::BringIntoViewOnFocusChange)->_put_BringIntoViewOnFocusChange(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} BringIntoViewOnFocusChange;
		struct : property {
			Visibility get() { Visibility value; hrcheck(enc(&IScrollViewer_adaptor::ComputedHorizontalScrollBarVisibility)->_get_ComputedHorizontalScrollBarVisibility(&value)); return value; }
			Visibility operator()() { return get(); }
			operator Visibility () { return get(); }
		} ComputedHorizontalScrollBarVisibility;
		struct : property {
			Visibility get() { Visibility value; hrcheck(enc(&IScrollViewer_adaptor::ComputedVerticalScrollBarVisibility)->_get_ComputedVerticalScrollBarVisibility(&value)); return value; }
			Visibility operator()() { return get(); }
			operator Visibility () { return get(); }
		} ComputedVerticalScrollBarVisibility;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollViewer_adaptor::ExtentHeight)->_get_ExtentHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ExtentHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollViewer_adaptor::ExtentWidth)->_get_ExtentWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ExtentWidth;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollViewer_adaptor::HorizontalOffset)->_get_HorizontalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} HorizontalOffset;
		struct : property {
			ScrollBarVisibility get() { ScrollBarVisibility value; hrcheck(enc(&IScrollViewer_adaptor::HorizontalScrollBarVisibility)->_get_HorizontalScrollBarVisibility(&value)); return value; }
			ScrollBarVisibility operator()() { return get(); }
			operator ScrollBarVisibility () { return get(); }
			void put(ScrollBarVisibility value) { hrcheck(enc(&IScrollViewer_adaptor::HorizontalScrollBarVisibility)->_put_HorizontalScrollBarVisibility(value)); }
			void operator=(ScrollBarVisibility value) { put(value); }
			void operator()(ScrollBarVisibility value) { put(value); }
		} HorizontalScrollBarVisibility;
		struct : property {
			ScrollMode get() { ScrollMode value; hrcheck(enc(&IScrollViewer_adaptor::HorizontalScrollMode)->_get_HorizontalScrollMode(&value)); return value; }
			ScrollMode operator()() { return get(); }
			operator ScrollMode () { return get(); }
			void put(ScrollMode value) { hrcheck(enc(&IScrollViewer_adaptor::HorizontalScrollMode)->_put_HorizontalScrollMode(value)); }
			void operator=(ScrollMode value) { put(value); }
			void operator()(ScrollMode value) { put(value); }
		} HorizontalScrollMode;
		struct : property {
			Primitives::SnapPointsAlignment get() { Primitives::SnapPointsAlignment value; hrcheck(enc(&IScrollViewer_adaptor::HorizontalSnapPointsAlignment)->_get_HorizontalSnapPointsAlignment(&value)); return value; }
			Primitives::SnapPointsAlignment operator()() { return get(); }
			operator Primitives::SnapPointsAlignment () { return get(); }
			void put(Primitives::SnapPointsAlignment value) { hrcheck(enc(&IScrollViewer_adaptor::HorizontalSnapPointsAlignment)->_put_HorizontalSnapPointsAlignment(value)); }
			void operator=(Primitives::SnapPointsAlignment value) { put(value); }
			void operator()(Primitives::SnapPointsAlignment value) { put(value); }
		} HorizontalSnapPointsAlignment;
		struct : property {
			SnapPointsType get() { SnapPointsType value; hrcheck(enc(&IScrollViewer_adaptor::HorizontalSnapPointsType)->_get_HorizontalSnapPointsType(&value)); return value; }
			SnapPointsType operator()() { return get(); }
			operator SnapPointsType () { return get(); }
			void put(SnapPointsType value) { hrcheck(enc(&IScrollViewer_adaptor::HorizontalSnapPointsType)->_put_HorizontalSnapPointsType(value)); }
			void operator=(SnapPointsType value) { put(value); }
			void operator()(SnapPointsType value) { put(value); }
		} HorizontalSnapPointsType;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollViewer_adaptor::IsDeferredScrollingEnabled)->_get_IsDeferredScrollingEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IScrollViewer_adaptor::IsDeferredScrollingEnabled)->_put_IsDeferredScrollingEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsDeferredScrollingEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollViewer_adaptor::IsHorizontalRailEnabled)->_get_IsHorizontalRailEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IScrollViewer_adaptor::IsHorizontalRailEnabled)->_put_IsHorizontalRailEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsHorizontalRailEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollViewer_adaptor::IsHorizontalScrollChainingEnabled)->_get_IsHorizontalScrollChainingEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IScrollViewer_adaptor::IsHorizontalScrollChainingEnabled)->_put_IsHorizontalScrollChainingEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsHorizontalScrollChainingEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollViewer_adaptor::IsScrollInertiaEnabled)->_get_IsScrollInertiaEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IScrollViewer_adaptor::IsScrollInertiaEnabled)->_put_IsScrollInertiaEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsScrollInertiaEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollViewer_adaptor::IsVerticalRailEnabled)->_get_IsVerticalRailEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IScrollViewer_adaptor::IsVerticalRailEnabled)->_put_IsVerticalRailEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsVerticalRailEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollViewer_adaptor::IsVerticalScrollChainingEnabled)->_get_IsVerticalScrollChainingEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IScrollViewer_adaptor::IsVerticalScrollChainingEnabled)->_put_IsVerticalScrollChainingEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsVerticalScrollChainingEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollViewer_adaptor::IsZoomChainingEnabled)->_get_IsZoomChainingEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IScrollViewer_adaptor::IsZoomChainingEnabled)->_put_IsZoomChainingEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsZoomChainingEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollViewer_adaptor::IsZoomInertiaEnabled)->_get_IsZoomInertiaEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IScrollViewer_adaptor::IsZoomInertiaEnabled)->_put_IsZoomInertiaEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsZoomInertiaEnabled;
		struct : property {
			float get() { float value; hrcheck(enc(&IScrollViewer_adaptor::MaxZoomFactor)->_get_MaxZoomFactor(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IScrollViewer_adaptor::MaxZoomFactor)->_put_MaxZoomFactor(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} MaxZoomFactor;
		struct : property {
			float get() { float value; hrcheck(enc(&IScrollViewer_adaptor::MinZoomFactor)->_get_MinZoomFactor(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&IScrollViewer_adaptor::MinZoomFactor)->_put_MinZoomFactor(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} MinZoomFactor;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollViewer_adaptor::ScrollableHeight)->_get_ScrollableHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ScrollableHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollViewer_adaptor::ScrollableWidth)->_get_ScrollableWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ScrollableWidth;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollViewer_adaptor::VerticalOffset)->_get_VerticalOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} VerticalOffset;
		struct : property {
			ScrollBarVisibility get() { ScrollBarVisibility value; hrcheck(enc(&IScrollViewer_adaptor::VerticalScrollBarVisibility)->_get_VerticalScrollBarVisibility(&value)); return value; }
			ScrollBarVisibility operator()() { return get(); }
			operator ScrollBarVisibility () { return get(); }
			void put(ScrollBarVisibility value) { hrcheck(enc(&IScrollViewer_adaptor::VerticalScrollBarVisibility)->_put_VerticalScrollBarVisibility(value)); }
			void operator=(ScrollBarVisibility value) { put(value); }
			void operator()(ScrollBarVisibility value) { put(value); }
		} VerticalScrollBarVisibility;
		struct : property {
			ScrollMode get() { ScrollMode value; hrcheck(enc(&IScrollViewer_adaptor::VerticalScrollMode)->_get_VerticalScrollMode(&value)); return value; }
			ScrollMode operator()() { return get(); }
			operator ScrollMode () { return get(); }
			void put(ScrollMode value) { hrcheck(enc(&IScrollViewer_adaptor::VerticalScrollMode)->_put_VerticalScrollMode(value)); }
			void operator=(ScrollMode value) { put(value); }
			void operator()(ScrollMode value) { put(value); }
		} VerticalScrollMode;
		struct : property {
			Primitives::SnapPointsAlignment get() { Primitives::SnapPointsAlignment value; hrcheck(enc(&IScrollViewer_adaptor::VerticalSnapPointsAlignment)->_get_VerticalSnapPointsAlignment(&value)); return value; }
			Primitives::SnapPointsAlignment operator()() { return get(); }
			operator Primitives::SnapPointsAlignment () { return get(); }
			void put(Primitives::SnapPointsAlignment value) { hrcheck(enc(&IScrollViewer_adaptor::VerticalSnapPointsAlignment)->_put_VerticalSnapPointsAlignment(value)); }
			void operator=(Primitives::SnapPointsAlignment value) { put(value); }
			void operator()(Primitives::SnapPointsAlignment value) { put(value); }
		} VerticalSnapPointsAlignment;
		struct : property {
			SnapPointsType get() { SnapPointsType value; hrcheck(enc(&IScrollViewer_adaptor::VerticalSnapPointsType)->_get_VerticalSnapPointsType(&value)); return value; }
			SnapPointsType operator()() { return get(); }
			operator SnapPointsType () { return get(); }
			void put(SnapPointsType value) { hrcheck(enc(&IScrollViewer_adaptor::VerticalSnapPointsType)->_put_VerticalSnapPointsType(value)); }
			void operator=(SnapPointsType value) { put(value); }
			void operator()(SnapPointsType value) { put(value); }
		} VerticalSnapPointsType;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollViewer_adaptor::ViewportHeight)->_get_ViewportHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ViewportHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollViewer_adaptor::ViewportWidth)->_get_ViewportWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ViewportWidth;
		struct : property {
			float get() { float value; hrcheck(enc(&IScrollViewer_adaptor::ZoomFactor)->_get_ZoomFactor(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} ZoomFactor;
		struct : property {
			Controls::ZoomMode get() { Controls::ZoomMode value; hrcheck(enc(&IScrollViewer_adaptor::ZoomMode)->_get_ZoomMode(&value)); return value; }
			Controls::ZoomMode operator()() { return get(); }
			operator Controls::ZoomMode () { return get(); }
			void put(Controls::ZoomMode value) { hrcheck(enc(&IScrollViewer_adaptor::ZoomMode)->_put_ZoomMode(value)); }
			void operator=(Controls::ZoomMode value) { put(value); }
			void operator()(Controls::ZoomMode value) { put(value); }
		} ZoomMode;
		struct : property {
			ptr<Foundation::Collections::IVector<float>> get() { Foundation::Collections::IVector<float>* value; hrcheck(enc(&IScrollViewer_adaptor::ZoomSnapPoints)->_get_ZoomSnapPoints(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<float>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<float>> () { return get(); }
			ptr<Foundation::Collections::IVector<float>> operator->() { return get(); }
		} ZoomSnapPoints;
		struct : property {
			SnapPointsType get() { SnapPointsType value; hrcheck(enc(&IScrollViewer_adaptor::ZoomSnapPointsType)->_get_ZoomSnapPointsType(&value)); return value; }
			SnapPointsType operator()() { return get(); }
			operator SnapPointsType () { return get(); }
			void put(SnapPointsType value) { hrcheck(enc(&IScrollViewer_adaptor::ZoomSnapPointsType)->_put_ZoomSnapPointsType(value)); }
			void operator=(SnapPointsType value) { put(value); }
			void operator()(SnapPointsType value) { put(value); }
		} ZoomSnapPointsType;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<ScrollViewerViewChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IScrollViewer_adaptor::ViewChanged)->_add_ViewChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IScrollViewer_adaptor::ViewChanged)->_remove_ViewChanged(token)); }
		} ViewChanged;
	};
	void ScrollToHorizontalOffset(double offset) { hrcheck(X::get()->_ScrollToHorizontalOffset(offset)); }
	void ScrollToVerticalOffset(double offset) { hrcheck(X::get()->_ScrollToVerticalOffset(offset)); }
	void ZoomToFactor(float factor) { hrcheck(X::get()->_ZoomToFactor(factor)); }
	void InvalidateScrollInfo() { hrcheck(X::get()->_InvalidateScrollInfo()); }
	IScrollViewer_adaptor() {}
};
template<typename X> struct adapt<IScrollViewer, X> : Windows::UI::Xaml::Controls::IScrollViewer_adaptor<X> { typedef adapt IScrollViewer; };
struct IScrollViewer : IScrollViewer_raw, generate<IScrollViewer> {};

// IScrollViewerStatics
struct IScrollViewerStatics : IInspectable {
	virtual STDMETHODIMP _get_HorizontalSnapPointsAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalSnapPointsAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalSnapPointsTypeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalSnapPointsTypeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ZoomSnapPointsTypeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ViewportWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ScrollableWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ComputedHorizontalScrollBarVisibilityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ExtentWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ViewportHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ScrollableHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ComputedVerticalScrollBarVisibilityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ExtentHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinZoomFactorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxZoomFactorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ZoomFactorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ZoomSnapPointsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalScrollBarVisibilityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetHorizontalScrollBarVisibility(DependencyObject* element, ScrollBarVisibility *horizontalScrollBarVisibility);
	virtual STDMETHODIMP _SetHorizontalScrollBarVisibility(DependencyObject* element, ScrollBarVisibility horizontalScrollBarVisibility);
	virtual STDMETHODIMP _get_VerticalScrollBarVisibilityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetVerticalScrollBarVisibility(DependencyObject* element, ScrollBarVisibility *verticalScrollBarVisibility);
	virtual STDMETHODIMP _SetVerticalScrollBarVisibility(DependencyObject* element, ScrollBarVisibility verticalScrollBarVisibility);
	virtual STDMETHODIMP _get_IsHorizontalRailEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsHorizontalRailEnabled(DependencyObject* element, bool *isHorizontalRailEnabled);
	virtual STDMETHODIMP _SetIsHorizontalRailEnabled(DependencyObject* element, bool isHorizontalRailEnabled);
	virtual STDMETHODIMP _get_IsVerticalRailEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsVerticalRailEnabled(DependencyObject* element, bool *isVerticalRailEnabled);
	virtual STDMETHODIMP _SetIsVerticalRailEnabled(DependencyObject* element, bool isVerticalRailEnabled);
	virtual STDMETHODIMP _get_IsHorizontalScrollChainingEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsHorizontalScrollChainingEnabled(DependencyObject* element, bool *isHorizontalScrollChainingEnabled);
	virtual STDMETHODIMP _SetIsHorizontalScrollChainingEnabled(DependencyObject* element, bool isHorizontalScrollChainingEnabled);
	virtual STDMETHODIMP _get_IsVerticalScrollChainingEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsVerticalScrollChainingEnabled(DependencyObject* element, bool *isVerticalScrollChainingEnabled);
	virtual STDMETHODIMP _SetIsVerticalScrollChainingEnabled(DependencyObject* element, bool isVerticalScrollChainingEnabled);
	virtual STDMETHODIMP _get_IsZoomChainingEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsZoomChainingEnabled(DependencyObject* element, bool *isZoomChainingEnabled);
	virtual STDMETHODIMP _SetIsZoomChainingEnabled(DependencyObject* element, bool isZoomChainingEnabled);
	virtual STDMETHODIMP _get_IsScrollInertiaEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsScrollInertiaEnabled(DependencyObject* element, bool *isScrollInertiaEnabled);
	virtual STDMETHODIMP _SetIsScrollInertiaEnabled(DependencyObject* element, bool isScrollInertiaEnabled);
	virtual STDMETHODIMP _get_IsZoomInertiaEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsZoomInertiaEnabled(DependencyObject* element, bool *isZoomInertiaEnabled);
	virtual STDMETHODIMP _SetIsZoomInertiaEnabled(DependencyObject* element, bool isZoomInertiaEnabled);
	virtual STDMETHODIMP _get_HorizontalScrollModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetHorizontalScrollMode(DependencyObject* element, ScrollMode *horizontalScrollMode);
	virtual STDMETHODIMP _SetHorizontalScrollMode(DependencyObject* element, ScrollMode horizontalScrollMode);
	virtual STDMETHODIMP _get_VerticalScrollModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetVerticalScrollMode(DependencyObject* element, ScrollMode *verticalScrollMode);
	virtual STDMETHODIMP _SetVerticalScrollMode(DependencyObject* element, ScrollMode verticalScrollMode);
	virtual STDMETHODIMP _get_ZoomModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetZoomMode(DependencyObject* element, ZoomMode *zoomMode);
	virtual STDMETHODIMP _SetZoomMode(DependencyObject* element, ZoomMode zoomMode);
	virtual STDMETHODIMP _get_IsDeferredScrollingEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetIsDeferredScrollingEnabled(DependencyObject* element, bool *isDeferredScrollingEnabled);
	virtual STDMETHODIMP _SetIsDeferredScrollingEnabled(DependencyObject* element, bool isDeferredScrollingEnabled);
	virtual STDMETHODIMP _get_BringIntoViewOnFocusChangeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetBringIntoViewOnFocusChange(DependencyObject* element, bool *bringIntoViewOnFocusChange);
	virtual STDMETHODIMP _SetBringIntoViewOnFocusChange(DependencyObject* element, bool bringIntoViewOnFocusChange);
};

// IScrollViewer2
struct IScrollViewer2_raw : IInspectable {
	virtual STDMETHODIMP _get_TopLeftHeader(UIElement* *value);
	virtual STDMETHODIMP _put_TopLeftHeader(UIElement* value);
	virtual STDMETHODIMP _get_LeftHeader(UIElement* *value);
	virtual STDMETHODIMP _put_LeftHeader(UIElement* value);
	virtual STDMETHODIMP _get_TopHeader(UIElement* *value);
	virtual STDMETHODIMP _put_TopHeader(UIElement* value);
	virtual STDMETHODIMP _add_ViewChanging(Foundation::EventHandler<ScrollViewerViewChangingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ViewChanging(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _ChangeView(Foundation::IReference<double>* horizontalOffset, Foundation::IReference<double>* verticalOffset, Foundation::IReference<float>* zoomFactor, bool *returnValue);
	virtual STDMETHODIMP _ChangeViewWithOptionalAnimation(Foundation::IReference<double>* horizontalOffset, Foundation::IReference<double>* verticalOffset, Foundation::IReference<float>* zoomFactor, bool disableAnimation, bool *returnValue);
};
template<typename X> struct IScrollViewer2_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IScrollViewer2_adaptor::LeftHeader)->_get_LeftHeader(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IScrollViewer2_adaptor::LeftHeader)->_put_LeftHeader(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} LeftHeader;
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IScrollViewer2_adaptor::TopHeader)->_get_TopHeader(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IScrollViewer2_adaptor::TopHeader)->_put_TopHeader(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} TopHeader;
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IScrollViewer2_adaptor::TopLeftHeader)->_get_TopLeftHeader(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IScrollViewer2_adaptor::TopLeftHeader)->_put_TopLeftHeader(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} TopLeftHeader;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<ScrollViewerViewChangingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IScrollViewer2_adaptor::ViewChanging)->_add_ViewChanging(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IScrollViewer2_adaptor::ViewChanging)->_remove_ViewChanging(token)); }
		} ViewChanging;
	};
	bool ChangeView(pptr<Foundation::IReference<double>> horizontalOffset, pptr<Foundation::IReference<double>> verticalOffset, pptr<Foundation::IReference<float>> zoomFactor) { bool returnValue; hrcheck(X::get()->_ChangeView(to_abi(horizontalOffset), to_abi(verticalOffset), to_abi(zoomFactor), &returnValue)); return returnValue; }
	bool ChangeView(pptr<Foundation::IReference<double>> horizontalOffset, pptr<Foundation::IReference<double>> verticalOffset, pptr<Foundation::IReference<float>> zoomFactor, bool disableAnimation) { bool returnValue; hrcheck(X::get()->_ChangeViewWithOptionalAnimation(to_abi(horizontalOffset), to_abi(verticalOffset), to_abi(zoomFactor), disableAnimation, &returnValue)); return returnValue; }
	IScrollViewer2_adaptor() {}
};
template<typename X> struct adapt<IScrollViewer2, X> : Windows::UI::Xaml::Controls::IScrollViewer2_adaptor<X> { typedef adapt IScrollViewer2; };
struct IScrollViewer2 : IScrollViewer2_raw, generate<IScrollViewer2> {};

// IScrollViewerStatics2
struct IScrollViewerStatics2 : IInspectable {
	virtual STDMETHODIMP _get_TopLeftHeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_LeftHeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TopHeaderProperty(DependencyProperty* *value);
};

// IScrollViewer3
struct IScrollViewer3_raw : IInspectable {
	virtual STDMETHODIMP _add_DirectManipulationStarted(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DirectManipulationStarted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DirectManipulationCompleted(Foundation::EventHandler<IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DirectManipulationCompleted(Foundation::EventRegistrationToken token);
};
template<typename X> struct IScrollViewer3_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IScrollViewer3_adaptor::DirectManipulationCompleted)->_add_DirectManipulationCompleted(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IScrollViewer3_adaptor::DirectManipulationCompleted)->_remove_DirectManipulationCompleted(token)); }
		} DirectManipulationCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IScrollViewer3_adaptor::DirectManipulationStarted)->_add_DirectManipulationStarted(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IScrollViewer3_adaptor::DirectManipulationStarted)->_remove_DirectManipulationStarted(token)); }
		} DirectManipulationStarted;
	};
	IScrollViewer3_adaptor() {}
};
template<typename X> struct adapt<IScrollViewer3, X> : Windows::UI::Xaml::Controls::IScrollViewer3_adaptor<X> { typedef adapt IScrollViewer3; };
struct IScrollViewer3 : IScrollViewer3_raw, generate<IScrollViewer3> {};

// ISwapChainBackgroundPanel
struct ISwapChainBackgroundPanel : IInspectable, generate<ISwapChainBackgroundPanel> {};

// ISwapChainBackgroundPanelFactory
struct ISwapChainBackgroundPanelFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, SwapChainBackgroundPanel* *instance);
};

// ISwapChainBackgroundPanel2
struct ISwapChainBackgroundPanel2_raw : IInspectable {
	virtual STDMETHODIMP _CreateCoreIndependentInputSource(Core::CoreInputDeviceTypes deviceTypes, Core::CoreIndependentInputSource* *returnValue);
};
template<typename X> struct ISwapChainBackgroundPanel2_adaptor : X {
	ptr<Core::CoreIndependentInputSource> CreateCoreIndependentInputSource(Core::CoreInputDeviceTypes deviceTypes) { Core::CoreIndependentInputSource* returnValue; hrcheck(X::get()->_CreateCoreIndependentInputSource(deviceTypes, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<ISwapChainBackgroundPanel2, X> : Windows::UI::Xaml::Controls::ISwapChainBackgroundPanel2_adaptor<X> { typedef adapt ISwapChainBackgroundPanel2; };
struct ISwapChainBackgroundPanel2 : ISwapChainBackgroundPanel2_raw, generate<ISwapChainBackgroundPanel2> {};

// ISwapChainPanel
struct ISwapChainPanel_raw : IInspectable {
	virtual STDMETHODIMP _get_CompositionScaleX(float *value);
	virtual STDMETHODIMP _get_CompositionScaleY(float *value);
	virtual STDMETHODIMP _add_CompositionScaleChanged(Foundation::TypedEventHandler<SwapChainPanel*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_CompositionScaleChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _CreateCoreIndependentInputSource(Core::CoreInputDeviceTypes deviceTypes, Core::CoreIndependentInputSource* *returnValue);
};
template<typename X> struct ISwapChainPanel_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&ISwapChainPanel_adaptor::CompositionScaleX)->_get_CompositionScaleX(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} CompositionScaleX;
		struct : property {
			float get() { float value; hrcheck(enc(&ISwapChainPanel_adaptor::CompositionScaleY)->_get_CompositionScaleY(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
		} CompositionScaleY;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SwapChainPanel>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISwapChainPanel_adaptor::CompositionScaleChanged)->_add_CompositionScaleChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISwapChainPanel_adaptor::CompositionScaleChanged)->_remove_CompositionScaleChanged(token)); }
		} CompositionScaleChanged;
	};
	ptr<Core::CoreIndependentInputSource> CreateCoreIndependentInputSource(Core::CoreInputDeviceTypes deviceTypes) { Core::CoreIndependentInputSource* returnValue; hrcheck(X::get()->_CreateCoreIndependentInputSource(deviceTypes, &returnValue)); return from_abi(returnValue); }
	ISwapChainPanel_adaptor() {}
};
template<typename X> struct adapt<ISwapChainPanel, X> : Windows::UI::Xaml::Controls::ISwapChainPanel_adaptor<X> { typedef adapt ISwapChainPanel; };
struct ISwapChainPanel : ISwapChainPanel_raw, generate<ISwapChainPanel> {};

// ISwapChainPanelStatics
struct ISwapChainPanelStatics : IInspectable {
	virtual STDMETHODIMP _get_CompositionScaleXProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CompositionScaleYProperty(DependencyProperty* *value);
};

// ISwapChainPanelFactory
struct ISwapChainPanelFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, SwapChainPanel* *instance);
};

// ICommandBar
struct ICommandBar_raw : IInspectable {
	virtual STDMETHODIMP _get_PrimaryCommands(Foundation::Collections::IObservableVector<ICommandBarElement*>* *value);
	virtual STDMETHODIMP _get_SecondaryCommands(Foundation::Collections::IObservableVector<ICommandBarElement*>* *value);
};
template<typename X> struct ICommandBar_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IObservableVector<ptr<ICommandBarElement>>> get() { Foundation::Collections::IObservableVector<ICommandBarElement*>* value; hrcheck(enc(&ICommandBar_adaptor::PrimaryCommands)->_get_PrimaryCommands(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IObservableVector<ptr<ICommandBarElement>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IObservableVector<ptr<ICommandBarElement>>> () { return get(); }
			ptr<Foundation::Collections::IObservableVector<ptr<ICommandBarElement>>> operator->() { return get(); }
		} PrimaryCommands;
		struct : property {
			ptr<Foundation::Collections::IObservableVector<ptr<ICommandBarElement>>> get() { Foundation::Collections::IObservableVector<ICommandBarElement*>* value; hrcheck(enc(&ICommandBar_adaptor::SecondaryCommands)->_get_SecondaryCommands(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IObservableVector<ptr<ICommandBarElement>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IObservableVector<ptr<ICommandBarElement>>> () { return get(); }
			ptr<Foundation::Collections::IObservableVector<ptr<ICommandBarElement>>> operator->() { return get(); }
		} SecondaryCommands;
	};
	ICommandBar_adaptor() {}
};
template<typename X> struct adapt<ICommandBar, X> : Windows::UI::Xaml::Controls::ICommandBar_adaptor<X> { typedef adapt ICommandBar; };
struct ICommandBar : ICommandBar_raw, generate<ICommandBar> {};

// ICommandBarStatics
struct ICommandBarStatics : IInspectable {
	virtual STDMETHODIMP _get_PrimaryCommandsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SecondaryCommandsProperty(DependencyProperty* *value);
};

// ICommandBarFactory
struct ICommandBarFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, CommandBar* *instance);
};

// ICommandBar2
struct ICommandBar2_raw : IInspectable {
	virtual STDMETHODIMP _get_CommandBarOverflowPresenterStyle(Style* *value);
	virtual STDMETHODIMP _put_CommandBarOverflowPresenterStyle(Style* value);
	virtual STDMETHODIMP _get_CommandBarTemplateSettings(Primitives::CommandBarTemplateSettings* *value);
};
template<typename X> struct ICommandBar2_adaptor : X {
	union {
		struct : property {
			ptr<Style> get() { Style* value; hrcheck(enc(&ICommandBar2_adaptor::CommandBarOverflowPresenterStyle)->_get_CommandBarOverflowPresenterStyle(&value)); return from_abi(value); }
			ptr<Style> operator()() { return get(); }
			operator ptr<Style> () { return get(); }
			ptr<Style> operator->() { return get(); }
			void put(pptr<Style> value) { hrcheck(enc(&ICommandBar2_adaptor::CommandBarOverflowPresenterStyle)->_put_CommandBarOverflowPresenterStyle(value)); }
			void operator=(pptr<Style> value) { put(value); }
			void operator()(pptr<Style> value) { put(value); }
		} CommandBarOverflowPresenterStyle;
		struct : property {
			ptr<Primitives::CommandBarTemplateSettings> get() { Primitives::CommandBarTemplateSettings* value; hrcheck(enc(&ICommandBar2_adaptor::CommandBarTemplateSettings)->_get_CommandBarTemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::CommandBarTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::CommandBarTemplateSettings> () { return get(); }
			ptr<Primitives::CommandBarTemplateSettings> operator->() { return get(); }
		} CommandBarTemplateSettings;
	};
	ICommandBar2_adaptor() {}
};
template<typename X> struct adapt<ICommandBar2, X> : Windows::UI::Xaml::Controls::ICommandBar2_adaptor<X> { typedef adapt ICommandBar2; };
struct ICommandBar2 : ICommandBar2_raw, generate<ICommandBar2> {};

// ICommandBarStatics2
struct ICommandBarStatics2 : IInspectable {
	virtual STDMETHODIMP _get_CommandBarOverflowPresenterStyleProperty(DependencyProperty* *value);
};

// ICommandBar3
struct ICommandBar3_raw : IInspectable {
	virtual STDMETHODIMP _get_DefaultLabelPosition(CommandBarDefaultLabelPosition *value);
	virtual STDMETHODIMP _put_DefaultLabelPosition(CommandBarDefaultLabelPosition value);
	virtual STDMETHODIMP _get_OverflowButtonVisibility(CommandBarOverflowButtonVisibility *value);
	virtual STDMETHODIMP _put_OverflowButtonVisibility(CommandBarOverflowButtonVisibility value);
	virtual STDMETHODIMP _get_IsDynamicOverflowEnabled(bool *value);
	virtual STDMETHODIMP _put_IsDynamicOverflowEnabled(bool value);
	virtual STDMETHODIMP _add_DynamicOverflowItemsChanging(Foundation::TypedEventHandler<CommandBar*, DynamicOverflowItemsChangingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DynamicOverflowItemsChanging(Foundation::EventRegistrationToken token);
};
template<typename X> struct ICommandBar3_adaptor : X {
	union {
		struct : property {
			CommandBarDefaultLabelPosition get() { CommandBarDefaultLabelPosition value; hrcheck(enc(&ICommandBar3_adaptor::DefaultLabelPosition)->_get_DefaultLabelPosition(&value)); return value; }
			CommandBarDefaultLabelPosition operator()() { return get(); }
			operator CommandBarDefaultLabelPosition () { return get(); }
			void put(CommandBarDefaultLabelPosition value) { hrcheck(enc(&ICommandBar3_adaptor::DefaultLabelPosition)->_put_DefaultLabelPosition(value)); }
			void operator=(CommandBarDefaultLabelPosition value) { put(value); }
			void operator()(CommandBarDefaultLabelPosition value) { put(value); }
		} DefaultLabelPosition;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICommandBar3_adaptor::IsDynamicOverflowEnabled)->_get_IsDynamicOverflowEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICommandBar3_adaptor::IsDynamicOverflowEnabled)->_put_IsDynamicOverflowEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsDynamicOverflowEnabled;
		struct : property {
			CommandBarOverflowButtonVisibility get() { CommandBarOverflowButtonVisibility value; hrcheck(enc(&ICommandBar3_adaptor::OverflowButtonVisibility)->_get_OverflowButtonVisibility(&value)); return value; }
			CommandBarOverflowButtonVisibility operator()() { return get(); }
			operator CommandBarOverflowButtonVisibility () { return get(); }
			void put(CommandBarOverflowButtonVisibility value) { hrcheck(enc(&ICommandBar3_adaptor::OverflowButtonVisibility)->_put_OverflowButtonVisibility(value)); }
			void operator=(CommandBarOverflowButtonVisibility value) { put(value); }
			void operator()(CommandBarOverflowButtonVisibility value) { put(value); }
		} OverflowButtonVisibility;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<CommandBar>, ptr<DynamicOverflowItemsChangingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ICommandBar3_adaptor::DynamicOverflowItemsChanging)->_add_DynamicOverflowItemsChanging(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ICommandBar3_adaptor::DynamicOverflowItemsChanging)->_remove_DynamicOverflowItemsChanging(token)); }
		} DynamicOverflowItemsChanging;
	};
	ICommandBar3_adaptor() {}
};
template<typename X> struct adapt<ICommandBar3, X> : Windows::UI::Xaml::Controls::ICommandBar3_adaptor<X> { typedef adapt ICommandBar3; };
struct ICommandBar3 : ICommandBar3_raw, generate<ICommandBar3> {};

// ICommandBarStatics3
struct ICommandBarStatics3 : IInspectable {
	virtual STDMETHODIMP _get_DefaultLabelPositionProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OverflowButtonVisibilityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsDynamicOverflowEnabledProperty(DependencyProperty* *value);
};

// IGridViewHeaderItem
struct IGridViewHeaderItem : IInspectable, generate<IGridViewHeaderItem> {};

// IGridViewHeaderItemFactory
struct IGridViewHeaderItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, GridViewHeaderItem* *instance);
};

// IGridViewItem
struct IGridViewItem_raw : IInspectable {
	virtual STDMETHODIMP _get_TemplateSettings(Primitives::GridViewItemTemplateSettings* *value);
};
template<typename X> struct IGridViewItem_adaptor : X {
	union {
		struct : property {
			ptr<Primitives::GridViewItemTemplateSettings> get() { Primitives::GridViewItemTemplateSettings* value; hrcheck(enc(&IGridViewItem_adaptor::TemplateSettings)->_get_TemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::GridViewItemTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::GridViewItemTemplateSettings> () { return get(); }
			ptr<Primitives::GridViewItemTemplateSettings> operator->() { return get(); }
		} TemplateSettings;
	};
	IGridViewItem_adaptor() {}
};
template<typename X> struct adapt<IGridViewItem, X> : Windows::UI::Xaml::Controls::IGridViewItem_adaptor<X> { typedef adapt IGridViewItem; };
struct IGridViewItem : IGridViewItem_raw, generate<IGridViewItem> {};

// IGridViewItemFactory
struct IGridViewItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, GridViewItem* *instance);
};

// IListViewHeaderItem
struct IListViewHeaderItem : IInspectable, generate<IListViewHeaderItem> {};

// IListViewHeaderItemFactory
struct IListViewHeaderItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ListViewHeaderItem* *instance);
};

// IListViewItem
struct IListViewItem_raw : IInspectable {
	virtual STDMETHODIMP _get_TemplateSettings(Primitives::ListViewItemTemplateSettings* *value);
};
template<typename X> struct IListViewItem_adaptor : X {
	union {
		struct : property {
			ptr<Primitives::ListViewItemTemplateSettings> get() { Primitives::ListViewItemTemplateSettings* value; hrcheck(enc(&IListViewItem_adaptor::TemplateSettings)->_get_TemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::ListViewItemTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::ListViewItemTemplateSettings> () { return get(); }
			ptr<Primitives::ListViewItemTemplateSettings> operator->() { return get(); }
		} TemplateSettings;
	};
	IListViewItem_adaptor() {}
};
template<typename X> struct adapt<IListViewItem, X> : Windows::UI::Xaml::Controls::IListViewItem_adaptor<X> { typedef adapt IListViewItem; };
struct IListViewItem : IListViewItem_raw, generate<IListViewItem> {};

// IListViewItemFactory
struct IListViewItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ListViewItem* *instance);
};

// IToggleMenuFlyoutItem
struct IToggleMenuFlyoutItem_raw : IInspectable {
	virtual STDMETHODIMP _get_IsChecked(bool *value);
	virtual STDMETHODIMP _put_IsChecked(bool value);
};
template<typename X> struct IToggleMenuFlyoutItem_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IToggleMenuFlyoutItem_adaptor::IsChecked)->_get_IsChecked(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IToggleMenuFlyoutItem_adaptor::IsChecked)->_put_IsChecked(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsChecked;
	};
	IToggleMenuFlyoutItem_adaptor() {}
};
template<typename X> struct adapt<IToggleMenuFlyoutItem, X> : Windows::UI::Xaml::Controls::IToggleMenuFlyoutItem_adaptor<X> { typedef adapt IToggleMenuFlyoutItem; };
struct IToggleMenuFlyoutItem : IToggleMenuFlyoutItem_raw, generate<IToggleMenuFlyoutItem> {};

// IToggleMenuFlyoutItemStatics
struct IToggleMenuFlyoutItemStatics : IInspectable {
	virtual STDMETHODIMP _get_IsCheckedProperty(DependencyProperty* *value);
};

// IToggleMenuFlyoutItemFactory
struct IToggleMenuFlyoutItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ToggleMenuFlyoutItem* *instance);
};

// IWrapGrid
struct IWrapGrid_raw : IInspectable {
	virtual STDMETHODIMP _get_ItemWidth(double *value);
	virtual STDMETHODIMP _put_ItemWidth(double value);
	virtual STDMETHODIMP _get_ItemHeight(double *value);
	virtual STDMETHODIMP _put_ItemHeight(double value);
	virtual STDMETHODIMP _get_Orientation(Controls::Orientation *value);
	virtual STDMETHODIMP _put_Orientation(Controls::Orientation value);
	virtual STDMETHODIMP _get_HorizontalChildrenAlignment(HorizontalAlignment *value);
	virtual STDMETHODIMP _put_HorizontalChildrenAlignment(HorizontalAlignment value);
	virtual STDMETHODIMP _get_VerticalChildrenAlignment(VerticalAlignment *value);
	virtual STDMETHODIMP _put_VerticalChildrenAlignment(VerticalAlignment value);
	virtual STDMETHODIMP _get_MaximumRowsOrColumns(int *value);
	virtual STDMETHODIMP _put_MaximumRowsOrColumns(int value);
};
template<typename X> struct IWrapGrid_adaptor : X {
	union {
		struct : property {
			HorizontalAlignment get() { HorizontalAlignment value; hrcheck(enc(&IWrapGrid_adaptor::HorizontalChildrenAlignment)->_get_HorizontalChildrenAlignment(&value)); return value; }
			HorizontalAlignment operator()() { return get(); }
			operator HorizontalAlignment () { return get(); }
			void put(HorizontalAlignment value) { hrcheck(enc(&IWrapGrid_adaptor::HorizontalChildrenAlignment)->_put_HorizontalChildrenAlignment(value)); }
			void operator=(HorizontalAlignment value) { put(value); }
			void operator()(HorizontalAlignment value) { put(value); }
		} HorizontalChildrenAlignment;
		struct : property {
			double get() { double value; hrcheck(enc(&IWrapGrid_adaptor::ItemHeight)->_get_ItemHeight(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IWrapGrid_adaptor::ItemHeight)->_put_ItemHeight(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ItemHeight;
		struct : property {
			double get() { double value; hrcheck(enc(&IWrapGrid_adaptor::ItemWidth)->_get_ItemWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IWrapGrid_adaptor::ItemWidth)->_put_ItemWidth(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ItemWidth;
		struct : property {
			int get() { int value; hrcheck(enc(&IWrapGrid_adaptor::MaximumRowsOrColumns)->_get_MaximumRowsOrColumns(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IWrapGrid_adaptor::MaximumRowsOrColumns)->_put_MaximumRowsOrColumns(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaximumRowsOrColumns;
		struct : property {
			Controls::Orientation get() { Controls::Orientation value; hrcheck(enc(&IWrapGrid_adaptor::Orientation)->_get_Orientation(&value)); return value; }
			Controls::Orientation operator()() { return get(); }
			operator Controls::Orientation () { return get(); }
			void put(Controls::Orientation value) { hrcheck(enc(&IWrapGrid_adaptor::Orientation)->_put_Orientation(value)); }
			void operator=(Controls::Orientation value) { put(value); }
			void operator()(Controls::Orientation value) { put(value); }
		} Orientation;
		struct : property {
			VerticalAlignment get() { VerticalAlignment value; hrcheck(enc(&IWrapGrid_adaptor::VerticalChildrenAlignment)->_get_VerticalChildrenAlignment(&value)); return value; }
			VerticalAlignment operator()() { return get(); }
			operator VerticalAlignment () { return get(); }
			void put(VerticalAlignment value) { hrcheck(enc(&IWrapGrid_adaptor::VerticalChildrenAlignment)->_put_VerticalChildrenAlignment(value)); }
			void operator=(VerticalAlignment value) { put(value); }
			void operator()(VerticalAlignment value) { put(value); }
		} VerticalChildrenAlignment;
	};
	IWrapGrid_adaptor() {}
};
template<typename X> struct adapt<IWrapGrid, X> : Windows::UI::Xaml::Controls::IWrapGrid_adaptor<X> { typedef adapt IWrapGrid; };
struct IWrapGrid : IWrapGrid_raw, generate<IWrapGrid> {};

// IWrapGridStatics
struct IWrapGridStatics : IInspectable {
	virtual STDMETHODIMP _get_ItemWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemHeightProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OrientationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalChildrenAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalChildrenAlignmentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaximumRowsOrColumnsProperty(DependencyProperty* *value);
};

// IAppBarButton
struct IAppBarButton_raw : IInspectable {
	virtual STDMETHODIMP _get_Label(HSTRING *value);
	virtual STDMETHODIMP _put_Label(HSTRING value);
	virtual STDMETHODIMP _get_Icon(IconElement* *value);
	virtual STDMETHODIMP _put_Icon(IconElement* value);
};
template<typename X> struct IAppBarButton_adaptor : X {
	union {
		struct : property {
			ptr<IconElement> get() { IconElement* value; hrcheck(enc(&IAppBarButton_adaptor::Icon)->_get_Icon(&value)); return from_abi(value); }
			ptr<IconElement> operator()() { return get(); }
			operator ptr<IconElement> () { return get(); }
			ptr<IconElement> operator->() { return get(); }
			void put(pptr<IconElement> value) { hrcheck(enc(&IAppBarButton_adaptor::Icon)->_put_Icon(value)); }
			void operator=(pptr<IconElement> value) { put(value); }
			void operator()(pptr<IconElement> value) { put(value); }
		} Icon;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppBarButton_adaptor::Label)->_get_Label(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IAppBarButton_adaptor::Label)->_put_Label(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Label;
	};
	IAppBarButton_adaptor() {}
};
template<typename X> struct adapt<IAppBarButton, X> : Windows::UI::Xaml::Controls::IAppBarButton_adaptor<X> { typedef adapt IAppBarButton; };
struct IAppBarButton : IAppBarButton_raw, generate<IAppBarButton> {};

// IAppBarButtonStatics
struct IAppBarButtonStatics : IInspectable {
	virtual STDMETHODIMP _get_LabelProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IconProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsCompactProperty(DependencyProperty* *value);
};

// IAppBarButtonFactory
struct IAppBarButtonFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, AppBarButton* *instance);
};

// IAppBarButton3
struct IAppBarButton3_raw : IInspectable {
	virtual STDMETHODIMP _get_LabelPosition(CommandBarLabelPosition *value);
	virtual STDMETHODIMP _put_LabelPosition(CommandBarLabelPosition value);
};
template<typename X> struct IAppBarButton3_adaptor : X {
	union {
		struct : property {
			CommandBarLabelPosition get() { CommandBarLabelPosition value; hrcheck(enc(&IAppBarButton3_adaptor::LabelPosition)->_get_LabelPosition(&value)); return value; }
			CommandBarLabelPosition operator()() { return get(); }
			operator CommandBarLabelPosition () { return get(); }
			void put(CommandBarLabelPosition value) { hrcheck(enc(&IAppBarButton3_adaptor::LabelPosition)->_put_LabelPosition(value)); }
			void operator=(CommandBarLabelPosition value) { put(value); }
			void operator()(CommandBarLabelPosition value) { put(value); }
		} LabelPosition;
	};
	IAppBarButton3_adaptor() {}
};
template<typename X> struct adapt<IAppBarButton3, X> : Windows::UI::Xaml::Controls::IAppBarButton3_adaptor<X> { typedef adapt IAppBarButton3; };
struct IAppBarButton3 : IAppBarButton3_raw, generate<IAppBarButton3> {};

// IAppBarButtonStatics3
struct IAppBarButtonStatics3 : IInspectable {
	virtual STDMETHODIMP _get_LabelPositionProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsInOverflowProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DynamicOverflowOrderProperty(DependencyProperty* *value);
};

// IAppBarButton4
struct IAppBarButton4_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyboardAcceleratorTextOverride(HSTRING *value);
	virtual STDMETHODIMP _put_KeyboardAcceleratorTextOverride(HSTRING value);
};
template<typename X> struct IAppBarButton4_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppBarButton4_adaptor::KeyboardAcceleratorTextOverride)->_get_KeyboardAcceleratorTextOverride(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IAppBarButton4_adaptor::KeyboardAcceleratorTextOverride)->_put_KeyboardAcceleratorTextOverride(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} KeyboardAcceleratorTextOverride;
	};
	IAppBarButton4_adaptor() {}
};
template<typename X> struct adapt<IAppBarButton4, X> : Windows::UI::Xaml::Controls::IAppBarButton4_adaptor<X> { typedef adapt IAppBarButton4; };
struct IAppBarButton4 : IAppBarButton4_raw, generate<IAppBarButton4> {};

// IAppBarButtonStatics4
struct IAppBarButtonStatics4 : IInspectable {
	virtual STDMETHODIMP _get_KeyboardAcceleratorTextOverrideProperty(DependencyProperty* *value);
};

// IAppBarButton5
struct IAppBarButton5_raw : IInspectable {
	virtual STDMETHODIMP _get_TemplateSettings(Primitives::AppBarButtonTemplateSettings* *value);
};
template<typename X> struct IAppBarButton5_adaptor : X {
	union {
		struct : property {
			ptr<Primitives::AppBarButtonTemplateSettings> get() { Primitives::AppBarButtonTemplateSettings* value; hrcheck(enc(&IAppBarButton5_adaptor::TemplateSettings)->_get_TemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::AppBarButtonTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::AppBarButtonTemplateSettings> () { return get(); }
			ptr<Primitives::AppBarButtonTemplateSettings> operator->() { return get(); }
		} TemplateSettings;
	};
	IAppBarButton5_adaptor() {}
};
template<typename X> struct adapt<IAppBarButton5, X> : Windows::UI::Xaml::Controls::IAppBarButton5_adaptor<X> { typedef adapt IAppBarButton5; };
struct IAppBarButton5 : IAppBarButton5_raw, generate<IAppBarButton5> {};

// IAppBarToggleButton
struct IAppBarToggleButton_raw : IInspectable {
	virtual STDMETHODIMP _get_Label(HSTRING *value);
	virtual STDMETHODIMP _put_Label(HSTRING value);
	virtual STDMETHODIMP _get_Icon(IconElement* *value);
	virtual STDMETHODIMP _put_Icon(IconElement* value);
};
template<typename X> struct IAppBarToggleButton_adaptor : X {
	union {
		struct : property {
			ptr<IconElement> get() { IconElement* value; hrcheck(enc(&IAppBarToggleButton_adaptor::Icon)->_get_Icon(&value)); return from_abi(value); }
			ptr<IconElement> operator()() { return get(); }
			operator ptr<IconElement> () { return get(); }
			ptr<IconElement> operator->() { return get(); }
			void put(pptr<IconElement> value) { hrcheck(enc(&IAppBarToggleButton_adaptor::Icon)->_put_Icon(value)); }
			void operator=(pptr<IconElement> value) { put(value); }
			void operator()(pptr<IconElement> value) { put(value); }
		} Icon;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppBarToggleButton_adaptor::Label)->_get_Label(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IAppBarToggleButton_adaptor::Label)->_put_Label(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Label;
	};
	IAppBarToggleButton_adaptor() {}
};
template<typename X> struct adapt<IAppBarToggleButton, X> : Windows::UI::Xaml::Controls::IAppBarToggleButton_adaptor<X> { typedef adapt IAppBarToggleButton; };
struct IAppBarToggleButton : IAppBarToggleButton_raw, generate<IAppBarToggleButton> {};

// IAppBarToggleButtonStatics
struct IAppBarToggleButtonStatics : IInspectable {
	virtual STDMETHODIMP _get_LabelProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IconProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsCompactProperty(DependencyProperty* *value);
};

// IAppBarToggleButtonFactory
struct IAppBarToggleButtonFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, AppBarToggleButton* *instance);
};

// IAppBarToggleButton3
struct IAppBarToggleButton3_raw : IInspectable {
	virtual STDMETHODIMP _get_LabelPosition(CommandBarLabelPosition *value);
	virtual STDMETHODIMP _put_LabelPosition(CommandBarLabelPosition value);
};
template<typename X> struct IAppBarToggleButton3_adaptor : X {
	union {
		struct : property {
			CommandBarLabelPosition get() { CommandBarLabelPosition value; hrcheck(enc(&IAppBarToggleButton3_adaptor::LabelPosition)->_get_LabelPosition(&value)); return value; }
			CommandBarLabelPosition operator()() { return get(); }
			operator CommandBarLabelPosition () { return get(); }
			void put(CommandBarLabelPosition value) { hrcheck(enc(&IAppBarToggleButton3_adaptor::LabelPosition)->_put_LabelPosition(value)); }
			void operator=(CommandBarLabelPosition value) { put(value); }
			void operator()(CommandBarLabelPosition value) { put(value); }
		} LabelPosition;
	};
	IAppBarToggleButton3_adaptor() {}
};
template<typename X> struct adapt<IAppBarToggleButton3, X> : Windows::UI::Xaml::Controls::IAppBarToggleButton3_adaptor<X> { typedef adapt IAppBarToggleButton3; };
struct IAppBarToggleButton3 : IAppBarToggleButton3_raw, generate<IAppBarToggleButton3> {};

// IAppBarToggleButtonStatics3
struct IAppBarToggleButtonStatics3 : IInspectable {
	virtual STDMETHODIMP _get_LabelPositionProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsInOverflowProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DynamicOverflowOrderProperty(DependencyProperty* *value);
};

// IAppBarToggleButton4
struct IAppBarToggleButton4_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyboardAcceleratorTextOverride(HSTRING *value);
	virtual STDMETHODIMP _put_KeyboardAcceleratorTextOverride(HSTRING value);
};
template<typename X> struct IAppBarToggleButton4_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppBarToggleButton4_adaptor::KeyboardAcceleratorTextOverride)->_get_KeyboardAcceleratorTextOverride(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IAppBarToggleButton4_adaptor::KeyboardAcceleratorTextOverride)->_put_KeyboardAcceleratorTextOverride(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} KeyboardAcceleratorTextOverride;
	};
	IAppBarToggleButton4_adaptor() {}
};
template<typename X> struct adapt<IAppBarToggleButton4, X> : Windows::UI::Xaml::Controls::IAppBarToggleButton4_adaptor<X> { typedef adapt IAppBarToggleButton4; };
struct IAppBarToggleButton4 : IAppBarToggleButton4_raw, generate<IAppBarToggleButton4> {};

// IAppBarToggleButtonStatics4
struct IAppBarToggleButtonStatics4 : IInspectable {
	virtual STDMETHODIMP _get_KeyboardAcceleratorTextOverrideProperty(DependencyProperty* *value);
};

// IAppBarToggleButton5
struct IAppBarToggleButton5_raw : IInspectable {
	virtual STDMETHODIMP _get_TemplateSettings(Primitives::AppBarToggleButtonTemplateSettings* *value);
};
template<typename X> struct IAppBarToggleButton5_adaptor : X {
	union {
		struct : property {
			ptr<Primitives::AppBarToggleButtonTemplateSettings> get() { Primitives::AppBarToggleButtonTemplateSettings* value; hrcheck(enc(&IAppBarToggleButton5_adaptor::TemplateSettings)->_get_TemplateSettings(&value)); return from_abi(value); }
			ptr<Primitives::AppBarToggleButtonTemplateSettings> operator()() { return get(); }
			operator ptr<Primitives::AppBarToggleButtonTemplateSettings> () { return get(); }
			ptr<Primitives::AppBarToggleButtonTemplateSettings> operator->() { return get(); }
		} TemplateSettings;
	};
	IAppBarToggleButton5_adaptor() {}
};
template<typename X> struct adapt<IAppBarToggleButton5, X> : Windows::UI::Xaml::Controls::IAppBarToggleButton5_adaptor<X> { typedef adapt IAppBarToggleButton5; };
struct IAppBarToggleButton5 : IAppBarToggleButton5_raw, generate<IAppBarToggleButton5> {};

// IGridView
struct IGridView : IInspectable, generate<IGridView> {};

// IGridViewFactory
struct IGridViewFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, GridView* *instance);
};

// IListView
struct IListView : IInspectable, generate<IListView> {};

// IListViewFactory
struct IListViewFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ListView* *instance);
};

// ITreeViewItemFactory
struct ITreeViewItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, TreeViewItem* *instance);
};

// ITreeViewItemStatics
struct ITreeViewItemStatics : IInspectable {
	virtual STDMETHODIMP _get_GlyphOpacityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_GlyphBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ExpandedGlyphProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CollapsedGlyphProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_GlyphSizeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsExpandedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TreeViewItemTemplateSettingsProperty(DependencyProperty* *value);
};

// ITreeViewItem
struct ITreeViewItem_raw : IInspectable {
	virtual STDMETHODIMP _get_GlyphOpacity(double *result);
	virtual STDMETHODIMP _put_GlyphOpacity(double value);
	virtual STDMETHODIMP _get_GlyphBrush(Media::Brush* *result);
	virtual STDMETHODIMP _put_GlyphBrush(Media::Brush* value);
	virtual STDMETHODIMP _get_ExpandedGlyph(HSTRING *value);
	virtual STDMETHODIMP _put_ExpandedGlyph(HSTRING value);
	virtual STDMETHODIMP _get_CollapsedGlyph(HSTRING *value);
	virtual STDMETHODIMP _put_CollapsedGlyph(HSTRING value);
	virtual STDMETHODIMP _get_GlyphSize(double *result);
	virtual STDMETHODIMP _put_GlyphSize(double value);
	virtual STDMETHODIMP _get_IsExpanded(bool *value);
	virtual STDMETHODIMP _put_IsExpanded(bool value);
	virtual STDMETHODIMP _get_TreeViewItemTemplateSettings(Controls::TreeViewItemTemplateSettings* *result);
};
template<typename X> struct ITreeViewItem_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITreeViewItem_adaptor::CollapsedGlyph)->_get_CollapsedGlyph(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITreeViewItem_adaptor::CollapsedGlyph)->_put_CollapsedGlyph(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} CollapsedGlyph;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITreeViewItem_adaptor::ExpandedGlyph)->_get_ExpandedGlyph(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITreeViewItem_adaptor::ExpandedGlyph)->_put_ExpandedGlyph(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ExpandedGlyph;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* result; hrcheck(enc(&ITreeViewItem_adaptor::GlyphBrush)->_get_GlyphBrush(&result)); return from_abi(result); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ITreeViewItem_adaptor::GlyphBrush)->_put_GlyphBrush(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} GlyphBrush;
		struct : property {
			double get() { double result; hrcheck(enc(&ITreeViewItem_adaptor::GlyphOpacity)->_get_GlyphOpacity(&result)); return result; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ITreeViewItem_adaptor::GlyphOpacity)->_put_GlyphOpacity(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} GlyphOpacity;
		struct : property {
			double get() { double result; hrcheck(enc(&ITreeViewItem_adaptor::GlyphSize)->_get_GlyphSize(&result)); return result; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ITreeViewItem_adaptor::GlyphSize)->_put_GlyphSize(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} GlyphSize;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITreeViewItem_adaptor::IsExpanded)->_get_IsExpanded(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITreeViewItem_adaptor::IsExpanded)->_put_IsExpanded(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsExpanded;
		struct : property {
			ptr<Controls::TreeViewItemTemplateSettings> get() { Controls::TreeViewItemTemplateSettings* result; hrcheck(enc(&ITreeViewItem_adaptor::TreeViewItemTemplateSettings)->_get_TreeViewItemTemplateSettings(&result)); return from_abi(result); }
			ptr<Controls::TreeViewItemTemplateSettings> operator()() { return get(); }
			operator ptr<Controls::TreeViewItemTemplateSettings> () { return get(); }
			ptr<Controls::TreeViewItemTemplateSettings> operator->() { return get(); }
		} TreeViewItemTemplateSettings;
	};
	ITreeViewItem_adaptor() {}
};
template<typename X> struct adapt<ITreeViewItem, X> : Windows::UI::Xaml::Controls::ITreeViewItem_adaptor<X> { typedef adapt ITreeViewItem; };
struct ITreeViewItem : ITreeViewItem_raw, generate<ITreeViewItem> {};

// ITreeViewItemTemplateSettingsFactory
struct ITreeViewItemTemplateSettingsFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, TreeViewItemTemplateSettings* *instance);
};

// ITreeViewItemTemplateSettingsStatics
struct ITreeViewItemTemplateSettingsStatics : IInspectable {
	virtual STDMETHODIMP _get_ExpandedGlyphVisibilityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CollapsedGlyphVisibilityProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IndentationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DragItemsCountProperty(DependencyProperty* *value);
};

// ITreeViewItemTemplateSettings
struct ITreeViewItemTemplateSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_ExpandedGlyphVisibility(Visibility *value);
	virtual STDMETHODIMP _get_CollapsedGlyphVisibility(Visibility *value);
	virtual STDMETHODIMP _get_Indentation(Thickness *value);
	virtual STDMETHODIMP _get_DragItemsCount(int *value);
};
template<typename X> struct ITreeViewItemTemplateSettings_adaptor : X {
	union {
		struct : property {
			Visibility get() { Visibility value; hrcheck(enc(&ITreeViewItemTemplateSettings_adaptor::CollapsedGlyphVisibility)->_get_CollapsedGlyphVisibility(&value)); return value; }
			Visibility operator()() { return get(); }
			operator Visibility () { return get(); }
		} CollapsedGlyphVisibility;
		struct : property {
			int get() { int value; hrcheck(enc(&ITreeViewItemTemplateSettings_adaptor::DragItemsCount)->_get_DragItemsCount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} DragItemsCount;
		struct : property {
			Visibility get() { Visibility value; hrcheck(enc(&ITreeViewItemTemplateSettings_adaptor::ExpandedGlyphVisibility)->_get_ExpandedGlyphVisibility(&value)); return value; }
			Visibility operator()() { return get(); }
			operator Visibility () { return get(); }
		} ExpandedGlyphVisibility;
		struct : property {
			Thickness get() { Thickness value; hrcheck(enc(&ITreeViewItemTemplateSettings_adaptor::Indentation)->_get_Indentation(&value)); return value; }
			Thickness operator()() { return get(); }
			operator Thickness () { return get(); }
		} Indentation;
	};
	ITreeViewItemTemplateSettings_adaptor() {}
};
template<typename X> struct adapt<ITreeViewItemTemplateSettings, X> : Windows::UI::Xaml::Controls::ITreeViewItemTemplateSettings_adaptor<X> { typedef adapt ITreeViewItemTemplateSettings; };
struct ITreeViewItemTemplateSettings : ITreeViewItemTemplateSettings_raw, generate<ITreeViewItemTemplateSettings> {};

// ITreeViewFactory
struct ITreeViewFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, TreeView* *instance);
};

// ITreeViewStatics
struct ITreeViewStatics : IInspectable {
	virtual STDMETHODIMP _get_SelectionModeProperty(DependencyProperty* *value);
};

// ITreeView
struct ITreeView_raw : IInspectable {
	virtual STDMETHODIMP _get_RootNodes(Foundation::Collections::IVector<TreeViewNode*>* *value);
	virtual STDMETHODIMP _get_SelectionMode(TreeViewSelectionMode *value);
	virtual STDMETHODIMP _put_SelectionMode(TreeViewSelectionMode value);
	virtual STDMETHODIMP _get_SelectedNodes(Foundation::Collections::IVector<TreeViewNode*>* *value);
	virtual STDMETHODIMP _Expand(TreeViewNode* value);
	virtual STDMETHODIMP _Collapse(TreeViewNode* value);
	virtual STDMETHODIMP _SelectAll();
	virtual STDMETHODIMP _add_ItemInvoked(Foundation::TypedEventHandler<TreeView*, TreeViewItemInvokedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ItemInvoked(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Expanding(Foundation::TypedEventHandler<TreeView*, TreeViewExpandingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Expanding(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Collapsed(Foundation::TypedEventHandler<TreeView*, TreeViewCollapsedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Collapsed(Foundation::EventRegistrationToken token);
};
template<typename X> struct ITreeView_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<TreeViewNode>>> get() { Foundation::Collections::IVector<TreeViewNode*>* value; hrcheck(enc(&ITreeView_adaptor::RootNodes)->_get_RootNodes(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<TreeViewNode>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<TreeViewNode>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<TreeViewNode>>> operator->() { return get(); }
		} RootNodes;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<TreeViewNode>>> get() { Foundation::Collections::IVector<TreeViewNode*>* value; hrcheck(enc(&ITreeView_adaptor::SelectedNodes)->_get_SelectedNodes(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<TreeViewNode>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<TreeViewNode>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<TreeViewNode>>> operator->() { return get(); }
		} SelectedNodes;
		struct : property {
			TreeViewSelectionMode get() { TreeViewSelectionMode value; hrcheck(enc(&ITreeView_adaptor::SelectionMode)->_get_SelectionMode(&value)); return value; }
			TreeViewSelectionMode operator()() { return get(); }
			operator TreeViewSelectionMode () { return get(); }
			void put(TreeViewSelectionMode value) { hrcheck(enc(&ITreeView_adaptor::SelectionMode)->_put_SelectionMode(value)); }
			void operator=(TreeViewSelectionMode value) { put(value); }
			void operator()(TreeViewSelectionMode value) { put(value); }
		} SelectionMode;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TreeView>, ptr<TreeViewCollapsedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITreeView_adaptor::Collapsed)->_add_Collapsed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITreeView_adaptor::Collapsed)->_remove_Collapsed(token)); }
		} Collapsed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TreeView>, ptr<TreeViewExpandingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITreeView_adaptor::Expanding)->_add_Expanding(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITreeView_adaptor::Expanding)->_remove_Expanding(token)); }
		} Expanding;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TreeView>, ptr<TreeViewItemInvokedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITreeView_adaptor::ItemInvoked)->_add_ItemInvoked(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITreeView_adaptor::ItemInvoked)->_remove_ItemInvoked(token)); }
		} ItemInvoked;
	};
	void Expand(pptr<TreeViewNode> value) { hrcheck(X::get()->_Expand(value)); }
	void Collapse(pptr<TreeViewNode> value) { hrcheck(X::get()->_Collapse(value)); }
	void SelectAll() { hrcheck(X::get()->_SelectAll()); }
	ITreeView_adaptor() {}
};
template<typename X> struct adapt<ITreeView, X> : Windows::UI::Xaml::Controls::ITreeView_adaptor<X> { typedef adapt ITreeView; };
struct ITreeView : ITreeView_raw, generate<ITreeView> {};

// ITreeViewListFactory
struct ITreeViewListFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, TreeViewList* *instance);
};

// ITreeViewList
struct ITreeViewList : IInspectable, generate<ITreeViewList> {};

// ITreeViewCollapsedEventArgs
struct ITreeViewCollapsedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Node(TreeViewNode* *value);
};
template<typename X> struct ITreeViewCollapsedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<TreeViewNode> get() { TreeViewNode* value; hrcheck(enc(&ITreeViewCollapsedEventArgs_adaptor::Node)->_get_Node(&value)); return from_abi(value); }
			ptr<TreeViewNode> operator()() { return get(); }
			operator ptr<TreeViewNode> () { return get(); }
			ptr<TreeViewNode> operator->() { return get(); }
		} Node;
	};
	ITreeViewCollapsedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITreeViewCollapsedEventArgs, X> : Windows::UI::Xaml::Controls::ITreeViewCollapsedEventArgs_adaptor<X> { typedef adapt ITreeViewCollapsedEventArgs; };
struct ITreeViewCollapsedEventArgs : ITreeViewCollapsedEventArgs_raw, generate<ITreeViewCollapsedEventArgs> {};

// TreeViewCollapsedEventArgs
template<typename X> struct statics<TreeViewCollapsedEventArgs, X> : X {
	typedef typename X::root_type TreeViewCollapsedEventArgs;
};
struct TreeViewCollapsedEventArgs : generate<TreeViewCollapsedEventArgs> {};

// ITreeViewExpandingEventArgs
struct ITreeViewExpandingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Node(TreeViewNode* *value);
};
template<typename X> struct ITreeViewExpandingEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<TreeViewNode> get() { TreeViewNode* value; hrcheck(enc(&ITreeViewExpandingEventArgs_adaptor::Node)->_get_Node(&value)); return from_abi(value); }
			ptr<TreeViewNode> operator()() { return get(); }
			operator ptr<TreeViewNode> () { return get(); }
			ptr<TreeViewNode> operator->() { return get(); }
		} Node;
	};
	ITreeViewExpandingEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITreeViewExpandingEventArgs, X> : Windows::UI::Xaml::Controls::ITreeViewExpandingEventArgs_adaptor<X> { typedef adapt ITreeViewExpandingEventArgs; };
struct ITreeViewExpandingEventArgs : ITreeViewExpandingEventArgs_raw, generate<ITreeViewExpandingEventArgs> {};

// TreeViewExpandingEventArgs
template<typename X> struct statics<TreeViewExpandingEventArgs, X> : X {
	typedef typename X::root_type TreeViewExpandingEventArgs;
};
struct TreeViewExpandingEventArgs : generate<TreeViewExpandingEventArgs> {};

// ITreeViewNodeFactory
struct ITreeViewNodeFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, TreeViewNode* *instance);
};

// ITreeViewNodeStatics
struct ITreeViewNodeStatics : IInspectable {
	virtual STDMETHODIMP _get_ContentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DepthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsExpandedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HasChildrenProperty(DependencyProperty* *value);
};

// ITreeViewNode
struct ITreeViewNode_raw : IInspectable {
	virtual STDMETHODIMP _get_Content(IInspectable* *value);
	virtual STDMETHODIMP _put_Content(IInspectable* value);
	virtual STDMETHODIMP _get_Parent(TreeViewNode* *value);
	virtual STDMETHODIMP _get_IsExpanded(bool *value);
	virtual STDMETHODIMP _put_IsExpanded(bool value);
	virtual STDMETHODIMP _get_HasChildren(bool *value);
	virtual STDMETHODIMP _get_Depth(int *value);
	virtual STDMETHODIMP _get_HasUnrealizedChildren(bool *value);
	virtual STDMETHODIMP _put_HasUnrealizedChildren(bool value);
	virtual STDMETHODIMP _get_Children(Foundation::Collections::IVector<TreeViewNode*>* *value);
};
template<typename X> struct ITreeViewNode_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<TreeViewNode>>> get() { Foundation::Collections::IVector<TreeViewNode*>* value; hrcheck(enc(&ITreeViewNode_adaptor::Children)->_get_Children(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<TreeViewNode>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<TreeViewNode>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<TreeViewNode>>> operator->() { return get(); }
		} Children;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ITreeViewNode_adaptor::Content)->_get_Content(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&ITreeViewNode_adaptor::Content)->_put_Content(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Content;
		struct : property {
			int get() { int value; hrcheck(enc(&ITreeViewNode_adaptor::Depth)->_get_Depth(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} Depth;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITreeViewNode_adaptor::HasChildren)->_get_HasChildren(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasChildren;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITreeViewNode_adaptor::HasUnrealizedChildren)->_get_HasUnrealizedChildren(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITreeViewNode_adaptor::HasUnrealizedChildren)->_put_HasUnrealizedChildren(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} HasUnrealizedChildren;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITreeViewNode_adaptor::IsExpanded)->_get_IsExpanded(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITreeViewNode_adaptor::IsExpanded)->_put_IsExpanded(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsExpanded;
		struct : property {
			ptr<TreeViewNode> get() { TreeViewNode* value; hrcheck(enc(&ITreeViewNode_adaptor::Parent)->_get_Parent(&value)); return from_abi(value); }
			ptr<TreeViewNode> operator()() { return get(); }
			operator ptr<TreeViewNode> () { return get(); }
			ptr<TreeViewNode> operator->() { return get(); }
		} Parent;
	};
	ITreeViewNode_adaptor() {}
};
template<typename X> struct adapt<ITreeViewNode, X> : Windows::UI::Xaml::Controls::ITreeViewNode_adaptor<X> { typedef adapt ITreeViewNode; };
struct ITreeViewNode : ITreeViewNode_raw, generate<ITreeViewNode> {};

// ITreeViewItemInvokedEventArgs
struct ITreeViewItemInvokedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_InvokedItem(IInspectable* *value);
	virtual STDMETHODIMP _put_Handled(bool value);
	virtual STDMETHODIMP _get_Handled(bool *value);
};
template<typename X> struct ITreeViewItemInvokedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITreeViewItemInvokedEventArgs_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ITreeViewItemInvokedEventArgs_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ITreeViewItemInvokedEventArgs_adaptor::InvokedItem)->_get_InvokedItem(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} InvokedItem;
	};
	ITreeViewItemInvokedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITreeViewItemInvokedEventArgs, X> : Windows::UI::Xaml::Controls::ITreeViewItemInvokedEventArgs_adaptor<X> { typedef adapt ITreeViewItemInvokedEventArgs; };
struct ITreeViewItemInvokedEventArgs : ITreeViewItemInvokedEventArgs_raw, generate<ITreeViewItemInvokedEventArgs> {};

// TreeViewItemInvokedEventArgs
template<typename X> struct statics<TreeViewItemInvokedEventArgs, X> : X {
	typedef typename X::root_type TreeViewItemInvokedEventArgs;
};
struct TreeViewItemInvokedEventArgs : generate<TreeViewItemInvokedEventArgs> {};

// ISwipeControlStatics
struct ISwipeControlStatics : IInspectable {
	virtual STDMETHODIMP _get_LeftItemsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RightItemsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TopItemsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BottomItemsProperty(DependencyProperty* *value);
};

// ISwipeControlFactory
struct ISwipeControlFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, SwipeControl* *instance);
};

// ISwipeControl
struct ISwipeControl_raw : IInspectable {
	virtual STDMETHODIMP _get_LeftItems(SwipeItems* *value);
	virtual STDMETHODIMP _put_LeftItems(SwipeItems* value);
	virtual STDMETHODIMP _get_RightItems(SwipeItems* *value);
	virtual STDMETHODIMP _put_RightItems(SwipeItems* value);
	virtual STDMETHODIMP _get_TopItems(SwipeItems* *value);
	virtual STDMETHODIMP _put_TopItems(SwipeItems* value);
	virtual STDMETHODIMP _get_BottomItems(SwipeItems* *value);
	virtual STDMETHODIMP _put_BottomItems(SwipeItems* value);
	virtual STDMETHODIMP _Close();
};
template<typename X> struct ISwipeControl_adaptor : X {
	union {
		struct : property {
			ptr<SwipeItems> get() { SwipeItems* value; hrcheck(enc(&ISwipeControl_adaptor::BottomItems)->_get_BottomItems(&value)); return from_abi(value); }
			ptr<SwipeItems> operator()() { return get(); }
			operator ptr<SwipeItems> () { return get(); }
			ptr<SwipeItems> operator->() { return get(); }
			void put(pptr<SwipeItems> value) { hrcheck(enc(&ISwipeControl_adaptor::BottomItems)->_put_BottomItems(value)); }
			void operator=(pptr<SwipeItems> value) { put(value); }
			void operator()(pptr<SwipeItems> value) { put(value); }
		} BottomItems;
		struct : property {
			ptr<SwipeItems> get() { SwipeItems* value; hrcheck(enc(&ISwipeControl_adaptor::LeftItems)->_get_LeftItems(&value)); return from_abi(value); }
			ptr<SwipeItems> operator()() { return get(); }
			operator ptr<SwipeItems> () { return get(); }
			ptr<SwipeItems> operator->() { return get(); }
			void put(pptr<SwipeItems> value) { hrcheck(enc(&ISwipeControl_adaptor::LeftItems)->_put_LeftItems(value)); }
			void operator=(pptr<SwipeItems> value) { put(value); }
			void operator()(pptr<SwipeItems> value) { put(value); }
		} LeftItems;
		struct : property {
			ptr<SwipeItems> get() { SwipeItems* value; hrcheck(enc(&ISwipeControl_adaptor::RightItems)->_get_RightItems(&value)); return from_abi(value); }
			ptr<SwipeItems> operator()() { return get(); }
			operator ptr<SwipeItems> () { return get(); }
			ptr<SwipeItems> operator->() { return get(); }
			void put(pptr<SwipeItems> value) { hrcheck(enc(&ISwipeControl_adaptor::RightItems)->_put_RightItems(value)); }
			void operator=(pptr<SwipeItems> value) { put(value); }
			void operator()(pptr<SwipeItems> value) { put(value); }
		} RightItems;
		struct : property {
			ptr<SwipeItems> get() { SwipeItems* value; hrcheck(enc(&ISwipeControl_adaptor::TopItems)->_get_TopItems(&value)); return from_abi(value); }
			ptr<SwipeItems> operator()() { return get(); }
			operator ptr<SwipeItems> () { return get(); }
			ptr<SwipeItems> operator->() { return get(); }
			void put(pptr<SwipeItems> value) { hrcheck(enc(&ISwipeControl_adaptor::TopItems)->_put_TopItems(value)); }
			void operator=(pptr<SwipeItems> value) { put(value); }
			void operator()(pptr<SwipeItems> value) { put(value); }
		} TopItems;
	};
	void Close() { hrcheck(X::get()->_Close()); }
	ISwipeControl_adaptor() {}
};
template<typename X> struct adapt<ISwipeControl, X> : Windows::UI::Xaml::Controls::ISwipeControl_adaptor<X> { typedef adapt ISwipeControl; };
struct ISwipeControl : ISwipeControl_raw, generate<ISwipeControl> {};

// ISwipeItemsStatics
struct ISwipeItemsStatics : IInspectable {
	virtual STDMETHODIMP _get_ModeProperty(DependencyProperty* *value);
};

// ISwipeItemsFactory
struct ISwipeItemsFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, SwipeItems* *instance);
};

// ISwipeItems
struct ISwipeItems_raw : IInspectable {
	virtual STDMETHODIMP _get_Mode(SwipeMode *value);
	virtual STDMETHODIMP _put_Mode(SwipeMode value);
};
template<typename X> struct ISwipeItems_adaptor : X {
	union {
		struct : property {
			SwipeMode get() { SwipeMode value; hrcheck(enc(&ISwipeItems_adaptor::Mode)->_get_Mode(&value)); return value; }
			SwipeMode operator()() { return get(); }
			operator SwipeMode () { return get(); }
			void put(SwipeMode value) { hrcheck(enc(&ISwipeItems_adaptor::Mode)->_put_Mode(value)); }
			void operator=(SwipeMode value) { put(value); }
			void operator()(SwipeMode value) { put(value); }
		} Mode;
	};
	ISwipeItems_adaptor() {}
};
template<typename X> struct adapt<ISwipeItems, X> : Windows::UI::Xaml::Controls::ISwipeItems_adaptor<X> { typedef adapt ISwipeItems; };
struct ISwipeItems : ISwipeItems_raw, generate<ISwipeItems> {};

// ISwipeItemInvokedEventArgs
struct ISwipeItemInvokedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_SwipeControl(Controls::SwipeControl* *value);
};
template<typename X> struct ISwipeItemInvokedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Controls::SwipeControl> get() { Controls::SwipeControl* value; hrcheck(enc(&ISwipeItemInvokedEventArgs_adaptor::SwipeControl)->_get_SwipeControl(&value)); return from_abi(value); }
			ptr<Controls::SwipeControl> operator()() { return get(); }
			operator ptr<Controls::SwipeControl> () { return get(); }
			ptr<Controls::SwipeControl> operator->() { return get(); }
		} SwipeControl;
	};
	ISwipeItemInvokedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISwipeItemInvokedEventArgs, X> : Windows::UI::Xaml::Controls::ISwipeItemInvokedEventArgs_adaptor<X> { typedef adapt ISwipeItemInvokedEventArgs; };
struct ISwipeItemInvokedEventArgs : ISwipeItemInvokedEventArgs_raw, generate<ISwipeItemInvokedEventArgs> {};

// IRatingItemInfoFactory
struct IRatingItemInfoFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, RatingItemInfo* *instance);
};

// IRatingItemInfo
struct IRatingItemInfo : IInspectable, generate<IRatingItemInfo> {};

// RatingItemInfo
template<typename> struct RatingItemInfo_statics {
	static RatingItemInfo *activate(object_ref outer, IInspectable* *inner) { RatingItemInfo *instance; hrcheck(get_activation_factory<RatingItemInfo, IRatingItemInfoFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<RatingItemInfo, X> : X, Windows::UI::Xaml::Controls::RatingItemInfo_statics<void> {
	using Windows::UI::Xaml::Controls::RatingItemInfo_statics<void>::activate;
	typedef typename X::root_type RatingItemInfo;
};
struct RatingItemInfo : generate<RatingItemInfo> {};

// IRatingItemFontInfoStatics
struct IRatingItemFontInfoStatics : IInspectable {
	virtual STDMETHODIMP _get_DisabledGlyphProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_GlyphProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlaceholderGlyphProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PointerOverGlyphProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PointerOverPlaceholderGlyphProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_UnsetGlyphProperty(DependencyProperty* *value);
};

// IRatingItemFontInfoFactory
struct IRatingItemFontInfoFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, RatingItemFontInfo* *instance);
};

// IRatingItemFontInfo
struct IRatingItemFontInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_DisabledGlyph(HSTRING *value);
	virtual STDMETHODIMP _put_DisabledGlyph(HSTRING value);
	virtual STDMETHODIMP _get_Glyph(HSTRING *value);
	virtual STDMETHODIMP _put_Glyph(HSTRING value);
	virtual STDMETHODIMP _get_PointerOverGlyph(HSTRING *value);
	virtual STDMETHODIMP _put_PointerOverGlyph(HSTRING value);
	virtual STDMETHODIMP _get_PointerOverPlaceholderGlyph(HSTRING *value);
	virtual STDMETHODIMP _put_PointerOverPlaceholderGlyph(HSTRING value);
	virtual STDMETHODIMP _get_PlaceholderGlyph(HSTRING *value);
	virtual STDMETHODIMP _put_PlaceholderGlyph(HSTRING value);
	virtual STDMETHODIMP _get_UnsetGlyph(HSTRING *value);
	virtual STDMETHODIMP _put_UnsetGlyph(HSTRING value);
};
template<typename X> struct IRatingItemFontInfo_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRatingItemFontInfo_adaptor::DisabledGlyph)->_get_DisabledGlyph(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IRatingItemFontInfo_adaptor::DisabledGlyph)->_put_DisabledGlyph(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DisabledGlyph;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRatingItemFontInfo_adaptor::Glyph)->_get_Glyph(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IRatingItemFontInfo_adaptor::Glyph)->_put_Glyph(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Glyph;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRatingItemFontInfo_adaptor::PlaceholderGlyph)->_get_PlaceholderGlyph(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IRatingItemFontInfo_adaptor::PlaceholderGlyph)->_put_PlaceholderGlyph(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PlaceholderGlyph;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRatingItemFontInfo_adaptor::PointerOverGlyph)->_get_PointerOverGlyph(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IRatingItemFontInfo_adaptor::PointerOverGlyph)->_put_PointerOverGlyph(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PointerOverGlyph;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRatingItemFontInfo_adaptor::PointerOverPlaceholderGlyph)->_get_PointerOverPlaceholderGlyph(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IRatingItemFontInfo_adaptor::PointerOverPlaceholderGlyph)->_put_PointerOverPlaceholderGlyph(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PointerOverPlaceholderGlyph;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRatingItemFontInfo_adaptor::UnsetGlyph)->_get_UnsetGlyph(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IRatingItemFontInfo_adaptor::UnsetGlyph)->_put_UnsetGlyph(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} UnsetGlyph;
	};
	IRatingItemFontInfo_adaptor() {}
};
template<typename X> struct adapt<IRatingItemFontInfo, X> : Windows::UI::Xaml::Controls::IRatingItemFontInfo_adaptor<X> { typedef adapt IRatingItemFontInfo; };
struct IRatingItemFontInfo : IRatingItemFontInfo_raw, generate<IRatingItemFontInfo> {};

// RatingItemFontInfo
template<typename> struct RatingItemFontInfo_statics {
	static struct _DisabledGlyphProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingItemFontInfo, IRatingItemFontInfoStatics>()->_get_DisabledGlyphProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DisabledGlyphProperty;
	static struct _GlyphProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingItemFontInfo, IRatingItemFontInfoStatics>()->_get_GlyphProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GlyphProperty;
	static struct _PlaceholderGlyphProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingItemFontInfo, IRatingItemFontInfoStatics>()->_get_PlaceholderGlyphProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlaceholderGlyphProperty;
	static struct _PointerOverGlyphProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingItemFontInfo, IRatingItemFontInfoStatics>()->_get_PointerOverGlyphProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PointerOverGlyphProperty;
	static struct _PointerOverPlaceholderGlyphProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingItemFontInfo, IRatingItemFontInfoStatics>()->_get_PointerOverPlaceholderGlyphProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PointerOverPlaceholderGlyphProperty;
	static struct _UnsetGlyphProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingItemFontInfo, IRatingItemFontInfoStatics>()->_get_UnsetGlyphProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} UnsetGlyphProperty;
	static RatingItemFontInfo *activate(object_ref outer, IInspectable* *inner) { RatingItemFontInfo *instance; hrcheck(get_activation_factory<RatingItemFontInfo, IRatingItemFontInfoFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename RatingItemFontInfo_statics<X>::_DisabledGlyphProperty RatingItemFontInfo_statics<X>::DisabledGlyphProperty;
template<typename X> typename RatingItemFontInfo_statics<X>::_GlyphProperty RatingItemFontInfo_statics<X>::GlyphProperty;
template<typename X> typename RatingItemFontInfo_statics<X>::_PlaceholderGlyphProperty RatingItemFontInfo_statics<X>::PlaceholderGlyphProperty;
template<typename X> typename RatingItemFontInfo_statics<X>::_PointerOverGlyphProperty RatingItemFontInfo_statics<X>::PointerOverGlyphProperty;
template<typename X> typename RatingItemFontInfo_statics<X>::_PointerOverPlaceholderGlyphProperty RatingItemFontInfo_statics<X>::PointerOverPlaceholderGlyphProperty;
template<typename X> typename RatingItemFontInfo_statics<X>::_UnsetGlyphProperty RatingItemFontInfo_statics<X>::UnsetGlyphProperty;

template<typename X> struct statics<RatingItemFontInfo, X> : X, Windows::UI::Xaml::Controls::RatingItemFontInfo_statics<void> {
	using Windows::UI::Xaml::Controls::RatingItemFontInfo_statics<void>::activate;
	typedef typename X::root_type RatingItemFontInfo;
};
struct RatingItemFontInfo : generate<RatingItemFontInfo> {};

// IRatingItemImageInfoStatics
struct IRatingItemImageInfoStatics : IInspectable {
	virtual STDMETHODIMP _get_DisabledImageProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ImageProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlaceholderImageProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PointerOverImageProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PointerOverPlaceholderImageProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_UnsetImageProperty(DependencyProperty* *value);
};

// IRatingItemImageInfoFactory
struct IRatingItemImageInfoFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, RatingItemImageInfo* *instance);
};

// IRatingItemImageInfo
struct IRatingItemImageInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_DisabledImage(Media::ImageSource* *value);
	virtual STDMETHODIMP _put_DisabledImage(Media::ImageSource* value);
	virtual STDMETHODIMP _get_Image(Media::ImageSource* *value);
	virtual STDMETHODIMP _put_Image(Media::ImageSource* value);
	virtual STDMETHODIMP _get_PlaceholderImage(Media::ImageSource* *value);
	virtual STDMETHODIMP _put_PlaceholderImage(Media::ImageSource* value);
	virtual STDMETHODIMP _get_PointerOverImage(Media::ImageSource* *value);
	virtual STDMETHODIMP _put_PointerOverImage(Media::ImageSource* value);
	virtual STDMETHODIMP _get_PointerOverPlaceholderImage(Media::ImageSource* *value);
	virtual STDMETHODIMP _put_PointerOverPlaceholderImage(Media::ImageSource* value);
	virtual STDMETHODIMP _get_UnsetImage(Media::ImageSource* *value);
	virtual STDMETHODIMP _put_UnsetImage(Media::ImageSource* value);
};
template<typename X> struct IRatingItemImageInfo_adaptor : X {
	union {
		struct : property {
			ptr<Media::ImageSource> get() { Media::ImageSource* value; hrcheck(enc(&IRatingItemImageInfo_adaptor::DisabledImage)->_get_DisabledImage(&value)); return from_abi(value); }
			ptr<Media::ImageSource> operator()() { return get(); }
			operator ptr<Media::ImageSource> () { return get(); }
			ptr<Media::ImageSource> operator->() { return get(); }
			void put(pptr<Media::ImageSource> value) { hrcheck(enc(&IRatingItemImageInfo_adaptor::DisabledImage)->_put_DisabledImage(value)); }
			void operator=(pptr<Media::ImageSource> value) { put(value); }
			void operator()(pptr<Media::ImageSource> value) { put(value); }
		} DisabledImage;
		struct : property {
			ptr<Media::ImageSource> get() { Media::ImageSource* value; hrcheck(enc(&IRatingItemImageInfo_adaptor::Image)->_get_Image(&value)); return from_abi(value); }
			ptr<Media::ImageSource> operator()() { return get(); }
			operator ptr<Media::ImageSource> () { return get(); }
			ptr<Media::ImageSource> operator->() { return get(); }
			void put(pptr<Media::ImageSource> value) { hrcheck(enc(&IRatingItemImageInfo_adaptor::Image)->_put_Image(value)); }
			void operator=(pptr<Media::ImageSource> value) { put(value); }
			void operator()(pptr<Media::ImageSource> value) { put(value); }
		} Image;
		struct : property {
			ptr<Media::ImageSource> get() { Media::ImageSource* value; hrcheck(enc(&IRatingItemImageInfo_adaptor::PlaceholderImage)->_get_PlaceholderImage(&value)); return from_abi(value); }
			ptr<Media::ImageSource> operator()() { return get(); }
			operator ptr<Media::ImageSource> () { return get(); }
			ptr<Media::ImageSource> operator->() { return get(); }
			void put(pptr<Media::ImageSource> value) { hrcheck(enc(&IRatingItemImageInfo_adaptor::PlaceholderImage)->_put_PlaceholderImage(value)); }
			void operator=(pptr<Media::ImageSource> value) { put(value); }
			void operator()(pptr<Media::ImageSource> value) { put(value); }
		} PlaceholderImage;
		struct : property {
			ptr<Media::ImageSource> get() { Media::ImageSource* value; hrcheck(enc(&IRatingItemImageInfo_adaptor::PointerOverImage)->_get_PointerOverImage(&value)); return from_abi(value); }
			ptr<Media::ImageSource> operator()() { return get(); }
			operator ptr<Media::ImageSource> () { return get(); }
			ptr<Media::ImageSource> operator->() { return get(); }
			void put(pptr<Media::ImageSource> value) { hrcheck(enc(&IRatingItemImageInfo_adaptor::PointerOverImage)->_put_PointerOverImage(value)); }
			void operator=(pptr<Media::ImageSource> value) { put(value); }
			void operator()(pptr<Media::ImageSource> value) { put(value); }
		} PointerOverImage;
		struct : property {
			ptr<Media::ImageSource> get() { Media::ImageSource* value; hrcheck(enc(&IRatingItemImageInfo_adaptor::PointerOverPlaceholderImage)->_get_PointerOverPlaceholderImage(&value)); return from_abi(value); }
			ptr<Media::ImageSource> operator()() { return get(); }
			operator ptr<Media::ImageSource> () { return get(); }
			ptr<Media::ImageSource> operator->() { return get(); }
			void put(pptr<Media::ImageSource> value) { hrcheck(enc(&IRatingItemImageInfo_adaptor::PointerOverPlaceholderImage)->_put_PointerOverPlaceholderImage(value)); }
			void operator=(pptr<Media::ImageSource> value) { put(value); }
			void operator()(pptr<Media::ImageSource> value) { put(value); }
		} PointerOverPlaceholderImage;
		struct : property {
			ptr<Media::ImageSource> get() { Media::ImageSource* value; hrcheck(enc(&IRatingItemImageInfo_adaptor::UnsetImage)->_get_UnsetImage(&value)); return from_abi(value); }
			ptr<Media::ImageSource> operator()() { return get(); }
			operator ptr<Media::ImageSource> () { return get(); }
			ptr<Media::ImageSource> operator->() { return get(); }
			void put(pptr<Media::ImageSource> value) { hrcheck(enc(&IRatingItemImageInfo_adaptor::UnsetImage)->_put_UnsetImage(value)); }
			void operator=(pptr<Media::ImageSource> value) { put(value); }
			void operator()(pptr<Media::ImageSource> value) { put(value); }
		} UnsetImage;
	};
	IRatingItemImageInfo_adaptor() {}
};
template<typename X> struct adapt<IRatingItemImageInfo, X> : Windows::UI::Xaml::Controls::IRatingItemImageInfo_adaptor<X> { typedef adapt IRatingItemImageInfo; };
struct IRatingItemImageInfo : IRatingItemImageInfo_raw, generate<IRatingItemImageInfo> {};

// RatingItemImageInfo
template<typename> struct RatingItemImageInfo_statics {
	static struct _DisabledImageProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingItemImageInfo, IRatingItemImageInfoStatics>()->_get_DisabledImageProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DisabledImageProperty;
	static struct _ImageProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingItemImageInfo, IRatingItemImageInfoStatics>()->_get_ImageProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ImageProperty;
	static struct _PlaceholderImageProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingItemImageInfo, IRatingItemImageInfoStatics>()->_get_PlaceholderImageProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlaceholderImageProperty;
	static struct _PointerOverImageProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingItemImageInfo, IRatingItemImageInfoStatics>()->_get_PointerOverImageProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PointerOverImageProperty;
	static struct _PointerOverPlaceholderImageProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingItemImageInfo, IRatingItemImageInfoStatics>()->_get_PointerOverPlaceholderImageProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PointerOverPlaceholderImageProperty;
	static struct _UnsetImageProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingItemImageInfo, IRatingItemImageInfoStatics>()->_get_UnsetImageProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} UnsetImageProperty;
	static RatingItemImageInfo *activate(object_ref outer, IInspectable* *inner) { RatingItemImageInfo *instance; hrcheck(get_activation_factory<RatingItemImageInfo, IRatingItemImageInfoFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename RatingItemImageInfo_statics<X>::_DisabledImageProperty RatingItemImageInfo_statics<X>::DisabledImageProperty;
template<typename X> typename RatingItemImageInfo_statics<X>::_ImageProperty RatingItemImageInfo_statics<X>::ImageProperty;
template<typename X> typename RatingItemImageInfo_statics<X>::_PlaceholderImageProperty RatingItemImageInfo_statics<X>::PlaceholderImageProperty;
template<typename X> typename RatingItemImageInfo_statics<X>::_PointerOverImageProperty RatingItemImageInfo_statics<X>::PointerOverImageProperty;
template<typename X> typename RatingItemImageInfo_statics<X>::_PointerOverPlaceholderImageProperty RatingItemImageInfo_statics<X>::PointerOverPlaceholderImageProperty;
template<typename X> typename RatingItemImageInfo_statics<X>::_UnsetImageProperty RatingItemImageInfo_statics<X>::UnsetImageProperty;

template<typename X> struct statics<RatingItemImageInfo, X> : X, Windows::UI::Xaml::Controls::RatingItemImageInfo_statics<void> {
	using Windows::UI::Xaml::Controls::RatingItemImageInfo_statics<void>::activate;
	typedef typename X::root_type RatingItemImageInfo;
};
struct RatingItemImageInfo : generate<RatingItemImageInfo> {};

// ISwipeItemFactory
struct ISwipeItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, SwipeItem* *instance);
};

// ISwipeItemStatics
struct ISwipeItemStatics : IInspectable {
	virtual STDMETHODIMP _get_IconSourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BackgroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ForegroundProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CommandProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CommandParameterProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BehaviorOnInvokedProperty(DependencyProperty* *value);
};

// ISwipeItem
struct ISwipeItem_raw : IInspectable {
	virtual STDMETHODIMP _get_Text(HSTRING *value);
	virtual STDMETHODIMP _put_Text(HSTRING value);
	virtual STDMETHODIMP _get_IconSource(Controls::IconSource* *value);
	virtual STDMETHODIMP _put_IconSource(Controls::IconSource* value);
	virtual STDMETHODIMP _get_Background(Media::Brush* *value);
	virtual STDMETHODIMP _put_Background(Media::Brush* value);
	virtual STDMETHODIMP _get_Foreground(Media::Brush* *value);
	virtual STDMETHODIMP _put_Foreground(Media::Brush* value);
	virtual STDMETHODIMP _get_Command(Input::ICommand* *value);
	virtual STDMETHODIMP _put_Command(Input::ICommand* value);
	virtual STDMETHODIMP _get_CommandParameter(IInspectable* *value);
	virtual STDMETHODIMP _put_CommandParameter(IInspectable* value);
	virtual STDMETHODIMP _get_BehaviorOnInvoked(SwipeBehaviorOnInvoked *value);
	virtual STDMETHODIMP _put_BehaviorOnInvoked(SwipeBehaviorOnInvoked value);
	virtual STDMETHODIMP _add_Invoked(Foundation::TypedEventHandler<SwipeItem*, SwipeItemInvokedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Invoked(Foundation::EventRegistrationToken token);
};
template<typename X> struct ISwipeItem_adaptor : X {
	union {
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ISwipeItem_adaptor::Background)->_get_Background(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ISwipeItem_adaptor::Background)->_put_Background(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Background;
		struct : property {
			SwipeBehaviorOnInvoked get() { SwipeBehaviorOnInvoked value; hrcheck(enc(&ISwipeItem_adaptor::BehaviorOnInvoked)->_get_BehaviorOnInvoked(&value)); return value; }
			SwipeBehaviorOnInvoked operator()() { return get(); }
			operator SwipeBehaviorOnInvoked () { return get(); }
			void put(SwipeBehaviorOnInvoked value) { hrcheck(enc(&ISwipeItem_adaptor::BehaviorOnInvoked)->_put_BehaviorOnInvoked(value)); }
			void operator=(SwipeBehaviorOnInvoked value) { put(value); }
			void operator()(SwipeBehaviorOnInvoked value) { put(value); }
		} BehaviorOnInvoked;
		struct : property {
			ptr<Input::ICommand> get() { Input::ICommand* value; hrcheck(enc(&ISwipeItem_adaptor::Command)->_get_Command(&value)); return from_abi(value); }
			ptr<Input::ICommand> operator()() { return get(); }
			operator ptr<Input::ICommand> () { return get(); }
			ptr<Input::ICommand> operator->() { return get(); }
			void put(pptr<Input::ICommand> value) { hrcheck(enc(&ISwipeItem_adaptor::Command)->_put_Command(value)); }
			void operator=(pptr<Input::ICommand> value) { put(value); }
			void operator()(pptr<Input::ICommand> value) { put(value); }
		} Command;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&ISwipeItem_adaptor::CommandParameter)->_get_CommandParameter(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&ISwipeItem_adaptor::CommandParameter)->_put_CommandParameter(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} CommandParameter;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&ISwipeItem_adaptor::Foreground)->_get_Foreground(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
			void put(pptr<Media::Brush> value) { hrcheck(enc(&ISwipeItem_adaptor::Foreground)->_put_Foreground(value)); }
			void operator=(pptr<Media::Brush> value) { put(value); }
			void operator()(pptr<Media::Brush> value) { put(value); }
		} Foreground;
		struct : property {
			ptr<Controls::IconSource> get() { Controls::IconSource* value; hrcheck(enc(&ISwipeItem_adaptor::IconSource)->_get_IconSource(&value)); return from_abi(value); }
			ptr<Controls::IconSource> operator()() { return get(); }
			operator ptr<Controls::IconSource> () { return get(); }
			ptr<Controls::IconSource> operator->() { return get(); }
			void put(pptr<Controls::IconSource> value) { hrcheck(enc(&ISwipeItem_adaptor::IconSource)->_put_IconSource(value)); }
			void operator=(pptr<Controls::IconSource> value) { put(value); }
			void operator()(pptr<Controls::IconSource> value) { put(value); }
		} IconSource;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISwipeItem_adaptor::Text)->_get_Text(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ISwipeItem_adaptor::Text)->_put_Text(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Text;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SwipeItem>, ptr<SwipeItemInvokedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISwipeItem_adaptor::Invoked)->_add_Invoked(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISwipeItem_adaptor::Invoked)->_remove_Invoked(token)); }
		} Invoked;
	};
	ISwipeItem_adaptor() {}
};
template<typename X> struct adapt<ISwipeItem, X> : Windows::UI::Xaml::Controls::ISwipeItem_adaptor<X> { typedef adapt ISwipeItem; };
struct ISwipeItem : ISwipeItem_raw, generate<ISwipeItem> {};

// SwipeItem
template<typename> struct SwipeItem_statics {
	static struct _BackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeItem, ISwipeItemStatics>()->_get_BackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BackgroundProperty;
	static struct _BehaviorOnInvokedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeItem, ISwipeItemStatics>()->_get_BehaviorOnInvokedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BehaviorOnInvokedProperty;
	static struct _CommandParameterProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeItem, ISwipeItemStatics>()->_get_CommandParameterProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CommandParameterProperty;
	static struct _CommandProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeItem, ISwipeItemStatics>()->_get_CommandProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CommandProperty;
	static struct _ForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeItem, ISwipeItemStatics>()->_get_ForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ForegroundProperty;
	static struct _IconSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeItem, ISwipeItemStatics>()->_get_IconSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IconSourceProperty;
	static struct _TextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeItem, ISwipeItemStatics>()->_get_TextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextProperty;
	static SwipeItem *activate(object_ref outer, IInspectable* *inner) { SwipeItem *instance; hrcheck(get_activation_factory<SwipeItem, ISwipeItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename SwipeItem_statics<X>::_BackgroundProperty SwipeItem_statics<X>::BackgroundProperty;
template<typename X> typename SwipeItem_statics<X>::_BehaviorOnInvokedProperty SwipeItem_statics<X>::BehaviorOnInvokedProperty;
template<typename X> typename SwipeItem_statics<X>::_CommandParameterProperty SwipeItem_statics<X>::CommandParameterProperty;
template<typename X> typename SwipeItem_statics<X>::_CommandProperty SwipeItem_statics<X>::CommandProperty;
template<typename X> typename SwipeItem_statics<X>::_ForegroundProperty SwipeItem_statics<X>::ForegroundProperty;
template<typename X> typename SwipeItem_statics<X>::_IconSourceProperty SwipeItem_statics<X>::IconSourceProperty;
template<typename X> typename SwipeItem_statics<X>::_TextProperty SwipeItem_statics<X>::TextProperty;

template<typename X> struct statics<SwipeItem, X> : X, Windows::UI::Xaml::Controls::SwipeItem_statics<void> {
	using Windows::UI::Xaml::Controls::SwipeItem_statics<void>::activate;
	typedef typename X::root_type SwipeItem;
};
struct SwipeItem : generate<SwipeItem> {};

// SwipeItems
template<typename> struct SwipeItems_statics {
	static struct _ModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeItems, ISwipeItemsStatics>()->_get_ModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ModeProperty;
	static SwipeItems *activate(object_ref outer, IInspectable* *inner) { SwipeItems *instance; hrcheck(get_activation_factory<SwipeItems, ISwipeItemsFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename SwipeItems_statics<X>::_ModeProperty SwipeItems_statics<X>::ModeProperty;

template<typename X> struct statics<SwipeItems, X> : X, Windows::UI::Xaml::Controls::SwipeItems_statics<void> {
	using Windows::UI::Xaml::Controls::SwipeItems_statics<void>::activate;
	typedef typename X::root_type SwipeItems;
};
struct SwipeItems : generate<SwipeItems> {};

// TreeViewNode
template<typename> struct TreeViewNode_statics {
	static struct _ContentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeViewNode, ITreeViewNodeStatics>()->_get_ContentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentProperty;
	static struct _DepthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeViewNode, ITreeViewNodeStatics>()->_get_DepthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DepthProperty;
	static struct _HasChildrenProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeViewNode, ITreeViewNodeStatics>()->_get_HasChildrenProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HasChildrenProperty;
	static struct _IsExpandedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeViewNode, ITreeViewNodeStatics>()->_get_IsExpandedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsExpandedProperty;
	static TreeViewNode *activate(object_ref outer, IInspectable* *inner) { TreeViewNode *instance; hrcheck(get_activation_factory<TreeViewNode, ITreeViewNodeFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename TreeViewNode_statics<X>::_ContentProperty TreeViewNode_statics<X>::ContentProperty;
template<typename X> typename TreeViewNode_statics<X>::_DepthProperty TreeViewNode_statics<X>::DepthProperty;
template<typename X> typename TreeViewNode_statics<X>::_HasChildrenProperty TreeViewNode_statics<X>::HasChildrenProperty;
template<typename X> typename TreeViewNode_statics<X>::_IsExpandedProperty TreeViewNode_statics<X>::IsExpandedProperty;

template<typename X> struct statics<TreeViewNode, X> : X, Windows::UI::Xaml::Controls::TreeViewNode_statics<void> {
	using Windows::UI::Xaml::Controls::TreeViewNode_statics<void>::activate;
	typedef typename X::root_type TreeViewNode;
};
struct TreeViewNode : generate<TreeViewNode> {};

// TreeViewItemTemplateSettings
template<typename> struct TreeViewItemTemplateSettings_statics {
	static struct _CollapsedGlyphVisibilityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeViewItemTemplateSettings, ITreeViewItemTemplateSettingsStatics>()->_get_CollapsedGlyphVisibilityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CollapsedGlyphVisibilityProperty;
	static struct _DragItemsCountProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeViewItemTemplateSettings, ITreeViewItemTemplateSettingsStatics>()->_get_DragItemsCountProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DragItemsCountProperty;
	static struct _ExpandedGlyphVisibilityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeViewItemTemplateSettings, ITreeViewItemTemplateSettingsStatics>()->_get_ExpandedGlyphVisibilityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ExpandedGlyphVisibilityProperty;
	static struct _IndentationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeViewItemTemplateSettings, ITreeViewItemTemplateSettingsStatics>()->_get_IndentationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IndentationProperty;
	static TreeViewItemTemplateSettings *activate(object_ref outer, IInspectable* *inner) { TreeViewItemTemplateSettings *instance; hrcheck(get_activation_factory<TreeViewItemTemplateSettings, ITreeViewItemTemplateSettingsFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename TreeViewItemTemplateSettings_statics<X>::_CollapsedGlyphVisibilityProperty TreeViewItemTemplateSettings_statics<X>::CollapsedGlyphVisibilityProperty;
template<typename X> typename TreeViewItemTemplateSettings_statics<X>::_DragItemsCountProperty TreeViewItemTemplateSettings_statics<X>::DragItemsCountProperty;
template<typename X> typename TreeViewItemTemplateSettings_statics<X>::_ExpandedGlyphVisibilityProperty TreeViewItemTemplateSettings_statics<X>::ExpandedGlyphVisibilityProperty;
template<typename X> typename TreeViewItemTemplateSettings_statics<X>::_IndentationProperty TreeViewItemTemplateSettings_statics<X>::IndentationProperty;

template<typename X> struct statics<TreeViewItemTemplateSettings, X> : X, Windows::UI::Xaml::Controls::TreeViewItemTemplateSettings_statics<void> {
	using Windows::UI::Xaml::Controls::TreeViewItemTemplateSettings_statics<void>::activate;
	typedef typename X::root_type TreeViewItemTemplateSettings;
};
struct TreeViewItemTemplateSettings : generate<TreeViewItemTemplateSettings> {};

// SwipeItemInvokedEventArgs
template<typename X> struct statics<SwipeItemInvokedEventArgs, X> : X {
	typedef typename X::root_type SwipeItemInvokedEventArgs;
};
struct SwipeItemInvokedEventArgs : generate<SwipeItemInvokedEventArgs> {};

// IRefreshContainerFactory
struct IRefreshContainerFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, RefreshContainer* *instance);
};

// IRefreshContainerStatics
struct IRefreshContainerStatics : IInspectable {
	virtual STDMETHODIMP _get_VisualizerProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PullDirectionProperty(DependencyProperty* *value);
};

// IRefreshContainer
struct IRefreshContainer_raw : IInspectable {
	virtual STDMETHODIMP _get_Visualizer(RefreshVisualizer* *value);
	virtual STDMETHODIMP _put_Visualizer(RefreshVisualizer* value);
	virtual STDMETHODIMP _get_PullDirection(RefreshPullDirection *value);
	virtual STDMETHODIMP _put_PullDirection(RefreshPullDirection value);
	virtual STDMETHODIMP _add_RefreshRequested(Foundation::TypedEventHandler<RefreshContainer*, RefreshRequestedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_RefreshRequested(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _RequestRefresh();
};
template<typename X> struct IRefreshContainer_adaptor : X {
	union {
		struct : property {
			RefreshPullDirection get() { RefreshPullDirection value; hrcheck(enc(&IRefreshContainer_adaptor::PullDirection)->_get_PullDirection(&value)); return value; }
			RefreshPullDirection operator()() { return get(); }
			operator RefreshPullDirection () { return get(); }
			void put(RefreshPullDirection value) { hrcheck(enc(&IRefreshContainer_adaptor::PullDirection)->_put_PullDirection(value)); }
			void operator=(RefreshPullDirection value) { put(value); }
			void operator()(RefreshPullDirection value) { put(value); }
		} PullDirection;
		struct : property {
			ptr<RefreshVisualizer> get() { RefreshVisualizer* value; hrcheck(enc(&IRefreshContainer_adaptor::Visualizer)->_get_Visualizer(&value)); return from_abi(value); }
			ptr<RefreshVisualizer> operator()() { return get(); }
			operator ptr<RefreshVisualizer> () { return get(); }
			ptr<RefreshVisualizer> operator->() { return get(); }
			void put(pptr<RefreshVisualizer> value) { hrcheck(enc(&IRefreshContainer_adaptor::Visualizer)->_put_Visualizer(value)); }
			void operator=(pptr<RefreshVisualizer> value) { put(value); }
			void operator()(pptr<RefreshVisualizer> value) { put(value); }
		} Visualizer;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<RefreshContainer>, ptr<RefreshRequestedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRefreshContainer_adaptor::RefreshRequested)->_add_RefreshRequested(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRefreshContainer_adaptor::RefreshRequested)->_remove_RefreshRequested(token)); }
		} RefreshRequested;
	};
	void RequestRefresh() { hrcheck(X::get()->_RequestRefresh()); }
	IRefreshContainer_adaptor() {}
};
template<typename X> struct adapt<IRefreshContainer, X> : Windows::UI::Xaml::Controls::IRefreshContainer_adaptor<X> { typedef adapt IRefreshContainer; };
struct IRefreshContainer : IRefreshContainer_raw, generate<IRefreshContainer> {};

// IconSource
template<typename> struct IconSource_statics {
	static struct _ForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<IconSource, IIconSourceStatics>()->_get_ForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ForegroundProperty;
};
template<typename X> typename IconSource_statics<X>::_ForegroundProperty IconSource_statics<X>::ForegroundProperty;

template<typename X> struct statics<IconSource, X> : X, Windows::UI::Xaml::Controls::IconSource_statics<void> {
	typedef typename X::root_type IconSource;
};
struct IconSource : generate<IconSource> {};

// AutoSuggestBoxQuerySubmittedEventArgs
template<typename X> struct statics<AutoSuggestBoxQuerySubmittedEventArgs, X> : X {
	typedef typename X::root_type AutoSuggestBoxQuerySubmittedEventArgs;
};
struct AutoSuggestBoxQuerySubmittedEventArgs : generate<AutoSuggestBoxQuerySubmittedEventArgs> {};

// AutoSuggestBoxSuggestionChosenEventArgs
template<typename X> struct statics<AutoSuggestBoxSuggestionChosenEventArgs, X> : X {
	typedef typename X::root_type AutoSuggestBoxSuggestionChosenEventArgs;
};
struct AutoSuggestBoxSuggestionChosenEventArgs : generate<AutoSuggestBoxSuggestionChosenEventArgs> {};

// AutoSuggestBoxTextChangedEventArgs
template<typename> struct AutoSuggestBoxTextChangedEventArgs_statics {
	static struct _ReasonProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AutoSuggestBoxTextChangedEventArgs, IAutoSuggestBoxTextChangedEventArgsStatics>()->_get_ReasonProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ReasonProperty;
};
template<typename X> typename AutoSuggestBoxTextChangedEventArgs_statics<X>::_ReasonProperty AutoSuggestBoxTextChangedEventArgs_statics<X>::ReasonProperty;

template<typename X> struct statics<AutoSuggestBoxTextChangedEventArgs, X> : X, Windows::UI::Xaml::Controls::AutoSuggestBoxTextChangedEventArgs_statics<void> {
	typedef typename X::root_type AutoSuggestBoxTextChangedEventArgs;
};
struct AutoSuggestBoxTextChangedEventArgs : generate<AutoSuggestBoxTextChangedEventArgs> {};

// IBitmapIconSource
struct IBitmapIconSource_raw : IInspectable {
	virtual STDMETHODIMP _get_UriSource(Foundation::Uri* *value);
	virtual STDMETHODIMP _put_UriSource(Foundation::Uri* value);
	virtual STDMETHODIMP _get_ShowAsMonochrome(bool *value);
	virtual STDMETHODIMP _put_ShowAsMonochrome(bool value);
};
template<typename X> struct IBitmapIconSource_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBitmapIconSource_adaptor::ShowAsMonochrome)->_get_ShowAsMonochrome(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IBitmapIconSource_adaptor::ShowAsMonochrome)->_put_ShowAsMonochrome(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ShowAsMonochrome;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IBitmapIconSource_adaptor::UriSource)->_get_UriSource(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IBitmapIconSource_adaptor::UriSource)->_put_UriSource(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} UriSource;
	};
	IBitmapIconSource_adaptor() {}
};
template<typename X> struct adapt<IBitmapIconSource, X> : Windows::UI::Xaml::Controls::IBitmapIconSource_adaptor<X> { typedef adapt IBitmapIconSource; };
struct IBitmapIconSource : IBitmapIconSource_raw, generate<IBitmapIconSource> {};

// BitmapIconSource
template<typename> struct BitmapIconSource_statics {
	static struct _ShowAsMonochromeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BitmapIconSource, IBitmapIconSourceStatics>()->_get_ShowAsMonochromeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ShowAsMonochromeProperty;
	static struct _UriSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BitmapIconSource, IBitmapIconSourceStatics>()->_get_UriSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} UriSourceProperty;
	static BitmapIconSource *activate(object_ref outer, IInspectable* *inner) { BitmapIconSource *instance; hrcheck(get_activation_factory<BitmapIconSource, IBitmapIconSourceFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename BitmapIconSource_statics<X>::_ShowAsMonochromeProperty BitmapIconSource_statics<X>::ShowAsMonochromeProperty;
template<typename X> typename BitmapIconSource_statics<X>::_UriSourceProperty BitmapIconSource_statics<X>::UriSourceProperty;

template<typename X> struct statics<BitmapIconSource, X> : X, Windows::UI::Xaml::Controls::BitmapIconSource_statics<void> {
	using Windows::UI::Xaml::Controls::BitmapIconSource_statics<void>::activate;
	typedef typename X::root_type BitmapIconSource;
};
struct BitmapIconSource : generate<BitmapIconSource> {};

// FontIconSource
template<typename> struct FontIconSource_statics {
	static struct _FontFamilyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FontIconSource, IFontIconSourceStatics>()->_get_FontFamilyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontFamilyProperty;
	static struct _FontSizeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FontIconSource, IFontIconSourceStatics>()->_get_FontSizeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontSizeProperty;
	static struct _FontStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FontIconSource, IFontIconSourceStatics>()->_get_FontStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontStyleProperty;
	static struct _FontWeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FontIconSource, IFontIconSourceStatics>()->_get_FontWeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontWeightProperty;
	static struct _GlyphProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FontIconSource, IFontIconSourceStatics>()->_get_GlyphProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GlyphProperty;
	static struct _IsTextScaleFactorEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FontIconSource, IFontIconSourceStatics>()->_get_IsTextScaleFactorEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTextScaleFactorEnabledProperty;
	static struct _MirroredWhenRightToLeftProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FontIconSource, IFontIconSourceStatics>()->_get_MirroredWhenRightToLeftProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MirroredWhenRightToLeftProperty;
	static FontIconSource *activate(object_ref outer, IInspectable* *inner) { FontIconSource *instance; hrcheck(get_activation_factory<FontIconSource, IFontIconSourceFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename FontIconSource_statics<X>::_FontFamilyProperty FontIconSource_statics<X>::FontFamilyProperty;
template<typename X> typename FontIconSource_statics<X>::_FontSizeProperty FontIconSource_statics<X>::FontSizeProperty;
template<typename X> typename FontIconSource_statics<X>::_FontStyleProperty FontIconSource_statics<X>::FontStyleProperty;
template<typename X> typename FontIconSource_statics<X>::_FontWeightProperty FontIconSource_statics<X>::FontWeightProperty;
template<typename X> typename FontIconSource_statics<X>::_GlyphProperty FontIconSource_statics<X>::GlyphProperty;
template<typename X> typename FontIconSource_statics<X>::_IsTextScaleFactorEnabledProperty FontIconSource_statics<X>::IsTextScaleFactorEnabledProperty;
template<typename X> typename FontIconSource_statics<X>::_MirroredWhenRightToLeftProperty FontIconSource_statics<X>::MirroredWhenRightToLeftProperty;

template<typename X> struct statics<FontIconSource, X> : X, Windows::UI::Xaml::Controls::FontIconSource_statics<void> {
	using Windows::UI::Xaml::Controls::FontIconSource_statics<void>::activate;
	typedef typename X::root_type FontIconSource;
};
struct FontIconSource : generate<FontIconSource> {};

// PathIconSource
template<typename> struct PathIconSource_statics {
	static struct _DataProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PathIconSource, IPathIconSourceStatics>()->_get_DataProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DataProperty;
	static PathIconSource *activate(object_ref outer, IInspectable* *inner) { PathIconSource *instance; hrcheck(get_activation_factory<PathIconSource, IPathIconSourceFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename PathIconSource_statics<X>::_DataProperty PathIconSource_statics<X>::DataProperty;

template<typename X> struct statics<PathIconSource, X> : X, Windows::UI::Xaml::Controls::PathIconSource_statics<void> {
	using Windows::UI::Xaml::Controls::PathIconSource_statics<void>::activate;
	typedef typename X::root_type PathIconSource;
};
struct PathIconSource : generate<PathIconSource> {};

// SymbolIconSource
template<typename> struct SymbolIconSource_statics {
	static struct _SymbolProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SymbolIconSource, ISymbolIconSourceStatics>()->_get_SymbolProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SymbolProperty;
	static SymbolIconSource *activate(object_ref outer, IInspectable* *inner) { SymbolIconSource *instance; hrcheck(get_activation_factory<SymbolIconSource, ISymbolIconSourceFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename SymbolIconSource_statics<X>::_SymbolProperty SymbolIconSource_statics<X>::SymbolProperty;

template<typename X> struct statics<SymbolIconSource, X> : X, Windows::UI::Xaml::Controls::SymbolIconSource_statics<void> {
	using Windows::UI::Xaml::Controls::SymbolIconSource_statics<void>::activate;
	typedef typename X::root_type SymbolIconSource;
};
struct SymbolIconSource : generate<SymbolIconSource> {};

// IRefreshRequestedEventArgs
struct IRefreshRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _GetDeferral(Foundation::Deferral* *value);
};
template<typename X> struct IRefreshRequestedEventArgs_adaptor : X {
	ptr<Foundation::Deferral> GetDeferral() { Foundation::Deferral* value; hrcheck(X::get()->_GetDeferral(&value)); return from_abi(value); }
};
template<typename X> struct adapt<IRefreshRequestedEventArgs, X> : Windows::UI::Xaml::Controls::IRefreshRequestedEventArgs_adaptor<X> { typedef adapt IRefreshRequestedEventArgs; };
struct IRefreshRequestedEventArgs : IRefreshRequestedEventArgs_raw, generate<IRefreshRequestedEventArgs> {};

// IRefreshStateChangedEventArgs
struct IRefreshStateChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_OldState(RefreshVisualizerState *value);
	virtual STDMETHODIMP _get_NewState(RefreshVisualizerState *value);
};
template<typename X> struct IRefreshStateChangedEventArgs_adaptor : X {
	union {
		struct : property {
			RefreshVisualizerState get() { RefreshVisualizerState value; hrcheck(enc(&IRefreshStateChangedEventArgs_adaptor::NewState)->_get_NewState(&value)); return value; }
			RefreshVisualizerState operator()() { return get(); }
			operator RefreshVisualizerState () { return get(); }
		} NewState;
		struct : property {
			RefreshVisualizerState get() { RefreshVisualizerState value; hrcheck(enc(&IRefreshStateChangedEventArgs_adaptor::OldState)->_get_OldState(&value)); return value; }
			RefreshVisualizerState operator()() { return get(); }
			operator RefreshVisualizerState () { return get(); }
		} OldState;
	};
	IRefreshStateChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IRefreshStateChangedEventArgs, X> : Windows::UI::Xaml::Controls::IRefreshStateChangedEventArgs_adaptor<X> { typedef adapt IRefreshStateChangedEventArgs; };
struct IRefreshStateChangedEventArgs : IRefreshStateChangedEventArgs_raw, generate<IRefreshStateChangedEventArgs> {};

// IRefreshVisualizerFactory
struct IRefreshVisualizerFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, RefreshVisualizer* *instance);
};

// IRefreshVisualizerStatics
struct IRefreshVisualizerStatics : IInspectable {
	virtual STDMETHODIMP _get_InfoProviderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OrientationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_StateProperty(DependencyProperty* *value);
};

// RefreshStateChangedEventArgs
template<typename X> struct statics<RefreshStateChangedEventArgs, X> : X {
	typedef typename X::root_type RefreshStateChangedEventArgs;
};
struct RefreshStateChangedEventArgs : generate<RefreshStateChangedEventArgs> {};

// RefreshRequestedEventArgs
template<typename X> struct statics<RefreshRequestedEventArgs, X> : X {
	typedef typename X::root_type RefreshRequestedEventArgs;
};
struct RefreshRequestedEventArgs : generate<RefreshRequestedEventArgs> {};

// CleanUpVirtualizedItemEventArgs
template<typename X> struct statics<CleanUpVirtualizedItemEventArgs, X> : X {
	typedef typename X::root_type CleanUpVirtualizedItemEventArgs;
};
struct CleanUpVirtualizedItemEventArgs : generate<CleanUpVirtualizedItemEventArgs> {};

// ContextMenuEventArgs
template<typename X> struct statics<ContextMenuEventArgs, X> : X {
	typedef typename X::root_type ContextMenuEventArgs;
};
struct ContextMenuEventArgs : generate<ContextMenuEventArgs> {};

// ItemClickEventArgs
template<typename X> struct statics<ItemClickEventArgs, X> : X {
	typedef typename X::root_type ItemClickEventArgs;
};
struct ItemClickEventArgs : generate<ItemClickEventArgs> {};

// SelectionChangedEventArgs
template<typename> struct SelectionChangedEventArgs_statics {
	static SelectionChangedEventArgs *activate(pptr<Foundation::Collections::IVector<object>> removedItems, pptr<Foundation::Collections::IVector<object>> addedItems, object_ref outer, IInspectable* *inner) { SelectionChangedEventArgs *instance; hrcheck(get_activation_factory<SelectionChangedEventArgs, ISelectionChangedEventArgsFactory>()->_CreateInstanceWithRemovedItemsAndAddedItems(removedItems, addedItems, outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<SelectionChangedEventArgs, X> : X, Windows::UI::Xaml::Controls::SelectionChangedEventArgs_statics<void> {
	using Windows::UI::Xaml::Controls::SelectionChangedEventArgs_statics<void>::activate;
	typedef typename X::root_type SelectionChangedEventArgs;
};
struct SelectionChangedEventArgs : generate<SelectionChangedEventArgs> {};

// TextChangedEventArgs
template<typename X> struct statics<TextChangedEventArgs, X> : X {
	typedef typename X::root_type TextChangedEventArgs;
};
struct TextChangedEventArgs : generate<TextChangedEventArgs> {};

// IRefreshVisualizer
struct IRefreshVisualizer_raw : IInspectable {
	virtual STDMETHODIMP _RequestRefresh();
	virtual STDMETHODIMP _get_Orientation(RefreshVisualizerOrientation *value);
	virtual STDMETHODIMP _put_Orientation(RefreshVisualizerOrientation value);
	virtual STDMETHODIMP _get_Content(UIElement* *value);
	virtual STDMETHODIMP _put_Content(UIElement* value);
	virtual STDMETHODIMP _get_State(RefreshVisualizerState *value);
	virtual STDMETHODIMP _add_RefreshRequested(Foundation::TypedEventHandler<RefreshVisualizer*, RefreshRequestedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_RefreshRequested(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_RefreshStateChanged(Foundation::TypedEventHandler<RefreshVisualizer*, RefreshStateChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_RefreshStateChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IRefreshVisualizer_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IRefreshVisualizer_adaptor::Content)->_get_Content(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IRefreshVisualizer_adaptor::Content)->_put_Content(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} Content;
		struct : property {
			RefreshVisualizerOrientation get() { RefreshVisualizerOrientation value; hrcheck(enc(&IRefreshVisualizer_adaptor::Orientation)->_get_Orientation(&value)); return value; }
			RefreshVisualizerOrientation operator()() { return get(); }
			operator RefreshVisualizerOrientation () { return get(); }
			void put(RefreshVisualizerOrientation value) { hrcheck(enc(&IRefreshVisualizer_adaptor::Orientation)->_put_Orientation(value)); }
			void operator=(RefreshVisualizerOrientation value) { put(value); }
			void operator()(RefreshVisualizerOrientation value) { put(value); }
		} Orientation;
		struct : property {
			RefreshVisualizerState get() { RefreshVisualizerState value; hrcheck(enc(&IRefreshVisualizer_adaptor::State)->_get_State(&value)); return value; }
			RefreshVisualizerState operator()() { return get(); }
			operator RefreshVisualizerState () { return get(); }
		} State;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<RefreshVisualizer>, ptr<RefreshRequestedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRefreshVisualizer_adaptor::RefreshRequested)->_add_RefreshRequested(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRefreshVisualizer_adaptor::RefreshRequested)->_remove_RefreshRequested(token)); }
		} RefreshRequested;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<RefreshVisualizer>, ptr<RefreshStateChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRefreshVisualizer_adaptor::RefreshStateChanged)->_add_RefreshStateChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRefreshVisualizer_adaptor::RefreshStateChanged)->_remove_RefreshStateChanged(token)); }
		} RefreshStateChanged;
	};
	void RequestRefresh() { hrcheck(X::get()->_RequestRefresh()); }
	IRefreshVisualizer_adaptor() {}
};
template<typename X> struct adapt<IRefreshVisualizer, X> : Windows::UI::Xaml::Controls::IRefreshVisualizer_adaptor<X> { typedef adapt IRefreshVisualizer; };
struct IRefreshVisualizer : IRefreshVisualizer_raw, generate<IRefreshVisualizer> {};

// IRefreshInteractionRatioChangedEventArgs
struct IRefreshInteractionRatioChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_InteractionRatio(double *value);
};
template<typename X> struct IRefreshInteractionRatioChangedEventArgs_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IRefreshInteractionRatioChangedEventArgs_adaptor::InteractionRatio)->_get_InteractionRatio(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} InteractionRatio;
	};
	IRefreshInteractionRatioChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IRefreshInteractionRatioChangedEventArgs, X> : Windows::UI::Xaml::Controls::IRefreshInteractionRatioChangedEventArgs_adaptor<X> { typedef adapt IRefreshInteractionRatioChangedEventArgs; };
struct IRefreshInteractionRatioChangedEventArgs : IRefreshInteractionRatioChangedEventArgs_raw, generate<IRefreshInteractionRatioChangedEventArgs> {};

// RefreshInteractionRatioChangedEventArgs
template<typename X> struct statics<RefreshInteractionRatioChangedEventArgs, X> : X {
	typedef typename X::root_type RefreshInteractionRatioChangedEventArgs;
};
struct RefreshInteractionRatioChangedEventArgs : generate<RefreshInteractionRatioChangedEventArgs> {};

// ItemsPanelTemplate
template<typename X> struct statics<ItemsPanelTemplate, X> : X {
	typedef typename X::root_type ItemsPanelTemplate;
};
struct ItemsPanelTemplate : generate<ItemsPanelTemplate> {};

// IParallaxViewFactory
struct IParallaxViewFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ParallaxView* *instance);
};

// IParallaxViewStatics
struct IParallaxViewStatics : IInspectable {
	virtual STDMETHODIMP _get_ChildProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalSourceEndOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalSourceOffsetKindProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalSourceStartOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxHorizontalShiftRatioProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HorizontalShiftProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsHorizontalShiftClampedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsVerticalShiftClampedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalSourceEndOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalSourceOffsetKindProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalSourceStartOffsetProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxVerticalShiftRatioProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_VerticalShiftProperty(DependencyProperty* *value);
};

// IParallaxView
struct IParallaxView_raw : IInspectable {
	virtual STDMETHODIMP _get_Child(UIElement* *value);
	virtual STDMETHODIMP _put_Child(UIElement* value);
	virtual STDMETHODIMP _get_HorizontalShift(double *value);
	virtual STDMETHODIMP _put_HorizontalShift(double value);
	virtual STDMETHODIMP _get_HorizontalSourceEndOffset(double *value);
	virtual STDMETHODIMP _put_HorizontalSourceEndOffset(double value);
	virtual STDMETHODIMP _get_HorizontalSourceOffsetKind(ParallaxSourceOffsetKind *value);
	virtual STDMETHODIMP _put_HorizontalSourceOffsetKind(ParallaxSourceOffsetKind value);
	virtual STDMETHODIMP _get_HorizontalSourceStartOffset(double *value);
	virtual STDMETHODIMP _put_HorizontalSourceStartOffset(double value);
	virtual STDMETHODIMP _get_IsHorizontalShiftClamped(bool *value);
	virtual STDMETHODIMP _put_IsHorizontalShiftClamped(bool value);
	virtual STDMETHODIMP _get_IsVerticalShiftClamped(bool *value);
	virtual STDMETHODIMP _put_IsVerticalShiftClamped(bool value);
	virtual STDMETHODIMP _get_MaxHorizontalShiftRatio(double *value);
	virtual STDMETHODIMP _put_MaxHorizontalShiftRatio(double value);
	virtual STDMETHODIMP _get_MaxVerticalShiftRatio(double *value);
	virtual STDMETHODIMP _put_MaxVerticalShiftRatio(double value);
	virtual STDMETHODIMP _get_Source(UIElement* *value);
	virtual STDMETHODIMP _put_Source(UIElement* value);
	virtual STDMETHODIMP _get_VerticalShift(double *value);
	virtual STDMETHODIMP _put_VerticalShift(double value);
	virtual STDMETHODIMP _get_VerticalSourceEndOffset(double *value);
	virtual STDMETHODIMP _put_VerticalSourceEndOffset(double value);
	virtual STDMETHODIMP _get_VerticalSourceOffsetKind(ParallaxSourceOffsetKind *value);
	virtual STDMETHODIMP _put_VerticalSourceOffsetKind(ParallaxSourceOffsetKind value);
	virtual STDMETHODIMP _get_VerticalSourceStartOffset(double *value);
	virtual STDMETHODIMP _put_VerticalSourceStartOffset(double value);
	virtual STDMETHODIMP _RefreshAutomaticHorizontalOffsets();
	virtual STDMETHODIMP _RefreshAutomaticVerticalOffsets();
};
template<typename X> struct IParallaxView_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IParallaxView_adaptor::Child)->_get_Child(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IParallaxView_adaptor::Child)->_put_Child(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} Child;
		struct : property {
			double get() { double value; hrcheck(enc(&IParallaxView_adaptor::HorizontalShift)->_get_HorizontalShift(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IParallaxView_adaptor::HorizontalShift)->_put_HorizontalShift(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} HorizontalShift;
		struct : property {
			double get() { double value; hrcheck(enc(&IParallaxView_adaptor::HorizontalSourceEndOffset)->_get_HorizontalSourceEndOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IParallaxView_adaptor::HorizontalSourceEndOffset)->_put_HorizontalSourceEndOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} HorizontalSourceEndOffset;
		struct : property {
			ParallaxSourceOffsetKind get() { ParallaxSourceOffsetKind value; hrcheck(enc(&IParallaxView_adaptor::HorizontalSourceOffsetKind)->_get_HorizontalSourceOffsetKind(&value)); return value; }
			ParallaxSourceOffsetKind operator()() { return get(); }
			operator ParallaxSourceOffsetKind () { return get(); }
			void put(ParallaxSourceOffsetKind value) { hrcheck(enc(&IParallaxView_adaptor::HorizontalSourceOffsetKind)->_put_HorizontalSourceOffsetKind(value)); }
			void operator=(ParallaxSourceOffsetKind value) { put(value); }
			void operator()(ParallaxSourceOffsetKind value) { put(value); }
		} HorizontalSourceOffsetKind;
		struct : property {
			double get() { double value; hrcheck(enc(&IParallaxView_adaptor::HorizontalSourceStartOffset)->_get_HorizontalSourceStartOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IParallaxView_adaptor::HorizontalSourceStartOffset)->_put_HorizontalSourceStartOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} HorizontalSourceStartOffset;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IParallaxView_adaptor::IsHorizontalShiftClamped)->_get_IsHorizontalShiftClamped(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IParallaxView_adaptor::IsHorizontalShiftClamped)->_put_IsHorizontalShiftClamped(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsHorizontalShiftClamped;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IParallaxView_adaptor::IsVerticalShiftClamped)->_get_IsVerticalShiftClamped(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IParallaxView_adaptor::IsVerticalShiftClamped)->_put_IsVerticalShiftClamped(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsVerticalShiftClamped;
		struct : property {
			double get() { double value; hrcheck(enc(&IParallaxView_adaptor::MaxHorizontalShiftRatio)->_get_MaxHorizontalShiftRatio(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IParallaxView_adaptor::MaxHorizontalShiftRatio)->_put_MaxHorizontalShiftRatio(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MaxHorizontalShiftRatio;
		struct : property {
			double get() { double value; hrcheck(enc(&IParallaxView_adaptor::MaxVerticalShiftRatio)->_get_MaxVerticalShiftRatio(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IParallaxView_adaptor::MaxVerticalShiftRatio)->_put_MaxVerticalShiftRatio(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MaxVerticalShiftRatio;
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IParallaxView_adaptor::Source)->_get_Source(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IParallaxView_adaptor::Source)->_put_Source(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} Source;
		struct : property {
			double get() { double value; hrcheck(enc(&IParallaxView_adaptor::VerticalShift)->_get_VerticalShift(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IParallaxView_adaptor::VerticalShift)->_put_VerticalShift(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} VerticalShift;
		struct : property {
			double get() { double value; hrcheck(enc(&IParallaxView_adaptor::VerticalSourceEndOffset)->_get_VerticalSourceEndOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IParallaxView_adaptor::VerticalSourceEndOffset)->_put_VerticalSourceEndOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} VerticalSourceEndOffset;
		struct : property {
			ParallaxSourceOffsetKind get() { ParallaxSourceOffsetKind value; hrcheck(enc(&IParallaxView_adaptor::VerticalSourceOffsetKind)->_get_VerticalSourceOffsetKind(&value)); return value; }
			ParallaxSourceOffsetKind operator()() { return get(); }
			operator ParallaxSourceOffsetKind () { return get(); }
			void put(ParallaxSourceOffsetKind value) { hrcheck(enc(&IParallaxView_adaptor::VerticalSourceOffsetKind)->_put_VerticalSourceOffsetKind(value)); }
			void operator=(ParallaxSourceOffsetKind value) { put(value); }
			void operator()(ParallaxSourceOffsetKind value) { put(value); }
		} VerticalSourceOffsetKind;
		struct : property {
			double get() { double value; hrcheck(enc(&IParallaxView_adaptor::VerticalSourceStartOffset)->_get_VerticalSourceStartOffset(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IParallaxView_adaptor::VerticalSourceStartOffset)->_put_VerticalSourceStartOffset(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} VerticalSourceStartOffset;
	};
	void RefreshAutomaticHorizontalOffsets() { hrcheck(X::get()->_RefreshAutomaticHorizontalOffsets()); }
	void RefreshAutomaticVerticalOffsets() { hrcheck(X::get()->_RefreshAutomaticVerticalOffsets()); }
	IParallaxView_adaptor() {}
};
template<typename X> struct adapt<IParallaxView, X> : Windows::UI::Xaml::Controls::IParallaxView_adaptor<X> { typedef adapt IParallaxView; };
struct IParallaxView : IParallaxView_raw, generate<IParallaxView> {};

// ParallaxView
template<typename> struct ParallaxView_statics {
	static struct _ChildProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ParallaxView, IParallaxViewStatics>()->_get_ChildProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ChildProperty;
	static struct _HorizontalShiftProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ParallaxView, IParallaxViewStatics>()->_get_HorizontalShiftProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalShiftProperty;
	static struct _HorizontalSourceEndOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ParallaxView, IParallaxViewStatics>()->_get_HorizontalSourceEndOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalSourceEndOffsetProperty;
	static struct _HorizontalSourceOffsetKindProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ParallaxView, IParallaxViewStatics>()->_get_HorizontalSourceOffsetKindProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalSourceOffsetKindProperty;
	static struct _HorizontalSourceStartOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ParallaxView, IParallaxViewStatics>()->_get_HorizontalSourceStartOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalSourceStartOffsetProperty;
	static struct _IsHorizontalShiftClampedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ParallaxView, IParallaxViewStatics>()->_get_IsHorizontalShiftClampedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsHorizontalShiftClampedProperty;
	static struct _IsVerticalShiftClampedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ParallaxView, IParallaxViewStatics>()->_get_IsVerticalShiftClampedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsVerticalShiftClampedProperty;
	static struct _MaxHorizontalShiftRatioProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ParallaxView, IParallaxViewStatics>()->_get_MaxHorizontalShiftRatioProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxHorizontalShiftRatioProperty;
	static struct _MaxVerticalShiftRatioProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ParallaxView, IParallaxViewStatics>()->_get_MaxVerticalShiftRatioProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxVerticalShiftRatioProperty;
	static struct _SourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ParallaxView, IParallaxViewStatics>()->_get_SourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SourceProperty;
	static struct _VerticalShiftProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ParallaxView, IParallaxViewStatics>()->_get_VerticalShiftProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalShiftProperty;
	static struct _VerticalSourceEndOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ParallaxView, IParallaxViewStatics>()->_get_VerticalSourceEndOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalSourceEndOffsetProperty;
	static struct _VerticalSourceOffsetKindProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ParallaxView, IParallaxViewStatics>()->_get_VerticalSourceOffsetKindProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalSourceOffsetKindProperty;
	static struct _VerticalSourceStartOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ParallaxView, IParallaxViewStatics>()->_get_VerticalSourceStartOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalSourceStartOffsetProperty;
	static ParallaxView *activate(object_ref outer, IInspectable* *inner) { ParallaxView *instance; hrcheck(get_activation_factory<ParallaxView, IParallaxViewFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename ParallaxView_statics<X>::_ChildProperty ParallaxView_statics<X>::ChildProperty;
template<typename X> typename ParallaxView_statics<X>::_HorizontalShiftProperty ParallaxView_statics<X>::HorizontalShiftProperty;
template<typename X> typename ParallaxView_statics<X>::_HorizontalSourceEndOffsetProperty ParallaxView_statics<X>::HorizontalSourceEndOffsetProperty;
template<typename X> typename ParallaxView_statics<X>::_HorizontalSourceOffsetKindProperty ParallaxView_statics<X>::HorizontalSourceOffsetKindProperty;
template<typename X> typename ParallaxView_statics<X>::_HorizontalSourceStartOffsetProperty ParallaxView_statics<X>::HorizontalSourceStartOffsetProperty;
template<typename X> typename ParallaxView_statics<X>::_IsHorizontalShiftClampedProperty ParallaxView_statics<X>::IsHorizontalShiftClampedProperty;
template<typename X> typename ParallaxView_statics<X>::_IsVerticalShiftClampedProperty ParallaxView_statics<X>::IsVerticalShiftClampedProperty;
template<typename X> typename ParallaxView_statics<X>::_MaxHorizontalShiftRatioProperty ParallaxView_statics<X>::MaxHorizontalShiftRatioProperty;
template<typename X> typename ParallaxView_statics<X>::_MaxVerticalShiftRatioProperty ParallaxView_statics<X>::MaxVerticalShiftRatioProperty;
template<typename X> typename ParallaxView_statics<X>::_SourceProperty ParallaxView_statics<X>::SourceProperty;
template<typename X> typename ParallaxView_statics<X>::_VerticalShiftProperty ParallaxView_statics<X>::VerticalShiftProperty;
template<typename X> typename ParallaxView_statics<X>::_VerticalSourceEndOffsetProperty ParallaxView_statics<X>::VerticalSourceEndOffsetProperty;
template<typename X> typename ParallaxView_statics<X>::_VerticalSourceOffsetKindProperty ParallaxView_statics<X>::VerticalSourceOffsetKindProperty;
template<typename X> typename ParallaxView_statics<X>::_VerticalSourceStartOffsetProperty ParallaxView_statics<X>::VerticalSourceStartOffsetProperty;

template<typename X> struct statics<ParallaxView, X> : X, Windows::UI::Xaml::Controls::ParallaxView_statics<void> {
	using Windows::UI::Xaml::Controls::ParallaxView_statics<void>::activate;
	typedef typename X::root_type ParallaxView;
};
struct ParallaxView : generate<ParallaxView> {};

// IRatingControlStatics
struct IRatingControlStatics : IInspectable {
	virtual STDMETHODIMP _get_CaptionProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_InitialSetValueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsClearEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsReadOnlyProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxRatingProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PlaceholderValueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemInfoProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ValueProperty(DependencyProperty* *value);
};

// Border
template<typename> struct Border_statics {
	static struct _BackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Border, IBorderStatics>()->_get_BackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BackgroundProperty;
	static struct _BorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Border, IBorderStatics>()->_get_BorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BorderBrushProperty;
	static struct _BorderThicknessProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Border, IBorderStatics>()->_get_BorderThicknessProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BorderThicknessProperty;
	static struct _ChildTransitionsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Border, IBorderStatics>()->_get_ChildTransitionsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ChildTransitionsProperty;
	static struct _CornerRadiusProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Border, IBorderStatics>()->_get_CornerRadiusProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CornerRadiusProperty;
	static struct _PaddingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Border, IBorderStatics>()->_get_PaddingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaddingProperty;
};
template<typename X> typename Border_statics<X>::_BackgroundProperty Border_statics<X>::BackgroundProperty;
template<typename X> typename Border_statics<X>::_BorderBrushProperty Border_statics<X>::BorderBrushProperty;
template<typename X> typename Border_statics<X>::_BorderThicknessProperty Border_statics<X>::BorderThicknessProperty;
template<typename X> typename Border_statics<X>::_ChildTransitionsProperty Border_statics<X>::ChildTransitionsProperty;
template<typename X> typename Border_statics<X>::_CornerRadiusProperty Border_statics<X>::CornerRadiusProperty;
template<typename X> typename Border_statics<X>::_PaddingProperty Border_statics<X>::PaddingProperty;

template<typename X> struct statics<Border, X> : X, Windows::UI::Xaml::Controls::Border_statics<void> {
	typedef typename X::root_type Border;
};
struct Border : generate<Border> {};

// CaptureElement
template<typename> struct CaptureElement_statics {
	static struct _SourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CaptureElement, ICaptureElementStatics>()->_get_SourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SourceProperty;
	static struct _StretchProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CaptureElement, ICaptureElementStatics>()->_get_StretchProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StretchProperty;
};
template<typename X> typename CaptureElement_statics<X>::_SourceProperty CaptureElement_statics<X>::SourceProperty;
template<typename X> typename CaptureElement_statics<X>::_StretchProperty CaptureElement_statics<X>::StretchProperty;

template<typename X> struct statics<CaptureElement, X> : X, Windows::UI::Xaml::Controls::CaptureElement_statics<void> {
	typedef typename X::root_type CaptureElement;
};
struct CaptureElement : generate<CaptureElement> {};

// Image
template<typename> struct Image_statics {
	static struct _NineGridProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Image, IImageStatics>()->_get_NineGridProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} NineGridProperty;
	static struct _PlayToSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Image, IImageStatics>()->_get_PlayToSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlayToSourceProperty;
	static struct _SourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Image, IImageStatics>()->_get_SourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SourceProperty;
	static struct _StretchProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Image, IImageStatics>()->_get_StretchProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StretchProperty;
};
template<typename X> typename Image_statics<X>::_NineGridProperty Image_statics<X>::NineGridProperty;
template<typename X> typename Image_statics<X>::_PlayToSourceProperty Image_statics<X>::PlayToSourceProperty;
template<typename X> typename Image_statics<X>::_SourceProperty Image_statics<X>::SourceProperty;
template<typename X> typename Image_statics<X>::_StretchProperty Image_statics<X>::StretchProperty;

template<typename X> struct statics<Image, X> : X, Windows::UI::Xaml::Controls::Image_statics<void> {
	typedef typename X::root_type Image;
};
struct Image : generate<Image> {};

// ItemsPresenter
template<typename> struct ItemsPresenter_statics {
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsPresenter, IItemsPresenterStatics>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static struct _HeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsPresenter, IItemsPresenterStatics>()->_get_HeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTemplateProperty;
	static struct _HeaderTransitionsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsPresenter, IItemsPresenterStatics>()->_get_HeaderTransitionsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTransitionsProperty;
	static struct _PaddingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsPresenter, IItemsPresenterStatics>()->_get_PaddingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaddingProperty;
	static struct _FooterProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsPresenter, IItemsPresenterStatics2>()->_get_FooterProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FooterProperty;
	static struct _FooterTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsPresenter, IItemsPresenterStatics2>()->_get_FooterTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FooterTemplateProperty;
	static struct _FooterTransitionsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsPresenter, IItemsPresenterStatics2>()->_get_FooterTransitionsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FooterTransitionsProperty;
};
template<typename X> typename ItemsPresenter_statics<X>::_HeaderProperty ItemsPresenter_statics<X>::HeaderProperty;
template<typename X> typename ItemsPresenter_statics<X>::_HeaderTemplateProperty ItemsPresenter_statics<X>::HeaderTemplateProperty;
template<typename X> typename ItemsPresenter_statics<X>::_HeaderTransitionsProperty ItemsPresenter_statics<X>::HeaderTransitionsProperty;
template<typename X> typename ItemsPresenter_statics<X>::_PaddingProperty ItemsPresenter_statics<X>::PaddingProperty;
template<typename X> typename ItemsPresenter_statics<X>::_FooterProperty ItemsPresenter_statics<X>::FooterProperty;
template<typename X> typename ItemsPresenter_statics<X>::_FooterTemplateProperty ItemsPresenter_statics<X>::FooterTemplateProperty;
template<typename X> typename ItemsPresenter_statics<X>::_FooterTransitionsProperty ItemsPresenter_statics<X>::FooterTransitionsProperty;

template<typename X> struct statics<ItemsPresenter, X> : X, Windows::UI::Xaml::Controls::ItemsPresenter_statics<void> {
	typedef typename X::root_type ItemsPresenter;
};
struct ItemsPresenter : generate<ItemsPresenter> {};

// RichTextBlockOverflow
template<typename> struct RichTextBlockOverflow_statics {
	static struct _HasOverflowContentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlockOverflow, IRichTextBlockOverflowStatics>()->_get_HasOverflowContentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HasOverflowContentProperty;
	static struct _OverflowContentTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlockOverflow, IRichTextBlockOverflowStatics>()->_get_OverflowContentTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OverflowContentTargetProperty;
	static struct _PaddingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlockOverflow, IRichTextBlockOverflowStatics>()->_get_PaddingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaddingProperty;
	static struct _MaxLinesProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlockOverflow, IRichTextBlockOverflowStatics2>()->_get_MaxLinesProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxLinesProperty;
	static struct _IsTextTrimmedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlockOverflow, IRichTextBlockOverflowStatics3>()->_get_IsTextTrimmedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTextTrimmedProperty;
};
template<typename X> typename RichTextBlockOverflow_statics<X>::_HasOverflowContentProperty RichTextBlockOverflow_statics<X>::HasOverflowContentProperty;
template<typename X> typename RichTextBlockOverflow_statics<X>::_OverflowContentTargetProperty RichTextBlockOverflow_statics<X>::OverflowContentTargetProperty;
template<typename X> typename RichTextBlockOverflow_statics<X>::_PaddingProperty RichTextBlockOverflow_statics<X>::PaddingProperty;
template<typename X> typename RichTextBlockOverflow_statics<X>::_MaxLinesProperty RichTextBlockOverflow_statics<X>::MaxLinesProperty;
template<typename X> typename RichTextBlockOverflow_statics<X>::_IsTextTrimmedProperty RichTextBlockOverflow_statics<X>::IsTextTrimmedProperty;

template<typename X> struct statics<RichTextBlockOverflow, X> : X, Windows::UI::Xaml::Controls::RichTextBlockOverflow_statics<void> {
	typedef typename X::root_type RichTextBlockOverflow;
};
struct RichTextBlockOverflow : generate<RichTextBlockOverflow> {};

// RichTextBlock
template<typename> struct RichTextBlock_statics {
	static struct _CharacterSpacingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_CharacterSpacingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CharacterSpacingProperty;
	static struct _FontFamilyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_FontFamilyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontFamilyProperty;
	static struct _FontSizeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_FontSizeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontSizeProperty;
	static struct _FontStretchProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_FontStretchProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontStretchProperty;
	static struct _FontStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_FontStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontStyleProperty;
	static struct _FontWeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_FontWeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontWeightProperty;
	static struct _ForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_ForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ForegroundProperty;
	static struct _HasOverflowContentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_HasOverflowContentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HasOverflowContentProperty;
	static struct _IsTextSelectionEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_IsTextSelectionEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTextSelectionEnabledProperty;
	static struct _LineHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_LineHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LineHeightProperty;
	static struct _LineStackingStrategyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_LineStackingStrategyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LineStackingStrategyProperty;
	static struct _OverflowContentTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_OverflowContentTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OverflowContentTargetProperty;
	static struct _PaddingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_PaddingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaddingProperty;
	static struct _SelectedTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_SelectedTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedTextProperty;
	static struct _TextAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_TextAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextAlignmentProperty;
	static struct _TextIndentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_TextIndentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextIndentProperty;
	static struct _TextTrimmingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_TextTrimmingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextTrimmingProperty;
	static struct _TextWrappingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics>()->_get_TextWrappingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextWrappingProperty;
	static struct _IsColorFontEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics2>()->_get_IsColorFontEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsColorFontEnabledProperty;
	static struct _MaxLinesProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics2>()->_get_MaxLinesProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxLinesProperty;
	static struct _OpticalMarginAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics2>()->_get_OpticalMarginAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OpticalMarginAlignmentProperty;
	static struct _SelectionHighlightColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics2>()->_get_SelectionHighlightColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectionHighlightColorProperty;
	static struct _TextLineBoundsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics2>()->_get_TextLineBoundsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextLineBoundsProperty;
	static struct _TextReadingOrderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics2>()->_get_TextReadingOrderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextReadingOrderProperty;
	static struct _IsTextScaleFactorEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics3>()->_get_IsTextScaleFactorEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTextScaleFactorEnabledProperty;
	static struct _TextDecorationsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics4>()->_get_TextDecorationsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextDecorationsProperty;
	static struct _HorizontalTextAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics5>()->_get_HorizontalTextAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalTextAlignmentProperty;
	static struct _IsTextTrimmedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichTextBlock, IRichTextBlockStatics5>()->_get_IsTextTrimmedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTextTrimmedProperty;
};
template<typename X> typename RichTextBlock_statics<X>::_CharacterSpacingProperty RichTextBlock_statics<X>::CharacterSpacingProperty;
template<typename X> typename RichTextBlock_statics<X>::_FontFamilyProperty RichTextBlock_statics<X>::FontFamilyProperty;
template<typename X> typename RichTextBlock_statics<X>::_FontSizeProperty RichTextBlock_statics<X>::FontSizeProperty;
template<typename X> typename RichTextBlock_statics<X>::_FontStretchProperty RichTextBlock_statics<X>::FontStretchProperty;
template<typename X> typename RichTextBlock_statics<X>::_FontStyleProperty RichTextBlock_statics<X>::FontStyleProperty;
template<typename X> typename RichTextBlock_statics<X>::_FontWeightProperty RichTextBlock_statics<X>::FontWeightProperty;
template<typename X> typename RichTextBlock_statics<X>::_ForegroundProperty RichTextBlock_statics<X>::ForegroundProperty;
template<typename X> typename RichTextBlock_statics<X>::_HasOverflowContentProperty RichTextBlock_statics<X>::HasOverflowContentProperty;
template<typename X> typename RichTextBlock_statics<X>::_IsTextSelectionEnabledProperty RichTextBlock_statics<X>::IsTextSelectionEnabledProperty;
template<typename X> typename RichTextBlock_statics<X>::_LineHeightProperty RichTextBlock_statics<X>::LineHeightProperty;
template<typename X> typename RichTextBlock_statics<X>::_LineStackingStrategyProperty RichTextBlock_statics<X>::LineStackingStrategyProperty;
template<typename X> typename RichTextBlock_statics<X>::_OverflowContentTargetProperty RichTextBlock_statics<X>::OverflowContentTargetProperty;
template<typename X> typename RichTextBlock_statics<X>::_PaddingProperty RichTextBlock_statics<X>::PaddingProperty;
template<typename X> typename RichTextBlock_statics<X>::_SelectedTextProperty RichTextBlock_statics<X>::SelectedTextProperty;
template<typename X> typename RichTextBlock_statics<X>::_TextAlignmentProperty RichTextBlock_statics<X>::TextAlignmentProperty;
template<typename X> typename RichTextBlock_statics<X>::_TextIndentProperty RichTextBlock_statics<X>::TextIndentProperty;
template<typename X> typename RichTextBlock_statics<X>::_TextTrimmingProperty RichTextBlock_statics<X>::TextTrimmingProperty;
template<typename X> typename RichTextBlock_statics<X>::_TextWrappingProperty RichTextBlock_statics<X>::TextWrappingProperty;
template<typename X> typename RichTextBlock_statics<X>::_IsColorFontEnabledProperty RichTextBlock_statics<X>::IsColorFontEnabledProperty;
template<typename X> typename RichTextBlock_statics<X>::_MaxLinesProperty RichTextBlock_statics<X>::MaxLinesProperty;
template<typename X> typename RichTextBlock_statics<X>::_OpticalMarginAlignmentProperty RichTextBlock_statics<X>::OpticalMarginAlignmentProperty;
template<typename X> typename RichTextBlock_statics<X>::_SelectionHighlightColorProperty RichTextBlock_statics<X>::SelectionHighlightColorProperty;
template<typename X> typename RichTextBlock_statics<X>::_TextLineBoundsProperty RichTextBlock_statics<X>::TextLineBoundsProperty;
template<typename X> typename RichTextBlock_statics<X>::_TextReadingOrderProperty RichTextBlock_statics<X>::TextReadingOrderProperty;
template<typename X> typename RichTextBlock_statics<X>::_IsTextScaleFactorEnabledProperty RichTextBlock_statics<X>::IsTextScaleFactorEnabledProperty;
template<typename X> typename RichTextBlock_statics<X>::_TextDecorationsProperty RichTextBlock_statics<X>::TextDecorationsProperty;
template<typename X> typename RichTextBlock_statics<X>::_HorizontalTextAlignmentProperty RichTextBlock_statics<X>::HorizontalTextAlignmentProperty;
template<typename X> typename RichTextBlock_statics<X>::_IsTextTrimmedProperty RichTextBlock_statics<X>::IsTextTrimmedProperty;

template<typename X> struct statics<RichTextBlock, X> : X, Windows::UI::Xaml::Controls::RichTextBlock_statics<void> {
	typedef typename X::root_type RichTextBlock;
};
struct RichTextBlock : generate<RichTextBlock> {};

// TextBlock
template<typename> struct TextBlock_statics {
	static struct _CharacterSpacingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_CharacterSpacingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CharacterSpacingProperty;
	static struct _FontFamilyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_FontFamilyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontFamilyProperty;
	static struct _FontSizeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_FontSizeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontSizeProperty;
	static struct _FontStretchProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_FontStretchProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontStretchProperty;
	static struct _FontStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_FontStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontStyleProperty;
	static struct _FontWeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_FontWeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontWeightProperty;
	static struct _ForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_ForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ForegroundProperty;
	static struct _IsTextSelectionEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_IsTextSelectionEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTextSelectionEnabledProperty;
	static struct _LineHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_LineHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LineHeightProperty;
	static struct _LineStackingStrategyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_LineStackingStrategyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LineStackingStrategyProperty;
	static struct _PaddingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_PaddingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaddingProperty;
	static struct _SelectedTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_SelectedTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedTextProperty;
	static struct _TextAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_TextAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextAlignmentProperty;
	static struct _TextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_TextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextProperty;
	static struct _TextTrimmingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_TextTrimmingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextTrimmingProperty;
	static struct _TextWrappingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics>()->_get_TextWrappingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextWrappingProperty;
	static struct _IsColorFontEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics2>()->_get_IsColorFontEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsColorFontEnabledProperty;
	static struct _MaxLinesProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics2>()->_get_MaxLinesProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxLinesProperty;
	static struct _OpticalMarginAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics2>()->_get_OpticalMarginAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OpticalMarginAlignmentProperty;
	static struct _SelectionHighlightColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics2>()->_get_SelectionHighlightColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectionHighlightColorProperty;
	static struct _TextLineBoundsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics2>()->_get_TextLineBoundsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextLineBoundsProperty;
	static struct _TextReadingOrderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics2>()->_get_TextReadingOrderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextReadingOrderProperty;
	static struct _IsTextScaleFactorEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics3>()->_get_IsTextScaleFactorEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTextScaleFactorEnabledProperty;
	static struct _TextDecorationsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics5>()->_get_TextDecorationsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextDecorationsProperty;
	static struct _HorizontalTextAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics6>()->_get_HorizontalTextAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalTextAlignmentProperty;
	static struct _IsTextTrimmedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBlock, ITextBlockStatics6>()->_get_IsTextTrimmedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTextTrimmedProperty;
};
template<typename X> typename TextBlock_statics<X>::_CharacterSpacingProperty TextBlock_statics<X>::CharacterSpacingProperty;
template<typename X> typename TextBlock_statics<X>::_FontFamilyProperty TextBlock_statics<X>::FontFamilyProperty;
template<typename X> typename TextBlock_statics<X>::_FontSizeProperty TextBlock_statics<X>::FontSizeProperty;
template<typename X> typename TextBlock_statics<X>::_FontStretchProperty TextBlock_statics<X>::FontStretchProperty;
template<typename X> typename TextBlock_statics<X>::_FontStyleProperty TextBlock_statics<X>::FontStyleProperty;
template<typename X> typename TextBlock_statics<X>::_FontWeightProperty TextBlock_statics<X>::FontWeightProperty;
template<typename X> typename TextBlock_statics<X>::_ForegroundProperty TextBlock_statics<X>::ForegroundProperty;
template<typename X> typename TextBlock_statics<X>::_IsTextSelectionEnabledProperty TextBlock_statics<X>::IsTextSelectionEnabledProperty;
template<typename X> typename TextBlock_statics<X>::_LineHeightProperty TextBlock_statics<X>::LineHeightProperty;
template<typename X> typename TextBlock_statics<X>::_LineStackingStrategyProperty TextBlock_statics<X>::LineStackingStrategyProperty;
template<typename X> typename TextBlock_statics<X>::_PaddingProperty TextBlock_statics<X>::PaddingProperty;
template<typename X> typename TextBlock_statics<X>::_SelectedTextProperty TextBlock_statics<X>::SelectedTextProperty;
template<typename X> typename TextBlock_statics<X>::_TextAlignmentProperty TextBlock_statics<X>::TextAlignmentProperty;
template<typename X> typename TextBlock_statics<X>::_TextProperty TextBlock_statics<X>::TextProperty;
template<typename X> typename TextBlock_statics<X>::_TextTrimmingProperty TextBlock_statics<X>::TextTrimmingProperty;
template<typename X> typename TextBlock_statics<X>::_TextWrappingProperty TextBlock_statics<X>::TextWrappingProperty;
template<typename X> typename TextBlock_statics<X>::_IsColorFontEnabledProperty TextBlock_statics<X>::IsColorFontEnabledProperty;
template<typename X> typename TextBlock_statics<X>::_MaxLinesProperty TextBlock_statics<X>::MaxLinesProperty;
template<typename X> typename TextBlock_statics<X>::_OpticalMarginAlignmentProperty TextBlock_statics<X>::OpticalMarginAlignmentProperty;
template<typename X> typename TextBlock_statics<X>::_SelectionHighlightColorProperty TextBlock_statics<X>::SelectionHighlightColorProperty;
template<typename X> typename TextBlock_statics<X>::_TextLineBoundsProperty TextBlock_statics<X>::TextLineBoundsProperty;
template<typename X> typename TextBlock_statics<X>::_TextReadingOrderProperty TextBlock_statics<X>::TextReadingOrderProperty;
template<typename X> typename TextBlock_statics<X>::_IsTextScaleFactorEnabledProperty TextBlock_statics<X>::IsTextScaleFactorEnabledProperty;
template<typename X> typename TextBlock_statics<X>::_TextDecorationsProperty TextBlock_statics<X>::TextDecorationsProperty;
template<typename X> typename TextBlock_statics<X>::_HorizontalTextAlignmentProperty TextBlock_statics<X>::HorizontalTextAlignmentProperty;
template<typename X> typename TextBlock_statics<X>::_IsTextTrimmedProperty TextBlock_statics<X>::IsTextTrimmedProperty;

template<typename X> struct statics<TextBlock, X> : X, Windows::UI::Xaml::Controls::TextBlock_statics<void> {
	typedef typename X::root_type TextBlock;
};
struct TextBlock : generate<TextBlock> {};

// Viewbox
template<typename> struct Viewbox_statics {
	static struct _StretchDirectionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Viewbox, IViewboxStatics>()->_get_StretchDirectionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StretchDirectionProperty;
	static struct _StretchProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Viewbox, IViewboxStatics>()->_get_StretchProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StretchProperty;
};
template<typename X> typename Viewbox_statics<X>::_StretchDirectionProperty Viewbox_statics<X>::StretchDirectionProperty;
template<typename X> typename Viewbox_statics<X>::_StretchProperty Viewbox_statics<X>::StretchProperty;

template<typename X> struct statics<Viewbox, X> : X, Windows::UI::Xaml::Controls::Viewbox_statics<void> {
	typedef typename X::root_type Viewbox;
};
struct Viewbox : generate<Viewbox> {};

// Grid
template<typename> struct Grid_statics {
	static struct _ColumnProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Grid, IGridStatics>()->_get_ColumnProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ColumnProperty;
	static struct _ColumnSpanProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Grid, IGridStatics>()->_get_ColumnSpanProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ColumnSpanProperty;
	static struct _RowProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Grid, IGridStatics>()->_get_RowProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RowProperty;
	static struct _RowSpanProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Grid, IGridStatics>()->_get_RowSpanProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RowSpanProperty;
	static struct _BorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Grid, IGridStatics2>()->_get_BorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BorderBrushProperty;
	static struct _BorderThicknessProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Grid, IGridStatics2>()->_get_BorderThicknessProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BorderThicknessProperty;
	static struct _CornerRadiusProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Grid, IGridStatics2>()->_get_CornerRadiusProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CornerRadiusProperty;
	static struct _PaddingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Grid, IGridStatics2>()->_get_PaddingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaddingProperty;
	static struct _ColumnSpacingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Grid, IGridStatics3>()->_get_ColumnSpacingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ColumnSpacingProperty;
	static struct _RowSpacingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Grid, IGridStatics3>()->_get_RowSpacingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RowSpacingProperty;
	static int GetRow(pptr<FrameworkElement> element) { int value; hrcheck(get_activation_factory<Grid, IGridStatics>()->_GetRow(element, &value)); return value; }
	static void SetRow(pptr<FrameworkElement> element, int value) { hrcheck(get_activation_factory<Grid, IGridStatics>()->_SetRow(element, value)); }
	static int GetColumn(pptr<FrameworkElement> element) { int value; hrcheck(get_activation_factory<Grid, IGridStatics>()->_GetColumn(element, &value)); return value; }
	static void SetColumn(pptr<FrameworkElement> element, int value) { hrcheck(get_activation_factory<Grid, IGridStatics>()->_SetColumn(element, value)); }
	static int GetRowSpan(pptr<FrameworkElement> element) { int value; hrcheck(get_activation_factory<Grid, IGridStatics>()->_GetRowSpan(element, &value)); return value; }
	static void SetRowSpan(pptr<FrameworkElement> element, int value) { hrcheck(get_activation_factory<Grid, IGridStatics>()->_SetRowSpan(element, value)); }
	static int GetColumnSpan(pptr<FrameworkElement> element) { int value; hrcheck(get_activation_factory<Grid, IGridStatics>()->_GetColumnSpan(element, &value)); return value; }
	static void SetColumnSpan(pptr<FrameworkElement> element, int value) { hrcheck(get_activation_factory<Grid, IGridStatics>()->_SetColumnSpan(element, value)); }
	static Grid *activate(object_ref outer, IInspectable* *inner) { Grid *instance; hrcheck(get_activation_factory<Grid, IGridFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename Grid_statics<X>::_ColumnProperty Grid_statics<X>::ColumnProperty;
template<typename X> typename Grid_statics<X>::_ColumnSpanProperty Grid_statics<X>::ColumnSpanProperty;
template<typename X> typename Grid_statics<X>::_RowProperty Grid_statics<X>::RowProperty;
template<typename X> typename Grid_statics<X>::_RowSpanProperty Grid_statics<X>::RowSpanProperty;
template<typename X> typename Grid_statics<X>::_BorderBrushProperty Grid_statics<X>::BorderBrushProperty;
template<typename X> typename Grid_statics<X>::_BorderThicknessProperty Grid_statics<X>::BorderThicknessProperty;
template<typename X> typename Grid_statics<X>::_CornerRadiusProperty Grid_statics<X>::CornerRadiusProperty;
template<typename X> typename Grid_statics<X>::_PaddingProperty Grid_statics<X>::PaddingProperty;
template<typename X> typename Grid_statics<X>::_ColumnSpacingProperty Grid_statics<X>::ColumnSpacingProperty;
template<typename X> typename Grid_statics<X>::_RowSpacingProperty Grid_statics<X>::RowSpacingProperty;

template<typename X> struct statics<Grid, X> : X, Windows::UI::Xaml::Controls::Grid_statics<void> {
	using Windows::UI::Xaml::Controls::Grid_statics<void>::activate;
	typedef typename X::root_type Grid;
};
struct Grid : generate<Grid> {};

// RelativePanel
template<typename> struct RelativePanel_statics {
	static struct _AboveProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_AboveProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AboveProperty;
	static struct _AlignBottomWithPanelProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_AlignBottomWithPanelProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlignBottomWithPanelProperty;
	static struct _AlignBottomWithProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_AlignBottomWithProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlignBottomWithProperty;
	static struct _AlignHorizontalCenterWithPanelProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_AlignHorizontalCenterWithPanelProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlignHorizontalCenterWithPanelProperty;
	static struct _AlignHorizontalCenterWithProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_AlignHorizontalCenterWithProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlignHorizontalCenterWithProperty;
	static struct _AlignLeftWithPanelProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_AlignLeftWithPanelProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlignLeftWithPanelProperty;
	static struct _AlignLeftWithProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_AlignLeftWithProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlignLeftWithProperty;
	static struct _AlignRightWithPanelProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_AlignRightWithPanelProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlignRightWithPanelProperty;
	static struct _AlignRightWithProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_AlignRightWithProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlignRightWithProperty;
	static struct _AlignTopWithPanelProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_AlignTopWithPanelProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlignTopWithPanelProperty;
	static struct _AlignTopWithProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_AlignTopWithProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlignTopWithProperty;
	static struct _AlignVerticalCenterWithPanelProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_AlignVerticalCenterWithPanelProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlignVerticalCenterWithPanelProperty;
	static struct _AlignVerticalCenterWithProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_AlignVerticalCenterWithProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlignVerticalCenterWithProperty;
	static struct _BelowProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_BelowProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BelowProperty;
	static struct _BorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_BorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BorderBrushProperty;
	static struct _BorderThicknessProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_BorderThicknessProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BorderThicknessProperty;
	static struct _CornerRadiusProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_CornerRadiusProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CornerRadiusProperty;
	static struct _LeftOfProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_LeftOfProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LeftOfProperty;
	static struct _PaddingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_PaddingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaddingProperty;
	static struct _RightOfProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_get_RightOfProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RightOfProperty;
	static object GetLeftOf(pptr<UIElement> element) { IInspectable* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetLeftOf(element, &value)); return from_abi(value); }
	static void SetLeftOf(pptr<UIElement> element, object_ref value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetLeftOf(element, value)); }
	static object GetAbove(pptr<UIElement> element) { IInspectable* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetAbove(element, &value)); return from_abi(value); }
	static void SetAbove(pptr<UIElement> element, object_ref value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetAbove(element, value)); }
	static object GetRightOf(pptr<UIElement> element) { IInspectable* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetRightOf(element, &value)); return from_abi(value); }
	static void SetRightOf(pptr<UIElement> element, object_ref value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetRightOf(element, value)); }
	static object GetBelow(pptr<UIElement> element) { IInspectable* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetBelow(element, &value)); return from_abi(value); }
	static void SetBelow(pptr<UIElement> element, object_ref value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetBelow(element, value)); }
	static object GetAlignHorizontalCenterWith(pptr<UIElement> element) { IInspectable* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetAlignHorizontalCenterWith(element, &value)); return from_abi(value); }
	static void SetAlignHorizontalCenterWith(pptr<UIElement> element, object_ref value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetAlignHorizontalCenterWith(element, value)); }
	static object GetAlignVerticalCenterWith(pptr<UIElement> element) { IInspectable* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetAlignVerticalCenterWith(element, &value)); return from_abi(value); }
	static void SetAlignVerticalCenterWith(pptr<UIElement> element, object_ref value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetAlignVerticalCenterWith(element, value)); }
	static object GetAlignLeftWith(pptr<UIElement> element) { IInspectable* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetAlignLeftWith(element, &value)); return from_abi(value); }
	static void SetAlignLeftWith(pptr<UIElement> element, object_ref value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetAlignLeftWith(element, value)); }
	static object GetAlignTopWith(pptr<UIElement> element) { IInspectable* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetAlignTopWith(element, &value)); return from_abi(value); }
	static void SetAlignTopWith(pptr<UIElement> element, object_ref value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetAlignTopWith(element, value)); }
	static object GetAlignRightWith(pptr<UIElement> element) { IInspectable* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetAlignRightWith(element, &value)); return from_abi(value); }
	static void SetAlignRightWith(pptr<UIElement> element, object_ref value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetAlignRightWith(element, value)); }
	static object GetAlignBottomWith(pptr<UIElement> element) { IInspectable* value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetAlignBottomWith(element, &value)); return from_abi(value); }
	static void SetAlignBottomWith(pptr<UIElement> element, object_ref value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetAlignBottomWith(element, value)); }
	static bool GetAlignLeftWithPanel(pptr<UIElement> element) { bool value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetAlignLeftWithPanel(element, &value)); return value; }
	static void SetAlignLeftWithPanel(pptr<UIElement> element, bool value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetAlignLeftWithPanel(element, value)); }
	static bool GetAlignTopWithPanel(pptr<UIElement> element) { bool value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetAlignTopWithPanel(element, &value)); return value; }
	static void SetAlignTopWithPanel(pptr<UIElement> element, bool value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetAlignTopWithPanel(element, value)); }
	static bool GetAlignRightWithPanel(pptr<UIElement> element) { bool value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetAlignRightWithPanel(element, &value)); return value; }
	static void SetAlignRightWithPanel(pptr<UIElement> element, bool value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetAlignRightWithPanel(element, value)); }
	static bool GetAlignBottomWithPanel(pptr<UIElement> element) { bool value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetAlignBottomWithPanel(element, &value)); return value; }
	static void SetAlignBottomWithPanel(pptr<UIElement> element, bool value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetAlignBottomWithPanel(element, value)); }
	static bool GetAlignHorizontalCenterWithPanel(pptr<UIElement> element) { bool value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetAlignHorizontalCenterWithPanel(element, &value)); return value; }
	static void SetAlignHorizontalCenterWithPanel(pptr<UIElement> element, bool value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetAlignHorizontalCenterWithPanel(element, value)); }
	static bool GetAlignVerticalCenterWithPanel(pptr<UIElement> element) { bool value; hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_GetAlignVerticalCenterWithPanel(element, &value)); return value; }
	static void SetAlignVerticalCenterWithPanel(pptr<UIElement> element, bool value) { hrcheck(get_activation_factory<RelativePanel, IRelativePanelStatics>()->_SetAlignVerticalCenterWithPanel(element, value)); }
	static RelativePanel *activate(object_ref outer, IInspectable* *inner) { RelativePanel *instance; hrcheck(get_activation_factory<RelativePanel, IRelativePanelFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename RelativePanel_statics<X>::_AboveProperty RelativePanel_statics<X>::AboveProperty;
template<typename X> typename RelativePanel_statics<X>::_AlignBottomWithPanelProperty RelativePanel_statics<X>::AlignBottomWithPanelProperty;
template<typename X> typename RelativePanel_statics<X>::_AlignBottomWithProperty RelativePanel_statics<X>::AlignBottomWithProperty;
template<typename X> typename RelativePanel_statics<X>::_AlignHorizontalCenterWithPanelProperty RelativePanel_statics<X>::AlignHorizontalCenterWithPanelProperty;
template<typename X> typename RelativePanel_statics<X>::_AlignHorizontalCenterWithProperty RelativePanel_statics<X>::AlignHorizontalCenterWithProperty;
template<typename X> typename RelativePanel_statics<X>::_AlignLeftWithPanelProperty RelativePanel_statics<X>::AlignLeftWithPanelProperty;
template<typename X> typename RelativePanel_statics<X>::_AlignLeftWithProperty RelativePanel_statics<X>::AlignLeftWithProperty;
template<typename X> typename RelativePanel_statics<X>::_AlignRightWithPanelProperty RelativePanel_statics<X>::AlignRightWithPanelProperty;
template<typename X> typename RelativePanel_statics<X>::_AlignRightWithProperty RelativePanel_statics<X>::AlignRightWithProperty;
template<typename X> typename RelativePanel_statics<X>::_AlignTopWithPanelProperty RelativePanel_statics<X>::AlignTopWithPanelProperty;
template<typename X> typename RelativePanel_statics<X>::_AlignTopWithProperty RelativePanel_statics<X>::AlignTopWithProperty;
template<typename X> typename RelativePanel_statics<X>::_AlignVerticalCenterWithPanelProperty RelativePanel_statics<X>::AlignVerticalCenterWithPanelProperty;
template<typename X> typename RelativePanel_statics<X>::_AlignVerticalCenterWithProperty RelativePanel_statics<X>::AlignVerticalCenterWithProperty;
template<typename X> typename RelativePanel_statics<X>::_BelowProperty RelativePanel_statics<X>::BelowProperty;
template<typename X> typename RelativePanel_statics<X>::_BorderBrushProperty RelativePanel_statics<X>::BorderBrushProperty;
template<typename X> typename RelativePanel_statics<X>::_BorderThicknessProperty RelativePanel_statics<X>::BorderThicknessProperty;
template<typename X> typename RelativePanel_statics<X>::_CornerRadiusProperty RelativePanel_statics<X>::CornerRadiusProperty;
template<typename X> typename RelativePanel_statics<X>::_LeftOfProperty RelativePanel_statics<X>::LeftOfProperty;
template<typename X> typename RelativePanel_statics<X>::_PaddingProperty RelativePanel_statics<X>::PaddingProperty;
template<typename X> typename RelativePanel_statics<X>::_RightOfProperty RelativePanel_statics<X>::RightOfProperty;

template<typename X> struct statics<RelativePanel, X> : X, Windows::UI::Xaml::Controls::RelativePanel_statics<void> {
	using Windows::UI::Xaml::Controls::RelativePanel_statics<void>::activate;
	typedef typename X::root_type RelativePanel;
};
struct RelativePanel : generate<RelativePanel> {};

// StackPanel
template<typename> struct StackPanel_statics {
	static struct _AreScrollSnapPointsRegularProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<StackPanel, IStackPanelStatics>()->_get_AreScrollSnapPointsRegularProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AreScrollSnapPointsRegularProperty;
	static struct _OrientationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<StackPanel, IStackPanelStatics>()->_get_OrientationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OrientationProperty;
	static struct _BorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<StackPanel, IStackPanelStatics2>()->_get_BorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BorderBrushProperty;
	static struct _BorderThicknessProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<StackPanel, IStackPanelStatics2>()->_get_BorderThicknessProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BorderThicknessProperty;
	static struct _CornerRadiusProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<StackPanel, IStackPanelStatics2>()->_get_CornerRadiusProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CornerRadiusProperty;
	static struct _PaddingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<StackPanel, IStackPanelStatics2>()->_get_PaddingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaddingProperty;
	static struct _SpacingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<StackPanel, IStackPanelStatics4>()->_get_SpacingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SpacingProperty;
	static StackPanel *activate(object_ref outer, IInspectable* *inner) { StackPanel *instance; hrcheck(get_activation_factory<StackPanel, IStackPanelFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename StackPanel_statics<X>::_AreScrollSnapPointsRegularProperty StackPanel_statics<X>::AreScrollSnapPointsRegularProperty;
template<typename X> typename StackPanel_statics<X>::_OrientationProperty StackPanel_statics<X>::OrientationProperty;
template<typename X> typename StackPanel_statics<X>::_BorderBrushProperty StackPanel_statics<X>::BorderBrushProperty;
template<typename X> typename StackPanel_statics<X>::_BorderThicknessProperty StackPanel_statics<X>::BorderThicknessProperty;
template<typename X> typename StackPanel_statics<X>::_CornerRadiusProperty StackPanel_statics<X>::CornerRadiusProperty;
template<typename X> typename StackPanel_statics<X>::_PaddingProperty StackPanel_statics<X>::PaddingProperty;
template<typename X> typename StackPanel_statics<X>::_SpacingProperty StackPanel_statics<X>::SpacingProperty;

template<typename X> struct statics<StackPanel, X> : X, Windows::UI::Xaml::Controls::StackPanel_statics<void> {
	using Windows::UI::Xaml::Controls::StackPanel_statics<void>::activate;
	typedef typename X::root_type StackPanel;
};
struct StackPanel : generate<StackPanel> {};

// VariableSizedWrapGrid
template<typename> struct VariableSizedWrapGrid_statics {
	static struct _ColumnSpanProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<VariableSizedWrapGrid, IVariableSizedWrapGridStatics>()->_get_ColumnSpanProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ColumnSpanProperty;
	static struct _HorizontalChildrenAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<VariableSizedWrapGrid, IVariableSizedWrapGridStatics>()->_get_HorizontalChildrenAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalChildrenAlignmentProperty;
	static struct _ItemHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<VariableSizedWrapGrid, IVariableSizedWrapGridStatics>()->_get_ItemHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemHeightProperty;
	static struct _ItemWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<VariableSizedWrapGrid, IVariableSizedWrapGridStatics>()->_get_ItemWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemWidthProperty;
	static struct _MaximumRowsOrColumnsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<VariableSizedWrapGrid, IVariableSizedWrapGridStatics>()->_get_MaximumRowsOrColumnsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaximumRowsOrColumnsProperty;
	static struct _OrientationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<VariableSizedWrapGrid, IVariableSizedWrapGridStatics>()->_get_OrientationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OrientationProperty;
	static struct _RowSpanProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<VariableSizedWrapGrid, IVariableSizedWrapGridStatics>()->_get_RowSpanProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RowSpanProperty;
	static struct _VerticalChildrenAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<VariableSizedWrapGrid, IVariableSizedWrapGridStatics>()->_get_VerticalChildrenAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalChildrenAlignmentProperty;
	static int GetRowSpan(pptr<UIElement> element) { int value; hrcheck(get_activation_factory<VariableSizedWrapGrid, IVariableSizedWrapGridStatics>()->_GetRowSpan(element, &value)); return value; }
	static void SetRowSpan(pptr<UIElement> element, int value) { hrcheck(get_activation_factory<VariableSizedWrapGrid, IVariableSizedWrapGridStatics>()->_SetRowSpan(element, value)); }
	static int GetColumnSpan(pptr<UIElement> element) { int value; hrcheck(get_activation_factory<VariableSizedWrapGrid, IVariableSizedWrapGridStatics>()->_GetColumnSpan(element, &value)); return value; }
	static void SetColumnSpan(pptr<UIElement> element, int value) { hrcheck(get_activation_factory<VariableSizedWrapGrid, IVariableSizedWrapGridStatics>()->_SetColumnSpan(element, value)); }
};
template<typename X> typename VariableSizedWrapGrid_statics<X>::_ColumnSpanProperty VariableSizedWrapGrid_statics<X>::ColumnSpanProperty;
template<typename X> typename VariableSizedWrapGrid_statics<X>::_HorizontalChildrenAlignmentProperty VariableSizedWrapGrid_statics<X>::HorizontalChildrenAlignmentProperty;
template<typename X> typename VariableSizedWrapGrid_statics<X>::_ItemHeightProperty VariableSizedWrapGrid_statics<X>::ItemHeightProperty;
template<typename X> typename VariableSizedWrapGrid_statics<X>::_ItemWidthProperty VariableSizedWrapGrid_statics<X>::ItemWidthProperty;
template<typename X> typename VariableSizedWrapGrid_statics<X>::_MaximumRowsOrColumnsProperty VariableSizedWrapGrid_statics<X>::MaximumRowsOrColumnsProperty;
template<typename X> typename VariableSizedWrapGrid_statics<X>::_OrientationProperty VariableSizedWrapGrid_statics<X>::OrientationProperty;
template<typename X> typename VariableSizedWrapGrid_statics<X>::_RowSpanProperty VariableSizedWrapGrid_statics<X>::RowSpanProperty;
template<typename X> typename VariableSizedWrapGrid_statics<X>::_VerticalChildrenAlignmentProperty VariableSizedWrapGrid_statics<X>::VerticalChildrenAlignmentProperty;

template<typename X> struct statics<VariableSizedWrapGrid, X> : X, Windows::UI::Xaml::Controls::VariableSizedWrapGrid_statics<void> {
	typedef typename X::root_type VariableSizedWrapGrid;
};
struct VariableSizedWrapGrid : generate<VariableSizedWrapGrid> {};

// IRatingControlFactory
struct IRatingControlFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, RatingControl* *instance);
};

// IRatingControl
struct IRatingControl_raw : IInspectable {
	virtual STDMETHODIMP _get_Caption(HSTRING *value);
	virtual STDMETHODIMP _put_Caption(HSTRING value);
	virtual STDMETHODIMP _get_InitialSetValue(int *value);
	virtual STDMETHODIMP _put_InitialSetValue(int value);
	virtual STDMETHODIMP _get_IsClearEnabled(bool *value);
	virtual STDMETHODIMP _put_IsClearEnabled(bool value);
	virtual STDMETHODIMP _get_IsReadOnly(bool *value);
	virtual STDMETHODIMP _put_IsReadOnly(bool value);
	virtual STDMETHODIMP _get_MaxRating(int *value);
	virtual STDMETHODIMP _put_MaxRating(int value);
	virtual STDMETHODIMP _get_PlaceholderValue(double *value);
	virtual STDMETHODIMP _put_PlaceholderValue(double value);
	virtual STDMETHODIMP _get_ItemInfo(RatingItemInfo* *value);
	virtual STDMETHODIMP _put_ItemInfo(RatingItemInfo* value);
	virtual STDMETHODIMP _get_Value(double *value);
	virtual STDMETHODIMP _put_Value(double value);
	virtual STDMETHODIMP _add_ValueChanged(Foundation::TypedEventHandler<RatingControl*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ValueChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IRatingControl_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRatingControl_adaptor::Caption)->_get_Caption(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IRatingControl_adaptor::Caption)->_put_Caption(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Caption;
		struct : property {
			int get() { int value; hrcheck(enc(&IRatingControl_adaptor::InitialSetValue)->_get_InitialSetValue(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IRatingControl_adaptor::InitialSetValue)->_put_InitialSetValue(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} InitialSetValue;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRatingControl_adaptor::IsClearEnabled)->_get_IsClearEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IRatingControl_adaptor::IsClearEnabled)->_put_IsClearEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsClearEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRatingControl_adaptor::IsReadOnly)->_get_IsReadOnly(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IRatingControl_adaptor::IsReadOnly)->_put_IsReadOnly(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsReadOnly;
		struct : property {
			ptr<RatingItemInfo> get() { RatingItemInfo* value; hrcheck(enc(&IRatingControl_adaptor::ItemInfo)->_get_ItemInfo(&value)); return from_abi(value); }
			ptr<RatingItemInfo> operator()() { return get(); }
			operator ptr<RatingItemInfo> () { return get(); }
			ptr<RatingItemInfo> operator->() { return get(); }
			void put(pptr<RatingItemInfo> value) { hrcheck(enc(&IRatingControl_adaptor::ItemInfo)->_put_ItemInfo(value)); }
			void operator=(pptr<RatingItemInfo> value) { put(value); }
			void operator()(pptr<RatingItemInfo> value) { put(value); }
		} ItemInfo;
		struct : property {
			int get() { int value; hrcheck(enc(&IRatingControl_adaptor::MaxRating)->_get_MaxRating(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IRatingControl_adaptor::MaxRating)->_put_MaxRating(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaxRating;
		struct : property {
			double get() { double value; hrcheck(enc(&IRatingControl_adaptor::PlaceholderValue)->_get_PlaceholderValue(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRatingControl_adaptor::PlaceholderValue)->_put_PlaceholderValue(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} PlaceholderValue;
		struct : property {
			double get() { double value; hrcheck(enc(&IRatingControl_adaptor::Value)->_get_Value(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IRatingControl_adaptor::Value)->_put_Value(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Value;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<RatingControl>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IRatingControl_adaptor::ValueChanged)->_add_ValueChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IRatingControl_adaptor::ValueChanged)->_remove_ValueChanged(token)); }
		} ValueChanged;
	};
	IRatingControl_adaptor() {}
};
template<typename X> struct adapt<IRatingControl, X> : Windows::UI::Xaml::Controls::IRatingControl_adaptor<X> { typedef adapt IRatingControl; };
struct IRatingControl : IRatingControl_raw, generate<IRatingControl> {};

// VirtualizingStackPanel
template<typename> struct VirtualizingStackPanel_statics {
	static struct _AreScrollSnapPointsRegularProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<VirtualizingStackPanel, IVirtualizingStackPanelStatics>()->_get_AreScrollSnapPointsRegularProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AreScrollSnapPointsRegularProperty;
	static struct _IsVirtualizingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<VirtualizingStackPanel, IVirtualizingStackPanelStatics>()->_get_IsVirtualizingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsVirtualizingProperty;
	static struct _OrientationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<VirtualizingStackPanel, IVirtualizingStackPanelStatics>()->_get_OrientationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OrientationProperty;
	static struct _VirtualizationModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<VirtualizingStackPanel, IVirtualizingStackPanelStatics>()->_get_VirtualizationModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VirtualizationModeProperty;
	static VirtualizationMode GetVirtualizationMode(pptr<DependencyObject> element) { VirtualizationMode value; hrcheck(get_activation_factory<VirtualizingStackPanel, IVirtualizingStackPanelStatics>()->_GetVirtualizationMode(element, &value)); return value; }
	static void SetVirtualizationMode(pptr<DependencyObject> element, VirtualizationMode value) { hrcheck(get_activation_factory<VirtualizingStackPanel, IVirtualizingStackPanelStatics>()->_SetVirtualizationMode(element, value)); }
	static bool GetIsVirtualizing(pptr<DependencyObject> o) { bool value; hrcheck(get_activation_factory<VirtualizingStackPanel, IVirtualizingStackPanelStatics>()->_GetIsVirtualizing(o, &value)); return value; }
};
template<typename X> typename VirtualizingStackPanel_statics<X>::_AreScrollSnapPointsRegularProperty VirtualizingStackPanel_statics<X>::AreScrollSnapPointsRegularProperty;
template<typename X> typename VirtualizingStackPanel_statics<X>::_IsVirtualizingProperty VirtualizingStackPanel_statics<X>::IsVirtualizingProperty;
template<typename X> typename VirtualizingStackPanel_statics<X>::_OrientationProperty VirtualizingStackPanel_statics<X>::OrientationProperty;
template<typename X> typename VirtualizingStackPanel_statics<X>::_VirtualizationModeProperty VirtualizingStackPanel_statics<X>::VirtualizationModeProperty;

template<typename X> struct statics<VirtualizingStackPanel, X> : X, Windows::UI::Xaml::Controls::VirtualizingStackPanel_statics<void> {
	typedef typename X::root_type VirtualizingStackPanel;
};
struct VirtualizingStackPanel : generate<VirtualizingStackPanel> {};

// IconElement
template<typename> struct IconElement_statics {
	static struct _ForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<IconElement, IIconElementStatics>()->_get_ForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ForegroundProperty;
};
template<typename X> typename IconElement_statics<X>::_ForegroundProperty IconElement_statics<X>::ForegroundProperty;

template<typename X> struct statics<IconElement, X> : X, Windows::UI::Xaml::Controls::IconElement_statics<void> {
	typedef typename X::root_type IconElement;
};
struct IconElement : generate<IconElement> {};

// InkCanvas
template<typename> struct InkCanvas_statics {
	static InkCanvas *activate(object_ref outer, IInspectable* *inner) { InkCanvas *instance; hrcheck(get_activation_factory<InkCanvas, IInkCanvasFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<InkCanvas, X> : X, Windows::UI::Xaml::Controls::InkCanvas_statics<void> {
	using Windows::UI::Xaml::Controls::InkCanvas_statics<void>::activate;
	typedef typename X::root_type InkCanvas;
};
struct InkCanvas : generate<InkCanvas> {};

// MediaElement
template<typename> struct MediaElement_statics {
	static struct _ActualStereo3DVideoPackingModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_ActualStereo3DVideoPackingModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ActualStereo3DVideoPackingModeProperty;
	static struct _AspectRatioHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_AspectRatioHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AspectRatioHeightProperty;
	static struct _AspectRatioWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_AspectRatioWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AspectRatioWidthProperty;
	static struct _AudioCategoryProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_AudioCategoryProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AudioCategoryProperty;
	static struct _AudioDeviceTypeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_AudioDeviceTypeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AudioDeviceTypeProperty;
	static struct _AudioStreamCountProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_AudioStreamCountProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AudioStreamCountProperty;
	static struct _AudioStreamIndexProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_AudioStreamIndexProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AudioStreamIndexProperty;
	static struct _AutoPlayProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_AutoPlayProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AutoPlayProperty;
	static struct _BalanceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_BalanceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BalanceProperty;
	static struct _BufferingProgressProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_BufferingProgressProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BufferingProgressProperty;
	static struct _CanPauseProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_CanPauseProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CanPauseProperty;
	static struct _CanSeekProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_CanSeekProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CanSeekProperty;
	static struct _CurrentStateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_CurrentStateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CurrentStateProperty;
	static struct _DefaultPlaybackRateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_DefaultPlaybackRateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DefaultPlaybackRateProperty;
	static struct _DownloadProgressOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_DownloadProgressOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DownloadProgressOffsetProperty;
	static struct _DownloadProgressProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_DownloadProgressProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DownloadProgressProperty;
	static struct _IsAudioOnlyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_IsAudioOnlyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsAudioOnlyProperty;
	static struct _IsLoopingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_IsLoopingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsLoopingProperty;
	static struct _IsMutedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_IsMutedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsMutedProperty;
	static struct _IsStereo3DVideoProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_IsStereo3DVideoProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsStereo3DVideoProperty;
	static struct _NaturalDurationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_NaturalDurationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} NaturalDurationProperty;
	static struct _NaturalVideoHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_NaturalVideoHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} NaturalVideoHeightProperty;
	static struct _NaturalVideoWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_NaturalVideoWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} NaturalVideoWidthProperty;
	static struct _PlayToSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_PlayToSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlayToSourceProperty;
	static struct _PlaybackRateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_PlaybackRateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlaybackRateProperty;
	static struct _PositionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_PositionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PositionProperty;
	static struct _PosterSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_PosterSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PosterSourceProperty;
	static struct _ProtectionManagerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_ProtectionManagerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ProtectionManagerProperty;
	static struct _RealTimePlaybackProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_RealTimePlaybackProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RealTimePlaybackProperty;
	static struct _SourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_SourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SourceProperty;
	static struct _Stereo3DVideoPackingModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_Stereo3DVideoPackingModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} Stereo3DVideoPackingModeProperty;
	static struct _Stereo3DVideoRenderModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_Stereo3DVideoRenderModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} Stereo3DVideoRenderModeProperty;
	static struct _VolumeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics>()->_get_VolumeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VolumeProperty;
	static struct _AreTransportControlsEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics2>()->_get_AreTransportControlsEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AreTransportControlsEnabledProperty;
	static struct _IsFullWindowProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics2>()->_get_IsFullWindowProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsFullWindowProperty;
	static struct _PlayToPreferredSourceUriProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics2>()->_get_PlayToPreferredSourceUriProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlayToPreferredSourceUriProperty;
	static struct _StretchProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaElement, IMediaElementStatics2>()->_get_StretchProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StretchProperty;
};
template<typename X> typename MediaElement_statics<X>::_ActualStereo3DVideoPackingModeProperty MediaElement_statics<X>::ActualStereo3DVideoPackingModeProperty;
template<typename X> typename MediaElement_statics<X>::_AspectRatioHeightProperty MediaElement_statics<X>::AspectRatioHeightProperty;
template<typename X> typename MediaElement_statics<X>::_AspectRatioWidthProperty MediaElement_statics<X>::AspectRatioWidthProperty;
template<typename X> typename MediaElement_statics<X>::_AudioCategoryProperty MediaElement_statics<X>::AudioCategoryProperty;
template<typename X> typename MediaElement_statics<X>::_AudioDeviceTypeProperty MediaElement_statics<X>::AudioDeviceTypeProperty;
template<typename X> typename MediaElement_statics<X>::_AudioStreamCountProperty MediaElement_statics<X>::AudioStreamCountProperty;
template<typename X> typename MediaElement_statics<X>::_AudioStreamIndexProperty MediaElement_statics<X>::AudioStreamIndexProperty;
template<typename X> typename MediaElement_statics<X>::_AutoPlayProperty MediaElement_statics<X>::AutoPlayProperty;
template<typename X> typename MediaElement_statics<X>::_BalanceProperty MediaElement_statics<X>::BalanceProperty;
template<typename X> typename MediaElement_statics<X>::_BufferingProgressProperty MediaElement_statics<X>::BufferingProgressProperty;
template<typename X> typename MediaElement_statics<X>::_CanPauseProperty MediaElement_statics<X>::CanPauseProperty;
template<typename X> typename MediaElement_statics<X>::_CanSeekProperty MediaElement_statics<X>::CanSeekProperty;
template<typename X> typename MediaElement_statics<X>::_CurrentStateProperty MediaElement_statics<X>::CurrentStateProperty;
template<typename X> typename MediaElement_statics<X>::_DefaultPlaybackRateProperty MediaElement_statics<X>::DefaultPlaybackRateProperty;
template<typename X> typename MediaElement_statics<X>::_DownloadProgressOffsetProperty MediaElement_statics<X>::DownloadProgressOffsetProperty;
template<typename X> typename MediaElement_statics<X>::_DownloadProgressProperty MediaElement_statics<X>::DownloadProgressProperty;
template<typename X> typename MediaElement_statics<X>::_IsAudioOnlyProperty MediaElement_statics<X>::IsAudioOnlyProperty;
template<typename X> typename MediaElement_statics<X>::_IsLoopingProperty MediaElement_statics<X>::IsLoopingProperty;
template<typename X> typename MediaElement_statics<X>::_IsMutedProperty MediaElement_statics<X>::IsMutedProperty;
template<typename X> typename MediaElement_statics<X>::_IsStereo3DVideoProperty MediaElement_statics<X>::IsStereo3DVideoProperty;
template<typename X> typename MediaElement_statics<X>::_NaturalDurationProperty MediaElement_statics<X>::NaturalDurationProperty;
template<typename X> typename MediaElement_statics<X>::_NaturalVideoHeightProperty MediaElement_statics<X>::NaturalVideoHeightProperty;
template<typename X> typename MediaElement_statics<X>::_NaturalVideoWidthProperty MediaElement_statics<X>::NaturalVideoWidthProperty;
template<typename X> typename MediaElement_statics<X>::_PlayToSourceProperty MediaElement_statics<X>::PlayToSourceProperty;
template<typename X> typename MediaElement_statics<X>::_PlaybackRateProperty MediaElement_statics<X>::PlaybackRateProperty;
template<typename X> typename MediaElement_statics<X>::_PositionProperty MediaElement_statics<X>::PositionProperty;
template<typename X> typename MediaElement_statics<X>::_PosterSourceProperty MediaElement_statics<X>::PosterSourceProperty;
template<typename X> typename MediaElement_statics<X>::_ProtectionManagerProperty MediaElement_statics<X>::ProtectionManagerProperty;
template<typename X> typename MediaElement_statics<X>::_RealTimePlaybackProperty MediaElement_statics<X>::RealTimePlaybackProperty;
template<typename X> typename MediaElement_statics<X>::_SourceProperty MediaElement_statics<X>::SourceProperty;
template<typename X> typename MediaElement_statics<X>::_Stereo3DVideoPackingModeProperty MediaElement_statics<X>::Stereo3DVideoPackingModeProperty;
template<typename X> typename MediaElement_statics<X>::_Stereo3DVideoRenderModeProperty MediaElement_statics<X>::Stereo3DVideoRenderModeProperty;
template<typename X> typename MediaElement_statics<X>::_VolumeProperty MediaElement_statics<X>::VolumeProperty;
template<typename X> typename MediaElement_statics<X>::_AreTransportControlsEnabledProperty MediaElement_statics<X>::AreTransportControlsEnabledProperty;
template<typename X> typename MediaElement_statics<X>::_IsFullWindowProperty MediaElement_statics<X>::IsFullWindowProperty;
template<typename X> typename MediaElement_statics<X>::_PlayToPreferredSourceUriProperty MediaElement_statics<X>::PlayToPreferredSourceUriProperty;
template<typename X> typename MediaElement_statics<X>::_StretchProperty MediaElement_statics<X>::StretchProperty;

template<typename X> struct statics<MediaElement, X> : X, Windows::UI::Xaml::Controls::MediaElement_statics<void> {
	typedef typename X::root_type MediaElement;
};
struct MediaElement : generate<MediaElement> {};

// MediaPlayerPresenter
template<typename> struct MediaPlayerPresenter_statics {
	static struct _IsFullWindowProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaPlayerPresenter, IMediaPlayerPresenterStatics>()->_get_IsFullWindowProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsFullWindowProperty;
	static struct _MediaPlayerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaPlayerPresenter, IMediaPlayerPresenterStatics>()->_get_MediaPlayerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MediaPlayerProperty;
	static struct _StretchProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaPlayerPresenter, IMediaPlayerPresenterStatics>()->_get_StretchProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StretchProperty;
	static MediaPlayerPresenter *activate(object_ref outer, IInspectable* *inner) { MediaPlayerPresenter *instance; hrcheck(get_activation_factory<MediaPlayerPresenter, IMediaPlayerPresenterFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename MediaPlayerPresenter_statics<X>::_IsFullWindowProperty MediaPlayerPresenter_statics<X>::IsFullWindowProperty;
template<typename X> typename MediaPlayerPresenter_statics<X>::_MediaPlayerProperty MediaPlayerPresenter_statics<X>::MediaPlayerProperty;
template<typename X> typename MediaPlayerPresenter_statics<X>::_StretchProperty MediaPlayerPresenter_statics<X>::StretchProperty;

template<typename X> struct statics<MediaPlayerPresenter, X> : X, Windows::UI::Xaml::Controls::MediaPlayerPresenter_statics<void> {
	using Windows::UI::Xaml::Controls::MediaPlayerPresenter_statics<void>::activate;
	typedef typename X::root_type MediaPlayerPresenter;
};
struct MediaPlayerPresenter : generate<MediaPlayerPresenter> {};

// WebView
template<typename> struct WebView_statics {
	static struct _AllowedScriptNotifyUrisProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WebView, IWebViewStatics>()->_get_AllowedScriptNotifyUrisProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AllowedScriptNotifyUrisProperty;
	static struct _AnyScriptNotifyUri : property {
		ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> get() { Foundation::Collections::IVector<Foundation::Uri*>* value; hrcheck(get_activation_factory<WebView, IWebViewStatics>()->_get_AnyScriptNotifyUri(&value)); return from_abi(value); }
		ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> operator()() { return get(); }
		operator ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> () { return get(); }
		ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> operator->() { return get(); }
	} AnyScriptNotifyUri;
	static struct _DataTransferPackageProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WebView, IWebViewStatics>()->_get_DataTransferPackageProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DataTransferPackageProperty;
	static struct _SourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WebView, IWebViewStatics>()->_get_SourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SourceProperty;
	static struct _CanGoBackProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WebView, IWebViewStatics2>()->_get_CanGoBackProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CanGoBackProperty;
	static struct _CanGoForwardProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WebView, IWebViewStatics2>()->_get_CanGoForwardProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CanGoForwardProperty;
	static struct _DefaultBackgroundColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WebView, IWebViewStatics2>()->_get_DefaultBackgroundColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DefaultBackgroundColorProperty;
	static struct _DocumentTitleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WebView, IWebViewStatics2>()->_get_DocumentTitleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DocumentTitleProperty;
	static struct _ContainsFullScreenElementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WebView, IWebViewStatics3>()->_get_ContainsFullScreenElementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContainsFullScreenElementProperty;
	static struct _DefaultExecutionMode : property {
		WebViewExecutionMode get() { WebViewExecutionMode value; hrcheck(get_activation_factory<WebView, IWebViewStatics4>()->_get_DefaultExecutionMode(&value)); return value; }
		WebViewExecutionMode operator()() { return get(); }
		operator WebViewExecutionMode () { return get(); }
	} DefaultExecutionMode;
	static struct _XYFocusDownProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WebView, IWebViewStatics5>()->_get_XYFocusDownProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} XYFocusDownProperty;
	static struct _XYFocusLeftProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WebView, IWebViewStatics5>()->_get_XYFocusLeftProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} XYFocusLeftProperty;
	static struct _XYFocusRightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WebView, IWebViewStatics5>()->_get_XYFocusRightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} XYFocusRightProperty;
	static struct _XYFocusUpProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WebView, IWebViewStatics5>()->_get_XYFocusUpProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} XYFocusUpProperty;
	static ptr<Foundation::IAsyncAction> ClearTemporaryWebDataAsync() { Foundation::IAsyncAction* returnValue; hrcheck(get_activation_factory<WebView, IWebViewStatics4>()->_ClearTemporaryWebDataAsync(&returnValue)); return from_abi(returnValue); }
	static WebView *activate(WebViewExecutionMode executionMode) { WebView *instance; hrcheck(get_activation_factory<WebView, IWebViewFactory4>()->_CreateInstanceWithExecutionMode(executionMode, &instance)); return instance; }
	static WebView *activate() { WebView *t; get_activation_factory<WebView>()->ActivateInstance((IInspectable**)&t); return t; }
};
template<typename X> typename WebView_statics<X>::_AllowedScriptNotifyUrisProperty WebView_statics<X>::AllowedScriptNotifyUrisProperty;
template<typename X> typename WebView_statics<X>::_AnyScriptNotifyUri WebView_statics<X>::AnyScriptNotifyUri;
template<typename X> typename WebView_statics<X>::_DataTransferPackageProperty WebView_statics<X>::DataTransferPackageProperty;
template<typename X> typename WebView_statics<X>::_SourceProperty WebView_statics<X>::SourceProperty;
template<typename X> typename WebView_statics<X>::_CanGoBackProperty WebView_statics<X>::CanGoBackProperty;
template<typename X> typename WebView_statics<X>::_CanGoForwardProperty WebView_statics<X>::CanGoForwardProperty;
template<typename X> typename WebView_statics<X>::_DefaultBackgroundColorProperty WebView_statics<X>::DefaultBackgroundColorProperty;
template<typename X> typename WebView_statics<X>::_DocumentTitleProperty WebView_statics<X>::DocumentTitleProperty;
template<typename X> typename WebView_statics<X>::_ContainsFullScreenElementProperty WebView_statics<X>::ContainsFullScreenElementProperty;
template<typename X> typename WebView_statics<X>::_DefaultExecutionMode WebView_statics<X>::DefaultExecutionMode;
template<typename X> typename WebView_statics<X>::_XYFocusDownProperty WebView_statics<X>::XYFocusDownProperty;
template<typename X> typename WebView_statics<X>::_XYFocusLeftProperty WebView_statics<X>::XYFocusLeftProperty;
template<typename X> typename WebView_statics<X>::_XYFocusRightProperty WebView_statics<X>::XYFocusRightProperty;
template<typename X> typename WebView_statics<X>::_XYFocusUpProperty WebView_statics<X>::XYFocusUpProperty;

template<typename X> struct statics<WebView, X> : X, Windows::UI::Xaml::Controls::WebView_statics<void> {
	using Windows::UI::Xaml::Controls::WebView_statics<void>::activate;
	typedef typename X::root_type WebView;
};
struct WebView : generate<WebView> {};

// BitmapIcon
template<typename> struct BitmapIcon_statics {
	static struct _UriSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BitmapIcon, IBitmapIconStatics>()->_get_UriSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} UriSourceProperty;
	static struct _ShowAsMonochromeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<BitmapIcon, IBitmapIconStatics2>()->_get_ShowAsMonochromeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ShowAsMonochromeProperty;
	static BitmapIcon *activate(object_ref outer, IInspectable* *inner) { BitmapIcon *instance; hrcheck(get_activation_factory<BitmapIcon, IBitmapIconFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename BitmapIcon_statics<X>::_UriSourceProperty BitmapIcon_statics<X>::UriSourceProperty;
template<typename X> typename BitmapIcon_statics<X>::_ShowAsMonochromeProperty BitmapIcon_statics<X>::ShowAsMonochromeProperty;

template<typename X> struct statics<BitmapIcon, X> : X, Windows::UI::Xaml::Controls::BitmapIcon_statics<void> {
	using Windows::UI::Xaml::Controls::BitmapIcon_statics<void>::activate;
	typedef typename X::root_type BitmapIcon;
};
struct BitmapIcon : generate<BitmapIcon> {};

// FontIcon
template<typename> struct FontIcon_statics {
	static struct _FontFamilyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FontIcon, IFontIconStatics>()->_get_FontFamilyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontFamilyProperty;
	static struct _FontSizeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FontIcon, IFontIconStatics>()->_get_FontSizeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontSizeProperty;
	static struct _FontStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FontIcon, IFontIconStatics>()->_get_FontStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontStyleProperty;
	static struct _FontWeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FontIcon, IFontIconStatics>()->_get_FontWeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FontWeightProperty;
	static struct _GlyphProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FontIcon, IFontIconStatics>()->_get_GlyphProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GlyphProperty;
	static struct _IsTextScaleFactorEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FontIcon, IFontIconStatics2>()->_get_IsTextScaleFactorEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTextScaleFactorEnabledProperty;
	static struct _MirroredWhenRightToLeftProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FontIcon, IFontIconStatics3>()->_get_MirroredWhenRightToLeftProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MirroredWhenRightToLeftProperty;
	static FontIcon *activate(object_ref outer, IInspectable* *inner) { FontIcon *instance; hrcheck(get_activation_factory<FontIcon, IFontIconFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename FontIcon_statics<X>::_FontFamilyProperty FontIcon_statics<X>::FontFamilyProperty;
template<typename X> typename FontIcon_statics<X>::_FontSizeProperty FontIcon_statics<X>::FontSizeProperty;
template<typename X> typename FontIcon_statics<X>::_FontStyleProperty FontIcon_statics<X>::FontStyleProperty;
template<typename X> typename FontIcon_statics<X>::_FontWeightProperty FontIcon_statics<X>::FontWeightProperty;
template<typename X> typename FontIcon_statics<X>::_GlyphProperty FontIcon_statics<X>::GlyphProperty;
template<typename X> typename FontIcon_statics<X>::_IsTextScaleFactorEnabledProperty FontIcon_statics<X>::IsTextScaleFactorEnabledProperty;
template<typename X> typename FontIcon_statics<X>::_MirroredWhenRightToLeftProperty FontIcon_statics<X>::MirroredWhenRightToLeftProperty;

template<typename X> struct statics<FontIcon, X> : X, Windows::UI::Xaml::Controls::FontIcon_statics<void> {
	using Windows::UI::Xaml::Controls::FontIcon_statics<void>::activate;
	typedef typename X::root_type FontIcon;
};
struct FontIcon : generate<FontIcon> {};

// ItemsStackPanel
template<typename> struct ItemsStackPanel_statics {
	static struct _CacheLengthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsStackPanel, IItemsStackPanelStatics>()->_get_CacheLengthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CacheLengthProperty;
	static struct _GroupHeaderPlacementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsStackPanel, IItemsStackPanelStatics>()->_get_GroupHeaderPlacementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GroupHeaderPlacementProperty;
	static struct _GroupPaddingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsStackPanel, IItemsStackPanelStatics>()->_get_GroupPaddingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GroupPaddingProperty;
	static struct _OrientationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsStackPanel, IItemsStackPanelStatics>()->_get_OrientationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OrientationProperty;
	static struct _AreStickyGroupHeadersEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsStackPanel, IItemsStackPanelStatics2>()->_get_AreStickyGroupHeadersEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AreStickyGroupHeadersEnabledProperty;
};
template<typename X> typename ItemsStackPanel_statics<X>::_CacheLengthProperty ItemsStackPanel_statics<X>::CacheLengthProperty;
template<typename X> typename ItemsStackPanel_statics<X>::_GroupHeaderPlacementProperty ItemsStackPanel_statics<X>::GroupHeaderPlacementProperty;
template<typename X> typename ItemsStackPanel_statics<X>::_GroupPaddingProperty ItemsStackPanel_statics<X>::GroupPaddingProperty;
template<typename X> typename ItemsStackPanel_statics<X>::_OrientationProperty ItemsStackPanel_statics<X>::OrientationProperty;
template<typename X> typename ItemsStackPanel_statics<X>::_AreStickyGroupHeadersEnabledProperty ItemsStackPanel_statics<X>::AreStickyGroupHeadersEnabledProperty;

template<typename X> struct statics<ItemsStackPanel, X> : X, Windows::UI::Xaml::Controls::ItemsStackPanel_statics<void> {
	typedef typename X::root_type ItemsStackPanel;
};
struct ItemsStackPanel : generate<ItemsStackPanel> {};

// ItemsWrapGrid
template<typename> struct ItemsWrapGrid_statics {
	static struct _CacheLengthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsWrapGrid, IItemsWrapGridStatics>()->_get_CacheLengthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CacheLengthProperty;
	static struct _GroupHeaderPlacementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsWrapGrid, IItemsWrapGridStatics>()->_get_GroupHeaderPlacementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GroupHeaderPlacementProperty;
	static struct _GroupPaddingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsWrapGrid, IItemsWrapGridStatics>()->_get_GroupPaddingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GroupPaddingProperty;
	static struct _ItemHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsWrapGrid, IItemsWrapGridStatics>()->_get_ItemHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemHeightProperty;
	static struct _ItemWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsWrapGrid, IItemsWrapGridStatics>()->_get_ItemWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemWidthProperty;
	static struct _MaximumRowsOrColumnsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsWrapGrid, IItemsWrapGridStatics>()->_get_MaximumRowsOrColumnsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaximumRowsOrColumnsProperty;
	static struct _OrientationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsWrapGrid, IItemsWrapGridStatics>()->_get_OrientationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OrientationProperty;
	static struct _AreStickyGroupHeadersEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ItemsWrapGrid, IItemsWrapGridStatics2>()->_get_AreStickyGroupHeadersEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AreStickyGroupHeadersEnabledProperty;
};
template<typename X> typename ItemsWrapGrid_statics<X>::_CacheLengthProperty ItemsWrapGrid_statics<X>::CacheLengthProperty;
template<typename X> typename ItemsWrapGrid_statics<X>::_GroupHeaderPlacementProperty ItemsWrapGrid_statics<X>::GroupHeaderPlacementProperty;
template<typename X> typename ItemsWrapGrid_statics<X>::_GroupPaddingProperty ItemsWrapGrid_statics<X>::GroupPaddingProperty;
template<typename X> typename ItemsWrapGrid_statics<X>::_ItemHeightProperty ItemsWrapGrid_statics<X>::ItemHeightProperty;
template<typename X> typename ItemsWrapGrid_statics<X>::_ItemWidthProperty ItemsWrapGrid_statics<X>::ItemWidthProperty;
template<typename X> typename ItemsWrapGrid_statics<X>::_MaximumRowsOrColumnsProperty ItemsWrapGrid_statics<X>::MaximumRowsOrColumnsProperty;
template<typename X> typename ItemsWrapGrid_statics<X>::_OrientationProperty ItemsWrapGrid_statics<X>::OrientationProperty;
template<typename X> typename ItemsWrapGrid_statics<X>::_AreStickyGroupHeadersEnabledProperty ItemsWrapGrid_statics<X>::AreStickyGroupHeadersEnabledProperty;

template<typename X> struct statics<ItemsWrapGrid, X> : X, Windows::UI::Xaml::Controls::ItemsWrapGrid_statics<void> {
	typedef typename X::root_type ItemsWrapGrid;
};
struct ItemsWrapGrid : generate<ItemsWrapGrid> {};

// PathIcon
template<typename> struct PathIcon_statics {
	static struct _DataProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PathIcon, IPathIconStatics>()->_get_DataProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DataProperty;
	static PathIcon *activate(object_ref outer, IInspectable* *inner) { PathIcon *instance; hrcheck(get_activation_factory<PathIcon, IPathIconFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename PathIcon_statics<X>::_DataProperty PathIcon_statics<X>::DataProperty;

template<typename X> struct statics<PathIcon, X> : X, Windows::UI::Xaml::Controls::PathIcon_statics<void> {
	using Windows::UI::Xaml::Controls::PathIcon_statics<void>::activate;
	typedef typename X::root_type PathIcon;
};
struct PathIcon : generate<PathIcon> {};

// ScrollContentPresenter
template<typename X> struct statics<ScrollContentPresenter, X> : X {
	typedef typename X::root_type ScrollContentPresenter;
};
struct ScrollContentPresenter : generate<ScrollContentPresenter> {};

// SymbolIcon
template<typename> struct SymbolIcon_statics {
	static struct _SymbolProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SymbolIcon, ISymbolIconStatics>()->_get_SymbolProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SymbolProperty;
	static SymbolIcon *activate() { SymbolIcon *t; get_activation_factory<SymbolIcon>()->ActivateInstance((IInspectable**)&t); return t; }
	static SymbolIcon *activate(Controls::Symbol symbol) { SymbolIcon *instance; hrcheck(get_activation_factory<SymbolIcon, ISymbolIconFactory>()->_CreateInstanceWithSymbol(symbol, &instance)); return instance; }
};
template<typename X> typename SymbolIcon_statics<X>::_SymbolProperty SymbolIcon_statics<X>::SymbolProperty;

template<typename X> struct statics<SymbolIcon, X> : X, Windows::UI::Xaml::Controls::SymbolIcon_statics<void> {
	using Windows::UI::Xaml::Controls::SymbolIcon_statics<void>::activate;
	typedef typename X::root_type SymbolIcon;
};
struct SymbolIcon : generate<SymbolIcon> {};

// SwapChainBackgroundPanel
template<typename> struct SwapChainBackgroundPanel_statics {
	static SwapChainBackgroundPanel *activate(object_ref outer, IInspectable* *inner) { SwapChainBackgroundPanel *instance; hrcheck(get_activation_factory<SwapChainBackgroundPanel, ISwapChainBackgroundPanelFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<SwapChainBackgroundPanel, X> : X, Windows::UI::Xaml::Controls::SwapChainBackgroundPanel_statics<void> {
	using Windows::UI::Xaml::Controls::SwapChainBackgroundPanel_statics<void>::activate;
	typedef typename X::root_type SwapChainBackgroundPanel;
};
struct SwapChainBackgroundPanel : generate<SwapChainBackgroundPanel> {};

// SwapChainPanel
template<typename> struct SwapChainPanel_statics {
	static struct _CompositionScaleXProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwapChainPanel, ISwapChainPanelStatics>()->_get_CompositionScaleXProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CompositionScaleXProperty;
	static struct _CompositionScaleYProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwapChainPanel, ISwapChainPanelStatics>()->_get_CompositionScaleYProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CompositionScaleYProperty;
	static SwapChainPanel *activate(object_ref outer, IInspectable* *inner) { SwapChainPanel *instance; hrcheck(get_activation_factory<SwapChainPanel, ISwapChainPanelFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename SwapChainPanel_statics<X>::_CompositionScaleXProperty SwapChainPanel_statics<X>::CompositionScaleXProperty;
template<typename X> typename SwapChainPanel_statics<X>::_CompositionScaleYProperty SwapChainPanel_statics<X>::CompositionScaleYProperty;

template<typename X> struct statics<SwapChainPanel, X> : X, Windows::UI::Xaml::Controls::SwapChainPanel_statics<void> {
	using Windows::UI::Xaml::Controls::SwapChainPanel_statics<void>::activate;
	typedef typename X::root_type SwapChainPanel;
};
struct SwapChainPanel : generate<SwapChainPanel> {};

// WrapGrid
template<typename> struct WrapGrid_statics {
	static struct _HorizontalChildrenAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WrapGrid, IWrapGridStatics>()->_get_HorizontalChildrenAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalChildrenAlignmentProperty;
	static struct _ItemHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WrapGrid, IWrapGridStatics>()->_get_ItemHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemHeightProperty;
	static struct _ItemWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WrapGrid, IWrapGridStatics>()->_get_ItemWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemWidthProperty;
	static struct _MaximumRowsOrColumnsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WrapGrid, IWrapGridStatics>()->_get_MaximumRowsOrColumnsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaximumRowsOrColumnsProperty;
	static struct _OrientationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WrapGrid, IWrapGridStatics>()->_get_OrientationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OrientationProperty;
	static struct _VerticalChildrenAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WrapGrid, IWrapGridStatics>()->_get_VerticalChildrenAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalChildrenAlignmentProperty;
};
template<typename X> typename WrapGrid_statics<X>::_HorizontalChildrenAlignmentProperty WrapGrid_statics<X>::HorizontalChildrenAlignmentProperty;
template<typename X> typename WrapGrid_statics<X>::_ItemHeightProperty WrapGrid_statics<X>::ItemHeightProperty;
template<typename X> typename WrapGrid_statics<X>::_ItemWidthProperty WrapGrid_statics<X>::ItemWidthProperty;
template<typename X> typename WrapGrid_statics<X>::_MaximumRowsOrColumnsProperty WrapGrid_statics<X>::MaximumRowsOrColumnsProperty;
template<typename X> typename WrapGrid_statics<X>::_OrientationProperty WrapGrid_statics<X>::OrientationProperty;
template<typename X> typename WrapGrid_statics<X>::_VerticalChildrenAlignmentProperty WrapGrid_statics<X>::VerticalChildrenAlignmentProperty;

template<typename X> struct statics<WrapGrid, X> : X, Windows::UI::Xaml::Controls::WrapGrid_statics<void> {
	typedef typename X::root_type WrapGrid;
};
struct WrapGrid : generate<WrapGrid> {};

// IUIElementCollection
struct IUIElementCollection_raw : IInspectable {
	virtual STDMETHODIMP _Move(unsigned oldIndex, unsigned newIndex);
};
template<typename X> struct IUIElementCollection_adaptor : X {
	void Move(unsigned oldIndex, unsigned newIndex) { hrcheck(X::get()->_Move(oldIndex, newIndex)); }
};
template<typename X> struct adapt<IUIElementCollection, X> : Windows::UI::Xaml::Controls::IUIElementCollection_adaptor<X> { typedef adapt IUIElementCollection; };
struct IUIElementCollection : IUIElementCollection_raw, generate<IUIElementCollection> {};

// UIElementCollection
template<typename X> struct statics<UIElementCollection, X> : X {
	typedef typename X::root_type UIElementCollection;
};
struct UIElementCollection : generate<UIElementCollection> {};

// IFocusDisengagedEventArgs
struct IFocusDisengagedEventArgs : IInspectable, generate<IFocusDisengagedEventArgs> {};

// FocusDisengagedEventArgs
template<typename X> struct statics<FocusDisengagedEventArgs, X> : X {
	typedef typename X::root_type FocusDisengagedEventArgs;
};
struct FocusDisengagedEventArgs : generate<FocusDisengagedEventArgs> {};

// IFocusEngagedEventArgs
struct IFocusEngagedEventArgs : IInspectable, generate<IFocusEngagedEventArgs> {};

// IFocusEngagedEventArgs2
struct IFocusEngagedEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _get_Handled(bool *value);
	virtual STDMETHODIMP _put_Handled(bool value);
};
template<typename X> struct IFocusEngagedEventArgs2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IFocusEngagedEventArgs2_adaptor::Handled)->_get_Handled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IFocusEngagedEventArgs2_adaptor::Handled)->_put_Handled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Handled;
	};
	IFocusEngagedEventArgs2_adaptor() {}
};
template<typename X> struct adapt<IFocusEngagedEventArgs2, X> : Windows::UI::Xaml::Controls::IFocusEngagedEventArgs2_adaptor<X> { typedef adapt IFocusEngagedEventArgs2; };
struct IFocusEngagedEventArgs2 : IFocusEngagedEventArgs2_raw, generate<IFocusEngagedEventArgs2> {};

// FocusEngagedEventArgs
template<typename X> struct statics<FocusEngagedEventArgs, X> : X {
	typedef typename X::root_type FocusEngagedEventArgs;
};
struct FocusEngagedEventArgs : generate<FocusEngagedEventArgs> {};

// IControlTemplate
struct IControlTemplate_raw : IInspectable {
	virtual STDMETHODIMP _get_TargetType(Interop::TypeName *value);
	virtual STDMETHODIMP _put_TargetType(Interop::TypeName value);
};
template<typename X> struct IControlTemplate_adaptor : X {
	union {
		struct : property {
			Interop::TypeName get() { Interop::TypeName value; hrcheck(enc(&IControlTemplate_adaptor::TargetType)->_get_TargetType(&value)); return value; }
			Interop::TypeName operator()() { return get(); }
			operator Interop::TypeName () { return get(); }
			void put(const Interop::TypeName& value) { hrcheck(enc(&IControlTemplate_adaptor::TargetType)->_put_TargetType(value)); }
			void operator=(const Interop::TypeName& value) { put(value); }
			void operator()(const Interop::TypeName& value) { put(value); }
		} TargetType;
	};
	IControlTemplate_adaptor() {}
};
template<typename X> struct adapt<IControlTemplate, X> : Windows::UI::Xaml::Controls::IControlTemplate_adaptor<X> { typedef adapt IControlTemplate; };
struct IControlTemplate : IControlTemplate_raw, generate<IControlTemplate> {};

// ControlTemplate
template<typename X> struct statics<ControlTemplate, X> : X {
	typedef typename X::root_type ControlTemplate;
};
struct ControlTemplate : generate<ControlTemplate> {};

// IColorPickerFactory
struct IColorPickerFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, ColorPicker* *instance);
};

// IColorPickerStatics
struct IColorPickerStatics : IInspectable {
	virtual STDMETHODIMP _get_ColorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PreviousColorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsAlphaEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsColorSpectrumVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsColorPreviewVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsColorSliderVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsAlphaSliderVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsMoreButtonVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsColorChannelTextInputVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsAlphaTextInputVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsHexInputVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinHueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxHueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinSaturationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxSaturationProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinValueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxValueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ColorSpectrumShapeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ColorSpectrumComponentsProperty(DependencyProperty* *value);
};

// IColorPicker
struct IColorPicker_raw : IInspectable {
	virtual STDMETHODIMP _get_Color(UI::Color *result);
	virtual STDMETHODIMP _put_Color(UI::Color value);
	virtual STDMETHODIMP _get_PreviousColor(Foundation::IReference<UI::Color>* *result);
	virtual STDMETHODIMP _put_PreviousColor(Foundation::IReference<UI::Color>* value);
	virtual STDMETHODIMP _get_IsAlphaEnabled(bool *result);
	virtual STDMETHODIMP _put_IsAlphaEnabled(bool value);
	virtual STDMETHODIMP _get_IsColorSpectrumVisible(bool *result);
	virtual STDMETHODIMP _put_IsColorSpectrumVisible(bool value);
	virtual STDMETHODIMP _get_IsColorPreviewVisible(bool *result);
	virtual STDMETHODIMP _put_IsColorPreviewVisible(bool value);
	virtual STDMETHODIMP _get_IsColorSliderVisible(bool *result);
	virtual STDMETHODIMP _put_IsColorSliderVisible(bool value);
	virtual STDMETHODIMP _get_IsAlphaSliderVisible(bool *result);
	virtual STDMETHODIMP _put_IsAlphaSliderVisible(bool value);
	virtual STDMETHODIMP _get_IsMoreButtonVisible(bool *result);
	virtual STDMETHODIMP _put_IsMoreButtonVisible(bool value);
	virtual STDMETHODIMP _get_IsColorChannelTextInputVisible(bool *result);
	virtual STDMETHODIMP _put_IsColorChannelTextInputVisible(bool value);
	virtual STDMETHODIMP _get_IsAlphaTextInputVisible(bool *result);
	virtual STDMETHODIMP _put_IsAlphaTextInputVisible(bool value);
	virtual STDMETHODIMP _get_IsHexInputVisible(bool *result);
	virtual STDMETHODIMP _put_IsHexInputVisible(bool value);
	virtual STDMETHODIMP _get_MinHue(int *result);
	virtual STDMETHODIMP _put_MinHue(int value);
	virtual STDMETHODIMP _get_MaxHue(int *result);
	virtual STDMETHODIMP _put_MaxHue(int value);
	virtual STDMETHODIMP _get_MinSaturation(int *result);
	virtual STDMETHODIMP _put_MinSaturation(int value);
	virtual STDMETHODIMP _get_MaxSaturation(int *result);
	virtual STDMETHODIMP _put_MaxSaturation(int value);
	virtual STDMETHODIMP _get_MinValue(int *result);
	virtual STDMETHODIMP _put_MinValue(int value);
	virtual STDMETHODIMP _get_MaxValue(int *result);
	virtual STDMETHODIMP _put_MaxValue(int value);
	virtual STDMETHODIMP _get_ColorSpectrumShape(Controls::ColorSpectrumShape *result);
	virtual STDMETHODIMP _put_ColorSpectrumShape(Controls::ColorSpectrumShape value);
	virtual STDMETHODIMP _get_ColorSpectrumComponents(Controls::ColorSpectrumComponents *result);
	virtual STDMETHODIMP _put_ColorSpectrumComponents(Controls::ColorSpectrumComponents value);
	virtual STDMETHODIMP _add_ColorChanged(Foundation::TypedEventHandler<ColorPicker*, ColorChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ColorChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IColorPicker_adaptor : X {
	union {
		struct : property {
			UI::Color get() { UI::Color result; hrcheck(enc(&IColorPicker_adaptor::Color)->_get_Color(&result)); return result; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IColorPicker_adaptor::Color)->_put_Color(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} Color;
		struct : property {
			Controls::ColorSpectrumComponents get() { Controls::ColorSpectrumComponents result; hrcheck(enc(&IColorPicker_adaptor::ColorSpectrumComponents)->_get_ColorSpectrumComponents(&result)); return result; }
			Controls::ColorSpectrumComponents operator()() { return get(); }
			operator Controls::ColorSpectrumComponents () { return get(); }
			void put(Controls::ColorSpectrumComponents value) { hrcheck(enc(&IColorPicker_adaptor::ColorSpectrumComponents)->_put_ColorSpectrumComponents(value)); }
			void operator=(Controls::ColorSpectrumComponents value) { put(value); }
			void operator()(Controls::ColorSpectrumComponents value) { put(value); }
		} ColorSpectrumComponents;
		struct : property {
			Controls::ColorSpectrumShape get() { Controls::ColorSpectrumShape result; hrcheck(enc(&IColorPicker_adaptor::ColorSpectrumShape)->_get_ColorSpectrumShape(&result)); return result; }
			Controls::ColorSpectrumShape operator()() { return get(); }
			operator Controls::ColorSpectrumShape () { return get(); }
			void put(Controls::ColorSpectrumShape value) { hrcheck(enc(&IColorPicker_adaptor::ColorSpectrumShape)->_put_ColorSpectrumShape(value)); }
			void operator=(Controls::ColorSpectrumShape value) { put(value); }
			void operator()(Controls::ColorSpectrumShape value) { put(value); }
		} ColorSpectrumShape;
		struct : property {
			bool get() { bool result; hrcheck(enc(&IColorPicker_adaptor::IsAlphaEnabled)->_get_IsAlphaEnabled(&result)); return result; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IColorPicker_adaptor::IsAlphaEnabled)->_put_IsAlphaEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsAlphaEnabled;
		struct : property {
			bool get() { bool result; hrcheck(enc(&IColorPicker_adaptor::IsAlphaSliderVisible)->_get_IsAlphaSliderVisible(&result)); return result; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IColorPicker_adaptor::IsAlphaSliderVisible)->_put_IsAlphaSliderVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsAlphaSliderVisible;
		struct : property {
			bool get() { bool result; hrcheck(enc(&IColorPicker_adaptor::IsAlphaTextInputVisible)->_get_IsAlphaTextInputVisible(&result)); return result; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IColorPicker_adaptor::IsAlphaTextInputVisible)->_put_IsAlphaTextInputVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsAlphaTextInputVisible;
		struct : property {
			bool get() { bool result; hrcheck(enc(&IColorPicker_adaptor::IsColorChannelTextInputVisible)->_get_IsColorChannelTextInputVisible(&result)); return result; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IColorPicker_adaptor::IsColorChannelTextInputVisible)->_put_IsColorChannelTextInputVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsColorChannelTextInputVisible;
		struct : property {
			bool get() { bool result; hrcheck(enc(&IColorPicker_adaptor::IsColorPreviewVisible)->_get_IsColorPreviewVisible(&result)); return result; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IColorPicker_adaptor::IsColorPreviewVisible)->_put_IsColorPreviewVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsColorPreviewVisible;
		struct : property {
			bool get() { bool result; hrcheck(enc(&IColorPicker_adaptor::IsColorSliderVisible)->_get_IsColorSliderVisible(&result)); return result; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IColorPicker_adaptor::IsColorSliderVisible)->_put_IsColorSliderVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsColorSliderVisible;
		struct : property {
			bool get() { bool result; hrcheck(enc(&IColorPicker_adaptor::IsColorSpectrumVisible)->_get_IsColorSpectrumVisible(&result)); return result; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IColorPicker_adaptor::IsColorSpectrumVisible)->_put_IsColorSpectrumVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsColorSpectrumVisible;
		struct : property {
			bool get() { bool result; hrcheck(enc(&IColorPicker_adaptor::IsHexInputVisible)->_get_IsHexInputVisible(&result)); return result; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IColorPicker_adaptor::IsHexInputVisible)->_put_IsHexInputVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsHexInputVisible;
		struct : property {
			bool get() { bool result; hrcheck(enc(&IColorPicker_adaptor::IsMoreButtonVisible)->_get_IsMoreButtonVisible(&result)); return result; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IColorPicker_adaptor::IsMoreButtonVisible)->_put_IsMoreButtonVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsMoreButtonVisible;
		struct : property {
			int get() { int result; hrcheck(enc(&IColorPicker_adaptor::MaxHue)->_get_MaxHue(&result)); return result; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IColorPicker_adaptor::MaxHue)->_put_MaxHue(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaxHue;
		struct : property {
			int get() { int result; hrcheck(enc(&IColorPicker_adaptor::MaxSaturation)->_get_MaxSaturation(&result)); return result; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IColorPicker_adaptor::MaxSaturation)->_put_MaxSaturation(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaxSaturation;
		struct : property {
			int get() { int result; hrcheck(enc(&IColorPicker_adaptor::MaxValue)->_get_MaxValue(&result)); return result; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IColorPicker_adaptor::MaxValue)->_put_MaxValue(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaxValue;
		struct : property {
			int get() { int result; hrcheck(enc(&IColorPicker_adaptor::MinHue)->_get_MinHue(&result)); return result; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IColorPicker_adaptor::MinHue)->_put_MinHue(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MinHue;
		struct : property {
			int get() { int result; hrcheck(enc(&IColorPicker_adaptor::MinSaturation)->_get_MinSaturation(&result)); return result; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IColorPicker_adaptor::MinSaturation)->_put_MinSaturation(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MinSaturation;
		struct : property {
			int get() { int result; hrcheck(enc(&IColorPicker_adaptor::MinValue)->_get_MinValue(&result)); return result; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IColorPicker_adaptor::MinValue)->_put_MinValue(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MinValue;
		struct : property {
			ptr<Foundation::IReference<UI::Color>> get() { Foundation::IReference<UI::Color>* result; hrcheck(enc(&IColorPicker_adaptor::PreviousColor)->_get_PreviousColor(&result)); return from_abi(result); }
			ptr<Foundation::IReference<UI::Color>> operator()() { return get(); }
			operator ptr<Foundation::IReference<UI::Color>> () { return get(); }
			ptr<Foundation::IReference<UI::Color>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<UI::Color>> value) { hrcheck(enc(&IColorPicker_adaptor::PreviousColor)->_put_PreviousColor(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<UI::Color>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<UI::Color>> value) { put(to_abi(value)); }
		} PreviousColor;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ColorPicker>, ptr<ColorChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IColorPicker_adaptor::ColorChanged)->_add_ColorChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IColorPicker_adaptor::ColorChanged)->_remove_ColorChanged(token)); }
		} ColorChanged;
	};
	IColorPicker_adaptor() {}
};
template<typename X> struct adapt<IColorPicker, X> : Windows::UI::Xaml::Controls::IColorPicker_adaptor<X> { typedef adapt IColorPicker; };
struct IColorPicker : IColorPicker_raw, generate<IColorPicker> {};

// ColorPicker
template<typename> struct ColorPicker_statics {
	static struct _ColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_ColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ColorProperty;
	static struct _ColorSpectrumComponentsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_ColorSpectrumComponentsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ColorSpectrumComponentsProperty;
	static struct _ColorSpectrumShapeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_ColorSpectrumShapeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ColorSpectrumShapeProperty;
	static struct _IsAlphaEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_IsAlphaEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsAlphaEnabledProperty;
	static struct _IsAlphaSliderVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_IsAlphaSliderVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsAlphaSliderVisibleProperty;
	static struct _IsAlphaTextInputVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_IsAlphaTextInputVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsAlphaTextInputVisibleProperty;
	static struct _IsColorChannelTextInputVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_IsColorChannelTextInputVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsColorChannelTextInputVisibleProperty;
	static struct _IsColorPreviewVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_IsColorPreviewVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsColorPreviewVisibleProperty;
	static struct _IsColorSliderVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_IsColorSliderVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsColorSliderVisibleProperty;
	static struct _IsColorSpectrumVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_IsColorSpectrumVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsColorSpectrumVisibleProperty;
	static struct _IsHexInputVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_IsHexInputVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsHexInputVisibleProperty;
	static struct _IsMoreButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_IsMoreButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsMoreButtonVisibleProperty;
	static struct _MaxHueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_MaxHueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxHueProperty;
	static struct _MaxSaturationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_MaxSaturationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxSaturationProperty;
	static struct _MaxValueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_MaxValueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxValueProperty;
	static struct _MinHueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_MinHueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinHueProperty;
	static struct _MinSaturationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_MinSaturationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinSaturationProperty;
	static struct _MinValueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_MinValueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinValueProperty;
	static struct _PreviousColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ColorPicker, IColorPickerStatics>()->_get_PreviousColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PreviousColorProperty;
	static ColorPicker *activate(object_ref outer, IInspectable* *inner) { ColorPicker *instance; hrcheck(get_activation_factory<ColorPicker, IColorPickerFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename ColorPicker_statics<X>::_ColorProperty ColorPicker_statics<X>::ColorProperty;
template<typename X> typename ColorPicker_statics<X>::_ColorSpectrumComponentsProperty ColorPicker_statics<X>::ColorSpectrumComponentsProperty;
template<typename X> typename ColorPicker_statics<X>::_ColorSpectrumShapeProperty ColorPicker_statics<X>::ColorSpectrumShapeProperty;
template<typename X> typename ColorPicker_statics<X>::_IsAlphaEnabledProperty ColorPicker_statics<X>::IsAlphaEnabledProperty;
template<typename X> typename ColorPicker_statics<X>::_IsAlphaSliderVisibleProperty ColorPicker_statics<X>::IsAlphaSliderVisibleProperty;
template<typename X> typename ColorPicker_statics<X>::_IsAlphaTextInputVisibleProperty ColorPicker_statics<X>::IsAlphaTextInputVisibleProperty;
template<typename X> typename ColorPicker_statics<X>::_IsColorChannelTextInputVisibleProperty ColorPicker_statics<X>::IsColorChannelTextInputVisibleProperty;
template<typename X> typename ColorPicker_statics<X>::_IsColorPreviewVisibleProperty ColorPicker_statics<X>::IsColorPreviewVisibleProperty;
template<typename X> typename ColorPicker_statics<X>::_IsColorSliderVisibleProperty ColorPicker_statics<X>::IsColorSliderVisibleProperty;
template<typename X> typename ColorPicker_statics<X>::_IsColorSpectrumVisibleProperty ColorPicker_statics<X>::IsColorSpectrumVisibleProperty;
template<typename X> typename ColorPicker_statics<X>::_IsHexInputVisibleProperty ColorPicker_statics<X>::IsHexInputVisibleProperty;
template<typename X> typename ColorPicker_statics<X>::_IsMoreButtonVisibleProperty ColorPicker_statics<X>::IsMoreButtonVisibleProperty;
template<typename X> typename ColorPicker_statics<X>::_MaxHueProperty ColorPicker_statics<X>::MaxHueProperty;
template<typename X> typename ColorPicker_statics<X>::_MaxSaturationProperty ColorPicker_statics<X>::MaxSaturationProperty;
template<typename X> typename ColorPicker_statics<X>::_MaxValueProperty ColorPicker_statics<X>::MaxValueProperty;
template<typename X> typename ColorPicker_statics<X>::_MinHueProperty ColorPicker_statics<X>::MinHueProperty;
template<typename X> typename ColorPicker_statics<X>::_MinSaturationProperty ColorPicker_statics<X>::MinSaturationProperty;
template<typename X> typename ColorPicker_statics<X>::_MinValueProperty ColorPicker_statics<X>::MinValueProperty;
template<typename X> typename ColorPicker_statics<X>::_PreviousColorProperty ColorPicker_statics<X>::PreviousColorProperty;

template<typename X> struct statics<ColorPicker, X> : X, Windows::UI::Xaml::Controls::ColorPicker_statics<void> {
	using Windows::UI::Xaml::Controls::ColorPicker_statics<void>::activate;
	typedef typename X::root_type ColorPicker;
};
struct ColorPicker : generate<ColorPicker> {};

// IPersonPictureStatics
struct IPersonPictureStatics : IInspectable {
	virtual STDMETHODIMP _get_BadgeNumberProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BadgeGlyphProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BadgeImageSourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_BadgeTextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsGroupProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ContactProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DisplayNameProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_InitialsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PreferSmallImageProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ProfilePictureProperty(DependencyProperty* *value);
};

// IPersonPictureFactory
struct IPersonPictureFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, PersonPicture* *instance);
};

// IPersonPicture
struct IPersonPicture_raw : IInspectable {
	virtual STDMETHODIMP _get_BadgeNumber(int *value);
	virtual STDMETHODIMP _put_BadgeNumber(int value);
	virtual STDMETHODIMP _get_BadgeGlyph(HSTRING *value);
	virtual STDMETHODIMP _put_BadgeGlyph(HSTRING value);
	virtual STDMETHODIMP _get_BadgeImageSource(Media::ImageSource* *value);
	virtual STDMETHODIMP _put_BadgeImageSource(Media::ImageSource* value);
	virtual STDMETHODIMP _get_BadgeText(HSTRING *value);
	virtual STDMETHODIMP _put_BadgeText(HSTRING value);
	virtual STDMETHODIMP _get_IsGroup(bool *value);
	virtual STDMETHODIMP _put_IsGroup(bool value);
	virtual STDMETHODIMP _get_Contact(ApplicationModel::Contacts::Contact* *value);
	virtual STDMETHODIMP _put_Contact(ApplicationModel::Contacts::Contact* value);
	virtual STDMETHODIMP _get_DisplayName(HSTRING *value);
	virtual STDMETHODIMP _put_DisplayName(HSTRING value);
	virtual STDMETHODIMP _get_Initials(HSTRING *value);
	virtual STDMETHODIMP _put_Initials(HSTRING value);
	virtual STDMETHODIMP _get_PreferSmallImage(bool *value);
	virtual STDMETHODIMP _put_PreferSmallImage(bool value);
	virtual STDMETHODIMP _get_ProfilePicture(Media::ImageSource* *value);
	virtual STDMETHODIMP _put_ProfilePicture(Media::ImageSource* value);
};
template<typename X> struct IPersonPicture_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPersonPicture_adaptor::BadgeGlyph)->_get_BadgeGlyph(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPersonPicture_adaptor::BadgeGlyph)->_put_BadgeGlyph(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} BadgeGlyph;
		struct : property {
			ptr<Media::ImageSource> get() { Media::ImageSource* value; hrcheck(enc(&IPersonPicture_adaptor::BadgeImageSource)->_get_BadgeImageSource(&value)); return from_abi(value); }
			ptr<Media::ImageSource> operator()() { return get(); }
			operator ptr<Media::ImageSource> () { return get(); }
			ptr<Media::ImageSource> operator->() { return get(); }
			void put(pptr<Media::ImageSource> value) { hrcheck(enc(&IPersonPicture_adaptor::BadgeImageSource)->_put_BadgeImageSource(value)); }
			void operator=(pptr<Media::ImageSource> value) { put(value); }
			void operator()(pptr<Media::ImageSource> value) { put(value); }
		} BadgeImageSource;
		struct : property {
			int get() { int value; hrcheck(enc(&IPersonPicture_adaptor::BadgeNumber)->_get_BadgeNumber(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IPersonPicture_adaptor::BadgeNumber)->_put_BadgeNumber(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} BadgeNumber;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPersonPicture_adaptor::BadgeText)->_get_BadgeText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPersonPicture_adaptor::BadgeText)->_put_BadgeText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} BadgeText;
		struct : property {
			ptr<ApplicationModel::Contacts::Contact> get() { ApplicationModel::Contacts::Contact* value; hrcheck(enc(&IPersonPicture_adaptor::Contact)->_get_Contact(&value)); return from_abi(value); }
			ptr<ApplicationModel::Contacts::Contact> operator()() { return get(); }
			operator ptr<ApplicationModel::Contacts::Contact> () { return get(); }
			ptr<ApplicationModel::Contacts::Contact> operator->() { return get(); }
			void put(pptr<ApplicationModel::Contacts::Contact> value) { hrcheck(enc(&IPersonPicture_adaptor::Contact)->_put_Contact(value)); }
			void operator=(pptr<ApplicationModel::Contacts::Contact> value) { put(value); }
			void operator()(pptr<ApplicationModel::Contacts::Contact> value) { put(value); }
		} Contact;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPersonPicture_adaptor::DisplayName)->_get_DisplayName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPersonPicture_adaptor::DisplayName)->_put_DisplayName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DisplayName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPersonPicture_adaptor::Initials)->_get_Initials(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPersonPicture_adaptor::Initials)->_put_Initials(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Initials;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPersonPicture_adaptor::IsGroup)->_get_IsGroup(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IPersonPicture_adaptor::IsGroup)->_put_IsGroup(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsGroup;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPersonPicture_adaptor::PreferSmallImage)->_get_PreferSmallImage(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IPersonPicture_adaptor::PreferSmallImage)->_put_PreferSmallImage(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} PreferSmallImage;
		struct : property {
			ptr<Media::ImageSource> get() { Media::ImageSource* value; hrcheck(enc(&IPersonPicture_adaptor::ProfilePicture)->_get_ProfilePicture(&value)); return from_abi(value); }
			ptr<Media::ImageSource> operator()() { return get(); }
			operator ptr<Media::ImageSource> () { return get(); }
			ptr<Media::ImageSource> operator->() { return get(); }
			void put(pptr<Media::ImageSource> value) { hrcheck(enc(&IPersonPicture_adaptor::ProfilePicture)->_put_ProfilePicture(value)); }
			void operator=(pptr<Media::ImageSource> value) { put(value); }
			void operator()(pptr<Media::ImageSource> value) { put(value); }
		} ProfilePicture;
	};
	IPersonPicture_adaptor() {}
};
template<typename X> struct adapt<IPersonPicture, X> : Windows::UI::Xaml::Controls::IPersonPicture_adaptor<X> { typedef adapt IPersonPicture; };
struct IPersonPicture : IPersonPicture_raw, generate<IPersonPicture> {};

// PersonPicture
template<typename> struct PersonPicture_statics {
	static struct _BadgeGlyphProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PersonPicture, IPersonPictureStatics>()->_get_BadgeGlyphProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BadgeGlyphProperty;
	static struct _BadgeImageSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PersonPicture, IPersonPictureStatics>()->_get_BadgeImageSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BadgeImageSourceProperty;
	static struct _BadgeNumberProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PersonPicture, IPersonPictureStatics>()->_get_BadgeNumberProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BadgeNumberProperty;
	static struct _BadgeTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PersonPicture, IPersonPictureStatics>()->_get_BadgeTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BadgeTextProperty;
	static struct _ContactProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PersonPicture, IPersonPictureStatics>()->_get_ContactProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContactProperty;
	static struct _DisplayNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PersonPicture, IPersonPictureStatics>()->_get_DisplayNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DisplayNameProperty;
	static struct _InitialsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PersonPicture, IPersonPictureStatics>()->_get_InitialsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} InitialsProperty;
	static struct _IsGroupProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PersonPicture, IPersonPictureStatics>()->_get_IsGroupProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsGroupProperty;
	static struct _PreferSmallImageProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PersonPicture, IPersonPictureStatics>()->_get_PreferSmallImageProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PreferSmallImageProperty;
	static struct _ProfilePictureProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PersonPicture, IPersonPictureStatics>()->_get_ProfilePictureProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ProfilePictureProperty;
	static PersonPicture *activate(object_ref outer, IInspectable* *inner) { PersonPicture *instance; hrcheck(get_activation_factory<PersonPicture, IPersonPictureFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename PersonPicture_statics<X>::_BadgeGlyphProperty PersonPicture_statics<X>::BadgeGlyphProperty;
template<typename X> typename PersonPicture_statics<X>::_BadgeImageSourceProperty PersonPicture_statics<X>::BadgeImageSourceProperty;
template<typename X> typename PersonPicture_statics<X>::_BadgeNumberProperty PersonPicture_statics<X>::BadgeNumberProperty;
template<typename X> typename PersonPicture_statics<X>::_BadgeTextProperty PersonPicture_statics<X>::BadgeTextProperty;
template<typename X> typename PersonPicture_statics<X>::_ContactProperty PersonPicture_statics<X>::ContactProperty;
template<typename X> typename PersonPicture_statics<X>::_DisplayNameProperty PersonPicture_statics<X>::DisplayNameProperty;
template<typename X> typename PersonPicture_statics<X>::_InitialsProperty PersonPicture_statics<X>::InitialsProperty;
template<typename X> typename PersonPicture_statics<X>::_IsGroupProperty PersonPicture_statics<X>::IsGroupProperty;
template<typename X> typename PersonPicture_statics<X>::_PreferSmallImageProperty PersonPicture_statics<X>::PreferSmallImageProperty;
template<typename X> typename PersonPicture_statics<X>::_ProfilePictureProperty PersonPicture_statics<X>::ProfilePictureProperty;

template<typename X> struct statics<PersonPicture, X> : X, Windows::UI::Xaml::Controls::PersonPicture_statics<void> {
	using Windows::UI::Xaml::Controls::PersonPicture_statics<void>::activate;
	typedef typename X::root_type PersonPicture;
};
struct PersonPicture : generate<PersonPicture> {};

// RatingControl
template<typename> struct RatingControl_statics {
	static struct _CaptionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingControl, IRatingControlStatics>()->_get_CaptionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CaptionProperty;
	static struct _InitialSetValueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingControl, IRatingControlStatics>()->_get_InitialSetValueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} InitialSetValueProperty;
	static struct _IsClearEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingControl, IRatingControlStatics>()->_get_IsClearEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsClearEnabledProperty;
	static struct _IsReadOnlyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingControl, IRatingControlStatics>()->_get_IsReadOnlyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsReadOnlyProperty;
	static struct _ItemInfoProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingControl, IRatingControlStatics>()->_get_ItemInfoProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemInfoProperty;
	static struct _MaxRatingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingControl, IRatingControlStatics>()->_get_MaxRatingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxRatingProperty;
	static struct _PlaceholderValueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingControl, IRatingControlStatics>()->_get_PlaceholderValueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlaceholderValueProperty;
	static struct _ValueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RatingControl, IRatingControlStatics>()->_get_ValueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ValueProperty;
	static RatingControl *activate(object_ref outer, IInspectable* *inner) { RatingControl *instance; hrcheck(get_activation_factory<RatingControl, IRatingControlFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename RatingControl_statics<X>::_CaptionProperty RatingControl_statics<X>::CaptionProperty;
template<typename X> typename RatingControl_statics<X>::_InitialSetValueProperty RatingControl_statics<X>::InitialSetValueProperty;
template<typename X> typename RatingControl_statics<X>::_IsClearEnabledProperty RatingControl_statics<X>::IsClearEnabledProperty;
template<typename X> typename RatingControl_statics<X>::_IsReadOnlyProperty RatingControl_statics<X>::IsReadOnlyProperty;
template<typename X> typename RatingControl_statics<X>::_ItemInfoProperty RatingControl_statics<X>::ItemInfoProperty;
template<typename X> typename RatingControl_statics<X>::_MaxRatingProperty RatingControl_statics<X>::MaxRatingProperty;
template<typename X> typename RatingControl_statics<X>::_PlaceholderValueProperty RatingControl_statics<X>::PlaceholderValueProperty;
template<typename X> typename RatingControl_statics<X>::_ValueProperty RatingControl_statics<X>::ValueProperty;

template<typename X> struct statics<RatingControl, X> : X, Windows::UI::Xaml::Controls::RatingControl_statics<void> {
	using Windows::UI::Xaml::Controls::RatingControl_statics<void>::activate;
	typedef typename X::root_type RatingControl;
};
struct RatingControl : generate<RatingControl> {};

// RefreshVisualizer
template<typename> struct RefreshVisualizer_statics {
	static struct _ContentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RefreshVisualizer, IRefreshVisualizerStatics>()->_get_ContentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentProperty;
	static struct _InfoProviderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RefreshVisualizer, IRefreshVisualizerStatics>()->_get_InfoProviderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} InfoProviderProperty;
	static struct _OrientationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RefreshVisualizer, IRefreshVisualizerStatics>()->_get_OrientationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OrientationProperty;
	static struct _StateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RefreshVisualizer, IRefreshVisualizerStatics>()->_get_StateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StateProperty;
	static RefreshVisualizer *activate(object_ref outer, IInspectable* *inner) { RefreshVisualizer *instance; hrcheck(get_activation_factory<RefreshVisualizer, IRefreshVisualizerFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename RefreshVisualizer_statics<X>::_ContentProperty RefreshVisualizer_statics<X>::ContentProperty;
template<typename X> typename RefreshVisualizer_statics<X>::_InfoProviderProperty RefreshVisualizer_statics<X>::InfoProviderProperty;
template<typename X> typename RefreshVisualizer_statics<X>::_OrientationProperty RefreshVisualizer_statics<X>::OrientationProperty;
template<typename X> typename RefreshVisualizer_statics<X>::_StateProperty RefreshVisualizer_statics<X>::StateProperty;

template<typename X> struct statics<RefreshVisualizer, X> : X, Windows::UI::Xaml::Controls::RefreshVisualizer_statics<void> {
	using Windows::UI::Xaml::Controls::RefreshVisualizer_statics<void>::activate;
	typedef typename X::root_type RefreshVisualizer;
};
struct RefreshVisualizer : generate<RefreshVisualizer> {};

// TreeView
template<typename> struct TreeView_statics {
	static struct _SelectionModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeView, ITreeViewStatics>()->_get_SelectionModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectionModeProperty;
	static TreeView *activate(object_ref outer, IInspectable* *inner) { TreeView *instance; hrcheck(get_activation_factory<TreeView, ITreeViewFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename TreeView_statics<X>::_SelectionModeProperty TreeView_statics<X>::SelectionModeProperty;

template<typename X> struct statics<TreeView, X> : X, Windows::UI::Xaml::Controls::TreeView_statics<void> {
	using Windows::UI::Xaml::Controls::TreeView_statics<void>::activate;
	typedef typename X::root_type TreeView;
};
struct TreeView : generate<TreeView> {};

// SemanticZoom
template<typename> struct SemanticZoom_statics {
	static struct _CanChangeViewsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SemanticZoom, ISemanticZoomStatics>()->_get_CanChangeViewsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CanChangeViewsProperty;
	static struct _IsZoomOutButtonEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SemanticZoom, ISemanticZoomStatics>()->_get_IsZoomOutButtonEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsZoomOutButtonEnabledProperty;
	static struct _IsZoomedInViewActiveProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SemanticZoom, ISemanticZoomStatics>()->_get_IsZoomedInViewActiveProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsZoomedInViewActiveProperty;
	static struct _ZoomedInViewProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SemanticZoom, ISemanticZoomStatics>()->_get_ZoomedInViewProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ZoomedInViewProperty;
	static struct _ZoomedOutViewProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SemanticZoom, ISemanticZoomStatics>()->_get_ZoomedOutViewProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ZoomedOutViewProperty;
};
template<typename X> typename SemanticZoom_statics<X>::_CanChangeViewsProperty SemanticZoom_statics<X>::CanChangeViewsProperty;
template<typename X> typename SemanticZoom_statics<X>::_IsZoomOutButtonEnabledProperty SemanticZoom_statics<X>::IsZoomOutButtonEnabledProperty;
template<typename X> typename SemanticZoom_statics<X>::_IsZoomedInViewActiveProperty SemanticZoom_statics<X>::IsZoomedInViewActiveProperty;
template<typename X> typename SemanticZoom_statics<X>::_ZoomedInViewProperty SemanticZoom_statics<X>::ZoomedInViewProperty;
template<typename X> typename SemanticZoom_statics<X>::_ZoomedOutViewProperty SemanticZoom_statics<X>::ZoomedOutViewProperty;

template<typename X> struct statics<SemanticZoom, X> : X, Windows::UI::Xaml::Controls::SemanticZoom_statics<void> {
	typedef typename X::root_type SemanticZoom;
};
struct SemanticZoom : generate<SemanticZoom> {};

// INavigationViewStatics2
struct INavigationViewStatics2 : IInspectable {
	virtual STDMETHODIMP _get_IsBackButtonVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsBackEnabledProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PaneTitleProperty(DependencyProperty* *value);
};

// INavigationViewStatics
struct INavigationViewStatics : IInspectable {
	virtual STDMETHODIMP _get_IsPaneOpenProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CompactModeThresholdWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ExpandedModeThresholdWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PaneFooterProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DisplayModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsSettingsVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsPaneToggleButtonVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AlwaysShowHeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CompactPaneLengthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OpenPaneLengthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_PaneToggleButtonStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MenuItemsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MenuItemsSourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedItemProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SettingsItemProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_AutoSuggestBoxProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MenuItemTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MenuItemTemplateSelectorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MenuItemContainerStyleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MenuItemContainerStyleSelectorProperty(DependencyProperty* *value);
};

// INavigationViewFactory
struct INavigationViewFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, NavigationView* *instance);
};

// INavigationView2
struct INavigationView2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsBackButtonVisible(NavigationViewBackButtonVisible *value);
	virtual STDMETHODIMP _put_IsBackButtonVisible(NavigationViewBackButtonVisible value);
	virtual STDMETHODIMP _get_IsBackEnabled(bool *value);
	virtual STDMETHODIMP _put_IsBackEnabled(bool value);
	virtual STDMETHODIMP _get_PaneTitle(HSTRING *value);
	virtual STDMETHODIMP _put_PaneTitle(HSTRING value);
	virtual STDMETHODIMP _add_BackRequested(Foundation::TypedEventHandler<NavigationView*, NavigationViewBackRequestedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_BackRequested(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PaneClosed(Foundation::TypedEventHandler<NavigationView*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PaneClosed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PaneClosing(Foundation::TypedEventHandler<NavigationView*, NavigationViewPaneClosingEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PaneClosing(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PaneOpened(Foundation::TypedEventHandler<NavigationView*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PaneOpened(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PaneOpening(Foundation::TypedEventHandler<NavigationView*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PaneOpening(Foundation::EventRegistrationToken token);
};
template<typename X> struct INavigationView2_adaptor : X {
	union {
		struct : property {
			NavigationViewBackButtonVisible get() { NavigationViewBackButtonVisible value; hrcheck(enc(&INavigationView2_adaptor::IsBackButtonVisible)->_get_IsBackButtonVisible(&value)); return value; }
			NavigationViewBackButtonVisible operator()() { return get(); }
			operator NavigationViewBackButtonVisible () { return get(); }
			void put(NavigationViewBackButtonVisible value) { hrcheck(enc(&INavigationView2_adaptor::IsBackButtonVisible)->_put_IsBackButtonVisible(value)); }
			void operator=(NavigationViewBackButtonVisible value) { put(value); }
			void operator()(NavigationViewBackButtonVisible value) { put(value); }
		} IsBackButtonVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&INavigationView2_adaptor::IsBackEnabled)->_get_IsBackEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&INavigationView2_adaptor::IsBackEnabled)->_put_IsBackEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsBackEnabled;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&INavigationView2_adaptor::PaneTitle)->_get_PaneTitle(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&INavigationView2_adaptor::PaneTitle)->_put_PaneTitle(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PaneTitle;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<NavigationView>, ptr<NavigationViewBackRequestedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&INavigationView2_adaptor::BackRequested)->_add_BackRequested(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&INavigationView2_adaptor::BackRequested)->_remove_BackRequested(token)); }
		} BackRequested;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<NavigationView>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&INavigationView2_adaptor::PaneClosed)->_add_PaneClosed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&INavigationView2_adaptor::PaneClosed)->_remove_PaneClosed(token)); }
		} PaneClosed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<NavigationView>, ptr<NavigationViewPaneClosingEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&INavigationView2_adaptor::PaneClosing)->_add_PaneClosing(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&INavigationView2_adaptor::PaneClosing)->_remove_PaneClosing(token)); }
		} PaneClosing;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<NavigationView>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&INavigationView2_adaptor::PaneOpened)->_add_PaneOpened(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&INavigationView2_adaptor::PaneOpened)->_remove_PaneOpened(token)); }
		} PaneOpened;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<NavigationView>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&INavigationView2_adaptor::PaneOpening)->_add_PaneOpening(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&INavigationView2_adaptor::PaneOpening)->_remove_PaneOpening(token)); }
		} PaneOpening;
	};
	INavigationView2_adaptor() {}
};
template<typename X> struct adapt<INavigationView2, X> : Windows::UI::Xaml::Controls::INavigationView2_adaptor<X> { typedef adapt INavigationView2; };
struct INavigationView2 : INavigationView2_raw, generate<INavigationView2> {};

// INavigationView
struct INavigationView_raw : IInspectable {
	virtual STDMETHODIMP _get_IsPaneOpen(bool *result);
	virtual STDMETHODIMP _put_IsPaneOpen(bool value);
	virtual STDMETHODIMP _get_CompactModeThresholdWidth(double *result);
	virtual STDMETHODIMP _put_CompactModeThresholdWidth(double value);
	virtual STDMETHODIMP _get_ExpandedModeThresholdWidth(double *result);
	virtual STDMETHODIMP _put_ExpandedModeThresholdWidth(double value);
	virtual STDMETHODIMP _get_PaneFooter(UIElement* *value);
	virtual STDMETHODIMP _put_PaneFooter(UIElement* value);
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_DisplayMode(NavigationViewDisplayMode *result);
	virtual STDMETHODIMP _get_IsSettingsVisible(bool *result);
	virtual STDMETHODIMP _put_IsSettingsVisible(bool value);
	virtual STDMETHODIMP _get_IsPaneToggleButtonVisible(bool *result);
	virtual STDMETHODIMP _put_IsPaneToggleButtonVisible(bool value);
	virtual STDMETHODIMP _get_AlwaysShowHeader(bool *result);
	virtual STDMETHODIMP _put_AlwaysShowHeader(bool value);
	virtual STDMETHODIMP _get_CompactPaneLength(double *result);
	virtual STDMETHODIMP _put_CompactPaneLength(double value);
	virtual STDMETHODIMP _get_OpenPaneLength(double *result);
	virtual STDMETHODIMP _put_OpenPaneLength(double value);
	virtual STDMETHODIMP _get_PaneToggleButtonStyle(Style* *value);
	virtual STDMETHODIMP _put_PaneToggleButtonStyle(Style* value);
	virtual STDMETHODIMP _get_SelectedItem(IInspectable* *value);
	virtual STDMETHODIMP _put_SelectedItem(IInspectable* value);
	virtual STDMETHODIMP _get_MenuItems(Foundation::Collections::IVector<IInspectable*>* *value);
	virtual STDMETHODIMP _get_MenuItemsSource(IInspectable* *value);
	virtual STDMETHODIMP _put_MenuItemsSource(IInspectable* value);
	virtual STDMETHODIMP _get_SettingsItem(IInspectable* *value);
	virtual STDMETHODIMP _get_AutoSuggestBox(Controls::AutoSuggestBox* *result);
	virtual STDMETHODIMP _put_AutoSuggestBox(Controls::AutoSuggestBox* value);
	virtual STDMETHODIMP _get_MenuItemTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_MenuItemTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_MenuItemTemplateSelector(DataTemplateSelector* *value);
	virtual STDMETHODIMP _put_MenuItemTemplateSelector(DataTemplateSelector* value);
	virtual STDMETHODIMP _get_MenuItemContainerStyle(Style* *value);
	virtual STDMETHODIMP _put_MenuItemContainerStyle(Style* value);
	virtual STDMETHODIMP _get_MenuItemContainerStyleSelector(StyleSelector* *value);
	virtual STDMETHODIMP _put_MenuItemContainerStyleSelector(StyleSelector* value);
	virtual STDMETHODIMP _MenuItemFromContainer(DependencyObject* container, IInspectable* *returnValue);
	virtual STDMETHODIMP _ContainerFromMenuItem(IInspectable* item, DependencyObject* *returnValue);
	virtual STDMETHODIMP _add_SelectionChanged(Foundation::TypedEventHandler<NavigationView*, NavigationViewSelectionChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SelectionChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ItemInvoked(Foundation::TypedEventHandler<NavigationView*, NavigationViewItemInvokedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ItemInvoked(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_DisplayModeChanged(Foundation::TypedEventHandler<NavigationView*, NavigationViewDisplayModeChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DisplayModeChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct INavigationView_adaptor : X {
	union {
		struct : property {
			bool get() { bool result; hrcheck(enc(&INavigationView_adaptor::AlwaysShowHeader)->_get_AlwaysShowHeader(&result)); return result; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&INavigationView_adaptor::AlwaysShowHeader)->_put_AlwaysShowHeader(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AlwaysShowHeader;
		struct : property {
			ptr<Controls::AutoSuggestBox> get() { Controls::AutoSuggestBox* result; hrcheck(enc(&INavigationView_adaptor::AutoSuggestBox)->_get_AutoSuggestBox(&result)); return from_abi(result); }
			ptr<Controls::AutoSuggestBox> operator()() { return get(); }
			operator ptr<Controls::AutoSuggestBox> () { return get(); }
			ptr<Controls::AutoSuggestBox> operator->() { return get(); }
			void put(pptr<Controls::AutoSuggestBox> value) { hrcheck(enc(&INavigationView_adaptor::AutoSuggestBox)->_put_AutoSuggestBox(value)); }
			void operator=(pptr<Controls::AutoSuggestBox> value) { put(value); }
			void operator()(pptr<Controls::AutoSuggestBox> value) { put(value); }
		} AutoSuggestBox;
		struct : property {
			double get() { double result; hrcheck(enc(&INavigationView_adaptor::CompactModeThresholdWidth)->_get_CompactModeThresholdWidth(&result)); return result; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&INavigationView_adaptor::CompactModeThresholdWidth)->_put_CompactModeThresholdWidth(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CompactModeThresholdWidth;
		struct : property {
			double get() { double result; hrcheck(enc(&INavigationView_adaptor::CompactPaneLength)->_get_CompactPaneLength(&result)); return result; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&INavigationView_adaptor::CompactPaneLength)->_put_CompactPaneLength(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} CompactPaneLength;
		struct : property {
			NavigationViewDisplayMode get() { NavigationViewDisplayMode result; hrcheck(enc(&INavigationView_adaptor::DisplayMode)->_get_DisplayMode(&result)); return result; }
			NavigationViewDisplayMode operator()() { return get(); }
			operator NavigationViewDisplayMode () { return get(); }
		} DisplayMode;
		struct : property {
			double get() { double result; hrcheck(enc(&INavigationView_adaptor::ExpandedModeThresholdWidth)->_get_ExpandedModeThresholdWidth(&result)); return result; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&INavigationView_adaptor::ExpandedModeThresholdWidth)->_put_ExpandedModeThresholdWidth(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} ExpandedModeThresholdWidth;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&INavigationView_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&INavigationView_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&INavigationView_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&INavigationView_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
		struct : property {
			bool get() { bool result; hrcheck(enc(&INavigationView_adaptor::IsPaneOpen)->_get_IsPaneOpen(&result)); return result; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&INavigationView_adaptor::IsPaneOpen)->_put_IsPaneOpen(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsPaneOpen;
		struct : property {
			bool get() { bool result; hrcheck(enc(&INavigationView_adaptor::IsPaneToggleButtonVisible)->_get_IsPaneToggleButtonVisible(&result)); return result; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&INavigationView_adaptor::IsPaneToggleButtonVisible)->_put_IsPaneToggleButtonVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsPaneToggleButtonVisible;
		struct : property {
			bool get() { bool result; hrcheck(enc(&INavigationView_adaptor::IsSettingsVisible)->_get_IsSettingsVisible(&result)); return result; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&INavigationView_adaptor::IsSettingsVisible)->_put_IsSettingsVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsSettingsVisible;
		struct : property {
			ptr<Style> get() { Style* value; hrcheck(enc(&INavigationView_adaptor::MenuItemContainerStyle)->_get_MenuItemContainerStyle(&value)); return from_abi(value); }
			ptr<Style> operator()() { return get(); }
			operator ptr<Style> () { return get(); }
			ptr<Style> operator->() { return get(); }
			void put(pptr<Style> value) { hrcheck(enc(&INavigationView_adaptor::MenuItemContainerStyle)->_put_MenuItemContainerStyle(value)); }
			void operator=(pptr<Style> value) { put(value); }
			void operator()(pptr<Style> value) { put(value); }
		} MenuItemContainerStyle;
		struct : property {
			ptr<StyleSelector> get() { StyleSelector* value; hrcheck(enc(&INavigationView_adaptor::MenuItemContainerStyleSelector)->_get_MenuItemContainerStyleSelector(&value)); return from_abi(value); }
			ptr<StyleSelector> operator()() { return get(); }
			operator ptr<StyleSelector> () { return get(); }
			ptr<StyleSelector> operator->() { return get(); }
			void put(pptr<StyleSelector> value) { hrcheck(enc(&INavigationView_adaptor::MenuItemContainerStyleSelector)->_put_MenuItemContainerStyleSelector(value)); }
			void operator=(pptr<StyleSelector> value) { put(value); }
			void operator()(pptr<StyleSelector> value) { put(value); }
		} MenuItemContainerStyleSelector;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&INavigationView_adaptor::MenuItemTemplate)->_get_MenuItemTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&INavigationView_adaptor::MenuItemTemplate)->_put_MenuItemTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} MenuItemTemplate;
		struct : property {
			ptr<DataTemplateSelector> get() { DataTemplateSelector* value; hrcheck(enc(&INavigationView_adaptor::MenuItemTemplateSelector)->_get_MenuItemTemplateSelector(&value)); return from_abi(value); }
			ptr<DataTemplateSelector> operator()() { return get(); }
			operator ptr<DataTemplateSelector> () { return get(); }
			ptr<DataTemplateSelector> operator->() { return get(); }
			void put(pptr<DataTemplateSelector> value) { hrcheck(enc(&INavigationView_adaptor::MenuItemTemplateSelector)->_put_MenuItemTemplateSelector(value)); }
			void operator=(pptr<DataTemplateSelector> value) { put(value); }
			void operator()(pptr<DataTemplateSelector> value) { put(value); }
		} MenuItemTemplateSelector;
		struct : property {
			ptr<Foundation::Collections::IVector<object>> get() { Foundation::Collections::IVector<IInspectable*>* value; hrcheck(enc(&INavigationView_adaptor::MenuItems)->_get_MenuItems(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<object>> () { return get(); }
			ptr<Foundation::Collections::IVector<object>> operator->() { return get(); }
		} MenuItems;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&INavigationView_adaptor::MenuItemsSource)->_get_MenuItemsSource(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&INavigationView_adaptor::MenuItemsSource)->_put_MenuItemsSource(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} MenuItemsSource;
		struct : property {
			double get() { double result; hrcheck(enc(&INavigationView_adaptor::OpenPaneLength)->_get_OpenPaneLength(&result)); return result; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&INavigationView_adaptor::OpenPaneLength)->_put_OpenPaneLength(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} OpenPaneLength;
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&INavigationView_adaptor::PaneFooter)->_get_PaneFooter(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&INavigationView_adaptor::PaneFooter)->_put_PaneFooter(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} PaneFooter;
		struct : property {
			ptr<Style> get() { Style* value; hrcheck(enc(&INavigationView_adaptor::PaneToggleButtonStyle)->_get_PaneToggleButtonStyle(&value)); return from_abi(value); }
			ptr<Style> operator()() { return get(); }
			operator ptr<Style> () { return get(); }
			ptr<Style> operator->() { return get(); }
			void put(pptr<Style> value) { hrcheck(enc(&INavigationView_adaptor::PaneToggleButtonStyle)->_put_PaneToggleButtonStyle(value)); }
			void operator=(pptr<Style> value) { put(value); }
			void operator()(pptr<Style> value) { put(value); }
		} PaneToggleButtonStyle;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&INavigationView_adaptor::SelectedItem)->_get_SelectedItem(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&INavigationView_adaptor::SelectedItem)->_put_SelectedItem(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} SelectedItem;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&INavigationView_adaptor::SettingsItem)->_get_SettingsItem(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} SettingsItem;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<NavigationView>, ptr<NavigationViewDisplayModeChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&INavigationView_adaptor::DisplayModeChanged)->_add_DisplayModeChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&INavigationView_adaptor::DisplayModeChanged)->_remove_DisplayModeChanged(token)); }
		} DisplayModeChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<NavigationView>, ptr<NavigationViewItemInvokedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&INavigationView_adaptor::ItemInvoked)->_add_ItemInvoked(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&INavigationView_adaptor::ItemInvoked)->_remove_ItemInvoked(token)); }
		} ItemInvoked;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<NavigationView>, ptr<NavigationViewSelectionChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&INavigationView_adaptor::SelectionChanged)->_add_SelectionChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&INavigationView_adaptor::SelectionChanged)->_remove_SelectionChanged(token)); }
		} SelectionChanged;
	};
	object MenuItemFromContainer(pptr<DependencyObject> container) { IInspectable* returnValue; hrcheck(X::get()->_MenuItemFromContainer(container, &returnValue)); return from_abi(returnValue); }
	ptr<DependencyObject> ContainerFromMenuItem(object_ref item) { DependencyObject* returnValue; hrcheck(X::get()->_ContainerFromMenuItem(item, &returnValue)); return from_abi(returnValue); }
	INavigationView_adaptor() {}
};
template<typename X> struct adapt<INavigationView, X> : Windows::UI::Xaml::Controls::INavigationView_adaptor<X> { typedef adapt INavigationView; };
struct INavigationView : INavigationView_raw, generate<INavigationView> {};

// NavigationView
template<typename> struct NavigationView_statics {
	static struct _AlwaysShowHeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_AlwaysShowHeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AlwaysShowHeaderProperty;
	static struct _AutoSuggestBoxProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_AutoSuggestBoxProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AutoSuggestBoxProperty;
	static struct _CompactModeThresholdWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_CompactModeThresholdWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CompactModeThresholdWidthProperty;
	static struct _CompactPaneLengthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_CompactPaneLengthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CompactPaneLengthProperty;
	static struct _DisplayModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_DisplayModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DisplayModeProperty;
	static struct _ExpandedModeThresholdWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_ExpandedModeThresholdWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ExpandedModeThresholdWidthProperty;
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static struct _HeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_HeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTemplateProperty;
	static struct _IsPaneOpenProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_IsPaneOpenProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsPaneOpenProperty;
	static struct _IsPaneToggleButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_IsPaneToggleButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsPaneToggleButtonVisibleProperty;
	static struct _IsSettingsVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_IsSettingsVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsSettingsVisibleProperty;
	static struct _MenuItemContainerStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_MenuItemContainerStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MenuItemContainerStyleProperty;
	static struct _MenuItemContainerStyleSelectorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_MenuItemContainerStyleSelectorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MenuItemContainerStyleSelectorProperty;
	static struct _MenuItemTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_MenuItemTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MenuItemTemplateProperty;
	static struct _MenuItemTemplateSelectorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_MenuItemTemplateSelectorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MenuItemTemplateSelectorProperty;
	static struct _MenuItemsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_MenuItemsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MenuItemsProperty;
	static struct _MenuItemsSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_MenuItemsSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MenuItemsSourceProperty;
	static struct _OpenPaneLengthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_OpenPaneLengthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OpenPaneLengthProperty;
	static struct _PaneFooterProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_PaneFooterProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaneFooterProperty;
	static struct _PaneToggleButtonStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_PaneToggleButtonStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaneToggleButtonStyleProperty;
	static struct _SelectedItemProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_SelectedItemProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedItemProperty;
	static struct _SettingsItemProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics>()->_get_SettingsItemProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SettingsItemProperty;
	static struct _IsBackButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics2>()->_get_IsBackButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsBackButtonVisibleProperty;
	static struct _IsBackEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics2>()->_get_IsBackEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsBackEnabledProperty;
	static struct _PaneTitleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationView, INavigationViewStatics2>()->_get_PaneTitleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaneTitleProperty;
	static NavigationView *activate(object_ref outer, IInspectable* *inner) { NavigationView *instance; hrcheck(get_activation_factory<NavigationView, INavigationViewFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename NavigationView_statics<X>::_AlwaysShowHeaderProperty NavigationView_statics<X>::AlwaysShowHeaderProperty;
template<typename X> typename NavigationView_statics<X>::_AutoSuggestBoxProperty NavigationView_statics<X>::AutoSuggestBoxProperty;
template<typename X> typename NavigationView_statics<X>::_CompactModeThresholdWidthProperty NavigationView_statics<X>::CompactModeThresholdWidthProperty;
template<typename X> typename NavigationView_statics<X>::_CompactPaneLengthProperty NavigationView_statics<X>::CompactPaneLengthProperty;
template<typename X> typename NavigationView_statics<X>::_DisplayModeProperty NavigationView_statics<X>::DisplayModeProperty;
template<typename X> typename NavigationView_statics<X>::_ExpandedModeThresholdWidthProperty NavigationView_statics<X>::ExpandedModeThresholdWidthProperty;
template<typename X> typename NavigationView_statics<X>::_HeaderProperty NavigationView_statics<X>::HeaderProperty;
template<typename X> typename NavigationView_statics<X>::_HeaderTemplateProperty NavigationView_statics<X>::HeaderTemplateProperty;
template<typename X> typename NavigationView_statics<X>::_IsPaneOpenProperty NavigationView_statics<X>::IsPaneOpenProperty;
template<typename X> typename NavigationView_statics<X>::_IsPaneToggleButtonVisibleProperty NavigationView_statics<X>::IsPaneToggleButtonVisibleProperty;
template<typename X> typename NavigationView_statics<X>::_IsSettingsVisibleProperty NavigationView_statics<X>::IsSettingsVisibleProperty;
template<typename X> typename NavigationView_statics<X>::_MenuItemContainerStyleProperty NavigationView_statics<X>::MenuItemContainerStyleProperty;
template<typename X> typename NavigationView_statics<X>::_MenuItemContainerStyleSelectorProperty NavigationView_statics<X>::MenuItemContainerStyleSelectorProperty;
template<typename X> typename NavigationView_statics<X>::_MenuItemTemplateProperty NavigationView_statics<X>::MenuItemTemplateProperty;
template<typename X> typename NavigationView_statics<X>::_MenuItemTemplateSelectorProperty NavigationView_statics<X>::MenuItemTemplateSelectorProperty;
template<typename X> typename NavigationView_statics<X>::_MenuItemsProperty NavigationView_statics<X>::MenuItemsProperty;
template<typename X> typename NavigationView_statics<X>::_MenuItemsSourceProperty NavigationView_statics<X>::MenuItemsSourceProperty;
template<typename X> typename NavigationView_statics<X>::_OpenPaneLengthProperty NavigationView_statics<X>::OpenPaneLengthProperty;
template<typename X> typename NavigationView_statics<X>::_PaneFooterProperty NavigationView_statics<X>::PaneFooterProperty;
template<typename X> typename NavigationView_statics<X>::_PaneToggleButtonStyleProperty NavigationView_statics<X>::PaneToggleButtonStyleProperty;
template<typename X> typename NavigationView_statics<X>::_SelectedItemProperty NavigationView_statics<X>::SelectedItemProperty;
template<typename X> typename NavigationView_statics<X>::_SettingsItemProperty NavigationView_statics<X>::SettingsItemProperty;
template<typename X> typename NavigationView_statics<X>::_IsBackButtonVisibleProperty NavigationView_statics<X>::IsBackButtonVisibleProperty;
template<typename X> typename NavigationView_statics<X>::_IsBackEnabledProperty NavigationView_statics<X>::IsBackEnabledProperty;
template<typename X> typename NavigationView_statics<X>::_PaneTitleProperty NavigationView_statics<X>::PaneTitleProperty;

template<typename X> struct statics<NavigationView, X> : X, Windows::UI::Xaml::Controls::NavigationView_statics<void> {
	using Windows::UI::Xaml::Controls::NavigationView_statics<void>::activate;
	typedef typename X::root_type NavigationView;
};
struct NavigationView : generate<NavigationView> {};

// RefreshContainer
template<typename> struct RefreshContainer_statics {
	static struct _PullDirectionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RefreshContainer, IRefreshContainerStatics>()->_get_PullDirectionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PullDirectionProperty;
	static struct _VisualizerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RefreshContainer, IRefreshContainerStatics>()->_get_VisualizerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VisualizerProperty;
	static RefreshContainer *activate(object_ref outer, IInspectable* *inner) { RefreshContainer *instance; hrcheck(get_activation_factory<RefreshContainer, IRefreshContainerFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename RefreshContainer_statics<X>::_PullDirectionProperty RefreshContainer_statics<X>::PullDirectionProperty;
template<typename X> typename RefreshContainer_statics<X>::_VisualizerProperty RefreshContainer_statics<X>::VisualizerProperty;

template<typename X> struct statics<RefreshContainer, X> : X, Windows::UI::Xaml::Controls::RefreshContainer_statics<void> {
	using Windows::UI::Xaml::Controls::RefreshContainer_statics<void>::activate;
	typedef typename X::root_type RefreshContainer;
};
struct RefreshContainer : generate<RefreshContainer> {};

// SwipeControl
template<typename> struct SwipeControl_statics {
	static struct _BottomItemsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeControl, ISwipeControlStatics>()->_get_BottomItemsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BottomItemsProperty;
	static struct _LeftItemsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeControl, ISwipeControlStatics>()->_get_LeftItemsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LeftItemsProperty;
	static struct _RightItemsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeControl, ISwipeControlStatics>()->_get_RightItemsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RightItemsProperty;
	static struct _TopItemsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SwipeControl, ISwipeControlStatics>()->_get_TopItemsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TopItemsProperty;
	static SwipeControl *activate(object_ref outer, IInspectable* *inner) { SwipeControl *instance; hrcheck(get_activation_factory<SwipeControl, ISwipeControlFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename SwipeControl_statics<X>::_BottomItemsProperty SwipeControl_statics<X>::BottomItemsProperty;
template<typename X> typename SwipeControl_statics<X>::_LeftItemsProperty SwipeControl_statics<X>::LeftItemsProperty;
template<typename X> typename SwipeControl_statics<X>::_RightItemsProperty SwipeControl_statics<X>::RightItemsProperty;
template<typename X> typename SwipeControl_statics<X>::_TopItemsProperty SwipeControl_statics<X>::TopItemsProperty;

template<typename X> struct statics<SwipeControl, X> : X, Windows::UI::Xaml::Controls::SwipeControl_statics<void> {
	using Windows::UI::Xaml::Controls::SwipeControl_statics<void>::activate;
	typedef typename X::root_type SwipeControl;
};
struct SwipeControl : generate<SwipeControl> {};

// ListViewBaseHeaderItem
template<typename X> struct statics<ListViewBaseHeaderItem, X> : X {
	typedef typename X::root_type ListViewBaseHeaderItem;
};
struct ListViewBaseHeaderItem : generate<ListViewBaseHeaderItem> {};

// HandwritingView
template<typename> struct HandwritingView_statics {
	static struct _AreCandidatesEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<HandwritingView, IHandwritingViewStatics>()->_get_AreCandidatesEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AreCandidatesEnabledProperty;
	static struct _IsOpenProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<HandwritingView, IHandwritingViewStatics>()->_get_IsOpenProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsOpenProperty;
	static struct _PlacementAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<HandwritingView, IHandwritingViewStatics>()->_get_PlacementAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlacementAlignmentProperty;
	static struct _PlacementTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<HandwritingView, IHandwritingViewStatics>()->_get_PlacementTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlacementTargetProperty;
	static HandwritingView *activate(object_ref outer, IInspectable* *inner) { HandwritingView *instance; hrcheck(get_activation_factory<HandwritingView, IHandwritingViewFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename HandwritingView_statics<X>::_AreCandidatesEnabledProperty HandwritingView_statics<X>::AreCandidatesEnabledProperty;
template<typename X> typename HandwritingView_statics<X>::_IsOpenProperty HandwritingView_statics<X>::IsOpenProperty;
template<typename X> typename HandwritingView_statics<X>::_PlacementAlignmentProperty HandwritingView_statics<X>::PlacementAlignmentProperty;
template<typename X> typename HandwritingView_statics<X>::_PlacementTargetProperty HandwritingView_statics<X>::PlacementTargetProperty;

template<typename X> struct statics<HandwritingView, X> : X, Windows::UI::Xaml::Controls::HandwritingView_statics<void> {
	using Windows::UI::Xaml::Controls::HandwritingView_statics<void>::activate;
	typedef typename X::root_type HandwritingView;
};
struct HandwritingView : generate<HandwritingView> {};

// MediaTransportControls
template<typename> struct MediaTransportControls_statics {
	static struct _IsCompactProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsCompactProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsCompactProperty;
	static struct _IsFastForwardButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsFastForwardButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsFastForwardButtonVisibleProperty;
	static struct _IsFastForwardEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsFastForwardEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsFastForwardEnabledProperty;
	static struct _IsFastRewindButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsFastRewindButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsFastRewindButtonVisibleProperty;
	static struct _IsFastRewindEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsFastRewindEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsFastRewindEnabledProperty;
	static struct _IsFullWindowButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsFullWindowButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsFullWindowButtonVisibleProperty;
	static struct _IsFullWindowEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsFullWindowEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsFullWindowEnabledProperty;
	static struct _IsPlaybackRateButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsPlaybackRateButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsPlaybackRateButtonVisibleProperty;
	static struct _IsPlaybackRateEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsPlaybackRateEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsPlaybackRateEnabledProperty;
	static struct _IsSeekBarVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsSeekBarVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsSeekBarVisibleProperty;
	static struct _IsSeekEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsSeekEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsSeekEnabledProperty;
	static struct _IsStopButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsStopButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsStopButtonVisibleProperty;
	static struct _IsStopEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsStopEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsStopEnabledProperty;
	static struct _IsVolumeButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsVolumeButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsVolumeButtonVisibleProperty;
	static struct _IsVolumeEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsVolumeEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsVolumeEnabledProperty;
	static struct _IsZoomButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsZoomButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsZoomButtonVisibleProperty;
	static struct _IsZoomEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics>()->_get_IsZoomEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsZoomEnabledProperty;
	static struct _FastPlayFallbackBehaviourProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics2>()->_get_FastPlayFallbackBehaviourProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FastPlayFallbackBehaviourProperty;
	static struct _IsNextTrackButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics2>()->_get_IsNextTrackButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsNextTrackButtonVisibleProperty;
	static struct _IsPreviousTrackButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics2>()->_get_IsPreviousTrackButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsPreviousTrackButtonVisibleProperty;
	static struct _IsSkipBackwardButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics2>()->_get_IsSkipBackwardButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsSkipBackwardButtonVisibleProperty;
	static struct _IsSkipBackwardEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics2>()->_get_IsSkipBackwardEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsSkipBackwardEnabledProperty;
	static struct _IsSkipForwardButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics2>()->_get_IsSkipForwardButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsSkipForwardButtonVisibleProperty;
	static struct _IsSkipForwardEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics2>()->_get_IsSkipForwardEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsSkipForwardEnabledProperty;
	static struct _IsRepeatButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics3>()->_get_IsRepeatButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsRepeatButtonVisibleProperty;
	static struct _IsRepeatEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics3>()->_get_IsRepeatEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsRepeatEnabledProperty;
	static struct _ShowAndHideAutomaticallyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics3>()->_get_ShowAndHideAutomaticallyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ShowAndHideAutomaticallyProperty;
	static struct _IsCompactOverlayButtonVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics4>()->_get_IsCompactOverlayButtonVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsCompactOverlayButtonVisibleProperty;
	static struct _IsCompactOverlayEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsStatics4>()->_get_IsCompactOverlayEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsCompactOverlayEnabledProperty;
	static MediaTransportControls *activate(object_ref outer, IInspectable* *inner) { MediaTransportControls *instance; hrcheck(get_activation_factory<MediaTransportControls, IMediaTransportControlsFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename MediaTransportControls_statics<X>::_IsCompactProperty MediaTransportControls_statics<X>::IsCompactProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsFastForwardButtonVisibleProperty MediaTransportControls_statics<X>::IsFastForwardButtonVisibleProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsFastForwardEnabledProperty MediaTransportControls_statics<X>::IsFastForwardEnabledProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsFastRewindButtonVisibleProperty MediaTransportControls_statics<X>::IsFastRewindButtonVisibleProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsFastRewindEnabledProperty MediaTransportControls_statics<X>::IsFastRewindEnabledProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsFullWindowButtonVisibleProperty MediaTransportControls_statics<X>::IsFullWindowButtonVisibleProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsFullWindowEnabledProperty MediaTransportControls_statics<X>::IsFullWindowEnabledProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsPlaybackRateButtonVisibleProperty MediaTransportControls_statics<X>::IsPlaybackRateButtonVisibleProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsPlaybackRateEnabledProperty MediaTransportControls_statics<X>::IsPlaybackRateEnabledProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsSeekBarVisibleProperty MediaTransportControls_statics<X>::IsSeekBarVisibleProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsSeekEnabledProperty MediaTransportControls_statics<X>::IsSeekEnabledProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsStopButtonVisibleProperty MediaTransportControls_statics<X>::IsStopButtonVisibleProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsStopEnabledProperty MediaTransportControls_statics<X>::IsStopEnabledProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsVolumeButtonVisibleProperty MediaTransportControls_statics<X>::IsVolumeButtonVisibleProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsVolumeEnabledProperty MediaTransportControls_statics<X>::IsVolumeEnabledProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsZoomButtonVisibleProperty MediaTransportControls_statics<X>::IsZoomButtonVisibleProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsZoomEnabledProperty MediaTransportControls_statics<X>::IsZoomEnabledProperty;
template<typename X> typename MediaTransportControls_statics<X>::_FastPlayFallbackBehaviourProperty MediaTransportControls_statics<X>::FastPlayFallbackBehaviourProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsNextTrackButtonVisibleProperty MediaTransportControls_statics<X>::IsNextTrackButtonVisibleProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsPreviousTrackButtonVisibleProperty MediaTransportControls_statics<X>::IsPreviousTrackButtonVisibleProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsSkipBackwardButtonVisibleProperty MediaTransportControls_statics<X>::IsSkipBackwardButtonVisibleProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsSkipBackwardEnabledProperty MediaTransportControls_statics<X>::IsSkipBackwardEnabledProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsSkipForwardButtonVisibleProperty MediaTransportControls_statics<X>::IsSkipForwardButtonVisibleProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsSkipForwardEnabledProperty MediaTransportControls_statics<X>::IsSkipForwardEnabledProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsRepeatButtonVisibleProperty MediaTransportControls_statics<X>::IsRepeatButtonVisibleProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsRepeatEnabledProperty MediaTransportControls_statics<X>::IsRepeatEnabledProperty;
template<typename X> typename MediaTransportControls_statics<X>::_ShowAndHideAutomaticallyProperty MediaTransportControls_statics<X>::ShowAndHideAutomaticallyProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsCompactOverlayButtonVisibleProperty MediaTransportControls_statics<X>::IsCompactOverlayButtonVisibleProperty;
template<typename X> typename MediaTransportControls_statics<X>::_IsCompactOverlayEnabledProperty MediaTransportControls_statics<X>::IsCompactOverlayEnabledProperty;

template<typename X> struct statics<MediaTransportControls, X> : X, Windows::UI::Xaml::Controls::MediaTransportControls_statics<void> {
	using Windows::UI::Xaml::Controls::MediaTransportControls_statics<void>::activate;
	typedef typename X::root_type MediaTransportControls;
};
struct MediaTransportControls : generate<MediaTransportControls> {};

// PasswordBox
template<typename> struct PasswordBox_statics {
	static struct _IsPasswordRevealButtonEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PasswordBox, IPasswordBoxStatics>()->_get_IsPasswordRevealButtonEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsPasswordRevealButtonEnabledProperty;
	static struct _MaxLengthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PasswordBox, IPasswordBoxStatics>()->_get_MaxLengthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxLengthProperty;
	static struct _PasswordCharProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PasswordBox, IPasswordBoxStatics>()->_get_PasswordCharProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PasswordCharProperty;
	static struct _PasswordProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PasswordBox, IPasswordBoxStatics>()->_get_PasswordProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PasswordProperty;
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PasswordBox, IPasswordBoxStatics2>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static struct _HeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PasswordBox, IPasswordBoxStatics2>()->_get_HeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTemplateProperty;
	static struct _PlaceholderTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PasswordBox, IPasswordBoxStatics2>()->_get_PlaceholderTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlaceholderTextProperty;
	static struct _PreventKeyboardDisplayOnProgrammaticFocusProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PasswordBox, IPasswordBoxStatics2>()->_get_PreventKeyboardDisplayOnProgrammaticFocusProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PreventKeyboardDisplayOnProgrammaticFocusProperty;
	static struct _SelectionHighlightColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PasswordBox, IPasswordBoxStatics2>()->_get_SelectionHighlightColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectionHighlightColorProperty;
	static struct _InputScopeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PasswordBox, IPasswordBoxStatics3>()->_get_InputScopeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} InputScopeProperty;
	static struct _PasswordRevealModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PasswordBox, IPasswordBoxStatics3>()->_get_PasswordRevealModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PasswordRevealModeProperty;
	static struct _TextReadingOrderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PasswordBox, IPasswordBoxStatics3>()->_get_TextReadingOrderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextReadingOrderProperty;
};
template<typename X> typename PasswordBox_statics<X>::_IsPasswordRevealButtonEnabledProperty PasswordBox_statics<X>::IsPasswordRevealButtonEnabledProperty;
template<typename X> typename PasswordBox_statics<X>::_MaxLengthProperty PasswordBox_statics<X>::MaxLengthProperty;
template<typename X> typename PasswordBox_statics<X>::_PasswordCharProperty PasswordBox_statics<X>::PasswordCharProperty;
template<typename X> typename PasswordBox_statics<X>::_PasswordProperty PasswordBox_statics<X>::PasswordProperty;
template<typename X> typename PasswordBox_statics<X>::_HeaderProperty PasswordBox_statics<X>::HeaderProperty;
template<typename X> typename PasswordBox_statics<X>::_HeaderTemplateProperty PasswordBox_statics<X>::HeaderTemplateProperty;
template<typename X> typename PasswordBox_statics<X>::_PlaceholderTextProperty PasswordBox_statics<X>::PlaceholderTextProperty;
template<typename X> typename PasswordBox_statics<X>::_PreventKeyboardDisplayOnProgrammaticFocusProperty PasswordBox_statics<X>::PreventKeyboardDisplayOnProgrammaticFocusProperty;
template<typename X> typename PasswordBox_statics<X>::_SelectionHighlightColorProperty PasswordBox_statics<X>::SelectionHighlightColorProperty;
template<typename X> typename PasswordBox_statics<X>::_InputScopeProperty PasswordBox_statics<X>::InputScopeProperty;
template<typename X> typename PasswordBox_statics<X>::_PasswordRevealModeProperty PasswordBox_statics<X>::PasswordRevealModeProperty;
template<typename X> typename PasswordBox_statics<X>::_TextReadingOrderProperty PasswordBox_statics<X>::TextReadingOrderProperty;

template<typename X> struct statics<PasswordBox, X> : X, Windows::UI::Xaml::Controls::PasswordBox_statics<void> {
	typedef typename X::root_type PasswordBox;
};
struct PasswordBox : generate<PasswordBox> {};

// ProgressRing
template<typename> struct ProgressRing_statics {
	static struct _IsActiveProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ProgressRing, IProgressRingStatics>()->_get_IsActiveProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsActiveProperty;
};
template<typename X> typename ProgressRing_statics<X>::_IsActiveProperty ProgressRing_statics<X>::IsActiveProperty;

template<typename X> struct statics<ProgressRing, X> : X, Windows::UI::Xaml::Controls::ProgressRing_statics<void> {
	typedef typename X::root_type ProgressRing;
};
struct ProgressRing : generate<ProgressRing> {};

// TextBox
template<typename> struct TextBox_statics {
	static struct _AcceptsReturnProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics>()->_get_AcceptsReturnProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AcceptsReturnProperty;
	static struct _InputScopeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics>()->_get_InputScopeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} InputScopeProperty;
	static struct _IsReadOnlyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics>()->_get_IsReadOnlyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsReadOnlyProperty;
	static struct _IsSpellCheckEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics>()->_get_IsSpellCheckEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsSpellCheckEnabledProperty;
	static struct _IsTextPredictionEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics>()->_get_IsTextPredictionEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTextPredictionEnabledProperty;
	static struct _MaxLengthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics>()->_get_MaxLengthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxLengthProperty;
	static struct _TextAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics>()->_get_TextAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextAlignmentProperty;
	static struct _TextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics>()->_get_TextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextProperty;
	static struct _TextWrappingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics>()->_get_TextWrappingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextWrappingProperty;
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics2>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static struct _HeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics2>()->_get_HeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTemplateProperty;
	static struct _IsColorFontEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics2>()->_get_IsColorFontEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsColorFontEnabledProperty;
	static struct _PlaceholderTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics2>()->_get_PlaceholderTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlaceholderTextProperty;
	static struct _PreventKeyboardDisplayOnProgrammaticFocusProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics2>()->_get_PreventKeyboardDisplayOnProgrammaticFocusProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PreventKeyboardDisplayOnProgrammaticFocusProperty;
	static struct _SelectionHighlightColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics2>()->_get_SelectionHighlightColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectionHighlightColorProperty;
	static struct _DesiredCandidateWindowAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics3>()->_get_DesiredCandidateWindowAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DesiredCandidateWindowAlignmentProperty;
	static struct _TextReadingOrderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics3>()->_get_TextReadingOrderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextReadingOrderProperty;
	static struct _SelectionHighlightColorWhenNotFocusedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics5>()->_get_SelectionHighlightColorWhenNotFocusedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectionHighlightColorWhenNotFocusedProperty;
	static struct _CharacterCasingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics6>()->_get_CharacterCasingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CharacterCasingProperty;
	static struct _HorizontalTextAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics6>()->_get_HorizontalTextAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalTextAlignmentProperty;
	static struct _PlaceholderForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics6>()->_get_PlaceholderForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlaceholderForegroundProperty;
	static struct _HandwritingViewProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics7>()->_get_HandwritingViewProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HandwritingViewProperty;
	static struct _IsHandwritingViewEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TextBox, ITextBoxStatics7>()->_get_IsHandwritingViewEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsHandwritingViewEnabledProperty;
	static TextBox *activate(object_ref outer, IInspectable* *inner) { TextBox *instance; hrcheck(get_activation_factory<TextBox, ITextBoxFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename TextBox_statics<X>::_AcceptsReturnProperty TextBox_statics<X>::AcceptsReturnProperty;
template<typename X> typename TextBox_statics<X>::_InputScopeProperty TextBox_statics<X>::InputScopeProperty;
template<typename X> typename TextBox_statics<X>::_IsReadOnlyProperty TextBox_statics<X>::IsReadOnlyProperty;
template<typename X> typename TextBox_statics<X>::_IsSpellCheckEnabledProperty TextBox_statics<X>::IsSpellCheckEnabledProperty;
template<typename X> typename TextBox_statics<X>::_IsTextPredictionEnabledProperty TextBox_statics<X>::IsTextPredictionEnabledProperty;
template<typename X> typename TextBox_statics<X>::_MaxLengthProperty TextBox_statics<X>::MaxLengthProperty;
template<typename X> typename TextBox_statics<X>::_TextAlignmentProperty TextBox_statics<X>::TextAlignmentProperty;
template<typename X> typename TextBox_statics<X>::_TextProperty TextBox_statics<X>::TextProperty;
template<typename X> typename TextBox_statics<X>::_TextWrappingProperty TextBox_statics<X>::TextWrappingProperty;
template<typename X> typename TextBox_statics<X>::_HeaderProperty TextBox_statics<X>::HeaderProperty;
template<typename X> typename TextBox_statics<X>::_HeaderTemplateProperty TextBox_statics<X>::HeaderTemplateProperty;
template<typename X> typename TextBox_statics<X>::_IsColorFontEnabledProperty TextBox_statics<X>::IsColorFontEnabledProperty;
template<typename X> typename TextBox_statics<X>::_PlaceholderTextProperty TextBox_statics<X>::PlaceholderTextProperty;
template<typename X> typename TextBox_statics<X>::_PreventKeyboardDisplayOnProgrammaticFocusProperty TextBox_statics<X>::PreventKeyboardDisplayOnProgrammaticFocusProperty;
template<typename X> typename TextBox_statics<X>::_SelectionHighlightColorProperty TextBox_statics<X>::SelectionHighlightColorProperty;
template<typename X> typename TextBox_statics<X>::_DesiredCandidateWindowAlignmentProperty TextBox_statics<X>::DesiredCandidateWindowAlignmentProperty;
template<typename X> typename TextBox_statics<X>::_TextReadingOrderProperty TextBox_statics<X>::TextReadingOrderProperty;
template<typename X> typename TextBox_statics<X>::_SelectionHighlightColorWhenNotFocusedProperty TextBox_statics<X>::SelectionHighlightColorWhenNotFocusedProperty;
template<typename X> typename TextBox_statics<X>::_CharacterCasingProperty TextBox_statics<X>::CharacterCasingProperty;
template<typename X> typename TextBox_statics<X>::_HorizontalTextAlignmentProperty TextBox_statics<X>::HorizontalTextAlignmentProperty;
template<typename X> typename TextBox_statics<X>::_PlaceholderForegroundProperty TextBox_statics<X>::PlaceholderForegroundProperty;
template<typename X> typename TextBox_statics<X>::_HandwritingViewProperty TextBox_statics<X>::HandwritingViewProperty;
template<typename X> typename TextBox_statics<X>::_IsHandwritingViewEnabledProperty TextBox_statics<X>::IsHandwritingViewEnabledProperty;

template<typename X> struct statics<TextBox, X> : X, Windows::UI::Xaml::Controls::TextBox_statics<void> {
	using Windows::UI::Xaml::Controls::TextBox_statics<void>::activate;
	typedef typename X::root_type TextBox;
};
struct TextBox : generate<TextBox> {};

// ToggleSwitch
template<typename> struct ToggleSwitch_statics {
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToggleSwitch, IToggleSwitchStatics>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static struct _HeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToggleSwitch, IToggleSwitchStatics>()->_get_HeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTemplateProperty;
	static struct _IsOnProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToggleSwitch, IToggleSwitchStatics>()->_get_IsOnProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsOnProperty;
	static struct _OffContentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToggleSwitch, IToggleSwitchStatics>()->_get_OffContentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OffContentProperty;
	static struct _OffContentTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToggleSwitch, IToggleSwitchStatics>()->_get_OffContentTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OffContentTemplateProperty;
	static struct _OnContentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToggleSwitch, IToggleSwitchStatics>()->_get_OnContentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OnContentProperty;
	static struct _OnContentTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToggleSwitch, IToggleSwitchStatics>()->_get_OnContentTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OnContentTemplateProperty;
};
template<typename X> typename ToggleSwitch_statics<X>::_HeaderProperty ToggleSwitch_statics<X>::HeaderProperty;
template<typename X> typename ToggleSwitch_statics<X>::_HeaderTemplateProperty ToggleSwitch_statics<X>::HeaderTemplateProperty;
template<typename X> typename ToggleSwitch_statics<X>::_IsOnProperty ToggleSwitch_statics<X>::IsOnProperty;
template<typename X> typename ToggleSwitch_statics<X>::_OffContentProperty ToggleSwitch_statics<X>::OffContentProperty;
template<typename X> typename ToggleSwitch_statics<X>::_OffContentTemplateProperty ToggleSwitch_statics<X>::OffContentTemplateProperty;
template<typename X> typename ToggleSwitch_statics<X>::_OnContentProperty ToggleSwitch_statics<X>::OnContentProperty;
template<typename X> typename ToggleSwitch_statics<X>::_OnContentTemplateProperty ToggleSwitch_statics<X>::OnContentTemplateProperty;

template<typename X> struct statics<ToggleSwitch, X> : X, Windows::UI::Xaml::Controls::ToggleSwitch_statics<void> {
	typedef typename X::root_type ToggleSwitch;
};
struct ToggleSwitch : generate<ToggleSwitch> {};

// UserControl
template<typename> struct UserControl_statics {
	static struct _ContentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<UserControl, IUserControlStatics>()->_get_ContentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentProperty;
	static UserControl *activate(object_ref outer, IInspectable* *inner) { UserControl *instance; hrcheck(get_activation_factory<UserControl, IUserControlFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename UserControl_statics<X>::_ContentProperty UserControl_statics<X>::ContentProperty;

template<typename X> struct statics<UserControl, X> : X, Windows::UI::Xaml::Controls::UserControl_statics<void> {
	using Windows::UI::Xaml::Controls::UserControl_statics<void>::activate;
	typedef typename X::root_type UserControl;
};
struct UserControl : generate<UserControl> {};

// GroupItem
template<typename> struct GroupItem_statics {
	static GroupItem *activate(object_ref outer, IInspectable* *inner) { GroupItem *instance; hrcheck(get_activation_factory<GroupItem, IGroupItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<GroupItem, X> : X, Windows::UI::Xaml::Controls::GroupItem_statics<void> {
	using Windows::UI::Xaml::Controls::GroupItem_statics<void>::activate;
	typedef typename X::root_type GroupItem;
};
struct GroupItem : generate<GroupItem> {};

// SettingsFlyout
template<typename> struct SettingsFlyout_statics {
	static struct _HeaderBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SettingsFlyout, ISettingsFlyoutStatics>()->_get_HeaderBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderBackgroundProperty;
	static struct _HeaderForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SettingsFlyout, ISettingsFlyoutStatics>()->_get_HeaderForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderForegroundProperty;
	static struct _IconSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SettingsFlyout, ISettingsFlyoutStatics>()->_get_IconSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IconSourceProperty;
	static struct _TitleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SettingsFlyout, ISettingsFlyoutStatics>()->_get_TitleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TitleProperty;
	static SettingsFlyout *activate(object_ref outer, IInspectable* *inner) { SettingsFlyout *instance; hrcheck(get_activation_factory<SettingsFlyout, ISettingsFlyoutFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename SettingsFlyout_statics<X>::_HeaderBackgroundProperty SettingsFlyout_statics<X>::HeaderBackgroundProperty;
template<typename X> typename SettingsFlyout_statics<X>::_HeaderForegroundProperty SettingsFlyout_statics<X>::HeaderForegroundProperty;
template<typename X> typename SettingsFlyout_statics<X>::_IconSourceProperty SettingsFlyout_statics<X>::IconSourceProperty;
template<typename X> typename SettingsFlyout_statics<X>::_TitleProperty SettingsFlyout_statics<X>::TitleProperty;

template<typename X> struct statics<SettingsFlyout, X> : X, Windows::UI::Xaml::Controls::SettingsFlyout_statics<void> {
	using Windows::UI::Xaml::Controls::SettingsFlyout_statics<void>::activate;
	typedef typename X::root_type SettingsFlyout;
};
struct SettingsFlyout : generate<SettingsFlyout> {};

// ToolTip
template<typename> struct ToolTip_statics {
	static struct _HorizontalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToolTip, IToolTipStatics>()->_get_HorizontalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalOffsetProperty;
	static struct _IsOpenProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToolTip, IToolTipStatics>()->_get_IsOpenProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsOpenProperty;
	static struct _PlacementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToolTip, IToolTipStatics>()->_get_PlacementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlacementProperty;
	static struct _PlacementTargetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToolTip, IToolTipStatics>()->_get_PlacementTargetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlacementTargetProperty;
	static struct _VerticalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToolTip, IToolTipStatics>()->_get_VerticalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalOffsetProperty;
	static ToolTip *activate(object_ref outer, IInspectable* *inner) { ToolTip *instance; hrcheck(get_activation_factory<ToolTip, IToolTipFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename ToolTip_statics<X>::_HorizontalOffsetProperty ToolTip_statics<X>::HorizontalOffsetProperty;
template<typename X> typename ToolTip_statics<X>::_IsOpenProperty ToolTip_statics<X>::IsOpenProperty;
template<typename X> typename ToolTip_statics<X>::_PlacementProperty ToolTip_statics<X>::PlacementProperty;
template<typename X> typename ToolTip_statics<X>::_PlacementTargetProperty ToolTip_statics<X>::PlacementTargetProperty;
template<typename X> typename ToolTip_statics<X>::_VerticalOffsetProperty ToolTip_statics<X>::VerticalOffsetProperty;

template<typename X> struct statics<ToolTip, X> : X, Windows::UI::Xaml::Controls::ToolTip_statics<void> {
	using Windows::UI::Xaml::Controls::ToolTip_statics<void>::activate;
	typedef typename X::root_type ToolTip;
};
struct ToolTip : generate<ToolTip> {};

// ComboBoxItem
template<typename> struct ComboBoxItem_statics {
	static ComboBoxItem *activate(object_ref outer, IInspectable* *inner) { ComboBoxItem *instance; hrcheck(get_activation_factory<ComboBoxItem, IComboBoxItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<ComboBoxItem, X> : X, Windows::UI::Xaml::Controls::ComboBoxItem_statics<void> {
	using Windows::UI::Xaml::Controls::ComboBoxItem_statics<void>::activate;
	typedef typename X::root_type ComboBoxItem;
};
struct ComboBoxItem : generate<ComboBoxItem> {};

// FlipViewItem
template<typename> struct FlipViewItem_statics {
	static FlipViewItem *activate(object_ref outer, IInspectable* *inner) { FlipViewItem *instance; hrcheck(get_activation_factory<FlipViewItem, IFlipViewItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<FlipViewItem, X> : X, Windows::UI::Xaml::Controls::FlipViewItem_statics<void> {
	using Windows::UI::Xaml::Controls::FlipViewItem_statics<void>::activate;
	typedef typename X::root_type FlipViewItem;
};
struct FlipViewItem : generate<FlipViewItem> {};

// ListBoxItem
template<typename> struct ListBoxItem_statics {
	static ListBoxItem *activate(object_ref outer, IInspectable* *inner) { ListBoxItem *instance; hrcheck(get_activation_factory<ListBoxItem, IListBoxItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<ListBoxItem, X> : X, Windows::UI::Xaml::Controls::ListBoxItem_statics<void> {
	using Windows::UI::Xaml::Controls::ListBoxItem_statics<void>::activate;
	typedef typename X::root_type ListBoxItem;
};
struct ListBoxItem : generate<ListBoxItem> {};

// ProgressBar
template<typename> struct ProgressBar_statics {
	static struct _IsIndeterminateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ProgressBar, IProgressBarStatics>()->_get_IsIndeterminateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsIndeterminateProperty;
	static struct _ShowErrorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ProgressBar, IProgressBarStatics>()->_get_ShowErrorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ShowErrorProperty;
	static struct _ShowPausedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ProgressBar, IProgressBarStatics>()->_get_ShowPausedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ShowPausedProperty;
	static ProgressBar *activate(object_ref outer, IInspectable* *inner) { ProgressBar *instance; hrcheck(get_activation_factory<ProgressBar, IProgressBarFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename ProgressBar_statics<X>::_IsIndeterminateProperty ProgressBar_statics<X>::IsIndeterminateProperty;
template<typename X> typename ProgressBar_statics<X>::_ShowErrorProperty ProgressBar_statics<X>::ShowErrorProperty;
template<typename X> typename ProgressBar_statics<X>::_ShowPausedProperty ProgressBar_statics<X>::ShowPausedProperty;

template<typename X> struct statics<ProgressBar, X> : X, Windows::UI::Xaml::Controls::ProgressBar_statics<void> {
	using Windows::UI::Xaml::Controls::ProgressBar_statics<void>::activate;
	typedef typename X::root_type ProgressBar;
};
struct ProgressBar : generate<ProgressBar> {};

// Button
template<typename> struct Button_statics {
	static struct _FlyoutProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Button, IButtonStaticsWithFlyout>()->_get_FlyoutProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FlyoutProperty;
	static Button *activate(object_ref outer, IInspectable* *inner) { Button *instance; hrcheck(get_activation_factory<Button, IButtonFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename Button_statics<X>::_FlyoutProperty Button_statics<X>::FlyoutProperty;

template<typename X> struct statics<Button, X> : X, Windows::UI::Xaml::Controls::Button_statics<void> {
	using Windows::UI::Xaml::Controls::Button_statics<void>::activate;
	typedef typename X::root_type Button;
};
struct Button : generate<Button> {};

// HyperlinkButton
template<typename> struct HyperlinkButton_statics {
	static struct _NavigateUriProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<HyperlinkButton, IHyperlinkButtonStatics>()->_get_NavigateUriProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} NavigateUriProperty;
	static HyperlinkButton *activate(object_ref outer, IInspectable* *inner) { HyperlinkButton *instance; hrcheck(get_activation_factory<HyperlinkButton, IHyperlinkButtonFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename HyperlinkButton_statics<X>::_NavigateUriProperty HyperlinkButton_statics<X>::NavigateUriProperty;

template<typename X> struct statics<HyperlinkButton, X> : X, Windows::UI::Xaml::Controls::HyperlinkButton_statics<void> {
	using Windows::UI::Xaml::Controls::HyperlinkButton_statics<void>::activate;
	typedef typename X::root_type HyperlinkButton;
};
struct HyperlinkButton : generate<HyperlinkButton> {};

// ListViewBase
template<typename> struct ListViewBase_statics {
	static struct _CanDragItemsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics>()->_get_CanDragItemsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CanDragItemsProperty;
	static struct _CanReorderItemsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics>()->_get_CanReorderItemsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CanReorderItemsProperty;
	static struct _DataFetchSizeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics>()->_get_DataFetchSizeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DataFetchSizeProperty;
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static struct _HeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics>()->_get_HeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTemplateProperty;
	static struct _HeaderTransitionsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics>()->_get_HeaderTransitionsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTransitionsProperty;
	static struct _IncrementalLoadingThresholdProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics>()->_get_IncrementalLoadingThresholdProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IncrementalLoadingThresholdProperty;
	static struct _IncrementalLoadingTriggerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics>()->_get_IncrementalLoadingTriggerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IncrementalLoadingTriggerProperty;
	static struct _IsActiveViewProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics>()->_get_IsActiveViewProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsActiveViewProperty;
	static struct _IsItemClickEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics>()->_get_IsItemClickEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsItemClickEnabledProperty;
	static struct _IsSwipeEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics>()->_get_IsSwipeEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsSwipeEnabledProperty;
	static struct _IsZoomedInViewProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics>()->_get_IsZoomedInViewProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsZoomedInViewProperty;
	static struct _SelectionModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics>()->_get_SelectionModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectionModeProperty;
	static struct _SemanticZoomOwnerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics>()->_get_SemanticZoomOwnerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SemanticZoomOwnerProperty;
	static struct _FooterProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics2>()->_get_FooterProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FooterProperty;
	static struct _FooterTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics2>()->_get_FooterTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FooterTemplateProperty;
	static struct _FooterTransitionsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics2>()->_get_FooterTransitionsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FooterTransitionsProperty;
	static struct _ShowsScrollingPlaceholdersProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics2>()->_get_ShowsScrollingPlaceholdersProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ShowsScrollingPlaceholdersProperty;
	static struct _ReorderModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics3>()->_get_ReorderModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ReorderModeProperty;
	static struct _IsMultiSelectCheckBoxEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics4>()->_get_IsMultiSelectCheckBoxEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsMultiSelectCheckBoxEnabledProperty;
	static struct _SingleSelectionFollowsFocusProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListViewBase, IListViewBaseStatics5>()->_get_SingleSelectionFollowsFocusProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SingleSelectionFollowsFocusProperty;
};
template<typename X> typename ListViewBase_statics<X>::_CanDragItemsProperty ListViewBase_statics<X>::CanDragItemsProperty;
template<typename X> typename ListViewBase_statics<X>::_CanReorderItemsProperty ListViewBase_statics<X>::CanReorderItemsProperty;
template<typename X> typename ListViewBase_statics<X>::_DataFetchSizeProperty ListViewBase_statics<X>::DataFetchSizeProperty;
template<typename X> typename ListViewBase_statics<X>::_HeaderProperty ListViewBase_statics<X>::HeaderProperty;
template<typename X> typename ListViewBase_statics<X>::_HeaderTemplateProperty ListViewBase_statics<X>::HeaderTemplateProperty;
template<typename X> typename ListViewBase_statics<X>::_HeaderTransitionsProperty ListViewBase_statics<X>::HeaderTransitionsProperty;
template<typename X> typename ListViewBase_statics<X>::_IncrementalLoadingThresholdProperty ListViewBase_statics<X>::IncrementalLoadingThresholdProperty;
template<typename X> typename ListViewBase_statics<X>::_IncrementalLoadingTriggerProperty ListViewBase_statics<X>::IncrementalLoadingTriggerProperty;
template<typename X> typename ListViewBase_statics<X>::_IsActiveViewProperty ListViewBase_statics<X>::IsActiveViewProperty;
template<typename X> typename ListViewBase_statics<X>::_IsItemClickEnabledProperty ListViewBase_statics<X>::IsItemClickEnabledProperty;
template<typename X> typename ListViewBase_statics<X>::_IsSwipeEnabledProperty ListViewBase_statics<X>::IsSwipeEnabledProperty;
template<typename X> typename ListViewBase_statics<X>::_IsZoomedInViewProperty ListViewBase_statics<X>::IsZoomedInViewProperty;
template<typename X> typename ListViewBase_statics<X>::_SelectionModeProperty ListViewBase_statics<X>::SelectionModeProperty;
template<typename X> typename ListViewBase_statics<X>::_SemanticZoomOwnerProperty ListViewBase_statics<X>::SemanticZoomOwnerProperty;
template<typename X> typename ListViewBase_statics<X>::_FooterProperty ListViewBase_statics<X>::FooterProperty;
template<typename X> typename ListViewBase_statics<X>::_FooterTemplateProperty ListViewBase_statics<X>::FooterTemplateProperty;
template<typename X> typename ListViewBase_statics<X>::_FooterTransitionsProperty ListViewBase_statics<X>::FooterTransitionsProperty;
template<typename X> typename ListViewBase_statics<X>::_ShowsScrollingPlaceholdersProperty ListViewBase_statics<X>::ShowsScrollingPlaceholdersProperty;
template<typename X> typename ListViewBase_statics<X>::_ReorderModeProperty ListViewBase_statics<X>::ReorderModeProperty;
template<typename X> typename ListViewBase_statics<X>::_IsMultiSelectCheckBoxEnabledProperty ListViewBase_statics<X>::IsMultiSelectCheckBoxEnabledProperty;
template<typename X> typename ListViewBase_statics<X>::_SingleSelectionFollowsFocusProperty ListViewBase_statics<X>::SingleSelectionFollowsFocusProperty;

template<typename X> struct statics<ListViewBase, X> : X, Windows::UI::Xaml::Controls::ListViewBase_statics<void> {
	typedef typename X::root_type ListViewBase;
};
struct ListViewBase : generate<ListViewBase> {
	using IListViewBase::ScrollIntoView;
};

// ComboBox
template<typename> struct ComboBox_statics {
	static struct _IsDropDownOpenProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ComboBox, IComboBoxStatics>()->_get_IsDropDownOpenProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsDropDownOpenProperty;
	static struct _MaxDropDownHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ComboBox, IComboBoxStatics>()->_get_MaxDropDownHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxDropDownHeightProperty;
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ComboBox, IComboBoxStatics2>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static struct _HeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ComboBox, IComboBoxStatics2>()->_get_HeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTemplateProperty;
	static struct _PlaceholderTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ComboBox, IComboBoxStatics2>()->_get_PlaceholderTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlaceholderTextProperty;
	static struct _IsTextSearchEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ComboBox, IComboBoxStatics3>()->_get_IsTextSearchEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTextSearchEnabledProperty;
	static struct _LightDismissOverlayModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ComboBox, IComboBoxStatics3>()->_get_LightDismissOverlayModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LightDismissOverlayModeProperty;
	static struct _SelectionChangedTriggerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ComboBox, IComboBoxStatics4>()->_get_SelectionChangedTriggerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectionChangedTriggerProperty;
	static struct _PlaceholderForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ComboBox, IComboBoxStatics5>()->_get_PlaceholderForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlaceholderForegroundProperty;
	static ComboBox *activate(object_ref outer, IInspectable* *inner) { ComboBox *instance; hrcheck(get_activation_factory<ComboBox, IComboBoxFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename ComboBox_statics<X>::_IsDropDownOpenProperty ComboBox_statics<X>::IsDropDownOpenProperty;
template<typename X> typename ComboBox_statics<X>::_MaxDropDownHeightProperty ComboBox_statics<X>::MaxDropDownHeightProperty;
template<typename X> typename ComboBox_statics<X>::_HeaderProperty ComboBox_statics<X>::HeaderProperty;
template<typename X> typename ComboBox_statics<X>::_HeaderTemplateProperty ComboBox_statics<X>::HeaderTemplateProperty;
template<typename X> typename ComboBox_statics<X>::_PlaceholderTextProperty ComboBox_statics<X>::PlaceholderTextProperty;
template<typename X> typename ComboBox_statics<X>::_IsTextSearchEnabledProperty ComboBox_statics<X>::IsTextSearchEnabledProperty;
template<typename X> typename ComboBox_statics<X>::_LightDismissOverlayModeProperty ComboBox_statics<X>::LightDismissOverlayModeProperty;
template<typename X> typename ComboBox_statics<X>::_SelectionChangedTriggerProperty ComboBox_statics<X>::SelectionChangedTriggerProperty;
template<typename X> typename ComboBox_statics<X>::_PlaceholderForegroundProperty ComboBox_statics<X>::PlaceholderForegroundProperty;

template<typename X> struct statics<ComboBox, X> : X, Windows::UI::Xaml::Controls::ComboBox_statics<void> {
	using Windows::UI::Xaml::Controls::ComboBox_statics<void>::activate;
	typedef typename X::root_type ComboBox;
};
struct ComboBox : generate<ComboBox> {};

// FlipView
template<typename> struct FlipView_statics {
	static struct _UseTouchAnimationsForAllNavigationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<FlipView, IFlipViewStatics2>()->_get_UseTouchAnimationsForAllNavigationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} UseTouchAnimationsForAllNavigationProperty;
	static FlipView *activate(object_ref outer, IInspectable* *inner) { FlipView *instance; hrcheck(get_activation_factory<FlipView, IFlipViewFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename FlipView_statics<X>::_UseTouchAnimationsForAllNavigationProperty FlipView_statics<X>::UseTouchAnimationsForAllNavigationProperty;

template<typename X> struct statics<FlipView, X> : X, Windows::UI::Xaml::Controls::FlipView_statics<void> {
	using Windows::UI::Xaml::Controls::FlipView_statics<void>::activate;
	typedef typename X::root_type FlipView;
};
struct FlipView : generate<FlipView> {};

// ListBox
template<typename> struct ListBox_statics {
	static struct _SelectionModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListBox, IListBoxStatics>()->_get_SelectionModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectionModeProperty;
	static struct _SingleSelectionFollowsFocusProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListBox, IListBoxStatics2>()->_get_SingleSelectionFollowsFocusProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SingleSelectionFollowsFocusProperty;
	static ListBox *activate(object_ref outer, IInspectable* *inner) { ListBox *instance; hrcheck(get_activation_factory<ListBox, IListBoxFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename ListBox_statics<X>::_SelectionModeProperty ListBox_statics<X>::SelectionModeProperty;
template<typename X> typename ListBox_statics<X>::_SingleSelectionFollowsFocusProperty ListBox_statics<X>::SingleSelectionFollowsFocusProperty;

template<typename X> struct statics<ListBox, X> : X, Windows::UI::Xaml::Controls::ListBox_statics<void> {
	using Windows::UI::Xaml::Controls::ListBox_statics<void>::activate;
	typedef typename X::root_type ListBox;
};
struct ListBox : generate<ListBox> {};

// CheckBox
template<typename> struct CheckBox_statics {
	static CheckBox *activate(object_ref outer, IInspectable* *inner) { CheckBox *instance; hrcheck(get_activation_factory<CheckBox, ICheckBoxFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<CheckBox, X> : X, Windows::UI::Xaml::Controls::CheckBox_statics<void> {
	using Windows::UI::Xaml::Controls::CheckBox_statics<void>::activate;
	typedef typename X::root_type CheckBox;
};
struct CheckBox : generate<CheckBox> {};

// RadioButton
template<typename> struct RadioButton_statics {
	static struct _GroupNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RadioButton, IRadioButtonStatics>()->_get_GroupNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GroupNameProperty;
	static RadioButton *activate(object_ref outer, IInspectable* *inner) { RadioButton *instance; hrcheck(get_activation_factory<RadioButton, IRadioButtonFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename RadioButton_statics<X>::_GroupNameProperty RadioButton_statics<X>::GroupNameProperty;

template<typename X> struct statics<RadioButton, X> : X, Windows::UI::Xaml::Controls::RadioButton_statics<void> {
	using Windows::UI::Xaml::Controls::RadioButton_statics<void>::activate;
	typedef typename X::root_type RadioButton;
};
struct RadioButton : generate<RadioButton> {};

// CalendarView
template<typename> struct CalendarView_statics {
	static struct _BlackoutForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_BlackoutForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BlackoutForegroundProperty;
	static struct _CalendarIdentifierProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_CalendarIdentifierProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CalendarIdentifierProperty;
	static struct _CalendarItemBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_CalendarItemBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CalendarItemBackgroundProperty;
	static struct _CalendarItemBorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_CalendarItemBorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CalendarItemBorderBrushProperty;
	static struct _CalendarItemBorderThicknessProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_CalendarItemBorderThicknessProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CalendarItemBorderThicknessProperty;
	static struct _CalendarItemForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_CalendarItemForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CalendarItemForegroundProperty;
	static struct _CalendarViewDayItemStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_CalendarViewDayItemStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CalendarViewDayItemStyleProperty;
	static struct _DayItemFontFamilyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_DayItemFontFamilyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DayItemFontFamilyProperty;
	static struct _DayItemFontSizeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_DayItemFontSizeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DayItemFontSizeProperty;
	static struct _DayItemFontStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_DayItemFontStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DayItemFontStyleProperty;
	static struct _DayItemFontWeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_DayItemFontWeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DayItemFontWeightProperty;
	static struct _DayOfWeekFormatProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_DayOfWeekFormatProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DayOfWeekFormatProperty;
	static struct _DisplayModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_DisplayModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DisplayModeProperty;
	static struct _FirstDayOfWeekProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_FirstDayOfWeekProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FirstDayOfWeekProperty;
	static struct _FirstOfMonthLabelFontFamilyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_FirstOfMonthLabelFontFamilyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FirstOfMonthLabelFontFamilyProperty;
	static struct _FirstOfMonthLabelFontSizeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_FirstOfMonthLabelFontSizeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FirstOfMonthLabelFontSizeProperty;
	static struct _FirstOfMonthLabelFontStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_FirstOfMonthLabelFontStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FirstOfMonthLabelFontStyleProperty;
	static struct _FirstOfMonthLabelFontWeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_FirstOfMonthLabelFontWeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FirstOfMonthLabelFontWeightProperty;
	static struct _FirstOfYearDecadeLabelFontFamilyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_FirstOfYearDecadeLabelFontFamilyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FirstOfYearDecadeLabelFontFamilyProperty;
	static struct _FirstOfYearDecadeLabelFontSizeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_FirstOfYearDecadeLabelFontSizeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FirstOfYearDecadeLabelFontSizeProperty;
	static struct _FirstOfYearDecadeLabelFontStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_FirstOfYearDecadeLabelFontStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FirstOfYearDecadeLabelFontStyleProperty;
	static struct _FirstOfYearDecadeLabelFontWeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_FirstOfYearDecadeLabelFontWeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FirstOfYearDecadeLabelFontWeightProperty;
	static struct _FocusBorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_FocusBorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FocusBorderBrushProperty;
	static struct _HorizontalDayItemAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_HorizontalDayItemAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalDayItemAlignmentProperty;
	static struct _HorizontalFirstOfMonthLabelAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_HorizontalFirstOfMonthLabelAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalFirstOfMonthLabelAlignmentProperty;
	static struct _HoverBorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_HoverBorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HoverBorderBrushProperty;
	static struct _IsGroupLabelVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_IsGroupLabelVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsGroupLabelVisibleProperty;
	static struct _IsOutOfScopeEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_IsOutOfScopeEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsOutOfScopeEnabledProperty;
	static struct _IsTodayHighlightedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_IsTodayHighlightedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTodayHighlightedProperty;
	static struct _MaxDateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_MaxDateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxDateProperty;
	static struct _MinDateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_MinDateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinDateProperty;
	static struct _MonthYearItemFontFamilyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_MonthYearItemFontFamilyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MonthYearItemFontFamilyProperty;
	static struct _MonthYearItemFontSizeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_MonthYearItemFontSizeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MonthYearItemFontSizeProperty;
	static struct _MonthYearItemFontStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_MonthYearItemFontStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MonthYearItemFontStyleProperty;
	static struct _MonthYearItemFontWeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_MonthYearItemFontWeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MonthYearItemFontWeightProperty;
	static struct _NumberOfWeeksInViewProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_NumberOfWeeksInViewProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} NumberOfWeeksInViewProperty;
	static struct _OutOfScopeBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_OutOfScopeBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OutOfScopeBackgroundProperty;
	static struct _OutOfScopeForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_OutOfScopeForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OutOfScopeForegroundProperty;
	static struct _PressedBorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_PressedBorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PressedBorderBrushProperty;
	static struct _PressedForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_PressedForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PressedForegroundProperty;
	static struct _SelectedBorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_SelectedBorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedBorderBrushProperty;
	static struct _SelectedDatesProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_SelectedDatesProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedDatesProperty;
	static struct _SelectedForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_SelectedForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedForegroundProperty;
	static struct _SelectedHoverBorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_SelectedHoverBorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedHoverBorderBrushProperty;
	static struct _SelectedPressedBorderBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_SelectedPressedBorderBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedPressedBorderBrushProperty;
	static struct _SelectionModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_SelectionModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectionModeProperty;
	static struct _TemplateSettingsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_TemplateSettingsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TemplateSettingsProperty;
	static struct _TodayFontWeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_TodayFontWeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TodayFontWeightProperty;
	static struct _TodayForegroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_TodayForegroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TodayForegroundProperty;
	static struct _VerticalDayItemAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_VerticalDayItemAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalDayItemAlignmentProperty;
	static struct _VerticalFirstOfMonthLabelAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarView, ICalendarViewStatics>()->_get_VerticalFirstOfMonthLabelAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalFirstOfMonthLabelAlignmentProperty;
	static CalendarView *activate(object_ref outer, IInspectable* *inner) { CalendarView *instance; hrcheck(get_activation_factory<CalendarView, ICalendarViewFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename CalendarView_statics<X>::_BlackoutForegroundProperty CalendarView_statics<X>::BlackoutForegroundProperty;
template<typename X> typename CalendarView_statics<X>::_CalendarIdentifierProperty CalendarView_statics<X>::CalendarIdentifierProperty;
template<typename X> typename CalendarView_statics<X>::_CalendarItemBackgroundProperty CalendarView_statics<X>::CalendarItemBackgroundProperty;
template<typename X> typename CalendarView_statics<X>::_CalendarItemBorderBrushProperty CalendarView_statics<X>::CalendarItemBorderBrushProperty;
template<typename X> typename CalendarView_statics<X>::_CalendarItemBorderThicknessProperty CalendarView_statics<X>::CalendarItemBorderThicknessProperty;
template<typename X> typename CalendarView_statics<X>::_CalendarItemForegroundProperty CalendarView_statics<X>::CalendarItemForegroundProperty;
template<typename X> typename CalendarView_statics<X>::_CalendarViewDayItemStyleProperty CalendarView_statics<X>::CalendarViewDayItemStyleProperty;
template<typename X> typename CalendarView_statics<X>::_DayItemFontFamilyProperty CalendarView_statics<X>::DayItemFontFamilyProperty;
template<typename X> typename CalendarView_statics<X>::_DayItemFontSizeProperty CalendarView_statics<X>::DayItemFontSizeProperty;
template<typename X> typename CalendarView_statics<X>::_DayItemFontStyleProperty CalendarView_statics<X>::DayItemFontStyleProperty;
template<typename X> typename CalendarView_statics<X>::_DayItemFontWeightProperty CalendarView_statics<X>::DayItemFontWeightProperty;
template<typename X> typename CalendarView_statics<X>::_DayOfWeekFormatProperty CalendarView_statics<X>::DayOfWeekFormatProperty;
template<typename X> typename CalendarView_statics<X>::_DisplayModeProperty CalendarView_statics<X>::DisplayModeProperty;
template<typename X> typename CalendarView_statics<X>::_FirstDayOfWeekProperty CalendarView_statics<X>::FirstDayOfWeekProperty;
template<typename X> typename CalendarView_statics<X>::_FirstOfMonthLabelFontFamilyProperty CalendarView_statics<X>::FirstOfMonthLabelFontFamilyProperty;
template<typename X> typename CalendarView_statics<X>::_FirstOfMonthLabelFontSizeProperty CalendarView_statics<X>::FirstOfMonthLabelFontSizeProperty;
template<typename X> typename CalendarView_statics<X>::_FirstOfMonthLabelFontStyleProperty CalendarView_statics<X>::FirstOfMonthLabelFontStyleProperty;
template<typename X> typename CalendarView_statics<X>::_FirstOfMonthLabelFontWeightProperty CalendarView_statics<X>::FirstOfMonthLabelFontWeightProperty;
template<typename X> typename CalendarView_statics<X>::_FirstOfYearDecadeLabelFontFamilyProperty CalendarView_statics<X>::FirstOfYearDecadeLabelFontFamilyProperty;
template<typename X> typename CalendarView_statics<X>::_FirstOfYearDecadeLabelFontSizeProperty CalendarView_statics<X>::FirstOfYearDecadeLabelFontSizeProperty;
template<typename X> typename CalendarView_statics<X>::_FirstOfYearDecadeLabelFontStyleProperty CalendarView_statics<X>::FirstOfYearDecadeLabelFontStyleProperty;
template<typename X> typename CalendarView_statics<X>::_FirstOfYearDecadeLabelFontWeightProperty CalendarView_statics<X>::FirstOfYearDecadeLabelFontWeightProperty;
template<typename X> typename CalendarView_statics<X>::_FocusBorderBrushProperty CalendarView_statics<X>::FocusBorderBrushProperty;
template<typename X> typename CalendarView_statics<X>::_HorizontalDayItemAlignmentProperty CalendarView_statics<X>::HorizontalDayItemAlignmentProperty;
template<typename X> typename CalendarView_statics<X>::_HorizontalFirstOfMonthLabelAlignmentProperty CalendarView_statics<X>::HorizontalFirstOfMonthLabelAlignmentProperty;
template<typename X> typename CalendarView_statics<X>::_HoverBorderBrushProperty CalendarView_statics<X>::HoverBorderBrushProperty;
template<typename X> typename CalendarView_statics<X>::_IsGroupLabelVisibleProperty CalendarView_statics<X>::IsGroupLabelVisibleProperty;
template<typename X> typename CalendarView_statics<X>::_IsOutOfScopeEnabledProperty CalendarView_statics<X>::IsOutOfScopeEnabledProperty;
template<typename X> typename CalendarView_statics<X>::_IsTodayHighlightedProperty CalendarView_statics<X>::IsTodayHighlightedProperty;
template<typename X> typename CalendarView_statics<X>::_MaxDateProperty CalendarView_statics<X>::MaxDateProperty;
template<typename X> typename CalendarView_statics<X>::_MinDateProperty CalendarView_statics<X>::MinDateProperty;
template<typename X> typename CalendarView_statics<X>::_MonthYearItemFontFamilyProperty CalendarView_statics<X>::MonthYearItemFontFamilyProperty;
template<typename X> typename CalendarView_statics<X>::_MonthYearItemFontSizeProperty CalendarView_statics<X>::MonthYearItemFontSizeProperty;
template<typename X> typename CalendarView_statics<X>::_MonthYearItemFontStyleProperty CalendarView_statics<X>::MonthYearItemFontStyleProperty;
template<typename X> typename CalendarView_statics<X>::_MonthYearItemFontWeightProperty CalendarView_statics<X>::MonthYearItemFontWeightProperty;
template<typename X> typename CalendarView_statics<X>::_NumberOfWeeksInViewProperty CalendarView_statics<X>::NumberOfWeeksInViewProperty;
template<typename X> typename CalendarView_statics<X>::_OutOfScopeBackgroundProperty CalendarView_statics<X>::OutOfScopeBackgroundProperty;
template<typename X> typename CalendarView_statics<X>::_OutOfScopeForegroundProperty CalendarView_statics<X>::OutOfScopeForegroundProperty;
template<typename X> typename CalendarView_statics<X>::_PressedBorderBrushProperty CalendarView_statics<X>::PressedBorderBrushProperty;
template<typename X> typename CalendarView_statics<X>::_PressedForegroundProperty CalendarView_statics<X>::PressedForegroundProperty;
template<typename X> typename CalendarView_statics<X>::_SelectedBorderBrushProperty CalendarView_statics<X>::SelectedBorderBrushProperty;
template<typename X> typename CalendarView_statics<X>::_SelectedDatesProperty CalendarView_statics<X>::SelectedDatesProperty;
template<typename X> typename CalendarView_statics<X>::_SelectedForegroundProperty CalendarView_statics<X>::SelectedForegroundProperty;
template<typename X> typename CalendarView_statics<X>::_SelectedHoverBorderBrushProperty CalendarView_statics<X>::SelectedHoverBorderBrushProperty;
template<typename X> typename CalendarView_statics<X>::_SelectedPressedBorderBrushProperty CalendarView_statics<X>::SelectedPressedBorderBrushProperty;
template<typename X> typename CalendarView_statics<X>::_SelectionModeProperty CalendarView_statics<X>::SelectionModeProperty;
template<typename X> typename CalendarView_statics<X>::_TemplateSettingsProperty CalendarView_statics<X>::TemplateSettingsProperty;
template<typename X> typename CalendarView_statics<X>::_TodayFontWeightProperty CalendarView_statics<X>::TodayFontWeightProperty;
template<typename X> typename CalendarView_statics<X>::_TodayForegroundProperty CalendarView_statics<X>::TodayForegroundProperty;
template<typename X> typename CalendarView_statics<X>::_VerticalDayItemAlignmentProperty CalendarView_statics<X>::VerticalDayItemAlignmentProperty;
template<typename X> typename CalendarView_statics<X>::_VerticalFirstOfMonthLabelAlignmentProperty CalendarView_statics<X>::VerticalFirstOfMonthLabelAlignmentProperty;

template<typename X> struct statics<CalendarView, X> : X, Windows::UI::Xaml::Controls::CalendarView_statics<void> {
	using Windows::UI::Xaml::Controls::CalendarView_statics<void>::activate;
	typedef typename X::root_type CalendarView;
};
struct CalendarView : generate<CalendarView> {};

// CalendarViewDayItem
template<typename> struct CalendarViewDayItem_statics {
	static struct _DateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarViewDayItem, ICalendarViewDayItemStatics>()->_get_DateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DateProperty;
	static struct _IsBlackoutProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarViewDayItem, ICalendarViewDayItemStatics>()->_get_IsBlackoutProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsBlackoutProperty;
	static CalendarViewDayItem *activate(object_ref outer, IInspectable* *inner) { CalendarViewDayItem *instance; hrcheck(get_activation_factory<CalendarViewDayItem, ICalendarViewDayItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename CalendarViewDayItem_statics<X>::_DateProperty CalendarViewDayItem_statics<X>::DateProperty;
template<typename X> typename CalendarViewDayItem_statics<X>::_IsBlackoutProperty CalendarViewDayItem_statics<X>::IsBlackoutProperty;

template<typename X> struct statics<CalendarViewDayItem, X> : X, Windows::UI::Xaml::Controls::CalendarViewDayItem_statics<void> {
	using Windows::UI::Xaml::Controls::CalendarViewDayItem_statics<void>::activate;
	typedef typename X::root_type CalendarViewDayItem;
};
struct CalendarViewDayItem : generate<CalendarViewDayItem> {};

// MenuFlyoutItemBase
template<typename X> struct statics<MenuFlyoutItemBase, X> : X {
	typedef typename X::root_type MenuFlyoutItemBase;
};
struct MenuFlyoutItemBase : generate<MenuFlyoutItemBase> {};

// AppBarSeparator
template<typename> struct AppBarSeparator_statics {
	static struct _IsCompactProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarSeparator, IAppBarSeparatorStatics>()->_get_IsCompactProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsCompactProperty;
	static struct _DynamicOverflowOrderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarSeparator, IAppBarSeparatorStatics3>()->_get_DynamicOverflowOrderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DynamicOverflowOrderProperty;
	static struct _IsInOverflowProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarSeparator, IAppBarSeparatorStatics3>()->_get_IsInOverflowProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsInOverflowProperty;
	static AppBarSeparator *activate(object_ref outer, IInspectable* *inner) { AppBarSeparator *instance; hrcheck(get_activation_factory<AppBarSeparator, IAppBarSeparatorFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename AppBarSeparator_statics<X>::_IsCompactProperty AppBarSeparator_statics<X>::IsCompactProperty;
template<typename X> typename AppBarSeparator_statics<X>::_DynamicOverflowOrderProperty AppBarSeparator_statics<X>::DynamicOverflowOrderProperty;
template<typename X> typename AppBarSeparator_statics<X>::_IsInOverflowProperty AppBarSeparator_statics<X>::IsInOverflowProperty;

template<typename X> struct statics<AppBarSeparator, X> : X, Windows::UI::Xaml::Controls::AppBarSeparator_statics<void> {
	using Windows::UI::Xaml::Controls::AppBarSeparator_statics<void>::activate;
	typedef typename X::root_type AppBarSeparator;
};
struct AppBarSeparator : generate<AppBarSeparator> {};

// CalendarDatePicker
template<typename> struct CalendarDatePicker_statics {
	static struct _CalendarIdentifierProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_CalendarIdentifierProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CalendarIdentifierProperty;
	static struct _CalendarViewStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_CalendarViewStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CalendarViewStyleProperty;
	static struct _DateFormatProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_DateFormatProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DateFormatProperty;
	static struct _DateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_DateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DateProperty;
	static struct _DayOfWeekFormatProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_DayOfWeekFormatProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DayOfWeekFormatProperty;
	static struct _DisplayModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_DisplayModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DisplayModeProperty;
	static struct _FirstDayOfWeekProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_FirstDayOfWeekProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FirstDayOfWeekProperty;
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static struct _HeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_HeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTemplateProperty;
	static struct _IsCalendarOpenProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_IsCalendarOpenProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsCalendarOpenProperty;
	static struct _IsGroupLabelVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_IsGroupLabelVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsGroupLabelVisibleProperty;
	static struct _IsOutOfScopeEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_IsOutOfScopeEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsOutOfScopeEnabledProperty;
	static struct _IsTodayHighlightedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_IsTodayHighlightedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTodayHighlightedProperty;
	static struct _MaxDateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_MaxDateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxDateProperty;
	static struct _MinDateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_MinDateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinDateProperty;
	static struct _PlaceholderTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics>()->_get_PlaceholderTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlaceholderTextProperty;
	static struct _LightDismissOverlayModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerStatics2>()->_get_LightDismissOverlayModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LightDismissOverlayModeProperty;
	static CalendarDatePicker *activate(object_ref outer, IInspectable* *inner) { CalendarDatePicker *instance; hrcheck(get_activation_factory<CalendarDatePicker, ICalendarDatePickerFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename CalendarDatePicker_statics<X>::_CalendarIdentifierProperty CalendarDatePicker_statics<X>::CalendarIdentifierProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_CalendarViewStyleProperty CalendarDatePicker_statics<X>::CalendarViewStyleProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_DateFormatProperty CalendarDatePicker_statics<X>::DateFormatProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_DateProperty CalendarDatePicker_statics<X>::DateProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_DayOfWeekFormatProperty CalendarDatePicker_statics<X>::DayOfWeekFormatProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_DisplayModeProperty CalendarDatePicker_statics<X>::DisplayModeProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_FirstDayOfWeekProperty CalendarDatePicker_statics<X>::FirstDayOfWeekProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_HeaderProperty CalendarDatePicker_statics<X>::HeaderProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_HeaderTemplateProperty CalendarDatePicker_statics<X>::HeaderTemplateProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_IsCalendarOpenProperty CalendarDatePicker_statics<X>::IsCalendarOpenProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_IsGroupLabelVisibleProperty CalendarDatePicker_statics<X>::IsGroupLabelVisibleProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_IsOutOfScopeEnabledProperty CalendarDatePicker_statics<X>::IsOutOfScopeEnabledProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_IsTodayHighlightedProperty CalendarDatePicker_statics<X>::IsTodayHighlightedProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_MaxDateProperty CalendarDatePicker_statics<X>::MaxDateProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_MinDateProperty CalendarDatePicker_statics<X>::MinDateProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_PlaceholderTextProperty CalendarDatePicker_statics<X>::PlaceholderTextProperty;
template<typename X> typename CalendarDatePicker_statics<X>::_LightDismissOverlayModeProperty CalendarDatePicker_statics<X>::LightDismissOverlayModeProperty;

template<typename X> struct statics<CalendarDatePicker, X> : X, Windows::UI::Xaml::Controls::CalendarDatePicker_statics<void> {
	using Windows::UI::Xaml::Controls::CalendarDatePicker_statics<void>::activate;
	typedef typename X::root_type CalendarDatePicker;
};
struct CalendarDatePicker : generate<CalendarDatePicker> {};

// DatePicker
template<typename> struct DatePicker_statics {
	static struct _CalendarIdentifierProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePicker, IDatePickerStatics>()->_get_CalendarIdentifierProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CalendarIdentifierProperty;
	static struct _DateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePicker, IDatePickerStatics>()->_get_DateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DateProperty;
	static struct _DayFormatProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePicker, IDatePickerStatics>()->_get_DayFormatProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DayFormatProperty;
	static struct _DayVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePicker, IDatePickerStatics>()->_get_DayVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DayVisibleProperty;
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePicker, IDatePickerStatics>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static struct _HeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePicker, IDatePickerStatics>()->_get_HeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTemplateProperty;
	static struct _MaxYearProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePicker, IDatePickerStatics>()->_get_MaxYearProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxYearProperty;
	static struct _MinYearProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePicker, IDatePickerStatics>()->_get_MinYearProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinYearProperty;
	static struct _MonthFormatProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePicker, IDatePickerStatics>()->_get_MonthFormatProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MonthFormatProperty;
	static struct _MonthVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePicker, IDatePickerStatics>()->_get_MonthVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MonthVisibleProperty;
	static struct _OrientationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePicker, IDatePickerStatics>()->_get_OrientationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OrientationProperty;
	static struct _YearFormatProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePicker, IDatePickerStatics>()->_get_YearFormatProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} YearFormatProperty;
	static struct _YearVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePicker, IDatePickerStatics>()->_get_YearVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} YearVisibleProperty;
	static struct _LightDismissOverlayModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePicker, IDatePickerStatics2>()->_get_LightDismissOverlayModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LightDismissOverlayModeProperty;
	static DatePicker *activate(object_ref outer, IInspectable* *inner) { DatePicker *instance; hrcheck(get_activation_factory<DatePicker, IDatePickerFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename DatePicker_statics<X>::_CalendarIdentifierProperty DatePicker_statics<X>::CalendarIdentifierProperty;
template<typename X> typename DatePicker_statics<X>::_DateProperty DatePicker_statics<X>::DateProperty;
template<typename X> typename DatePicker_statics<X>::_DayFormatProperty DatePicker_statics<X>::DayFormatProperty;
template<typename X> typename DatePicker_statics<X>::_DayVisibleProperty DatePicker_statics<X>::DayVisibleProperty;
template<typename X> typename DatePicker_statics<X>::_HeaderProperty DatePicker_statics<X>::HeaderProperty;
template<typename X> typename DatePicker_statics<X>::_HeaderTemplateProperty DatePicker_statics<X>::HeaderTemplateProperty;
template<typename X> typename DatePicker_statics<X>::_MaxYearProperty DatePicker_statics<X>::MaxYearProperty;
template<typename X> typename DatePicker_statics<X>::_MinYearProperty DatePicker_statics<X>::MinYearProperty;
template<typename X> typename DatePicker_statics<X>::_MonthFormatProperty DatePicker_statics<X>::MonthFormatProperty;
template<typename X> typename DatePicker_statics<X>::_MonthVisibleProperty DatePicker_statics<X>::MonthVisibleProperty;
template<typename X> typename DatePicker_statics<X>::_OrientationProperty DatePicker_statics<X>::OrientationProperty;
template<typename X> typename DatePicker_statics<X>::_YearFormatProperty DatePicker_statics<X>::YearFormatProperty;
template<typename X> typename DatePicker_statics<X>::_YearVisibleProperty DatePicker_statics<X>::YearVisibleProperty;
template<typename X> typename DatePicker_statics<X>::_LightDismissOverlayModeProperty DatePicker_statics<X>::LightDismissOverlayModeProperty;

template<typename X> struct statics<DatePicker, X> : X, Windows::UI::Xaml::Controls::DatePicker_statics<void> {
	using Windows::UI::Xaml::Controls::DatePicker_statics<void>::activate;
	typedef typename X::root_type DatePicker;
};
struct DatePicker : generate<DatePicker> {};

// Hub
template<typename> struct Hub_statics {
	static struct _DefaultSectionIndexProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Hub, IHubStatics>()->_get_DefaultSectionIndexProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DefaultSectionIndexProperty;
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Hub, IHubStatics>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static struct _HeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Hub, IHubStatics>()->_get_HeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTemplateProperty;
	static struct _IsActiveViewProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Hub, IHubStatics>()->_get_IsActiveViewProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsActiveViewProperty;
	static struct _IsZoomedInViewProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Hub, IHubStatics>()->_get_IsZoomedInViewProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsZoomedInViewProperty;
	static struct _OrientationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Hub, IHubStatics>()->_get_OrientationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OrientationProperty;
	static struct _SemanticZoomOwnerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Hub, IHubStatics>()->_get_SemanticZoomOwnerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SemanticZoomOwnerProperty;
	static Hub *activate(object_ref outer, IInspectable* *inner) { Hub *instance; hrcheck(get_activation_factory<Hub, IHubFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename Hub_statics<X>::_DefaultSectionIndexProperty Hub_statics<X>::DefaultSectionIndexProperty;
template<typename X> typename Hub_statics<X>::_HeaderProperty Hub_statics<X>::HeaderProperty;
template<typename X> typename Hub_statics<X>::_HeaderTemplateProperty Hub_statics<X>::HeaderTemplateProperty;
template<typename X> typename Hub_statics<X>::_IsActiveViewProperty Hub_statics<X>::IsActiveViewProperty;
template<typename X> typename Hub_statics<X>::_IsZoomedInViewProperty Hub_statics<X>::IsZoomedInViewProperty;
template<typename X> typename Hub_statics<X>::_OrientationProperty Hub_statics<X>::OrientationProperty;
template<typename X> typename Hub_statics<X>::_SemanticZoomOwnerProperty Hub_statics<X>::SemanticZoomOwnerProperty;

template<typename X> struct statics<Hub, X> : X, Windows::UI::Xaml::Controls::Hub_statics<void> {
	using Windows::UI::Xaml::Controls::Hub_statics<void>::activate;
	typedef typename X::root_type Hub;
};
struct Hub : generate<Hub> {};

// MediaPlayerElement
template<typename> struct MediaPlayerElement_statics {
	static struct _AreTransportControlsEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaPlayerElement, IMediaPlayerElementStatics>()->_get_AreTransportControlsEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AreTransportControlsEnabledProperty;
	static struct _AutoPlayProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaPlayerElement, IMediaPlayerElementStatics>()->_get_AutoPlayProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AutoPlayProperty;
	static struct _IsFullWindowProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaPlayerElement, IMediaPlayerElementStatics>()->_get_IsFullWindowProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsFullWindowProperty;
	static struct _MediaPlayerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaPlayerElement, IMediaPlayerElementStatics>()->_get_MediaPlayerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MediaPlayerProperty;
	static struct _PosterSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaPlayerElement, IMediaPlayerElementStatics>()->_get_PosterSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PosterSourceProperty;
	static struct _SourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaPlayerElement, IMediaPlayerElementStatics>()->_get_SourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SourceProperty;
	static struct _StretchProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MediaPlayerElement, IMediaPlayerElementStatics>()->_get_StretchProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} StretchProperty;
	static MediaPlayerElement *activate(object_ref outer, IInspectable* *inner) { MediaPlayerElement *instance; hrcheck(get_activation_factory<MediaPlayerElement, IMediaPlayerElementFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename MediaPlayerElement_statics<X>::_AreTransportControlsEnabledProperty MediaPlayerElement_statics<X>::AreTransportControlsEnabledProperty;
template<typename X> typename MediaPlayerElement_statics<X>::_AutoPlayProperty MediaPlayerElement_statics<X>::AutoPlayProperty;
template<typename X> typename MediaPlayerElement_statics<X>::_IsFullWindowProperty MediaPlayerElement_statics<X>::IsFullWindowProperty;
template<typename X> typename MediaPlayerElement_statics<X>::_MediaPlayerProperty MediaPlayerElement_statics<X>::MediaPlayerProperty;
template<typename X> typename MediaPlayerElement_statics<X>::_PosterSourceProperty MediaPlayerElement_statics<X>::PosterSourceProperty;
template<typename X> typename MediaPlayerElement_statics<X>::_SourceProperty MediaPlayerElement_statics<X>::SourceProperty;
template<typename X> typename MediaPlayerElement_statics<X>::_StretchProperty MediaPlayerElement_statics<X>::StretchProperty;

template<typename X> struct statics<MediaPlayerElement, X> : X, Windows::UI::Xaml::Controls::MediaPlayerElement_statics<void> {
	using Windows::UI::Xaml::Controls::MediaPlayerElement_statics<void>::activate;
	typedef typename X::root_type MediaPlayerElement;
};
struct MediaPlayerElement : generate<MediaPlayerElement> {};

// RichEditBox
template<typename> struct RichEditBox_statics {
	static struct _AcceptsReturnProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics>()->_get_AcceptsReturnProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AcceptsReturnProperty;
	static struct _InputScopeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics>()->_get_InputScopeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} InputScopeProperty;
	static struct _IsReadOnlyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics>()->_get_IsReadOnlyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsReadOnlyProperty;
	static struct _IsSpellCheckEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics>()->_get_IsSpellCheckEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsSpellCheckEnabledProperty;
	static struct _IsTextPredictionEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics>()->_get_IsTextPredictionEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsTextPredictionEnabledProperty;
	static struct _TextAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics>()->_get_TextAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextAlignmentProperty;
	static struct _TextWrappingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics>()->_get_TextWrappingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextWrappingProperty;
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics2>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static struct _HeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics2>()->_get_HeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTemplateProperty;
	static struct _IsColorFontEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics2>()->_get_IsColorFontEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsColorFontEnabledProperty;
	static struct _PlaceholderTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics2>()->_get_PlaceholderTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlaceholderTextProperty;
	static struct _PreventKeyboardDisplayOnProgrammaticFocusProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics2>()->_get_PreventKeyboardDisplayOnProgrammaticFocusProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PreventKeyboardDisplayOnProgrammaticFocusProperty;
	static struct _SelectionHighlightColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics2>()->_get_SelectionHighlightColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectionHighlightColorProperty;
	static struct _DesiredCandidateWindowAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics3>()->_get_DesiredCandidateWindowAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DesiredCandidateWindowAlignmentProperty;
	static struct _TextReadingOrderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics3>()->_get_TextReadingOrderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextReadingOrderProperty;
	static struct _ClipboardCopyFormatProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics4>()->_get_ClipboardCopyFormatProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ClipboardCopyFormatProperty;
	static struct _MaxLengthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics5>()->_get_MaxLengthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxLengthProperty;
	static struct _SelectionHighlightColorWhenNotFocusedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics5>()->_get_SelectionHighlightColorWhenNotFocusedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectionHighlightColorWhenNotFocusedProperty;
	static struct _CharacterCasingProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics6>()->_get_CharacterCasingProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CharacterCasingProperty;
	static struct _DisabledFormattingAcceleratorsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics6>()->_get_DisabledFormattingAcceleratorsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DisabledFormattingAcceleratorsProperty;
	static struct _HorizontalTextAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics6>()->_get_HorizontalTextAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalTextAlignmentProperty;
	static struct _ContentLinkBackgroundColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics7>()->_get_ContentLinkBackgroundColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentLinkBackgroundColorProperty;
	static struct _ContentLinkForegroundColorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics7>()->_get_ContentLinkForegroundColorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentLinkForegroundColorProperty;
	static struct _ContentLinkProvidersProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics7>()->_get_ContentLinkProvidersProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentLinkProvidersProperty;
	static struct _HandwritingViewProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics7>()->_get_HandwritingViewProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HandwritingViewProperty;
	static struct _IsHandwritingViewEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxStatics7>()->_get_IsHandwritingViewEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsHandwritingViewEnabledProperty;
	static RichEditBox *activate(object_ref outer, IInspectable* *inner) { RichEditBox *instance; hrcheck(get_activation_factory<RichEditBox, IRichEditBoxFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename RichEditBox_statics<X>::_AcceptsReturnProperty RichEditBox_statics<X>::AcceptsReturnProperty;
template<typename X> typename RichEditBox_statics<X>::_InputScopeProperty RichEditBox_statics<X>::InputScopeProperty;
template<typename X> typename RichEditBox_statics<X>::_IsReadOnlyProperty RichEditBox_statics<X>::IsReadOnlyProperty;
template<typename X> typename RichEditBox_statics<X>::_IsSpellCheckEnabledProperty RichEditBox_statics<X>::IsSpellCheckEnabledProperty;
template<typename X> typename RichEditBox_statics<X>::_IsTextPredictionEnabledProperty RichEditBox_statics<X>::IsTextPredictionEnabledProperty;
template<typename X> typename RichEditBox_statics<X>::_TextAlignmentProperty RichEditBox_statics<X>::TextAlignmentProperty;
template<typename X> typename RichEditBox_statics<X>::_TextWrappingProperty RichEditBox_statics<X>::TextWrappingProperty;
template<typename X> typename RichEditBox_statics<X>::_HeaderProperty RichEditBox_statics<X>::HeaderProperty;
template<typename X> typename RichEditBox_statics<X>::_HeaderTemplateProperty RichEditBox_statics<X>::HeaderTemplateProperty;
template<typename X> typename RichEditBox_statics<X>::_IsColorFontEnabledProperty RichEditBox_statics<X>::IsColorFontEnabledProperty;
template<typename X> typename RichEditBox_statics<X>::_PlaceholderTextProperty RichEditBox_statics<X>::PlaceholderTextProperty;
template<typename X> typename RichEditBox_statics<X>::_PreventKeyboardDisplayOnProgrammaticFocusProperty RichEditBox_statics<X>::PreventKeyboardDisplayOnProgrammaticFocusProperty;
template<typename X> typename RichEditBox_statics<X>::_SelectionHighlightColorProperty RichEditBox_statics<X>::SelectionHighlightColorProperty;
template<typename X> typename RichEditBox_statics<X>::_DesiredCandidateWindowAlignmentProperty RichEditBox_statics<X>::DesiredCandidateWindowAlignmentProperty;
template<typename X> typename RichEditBox_statics<X>::_TextReadingOrderProperty RichEditBox_statics<X>::TextReadingOrderProperty;
template<typename X> typename RichEditBox_statics<X>::_ClipboardCopyFormatProperty RichEditBox_statics<X>::ClipboardCopyFormatProperty;
template<typename X> typename RichEditBox_statics<X>::_MaxLengthProperty RichEditBox_statics<X>::MaxLengthProperty;
template<typename X> typename RichEditBox_statics<X>::_SelectionHighlightColorWhenNotFocusedProperty RichEditBox_statics<X>::SelectionHighlightColorWhenNotFocusedProperty;
template<typename X> typename RichEditBox_statics<X>::_CharacterCasingProperty RichEditBox_statics<X>::CharacterCasingProperty;
template<typename X> typename RichEditBox_statics<X>::_DisabledFormattingAcceleratorsProperty RichEditBox_statics<X>::DisabledFormattingAcceleratorsProperty;
template<typename X> typename RichEditBox_statics<X>::_HorizontalTextAlignmentProperty RichEditBox_statics<X>::HorizontalTextAlignmentProperty;
template<typename X> typename RichEditBox_statics<X>::_ContentLinkBackgroundColorProperty RichEditBox_statics<X>::ContentLinkBackgroundColorProperty;
template<typename X> typename RichEditBox_statics<X>::_ContentLinkForegroundColorProperty RichEditBox_statics<X>::ContentLinkForegroundColorProperty;
template<typename X> typename RichEditBox_statics<X>::_ContentLinkProvidersProperty RichEditBox_statics<X>::ContentLinkProvidersProperty;
template<typename X> typename RichEditBox_statics<X>::_HandwritingViewProperty RichEditBox_statics<X>::HandwritingViewProperty;
template<typename X> typename RichEditBox_statics<X>::_IsHandwritingViewEnabledProperty RichEditBox_statics<X>::IsHandwritingViewEnabledProperty;

template<typename X> struct statics<RichEditBox, X> : X, Windows::UI::Xaml::Controls::RichEditBox_statics<void> {
	using Windows::UI::Xaml::Controls::RichEditBox_statics<void>::activate;
	typedef typename X::root_type RichEditBox;
};
struct RichEditBox : generate<RichEditBox> {};

// SearchBox
template<typename> struct SearchBox_statics {
	static struct _ChooseSuggestionOnEnterProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SearchBox, ISearchBoxStatics>()->_get_ChooseSuggestionOnEnterProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ChooseSuggestionOnEnterProperty;
	static struct _FocusOnKeyboardInputProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SearchBox, ISearchBoxStatics>()->_get_FocusOnKeyboardInputProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FocusOnKeyboardInputProperty;
	static struct _PlaceholderTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SearchBox, ISearchBoxStatics>()->_get_PlaceholderTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlaceholderTextProperty;
	static struct _QueryTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SearchBox, ISearchBoxStatics>()->_get_QueryTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} QueryTextProperty;
	static struct _SearchHistoryContextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SearchBox, ISearchBoxStatics>()->_get_SearchHistoryContextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SearchHistoryContextProperty;
	static struct _SearchHistoryEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SearchBox, ISearchBoxStatics>()->_get_SearchHistoryEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SearchHistoryEnabledProperty;
	static SearchBox *activate(object_ref outer, IInspectable* *inner) { SearchBox *instance; hrcheck(get_activation_factory<SearchBox, ISearchBoxFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename SearchBox_statics<X>::_ChooseSuggestionOnEnterProperty SearchBox_statics<X>::ChooseSuggestionOnEnterProperty;
template<typename X> typename SearchBox_statics<X>::_FocusOnKeyboardInputProperty SearchBox_statics<X>::FocusOnKeyboardInputProperty;
template<typename X> typename SearchBox_statics<X>::_PlaceholderTextProperty SearchBox_statics<X>::PlaceholderTextProperty;
template<typename X> typename SearchBox_statics<X>::_QueryTextProperty SearchBox_statics<X>::QueryTextProperty;
template<typename X> typename SearchBox_statics<X>::_SearchHistoryContextProperty SearchBox_statics<X>::SearchHistoryContextProperty;
template<typename X> typename SearchBox_statics<X>::_SearchHistoryEnabledProperty SearchBox_statics<X>::SearchHistoryEnabledProperty;

template<typename X> struct statics<SearchBox, X> : X, Windows::UI::Xaml::Controls::SearchBox_statics<void> {
	using Windows::UI::Xaml::Controls::SearchBox_statics<void>::activate;
	typedef typename X::root_type SearchBox;
};
struct SearchBox : generate<SearchBox> {};

// SplitView
template<typename> struct SplitView_statics {
	static struct _CompactPaneLengthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitView, ISplitViewStatics>()->_get_CompactPaneLengthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CompactPaneLengthProperty;
	static struct _ContentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitView, ISplitViewStatics>()->_get_ContentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentProperty;
	static struct _DisplayModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitView, ISplitViewStatics>()->_get_DisplayModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DisplayModeProperty;
	static struct _IsPaneOpenProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitView, ISplitViewStatics>()->_get_IsPaneOpenProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsPaneOpenProperty;
	static struct _OpenPaneLengthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitView, ISplitViewStatics>()->_get_OpenPaneLengthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OpenPaneLengthProperty;
	static struct _PaneBackgroundProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitView, ISplitViewStatics>()->_get_PaneBackgroundProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaneBackgroundProperty;
	static struct _PanePlacementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitView, ISplitViewStatics>()->_get_PanePlacementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PanePlacementProperty;
	static struct _PaneProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitView, ISplitViewStatics>()->_get_PaneProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaneProperty;
	static struct _TemplateSettingsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitView, ISplitViewStatics>()->_get_TemplateSettingsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TemplateSettingsProperty;
	static struct _LightDismissOverlayModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<SplitView, ISplitViewStatics2>()->_get_LightDismissOverlayModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LightDismissOverlayModeProperty;
	static SplitView *activate(object_ref outer, IInspectable* *inner) { SplitView *instance; hrcheck(get_activation_factory<SplitView, ISplitViewFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename SplitView_statics<X>::_CompactPaneLengthProperty SplitView_statics<X>::CompactPaneLengthProperty;
template<typename X> typename SplitView_statics<X>::_ContentProperty SplitView_statics<X>::ContentProperty;
template<typename X> typename SplitView_statics<X>::_DisplayModeProperty SplitView_statics<X>::DisplayModeProperty;
template<typename X> typename SplitView_statics<X>::_IsPaneOpenProperty SplitView_statics<X>::IsPaneOpenProperty;
template<typename X> typename SplitView_statics<X>::_OpenPaneLengthProperty SplitView_statics<X>::OpenPaneLengthProperty;
template<typename X> typename SplitView_statics<X>::_PaneBackgroundProperty SplitView_statics<X>::PaneBackgroundProperty;
template<typename X> typename SplitView_statics<X>::_PanePlacementProperty SplitView_statics<X>::PanePlacementProperty;
template<typename X> typename SplitView_statics<X>::_PaneProperty SplitView_statics<X>::PaneProperty;
template<typename X> typename SplitView_statics<X>::_TemplateSettingsProperty SplitView_statics<X>::TemplateSettingsProperty;
template<typename X> typename SplitView_statics<X>::_LightDismissOverlayModeProperty SplitView_statics<X>::LightDismissOverlayModeProperty;

template<typename X> struct statics<SplitView, X> : X, Windows::UI::Xaml::Controls::SplitView_statics<void> {
	using Windows::UI::Xaml::Controls::SplitView_statics<void>::activate;
	typedef typename X::root_type SplitView;
};
struct SplitView : generate<SplitView> {};

// TimePicker
template<typename> struct TimePicker_statics {
	static struct _ClockIdentifierProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TimePicker, ITimePickerStatics>()->_get_ClockIdentifierProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ClockIdentifierProperty;
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TimePicker, ITimePickerStatics>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static struct _HeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TimePicker, ITimePickerStatics>()->_get_HeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTemplateProperty;
	static struct _MinuteIncrementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TimePicker, ITimePickerStatics>()->_get_MinuteIncrementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinuteIncrementProperty;
	static struct _TimeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TimePicker, ITimePickerStatics>()->_get_TimeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TimeProperty;
	static struct _LightDismissOverlayModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TimePicker, ITimePickerStatics2>()->_get_LightDismissOverlayModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LightDismissOverlayModeProperty;
	static TimePicker *activate(object_ref outer, IInspectable* *inner) { TimePicker *instance; hrcheck(get_activation_factory<TimePicker, ITimePickerFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename TimePicker_statics<X>::_ClockIdentifierProperty TimePicker_statics<X>::ClockIdentifierProperty;
template<typename X> typename TimePicker_statics<X>::_HeaderProperty TimePicker_statics<X>::HeaderProperty;
template<typename X> typename TimePicker_statics<X>::_HeaderTemplateProperty TimePicker_statics<X>::HeaderTemplateProperty;
template<typename X> typename TimePicker_statics<X>::_MinuteIncrementProperty TimePicker_statics<X>::MinuteIncrementProperty;
template<typename X> typename TimePicker_statics<X>::_TimeProperty TimePicker_statics<X>::TimeProperty;
template<typename X> typename TimePicker_statics<X>::_LightDismissOverlayModeProperty TimePicker_statics<X>::LightDismissOverlayModeProperty;

template<typename X> struct statics<TimePicker, X> : X, Windows::UI::Xaml::Controls::TimePicker_statics<void> {
	using Windows::UI::Xaml::Controls::TimePicker_statics<void>::activate;
	typedef typename X::root_type TimePicker;
};
struct TimePicker : generate<TimePicker> {};

// AppBar
template<typename> struct AppBar_statics {
	static struct _IsOpenProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBar, IAppBarStatics>()->_get_IsOpenProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsOpenProperty;
	static struct _IsStickyProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBar, IAppBarStatics>()->_get_IsStickyProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsStickyProperty;
	static struct _ClosedDisplayModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBar, IAppBarStatics2>()->_get_ClosedDisplayModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ClosedDisplayModeProperty;
	static struct _LightDismissOverlayModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBar, IAppBarStatics4>()->_get_LightDismissOverlayModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LightDismissOverlayModeProperty;
	static AppBar *activate(object_ref outer, IInspectable* *inner) { AppBar *instance; hrcheck(get_activation_factory<AppBar, IAppBarFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename AppBar_statics<X>::_IsOpenProperty AppBar_statics<X>::IsOpenProperty;
template<typename X> typename AppBar_statics<X>::_IsStickyProperty AppBar_statics<X>::IsStickyProperty;
template<typename X> typename AppBar_statics<X>::_ClosedDisplayModeProperty AppBar_statics<X>::ClosedDisplayModeProperty;
template<typename X> typename AppBar_statics<X>::_LightDismissOverlayModeProperty AppBar_statics<X>::LightDismissOverlayModeProperty;

template<typename X> struct statics<AppBar, X> : X, Windows::UI::Xaml::Controls::AppBar_statics<void> {
	using Windows::UI::Xaml::Controls::AppBar_statics<void>::activate;
	typedef typename X::root_type AppBar;
};
struct AppBar : generate<AppBar> {};

// AutoSuggestBox
template<typename> struct AutoSuggestBox_statics {
	static struct _AutoMaximizeSuggestionAreaProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AutoSuggestBox, IAutoSuggestBoxStatics>()->_get_AutoMaximizeSuggestionAreaProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} AutoMaximizeSuggestionAreaProperty;
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AutoSuggestBox, IAutoSuggestBoxStatics>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static struct _IsSuggestionListOpenProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AutoSuggestBox, IAutoSuggestBoxStatics>()->_get_IsSuggestionListOpenProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsSuggestionListOpenProperty;
	static struct _MaxSuggestionListHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AutoSuggestBox, IAutoSuggestBoxStatics>()->_get_MaxSuggestionListHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxSuggestionListHeightProperty;
	static struct _PlaceholderTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AutoSuggestBox, IAutoSuggestBoxStatics>()->_get_PlaceholderTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PlaceholderTextProperty;
	static struct _TextBoxStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AutoSuggestBox, IAutoSuggestBoxStatics>()->_get_TextBoxStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextBoxStyleProperty;
	static struct _TextMemberPathProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AutoSuggestBox, IAutoSuggestBoxStatics>()->_get_TextMemberPathProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextMemberPathProperty;
	static struct _TextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AutoSuggestBox, IAutoSuggestBoxStatics>()->_get_TextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextProperty;
	static struct _UpdateTextOnSelectProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AutoSuggestBox, IAutoSuggestBoxStatics>()->_get_UpdateTextOnSelectProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} UpdateTextOnSelectProperty;
	static struct _QueryIconProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AutoSuggestBox, IAutoSuggestBoxStatics2>()->_get_QueryIconProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} QueryIconProperty;
	static struct _LightDismissOverlayModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AutoSuggestBox, IAutoSuggestBoxStatics3>()->_get_LightDismissOverlayModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LightDismissOverlayModeProperty;
};
template<typename X> typename AutoSuggestBox_statics<X>::_AutoMaximizeSuggestionAreaProperty AutoSuggestBox_statics<X>::AutoMaximizeSuggestionAreaProperty;
template<typename X> typename AutoSuggestBox_statics<X>::_HeaderProperty AutoSuggestBox_statics<X>::HeaderProperty;
template<typename X> typename AutoSuggestBox_statics<X>::_IsSuggestionListOpenProperty AutoSuggestBox_statics<X>::IsSuggestionListOpenProperty;
template<typename X> typename AutoSuggestBox_statics<X>::_MaxSuggestionListHeightProperty AutoSuggestBox_statics<X>::MaxSuggestionListHeightProperty;
template<typename X> typename AutoSuggestBox_statics<X>::_PlaceholderTextProperty AutoSuggestBox_statics<X>::PlaceholderTextProperty;
template<typename X> typename AutoSuggestBox_statics<X>::_TextBoxStyleProperty AutoSuggestBox_statics<X>::TextBoxStyleProperty;
template<typename X> typename AutoSuggestBox_statics<X>::_TextMemberPathProperty AutoSuggestBox_statics<X>::TextMemberPathProperty;
template<typename X> typename AutoSuggestBox_statics<X>::_TextProperty AutoSuggestBox_statics<X>::TextProperty;
template<typename X> typename AutoSuggestBox_statics<X>::_UpdateTextOnSelectProperty AutoSuggestBox_statics<X>::UpdateTextOnSelectProperty;
template<typename X> typename AutoSuggestBox_statics<X>::_QueryIconProperty AutoSuggestBox_statics<X>::QueryIconProperty;
template<typename X> typename AutoSuggestBox_statics<X>::_LightDismissOverlayModeProperty AutoSuggestBox_statics<X>::LightDismissOverlayModeProperty;

template<typename X> struct statics<AutoSuggestBox, X> : X, Windows::UI::Xaml::Controls::AutoSuggestBox_statics<void> {
	typedef typename X::root_type AutoSuggestBox;
};
struct AutoSuggestBox : generate<AutoSuggestBox> {};

// CommandBarOverflowPresenter
template<typename> struct CommandBarOverflowPresenter_statics {
	static CommandBarOverflowPresenter *activate(object_ref outer, IInspectable* *inner) { CommandBarOverflowPresenter *instance; hrcheck(get_activation_factory<CommandBarOverflowPresenter, ICommandBarOverflowPresenterFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<CommandBarOverflowPresenter, X> : X, Windows::UI::Xaml::Controls::CommandBarOverflowPresenter_statics<void> {
	using Windows::UI::Xaml::Controls::CommandBarOverflowPresenter_statics<void>::activate;
	typedef typename X::root_type CommandBarOverflowPresenter;
};
struct CommandBarOverflowPresenter : generate<CommandBarOverflowPresenter> {};

// ContentDialog
template<typename> struct ContentDialog_statics {
	static struct _FullSizeDesiredProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics>()->_get_FullSizeDesiredProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FullSizeDesiredProperty;
	static struct _IsPrimaryButtonEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics>()->_get_IsPrimaryButtonEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsPrimaryButtonEnabledProperty;
	static struct _IsSecondaryButtonEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics>()->_get_IsSecondaryButtonEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsSecondaryButtonEnabledProperty;
	static struct _PrimaryButtonCommandParameterProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics>()->_get_PrimaryButtonCommandParameterProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PrimaryButtonCommandParameterProperty;
	static struct _PrimaryButtonCommandProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics>()->_get_PrimaryButtonCommandProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PrimaryButtonCommandProperty;
	static struct _PrimaryButtonTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics>()->_get_PrimaryButtonTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PrimaryButtonTextProperty;
	static struct _SecondaryButtonCommandParameterProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics>()->_get_SecondaryButtonCommandParameterProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SecondaryButtonCommandParameterProperty;
	static struct _SecondaryButtonCommandProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics>()->_get_SecondaryButtonCommandProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SecondaryButtonCommandProperty;
	static struct _SecondaryButtonTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics>()->_get_SecondaryButtonTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SecondaryButtonTextProperty;
	static struct _TitleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics>()->_get_TitleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TitleProperty;
	static struct _TitleTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics>()->_get_TitleTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TitleTemplateProperty;
	static struct _CloseButtonCommandParameterProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics2>()->_get_CloseButtonCommandParameterProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CloseButtonCommandParameterProperty;
	static struct _CloseButtonCommandProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics2>()->_get_CloseButtonCommandProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CloseButtonCommandProperty;
	static struct _CloseButtonStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics2>()->_get_CloseButtonStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CloseButtonStyleProperty;
	static struct _CloseButtonTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics2>()->_get_CloseButtonTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CloseButtonTextProperty;
	static struct _DefaultButtonProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics2>()->_get_DefaultButtonProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DefaultButtonProperty;
	static struct _PrimaryButtonStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics2>()->_get_PrimaryButtonStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PrimaryButtonStyleProperty;
	static struct _SecondaryButtonStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ContentDialog, IContentDialogStatics2>()->_get_SecondaryButtonStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SecondaryButtonStyleProperty;
	static ContentDialog *activate(object_ref outer, IInspectable* *inner) { ContentDialog *instance; hrcheck(get_activation_factory<ContentDialog, IContentDialogFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename ContentDialog_statics<X>::_FullSizeDesiredProperty ContentDialog_statics<X>::FullSizeDesiredProperty;
template<typename X> typename ContentDialog_statics<X>::_IsPrimaryButtonEnabledProperty ContentDialog_statics<X>::IsPrimaryButtonEnabledProperty;
template<typename X> typename ContentDialog_statics<X>::_IsSecondaryButtonEnabledProperty ContentDialog_statics<X>::IsSecondaryButtonEnabledProperty;
template<typename X> typename ContentDialog_statics<X>::_PrimaryButtonCommandParameterProperty ContentDialog_statics<X>::PrimaryButtonCommandParameterProperty;
template<typename X> typename ContentDialog_statics<X>::_PrimaryButtonCommandProperty ContentDialog_statics<X>::PrimaryButtonCommandProperty;
template<typename X> typename ContentDialog_statics<X>::_PrimaryButtonTextProperty ContentDialog_statics<X>::PrimaryButtonTextProperty;
template<typename X> typename ContentDialog_statics<X>::_SecondaryButtonCommandParameterProperty ContentDialog_statics<X>::SecondaryButtonCommandParameterProperty;
template<typename X> typename ContentDialog_statics<X>::_SecondaryButtonCommandProperty ContentDialog_statics<X>::SecondaryButtonCommandProperty;
template<typename X> typename ContentDialog_statics<X>::_SecondaryButtonTextProperty ContentDialog_statics<X>::SecondaryButtonTextProperty;
template<typename X> typename ContentDialog_statics<X>::_TitleProperty ContentDialog_statics<X>::TitleProperty;
template<typename X> typename ContentDialog_statics<X>::_TitleTemplateProperty ContentDialog_statics<X>::TitleTemplateProperty;
template<typename X> typename ContentDialog_statics<X>::_CloseButtonCommandParameterProperty ContentDialog_statics<X>::CloseButtonCommandParameterProperty;
template<typename X> typename ContentDialog_statics<X>::_CloseButtonCommandProperty ContentDialog_statics<X>::CloseButtonCommandProperty;
template<typename X> typename ContentDialog_statics<X>::_CloseButtonStyleProperty ContentDialog_statics<X>::CloseButtonStyleProperty;
template<typename X> typename ContentDialog_statics<X>::_CloseButtonTextProperty ContentDialog_statics<X>::CloseButtonTextProperty;
template<typename X> typename ContentDialog_statics<X>::_DefaultButtonProperty ContentDialog_statics<X>::DefaultButtonProperty;
template<typename X> typename ContentDialog_statics<X>::_PrimaryButtonStyleProperty ContentDialog_statics<X>::PrimaryButtonStyleProperty;
template<typename X> typename ContentDialog_statics<X>::_SecondaryButtonStyleProperty ContentDialog_statics<X>::SecondaryButtonStyleProperty;

template<typename X> struct statics<ContentDialog, X> : X, Windows::UI::Xaml::Controls::ContentDialog_statics<void> {
	using Windows::UI::Xaml::Controls::ContentDialog_statics<void>::activate;
	typedef typename X::root_type ContentDialog;
};
struct ContentDialog : generate<ContentDialog> {
	using IContentDialog::ShowAsync;
	using IContentDialog3::ShowAsync;
};

// FlyoutPresenter
template<typename> struct FlyoutPresenter_statics {
	static FlyoutPresenter *activate(object_ref outer, IInspectable* *inner) { FlyoutPresenter *instance; hrcheck(get_activation_factory<FlyoutPresenter, IFlyoutPresenterFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<FlyoutPresenter, X> : X, Windows::UI::Xaml::Controls::FlyoutPresenter_statics<void> {
	using Windows::UI::Xaml::Controls::FlyoutPresenter_statics<void>::activate;
	typedef typename X::root_type FlyoutPresenter;
};
struct FlyoutPresenter : generate<FlyoutPresenter> {};

// Frame
template<typename> struct Frame_statics {
	static struct _BackStackDepthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Frame, IFrameStatics>()->_get_BackStackDepthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BackStackDepthProperty;
	static struct _CacheSizeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Frame, IFrameStatics>()->_get_CacheSizeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CacheSizeProperty;
	static struct _CanGoBackProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Frame, IFrameStatics>()->_get_CanGoBackProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CanGoBackProperty;
	static struct _CanGoForwardProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Frame, IFrameStatics>()->_get_CanGoForwardProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CanGoForwardProperty;
	static struct _CurrentSourcePageTypeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Frame, IFrameStatics>()->_get_CurrentSourcePageTypeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CurrentSourcePageTypeProperty;
	static struct _SourcePageTypeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Frame, IFrameStatics>()->_get_SourcePageTypeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SourcePageTypeProperty;
	static struct _BackStackProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Frame, IFrameStatics2>()->_get_BackStackProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BackStackProperty;
	static struct _ForwardStackProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Frame, IFrameStatics2>()->_get_ForwardStackProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ForwardStackProperty;
	static Frame *activate(object_ref outer, IInspectable* *inner) { Frame *instance; hrcheck(get_activation_factory<Frame, IFrameFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename Frame_statics<X>::_BackStackDepthProperty Frame_statics<X>::BackStackDepthProperty;
template<typename X> typename Frame_statics<X>::_CacheSizeProperty Frame_statics<X>::CacheSizeProperty;
template<typename X> typename Frame_statics<X>::_CanGoBackProperty Frame_statics<X>::CanGoBackProperty;
template<typename X> typename Frame_statics<X>::_CanGoForwardProperty Frame_statics<X>::CanGoForwardProperty;
template<typename X> typename Frame_statics<X>::_CurrentSourcePageTypeProperty Frame_statics<X>::CurrentSourcePageTypeProperty;
template<typename X> typename Frame_statics<X>::_SourcePageTypeProperty Frame_statics<X>::SourcePageTypeProperty;
template<typename X> typename Frame_statics<X>::_BackStackProperty Frame_statics<X>::BackStackProperty;
template<typename X> typename Frame_statics<X>::_ForwardStackProperty Frame_statics<X>::ForwardStackProperty;

template<typename X> struct statics<Frame, X> : X, Windows::UI::Xaml::Controls::Frame_statics<void> {
	using Windows::UI::Xaml::Controls::Frame_statics<void>::activate;
	typedef typename X::root_type Frame;
};
struct Frame : generate<Frame> {
	using IFrame4::SetNavigationState;
	using IFrame::SetNavigationState;
	using IFrame2::Navigate;
	using IFrame::Navigate;
	using INavigate::Navigate;
	using IFrame::GoBack;
	using IFrame3::GoBack;
};

// MenuFlyoutItem
template<typename> struct MenuFlyoutItem_statics {
	static struct _CommandParameterProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MenuFlyoutItem, IMenuFlyoutItemStatics>()->_get_CommandParameterProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CommandParameterProperty;
	static struct _CommandProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MenuFlyoutItem, IMenuFlyoutItemStatics>()->_get_CommandProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CommandProperty;
	static struct _TextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MenuFlyoutItem, IMenuFlyoutItemStatics>()->_get_TextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextProperty;
	static struct _IconProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MenuFlyoutItem, IMenuFlyoutItemStatics2>()->_get_IconProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IconProperty;
	static struct _KeyboardAcceleratorTextOverrideProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MenuFlyoutItem, IMenuFlyoutItemStatics3>()->_get_KeyboardAcceleratorTextOverrideProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeyboardAcceleratorTextOverrideProperty;
	static MenuFlyoutItem *activate(object_ref outer, IInspectable* *inner) { MenuFlyoutItem *instance; hrcheck(get_activation_factory<MenuFlyoutItem, IMenuFlyoutItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename MenuFlyoutItem_statics<X>::_CommandParameterProperty MenuFlyoutItem_statics<X>::CommandParameterProperty;
template<typename X> typename MenuFlyoutItem_statics<X>::_CommandProperty MenuFlyoutItem_statics<X>::CommandProperty;
template<typename X> typename MenuFlyoutItem_statics<X>::_TextProperty MenuFlyoutItem_statics<X>::TextProperty;
template<typename X> typename MenuFlyoutItem_statics<X>::_IconProperty MenuFlyoutItem_statics<X>::IconProperty;
template<typename X> typename MenuFlyoutItem_statics<X>::_KeyboardAcceleratorTextOverrideProperty MenuFlyoutItem_statics<X>::KeyboardAcceleratorTextOverrideProperty;

template<typename X> struct statics<MenuFlyoutItem, X> : X, Windows::UI::Xaml::Controls::MenuFlyoutItem_statics<void> {
	using Windows::UI::Xaml::Controls::MenuFlyoutItem_statics<void>::activate;
	typedef typename X::root_type MenuFlyoutItem;
};
struct MenuFlyoutItem : generate<MenuFlyoutItem> {};

// MenuFlyoutPresenter
template<typename> struct MenuFlyoutPresenter_statics {
	static MenuFlyoutPresenter *activate(object_ref outer, IInspectable* *inner) { MenuFlyoutPresenter *instance; hrcheck(get_activation_factory<MenuFlyoutPresenter, IMenuFlyoutPresenterFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<MenuFlyoutPresenter, X> : X, Windows::UI::Xaml::Controls::MenuFlyoutPresenter_statics<void> {
	using Windows::UI::Xaml::Controls::MenuFlyoutPresenter_statics<void>::activate;
	typedef typename X::root_type MenuFlyoutPresenter;
};
struct MenuFlyoutPresenter : generate<MenuFlyoutPresenter> {};

// MenuFlyoutSeparator
template<typename> struct MenuFlyoutSeparator_statics {
	static MenuFlyoutSeparator *activate(object_ref outer, IInspectable* *inner) { MenuFlyoutSeparator *instance; hrcheck(get_activation_factory<MenuFlyoutSeparator, IMenuFlyoutSeparatorFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<MenuFlyoutSeparator, X> : X, Windows::UI::Xaml::Controls::MenuFlyoutSeparator_statics<void> {
	using Windows::UI::Xaml::Controls::MenuFlyoutSeparator_statics<void>::activate;
	typedef typename X::root_type MenuFlyoutSeparator;
};
struct MenuFlyoutSeparator : generate<MenuFlyoutSeparator> {};

// MenuFlyoutSubItem
template<typename> struct MenuFlyoutSubItem_statics {
	static struct _TextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MenuFlyoutSubItem, IMenuFlyoutSubItemStatics>()->_get_TextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TextProperty;
	static struct _IconProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MenuFlyoutSubItem, IMenuFlyoutSubItemStatics2>()->_get_IconProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IconProperty;
};
template<typename X> typename MenuFlyoutSubItem_statics<X>::_TextProperty MenuFlyoutSubItem_statics<X>::TextProperty;
template<typename X> typename MenuFlyoutSubItem_statics<X>::_IconProperty MenuFlyoutSubItem_statics<X>::IconProperty;

template<typename X> struct statics<MenuFlyoutSubItem, X> : X, Windows::UI::Xaml::Controls::MenuFlyoutSubItem_statics<void> {
	typedef typename X::root_type MenuFlyoutSubItem;
};
struct MenuFlyoutSubItem : generate<MenuFlyoutSubItem> {};

// Page
template<typename> struct Page_statics {
	static struct _BottomAppBarProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Page, IPageStatics>()->_get_BottomAppBarProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BottomAppBarProperty;
	static struct _FrameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Page, IPageStatics>()->_get_FrameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FrameProperty;
	static struct _TopAppBarProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Page, IPageStatics>()->_get_TopAppBarProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TopAppBarProperty;
	static Page *activate(object_ref outer, IInspectable* *inner) { Page *instance; hrcheck(get_activation_factory<Page, IPageFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename Page_statics<X>::_BottomAppBarProperty Page_statics<X>::BottomAppBarProperty;
template<typename X> typename Page_statics<X>::_FrameProperty Page_statics<X>::FrameProperty;
template<typename X> typename Page_statics<X>::_TopAppBarProperty Page_statics<X>::TopAppBarProperty;

template<typename X> struct statics<Page, X> : X, Windows::UI::Xaml::Controls::Page_statics<void> {
	using Windows::UI::Xaml::Controls::Page_statics<void>::activate;
	typedef typename X::root_type Page;
};
struct Page : generate<Page> {};

// ScrollViewer
template<typename> struct ScrollViewer_statics {
	static struct _BringIntoViewOnFocusChangeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_BringIntoViewOnFocusChangeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} BringIntoViewOnFocusChangeProperty;
	static struct _ComputedHorizontalScrollBarVisibilityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_ComputedHorizontalScrollBarVisibilityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ComputedHorizontalScrollBarVisibilityProperty;
	static struct _ComputedVerticalScrollBarVisibilityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_ComputedVerticalScrollBarVisibilityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ComputedVerticalScrollBarVisibilityProperty;
	static struct _ExtentHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_ExtentHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ExtentHeightProperty;
	static struct _ExtentWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_ExtentWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ExtentWidthProperty;
	static struct _HorizontalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_HorizontalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalOffsetProperty;
	static struct _HorizontalScrollBarVisibilityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_HorizontalScrollBarVisibilityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalScrollBarVisibilityProperty;
	static struct _HorizontalScrollModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_HorizontalScrollModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalScrollModeProperty;
	static struct _HorizontalSnapPointsAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_HorizontalSnapPointsAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalSnapPointsAlignmentProperty;
	static struct _HorizontalSnapPointsTypeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_HorizontalSnapPointsTypeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HorizontalSnapPointsTypeProperty;
	static struct _IsDeferredScrollingEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_IsDeferredScrollingEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsDeferredScrollingEnabledProperty;
	static struct _IsHorizontalRailEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_IsHorizontalRailEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsHorizontalRailEnabledProperty;
	static struct _IsHorizontalScrollChainingEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_IsHorizontalScrollChainingEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsHorizontalScrollChainingEnabledProperty;
	static struct _IsScrollInertiaEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_IsScrollInertiaEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsScrollInertiaEnabledProperty;
	static struct _IsVerticalRailEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_IsVerticalRailEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsVerticalRailEnabledProperty;
	static struct _IsVerticalScrollChainingEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_IsVerticalScrollChainingEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsVerticalScrollChainingEnabledProperty;
	static struct _IsZoomChainingEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_IsZoomChainingEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsZoomChainingEnabledProperty;
	static struct _IsZoomInertiaEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_IsZoomInertiaEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsZoomInertiaEnabledProperty;
	static struct _MaxZoomFactorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_MaxZoomFactorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxZoomFactorProperty;
	static struct _MinZoomFactorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_MinZoomFactorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinZoomFactorProperty;
	static struct _ScrollableHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_ScrollableHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ScrollableHeightProperty;
	static struct _ScrollableWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_ScrollableWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ScrollableWidthProperty;
	static struct _VerticalOffsetProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_VerticalOffsetProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalOffsetProperty;
	static struct _VerticalScrollBarVisibilityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_VerticalScrollBarVisibilityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalScrollBarVisibilityProperty;
	static struct _VerticalScrollModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_VerticalScrollModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalScrollModeProperty;
	static struct _VerticalSnapPointsAlignmentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_VerticalSnapPointsAlignmentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalSnapPointsAlignmentProperty;
	static struct _VerticalSnapPointsTypeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_VerticalSnapPointsTypeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} VerticalSnapPointsTypeProperty;
	static struct _ViewportHeightProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_ViewportHeightProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ViewportHeightProperty;
	static struct _ViewportWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_ViewportWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ViewportWidthProperty;
	static struct _ZoomFactorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_ZoomFactorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ZoomFactorProperty;
	static struct _ZoomModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_ZoomModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ZoomModeProperty;
	static struct _ZoomSnapPointsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_ZoomSnapPointsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ZoomSnapPointsProperty;
	static struct _ZoomSnapPointsTypeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_get_ZoomSnapPointsTypeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ZoomSnapPointsTypeProperty;
	static struct _LeftHeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics2>()->_get_LeftHeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LeftHeaderProperty;
	static struct _TopHeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics2>()->_get_TopHeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TopHeaderProperty;
	static struct _TopLeftHeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics2>()->_get_TopLeftHeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TopLeftHeaderProperty;
	static ScrollBarVisibility GetHorizontalScrollBarVisibility(pptr<DependencyObject> element) { ScrollBarVisibility horizontalScrollBarVisibility; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_GetHorizontalScrollBarVisibility(element, &horizontalScrollBarVisibility)); return horizontalScrollBarVisibility; }
	static void SetHorizontalScrollBarVisibility(pptr<DependencyObject> element, ScrollBarVisibility horizontalScrollBarVisibility) { hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_SetHorizontalScrollBarVisibility(element, horizontalScrollBarVisibility)); }
	static ScrollBarVisibility GetVerticalScrollBarVisibility(pptr<DependencyObject> element) { ScrollBarVisibility verticalScrollBarVisibility; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_GetVerticalScrollBarVisibility(element, &verticalScrollBarVisibility)); return verticalScrollBarVisibility; }
	static void SetVerticalScrollBarVisibility(pptr<DependencyObject> element, ScrollBarVisibility verticalScrollBarVisibility) { hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_SetVerticalScrollBarVisibility(element, verticalScrollBarVisibility)); }
	static bool GetIsHorizontalRailEnabled(pptr<DependencyObject> element) { bool isHorizontalRailEnabled; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_GetIsHorizontalRailEnabled(element, &isHorizontalRailEnabled)); return isHorizontalRailEnabled; }
	static void SetIsHorizontalRailEnabled(pptr<DependencyObject> element, bool isHorizontalRailEnabled) { hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_SetIsHorizontalRailEnabled(element, isHorizontalRailEnabled)); }
	static bool GetIsVerticalRailEnabled(pptr<DependencyObject> element) { bool isVerticalRailEnabled; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_GetIsVerticalRailEnabled(element, &isVerticalRailEnabled)); return isVerticalRailEnabled; }
	static void SetIsVerticalRailEnabled(pptr<DependencyObject> element, bool isVerticalRailEnabled) { hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_SetIsVerticalRailEnabled(element, isVerticalRailEnabled)); }
	static bool GetIsHorizontalScrollChainingEnabled(pptr<DependencyObject> element) { bool isHorizontalScrollChainingEnabled; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_GetIsHorizontalScrollChainingEnabled(element, &isHorizontalScrollChainingEnabled)); return isHorizontalScrollChainingEnabled; }
	static void SetIsHorizontalScrollChainingEnabled(pptr<DependencyObject> element, bool isHorizontalScrollChainingEnabled) { hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_SetIsHorizontalScrollChainingEnabled(element, isHorizontalScrollChainingEnabled)); }
	static bool GetIsVerticalScrollChainingEnabled(pptr<DependencyObject> element) { bool isVerticalScrollChainingEnabled; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_GetIsVerticalScrollChainingEnabled(element, &isVerticalScrollChainingEnabled)); return isVerticalScrollChainingEnabled; }
	static void SetIsVerticalScrollChainingEnabled(pptr<DependencyObject> element, bool isVerticalScrollChainingEnabled) { hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_SetIsVerticalScrollChainingEnabled(element, isVerticalScrollChainingEnabled)); }
	static bool GetIsZoomChainingEnabled(pptr<DependencyObject> element) { bool isZoomChainingEnabled; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_GetIsZoomChainingEnabled(element, &isZoomChainingEnabled)); return isZoomChainingEnabled; }
	static void SetIsZoomChainingEnabled(pptr<DependencyObject> element, bool isZoomChainingEnabled) { hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_SetIsZoomChainingEnabled(element, isZoomChainingEnabled)); }
	static bool GetIsScrollInertiaEnabled(pptr<DependencyObject> element) { bool isScrollInertiaEnabled; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_GetIsScrollInertiaEnabled(element, &isScrollInertiaEnabled)); return isScrollInertiaEnabled; }
	static void SetIsScrollInertiaEnabled(pptr<DependencyObject> element, bool isScrollInertiaEnabled) { hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_SetIsScrollInertiaEnabled(element, isScrollInertiaEnabled)); }
	static bool GetIsZoomInertiaEnabled(pptr<DependencyObject> element) { bool isZoomInertiaEnabled; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_GetIsZoomInertiaEnabled(element, &isZoomInertiaEnabled)); return isZoomInertiaEnabled; }
	static void SetIsZoomInertiaEnabled(pptr<DependencyObject> element, bool isZoomInertiaEnabled) { hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_SetIsZoomInertiaEnabled(element, isZoomInertiaEnabled)); }
	static ScrollMode GetHorizontalScrollMode(pptr<DependencyObject> element) { ScrollMode horizontalScrollMode; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_GetHorizontalScrollMode(element, &horizontalScrollMode)); return horizontalScrollMode; }
	static void SetHorizontalScrollMode(pptr<DependencyObject> element, ScrollMode horizontalScrollMode) { hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_SetHorizontalScrollMode(element, horizontalScrollMode)); }
	static ScrollMode GetVerticalScrollMode(pptr<DependencyObject> element) { ScrollMode verticalScrollMode; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_GetVerticalScrollMode(element, &verticalScrollMode)); return verticalScrollMode; }
	static void SetVerticalScrollMode(pptr<DependencyObject> element, ScrollMode verticalScrollMode) { hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_SetVerticalScrollMode(element, verticalScrollMode)); }
	static Controls::ZoomMode GetZoomMode(pptr<DependencyObject> element) { Controls::ZoomMode zoomMode; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_GetZoomMode(element, &zoomMode)); return zoomMode; }
	static void SetZoomMode(pptr<DependencyObject> element, Controls::ZoomMode zoomMode) { hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_SetZoomMode(element, zoomMode)); }
	static bool GetIsDeferredScrollingEnabled(pptr<DependencyObject> element) { bool isDeferredScrollingEnabled; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_GetIsDeferredScrollingEnabled(element, &isDeferredScrollingEnabled)); return isDeferredScrollingEnabled; }
	static void SetIsDeferredScrollingEnabled(pptr<DependencyObject> element, bool isDeferredScrollingEnabled) { hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_SetIsDeferredScrollingEnabled(element, isDeferredScrollingEnabled)); }
	static bool GetBringIntoViewOnFocusChange(pptr<DependencyObject> element) { bool bringIntoViewOnFocusChange; hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_GetBringIntoViewOnFocusChange(element, &bringIntoViewOnFocusChange)); return bringIntoViewOnFocusChange; }
	static void SetBringIntoViewOnFocusChange(pptr<DependencyObject> element, bool bringIntoViewOnFocusChange) { hrcheck(get_activation_factory<ScrollViewer, IScrollViewerStatics>()->_SetBringIntoViewOnFocusChange(element, bringIntoViewOnFocusChange)); }
};
template<typename X> typename ScrollViewer_statics<X>::_BringIntoViewOnFocusChangeProperty ScrollViewer_statics<X>::BringIntoViewOnFocusChangeProperty;
template<typename X> typename ScrollViewer_statics<X>::_ComputedHorizontalScrollBarVisibilityProperty ScrollViewer_statics<X>::ComputedHorizontalScrollBarVisibilityProperty;
template<typename X> typename ScrollViewer_statics<X>::_ComputedVerticalScrollBarVisibilityProperty ScrollViewer_statics<X>::ComputedVerticalScrollBarVisibilityProperty;
template<typename X> typename ScrollViewer_statics<X>::_ExtentHeightProperty ScrollViewer_statics<X>::ExtentHeightProperty;
template<typename X> typename ScrollViewer_statics<X>::_ExtentWidthProperty ScrollViewer_statics<X>::ExtentWidthProperty;
template<typename X> typename ScrollViewer_statics<X>::_HorizontalOffsetProperty ScrollViewer_statics<X>::HorizontalOffsetProperty;
template<typename X> typename ScrollViewer_statics<X>::_HorizontalScrollBarVisibilityProperty ScrollViewer_statics<X>::HorizontalScrollBarVisibilityProperty;
template<typename X> typename ScrollViewer_statics<X>::_HorizontalScrollModeProperty ScrollViewer_statics<X>::HorizontalScrollModeProperty;
template<typename X> typename ScrollViewer_statics<X>::_HorizontalSnapPointsAlignmentProperty ScrollViewer_statics<X>::HorizontalSnapPointsAlignmentProperty;
template<typename X> typename ScrollViewer_statics<X>::_HorizontalSnapPointsTypeProperty ScrollViewer_statics<X>::HorizontalSnapPointsTypeProperty;
template<typename X> typename ScrollViewer_statics<X>::_IsDeferredScrollingEnabledProperty ScrollViewer_statics<X>::IsDeferredScrollingEnabledProperty;
template<typename X> typename ScrollViewer_statics<X>::_IsHorizontalRailEnabledProperty ScrollViewer_statics<X>::IsHorizontalRailEnabledProperty;
template<typename X> typename ScrollViewer_statics<X>::_IsHorizontalScrollChainingEnabledProperty ScrollViewer_statics<X>::IsHorizontalScrollChainingEnabledProperty;
template<typename X> typename ScrollViewer_statics<X>::_IsScrollInertiaEnabledProperty ScrollViewer_statics<X>::IsScrollInertiaEnabledProperty;
template<typename X> typename ScrollViewer_statics<X>::_IsVerticalRailEnabledProperty ScrollViewer_statics<X>::IsVerticalRailEnabledProperty;
template<typename X> typename ScrollViewer_statics<X>::_IsVerticalScrollChainingEnabledProperty ScrollViewer_statics<X>::IsVerticalScrollChainingEnabledProperty;
template<typename X> typename ScrollViewer_statics<X>::_IsZoomChainingEnabledProperty ScrollViewer_statics<X>::IsZoomChainingEnabledProperty;
template<typename X> typename ScrollViewer_statics<X>::_IsZoomInertiaEnabledProperty ScrollViewer_statics<X>::IsZoomInertiaEnabledProperty;
template<typename X> typename ScrollViewer_statics<X>::_MaxZoomFactorProperty ScrollViewer_statics<X>::MaxZoomFactorProperty;
template<typename X> typename ScrollViewer_statics<X>::_MinZoomFactorProperty ScrollViewer_statics<X>::MinZoomFactorProperty;
template<typename X> typename ScrollViewer_statics<X>::_ScrollableHeightProperty ScrollViewer_statics<X>::ScrollableHeightProperty;
template<typename X> typename ScrollViewer_statics<X>::_ScrollableWidthProperty ScrollViewer_statics<X>::ScrollableWidthProperty;
template<typename X> typename ScrollViewer_statics<X>::_VerticalOffsetProperty ScrollViewer_statics<X>::VerticalOffsetProperty;
template<typename X> typename ScrollViewer_statics<X>::_VerticalScrollBarVisibilityProperty ScrollViewer_statics<X>::VerticalScrollBarVisibilityProperty;
template<typename X> typename ScrollViewer_statics<X>::_VerticalScrollModeProperty ScrollViewer_statics<X>::VerticalScrollModeProperty;
template<typename X> typename ScrollViewer_statics<X>::_VerticalSnapPointsAlignmentProperty ScrollViewer_statics<X>::VerticalSnapPointsAlignmentProperty;
template<typename X> typename ScrollViewer_statics<X>::_VerticalSnapPointsTypeProperty ScrollViewer_statics<X>::VerticalSnapPointsTypeProperty;
template<typename X> typename ScrollViewer_statics<X>::_ViewportHeightProperty ScrollViewer_statics<X>::ViewportHeightProperty;
template<typename X> typename ScrollViewer_statics<X>::_ViewportWidthProperty ScrollViewer_statics<X>::ViewportWidthProperty;
template<typename X> typename ScrollViewer_statics<X>::_ZoomFactorProperty ScrollViewer_statics<X>::ZoomFactorProperty;
template<typename X> typename ScrollViewer_statics<X>::_ZoomModeProperty ScrollViewer_statics<X>::ZoomModeProperty;
template<typename X> typename ScrollViewer_statics<X>::_ZoomSnapPointsProperty ScrollViewer_statics<X>::ZoomSnapPointsProperty;
template<typename X> typename ScrollViewer_statics<X>::_ZoomSnapPointsTypeProperty ScrollViewer_statics<X>::ZoomSnapPointsTypeProperty;
template<typename X> typename ScrollViewer_statics<X>::_LeftHeaderProperty ScrollViewer_statics<X>::LeftHeaderProperty;
template<typename X> typename ScrollViewer_statics<X>::_TopHeaderProperty ScrollViewer_statics<X>::TopHeaderProperty;
template<typename X> typename ScrollViewer_statics<X>::_TopLeftHeaderProperty ScrollViewer_statics<X>::TopLeftHeaderProperty;

template<typename X> struct statics<ScrollViewer, X> : X, Windows::UI::Xaml::Controls::ScrollViewer_statics<void> {
	typedef typename X::root_type ScrollViewer;
};
struct ScrollViewer : generate<ScrollViewer> {
	using IScrollViewer2::ChangeView;
};

// CommandBar
template<typename> struct CommandBar_statics {
	static struct _PrimaryCommandsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CommandBar, ICommandBarStatics>()->_get_PrimaryCommandsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PrimaryCommandsProperty;
	static struct _SecondaryCommandsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CommandBar, ICommandBarStatics>()->_get_SecondaryCommandsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SecondaryCommandsProperty;
	static struct _CommandBarOverflowPresenterStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CommandBar, ICommandBarStatics2>()->_get_CommandBarOverflowPresenterStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CommandBarOverflowPresenterStyleProperty;
	static struct _DefaultLabelPositionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CommandBar, ICommandBarStatics3>()->_get_DefaultLabelPositionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DefaultLabelPositionProperty;
	static struct _IsDynamicOverflowEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CommandBar, ICommandBarStatics3>()->_get_IsDynamicOverflowEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsDynamicOverflowEnabledProperty;
	static struct _OverflowButtonVisibilityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<CommandBar, ICommandBarStatics3>()->_get_OverflowButtonVisibilityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OverflowButtonVisibilityProperty;
	static CommandBar *activate(object_ref outer, IInspectable* *inner) { CommandBar *instance; hrcheck(get_activation_factory<CommandBar, ICommandBarFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename CommandBar_statics<X>::_PrimaryCommandsProperty CommandBar_statics<X>::PrimaryCommandsProperty;
template<typename X> typename CommandBar_statics<X>::_SecondaryCommandsProperty CommandBar_statics<X>::SecondaryCommandsProperty;
template<typename X> typename CommandBar_statics<X>::_CommandBarOverflowPresenterStyleProperty CommandBar_statics<X>::CommandBarOverflowPresenterStyleProperty;
template<typename X> typename CommandBar_statics<X>::_DefaultLabelPositionProperty CommandBar_statics<X>::DefaultLabelPositionProperty;
template<typename X> typename CommandBar_statics<X>::_IsDynamicOverflowEnabledProperty CommandBar_statics<X>::IsDynamicOverflowEnabledProperty;
template<typename X> typename CommandBar_statics<X>::_OverflowButtonVisibilityProperty CommandBar_statics<X>::OverflowButtonVisibilityProperty;

template<typename X> struct statics<CommandBar, X> : X, Windows::UI::Xaml::Controls::CommandBar_statics<void> {
	using Windows::UI::Xaml::Controls::CommandBar_statics<void>::activate;
	typedef typename X::root_type CommandBar;
};
struct CommandBar : generate<CommandBar> {};

// GridViewHeaderItem
template<typename> struct GridViewHeaderItem_statics {
	static GridViewHeaderItem *activate(object_ref outer, IInspectable* *inner) { GridViewHeaderItem *instance; hrcheck(get_activation_factory<GridViewHeaderItem, IGridViewHeaderItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<GridViewHeaderItem, X> : X, Windows::UI::Xaml::Controls::GridViewHeaderItem_statics<void> {
	using Windows::UI::Xaml::Controls::GridViewHeaderItem_statics<void>::activate;
	typedef typename X::root_type GridViewHeaderItem;
};
struct GridViewHeaderItem : generate<GridViewHeaderItem> {};

// GridViewItem
template<typename> struct GridViewItem_statics {
	static GridViewItem *activate(object_ref outer, IInspectable* *inner) { GridViewItem *instance; hrcheck(get_activation_factory<GridViewItem, IGridViewItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<GridViewItem, X> : X, Windows::UI::Xaml::Controls::GridViewItem_statics<void> {
	using Windows::UI::Xaml::Controls::GridViewItem_statics<void>::activate;
	typedef typename X::root_type GridViewItem;
};
struct GridViewItem : generate<GridViewItem> {};

// ListViewHeaderItem
template<typename> struct ListViewHeaderItem_statics {
	static ListViewHeaderItem *activate(object_ref outer, IInspectable* *inner) { ListViewHeaderItem *instance; hrcheck(get_activation_factory<ListViewHeaderItem, IListViewHeaderItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<ListViewHeaderItem, X> : X, Windows::UI::Xaml::Controls::ListViewHeaderItem_statics<void> {
	using Windows::UI::Xaml::Controls::ListViewHeaderItem_statics<void>::activate;
	typedef typename X::root_type ListViewHeaderItem;
};
struct ListViewHeaderItem : generate<ListViewHeaderItem> {};

// ListViewItem
template<typename> struct ListViewItem_statics {
	static ListViewItem *activate(object_ref outer, IInspectable* *inner) { ListViewItem *instance; hrcheck(get_activation_factory<ListViewItem, IListViewItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<ListViewItem, X> : X, Windows::UI::Xaml::Controls::ListViewItem_statics<void> {
	using Windows::UI::Xaml::Controls::ListViewItem_statics<void>::activate;
	typedef typename X::root_type ListViewItem;
};
struct ListViewItem : generate<ListViewItem> {};

// INavigationViewItemBaseFactory
struct INavigationViewItemBaseFactory : IInspectable, generate<INavigationViewItemBaseFactory> {};

// INavigationViewItemBase
struct INavigationViewItemBase : IInspectable, generate<INavigationViewItemBase> {};

// NavigationViewItemBase
template<typename X> struct statics<NavigationViewItemBase, X> : X {
	typedef typename X::root_type NavigationViewItemBase;
};
struct NavigationViewItemBase : generate<NavigationViewItemBase> {};

// INavigationViewItemStatics
struct INavigationViewItemStatics : IInspectable {
	virtual STDMETHODIMP _get_IconProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_CompactPaneLengthProperty(DependencyProperty* *value);
};

// INavigationViewItemFactory
struct INavigationViewItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, NavigationViewItem* *instance);
};

// INavigationViewItem
struct INavigationViewItem_raw : IInspectable {
	virtual STDMETHODIMP _get_Icon(IconElement* *value);
	virtual STDMETHODIMP _put_Icon(IconElement* value);
	virtual STDMETHODIMP _get_CompactPaneLength(double *value);
};
template<typename X> struct INavigationViewItem_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&INavigationViewItem_adaptor::CompactPaneLength)->_get_CompactPaneLength(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} CompactPaneLength;
		struct : property {
			ptr<IconElement> get() { IconElement* value; hrcheck(enc(&INavigationViewItem_adaptor::Icon)->_get_Icon(&value)); return from_abi(value); }
			ptr<IconElement> operator()() { return get(); }
			operator ptr<IconElement> () { return get(); }
			ptr<IconElement> operator->() { return get(); }
			void put(pptr<IconElement> value) { hrcheck(enc(&INavigationViewItem_adaptor::Icon)->_put_Icon(value)); }
			void operator=(pptr<IconElement> value) { put(value); }
			void operator()(pptr<IconElement> value) { put(value); }
		} Icon;
	};
	INavigationViewItem_adaptor() {}
};
template<typename X> struct adapt<INavigationViewItem, X> : Windows::UI::Xaml::Controls::INavigationViewItem_adaptor<X> { typedef adapt INavigationViewItem; };
struct INavigationViewItem : INavigationViewItem_raw, generate<INavigationViewItem> {};

// NavigationViewItem
template<typename> struct NavigationViewItem_statics {
	static struct _CompactPaneLengthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationViewItem, INavigationViewItemStatics>()->_get_CompactPaneLengthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CompactPaneLengthProperty;
	static struct _IconProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<NavigationViewItem, INavigationViewItemStatics>()->_get_IconProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IconProperty;
	static NavigationViewItem *activate(object_ref outer, IInspectable* *inner) { NavigationViewItem *instance; hrcheck(get_activation_factory<NavigationViewItem, INavigationViewItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename NavigationViewItem_statics<X>::_CompactPaneLengthProperty NavigationViewItem_statics<X>::CompactPaneLengthProperty;
template<typename X> typename NavigationViewItem_statics<X>::_IconProperty NavigationViewItem_statics<X>::IconProperty;

template<typename X> struct statics<NavigationViewItem, X> : X, Windows::UI::Xaml::Controls::NavigationViewItem_statics<void> {
	using Windows::UI::Xaml::Controls::NavigationViewItem_statics<void>::activate;
	typedef typename X::root_type NavigationViewItem;
};
struct NavigationViewItem : generate<NavigationViewItem> {};

// INavigationViewItemSeparatorFactory
struct INavigationViewItemSeparatorFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, NavigationViewItemSeparator* *instance);
};

// INavigationViewItemSeparator
struct INavigationViewItemSeparator : IInspectable, generate<INavigationViewItemSeparator> {};

// NavigationViewItemSeparator
template<typename> struct NavigationViewItemSeparator_statics {
	static NavigationViewItemSeparator *activate(object_ref outer, IInspectable* *inner) { NavigationViewItemSeparator *instance; hrcheck(get_activation_factory<NavigationViewItemSeparator, INavigationViewItemSeparatorFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<NavigationViewItemSeparator, X> : X, Windows::UI::Xaml::Controls::NavigationViewItemSeparator_statics<void> {
	using Windows::UI::Xaml::Controls::NavigationViewItemSeparator_statics<void>::activate;
	typedef typename X::root_type NavigationViewItemSeparator;
};
struct NavigationViewItemSeparator : generate<NavigationViewItemSeparator> {};

// INavigationViewItemHeaderFactory
struct INavigationViewItemHeaderFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, NavigationViewItemHeader* *instance);
};

// INavigationViewItemHeader
struct INavigationViewItemHeader : IInspectable, generate<INavigationViewItemHeader> {};

// NavigationViewItemHeader
template<typename> struct NavigationViewItemHeader_statics {
	static NavigationViewItemHeader *activate(object_ref outer, IInspectable* *inner) { NavigationViewItemHeader *instance; hrcheck(get_activation_factory<NavigationViewItemHeader, INavigationViewItemHeaderFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<NavigationViewItemHeader, X> : X, Windows::UI::Xaml::Controls::NavigationViewItemHeader_statics<void> {
	using Windows::UI::Xaml::Controls::NavigationViewItemHeader_statics<void>::activate;
	typedef typename X::root_type NavigationViewItemHeader;
};
struct NavigationViewItemHeader : generate<NavigationViewItemHeader> {};

// TreeViewItem
template<typename> struct TreeViewItem_statics {
	static struct _CollapsedGlyphProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeViewItem, ITreeViewItemStatics>()->_get_CollapsedGlyphProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CollapsedGlyphProperty;
	static struct _ExpandedGlyphProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeViewItem, ITreeViewItemStatics>()->_get_ExpandedGlyphProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ExpandedGlyphProperty;
	static struct _GlyphBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeViewItem, ITreeViewItemStatics>()->_get_GlyphBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GlyphBrushProperty;
	static struct _GlyphOpacityProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeViewItem, ITreeViewItemStatics>()->_get_GlyphOpacityProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GlyphOpacityProperty;
	static struct _GlyphSizeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeViewItem, ITreeViewItemStatics>()->_get_GlyphSizeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} GlyphSizeProperty;
	static struct _IsExpandedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeViewItem, ITreeViewItemStatics>()->_get_IsExpandedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsExpandedProperty;
	static struct _TreeViewItemTemplateSettingsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TreeViewItem, ITreeViewItemStatics>()->_get_TreeViewItemTemplateSettingsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TreeViewItemTemplateSettingsProperty;
	static TreeViewItem *activate(object_ref outer, IInspectable* *inner) { TreeViewItem *instance; hrcheck(get_activation_factory<TreeViewItem, ITreeViewItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename TreeViewItem_statics<X>::_CollapsedGlyphProperty TreeViewItem_statics<X>::CollapsedGlyphProperty;
template<typename X> typename TreeViewItem_statics<X>::_ExpandedGlyphProperty TreeViewItem_statics<X>::ExpandedGlyphProperty;
template<typename X> typename TreeViewItem_statics<X>::_GlyphBrushProperty TreeViewItem_statics<X>::GlyphBrushProperty;
template<typename X> typename TreeViewItem_statics<X>::_GlyphOpacityProperty TreeViewItem_statics<X>::GlyphOpacityProperty;
template<typename X> typename TreeViewItem_statics<X>::_GlyphSizeProperty TreeViewItem_statics<X>::GlyphSizeProperty;
template<typename X> typename TreeViewItem_statics<X>::_IsExpandedProperty TreeViewItem_statics<X>::IsExpandedProperty;
template<typename X> typename TreeViewItem_statics<X>::_TreeViewItemTemplateSettingsProperty TreeViewItem_statics<X>::TreeViewItemTemplateSettingsProperty;

template<typename X> struct statics<TreeViewItem, X> : X, Windows::UI::Xaml::Controls::TreeViewItem_statics<void> {
	using Windows::UI::Xaml::Controls::TreeViewItem_statics<void>::activate;
	typedef typename X::root_type TreeViewItem;
};
struct TreeViewItem : generate<TreeViewItem> {};

// ToggleMenuFlyoutItem
template<typename> struct ToggleMenuFlyoutItem_statics {
	static struct _IsCheckedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ToggleMenuFlyoutItem, IToggleMenuFlyoutItemStatics>()->_get_IsCheckedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsCheckedProperty;
	static ToggleMenuFlyoutItem *activate(object_ref outer, IInspectable* *inner) { ToggleMenuFlyoutItem *instance; hrcheck(get_activation_factory<ToggleMenuFlyoutItem, IToggleMenuFlyoutItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename ToggleMenuFlyoutItem_statics<X>::_IsCheckedProperty ToggleMenuFlyoutItem_statics<X>::IsCheckedProperty;

template<typename X> struct statics<ToggleMenuFlyoutItem, X> : X, Windows::UI::Xaml::Controls::ToggleMenuFlyoutItem_statics<void> {
	using Windows::UI::Xaml::Controls::ToggleMenuFlyoutItem_statics<void>::activate;
	typedef typename X::root_type ToggleMenuFlyoutItem;
};
struct ToggleMenuFlyoutItem : generate<ToggleMenuFlyoutItem> {};

// AppBarButton
template<typename> struct AppBarButton_statics {
	static struct _IconProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarButton, IAppBarButtonStatics>()->_get_IconProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IconProperty;
	static struct _IsCompactProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarButton, IAppBarButtonStatics>()->_get_IsCompactProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsCompactProperty;
	static struct _LabelProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarButton, IAppBarButtonStatics>()->_get_LabelProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LabelProperty;
	static struct _DynamicOverflowOrderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarButton, IAppBarButtonStatics3>()->_get_DynamicOverflowOrderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DynamicOverflowOrderProperty;
	static struct _IsInOverflowProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarButton, IAppBarButtonStatics3>()->_get_IsInOverflowProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsInOverflowProperty;
	static struct _LabelPositionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarButton, IAppBarButtonStatics3>()->_get_LabelPositionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LabelPositionProperty;
	static struct _KeyboardAcceleratorTextOverrideProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarButton, IAppBarButtonStatics4>()->_get_KeyboardAcceleratorTextOverrideProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeyboardAcceleratorTextOverrideProperty;
	static AppBarButton *activate(object_ref outer, IInspectable* *inner) { AppBarButton *instance; hrcheck(get_activation_factory<AppBarButton, IAppBarButtonFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename AppBarButton_statics<X>::_IconProperty AppBarButton_statics<X>::IconProperty;
template<typename X> typename AppBarButton_statics<X>::_IsCompactProperty AppBarButton_statics<X>::IsCompactProperty;
template<typename X> typename AppBarButton_statics<X>::_LabelProperty AppBarButton_statics<X>::LabelProperty;
template<typename X> typename AppBarButton_statics<X>::_DynamicOverflowOrderProperty AppBarButton_statics<X>::DynamicOverflowOrderProperty;
template<typename X> typename AppBarButton_statics<X>::_IsInOverflowProperty AppBarButton_statics<X>::IsInOverflowProperty;
template<typename X> typename AppBarButton_statics<X>::_LabelPositionProperty AppBarButton_statics<X>::LabelPositionProperty;
template<typename X> typename AppBarButton_statics<X>::_KeyboardAcceleratorTextOverrideProperty AppBarButton_statics<X>::KeyboardAcceleratorTextOverrideProperty;

template<typename X> struct statics<AppBarButton, X> : X, Windows::UI::Xaml::Controls::AppBarButton_statics<void> {
	using Windows::UI::Xaml::Controls::AppBarButton_statics<void>::activate;
	typedef typename X::root_type AppBarButton;
};
struct AppBarButton : generate<AppBarButton> {};

// AppBarToggleButton
template<typename> struct AppBarToggleButton_statics {
	static struct _IconProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarToggleButton, IAppBarToggleButtonStatics>()->_get_IconProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IconProperty;
	static struct _IsCompactProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarToggleButton, IAppBarToggleButtonStatics>()->_get_IsCompactProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsCompactProperty;
	static struct _LabelProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarToggleButton, IAppBarToggleButtonStatics>()->_get_LabelProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LabelProperty;
	static struct _DynamicOverflowOrderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarToggleButton, IAppBarToggleButtonStatics3>()->_get_DynamicOverflowOrderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DynamicOverflowOrderProperty;
	static struct _IsInOverflowProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarToggleButton, IAppBarToggleButtonStatics3>()->_get_IsInOverflowProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsInOverflowProperty;
	static struct _LabelPositionProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarToggleButton, IAppBarToggleButtonStatics3>()->_get_LabelPositionProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LabelPositionProperty;
	static struct _KeyboardAcceleratorTextOverrideProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<AppBarToggleButton, IAppBarToggleButtonStatics4>()->_get_KeyboardAcceleratorTextOverrideProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KeyboardAcceleratorTextOverrideProperty;
	static AppBarToggleButton *activate(object_ref outer, IInspectable* *inner) { AppBarToggleButton *instance; hrcheck(get_activation_factory<AppBarToggleButton, IAppBarToggleButtonFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename AppBarToggleButton_statics<X>::_IconProperty AppBarToggleButton_statics<X>::IconProperty;
template<typename X> typename AppBarToggleButton_statics<X>::_IsCompactProperty AppBarToggleButton_statics<X>::IsCompactProperty;
template<typename X> typename AppBarToggleButton_statics<X>::_LabelProperty AppBarToggleButton_statics<X>::LabelProperty;
template<typename X> typename AppBarToggleButton_statics<X>::_DynamicOverflowOrderProperty AppBarToggleButton_statics<X>::DynamicOverflowOrderProperty;
template<typename X> typename AppBarToggleButton_statics<X>::_IsInOverflowProperty AppBarToggleButton_statics<X>::IsInOverflowProperty;
template<typename X> typename AppBarToggleButton_statics<X>::_LabelPositionProperty AppBarToggleButton_statics<X>::LabelPositionProperty;
template<typename X> typename AppBarToggleButton_statics<X>::_KeyboardAcceleratorTextOverrideProperty AppBarToggleButton_statics<X>::KeyboardAcceleratorTextOverrideProperty;

template<typename X> struct statics<AppBarToggleButton, X> : X, Windows::UI::Xaml::Controls::AppBarToggleButton_statics<void> {
	using Windows::UI::Xaml::Controls::AppBarToggleButton_statics<void>::activate;
	typedef typename X::root_type AppBarToggleButton;
};
struct AppBarToggleButton : generate<AppBarToggleButton> {};

// GridView
template<typename> struct GridView_statics {
	static GridView *activate(object_ref outer, IInspectable* *inner) { GridView *instance; hrcheck(get_activation_factory<GridView, IGridViewFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<GridView, X> : X, Windows::UI::Xaml::Controls::GridView_statics<void> {
	using Windows::UI::Xaml::Controls::GridView_statics<void>::activate;
	typedef typename X::root_type GridView;
};
struct GridView : generate<GridView> {
	using IListViewBase::ScrollIntoView;
};

// ListView
template<typename> struct ListView_statics {
	static ListView *activate(object_ref outer, IInspectable* *inner) { ListView *instance; hrcheck(get_activation_factory<ListView, IListViewFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<ListView, X> : X, Windows::UI::Xaml::Controls::ListView_statics<void> {
	using Windows::UI::Xaml::Controls::ListView_statics<void>::activate;
	typedef typename X::root_type ListView;
};
struct ListView : generate<ListView> {
	using IListViewBase::ScrollIntoView;
};

// INavigationViewListFactory
struct INavigationViewListFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, NavigationViewList* *instance);
};

// INavigationViewList
struct INavigationViewList : IInspectable, generate<INavigationViewList> {};

// NavigationViewList
template<typename> struct NavigationViewList_statics {
	static NavigationViewList *activate(object_ref outer, IInspectable* *inner) { NavigationViewList *instance; hrcheck(get_activation_factory<NavigationViewList, INavigationViewListFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<NavigationViewList, X> : X, Windows::UI::Xaml::Controls::NavigationViewList_statics<void> {
	using Windows::UI::Xaml::Controls::NavigationViewList_statics<void>::activate;
	typedef typename X::root_type NavigationViewList;
};
struct NavigationViewList : generate<NavigationViewList> {
	using IListViewBase::ScrollIntoView;
};

// TreeViewList
template<typename> struct TreeViewList_statics {
	static TreeViewList *activate(object_ref outer, IInspectable* *inner) { TreeViewList *instance; hrcheck(get_activation_factory<TreeViewList, ITreeViewListFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<TreeViewList, X> : X, Windows::UI::Xaml::Controls::TreeViewList_statics<void> {
	using Windows::UI::Xaml::Controls::TreeViewList_statics<void>::activate;
	typedef typename X::root_type TreeViewList;
};
struct TreeViewList : generate<TreeViewList> {
	using IListViewBase::ScrollIntoView;
};

// Flyout
template<typename> struct Flyout_statics {
	static struct _ContentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Flyout, IFlyoutStatics>()->_get_ContentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentProperty;
	static struct _FlyoutPresenterStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Flyout, IFlyoutStatics>()->_get_FlyoutPresenterStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} FlyoutPresenterStyleProperty;
	static Flyout *activate(object_ref outer, IInspectable* *inner) { Flyout *instance; hrcheck(get_activation_factory<Flyout, IFlyoutFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename Flyout_statics<X>::_ContentProperty Flyout_statics<X>::ContentProperty;
template<typename X> typename Flyout_statics<X>::_FlyoutPresenterStyleProperty Flyout_statics<X>::FlyoutPresenterStyleProperty;

template<typename X> struct statics<Flyout, X> : X, Windows::UI::Xaml::Controls::Flyout_statics<void> {
	using Windows::UI::Xaml::Controls::Flyout_statics<void>::activate;
	typedef typename X::root_type Flyout;
};
struct Flyout : generate<Flyout> {};

// MenuFlyout
template<typename> struct MenuFlyout_statics {
	static struct _MenuFlyoutPresenterStyleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<MenuFlyout, IMenuFlyoutStatics>()->_get_MenuFlyoutPresenterStyleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MenuFlyoutPresenterStyleProperty;
	static MenuFlyout *activate(object_ref outer, IInspectable* *inner) { MenuFlyout *instance; hrcheck(get_activation_factory<MenuFlyout, IMenuFlyoutFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename MenuFlyout_statics<X>::_MenuFlyoutPresenterStyleProperty MenuFlyout_statics<X>::MenuFlyoutPresenterStyleProperty;

template<typename X> struct statics<MenuFlyout, X> : X, Windows::UI::Xaml::Controls::MenuFlyout_statics<void> {
	using Windows::UI::Xaml::Controls::MenuFlyout_statics<void>::activate;
	typedef typename X::root_type MenuFlyout;
};
struct MenuFlyout : generate<MenuFlyout> {
	using IMenuFlyout2::ShowAt;
	using IFlyoutBase::ShowAt;
};

// WebViewBrush
template<typename> struct WebViewBrush_statics {
	static struct _SourceNameProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<WebViewBrush, IWebViewBrushStatics>()->_get_SourceNameProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SourceNameProperty;
};
template<typename X> typename WebViewBrush_statics<X>::_SourceNameProperty WebViewBrush_statics<X>::SourceNameProperty;

template<typename X> struct statics<WebViewBrush, X> : X, Windows::UI::Xaml::Controls::WebViewBrush_statics<void> {
	typedef typename X::root_type WebViewBrush;
};
struct WebViewBrush : generate<WebViewBrush> {};

// IInkToolbarIsStencilButtonCheckedChangedEventArgs
struct IInkToolbarIsStencilButtonCheckedChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_StencilButton(InkToolbarStencilButton* *value);
	virtual STDMETHODIMP _get_StencilKind(InkToolbarStencilKind *value);
};
template<typename X> struct IInkToolbarIsStencilButtonCheckedChangedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<InkToolbarStencilButton> get() { InkToolbarStencilButton* value; hrcheck(enc(&IInkToolbarIsStencilButtonCheckedChangedEventArgs_adaptor::StencilButton)->_get_StencilButton(&value)); return from_abi(value); }
			ptr<InkToolbarStencilButton> operator()() { return get(); }
			operator ptr<InkToolbarStencilButton> () { return get(); }
			ptr<InkToolbarStencilButton> operator->() { return get(); }
		} StencilButton;
		struct : property {
			InkToolbarStencilKind get() { InkToolbarStencilKind value; hrcheck(enc(&IInkToolbarIsStencilButtonCheckedChangedEventArgs_adaptor::StencilKind)->_get_StencilKind(&value)); return value; }
			InkToolbarStencilKind operator()() { return get(); }
			operator InkToolbarStencilKind () { return get(); }
		} StencilKind;
	};
	IInkToolbarIsStencilButtonCheckedChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IInkToolbarIsStencilButtonCheckedChangedEventArgs, X> : Windows::UI::Xaml::Controls::IInkToolbarIsStencilButtonCheckedChangedEventArgs_adaptor<X> { typedef adapt IInkToolbarIsStencilButtonCheckedChangedEventArgs; };
struct IInkToolbarIsStencilButtonCheckedChangedEventArgs : IInkToolbarIsStencilButtonCheckedChangedEventArgs_raw, generate<IInkToolbarIsStencilButtonCheckedChangedEventArgs> {};

// InkToolbarIsStencilButtonCheckedChangedEventArgs
template<typename X> struct statics<InkToolbarIsStencilButtonCheckedChangedEventArgs, X> : X {
	typedef typename X::root_type InkToolbarIsStencilButtonCheckedChangedEventArgs;
};
struct InkToolbarIsStencilButtonCheckedChangedEventArgs : generate<InkToolbarIsStencilButtonCheckedChangedEventArgs> {};

// IInkToolbarCustomPen
struct IInkToolbarCustomPen_raw : IInspectable {
	virtual STDMETHODIMP _CreateInkDrawingAttributes(Media::Brush* brush, double strokeWidth, UI::Input::Inking::InkDrawingAttributes* *returnValue);
};
template<typename X> struct IInkToolbarCustomPen_adaptor : X {
	ptr<UI::Input::Inking::InkDrawingAttributes> CreateInkDrawingAttributes(pptr<Media::Brush> brush, double strokeWidth) { UI::Input::Inking::InkDrawingAttributes* returnValue; hrcheck(X::get()->_CreateInkDrawingAttributes(brush, strokeWidth, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IInkToolbarCustomPen, X> : Windows::UI::Xaml::Controls::IInkToolbarCustomPen_adaptor<X> { typedef adapt IInkToolbarCustomPen; };
struct IInkToolbarCustomPen : IInkToolbarCustomPen_raw, generate<IInkToolbarCustomPen> {};

// IInkToolbarCustomPenOverrides
struct IInkToolbarCustomPenOverrides_raw : IInspectable {
	virtual STDMETHODIMP _CreateInkDrawingAttributesCore(Media::Brush* brush, double strokeWidth, UI::Input::Inking::InkDrawingAttributes* *returnValue) = 0;
};
template<typename X> struct IInkToolbarCustomPenOverrides_adaptor : X {
	ptr<UI::Input::Inking::InkDrawingAttributes> CreateInkDrawingAttributesCore(pptr<Media::Brush> brush, double strokeWidth) { UI::Input::Inking::InkDrawingAttributes* returnValue; hrcheck(X::get()->_CreateInkDrawingAttributesCore(brush, strokeWidth, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IInkToolbarCustomPenOverrides, X> : Windows::UI::Xaml::Controls::IInkToolbarCustomPenOverrides_adaptor<X> { typedef adapt IInkToolbarCustomPenOverrides; };
template<typename X> struct IInkToolbarCustomPenOverrides_unadaptor : X {
	STDMETHODIMP _CreateInkDrawingAttributesCore(Media::Brush* brush, double strokeWidth, UI::Input::Inking::InkDrawingAttributes* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->CreateInkDrawingAttributesCore(brush, strokeWidth)); }); }
};
template<typename X> struct unadapt<IInkToolbarCustomPenOverrides, X> : Windows::UI::Xaml::Controls::IInkToolbarCustomPenOverrides_unadaptor<X> {};
struct IInkToolbarCustomPenOverrides : IInkToolbarCustomPenOverrides_raw, generate<IInkToolbarCustomPenOverrides> {};

// IInkToolbarCustomPenFactory
struct IInkToolbarCustomPenFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, InkToolbarCustomPen* *instance);
};

// InkToolbarCustomPen
template<typename X> struct statics<InkToolbarCustomPen, X> : X {
	typedef typename X::root_type InkToolbarCustomPen;
};
struct InkToolbarCustomPen : generate<InkToolbarCustomPen> {};

// IInkToolbar
struct IInkToolbar_raw : IInspectable {
	virtual STDMETHODIMP _get_InitialControls(InkToolbarInitialControls *value);
	virtual STDMETHODIMP _put_InitialControls(InkToolbarInitialControls value);
	virtual STDMETHODIMP _get_Children(DependencyObjectCollection* *value);
	virtual STDMETHODIMP _get_ActiveTool(InkToolbarToolButton* *value);
	virtual STDMETHODIMP _put_ActiveTool(InkToolbarToolButton* value);
	virtual STDMETHODIMP _get_InkDrawingAttributes(UI::Input::Inking::InkDrawingAttributes* *value);
	virtual STDMETHODIMP _get_IsRulerButtonChecked(bool *value);
	virtual STDMETHODIMP _put_IsRulerButtonChecked(bool value);
	virtual STDMETHODIMP _get_TargetInkCanvas(InkCanvas* *value);
	virtual STDMETHODIMP _put_TargetInkCanvas(InkCanvas* value);
	virtual STDMETHODIMP _add_ActiveToolChanged(Foundation::TypedEventHandler<InkToolbar*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ActiveToolChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_InkDrawingAttributesChanged(Foundation::TypedEventHandler<InkToolbar*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_InkDrawingAttributesChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_EraseAllClicked(Foundation::TypedEventHandler<InkToolbar*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_EraseAllClicked(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_IsRulerButtonCheckedChanged(Foundation::TypedEventHandler<InkToolbar*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_IsRulerButtonCheckedChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _GetToolButton(InkToolbarTool tool, InkToolbarToolButton* *returnValue);
	virtual STDMETHODIMP _GetToggleButton(InkToolbarToggle tool, InkToolbarToggleButton* *returnValue);
};
template<typename X> struct IInkToolbar_adaptor : X {
	union {
		struct : property {
			ptr<InkToolbarToolButton> get() { InkToolbarToolButton* value; hrcheck(enc(&IInkToolbar_adaptor::ActiveTool)->_get_ActiveTool(&value)); return from_abi(value); }
			ptr<InkToolbarToolButton> operator()() { return get(); }
			operator ptr<InkToolbarToolButton> () { return get(); }
			ptr<InkToolbarToolButton> operator->() { return get(); }
			void put(pptr<InkToolbarToolButton> value) { hrcheck(enc(&IInkToolbar_adaptor::ActiveTool)->_put_ActiveTool(value)); }
			void operator=(pptr<InkToolbarToolButton> value) { put(value); }
			void operator()(pptr<InkToolbarToolButton> value) { put(value); }
		} ActiveTool;
		struct : property {
			ptr<DependencyObjectCollection> get() { DependencyObjectCollection* value; hrcheck(enc(&IInkToolbar_adaptor::Children)->_get_Children(&value)); return from_abi(value); }
			ptr<DependencyObjectCollection> operator()() { return get(); }
			operator ptr<DependencyObjectCollection> () { return get(); }
			ptr<DependencyObjectCollection> operator->() { return get(); }
		} Children;
		struct : property {
			InkToolbarInitialControls get() { InkToolbarInitialControls value; hrcheck(enc(&IInkToolbar_adaptor::InitialControls)->_get_InitialControls(&value)); return value; }
			InkToolbarInitialControls operator()() { return get(); }
			operator InkToolbarInitialControls () { return get(); }
			void put(InkToolbarInitialControls value) { hrcheck(enc(&IInkToolbar_adaptor::InitialControls)->_put_InitialControls(value)); }
			void operator=(InkToolbarInitialControls value) { put(value); }
			void operator()(InkToolbarInitialControls value) { put(value); }
		} InitialControls;
		struct : property {
			ptr<UI::Input::Inking::InkDrawingAttributes> get() { UI::Input::Inking::InkDrawingAttributes* value; hrcheck(enc(&IInkToolbar_adaptor::InkDrawingAttributes)->_get_InkDrawingAttributes(&value)); return from_abi(value); }
			ptr<UI::Input::Inking::InkDrawingAttributes> operator()() { return get(); }
			operator ptr<UI::Input::Inking::InkDrawingAttributes> () { return get(); }
			ptr<UI::Input::Inking::InkDrawingAttributes> operator->() { return get(); }
		} InkDrawingAttributes;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IInkToolbar_adaptor::IsRulerButtonChecked)->_get_IsRulerButtonChecked(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IInkToolbar_adaptor::IsRulerButtonChecked)->_put_IsRulerButtonChecked(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsRulerButtonChecked;
		struct : property {
			ptr<InkCanvas> get() { InkCanvas* value; hrcheck(enc(&IInkToolbar_adaptor::TargetInkCanvas)->_get_TargetInkCanvas(&value)); return from_abi(value); }
			ptr<InkCanvas> operator()() { return get(); }
			operator ptr<InkCanvas> () { return get(); }
			ptr<InkCanvas> operator->() { return get(); }
			void put(pptr<InkCanvas> value) { hrcheck(enc(&IInkToolbar_adaptor::TargetInkCanvas)->_put_TargetInkCanvas(value)); }
			void operator=(pptr<InkCanvas> value) { put(value); }
			void operator()(pptr<InkCanvas> value) { put(value); }
		} TargetInkCanvas;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<InkToolbar>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IInkToolbar_adaptor::ActiveToolChanged)->_add_ActiveToolChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IInkToolbar_adaptor::ActiveToolChanged)->_remove_ActiveToolChanged(token)); }
		} ActiveToolChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<InkToolbar>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IInkToolbar_adaptor::EraseAllClicked)->_add_EraseAllClicked(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IInkToolbar_adaptor::EraseAllClicked)->_remove_EraseAllClicked(token)); }
		} EraseAllClicked;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<InkToolbar>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IInkToolbar_adaptor::InkDrawingAttributesChanged)->_add_InkDrawingAttributesChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IInkToolbar_adaptor::InkDrawingAttributesChanged)->_remove_InkDrawingAttributesChanged(token)); }
		} InkDrawingAttributesChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<InkToolbar>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IInkToolbar_adaptor::IsRulerButtonCheckedChanged)->_add_IsRulerButtonCheckedChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IInkToolbar_adaptor::IsRulerButtonCheckedChanged)->_remove_IsRulerButtonCheckedChanged(token)); }
		} IsRulerButtonCheckedChanged;
	};
	ptr<InkToolbarToolButton> GetToolButton(InkToolbarTool tool) { InkToolbarToolButton* returnValue; hrcheck(X::get()->_GetToolButton(tool, &returnValue)); return from_abi(returnValue); }
	ptr<InkToolbarToggleButton> GetToggleButton(InkToolbarToggle tool) { InkToolbarToggleButton* returnValue; hrcheck(X::get()->_GetToggleButton(tool, &returnValue)); return from_abi(returnValue); }
	IInkToolbar_adaptor() {}
};
template<typename X> struct adapt<IInkToolbar, X> : Windows::UI::Xaml::Controls::IInkToolbar_adaptor<X> { typedef adapt IInkToolbar; };
struct IInkToolbar : IInkToolbar_raw, generate<IInkToolbar> {};

// IInkToolbarStatics
struct IInkToolbarStatics : IInspectable {
	virtual STDMETHODIMP _get_InitialControlsProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ChildrenProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ActiveToolProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_InkDrawingAttributesProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsRulerButtonCheckedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TargetInkCanvasProperty(DependencyProperty* *value);
};

// IInkToolbarFactory
struct IInkToolbarFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, InkToolbar* *instance);
};

// IInkToolbar2
struct IInkToolbar2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsStencilButtonChecked(bool *value);
	virtual STDMETHODIMP _put_IsStencilButtonChecked(bool value);
	virtual STDMETHODIMP _get_ButtonFlyoutPlacement(InkToolbarButtonFlyoutPlacement *value);
	virtual STDMETHODIMP _put_ButtonFlyoutPlacement(InkToolbarButtonFlyoutPlacement value);
	virtual STDMETHODIMP _get_Orientation(Controls::Orientation *value);
	virtual STDMETHODIMP _put_Orientation(Controls::Orientation value);
	virtual STDMETHODIMP _add_IsStencilButtonCheckedChanged(Foundation::TypedEventHandler<InkToolbar*, InkToolbarIsStencilButtonCheckedChangedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_IsStencilButtonCheckedChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _GetMenuButton(InkToolbarMenuKind menu, InkToolbarMenuButton* *returnValue);
};
template<typename X> struct IInkToolbar2_adaptor : X {
	union {
		struct : property {
			InkToolbarButtonFlyoutPlacement get() { InkToolbarButtonFlyoutPlacement value; hrcheck(enc(&IInkToolbar2_adaptor::ButtonFlyoutPlacement)->_get_ButtonFlyoutPlacement(&value)); return value; }
			InkToolbarButtonFlyoutPlacement operator()() { return get(); }
			operator InkToolbarButtonFlyoutPlacement () { return get(); }
			void put(InkToolbarButtonFlyoutPlacement value) { hrcheck(enc(&IInkToolbar2_adaptor::ButtonFlyoutPlacement)->_put_ButtonFlyoutPlacement(value)); }
			void operator=(InkToolbarButtonFlyoutPlacement value) { put(value); }
			void operator()(InkToolbarButtonFlyoutPlacement value) { put(value); }
		} ButtonFlyoutPlacement;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IInkToolbar2_adaptor::IsStencilButtonChecked)->_get_IsStencilButtonChecked(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IInkToolbar2_adaptor::IsStencilButtonChecked)->_put_IsStencilButtonChecked(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsStencilButtonChecked;
		struct : property {
			Controls::Orientation get() { Controls::Orientation value; hrcheck(enc(&IInkToolbar2_adaptor::Orientation)->_get_Orientation(&value)); return value; }
			Controls::Orientation operator()() { return get(); }
			operator Controls::Orientation () { return get(); }
			void put(Controls::Orientation value) { hrcheck(enc(&IInkToolbar2_adaptor::Orientation)->_put_Orientation(value)); }
			void operator=(Controls::Orientation value) { put(value); }
			void operator()(Controls::Orientation value) { put(value); }
		} Orientation;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<InkToolbar>, ptr<InkToolbarIsStencilButtonCheckedChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IInkToolbar2_adaptor::IsStencilButtonCheckedChanged)->_add_IsStencilButtonCheckedChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IInkToolbar2_adaptor::IsStencilButtonCheckedChanged)->_remove_IsStencilButtonCheckedChanged(token)); }
		} IsStencilButtonCheckedChanged;
	};
	ptr<InkToolbarMenuButton> GetMenuButton(InkToolbarMenuKind menu) { InkToolbarMenuButton* returnValue; hrcheck(X::get()->_GetMenuButton(menu, &returnValue)); return from_abi(returnValue); }
	IInkToolbar2_adaptor() {}
};
template<typename X> struct adapt<IInkToolbar2, X> : Windows::UI::Xaml::Controls::IInkToolbar2_adaptor<X> { typedef adapt IInkToolbar2; };
struct IInkToolbar2 : IInkToolbar2_raw, generate<IInkToolbar2> {};

// IInkToolbarStatics2
struct IInkToolbarStatics2 : IInspectable {
	virtual STDMETHODIMP _get_IsStencilButtonCheckedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ButtonFlyoutPlacementProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_OrientationProperty(DependencyProperty* *value);
};

// InkToolbar
template<typename> struct InkToolbar_statics {
	static struct _ActiveToolProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbar, IInkToolbarStatics>()->_get_ActiveToolProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ActiveToolProperty;
	static struct _ChildrenProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbar, IInkToolbarStatics>()->_get_ChildrenProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ChildrenProperty;
	static struct _InitialControlsProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbar, IInkToolbarStatics>()->_get_InitialControlsProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} InitialControlsProperty;
	static struct _InkDrawingAttributesProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbar, IInkToolbarStatics>()->_get_InkDrawingAttributesProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} InkDrawingAttributesProperty;
	static struct _IsRulerButtonCheckedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbar, IInkToolbarStatics>()->_get_IsRulerButtonCheckedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsRulerButtonCheckedProperty;
	static struct _TargetInkCanvasProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbar, IInkToolbarStatics>()->_get_TargetInkCanvasProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TargetInkCanvasProperty;
	static struct _ButtonFlyoutPlacementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbar, IInkToolbarStatics2>()->_get_ButtonFlyoutPlacementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ButtonFlyoutPlacementProperty;
	static struct _IsStencilButtonCheckedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbar, IInkToolbarStatics2>()->_get_IsStencilButtonCheckedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsStencilButtonCheckedProperty;
	static struct _OrientationProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbar, IInkToolbarStatics2>()->_get_OrientationProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} OrientationProperty;
	static InkToolbar *activate(object_ref outer, IInspectable* *inner) { InkToolbar *instance; hrcheck(get_activation_factory<InkToolbar, IInkToolbarFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename InkToolbar_statics<X>::_ActiveToolProperty InkToolbar_statics<X>::ActiveToolProperty;
template<typename X> typename InkToolbar_statics<X>::_ChildrenProperty InkToolbar_statics<X>::ChildrenProperty;
template<typename X> typename InkToolbar_statics<X>::_InitialControlsProperty InkToolbar_statics<X>::InitialControlsProperty;
template<typename X> typename InkToolbar_statics<X>::_InkDrawingAttributesProperty InkToolbar_statics<X>::InkDrawingAttributesProperty;
template<typename X> typename InkToolbar_statics<X>::_IsRulerButtonCheckedProperty InkToolbar_statics<X>::IsRulerButtonCheckedProperty;
template<typename X> typename InkToolbar_statics<X>::_TargetInkCanvasProperty InkToolbar_statics<X>::TargetInkCanvasProperty;
template<typename X> typename InkToolbar_statics<X>::_ButtonFlyoutPlacementProperty InkToolbar_statics<X>::ButtonFlyoutPlacementProperty;
template<typename X> typename InkToolbar_statics<X>::_IsStencilButtonCheckedProperty InkToolbar_statics<X>::IsStencilButtonCheckedProperty;
template<typename X> typename InkToolbar_statics<X>::_OrientationProperty InkToolbar_statics<X>::OrientationProperty;

template<typename X> struct statics<InkToolbar, X> : X, Windows::UI::Xaml::Controls::InkToolbar_statics<void> {
	using Windows::UI::Xaml::Controls::InkToolbar_statics<void>::activate;
	typedef typename X::root_type InkToolbar;
};
struct InkToolbar : generate<InkToolbar> {};

// IInkToolbarPenConfigurationControl
struct IInkToolbarPenConfigurationControl_raw : IInspectable {
	virtual STDMETHODIMP _get_PenButton(InkToolbarPenButton* *value);
};
template<typename X> struct IInkToolbarPenConfigurationControl_adaptor : X {
	union {
		struct : property {
			ptr<InkToolbarPenButton> get() { InkToolbarPenButton* value; hrcheck(enc(&IInkToolbarPenConfigurationControl_adaptor::PenButton)->_get_PenButton(&value)); return from_abi(value); }
			ptr<InkToolbarPenButton> operator()() { return get(); }
			operator ptr<InkToolbarPenButton> () { return get(); }
			ptr<InkToolbarPenButton> operator->() { return get(); }
		} PenButton;
	};
	IInkToolbarPenConfigurationControl_adaptor() {}
};
template<typename X> struct adapt<IInkToolbarPenConfigurationControl, X> : Windows::UI::Xaml::Controls::IInkToolbarPenConfigurationControl_adaptor<X> { typedef adapt IInkToolbarPenConfigurationControl; };
struct IInkToolbarPenConfigurationControl : IInkToolbarPenConfigurationControl_raw, generate<IInkToolbarPenConfigurationControl> {};

// IInkToolbarPenConfigurationControlStatics
struct IInkToolbarPenConfigurationControlStatics : IInspectable {
	virtual STDMETHODIMP _get_PenButtonProperty(DependencyProperty* *value);
};

// IInkToolbarPenConfigurationControlFactory
struct IInkToolbarPenConfigurationControlFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, InkToolbarPenConfigurationControl* *instance);
};

// InkToolbarPenConfigurationControl
template<typename> struct InkToolbarPenConfigurationControl_statics {
	static struct _PenButtonProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarPenConfigurationControl, IInkToolbarPenConfigurationControlStatics>()->_get_PenButtonProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PenButtonProperty;
	static InkToolbarPenConfigurationControl *activate(object_ref outer, IInspectable* *inner) { InkToolbarPenConfigurationControl *instance; hrcheck(get_activation_factory<InkToolbarPenConfigurationControl, IInkToolbarPenConfigurationControlFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename InkToolbarPenConfigurationControl_statics<X>::_PenButtonProperty InkToolbarPenConfigurationControl_statics<X>::PenButtonProperty;

template<typename X> struct statics<InkToolbarPenConfigurationControl, X> : X, Windows::UI::Xaml::Controls::InkToolbarPenConfigurationControl_statics<void> {
	using Windows::UI::Xaml::Controls::InkToolbarPenConfigurationControl_statics<void>::activate;
	typedef typename X::root_type InkToolbarPenConfigurationControl;
};
struct InkToolbarPenConfigurationControl : generate<InkToolbarPenConfigurationControl> {};

// IInkToolbarFlyoutItem
struct IInkToolbarFlyoutItem_raw : IInspectable {
	virtual STDMETHODIMP _get_Kind(InkToolbarFlyoutItemKind *value);
	virtual STDMETHODIMP _put_Kind(InkToolbarFlyoutItemKind value);
	virtual STDMETHODIMP _get_IsChecked(bool *value);
	virtual STDMETHODIMP _put_IsChecked(bool value);
	virtual STDMETHODIMP _add_Checked(Foundation::TypedEventHandler<InkToolbarFlyoutItem*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Checked(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Unchecked(Foundation::TypedEventHandler<InkToolbarFlyoutItem*, IInspectable*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Unchecked(Foundation::EventRegistrationToken token);
};
template<typename X> struct IInkToolbarFlyoutItem_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IInkToolbarFlyoutItem_adaptor::IsChecked)->_get_IsChecked(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IInkToolbarFlyoutItem_adaptor::IsChecked)->_put_IsChecked(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsChecked;
		struct : property {
			InkToolbarFlyoutItemKind get() { InkToolbarFlyoutItemKind value; hrcheck(enc(&IInkToolbarFlyoutItem_adaptor::Kind)->_get_Kind(&value)); return value; }
			InkToolbarFlyoutItemKind operator()() { return get(); }
			operator InkToolbarFlyoutItemKind () { return get(); }
			void put(InkToolbarFlyoutItemKind value) { hrcheck(enc(&IInkToolbarFlyoutItem_adaptor::Kind)->_put_Kind(value)); }
			void operator=(InkToolbarFlyoutItemKind value) { put(value); }
			void operator()(InkToolbarFlyoutItemKind value) { put(value); }
		} Kind;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<InkToolbarFlyoutItem>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IInkToolbarFlyoutItem_adaptor::Checked)->_add_Checked(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IInkToolbarFlyoutItem_adaptor::Checked)->_remove_Checked(token)); }
		} Checked;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<InkToolbarFlyoutItem>, object>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IInkToolbarFlyoutItem_adaptor::Unchecked)->_add_Unchecked(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IInkToolbarFlyoutItem_adaptor::Unchecked)->_remove_Unchecked(token)); }
		} Unchecked;
	};
	IInkToolbarFlyoutItem_adaptor() {}
};
template<typename X> struct adapt<IInkToolbarFlyoutItem, X> : Windows::UI::Xaml::Controls::IInkToolbarFlyoutItem_adaptor<X> { typedef adapt IInkToolbarFlyoutItem; };
struct IInkToolbarFlyoutItem : IInkToolbarFlyoutItem_raw, generate<IInkToolbarFlyoutItem> {};

// IInkToolbarFlyoutItemFactory
struct IInkToolbarFlyoutItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, InkToolbarFlyoutItem* *instance);
};

// IInkToolbarFlyoutItemStatics
struct IInkToolbarFlyoutItemStatics : IInspectable {
	virtual STDMETHODIMP _get_KindProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsCheckedProperty(DependencyProperty* *value);
};

// InkToolbarFlyoutItem
template<typename> struct InkToolbarFlyoutItem_statics {
	static struct _IsCheckedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarFlyoutItem, IInkToolbarFlyoutItemStatics>()->_get_IsCheckedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsCheckedProperty;
	static struct _KindProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarFlyoutItem, IInkToolbarFlyoutItemStatics>()->_get_KindProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} KindProperty;
	static InkToolbarFlyoutItem *activate(object_ref outer, IInspectable* *inner) { InkToolbarFlyoutItem *instance; hrcheck(get_activation_factory<InkToolbarFlyoutItem, IInkToolbarFlyoutItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename InkToolbarFlyoutItem_statics<X>::_IsCheckedProperty InkToolbarFlyoutItem_statics<X>::IsCheckedProperty;
template<typename X> typename InkToolbarFlyoutItem_statics<X>::_KindProperty InkToolbarFlyoutItem_statics<X>::KindProperty;

template<typename X> struct statics<InkToolbarFlyoutItem, X> : X, Windows::UI::Xaml::Controls::InkToolbarFlyoutItem_statics<void> {
	using Windows::UI::Xaml::Controls::InkToolbarFlyoutItem_statics<void>::activate;
	typedef typename X::root_type InkToolbarFlyoutItem;
};
struct InkToolbarFlyoutItem : generate<InkToolbarFlyoutItem> {};

// IInkToolbarMenuButton
struct IInkToolbarMenuButton_raw : IInspectable {
	virtual STDMETHODIMP _get_MenuKind(InkToolbarMenuKind *value);
	virtual STDMETHODIMP _get_IsExtensionGlyphShown(bool *value);
	virtual STDMETHODIMP _put_IsExtensionGlyphShown(bool value);
};
template<typename X> struct IInkToolbarMenuButton_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IInkToolbarMenuButton_adaptor::IsExtensionGlyphShown)->_get_IsExtensionGlyphShown(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IInkToolbarMenuButton_adaptor::IsExtensionGlyphShown)->_put_IsExtensionGlyphShown(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsExtensionGlyphShown;
		struct : property {
			InkToolbarMenuKind get() { InkToolbarMenuKind value; hrcheck(enc(&IInkToolbarMenuButton_adaptor::MenuKind)->_get_MenuKind(&value)); return value; }
			InkToolbarMenuKind operator()() { return get(); }
			operator InkToolbarMenuKind () { return get(); }
		} MenuKind;
	};
	IInkToolbarMenuButton_adaptor() {}
};
template<typename X> struct adapt<IInkToolbarMenuButton, X> : Windows::UI::Xaml::Controls::IInkToolbarMenuButton_adaptor<X> { typedef adapt IInkToolbarMenuButton; };
struct IInkToolbarMenuButton : IInkToolbarMenuButton_raw, generate<IInkToolbarMenuButton> {};

// IInkToolbarMenuButtonFactory
struct IInkToolbarMenuButtonFactory : IInspectable, generate<IInkToolbarMenuButtonFactory> {};

// IInkToolbarMenuButtonStatics
struct IInkToolbarMenuButtonStatics : IInspectable {
	virtual STDMETHODIMP _get_IsExtensionGlyphShownProperty(DependencyProperty* *value);
};

// InkToolbarMenuButton
template<typename> struct InkToolbarMenuButton_statics {
	static struct _IsExtensionGlyphShownProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarMenuButton, IInkToolbarMenuButtonStatics>()->_get_IsExtensionGlyphShownProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsExtensionGlyphShownProperty;
};
template<typename X> typename InkToolbarMenuButton_statics<X>::_IsExtensionGlyphShownProperty InkToolbarMenuButton_statics<X>::IsExtensionGlyphShownProperty;

template<typename X> struct statics<InkToolbarMenuButton, X> : X, Windows::UI::Xaml::Controls::InkToolbarMenuButton_statics<void> {
	typedef typename X::root_type InkToolbarMenuButton;
};
struct InkToolbarMenuButton : generate<InkToolbarMenuButton> {};

// IInkToolbarStencilButton
struct IInkToolbarStencilButton_raw : IInspectable {
	virtual STDMETHODIMP _get_Ruler(UI::Input::Inking::InkPresenterRuler* *value);
	virtual STDMETHODIMP _get_Protractor(UI::Input::Inking::InkPresenterProtractor* *value);
	virtual STDMETHODIMP _get_SelectedStencil(InkToolbarStencilKind *value);
	virtual STDMETHODIMP _put_SelectedStencil(InkToolbarStencilKind value);
	virtual STDMETHODIMP _get_IsRulerItemVisible(bool *value);
	virtual STDMETHODIMP _put_IsRulerItemVisible(bool value);
	virtual STDMETHODIMP _get_IsProtractorItemVisible(bool *value);
	virtual STDMETHODIMP _put_IsProtractorItemVisible(bool value);
};
template<typename X> struct IInkToolbarStencilButton_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IInkToolbarStencilButton_adaptor::IsProtractorItemVisible)->_get_IsProtractorItemVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IInkToolbarStencilButton_adaptor::IsProtractorItemVisible)->_put_IsProtractorItemVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsProtractorItemVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IInkToolbarStencilButton_adaptor::IsRulerItemVisible)->_get_IsRulerItemVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IInkToolbarStencilButton_adaptor::IsRulerItemVisible)->_put_IsRulerItemVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsRulerItemVisible;
		struct : property {
			ptr<UI::Input::Inking::InkPresenterProtractor> get() { UI::Input::Inking::InkPresenterProtractor* value; hrcheck(enc(&IInkToolbarStencilButton_adaptor::Protractor)->_get_Protractor(&value)); return from_abi(value); }
			ptr<UI::Input::Inking::InkPresenterProtractor> operator()() { return get(); }
			operator ptr<UI::Input::Inking::InkPresenterProtractor> () { return get(); }
			ptr<UI::Input::Inking::InkPresenterProtractor> operator->() { return get(); }
		} Protractor;
		struct : property {
			ptr<UI::Input::Inking::InkPresenterRuler> get() { UI::Input::Inking::InkPresenterRuler* value; hrcheck(enc(&IInkToolbarStencilButton_adaptor::Ruler)->_get_Ruler(&value)); return from_abi(value); }
			ptr<UI::Input::Inking::InkPresenterRuler> operator()() { return get(); }
			operator ptr<UI::Input::Inking::InkPresenterRuler> () { return get(); }
			ptr<UI::Input::Inking::InkPresenterRuler> operator->() { return get(); }
		} Ruler;
		struct : property {
			InkToolbarStencilKind get() { InkToolbarStencilKind value; hrcheck(enc(&IInkToolbarStencilButton_adaptor::SelectedStencil)->_get_SelectedStencil(&value)); return value; }
			InkToolbarStencilKind operator()() { return get(); }
			operator InkToolbarStencilKind () { return get(); }
			void put(InkToolbarStencilKind value) { hrcheck(enc(&IInkToolbarStencilButton_adaptor::SelectedStencil)->_put_SelectedStencil(value)); }
			void operator=(InkToolbarStencilKind value) { put(value); }
			void operator()(InkToolbarStencilKind value) { put(value); }
		} SelectedStencil;
	};
	IInkToolbarStencilButton_adaptor() {}
};
template<typename X> struct adapt<IInkToolbarStencilButton, X> : Windows::UI::Xaml::Controls::IInkToolbarStencilButton_adaptor<X> { typedef adapt IInkToolbarStencilButton; };
struct IInkToolbarStencilButton : IInkToolbarStencilButton_raw, generate<IInkToolbarStencilButton> {};

// IInkToolbarStencilButtonFactory
struct IInkToolbarStencilButtonFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, InkToolbarStencilButton* *instance);
};

// IInkToolbarStencilButtonStatics
struct IInkToolbarStencilButtonStatics : IInspectable {
	virtual STDMETHODIMP _get_RulerProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ProtractorProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedStencilProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsRulerItemVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsProtractorItemVisibleProperty(DependencyProperty* *value);
};

// InkToolbarStencilButton
template<typename> struct InkToolbarStencilButton_statics {
	static struct _IsProtractorItemVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarStencilButton, IInkToolbarStencilButtonStatics>()->_get_IsProtractorItemVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsProtractorItemVisibleProperty;
	static struct _IsRulerItemVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarStencilButton, IInkToolbarStencilButtonStatics>()->_get_IsRulerItemVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsRulerItemVisibleProperty;
	static struct _ProtractorProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarStencilButton, IInkToolbarStencilButtonStatics>()->_get_ProtractorProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ProtractorProperty;
	static struct _RulerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarStencilButton, IInkToolbarStencilButtonStatics>()->_get_RulerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RulerProperty;
	static struct _SelectedStencilProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarStencilButton, IInkToolbarStencilButtonStatics>()->_get_SelectedStencilProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedStencilProperty;
	static InkToolbarStencilButton *activate(object_ref outer, IInspectable* *inner) { InkToolbarStencilButton *instance; hrcheck(get_activation_factory<InkToolbarStencilButton, IInkToolbarStencilButtonFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename InkToolbarStencilButton_statics<X>::_IsProtractorItemVisibleProperty InkToolbarStencilButton_statics<X>::IsProtractorItemVisibleProperty;
template<typename X> typename InkToolbarStencilButton_statics<X>::_IsRulerItemVisibleProperty InkToolbarStencilButton_statics<X>::IsRulerItemVisibleProperty;
template<typename X> typename InkToolbarStencilButton_statics<X>::_ProtractorProperty InkToolbarStencilButton_statics<X>::ProtractorProperty;
template<typename X> typename InkToolbarStencilButton_statics<X>::_RulerProperty InkToolbarStencilButton_statics<X>::RulerProperty;
template<typename X> typename InkToolbarStencilButton_statics<X>::_SelectedStencilProperty InkToolbarStencilButton_statics<X>::SelectedStencilProperty;

template<typename X> struct statics<InkToolbarStencilButton, X> : X, Windows::UI::Xaml::Controls::InkToolbarStencilButton_statics<void> {
	using Windows::UI::Xaml::Controls::InkToolbarStencilButton_statics<void>::activate;
	typedef typename X::root_type InkToolbarStencilButton;
};
struct InkToolbarStencilButton : generate<InkToolbarStencilButton> {};

// IInkToolbarToggleButton
struct IInkToolbarToggleButton_raw : IInspectable {
	virtual STDMETHODIMP _get_ToggleKind(InkToolbarToggle *value);
};
template<typename X> struct IInkToolbarToggleButton_adaptor : X {
	union {
		struct : property {
			InkToolbarToggle get() { InkToolbarToggle value; hrcheck(enc(&IInkToolbarToggleButton_adaptor::ToggleKind)->_get_ToggleKind(&value)); return value; }
			InkToolbarToggle operator()() { return get(); }
			operator InkToolbarToggle () { return get(); }
		} ToggleKind;
	};
	IInkToolbarToggleButton_adaptor() {}
};
template<typename X> struct adapt<IInkToolbarToggleButton, X> : Windows::UI::Xaml::Controls::IInkToolbarToggleButton_adaptor<X> { typedef adapt IInkToolbarToggleButton; };
struct IInkToolbarToggleButton : IInkToolbarToggleButton_raw, generate<IInkToolbarToggleButton> {};

// IInkToolbarToggleButtonFactory
struct IInkToolbarToggleButtonFactory : IInspectable, generate<IInkToolbarToggleButtonFactory> {};

// InkToolbarToggleButton
template<typename X> struct statics<InkToolbarToggleButton, X> : X {
	typedef typename X::root_type InkToolbarToggleButton;
};
struct InkToolbarToggleButton : generate<InkToolbarToggleButton> {};

// IInkToolbarToolButton
struct IInkToolbarToolButton_raw : IInspectable {
	virtual STDMETHODIMP _get_ToolKind(InkToolbarTool *value);
	virtual STDMETHODIMP _get_IsExtensionGlyphShown(bool *value);
	virtual STDMETHODIMP _put_IsExtensionGlyphShown(bool value);
};
template<typename X> struct IInkToolbarToolButton_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IInkToolbarToolButton_adaptor::IsExtensionGlyphShown)->_get_IsExtensionGlyphShown(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IInkToolbarToolButton_adaptor::IsExtensionGlyphShown)->_put_IsExtensionGlyphShown(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsExtensionGlyphShown;
		struct : property {
			InkToolbarTool get() { InkToolbarTool value; hrcheck(enc(&IInkToolbarToolButton_adaptor::ToolKind)->_get_ToolKind(&value)); return value; }
			InkToolbarTool operator()() { return get(); }
			operator InkToolbarTool () { return get(); }
		} ToolKind;
	};
	IInkToolbarToolButton_adaptor() {}
};
template<typename X> struct adapt<IInkToolbarToolButton, X> : Windows::UI::Xaml::Controls::IInkToolbarToolButton_adaptor<X> { typedef adapt IInkToolbarToolButton; };
struct IInkToolbarToolButton : IInkToolbarToolButton_raw, generate<IInkToolbarToolButton> {};

// IInkToolbarToolButtonFactory
struct IInkToolbarToolButtonFactory : IInspectable, generate<IInkToolbarToolButtonFactory> {};

// IInkToolbarToolButtonStatics
struct IInkToolbarToolButtonStatics : IInspectable {
	virtual STDMETHODIMP _get_IsExtensionGlyphShownProperty(DependencyProperty* *value);
};

// InkToolbarToolButton
template<typename> struct InkToolbarToolButton_statics {
	static struct _IsExtensionGlyphShownProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarToolButton, IInkToolbarToolButtonStatics>()->_get_IsExtensionGlyphShownProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsExtensionGlyphShownProperty;
};
template<typename X> typename InkToolbarToolButton_statics<X>::_IsExtensionGlyphShownProperty InkToolbarToolButton_statics<X>::IsExtensionGlyphShownProperty;

template<typename X> struct statics<InkToolbarToolButton, X> : X, Windows::UI::Xaml::Controls::InkToolbarToolButton_statics<void> {
	typedef typename X::root_type InkToolbarToolButton;
};
struct InkToolbarToolButton : generate<InkToolbarToolButton> {};

// IInkToolbarCustomToggleButton
struct IInkToolbarCustomToggleButton : IInspectable, generate<IInkToolbarCustomToggleButton> {};

// IInkToolbarCustomToggleButtonFactory
struct IInkToolbarCustomToggleButtonFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, InkToolbarCustomToggleButton* *instance);
};

// InkToolbarCustomToggleButton
template<typename> struct InkToolbarCustomToggleButton_statics {
	static InkToolbarCustomToggleButton *activate(object_ref outer, IInspectable* *inner) { InkToolbarCustomToggleButton *instance; hrcheck(get_activation_factory<InkToolbarCustomToggleButton, IInkToolbarCustomToggleButtonFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<InkToolbarCustomToggleButton, X> : X, Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton_statics<void> {
	using Windows::UI::Xaml::Controls::InkToolbarCustomToggleButton_statics<void>::activate;
	typedef typename X::root_type InkToolbarCustomToggleButton;
};
struct InkToolbarCustomToggleButton : generate<InkToolbarCustomToggleButton> {};

// IInkToolbarCustomToolButton
struct IInkToolbarCustomToolButton_raw : IInspectable {
	virtual STDMETHODIMP _get_ConfigurationContent(UIElement* *value);
	virtual STDMETHODIMP _put_ConfigurationContent(UIElement* value);
};
template<typename X> struct IInkToolbarCustomToolButton_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IInkToolbarCustomToolButton_adaptor::ConfigurationContent)->_get_ConfigurationContent(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IInkToolbarCustomToolButton_adaptor::ConfigurationContent)->_put_ConfigurationContent(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} ConfigurationContent;
	};
	IInkToolbarCustomToolButton_adaptor() {}
};
template<typename X> struct adapt<IInkToolbarCustomToolButton, X> : Windows::UI::Xaml::Controls::IInkToolbarCustomToolButton_adaptor<X> { typedef adapt IInkToolbarCustomToolButton; };
struct IInkToolbarCustomToolButton : IInkToolbarCustomToolButton_raw, generate<IInkToolbarCustomToolButton> {};

// IInkToolbarCustomToolButtonStatics
struct IInkToolbarCustomToolButtonStatics : IInspectable {
	virtual STDMETHODIMP _get_ConfigurationContentProperty(DependencyProperty* *value);
};

// IInkToolbarCustomToolButtonFactory
struct IInkToolbarCustomToolButtonFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, InkToolbarCustomToolButton* *instance);
};

// InkToolbarCustomToolButton
template<typename> struct InkToolbarCustomToolButton_statics {
	static struct _ConfigurationContentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarCustomToolButton, IInkToolbarCustomToolButtonStatics>()->_get_ConfigurationContentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ConfigurationContentProperty;
	static InkToolbarCustomToolButton *activate(object_ref outer, IInspectable* *inner) { InkToolbarCustomToolButton *instance; hrcheck(get_activation_factory<InkToolbarCustomToolButton, IInkToolbarCustomToolButtonFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename InkToolbarCustomToolButton_statics<X>::_ConfigurationContentProperty InkToolbarCustomToolButton_statics<X>::ConfigurationContentProperty;

template<typename X> struct statics<InkToolbarCustomToolButton, X> : X, Windows::UI::Xaml::Controls::InkToolbarCustomToolButton_statics<void> {
	using Windows::UI::Xaml::Controls::InkToolbarCustomToolButton_statics<void>::activate;
	typedef typename X::root_type InkToolbarCustomToolButton;
};
struct InkToolbarCustomToolButton : generate<InkToolbarCustomToolButton> {};

// IInkToolbarEraserButton
struct IInkToolbarEraserButton : IInspectable, generate<IInkToolbarEraserButton> {};

// IInkToolbarEraserButtonFactory
struct IInkToolbarEraserButtonFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, InkToolbarEraserButton* *instance);
};

// IInkToolbarEraserButton2
struct IInkToolbarEraserButton2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsClearAllVisible(bool *value);
	virtual STDMETHODIMP _put_IsClearAllVisible(bool value);
};
template<typename X> struct IInkToolbarEraserButton2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IInkToolbarEraserButton2_adaptor::IsClearAllVisible)->_get_IsClearAllVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IInkToolbarEraserButton2_adaptor::IsClearAllVisible)->_put_IsClearAllVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsClearAllVisible;
	};
	IInkToolbarEraserButton2_adaptor() {}
};
template<typename X> struct adapt<IInkToolbarEraserButton2, X> : Windows::UI::Xaml::Controls::IInkToolbarEraserButton2_adaptor<X> { typedef adapt IInkToolbarEraserButton2; };
struct IInkToolbarEraserButton2 : IInkToolbarEraserButton2_raw, generate<IInkToolbarEraserButton2> {};

// IInkToolbarEraserButtonStatics2
struct IInkToolbarEraserButtonStatics2 : IInspectable {
	virtual STDMETHODIMP _get_IsClearAllVisibleProperty(DependencyProperty* *value);
};

// InkToolbarEraserButton
template<typename> struct InkToolbarEraserButton_statics {
	static struct _IsClearAllVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarEraserButton, IInkToolbarEraserButtonStatics2>()->_get_IsClearAllVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsClearAllVisibleProperty;
	static InkToolbarEraserButton *activate(object_ref outer, IInspectable* *inner) { InkToolbarEraserButton *instance; hrcheck(get_activation_factory<InkToolbarEraserButton, IInkToolbarEraserButtonFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename InkToolbarEraserButton_statics<X>::_IsClearAllVisibleProperty InkToolbarEraserButton_statics<X>::IsClearAllVisibleProperty;

template<typename X> struct statics<InkToolbarEraserButton, X> : X, Windows::UI::Xaml::Controls::InkToolbarEraserButton_statics<void> {
	using Windows::UI::Xaml::Controls::InkToolbarEraserButton_statics<void>::activate;
	typedef typename X::root_type InkToolbarEraserButton;
};
struct InkToolbarEraserButton : generate<InkToolbarEraserButton> {};

// IInkToolbarPenButton
struct IInkToolbarPenButton_raw : IInspectable {
	virtual STDMETHODIMP _get_Palette(Foundation::Collections::IVector<Media::Brush*>* *value);
	virtual STDMETHODIMP _put_Palette(Foundation::Collections::IVector<Media::Brush*>* value);
	virtual STDMETHODIMP _get_MinStrokeWidth(double *value);
	virtual STDMETHODIMP _put_MinStrokeWidth(double value);
	virtual STDMETHODIMP _get_MaxStrokeWidth(double *value);
	virtual STDMETHODIMP _put_MaxStrokeWidth(double value);
	virtual STDMETHODIMP _get_SelectedBrush(Media::Brush* *value);
	virtual STDMETHODIMP _get_SelectedBrushIndex(int *value);
	virtual STDMETHODIMP _put_SelectedBrushIndex(int value);
	virtual STDMETHODIMP _get_SelectedStrokeWidth(double *value);
	virtual STDMETHODIMP _put_SelectedStrokeWidth(double value);
};
template<typename X> struct IInkToolbarPenButton_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IInkToolbarPenButton_adaptor::MaxStrokeWidth)->_get_MaxStrokeWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IInkToolbarPenButton_adaptor::MaxStrokeWidth)->_put_MaxStrokeWidth(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MaxStrokeWidth;
		struct : property {
			double get() { double value; hrcheck(enc(&IInkToolbarPenButton_adaptor::MinStrokeWidth)->_get_MinStrokeWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IInkToolbarPenButton_adaptor::MinStrokeWidth)->_put_MinStrokeWidth(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MinStrokeWidth;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Media::Brush>>> get() { Foundation::Collections::IVector<Media::Brush*>* value; hrcheck(enc(&IInkToolbarPenButton_adaptor::Palette)->_get_Palette(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Media::Brush>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Media::Brush>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Media::Brush>>> operator->() { return get(); }
			void put(pptr<Foundation::Collections::IVector<ptr<Media::Brush>>> value) { hrcheck(enc(&IInkToolbarPenButton_adaptor::Palette)->_put_Palette(to_abi(value))); }
			void operator=(pptr<Foundation::Collections::IVector<ptr<Media::Brush>>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::Collections::IVector<ptr<Media::Brush>>> value) { put(to_abi(value)); }
		} Palette;
		struct : property {
			ptr<Media::Brush> get() { Media::Brush* value; hrcheck(enc(&IInkToolbarPenButton_adaptor::SelectedBrush)->_get_SelectedBrush(&value)); return from_abi(value); }
			ptr<Media::Brush> operator()() { return get(); }
			operator ptr<Media::Brush> () { return get(); }
			ptr<Media::Brush> operator->() { return get(); }
		} SelectedBrush;
		struct : property {
			int get() { int value; hrcheck(enc(&IInkToolbarPenButton_adaptor::SelectedBrushIndex)->_get_SelectedBrushIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IInkToolbarPenButton_adaptor::SelectedBrushIndex)->_put_SelectedBrushIndex(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} SelectedBrushIndex;
		struct : property {
			double get() { double value; hrcheck(enc(&IInkToolbarPenButton_adaptor::SelectedStrokeWidth)->_get_SelectedStrokeWidth(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IInkToolbarPenButton_adaptor::SelectedStrokeWidth)->_put_SelectedStrokeWidth(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} SelectedStrokeWidth;
	};
	IInkToolbarPenButton_adaptor() {}
};
template<typename X> struct adapt<IInkToolbarPenButton, X> : Windows::UI::Xaml::Controls::IInkToolbarPenButton_adaptor<X> { typedef adapt IInkToolbarPenButton; };
struct IInkToolbarPenButton : IInkToolbarPenButton_raw, generate<IInkToolbarPenButton> {};

// IInkToolbarPenButtonFactory
struct IInkToolbarPenButtonFactory : IInspectable, generate<IInkToolbarPenButtonFactory> {};

// IInkToolbarPenButtonStatics
struct IInkToolbarPenButtonStatics : IInspectable {
	virtual STDMETHODIMP _get_PaletteProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinStrokeWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxStrokeWidthProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedBrushProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedBrushIndexProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedStrokeWidthProperty(DependencyProperty* *value);
};

// InkToolbarPenButton
template<typename> struct InkToolbarPenButton_statics {
	static struct _MaxStrokeWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarPenButton, IInkToolbarPenButtonStatics>()->_get_MaxStrokeWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxStrokeWidthProperty;
	static struct _MinStrokeWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarPenButton, IInkToolbarPenButtonStatics>()->_get_MinStrokeWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinStrokeWidthProperty;
	static struct _PaletteProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarPenButton, IInkToolbarPenButtonStatics>()->_get_PaletteProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PaletteProperty;
	static struct _SelectedBrushIndexProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarPenButton, IInkToolbarPenButtonStatics>()->_get_SelectedBrushIndexProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedBrushIndexProperty;
	static struct _SelectedBrushProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarPenButton, IInkToolbarPenButtonStatics>()->_get_SelectedBrushProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedBrushProperty;
	static struct _SelectedStrokeWidthProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarPenButton, IInkToolbarPenButtonStatics>()->_get_SelectedStrokeWidthProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedStrokeWidthProperty;
};
template<typename X> typename InkToolbarPenButton_statics<X>::_MaxStrokeWidthProperty InkToolbarPenButton_statics<X>::MaxStrokeWidthProperty;
template<typename X> typename InkToolbarPenButton_statics<X>::_MinStrokeWidthProperty InkToolbarPenButton_statics<X>::MinStrokeWidthProperty;
template<typename X> typename InkToolbarPenButton_statics<X>::_PaletteProperty InkToolbarPenButton_statics<X>::PaletteProperty;
template<typename X> typename InkToolbarPenButton_statics<X>::_SelectedBrushIndexProperty InkToolbarPenButton_statics<X>::SelectedBrushIndexProperty;
template<typename X> typename InkToolbarPenButton_statics<X>::_SelectedBrushProperty InkToolbarPenButton_statics<X>::SelectedBrushProperty;
template<typename X> typename InkToolbarPenButton_statics<X>::_SelectedStrokeWidthProperty InkToolbarPenButton_statics<X>::SelectedStrokeWidthProperty;

template<typename X> struct statics<InkToolbarPenButton, X> : X, Windows::UI::Xaml::Controls::InkToolbarPenButton_statics<void> {
	typedef typename X::root_type InkToolbarPenButton;
};
struct InkToolbarPenButton : generate<InkToolbarPenButton> {};

// IInkToolbarRulerButton
struct IInkToolbarRulerButton_raw : IInspectable {
	virtual STDMETHODIMP _get_Ruler(UI::Input::Inking::InkPresenterRuler* *value);
};
template<typename X> struct IInkToolbarRulerButton_adaptor : X {
	union {
		struct : property {
			ptr<UI::Input::Inking::InkPresenterRuler> get() { UI::Input::Inking::InkPresenterRuler* value; hrcheck(enc(&IInkToolbarRulerButton_adaptor::Ruler)->_get_Ruler(&value)); return from_abi(value); }
			ptr<UI::Input::Inking::InkPresenterRuler> operator()() { return get(); }
			operator ptr<UI::Input::Inking::InkPresenterRuler> () { return get(); }
			ptr<UI::Input::Inking::InkPresenterRuler> operator->() { return get(); }
		} Ruler;
	};
	IInkToolbarRulerButton_adaptor() {}
};
template<typename X> struct adapt<IInkToolbarRulerButton, X> : Windows::UI::Xaml::Controls::IInkToolbarRulerButton_adaptor<X> { typedef adapt IInkToolbarRulerButton; };
struct IInkToolbarRulerButton : IInkToolbarRulerButton_raw, generate<IInkToolbarRulerButton> {};

// IInkToolbarRulerButtonStatics
struct IInkToolbarRulerButtonStatics : IInspectable {
	virtual STDMETHODIMP _get_RulerProperty(DependencyProperty* *value);
};

// IInkToolbarRulerButtonFactory
struct IInkToolbarRulerButtonFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, InkToolbarRulerButton* *instance);
};

// InkToolbarRulerButton
template<typename> struct InkToolbarRulerButton_statics {
	static struct _RulerProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarRulerButton, IInkToolbarRulerButtonStatics>()->_get_RulerProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RulerProperty;
	static InkToolbarRulerButton *activate(object_ref outer, IInspectable* *inner) { InkToolbarRulerButton *instance; hrcheck(get_activation_factory<InkToolbarRulerButton, IInkToolbarRulerButtonFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename InkToolbarRulerButton_statics<X>::_RulerProperty InkToolbarRulerButton_statics<X>::RulerProperty;

template<typename X> struct statics<InkToolbarRulerButton, X> : X, Windows::UI::Xaml::Controls::InkToolbarRulerButton_statics<void> {
	using Windows::UI::Xaml::Controls::InkToolbarRulerButton_statics<void>::activate;
	typedef typename X::root_type InkToolbarRulerButton;
};
struct InkToolbarRulerButton : generate<InkToolbarRulerButton> {};

// IInkToolbarBallpointPenButton
struct IInkToolbarBallpointPenButton : IInspectable, generate<IInkToolbarBallpointPenButton> {};

// IInkToolbarBallpointPenButtonFactory
struct IInkToolbarBallpointPenButtonFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, InkToolbarBallpointPenButton* *instance);
};

// InkToolbarBallpointPenButton
template<typename> struct InkToolbarBallpointPenButton_statics {
	static InkToolbarBallpointPenButton *activate(object_ref outer, IInspectable* *inner) { InkToolbarBallpointPenButton *instance; hrcheck(get_activation_factory<InkToolbarBallpointPenButton, IInkToolbarBallpointPenButtonFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<InkToolbarBallpointPenButton, X> : X, Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton_statics<void> {
	using Windows::UI::Xaml::Controls::InkToolbarBallpointPenButton_statics<void>::activate;
	typedef typename X::root_type InkToolbarBallpointPenButton;
};
struct InkToolbarBallpointPenButton : generate<InkToolbarBallpointPenButton> {};

// IInkToolbarCustomPenButton
struct IInkToolbarCustomPenButton_raw : IInspectable {
	virtual STDMETHODIMP _get_CustomPen(InkToolbarCustomPen* *value);
	virtual STDMETHODIMP _put_CustomPen(InkToolbarCustomPen* value);
	virtual STDMETHODIMP _get_ConfigurationContent(UIElement* *value);
	virtual STDMETHODIMP _put_ConfigurationContent(UIElement* value);
};
template<typename X> struct IInkToolbarCustomPenButton_adaptor : X {
	union {
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IInkToolbarCustomPenButton_adaptor::ConfigurationContent)->_get_ConfigurationContent(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IInkToolbarCustomPenButton_adaptor::ConfigurationContent)->_put_ConfigurationContent(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} ConfigurationContent;
		struct : property {
			ptr<InkToolbarCustomPen> get() { InkToolbarCustomPen* value; hrcheck(enc(&IInkToolbarCustomPenButton_adaptor::CustomPen)->_get_CustomPen(&value)); return from_abi(value); }
			ptr<InkToolbarCustomPen> operator()() { return get(); }
			operator ptr<InkToolbarCustomPen> () { return get(); }
			ptr<InkToolbarCustomPen> operator->() { return get(); }
			void put(pptr<InkToolbarCustomPen> value) { hrcheck(enc(&IInkToolbarCustomPenButton_adaptor::CustomPen)->_put_CustomPen(value)); }
			void operator=(pptr<InkToolbarCustomPen> value) { put(value); }
			void operator()(pptr<InkToolbarCustomPen> value) { put(value); }
		} CustomPen;
	};
	IInkToolbarCustomPenButton_adaptor() {}
};
template<typename X> struct adapt<IInkToolbarCustomPenButton, X> : Windows::UI::Xaml::Controls::IInkToolbarCustomPenButton_adaptor<X> { typedef adapt IInkToolbarCustomPenButton; };
struct IInkToolbarCustomPenButton : IInkToolbarCustomPenButton_raw, generate<IInkToolbarCustomPenButton> {};

// IInkToolbarCustomPenButtonStatics
struct IInkToolbarCustomPenButtonStatics : IInspectable {
	virtual STDMETHODIMP _get_CustomPenProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ConfigurationContentProperty(DependencyProperty* *value);
};

// IInkToolbarCustomPenButtonFactory
struct IInkToolbarCustomPenButtonFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, InkToolbarCustomPenButton* *instance);
};

// InkToolbarCustomPenButton
template<typename> struct InkToolbarCustomPenButton_statics {
	static struct _ConfigurationContentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarCustomPenButton, IInkToolbarCustomPenButtonStatics>()->_get_ConfigurationContentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ConfigurationContentProperty;
	static struct _CustomPenProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<InkToolbarCustomPenButton, IInkToolbarCustomPenButtonStatics>()->_get_CustomPenProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CustomPenProperty;
	static InkToolbarCustomPenButton *activate(object_ref outer, IInspectable* *inner) { InkToolbarCustomPenButton *instance; hrcheck(get_activation_factory<InkToolbarCustomPenButton, IInkToolbarCustomPenButtonFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename InkToolbarCustomPenButton_statics<X>::_ConfigurationContentProperty InkToolbarCustomPenButton_statics<X>::ConfigurationContentProperty;
template<typename X> typename InkToolbarCustomPenButton_statics<X>::_CustomPenProperty InkToolbarCustomPenButton_statics<X>::CustomPenProperty;

template<typename X> struct statics<InkToolbarCustomPenButton, X> : X, Windows::UI::Xaml::Controls::InkToolbarCustomPenButton_statics<void> {
	using Windows::UI::Xaml::Controls::InkToolbarCustomPenButton_statics<void>::activate;
	typedef typename X::root_type InkToolbarCustomPenButton;
};
struct InkToolbarCustomPenButton : generate<InkToolbarCustomPenButton> {};

// IInkToolbarHighlighterButton
struct IInkToolbarHighlighterButton : IInspectable, generate<IInkToolbarHighlighterButton> {};

// IInkToolbarHighlighterButtonFactory
struct IInkToolbarHighlighterButtonFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, InkToolbarHighlighterButton* *instance);
};

// InkToolbarHighlighterButton
template<typename> struct InkToolbarHighlighterButton_statics {
	static InkToolbarHighlighterButton *activate(object_ref outer, IInspectable* *inner) { InkToolbarHighlighterButton *instance; hrcheck(get_activation_factory<InkToolbarHighlighterButton, IInkToolbarHighlighterButtonFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<InkToolbarHighlighterButton, X> : X, Windows::UI::Xaml::Controls::InkToolbarHighlighterButton_statics<void> {
	using Windows::UI::Xaml::Controls::InkToolbarHighlighterButton_statics<void>::activate;
	typedef typename X::root_type InkToolbarHighlighterButton;
};
struct InkToolbarHighlighterButton : generate<InkToolbarHighlighterButton> {};

// IInkToolbarPencilButton
struct IInkToolbarPencilButton : IInspectable, generate<IInkToolbarPencilButton> {};

// IInkToolbarPencilButtonFactory
struct IInkToolbarPencilButtonFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, InkToolbarPencilButton* *instance);
};

// InkToolbarPencilButton
template<typename> struct InkToolbarPencilButton_statics {
	static InkToolbarPencilButton *activate(object_ref outer, IInspectable* *inner) { InkToolbarPencilButton *instance; hrcheck(get_activation_factory<InkToolbarPencilButton, IInkToolbarPencilButtonFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<InkToolbarPencilButton, X> : X, Windows::UI::Xaml::Controls::InkToolbarPencilButton_statics<void> {
	using Windows::UI::Xaml::Controls::InkToolbarPencilButton_statics<void>::activate;
	typedef typename X::root_type InkToolbarPencilButton;
};
struct InkToolbarPencilButton : generate<InkToolbarPencilButton> {};

// IPivotItemEventArgs
struct IPivotItemEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Item(PivotItem* *value);
	virtual STDMETHODIMP _put_Item(PivotItem* value);
};
template<typename X> struct IPivotItemEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<PivotItem> get() { PivotItem* value; hrcheck(enc(&IPivotItemEventArgs_adaptor::Item)->_get_Item(&value)); return from_abi(value); }
			ptr<PivotItem> operator()() { return get(); }
			operator ptr<PivotItem> () { return get(); }
			ptr<PivotItem> operator->() { return get(); }
			void put(pptr<PivotItem> value) { hrcheck(enc(&IPivotItemEventArgs_adaptor::Item)->_put_Item(value)); }
			void operator=(pptr<PivotItem> value) { put(value); }
			void operator()(pptr<PivotItem> value) { put(value); }
		} Item;
	};
	IPivotItemEventArgs_adaptor() {}
};
template<typename X> struct adapt<IPivotItemEventArgs, X> : Windows::UI::Xaml::Controls::IPivotItemEventArgs_adaptor<X> { typedef adapt IPivotItemEventArgs; };
struct IPivotItemEventArgs : IPivotItemEventArgs_raw, generate<IPivotItemEventArgs> {};

// PivotItemEventArgs
template<typename X> struct statics<PivotItemEventArgs, X> : X {
	typedef typename X::root_type PivotItemEventArgs;
};
struct PivotItemEventArgs : generate<PivotItemEventArgs> {};

// IDatePickedEventArgs
struct IDatePickedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_OldDate(Foundation::DateTime *value);
	virtual STDMETHODIMP _get_NewDate(Foundation::DateTime *value);
};
template<typename X> struct IDatePickedEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IDatePickedEventArgs_adaptor::NewDate)->_get_NewDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} NewDate;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IDatePickedEventArgs_adaptor::OldDate)->_get_OldDate(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} OldDate;
	};
	IDatePickedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDatePickedEventArgs, X> : Windows::UI::Xaml::Controls::IDatePickedEventArgs_adaptor<X> { typedef adapt IDatePickedEventArgs; };
struct IDatePickedEventArgs : IDatePickedEventArgs_raw, generate<IDatePickedEventArgs> {};

// DatePickedEventArgs
template<typename X> struct statics<DatePickedEventArgs, X> : X {
	typedef typename X::root_type DatePickedEventArgs;
};
struct DatePickedEventArgs : generate<DatePickedEventArgs> {};

// IDatePickerFlyoutItem
struct IDatePickerFlyoutItem_raw : IInspectable {
	virtual STDMETHODIMP _get_PrimaryText(HSTRING *value);
	virtual STDMETHODIMP _put_PrimaryText(HSTRING value);
	virtual STDMETHODIMP _get_SecondaryText(HSTRING *value);
	virtual STDMETHODIMP _put_SecondaryText(HSTRING value);
};
template<typename X> struct IDatePickerFlyoutItem_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDatePickerFlyoutItem_adaptor::PrimaryText)->_get_PrimaryText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDatePickerFlyoutItem_adaptor::PrimaryText)->_put_PrimaryText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} PrimaryText;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDatePickerFlyoutItem_adaptor::SecondaryText)->_get_SecondaryText(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDatePickerFlyoutItem_adaptor::SecondaryText)->_put_SecondaryText(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} SecondaryText;
	};
	IDatePickerFlyoutItem_adaptor() {}
};
template<typename X> struct adapt<IDatePickerFlyoutItem, X> : Windows::UI::Xaml::Controls::IDatePickerFlyoutItem_adaptor<X> { typedef adapt IDatePickerFlyoutItem; };
struct IDatePickerFlyoutItem : IDatePickerFlyoutItem_raw, generate<IDatePickerFlyoutItem> {};

// IDatePickerFlyoutItemStatics
struct IDatePickerFlyoutItemStatics : IInspectable {
	virtual STDMETHODIMP _get_PrimaryTextProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SecondaryTextProperty(DependencyProperty* *value);
};

// DatePickerFlyoutItem
template<typename> struct DatePickerFlyoutItem_statics {
	static struct _PrimaryTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePickerFlyoutItem, IDatePickerFlyoutItemStatics>()->_get_PrimaryTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} PrimaryTextProperty;
	static struct _SecondaryTextProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePickerFlyoutItem, IDatePickerFlyoutItemStatics>()->_get_SecondaryTextProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SecondaryTextProperty;
};
template<typename X> typename DatePickerFlyoutItem_statics<X>::_PrimaryTextProperty DatePickerFlyoutItem_statics<X>::PrimaryTextProperty;
template<typename X> typename DatePickerFlyoutItem_statics<X>::_SecondaryTextProperty DatePickerFlyoutItem_statics<X>::SecondaryTextProperty;

template<typename X> struct statics<DatePickerFlyoutItem, X> : X, Windows::UI::Xaml::Controls::DatePickerFlyoutItem_statics<void> {
	typedef typename X::root_type DatePickerFlyoutItem;
};
struct DatePickerFlyoutItem : generate<DatePickerFlyoutItem> {};

// IItemsPickedEventArgs
struct IItemsPickedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_AddedItems(Foundation::Collections::IVector<IInspectable*>* *value);
	virtual STDMETHODIMP _get_RemovedItems(Foundation::Collections::IVector<IInspectable*>* *value);
};
template<typename X> struct IItemsPickedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<object>> get() { Foundation::Collections::IVector<IInspectable*>* value; hrcheck(enc(&IItemsPickedEventArgs_adaptor::AddedItems)->_get_AddedItems(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<object>> () { return get(); }
			ptr<Foundation::Collections::IVector<object>> operator->() { return get(); }
		} AddedItems;
		struct : property {
			ptr<Foundation::Collections::IVector<object>> get() { Foundation::Collections::IVector<IInspectable*>* value; hrcheck(enc(&IItemsPickedEventArgs_adaptor::RemovedItems)->_get_RemovedItems(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<object>> () { return get(); }
			ptr<Foundation::Collections::IVector<object>> operator->() { return get(); }
		} RemovedItems;
	};
	IItemsPickedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IItemsPickedEventArgs, X> : Windows::UI::Xaml::Controls::IItemsPickedEventArgs_adaptor<X> { typedef adapt IItemsPickedEventArgs; };
struct IItemsPickedEventArgs : IItemsPickedEventArgs_raw, generate<IItemsPickedEventArgs> {};

// ItemsPickedEventArgs
template<typename X> struct statics<ItemsPickedEventArgs, X> : X {
	typedef typename X::root_type ItemsPickedEventArgs;
};
struct ItemsPickedEventArgs : generate<ItemsPickedEventArgs> {};

// IPickerConfirmedEventArgs
struct IPickerConfirmedEventArgs : IInspectable, generate<IPickerConfirmedEventArgs> {};

// PickerConfirmedEventArgs
template<typename X> struct statics<PickerConfirmedEventArgs, X> : X {
	typedef typename X::root_type PickerConfirmedEventArgs;
};
struct PickerConfirmedEventArgs : generate<PickerConfirmedEventArgs> {};

// ITimePickedEventArgs
struct ITimePickedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_OldTime(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_NewTime(Foundation::TimeSpan *value);
};
template<typename X> struct ITimePickedEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ITimePickedEventArgs_adaptor::NewTime)->_get_NewTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} NewTime;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ITimePickedEventArgs_adaptor::OldTime)->_get_OldTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} OldTime;
	};
	ITimePickedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ITimePickedEventArgs, X> : Windows::UI::Xaml::Controls::ITimePickedEventArgs_adaptor<X> { typedef adapt ITimePickedEventArgs; };
struct ITimePickedEventArgs : ITimePickedEventArgs_raw, generate<ITimePickedEventArgs> {};

// TimePickedEventArgs
template<typename X> struct statics<TimePickedEventArgs, X> : X {
	typedef typename X::root_type TimePickedEventArgs;
};
struct TimePickedEventArgs : generate<TimePickedEventArgs> {};

// IDatePickerFlyout
struct IDatePickerFlyout_raw : IInspectable {
	virtual STDMETHODIMP _get_CalendarIdentifier(HSTRING *value);
	virtual STDMETHODIMP _put_CalendarIdentifier(HSTRING value);
	virtual STDMETHODIMP _get_Date(Foundation::DateTime *value);
	virtual STDMETHODIMP _put_Date(Foundation::DateTime value);
	virtual STDMETHODIMP _get_DayVisible(bool *value);
	virtual STDMETHODIMP _put_DayVisible(bool value);
	virtual STDMETHODIMP _get_MonthVisible(bool *value);
	virtual STDMETHODIMP _put_MonthVisible(bool value);
	virtual STDMETHODIMP _get_YearVisible(bool *value);
	virtual STDMETHODIMP _put_YearVisible(bool value);
	virtual STDMETHODIMP _get_MinYear(Foundation::DateTime *value);
	virtual STDMETHODIMP _put_MinYear(Foundation::DateTime value);
	virtual STDMETHODIMP _get_MaxYear(Foundation::DateTime *value);
	virtual STDMETHODIMP _put_MaxYear(Foundation::DateTime value);
	virtual STDMETHODIMP _add_DatePicked(Foundation::TypedEventHandler<DatePickerFlyout*, DatePickedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DatePicked(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _ShowAtAsync(FrameworkElement* target, Foundation::IAsyncOperation<Foundation::IReference<Foundation::DateTime>*>* *returnValue);
};
template<typename X> struct IDatePickerFlyout_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDatePickerFlyout_adaptor::CalendarIdentifier)->_get_CalendarIdentifier(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDatePickerFlyout_adaptor::CalendarIdentifier)->_put_CalendarIdentifier(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} CalendarIdentifier;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IDatePickerFlyout_adaptor::Date)->_get_Date(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
			void put(const Foundation::DateTime& value) { hrcheck(enc(&IDatePickerFlyout_adaptor::Date)->_put_Date(value)); }
			void operator=(const Foundation::DateTime& value) { put(value); }
			void operator()(const Foundation::DateTime& value) { put(value); }
		} Date;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDatePickerFlyout_adaptor::DayVisible)->_get_DayVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDatePickerFlyout_adaptor::DayVisible)->_put_DayVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} DayVisible;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IDatePickerFlyout_adaptor::MaxYear)->_get_MaxYear(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
			void put(const Foundation::DateTime& value) { hrcheck(enc(&IDatePickerFlyout_adaptor::MaxYear)->_put_MaxYear(value)); }
			void operator=(const Foundation::DateTime& value) { put(value); }
			void operator()(const Foundation::DateTime& value) { put(value); }
		} MaxYear;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IDatePickerFlyout_adaptor::MinYear)->_get_MinYear(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
			void put(const Foundation::DateTime& value) { hrcheck(enc(&IDatePickerFlyout_adaptor::MinYear)->_put_MinYear(value)); }
			void operator=(const Foundation::DateTime& value) { put(value); }
			void operator()(const Foundation::DateTime& value) { put(value); }
		} MinYear;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDatePickerFlyout_adaptor::MonthVisible)->_get_MonthVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDatePickerFlyout_adaptor::MonthVisible)->_put_MonthVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} MonthVisible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDatePickerFlyout_adaptor::YearVisible)->_get_YearVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDatePickerFlyout_adaptor::YearVisible)->_put_YearVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} YearVisible;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DatePickerFlyout>, ptr<DatePickedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IDatePickerFlyout_adaptor::DatePicked)->_add_DatePicked(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IDatePickerFlyout_adaptor::DatePicked)->_remove_DatePicked(token)); }
		} DatePicked;
	};
	ptr<Foundation::IAsyncOperation<ptr<Foundation::IReference<Foundation::DateTime>>>> ShowAtAsync(pptr<FrameworkElement> target) { Foundation::IAsyncOperation<Foundation::IReference<Foundation::DateTime>*>* returnValue; hrcheck(X::get()->_ShowAtAsync(target, &returnValue)); return from_abi(returnValue); }
	IDatePickerFlyout_adaptor() {}
};
template<typename X> struct adapt<IDatePickerFlyout, X> : Windows::UI::Xaml::Controls::IDatePickerFlyout_adaptor<X> { typedef adapt IDatePickerFlyout; };
struct IDatePickerFlyout : IDatePickerFlyout_raw, generate<IDatePickerFlyout> {};

// IDatePickerFlyoutStatics
struct IDatePickerFlyoutStatics : IInspectable {
	virtual STDMETHODIMP _get_CalendarIdentifierProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DayVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MonthVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_YearVisibleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinYearProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MaxYearProperty(DependencyProperty* *value);
};

// IDatePickerFlyout2
struct IDatePickerFlyout2_raw : IInspectable {
	virtual STDMETHODIMP _get_DayFormat(HSTRING *value);
	virtual STDMETHODIMP _put_DayFormat(HSTRING value);
	virtual STDMETHODIMP _get_MonthFormat(HSTRING *value);
	virtual STDMETHODIMP _put_MonthFormat(HSTRING value);
	virtual STDMETHODIMP _get_YearFormat(HSTRING *value);
	virtual STDMETHODIMP _put_YearFormat(HSTRING value);
};
template<typename X> struct IDatePickerFlyout2_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDatePickerFlyout2_adaptor::DayFormat)->_get_DayFormat(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDatePickerFlyout2_adaptor::DayFormat)->_put_DayFormat(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DayFormat;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDatePickerFlyout2_adaptor::MonthFormat)->_get_MonthFormat(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDatePickerFlyout2_adaptor::MonthFormat)->_put_MonthFormat(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} MonthFormat;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDatePickerFlyout2_adaptor::YearFormat)->_get_YearFormat(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IDatePickerFlyout2_adaptor::YearFormat)->_put_YearFormat(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} YearFormat;
	};
	IDatePickerFlyout2_adaptor() {}
};
template<typename X> struct adapt<IDatePickerFlyout2, X> : Windows::UI::Xaml::Controls::IDatePickerFlyout2_adaptor<X> { typedef adapt IDatePickerFlyout2; };
struct IDatePickerFlyout2 : IDatePickerFlyout2_raw, generate<IDatePickerFlyout2> {};

// IDatePickerFlyoutStatics2
struct IDatePickerFlyoutStatics2 : IInspectable {
	virtual STDMETHODIMP _get_DayFormatProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MonthFormatProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_YearFormatProperty(DependencyProperty* *value);
};

// IListPickerFlyout
struct IListPickerFlyout_raw : IInspectable {
	virtual STDMETHODIMP _get_ItemsSource(IInspectable* *value);
	virtual STDMETHODIMP _put_ItemsSource(IInspectable* value);
	virtual STDMETHODIMP _get_ItemTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_ItemTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_DisplayMemberPath(HSTRING *value);
	virtual STDMETHODIMP _put_DisplayMemberPath(HSTRING value);
	virtual STDMETHODIMP _get_SelectionMode(ListPickerFlyoutSelectionMode *value);
	virtual STDMETHODIMP _put_SelectionMode(ListPickerFlyoutSelectionMode value);
	virtual STDMETHODIMP _get_SelectedIndex(int *value);
	virtual STDMETHODIMP _put_SelectedIndex(int value);
	virtual STDMETHODIMP _get_SelectedItem(IInspectable* *value);
	virtual STDMETHODIMP _put_SelectedItem(IInspectable* value);
	virtual STDMETHODIMP _get_SelectedValue(IInspectable* *value);
	virtual STDMETHODIMP _put_SelectedValue(IInspectable* value);
	virtual STDMETHODIMP _get_SelectedValuePath(HSTRING *value);
	virtual STDMETHODIMP _put_SelectedValuePath(HSTRING value);
	virtual STDMETHODIMP _get_SelectedItems(Foundation::Collections::IVector<IInspectable*>* *value);
	virtual STDMETHODIMP _add_ItemsPicked(Foundation::TypedEventHandler<ListPickerFlyout*, ItemsPickedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ItemsPicked(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _ShowAtAsync(FrameworkElement* target, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IInspectable*>*>* *returnValue);
};
template<typename X> struct IListPickerFlyout_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IListPickerFlyout_adaptor::DisplayMemberPath)->_get_DisplayMemberPath(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IListPickerFlyout_adaptor::DisplayMemberPath)->_put_DisplayMemberPath(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} DisplayMemberPath;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IListPickerFlyout_adaptor::ItemTemplate)->_get_ItemTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IListPickerFlyout_adaptor::ItemTemplate)->_put_ItemTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} ItemTemplate;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IListPickerFlyout_adaptor::ItemsSource)->_get_ItemsSource(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IListPickerFlyout_adaptor::ItemsSource)->_put_ItemsSource(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} ItemsSource;
		struct : property {
			int get() { int value; hrcheck(enc(&IListPickerFlyout_adaptor::SelectedIndex)->_get_SelectedIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IListPickerFlyout_adaptor::SelectedIndex)->_put_SelectedIndex(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} SelectedIndex;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IListPickerFlyout_adaptor::SelectedItem)->_get_SelectedItem(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IListPickerFlyout_adaptor::SelectedItem)->_put_SelectedItem(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} SelectedItem;
		struct : property {
			ptr<Foundation::Collections::IVector<object>> get() { Foundation::Collections::IVector<IInspectable*>* value; hrcheck(enc(&IListPickerFlyout_adaptor::SelectedItems)->_get_SelectedItems(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<object>> () { return get(); }
			ptr<Foundation::Collections::IVector<object>> operator->() { return get(); }
		} SelectedItems;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IListPickerFlyout_adaptor::SelectedValue)->_get_SelectedValue(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IListPickerFlyout_adaptor::SelectedValue)->_put_SelectedValue(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} SelectedValue;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IListPickerFlyout_adaptor::SelectedValuePath)->_get_SelectedValuePath(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IListPickerFlyout_adaptor::SelectedValuePath)->_put_SelectedValuePath(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} SelectedValuePath;
		struct : property {
			ListPickerFlyoutSelectionMode get() { ListPickerFlyoutSelectionMode value; hrcheck(enc(&IListPickerFlyout_adaptor::SelectionMode)->_get_SelectionMode(&value)); return value; }
			ListPickerFlyoutSelectionMode operator()() { return get(); }
			operator ListPickerFlyoutSelectionMode () { return get(); }
			void put(ListPickerFlyoutSelectionMode value) { hrcheck(enc(&IListPickerFlyout_adaptor::SelectionMode)->_put_SelectionMode(value)); }
			void operator=(ListPickerFlyoutSelectionMode value) { put(value); }
			void operator()(ListPickerFlyoutSelectionMode value) { put(value); }
		} SelectionMode;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ListPickerFlyout>, ptr<ItemsPickedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IListPickerFlyout_adaptor::ItemsPicked)->_add_ItemsPicked(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IListPickerFlyout_adaptor::ItemsPicked)->_remove_ItemsPicked(token)); }
		} ItemsPicked;
	};
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<object>>>> ShowAtAsync(pptr<FrameworkElement> target) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IInspectable*>*>* returnValue; hrcheck(X::get()->_ShowAtAsync(target, &returnValue)); return from_abi(returnValue); }
	IListPickerFlyout_adaptor() {}
};
template<typename X> struct adapt<IListPickerFlyout, X> : Windows::UI::Xaml::Controls::IListPickerFlyout_adaptor<X> { typedef adapt IListPickerFlyout; };
struct IListPickerFlyout : IListPickerFlyout_raw, generate<IListPickerFlyout> {};

// IListPickerFlyoutStatics
struct IListPickerFlyoutStatics : IInspectable {
	virtual STDMETHODIMP _get_ItemsSourceProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ItemTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_DisplayMemberPathProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectionModeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedIndexProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedItemProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedValueProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedValuePathProperty(DependencyProperty* *value);
};

// IPickerFlyout
struct IPickerFlyout_raw : IInspectable {
	virtual STDMETHODIMP _get_Content(UIElement* *value);
	virtual STDMETHODIMP _put_Content(UIElement* value);
	virtual STDMETHODIMP _get_ConfirmationButtonsVisible(bool *value);
	virtual STDMETHODIMP _put_ConfirmationButtonsVisible(bool value);
	virtual STDMETHODIMP _add_Confirmed(Foundation::TypedEventHandler<PickerFlyout*, PickerConfirmedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Confirmed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _ShowAtAsync(FrameworkElement* target, Foundation::IAsyncOperation<bool>* *returnValue);
};
template<typename X> struct IPickerFlyout_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPickerFlyout_adaptor::ConfirmationButtonsVisible)->_get_ConfirmationButtonsVisible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IPickerFlyout_adaptor::ConfirmationButtonsVisible)->_put_ConfirmationButtonsVisible(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ConfirmationButtonsVisible;
		struct : property {
			ptr<UIElement> get() { UIElement* value; hrcheck(enc(&IPickerFlyout_adaptor::Content)->_get_Content(&value)); return from_abi(value); }
			ptr<UIElement> operator()() { return get(); }
			operator ptr<UIElement> () { return get(); }
			ptr<UIElement> operator->() { return get(); }
			void put(pptr<UIElement> value) { hrcheck(enc(&IPickerFlyout_adaptor::Content)->_put_Content(value)); }
			void operator=(pptr<UIElement> value) { put(value); }
			void operator()(pptr<UIElement> value) { put(value); }
		} Content;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<PickerFlyout>, ptr<PickerConfirmedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPickerFlyout_adaptor::Confirmed)->_add_Confirmed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPickerFlyout_adaptor::Confirmed)->_remove_Confirmed(token)); }
		} Confirmed;
	};
	ptr<Foundation::IAsyncOperation<bool>> ShowAtAsync(pptr<FrameworkElement> target) { Foundation::IAsyncOperation<bool>* returnValue; hrcheck(X::get()->_ShowAtAsync(target, &returnValue)); return from_abi(returnValue); }
	IPickerFlyout_adaptor() {}
};
template<typename X> struct adapt<IPickerFlyout, X> : Windows::UI::Xaml::Controls::IPickerFlyout_adaptor<X> { typedef adapt IPickerFlyout; };
struct IPickerFlyout : IPickerFlyout_raw, generate<IPickerFlyout> {};

// IPickerFlyoutStatics
struct IPickerFlyoutStatics : IInspectable {
	virtual STDMETHODIMP _get_ContentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_ConfirmationButtonsVisibleProperty(DependencyProperty* *value);
};

// ITimePickerFlyout
struct ITimePickerFlyout_raw : IInspectable {
	virtual STDMETHODIMP _get_ClockIdentifier(HSTRING *value);
	virtual STDMETHODIMP _put_ClockIdentifier(HSTRING value);
	virtual STDMETHODIMP _get_Time(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_Time(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_MinuteIncrement(int *value);
	virtual STDMETHODIMP _put_MinuteIncrement(int value);
	virtual STDMETHODIMP _add_TimePicked(Foundation::TypedEventHandler<TimePickerFlyout*, TimePickedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_TimePicked(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _ShowAtAsync(FrameworkElement* target, Foundation::IAsyncOperation<Foundation::IReference<Foundation::TimeSpan>*>* *returnValue);
};
template<typename X> struct ITimePickerFlyout_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ITimePickerFlyout_adaptor::ClockIdentifier)->_get_ClockIdentifier(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ITimePickerFlyout_adaptor::ClockIdentifier)->_put_ClockIdentifier(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ClockIdentifier;
		struct : property {
			int get() { int value; hrcheck(enc(&ITimePickerFlyout_adaptor::MinuteIncrement)->_get_MinuteIncrement(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ITimePickerFlyout_adaptor::MinuteIncrement)->_put_MinuteIncrement(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MinuteIncrement;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&ITimePickerFlyout_adaptor::Time)->_get_Time(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&ITimePickerFlyout_adaptor::Time)->_put_Time(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} Time;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<TimePickerFlyout>, ptr<TimePickedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&ITimePickerFlyout_adaptor::TimePicked)->_add_TimePicked(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ITimePickerFlyout_adaptor::TimePicked)->_remove_TimePicked(token)); }
		} TimePicked;
	};
	ptr<Foundation::IAsyncOperation<ptr<Foundation::IReference<Foundation::TimeSpan>>>> ShowAtAsync(pptr<FrameworkElement> target) { Foundation::IAsyncOperation<Foundation::IReference<Foundation::TimeSpan>*>* returnValue; hrcheck(X::get()->_ShowAtAsync(target, &returnValue)); return from_abi(returnValue); }
	ITimePickerFlyout_adaptor() {}
};
template<typename X> struct adapt<ITimePickerFlyout, X> : Windows::UI::Xaml::Controls::ITimePickerFlyout_adaptor<X> { typedef adapt ITimePickerFlyout; };
struct ITimePickerFlyout : ITimePickerFlyout_raw, generate<ITimePickerFlyout> {};

// ITimePickerFlyoutStatics
struct ITimePickerFlyoutStatics : IInspectable {
	virtual STDMETHODIMP _get_ClockIdentifierProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TimeProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_MinuteIncrementProperty(DependencyProperty* *value);
};

// IDatePickerFlyoutPresenter
struct IDatePickerFlyoutPresenter : IInspectable, generate<IDatePickerFlyoutPresenter> {};

// DatePickerFlyoutPresenter
template<typename X> struct statics<DatePickerFlyoutPresenter, X> : X {
	typedef typename X::root_type DatePickerFlyoutPresenter;
};
struct DatePickerFlyoutPresenter : generate<DatePickerFlyoutPresenter> {};

// IListPickerFlyoutPresenter
struct IListPickerFlyoutPresenter : IInspectable, generate<IListPickerFlyoutPresenter> {};

// ListPickerFlyoutPresenter
template<typename X> struct statics<ListPickerFlyoutPresenter, X> : X {
	typedef typename X::root_type ListPickerFlyoutPresenter;
};
struct ListPickerFlyoutPresenter : generate<ListPickerFlyoutPresenter> {};

// ITimePickerFlyoutPresenter
struct ITimePickerFlyoutPresenter : IInspectable, generate<ITimePickerFlyoutPresenter> {};

// TimePickerFlyoutPresenter
template<typename X> struct statics<TimePickerFlyoutPresenter, X> : X {
	typedef typename X::root_type TimePickerFlyoutPresenter;
};
struct TimePickerFlyoutPresenter : generate<TimePickerFlyoutPresenter> {};

// IPickerFlyoutPresenter
struct IPickerFlyoutPresenter : IInspectable, generate<IPickerFlyoutPresenter> {};

// PickerFlyoutPresenter
template<typename X> struct statics<PickerFlyoutPresenter, X> : X {
	typedef typename X::root_type PickerFlyoutPresenter;
};
struct PickerFlyoutPresenter : generate<PickerFlyoutPresenter> {};

// IPivot
struct IPivot_raw : IInspectable {
	virtual STDMETHODIMP _get_Title(IInspectable* *value);
	virtual STDMETHODIMP _put_Title(IInspectable* value);
	virtual STDMETHODIMP _get_TitleTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_TitleTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_HeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_HeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_SelectedIndex(int *value);
	virtual STDMETHODIMP _put_SelectedIndex(int value);
	virtual STDMETHODIMP _get_SelectedItem(IInspectable* *value);
	virtual STDMETHODIMP _put_SelectedItem(IInspectable* value);
	virtual STDMETHODIMP _get_IsLocked(bool *value);
	virtual STDMETHODIMP _put_IsLocked(bool value);
	virtual STDMETHODIMP _add_SelectionChanged(SelectionChangedEventHandler* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_SelectionChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PivotItemLoading(Foundation::TypedEventHandler<Pivot*, PivotItemEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PivotItemLoading(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PivotItemLoaded(Foundation::TypedEventHandler<Pivot*, PivotItemEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PivotItemLoaded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PivotItemUnloading(Foundation::TypedEventHandler<Pivot*, PivotItemEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PivotItemUnloading(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_PivotItemUnloaded(Foundation::TypedEventHandler<Pivot*, PivotItemEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PivotItemUnloaded(Foundation::EventRegistrationToken token);
};
template<typename X> struct IPivot_adaptor : X {
	union {
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IPivot_adaptor::HeaderTemplate)->_get_HeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IPivot_adaptor::HeaderTemplate)->_put_HeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} HeaderTemplate;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPivot_adaptor::IsLocked)->_get_IsLocked(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IPivot_adaptor::IsLocked)->_put_IsLocked(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsLocked;
		struct : property {
			int get() { int value; hrcheck(enc(&IPivot_adaptor::SelectedIndex)->_get_SelectedIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IPivot_adaptor::SelectedIndex)->_put_SelectedIndex(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} SelectedIndex;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IPivot_adaptor::SelectedItem)->_get_SelectedItem(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IPivot_adaptor::SelectedItem)->_put_SelectedItem(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} SelectedItem;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IPivot_adaptor::Title)->_get_Title(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IPivot_adaptor::Title)->_put_Title(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Title;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IPivot_adaptor::TitleTemplate)->_get_TitleTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IPivot_adaptor::TitleTemplate)->_put_TitleTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} TitleTemplate;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<Pivot>, ptr<PivotItemEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPivot_adaptor::PivotItemLoaded)->_add_PivotItemLoaded(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPivot_adaptor::PivotItemLoaded)->_remove_PivotItemLoaded(token)); }
		} PivotItemLoaded;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<Pivot>, ptr<PivotItemEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPivot_adaptor::PivotItemLoading)->_add_PivotItemLoading(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPivot_adaptor::PivotItemLoading)->_remove_PivotItemLoading(token)); }
		} PivotItemLoading;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<Pivot>, ptr<PivotItemEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPivot_adaptor::PivotItemUnloaded)->_add_PivotItemUnloaded(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPivot_adaptor::PivotItemUnloaded)->_remove_PivotItemUnloaded(token)); }
		} PivotItemUnloaded;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<Pivot>, ptr<PivotItemEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPivot_adaptor::PivotItemUnloading)->_add_PivotItemUnloading(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPivot_adaptor::PivotItemUnloading)->_remove_PivotItemUnloading(token)); }
		} PivotItemUnloading;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<SelectionChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPivot_adaptor::SelectionChanged)->_add_SelectionChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPivot_adaptor::SelectionChanged)->_remove_SelectionChanged(token)); }
		} SelectionChanged;
	};
	IPivot_adaptor() {}
};
template<typename X> struct adapt<IPivot, X> : Windows::UI::Xaml::Controls::IPivot_adaptor<X> { typedef adapt IPivot; };
struct IPivot : IPivot_raw, generate<IPivot> {};

// IPivotStatics
struct IPivotStatics : IInspectable {
	virtual STDMETHODIMP _get_TitleProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_TitleTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_HeaderTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedIndexProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SelectedItemProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsLockedProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_SlideInAnimationGroupProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetSlideInAnimationGroup(FrameworkElement* element, PivotSlideInAnimationGroup *value);
	virtual STDMETHODIMP _SetSlideInAnimationGroup(FrameworkElement* element, PivotSlideInAnimationGroup value);
};

// IPivotFactory
struct IPivotFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, Pivot* *instance);
};

// IPivot2
struct IPivot2_raw : IInspectable {
	virtual STDMETHODIMP _get_LeftHeader(IInspectable* *value);
	virtual STDMETHODIMP _put_LeftHeader(IInspectable* value);
	virtual STDMETHODIMP _get_LeftHeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_LeftHeaderTemplate(DataTemplate* value);
	virtual STDMETHODIMP _get_RightHeader(IInspectable* *value);
	virtual STDMETHODIMP _put_RightHeader(IInspectable* value);
	virtual STDMETHODIMP _get_RightHeaderTemplate(DataTemplate* *value);
	virtual STDMETHODIMP _put_RightHeaderTemplate(DataTemplate* value);
};
template<typename X> struct IPivot2_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IPivot2_adaptor::LeftHeader)->_get_LeftHeader(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IPivot2_adaptor::LeftHeader)->_put_LeftHeader(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} LeftHeader;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IPivot2_adaptor::LeftHeaderTemplate)->_get_LeftHeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IPivot2_adaptor::LeftHeaderTemplate)->_put_LeftHeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} LeftHeaderTemplate;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IPivot2_adaptor::RightHeader)->_get_RightHeader(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IPivot2_adaptor::RightHeader)->_put_RightHeader(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} RightHeader;
		struct : property {
			ptr<DataTemplate> get() { DataTemplate* value; hrcheck(enc(&IPivot2_adaptor::RightHeaderTemplate)->_get_RightHeaderTemplate(&value)); return from_abi(value); }
			ptr<DataTemplate> operator()() { return get(); }
			operator ptr<DataTemplate> () { return get(); }
			ptr<DataTemplate> operator->() { return get(); }
			void put(pptr<DataTemplate> value) { hrcheck(enc(&IPivot2_adaptor::RightHeaderTemplate)->_put_RightHeaderTemplate(value)); }
			void operator=(pptr<DataTemplate> value) { put(value); }
			void operator()(pptr<DataTemplate> value) { put(value); }
		} RightHeaderTemplate;
	};
	IPivot2_adaptor() {}
};
template<typename X> struct adapt<IPivot2, X> : Windows::UI::Xaml::Controls::IPivot2_adaptor<X> { typedef adapt IPivot2; };
struct IPivot2 : IPivot2_raw, generate<IPivot2> {};

// IPivotStatics2
struct IPivotStatics2 : IInspectable {
	virtual STDMETHODIMP _get_LeftHeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_LeftHeaderTemplateProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RightHeaderProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_RightHeaderTemplateProperty(DependencyProperty* *value);
};

// IPivot3
struct IPivot3_raw : IInspectable {
	virtual STDMETHODIMP _get_HeaderFocusVisualPlacement(PivotHeaderFocusVisualPlacement *value);
	virtual STDMETHODIMP _put_HeaderFocusVisualPlacement(PivotHeaderFocusVisualPlacement value);
	virtual STDMETHODIMP _get_IsHeaderItemsCarouselEnabled(bool *value);
	virtual STDMETHODIMP _put_IsHeaderItemsCarouselEnabled(bool value);
};
template<typename X> struct IPivot3_adaptor : X {
	union {
		struct : property {
			PivotHeaderFocusVisualPlacement get() { PivotHeaderFocusVisualPlacement value; hrcheck(enc(&IPivot3_adaptor::HeaderFocusVisualPlacement)->_get_HeaderFocusVisualPlacement(&value)); return value; }
			PivotHeaderFocusVisualPlacement operator()() { return get(); }
			operator PivotHeaderFocusVisualPlacement () { return get(); }
			void put(PivotHeaderFocusVisualPlacement value) { hrcheck(enc(&IPivot3_adaptor::HeaderFocusVisualPlacement)->_put_HeaderFocusVisualPlacement(value)); }
			void operator=(PivotHeaderFocusVisualPlacement value) { put(value); }
			void operator()(PivotHeaderFocusVisualPlacement value) { put(value); }
		} HeaderFocusVisualPlacement;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IPivot3_adaptor::IsHeaderItemsCarouselEnabled)->_get_IsHeaderItemsCarouselEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IPivot3_adaptor::IsHeaderItemsCarouselEnabled)->_put_IsHeaderItemsCarouselEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsHeaderItemsCarouselEnabled;
	};
	IPivot3_adaptor() {}
};
template<typename X> struct adapt<IPivot3, X> : Windows::UI::Xaml::Controls::IPivot3_adaptor<X> { typedef adapt IPivot3; };
struct IPivot3 : IPivot3_raw, generate<IPivot3> {};

// IPivotStatics3
struct IPivotStatics3 : IInspectable {
	virtual STDMETHODIMP _get_HeaderFocusVisualPlacementProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _get_IsHeaderItemsCarouselEnabledProperty(DependencyProperty* *value);
};

// Pivot
template<typename> struct Pivot_statics {
	static struct _HeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Pivot, IPivotStatics>()->_get_HeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderTemplateProperty;
	static struct _IsLockedProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Pivot, IPivotStatics>()->_get_IsLockedProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsLockedProperty;
	static struct _SelectedIndexProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Pivot, IPivotStatics>()->_get_SelectedIndexProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedIndexProperty;
	static struct _SelectedItemProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Pivot, IPivotStatics>()->_get_SelectedItemProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedItemProperty;
	static struct _SlideInAnimationGroupProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Pivot, IPivotStatics>()->_get_SlideInAnimationGroupProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SlideInAnimationGroupProperty;
	static struct _TitleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Pivot, IPivotStatics>()->_get_TitleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TitleProperty;
	static struct _TitleTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Pivot, IPivotStatics>()->_get_TitleTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TitleTemplateProperty;
	static struct _LeftHeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Pivot, IPivotStatics2>()->_get_LeftHeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LeftHeaderProperty;
	static struct _LeftHeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Pivot, IPivotStatics2>()->_get_LeftHeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} LeftHeaderTemplateProperty;
	static struct _RightHeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Pivot, IPivotStatics2>()->_get_RightHeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RightHeaderProperty;
	static struct _RightHeaderTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Pivot, IPivotStatics2>()->_get_RightHeaderTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} RightHeaderTemplateProperty;
	static struct _HeaderFocusVisualPlacementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Pivot, IPivotStatics3>()->_get_HeaderFocusVisualPlacementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderFocusVisualPlacementProperty;
	static struct _IsHeaderItemsCarouselEnabledProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<Pivot, IPivotStatics3>()->_get_IsHeaderItemsCarouselEnabledProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} IsHeaderItemsCarouselEnabledProperty;
	static PivotSlideInAnimationGroup GetSlideInAnimationGroup(pptr<FrameworkElement> element) { PivotSlideInAnimationGroup value; hrcheck(get_activation_factory<Pivot, IPivotStatics>()->_GetSlideInAnimationGroup(element, &value)); return value; }
	static void SetSlideInAnimationGroup(pptr<FrameworkElement> element, PivotSlideInAnimationGroup value) { hrcheck(get_activation_factory<Pivot, IPivotStatics>()->_SetSlideInAnimationGroup(element, value)); }
	static Pivot *activate(object_ref outer, IInspectable* *inner) { Pivot *instance; hrcheck(get_activation_factory<Pivot, IPivotFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename Pivot_statics<X>::_HeaderTemplateProperty Pivot_statics<X>::HeaderTemplateProperty;
template<typename X> typename Pivot_statics<X>::_IsLockedProperty Pivot_statics<X>::IsLockedProperty;
template<typename X> typename Pivot_statics<X>::_SelectedIndexProperty Pivot_statics<X>::SelectedIndexProperty;
template<typename X> typename Pivot_statics<X>::_SelectedItemProperty Pivot_statics<X>::SelectedItemProperty;
template<typename X> typename Pivot_statics<X>::_SlideInAnimationGroupProperty Pivot_statics<X>::SlideInAnimationGroupProperty;
template<typename X> typename Pivot_statics<X>::_TitleProperty Pivot_statics<X>::TitleProperty;
template<typename X> typename Pivot_statics<X>::_TitleTemplateProperty Pivot_statics<X>::TitleTemplateProperty;
template<typename X> typename Pivot_statics<X>::_LeftHeaderProperty Pivot_statics<X>::LeftHeaderProperty;
template<typename X> typename Pivot_statics<X>::_LeftHeaderTemplateProperty Pivot_statics<X>::LeftHeaderTemplateProperty;
template<typename X> typename Pivot_statics<X>::_RightHeaderProperty Pivot_statics<X>::RightHeaderProperty;
template<typename X> typename Pivot_statics<X>::_RightHeaderTemplateProperty Pivot_statics<X>::RightHeaderTemplateProperty;
template<typename X> typename Pivot_statics<X>::_HeaderFocusVisualPlacementProperty Pivot_statics<X>::HeaderFocusVisualPlacementProperty;
template<typename X> typename Pivot_statics<X>::_IsHeaderItemsCarouselEnabledProperty Pivot_statics<X>::IsHeaderItemsCarouselEnabledProperty;

template<typename X> struct statics<Pivot, X> : X, Windows::UI::Xaml::Controls::Pivot_statics<void> {
	using Windows::UI::Xaml::Controls::Pivot_statics<void>::activate;
	typedef typename X::root_type Pivot;
};
struct Pivot : generate<Pivot> {};

// IPivotItem
struct IPivotItem_raw : IInspectable {
	virtual STDMETHODIMP _get_Header(IInspectable* *value);
	virtual STDMETHODIMP _put_Header(IInspectable* value);
};
template<typename X> struct IPivotItem_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IPivotItem_adaptor::Header)->_get_Header(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
			void put(object_ref value) { hrcheck(enc(&IPivotItem_adaptor::Header)->_put_Header(value)); }
			void operator=(object_ref value) { put(move(value)); }
			void operator()(object_ref value) { put(move(value)); }
		} Header;
	};
	IPivotItem_adaptor() {}
};
template<typename X> struct adapt<IPivotItem, X> : Windows::UI::Xaml::Controls::IPivotItem_adaptor<X> { typedef adapt IPivotItem; };
struct IPivotItem : IPivotItem_raw, generate<IPivotItem> {};

// IPivotItemFactory
struct IPivotItemFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, PivotItem* *instance);
};

// IPivotItemStatics
struct IPivotItemStatics : IInspectable {
	virtual STDMETHODIMP _get_HeaderProperty(DependencyProperty* *value);
};

// PivotItem
template<typename> struct PivotItem_statics {
	static struct _HeaderProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PivotItem, IPivotItemStatics>()->_get_HeaderProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} HeaderProperty;
	static PivotItem *activate(object_ref outer, IInspectable* *inner) { PivotItem *instance; hrcheck(get_activation_factory<PivotItem, IPivotItemFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};
template<typename X> typename PivotItem_statics<X>::_HeaderProperty PivotItem_statics<X>::HeaderProperty;

template<typename X> struct statics<PivotItem, X> : X, Windows::UI::Xaml::Controls::PivotItem_statics<void> {
	using Windows::UI::Xaml::Controls::PivotItem_statics<void>::activate;
	typedef typename X::root_type PivotItem;
};
struct PivotItem : generate<PivotItem> {};

// INavigationViewBackRequestedEventArgs
struct INavigationViewBackRequestedEventArgs : IInspectable, generate<INavigationViewBackRequestedEventArgs> {};

// NavigationViewBackRequestedEventArgs
template<typename X> struct statics<NavigationViewBackRequestedEventArgs, X> : X {
	typedef typename X::root_type NavigationViewBackRequestedEventArgs;
};
struct NavigationViewBackRequestedEventArgs : generate<NavigationViewBackRequestedEventArgs> {};

// INavigationViewPaneClosingEventArgs
struct INavigationViewPaneClosingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Cancel(bool *value);
	virtual STDMETHODIMP _put_Cancel(bool value);
};
template<typename X> struct INavigationViewPaneClosingEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&INavigationViewPaneClosingEventArgs_adaptor::Cancel)->_get_Cancel(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&INavigationViewPaneClosingEventArgs_adaptor::Cancel)->_put_Cancel(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Cancel;
	};
	INavigationViewPaneClosingEventArgs_adaptor() {}
};
template<typename X> struct adapt<INavigationViewPaneClosingEventArgs, X> : Windows::UI::Xaml::Controls::INavigationViewPaneClosingEventArgs_adaptor<X> { typedef adapt INavigationViewPaneClosingEventArgs; };
struct INavigationViewPaneClosingEventArgs : INavigationViewPaneClosingEventArgs_raw, generate<INavigationViewPaneClosingEventArgs> {};

// NavigationViewPaneClosingEventArgs
template<typename X> struct statics<NavigationViewPaneClosingEventArgs, X> : X {
	typedef typename X::root_type NavigationViewPaneClosingEventArgs;
};
struct NavigationViewPaneClosingEventArgs : generate<NavigationViewPaneClosingEventArgs> {};

// INavigationViewItemInvokedEventArgs
struct INavigationViewItemInvokedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_InvokedItem(IInspectable* *value);
	virtual STDMETHODIMP _get_IsSettingsInvoked(bool *value);
};
template<typename X> struct INavigationViewItemInvokedEventArgs_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&INavigationViewItemInvokedEventArgs_adaptor::InvokedItem)->_get_InvokedItem(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} InvokedItem;
		struct : property {
			bool get() { bool value; hrcheck(enc(&INavigationViewItemInvokedEventArgs_adaptor::IsSettingsInvoked)->_get_IsSettingsInvoked(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsSettingsInvoked;
	};
	INavigationViewItemInvokedEventArgs_adaptor() {}
};
template<typename X> struct adapt<INavigationViewItemInvokedEventArgs, X> : Windows::UI::Xaml::Controls::INavigationViewItemInvokedEventArgs_adaptor<X> { typedef adapt INavigationViewItemInvokedEventArgs; };
struct INavigationViewItemInvokedEventArgs : INavigationViewItemInvokedEventArgs_raw, generate<INavigationViewItemInvokedEventArgs> {};

// NavigationViewItemInvokedEventArgs
template<typename X> struct statics<NavigationViewItemInvokedEventArgs, X> : X {
	typedef typename X::root_type NavigationViewItemInvokedEventArgs;
};
struct NavigationViewItemInvokedEventArgs : generate<NavigationViewItemInvokedEventArgs> {};

// INavigationViewSelectionChangedEventArgs
struct INavigationViewSelectionChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_SelectedItem(IInspectable* *value);
	virtual STDMETHODIMP _get_IsSettingsSelected(bool *value);
};
template<typename X> struct INavigationViewSelectionChangedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&INavigationViewSelectionChangedEventArgs_adaptor::IsSettingsSelected)->_get_IsSettingsSelected(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsSettingsSelected;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&INavigationViewSelectionChangedEventArgs_adaptor::SelectedItem)->_get_SelectedItem(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} SelectedItem;
	};
	INavigationViewSelectionChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<INavigationViewSelectionChangedEventArgs, X> : Windows::UI::Xaml::Controls::INavigationViewSelectionChangedEventArgs_adaptor<X> { typedef adapt INavigationViewSelectionChangedEventArgs; };
struct INavigationViewSelectionChangedEventArgs : INavigationViewSelectionChangedEventArgs_raw, generate<INavigationViewSelectionChangedEventArgs> {};

// NavigationViewSelectionChangedEventArgs
template<typename X> struct statics<NavigationViewSelectionChangedEventArgs, X> : X {
	typedef typename X::root_type NavigationViewSelectionChangedEventArgs;
};
struct NavigationViewSelectionChangedEventArgs : generate<NavigationViewSelectionChangedEventArgs> {};

// DatePickerFlyout
template<typename> struct DatePickerFlyout_statics {
	static struct _CalendarIdentifierProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePickerFlyout, IDatePickerFlyoutStatics>()->_get_CalendarIdentifierProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} CalendarIdentifierProperty;
	static struct _DateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePickerFlyout, IDatePickerFlyoutStatics>()->_get_DateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DateProperty;
	static struct _DayVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePickerFlyout, IDatePickerFlyoutStatics>()->_get_DayVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DayVisibleProperty;
	static struct _MaxYearProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePickerFlyout, IDatePickerFlyoutStatics>()->_get_MaxYearProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MaxYearProperty;
	static struct _MinYearProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePickerFlyout, IDatePickerFlyoutStatics>()->_get_MinYearProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinYearProperty;
	static struct _MonthVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePickerFlyout, IDatePickerFlyoutStatics>()->_get_MonthVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MonthVisibleProperty;
	static struct _YearVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePickerFlyout, IDatePickerFlyoutStatics>()->_get_YearVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} YearVisibleProperty;
	static struct _DayFormatProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePickerFlyout, IDatePickerFlyoutStatics2>()->_get_DayFormatProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DayFormatProperty;
	static struct _MonthFormatProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePickerFlyout, IDatePickerFlyoutStatics2>()->_get_MonthFormatProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MonthFormatProperty;
	static struct _YearFormatProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<DatePickerFlyout, IDatePickerFlyoutStatics2>()->_get_YearFormatProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} YearFormatProperty;
};
template<typename X> typename DatePickerFlyout_statics<X>::_CalendarIdentifierProperty DatePickerFlyout_statics<X>::CalendarIdentifierProperty;
template<typename X> typename DatePickerFlyout_statics<X>::_DateProperty DatePickerFlyout_statics<X>::DateProperty;
template<typename X> typename DatePickerFlyout_statics<X>::_DayVisibleProperty DatePickerFlyout_statics<X>::DayVisibleProperty;
template<typename X> typename DatePickerFlyout_statics<X>::_MaxYearProperty DatePickerFlyout_statics<X>::MaxYearProperty;
template<typename X> typename DatePickerFlyout_statics<X>::_MinYearProperty DatePickerFlyout_statics<X>::MinYearProperty;
template<typename X> typename DatePickerFlyout_statics<X>::_MonthVisibleProperty DatePickerFlyout_statics<X>::MonthVisibleProperty;
template<typename X> typename DatePickerFlyout_statics<X>::_YearVisibleProperty DatePickerFlyout_statics<X>::YearVisibleProperty;
template<typename X> typename DatePickerFlyout_statics<X>::_DayFormatProperty DatePickerFlyout_statics<X>::DayFormatProperty;
template<typename X> typename DatePickerFlyout_statics<X>::_MonthFormatProperty DatePickerFlyout_statics<X>::MonthFormatProperty;
template<typename X> typename DatePickerFlyout_statics<X>::_YearFormatProperty DatePickerFlyout_statics<X>::YearFormatProperty;

template<typename X> struct statics<DatePickerFlyout, X> : X, Windows::UI::Xaml::Controls::DatePickerFlyout_statics<void> {
	typedef typename X::root_type DatePickerFlyout;
};
struct DatePickerFlyout : generate<DatePickerFlyout> {};

// ListPickerFlyout
template<typename> struct ListPickerFlyout_statics {
	static struct _DisplayMemberPathProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListPickerFlyout, IListPickerFlyoutStatics>()->_get_DisplayMemberPathProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DisplayMemberPathProperty;
	static struct _ItemTemplateProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListPickerFlyout, IListPickerFlyoutStatics>()->_get_ItemTemplateProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemTemplateProperty;
	static struct _ItemsSourceProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListPickerFlyout, IListPickerFlyoutStatics>()->_get_ItemsSourceProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ItemsSourceProperty;
	static struct _SelectedIndexProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListPickerFlyout, IListPickerFlyoutStatics>()->_get_SelectedIndexProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedIndexProperty;
	static struct _SelectedItemProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListPickerFlyout, IListPickerFlyoutStatics>()->_get_SelectedItemProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedItemProperty;
	static struct _SelectedValuePathProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListPickerFlyout, IListPickerFlyoutStatics>()->_get_SelectedValuePathProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedValuePathProperty;
	static struct _SelectedValueProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListPickerFlyout, IListPickerFlyoutStatics>()->_get_SelectedValueProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectedValueProperty;
	static struct _SelectionModeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<ListPickerFlyout, IListPickerFlyoutStatics>()->_get_SelectionModeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} SelectionModeProperty;
};
template<typename X> typename ListPickerFlyout_statics<X>::_DisplayMemberPathProperty ListPickerFlyout_statics<X>::DisplayMemberPathProperty;
template<typename X> typename ListPickerFlyout_statics<X>::_ItemTemplateProperty ListPickerFlyout_statics<X>::ItemTemplateProperty;
template<typename X> typename ListPickerFlyout_statics<X>::_ItemsSourceProperty ListPickerFlyout_statics<X>::ItemsSourceProperty;
template<typename X> typename ListPickerFlyout_statics<X>::_SelectedIndexProperty ListPickerFlyout_statics<X>::SelectedIndexProperty;
template<typename X> typename ListPickerFlyout_statics<X>::_SelectedItemProperty ListPickerFlyout_statics<X>::SelectedItemProperty;
template<typename X> typename ListPickerFlyout_statics<X>::_SelectedValuePathProperty ListPickerFlyout_statics<X>::SelectedValuePathProperty;
template<typename X> typename ListPickerFlyout_statics<X>::_SelectedValueProperty ListPickerFlyout_statics<X>::SelectedValueProperty;
template<typename X> typename ListPickerFlyout_statics<X>::_SelectionModeProperty ListPickerFlyout_statics<X>::SelectionModeProperty;

template<typename X> struct statics<ListPickerFlyout, X> : X, Windows::UI::Xaml::Controls::ListPickerFlyout_statics<void> {
	typedef typename X::root_type ListPickerFlyout;
};
struct ListPickerFlyout : generate<ListPickerFlyout> {};

// PickerFlyout
template<typename> struct PickerFlyout_statics {
	static struct _ConfirmationButtonsVisibleProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PickerFlyout, IPickerFlyoutStatics>()->_get_ConfirmationButtonsVisibleProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ConfirmationButtonsVisibleProperty;
	static struct _ContentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<PickerFlyout, IPickerFlyoutStatics>()->_get_ContentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ContentProperty;
};
template<typename X> typename PickerFlyout_statics<X>::_ConfirmationButtonsVisibleProperty PickerFlyout_statics<X>::ConfirmationButtonsVisibleProperty;
template<typename X> typename PickerFlyout_statics<X>::_ContentProperty PickerFlyout_statics<X>::ContentProperty;

template<typename X> struct statics<PickerFlyout, X> : X, Windows::UI::Xaml::Controls::PickerFlyout_statics<void> {
	typedef typename X::root_type PickerFlyout;
};
struct PickerFlyout : generate<PickerFlyout> {};

// TimePickerFlyout
template<typename> struct TimePickerFlyout_statics {
	static struct _ClockIdentifierProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TimePickerFlyout, ITimePickerFlyoutStatics>()->_get_ClockIdentifierProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} ClockIdentifierProperty;
	static struct _MinuteIncrementProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TimePickerFlyout, ITimePickerFlyoutStatics>()->_get_MinuteIncrementProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} MinuteIncrementProperty;
	static struct _TimeProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<TimePickerFlyout, ITimePickerFlyoutStatics>()->_get_TimeProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} TimeProperty;
};
template<typename X> typename TimePickerFlyout_statics<X>::_ClockIdentifierProperty TimePickerFlyout_statics<X>::ClockIdentifierProperty;
template<typename X> typename TimePickerFlyout_statics<X>::_MinuteIncrementProperty TimePickerFlyout_statics<X>::MinuteIncrementProperty;
template<typename X> typename TimePickerFlyout_statics<X>::_TimeProperty TimePickerFlyout_statics<X>::TimeProperty;

template<typename X> struct statics<TimePickerFlyout, X> : X, Windows::UI::Xaml::Controls::TimePickerFlyout_statics<void> {
	typedef typename X::root_type TimePickerFlyout;
};
struct TimePickerFlyout : generate<TimePickerFlyout> {};

// INavigationViewDisplayModeChangedEventArgs
struct INavigationViewDisplayModeChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_DisplayMode(NavigationViewDisplayMode *value);
};
template<typename X> struct INavigationViewDisplayModeChangedEventArgs_adaptor : X {
	union {
		struct : property {
			NavigationViewDisplayMode get() { NavigationViewDisplayMode value; hrcheck(enc(&INavigationViewDisplayModeChangedEventArgs_adaptor::DisplayMode)->_get_DisplayMode(&value)); return value; }
			NavigationViewDisplayMode operator()() { return get(); }
			operator NavigationViewDisplayMode () { return get(); }
		} DisplayMode;
	};
	INavigationViewDisplayModeChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<INavigationViewDisplayModeChangedEventArgs, X> : Windows::UI::Xaml::Controls::INavigationViewDisplayModeChangedEventArgs_adaptor<X> { typedef adapt INavigationViewDisplayModeChangedEventArgs; };
struct INavigationViewDisplayModeChangedEventArgs : INavigationViewDisplayModeChangedEventArgs_raw, generate<INavigationViewDisplayModeChangedEventArgs> {};

// NavigationViewDisplayModeChangedEventArgs
template<typename X> struct statics<NavigationViewDisplayModeChangedEventArgs, X> : X {
	typedef typename X::root_type NavigationViewDisplayModeChangedEventArgs;
};
struct NavigationViewDisplayModeChangedEventArgs : generate<NavigationViewDisplayModeChangedEventArgs> {};

// IColorChangedEventArgs
struct IColorChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_OldColor(Color *result);
	virtual STDMETHODIMP _get_NewColor(Color *result);
};
template<typename X> struct IColorChangedEventArgs_adaptor : X {
	union {
		struct : property {
			Color get() { Color result; hrcheck(enc(&IColorChangedEventArgs_adaptor::NewColor)->_get_NewColor(&result)); return result; }
			Color operator()() { return get(); }
			operator Color () { return get(); }
		} NewColor;
		struct : property {
			Color get() { Color result; hrcheck(enc(&IColorChangedEventArgs_adaptor::OldColor)->_get_OldColor(&result)); return result; }
			Color operator()() { return get(); }
			operator Color () { return get(); }
		} OldColor;
	};
	IColorChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IColorChangedEventArgs, X> : Windows::UI::Xaml::Controls::IColorChangedEventArgs_adaptor<X> { typedef adapt IColorChangedEventArgs; };
struct IColorChangedEventArgs : IColorChangedEventArgs_raw, generate<IColorChangedEventArgs> {};

// ColorChangedEventArgs
template<typename X> struct statics<ColorChangedEventArgs, X> : X {
	typedef typename X::root_type ColorChangedEventArgs;
};
struct ColorChangedEventArgs : generate<ColorChangedEventArgs> {};
}}}}
} // namespace iso_winrt
