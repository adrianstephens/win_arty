#pragma once
// generated by isopod tools
// namespaces:
// Windows.Media.Effects

#include "Windows.Media.Effects.0.h"
#include "Windows.Media.MediaProperties.0.h"
#include "Windows.Foundation.Numerics.0.h"
#include "Windows.Media.Playback.0.h"
#include "Windows.Media.Capture.0.h"
#include "Windows.Media.Render.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.UI.0.h"
#include "Windows.Media.Transcoding.0.h"
#include "Windows.Media.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
struct IPropertySet;
template<typename T> struct IVectorView;
}}
namespace Graphics { namespace DirectX { namespace Direct3D11 {
struct IDirect3DDevice;
struct IDirect3DSurface;
}}}
namespace Media { namespace Editing {
struct MediaOverlay;
}}
namespace Storage { namespace Streams {
struct IRandomAccessStreamWithContentType;
}}}

// defs

template<> struct def<Windows::Media::Effects::IVideoCompositorDefinition> : overridable_type<> {};
template<> struct def<Windows::Media::Effects::IVideoCompositorDefinitionFactory> : interface_type<> {};
template<> struct def<Windows::Media::Effects::VideoCompositorDefinition> : class_type<Platform::Object, Windows::Media::Effects::IVideoCompositorDefinition>, custom_activators {};
template<> struct def<Windows::Media::Effects::ICompositeVideoFrameContext> : interface_type<> {};
template<> struct def<Windows::Media::Effects::CompositeVideoFrameContext> : class_type<Platform::Object, Windows::Media::Effects::ICompositeVideoFrameContext> {};
template<> struct def<Windows::Media::Effects::AudioEffectType> : enum_type<int> {};
template<> struct def<Windows::Media::Effects::IAudioEffect> : interface_type<> {};
template<> struct def<Windows::Media::Effects::AudioEffect> : class_type<Platform::Object, Windows::Media::Effects::IAudioEffect> {};
template<> struct def<Windows::Media::Effects::IAudioEffectsManagerStatics> : interface_type<> {};
template<> struct def<Windows::Media::Effects::IAudioRenderEffectsManager2> : interface_type<> {};
template<> struct def<Windows::Media::Effects::IAudioRenderEffectsManager> : interface_type<> {};
template<> struct def<Windows::Media::Effects::AudioRenderEffectsManager> : class_type<Platform::Object, Windows::Media::Effects::IAudioRenderEffectsManager, Windows::Media::Effects::IAudioRenderEffectsManager2> {};
template<> struct def<Windows::Media::Effects::IAudioCaptureEffectsManager> : interface_type<> {};
template<> struct def<Windows::Media::Effects::AudioCaptureEffectsManager> : class_type<Platform::Object, Windows::Media::Effects::IAudioCaptureEffectsManager> {};
template<> struct def<Windows::Media::Effects::AudioEffectsManager> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Media::Effects::MediaEffectClosedReason> : enum_type<int> {};
template<> struct def<Windows::Media::Effects::IVideoCompositor> : overridable_type<Windows::Media::IMediaExtension> {};
template<> struct def<Windows::Media::Effects::IVideoEffectDefinition> : overridable_type<> {};
template<> struct def<Windows::Media::Effects::IVideoEffectDefinitionFactory> : interface_type<> {};
template<> struct def<Windows::Media::Effects::VideoEffectDefinition> : class_type<Platform::Object, Windows::Media::Effects::IVideoEffectDefinition>, custom_activators {};
template<> struct def<Windows::Media::Effects::IAudioEffectDefinition> : overridable_type<> {};
template<> struct def<Windows::Media::Effects::IAudioEffectDefinitionFactory> : interface_type<> {};
template<> struct def<Windows::Media::Effects::AudioEffectDefinition> : class_type<Platform::Object, Windows::Media::Effects::IAudioEffectDefinition>, custom_activators {};
template<> struct def<Windows::Media::Effects::MediaMemoryTypes> : enum_type<int> {};
template<> struct def<Windows::Media::Effects::IProcessVideoFrameContext> : interface_type<> {};
template<> struct def<Windows::Media::Effects::IBasicVideoEffect> : overridable_type<Windows::Media::IMediaExtension> {};
template<> struct def<Windows::Media::Effects::ProcessVideoFrameContext> : class_type<Platform::Object, Windows::Media::Effects::IProcessVideoFrameContext> {};
template<> struct def<Windows::Media::Effects::IProcessAudioFrameContext> : interface_type<> {};
template<> struct def<Windows::Media::Effects::IBasicAudioEffect> : overridable_type<Windows::Media::IMediaExtension> {};
template<> struct def<Windows::Media::Effects::ProcessAudioFrameContext> : class_type<Platform::Object, Windows::Media::Effects::IProcessAudioFrameContext> {};
template<> struct def<Windows::Media::Effects::IVideoTransformEffectDefinition> : interface_type<Windows::Media::Effects::IVideoEffectDefinition> {};
template<> struct def<Windows::Media::Effects::IVideoTransformSphericalProjection> : interface_type<> {};
template<> struct def<Windows::Media::Effects::IVideoTransformEffectDefinition2> : interface_type<> {};
template<> struct def<Windows::Media::Effects::VideoTransformSphericalProjection> : class_type<Platform::Object, Windows::Media::Effects::IVideoTransformSphericalProjection> {};
template<> struct def<Windows::Media::Effects::VideoTransformEffectDefinition> : class_type<Platform::Object, Windows::Media::Effects::IVideoEffectDefinition, Windows::Media::Effects::IVideoTransformEffectDefinition, Windows::Media::Effects::IVideoTransformEffectDefinition2> {};
template<> struct def<Windows::Media::Effects::ISlowMotionEffectDefinition> : interface_type<Windows::Media::Effects::IVideoEffectDefinition> {};
template<> struct def<Windows::Media::Effects::SlowMotionEffectDefinition> : class_type<Platform::Object, Windows::Media::Effects::ISlowMotionEffectDefinition> {};

// uuids

template<> struct uuid<Windows::Media::Effects::IVideoCompositorDefinition> { define_guid(0x7946B8D0, 0x2010, 0x4AE3, 0x9A, 0xB2, 0x2C, 0xEF, 0x42, 0xED, 0xD4, 0xD2);};
template<> struct uuid<Windows::Media::Effects::IVideoCompositorDefinitionFactory> { define_guid(0x4366FD10, 0x68B8, 0x4D52, 0x89, 0xB6, 0x2, 0xA9, 0x68, 0xCC, 0xA8, 0x99);};
template<> struct uuid<Windows::Media::Effects::ICompositeVideoFrameContext> { define_guid(0x6C30024B, 0xF514, 0x4278, 0xA5, 0xF7, 0xB9, 0x18, 0x80, 0x49, 0xD1, 0x10);};
template<> struct uuid<Windows::Media::Effects::IAudioEffect> { define_guid(0x34AAFA51, 0x9207, 0x4055, 0xBE, 0x93, 0x6E, 0x57, 0x34, 0xA8, 0x6A, 0xE4);};
template<> struct uuid<Windows::Media::Effects::IAudioEffectsManagerStatics> { define_guid(0x66406C04, 0x86FA, 0x47CC, 0xA3, 0x15, 0xF4, 0x89, 0xD8, 0xC3, 0xFE, 0x10);};
template<> struct uuid<Windows::Media::Effects::IAudioRenderEffectsManager2> { define_guid(0xA844CD09, 0x5ECC, 0x44B3, 0xBB, 0x4E, 0x1D, 0xB0, 0x72, 0x87, 0x13, 0x9C);};
template<> struct uuid<Windows::Media::Effects::IAudioRenderEffectsManager> { define_guid(0x4DC98966, 0x8751, 0x42B2, 0xBF, 0xCB, 0x39, 0xCA, 0x78, 0x64, 0xBD, 0x47);};
template<> struct uuid<Windows::Media::Effects::IAudioCaptureEffectsManager> { define_guid(0x8F85C271, 0x38D, 0x4393, 0x82, 0x98, 0x54, 0x1, 0x10, 0x60, 0x8E, 0xEF);};
template<> struct uuid<Windows::Media::Effects::IVideoCompositor> { define_guid(0x8510B43E, 0x420C, 0x420F, 0x96, 0xC7, 0x7C, 0x98, 0xBB, 0xA1, 0xFC, 0x55);};
template<> struct uuid<Windows::Media::Effects::IVideoEffectDefinition> { define_guid(0x39F38CF0, 0x8D0F, 0x4F3E, 0x84, 0xFC, 0x2D, 0x46, 0xA5, 0x29, 0x79, 0x43);};
template<> struct uuid<Windows::Media::Effects::IVideoEffectDefinitionFactory> { define_guid(0x81439B4E, 0x6E33, 0x428F, 0x9D, 0x21, 0xB5, 0xAA, 0xFE, 0xF7, 0x61, 0x7C);};
template<> struct uuid<Windows::Media::Effects::IAudioEffectDefinition> { define_guid(0xE4D7F974, 0x7D80, 0x4F73, 0x90, 0x89, 0xE3, 0x1C, 0x9D, 0xB9, 0xC2, 0x94);};
template<> struct uuid<Windows::Media::Effects::IAudioEffectDefinitionFactory> { define_guid(0x8E1DA646, 0xE705, 0x45ED, 0x8A, 0x2B, 0xFC, 0x4E, 0x4F, 0x40, 0x5A, 0x97);};
template<> struct uuid<Windows::Media::Effects::IProcessVideoFrameContext> { define_guid(0x276F0E2B, 0x6461, 0x401E, 0xBA, 0x78, 0xF, 0xDA, 0xD6, 0x11, 0x4E, 0xEC);};
template<> struct uuid<Windows::Media::Effects::IBasicVideoEffect> { define_guid(0x8262C7EF, 0xB360, 0x40BE, 0x94, 0x9B, 0x2F, 0xF4, 0x2F, 0xF3, 0x56, 0x93);};
template<> struct uuid<Windows::Media::Effects::IProcessAudioFrameContext> { define_guid(0x4CD92946, 0x1222, 0x4A27, 0xA5, 0x86, 0xFB, 0x3E, 0x20, 0x27, 0x32, 0x55);};
template<> struct uuid<Windows::Media::Effects::IBasicAudioEffect> { define_guid(0x8C062C53, 0x6BC0, 0x48B8, 0xA9, 0x9A, 0x4B, 0x41, 0x55, 0xF, 0x13, 0x59);};
template<> struct uuid<Windows::Media::Effects::IVideoTransformEffectDefinition> { define_guid(0x9664BB6A, 0x1EA6, 0x4AA6, 0x80, 0x74, 0xAB, 0xE8, 0x85, 0x1E, 0xCA, 0xE2);};
template<> struct uuid<Windows::Media::Effects::IVideoTransformSphericalProjection> { define_guid(0xCF4401F0, 0x9BF2, 0x4C39, 0x9F, 0x41, 0xE0, 0x22, 0x51, 0x4A, 0x84, 0x68);};
template<> struct uuid<Windows::Media::Effects::IVideoTransformEffectDefinition2> { define_guid(0xF0A8089F, 0x66C8, 0x4694, 0x9F, 0xD9, 0x11, 0x36, 0xAB, 0xF7, 0x44, 0x4A);};
template<> struct uuid<Windows::Media::Effects::ISlowMotionEffectDefinition> { define_guid(0x35053CD0, 0x176C, 0x4763, 0x82, 0xC4, 0x1B, 0x2, 0xDB, 0xE3, 0x17, 0x37);};

// types

namespace Windows { namespace Media { namespace Effects {

// IVideoCompositorDefinition
struct IVideoCompositorDefinition_raw : IInspectable {
	virtual STDMETHODIMP _get_ActivatableClassId(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_Properties(Foundation::Collections::IPropertySet* *value) = 0;
};
template<typename X> struct IVideoCompositorDefinition_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVideoCompositorDefinition_adaptor::ActivatableClassId)->_get_ActivatableClassId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ActivatableClassId;
		struct : property {
			ptr<Foundation::Collections::IPropertySet> get() { Foundation::Collections::IPropertySet* value; hrcheck(enc(&IVideoCompositorDefinition_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IPropertySet> operator()() { return get(); }
			operator ptr<Foundation::Collections::IPropertySet> () { return get(); }
			ptr<Foundation::Collections::IPropertySet> operator->() { return get(); }
		} Properties;
	};
	IVideoCompositorDefinition_adaptor() {}
};
template<typename X> struct adapt<IVideoCompositorDefinition, X> : Windows::Media::Effects::IVideoCompositorDefinition_adaptor<X> { typedef adapt IVideoCompositorDefinition; };
template<typename X> struct IVideoCompositorDefinition_unadaptor : X {
	STDMETHODIMP _get_ActivatableClassId(HSTRING *value) { return hrtry([&, this] { get_prop(value, ActivatableClassId); }); }
	STDMETHODIMP _get_Properties(Foundation::Collections::IPropertySet* *value) { return hrtry([&, this] { get_prop(value, Properties); }); }
};
template<typename X> struct unadapt<IVideoCompositorDefinition, X> : Windows::Media::Effects::IVideoCompositorDefinition_unadaptor<X> {};
struct IVideoCompositorDefinition : IVideoCompositorDefinition_raw, generate<IVideoCompositorDefinition> {};

// IVideoCompositorDefinitionFactory
struct IVideoCompositorDefinitionFactory : IInspectable {
	virtual STDMETHODIMP _Create(HSTRING activatableClassId, VideoCompositorDefinition* *value);
	virtual STDMETHODIMP _CreateWithProperties(HSTRING activatableClassId, Foundation::Collections::IPropertySet* props, VideoCompositorDefinition* *value);
};

// VideoCompositorDefinition
template<typename> struct VideoCompositorDefinition_statics {
	static VideoCompositorDefinition *activate(hstring_ref activatableClassId) { VideoCompositorDefinition *value; hrcheck(get_activation_factory<VideoCompositorDefinition, IVideoCompositorDefinitionFactory>()->_Create(activatableClassId, &value)); return value; }
	static VideoCompositorDefinition *activate(hstring_ref activatableClassId, pptr<Foundation::Collections::IPropertySet> props) { VideoCompositorDefinition *value; hrcheck(get_activation_factory<VideoCompositorDefinition, IVideoCompositorDefinitionFactory>()->_CreateWithProperties(activatableClassId, props, &value)); return value; }
};

template<typename X> struct statics<VideoCompositorDefinition, X> : X, Windows::Media::Effects::VideoCompositorDefinition_statics<void> {
	using Windows::Media::Effects::VideoCompositorDefinition_statics<void>::activate;
	typedef typename X::root_type VideoCompositorDefinition;
};
struct VideoCompositorDefinition : generate<VideoCompositorDefinition> {};

// ICompositeVideoFrameContext
struct ICompositeVideoFrameContext_raw : IInspectable {
	virtual STDMETHODIMP _get_SurfacesToOverlay(Foundation::Collections::IVectorView<Graphics::DirectX::Direct3D11::IDirect3DSurface*>* *value);
	virtual STDMETHODIMP _get_BackgroundFrame(VideoFrame* *value);
	virtual STDMETHODIMP _get_OutputFrame(VideoFrame* *value);
	virtual STDMETHODIMP _GetOverlayForSurface(Graphics::DirectX::Direct3D11::IDirect3DSurface* surfaceToOverlay, Editing::MediaOverlay* *value);
};
template<typename X> struct ICompositeVideoFrameContext_adaptor : X {
	union {
		struct : property {
			ptr<VideoFrame> get() { VideoFrame* value; hrcheck(enc(&ICompositeVideoFrameContext_adaptor::BackgroundFrame)->_get_BackgroundFrame(&value)); return from_abi(value); }
			ptr<VideoFrame> operator()() { return get(); }
			operator ptr<VideoFrame> () { return get(); }
			ptr<VideoFrame> operator->() { return get(); }
		} BackgroundFrame;
		struct : property {
			ptr<VideoFrame> get() { VideoFrame* value; hrcheck(enc(&ICompositeVideoFrameContext_adaptor::OutputFrame)->_get_OutputFrame(&value)); return from_abi(value); }
			ptr<VideoFrame> operator()() { return get(); }
			operator ptr<VideoFrame> () { return get(); }
			ptr<VideoFrame> operator->() { return get(); }
		} OutputFrame;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Graphics::DirectX::Direct3D11::IDirect3DSurface>>> get() { Foundation::Collections::IVectorView<Graphics::DirectX::Direct3D11::IDirect3DSurface*>* value; hrcheck(enc(&ICompositeVideoFrameContext_adaptor::SurfacesToOverlay)->_get_SurfacesToOverlay(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Graphics::DirectX::Direct3D11::IDirect3DSurface>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Graphics::DirectX::Direct3D11::IDirect3DSurface>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Graphics::DirectX::Direct3D11::IDirect3DSurface>>> operator->() { return get(); }
		} SurfacesToOverlay;
	};
	ptr<Editing::MediaOverlay> GetOverlayForSurface(pptr<Graphics::DirectX::Direct3D11::IDirect3DSurface> surfaceToOverlay) { Editing::MediaOverlay* value; hrcheck(X::get()->_GetOverlayForSurface(surfaceToOverlay, &value)); return from_abi(value); }
	ICompositeVideoFrameContext_adaptor() {}
};
template<typename X> struct adapt<ICompositeVideoFrameContext, X> : Windows::Media::Effects::ICompositeVideoFrameContext_adaptor<X> { typedef adapt ICompositeVideoFrameContext; };
struct ICompositeVideoFrameContext : ICompositeVideoFrameContext_raw, generate<ICompositeVideoFrameContext> {};

// CompositeVideoFrameContext
template<typename X> struct statics<CompositeVideoFrameContext, X> : X {
	typedef typename X::root_type CompositeVideoFrameContext;
};
struct CompositeVideoFrameContext : generate<CompositeVideoFrameContext> {};

// IAudioEffect
struct IAudioEffect_raw : IInspectable {
	virtual STDMETHODIMP _get_AudioEffectType(Effects::AudioEffectType *value);
};
template<typename X> struct IAudioEffect_adaptor : X {
	union {
		struct : property {
			Effects::AudioEffectType get() { Effects::AudioEffectType value; hrcheck(enc(&IAudioEffect_adaptor::AudioEffectType)->_get_AudioEffectType(&value)); return value; }
			Effects::AudioEffectType operator()() { return get(); }
			operator Effects::AudioEffectType () { return get(); }
		} AudioEffectType;
	};
	IAudioEffect_adaptor() {}
};
template<typename X> struct adapt<IAudioEffect, X> : Windows::Media::Effects::IAudioEffect_adaptor<X> { typedef adapt IAudioEffect; };
struct IAudioEffect : IAudioEffect_raw, generate<IAudioEffect> {};

// AudioEffect
template<typename X> struct statics<AudioEffect, X> : X {
	typedef typename X::root_type AudioEffect;
};
struct AudioEffect : generate<AudioEffect> {};

// IAudioEffectsManagerStatics
struct IAudioEffectsManagerStatics : IInspectable {
	virtual STDMETHODIMP _CreateAudioRenderEffectsManager(HSTRING deviceId, Render::AudioRenderCategory category, AudioRenderEffectsManager* *value);
	virtual STDMETHODIMP _CreateAudioRenderEffectsManagerWithMode(HSTRING deviceId, Render::AudioRenderCategory category, AudioProcessing mode, AudioRenderEffectsManager* *value);
	virtual STDMETHODIMP _CreateAudioCaptureEffectsManager(HSTRING deviceId, Capture::MediaCategory category, AudioCaptureEffectsManager* *value);
	virtual STDMETHODIMP _CreateAudioCaptureEffectsManagerWithMode(HSTRING deviceId, Capture::MediaCategory category, AudioProcessing mode, AudioCaptureEffectsManager* *value);
};

// IAudioRenderEffectsManager2
struct IAudioRenderEffectsManager2_raw : IInspectable {
	virtual STDMETHODIMP _get_EffectsProviderThumbnail(Storage::Streams::IRandomAccessStreamWithContentType* *value);
	virtual STDMETHODIMP _get_EffectsProviderSettingsLabel(HSTRING *value);
	virtual STDMETHODIMP _ShowSettingsUI();
};
template<typename X> struct IAudioRenderEffectsManager2_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAudioRenderEffectsManager2_adaptor::EffectsProviderSettingsLabel)->_get_EffectsProviderSettingsLabel(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} EffectsProviderSettingsLabel;
		struct : property {
			ptr<Storage::Streams::IRandomAccessStreamWithContentType> get() { Storage::Streams::IRandomAccessStreamWithContentType* value; hrcheck(enc(&IAudioRenderEffectsManager2_adaptor::EffectsProviderThumbnail)->_get_EffectsProviderThumbnail(&value)); return from_abi(value); }
			ptr<Storage::Streams::IRandomAccessStreamWithContentType> operator()() { return get(); }
			operator ptr<Storage::Streams::IRandomAccessStreamWithContentType> () { return get(); }
			ptr<Storage::Streams::IRandomAccessStreamWithContentType> operator->() { return get(); }
		} EffectsProviderThumbnail;
	};
	void ShowSettingsUI() { hrcheck(X::get()->_ShowSettingsUI()); }
	IAudioRenderEffectsManager2_adaptor() {}
};
template<typename X> struct adapt<IAudioRenderEffectsManager2, X> : Windows::Media::Effects::IAudioRenderEffectsManager2_adaptor<X> { typedef adapt IAudioRenderEffectsManager2; };
struct IAudioRenderEffectsManager2 : IAudioRenderEffectsManager2_raw, generate<IAudioRenderEffectsManager2> {};

// IAudioRenderEffectsManager
struct IAudioRenderEffectsManager_raw : IInspectable {
	virtual STDMETHODIMP _add_AudioRenderEffectsChanged(Foundation::TypedEventHandler<AudioRenderEffectsManager*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_AudioRenderEffectsChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _GetAudioRenderEffects(Foundation::Collections::IVectorView<AudioEffect*>* *effects);
};
template<typename X> struct IAudioRenderEffectsManager_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AudioRenderEffectsManager>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAudioRenderEffectsManager_adaptor::AudioRenderEffectsChanged)->_add_AudioRenderEffectsChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAudioRenderEffectsManager_adaptor::AudioRenderEffectsChanged)->_remove_AudioRenderEffectsChanged(token)); }
		} AudioRenderEffectsChanged;
	};
	ptr<Foundation::Collections::IVectorView<ptr<AudioEffect>>> GetAudioRenderEffects() { Foundation::Collections::IVectorView<AudioEffect*>* effects; hrcheck(X::get()->_GetAudioRenderEffects(&effects)); return from_abi(effects); }
	IAudioRenderEffectsManager_adaptor() {}
};
template<typename X> struct adapt<IAudioRenderEffectsManager, X> : Windows::Media::Effects::IAudioRenderEffectsManager_adaptor<X> { typedef adapt IAudioRenderEffectsManager; };
struct IAudioRenderEffectsManager : IAudioRenderEffectsManager_raw, generate<IAudioRenderEffectsManager> {};

// AudioRenderEffectsManager
template<typename X> struct statics<AudioRenderEffectsManager, X> : X {
	typedef typename X::root_type AudioRenderEffectsManager;
};
struct AudioRenderEffectsManager : generate<AudioRenderEffectsManager> {};

// IAudioCaptureEffectsManager
struct IAudioCaptureEffectsManager_raw : IInspectable {
	virtual STDMETHODIMP _add_AudioCaptureEffectsChanged(Foundation::TypedEventHandler<AudioCaptureEffectsManager*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_AudioCaptureEffectsChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _GetAudioCaptureEffects(Foundation::Collections::IVectorView<AudioEffect*>* *effects);
};
template<typename X> struct IAudioCaptureEffectsManager_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AudioCaptureEffectsManager>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAudioCaptureEffectsManager_adaptor::AudioCaptureEffectsChanged)->_add_AudioCaptureEffectsChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAudioCaptureEffectsManager_adaptor::AudioCaptureEffectsChanged)->_remove_AudioCaptureEffectsChanged(token)); }
		} AudioCaptureEffectsChanged;
	};
	ptr<Foundation::Collections::IVectorView<ptr<AudioEffect>>> GetAudioCaptureEffects() { Foundation::Collections::IVectorView<AudioEffect*>* effects; hrcheck(X::get()->_GetAudioCaptureEffects(&effects)); return from_abi(effects); }
	IAudioCaptureEffectsManager_adaptor() {}
};
template<typename X> struct adapt<IAudioCaptureEffectsManager, X> : Windows::Media::Effects::IAudioCaptureEffectsManager_adaptor<X> { typedef adapt IAudioCaptureEffectsManager; };
struct IAudioCaptureEffectsManager : IAudioCaptureEffectsManager_raw, generate<IAudioCaptureEffectsManager> {};

// AudioCaptureEffectsManager
template<typename X> struct statics<AudioCaptureEffectsManager, X> : X {
	typedef typename X::root_type AudioCaptureEffectsManager;
};
struct AudioCaptureEffectsManager : generate<AudioCaptureEffectsManager> {};

// AudioEffectsManager
template<typename> struct AudioEffectsManager_statics {
	static ptr<AudioRenderEffectsManager> CreateAudioRenderEffectsManager(hstring_ref deviceId, Render::AudioRenderCategory category) { AudioRenderEffectsManager* value; hrcheck(get_activation_factory<AudioEffectsManager, IAudioEffectsManagerStatics>()->_CreateAudioRenderEffectsManager(deviceId, category, &value)); return from_abi(value); }
	static ptr<AudioRenderEffectsManager> CreateAudioRenderEffectsManager(hstring_ref deviceId, Render::AudioRenderCategory category, AudioProcessing mode) { AudioRenderEffectsManager* value; hrcheck(get_activation_factory<AudioEffectsManager, IAudioEffectsManagerStatics>()->_CreateAudioRenderEffectsManagerWithMode(deviceId, category, mode, &value)); return from_abi(value); }
	static ptr<AudioCaptureEffectsManager> CreateAudioCaptureEffectsManager(hstring_ref deviceId, Capture::MediaCategory category) { AudioCaptureEffectsManager* value; hrcheck(get_activation_factory<AudioEffectsManager, IAudioEffectsManagerStatics>()->_CreateAudioCaptureEffectsManager(deviceId, category, &value)); return from_abi(value); }
	static ptr<AudioCaptureEffectsManager> CreateAudioCaptureEffectsManager(hstring_ref deviceId, Capture::MediaCategory category, AudioProcessing mode) { AudioCaptureEffectsManager* value; hrcheck(get_activation_factory<AudioEffectsManager, IAudioEffectsManagerStatics>()->_CreateAudioCaptureEffectsManagerWithMode(deviceId, category, mode, &value)); return from_abi(value); }
};

template<typename X> struct statics<AudioEffectsManager, X> : X, Windows::Media::Effects::AudioEffectsManager_statics<void> {
	typedef typename X::root_type AudioEffectsManager;
};
struct AudioEffectsManager : generate<AudioEffectsManager> {};

// IVideoCompositor
struct IVideoCompositor_raw : IInspectable {
	virtual STDMETHODIMP _get_TimeIndependent(bool *value) = 0;
	virtual STDMETHODIMP _SetEncodingProperties(MediaProperties::VideoEncodingProperties* backgroundProperties, Graphics::DirectX::Direct3D11::IDirect3DDevice* device) = 0;
	virtual STDMETHODIMP _CompositeFrame(CompositeVideoFrameContext* context) = 0;
	virtual STDMETHODIMP _Close(MediaEffectClosedReason reason) = 0;
	virtual STDMETHODIMP _DiscardQueuedFrames() = 0;
};
template<typename X> struct IVideoCompositor_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVideoCompositor_adaptor::TimeIndependent)->_get_TimeIndependent(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} TimeIndependent;
	};
	void SetEncodingProperties(pptr<MediaProperties::VideoEncodingProperties> backgroundProperties, pptr<Graphics::DirectX::Direct3D11::IDirect3DDevice> device) { hrcheck(X::get()->_SetEncodingProperties(backgroundProperties, device)); }
	void CompositeFrame(pptr<CompositeVideoFrameContext> context) { hrcheck(X::get()->_CompositeFrame(context)); }
	void Close(MediaEffectClosedReason reason) { hrcheck(X::get()->_Close(reason)); }
	void DiscardQueuedFrames() { hrcheck(X::get()->_DiscardQueuedFrames()); }
	IVideoCompositor_adaptor() {}
};
template<typename X> struct adapt<IVideoCompositor, X> : Windows::Media::Effects::IVideoCompositor_adaptor<X> { typedef adapt IVideoCompositor; };
template<typename X> struct IVideoCompositor_unadaptor : X {
	STDMETHODIMP _get_TimeIndependent(bool *value) { return hrtry([&, this] { get_prop(value, TimeIndependent); }); }
	STDMETHODIMP _SetEncodingProperties(MediaProperties::VideoEncodingProperties* backgroundProperties, Graphics::DirectX::Direct3D11::IDirect3DDevice* device) { return hrtry([&, this] { X::get()->SetEncodingProperties(backgroundProperties, device); }); }
	STDMETHODIMP _CompositeFrame(CompositeVideoFrameContext* context) { return hrtry([&, this] { X::get()->CompositeFrame(context); }); }
	STDMETHODIMP _Close(MediaEffectClosedReason reason) { return hrtry([&, this] { X::get()->Close(reason); }); }
	STDMETHODIMP _DiscardQueuedFrames() { return hrtry([&, this] { X::get()->DiscardQueuedFrames(); }); }
};
template<typename X> struct unadapt<IVideoCompositor, X> : Windows::Media::Effects::IVideoCompositor_unadaptor<X> {};
struct IVideoCompositor : IVideoCompositor_raw, generate<IVideoCompositor> {};

// IVideoEffectDefinition
struct IVideoEffectDefinition_raw : IInspectable {
	virtual STDMETHODIMP _get_ActivatableClassId(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_Properties(Foundation::Collections::IPropertySet* *value) = 0;
};
template<typename X> struct IVideoEffectDefinition_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVideoEffectDefinition_adaptor::ActivatableClassId)->_get_ActivatableClassId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ActivatableClassId;
		struct : property {
			ptr<Foundation::Collections::IPropertySet> get() { Foundation::Collections::IPropertySet* value; hrcheck(enc(&IVideoEffectDefinition_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IPropertySet> operator()() { return get(); }
			operator ptr<Foundation::Collections::IPropertySet> () { return get(); }
			ptr<Foundation::Collections::IPropertySet> operator->() { return get(); }
		} Properties;
	};
	IVideoEffectDefinition_adaptor() {}
};
template<typename X> struct adapt<IVideoEffectDefinition, X> : Windows::Media::Effects::IVideoEffectDefinition_adaptor<X> { typedef adapt IVideoEffectDefinition; };
template<typename X> struct IVideoEffectDefinition_unadaptor : X {
	STDMETHODIMP _get_ActivatableClassId(HSTRING *value) { return hrtry([&, this] { get_prop(value, ActivatableClassId); }); }
	STDMETHODIMP _get_Properties(Foundation::Collections::IPropertySet* *value) { return hrtry([&, this] { get_prop(value, Properties); }); }
};
template<typename X> struct unadapt<IVideoEffectDefinition, X> : Windows::Media::Effects::IVideoEffectDefinition_unadaptor<X> {};
struct IVideoEffectDefinition : IVideoEffectDefinition_raw, generate<IVideoEffectDefinition> {};

// IVideoEffectDefinitionFactory
struct IVideoEffectDefinitionFactory : IInspectable {
	virtual STDMETHODIMP _Create(HSTRING activatableClassId, VideoEffectDefinition* *value);
	virtual STDMETHODIMP _CreateWithProperties(HSTRING activatableClassId, Foundation::Collections::IPropertySet* props, VideoEffectDefinition* *value);
};

// VideoEffectDefinition
template<typename> struct VideoEffectDefinition_statics {
	static VideoEffectDefinition *activate(hstring_ref activatableClassId) { VideoEffectDefinition *value; hrcheck(get_activation_factory<VideoEffectDefinition, IVideoEffectDefinitionFactory>()->_Create(activatableClassId, &value)); return value; }
	static VideoEffectDefinition *activate(hstring_ref activatableClassId, pptr<Foundation::Collections::IPropertySet> props) { VideoEffectDefinition *value; hrcheck(get_activation_factory<VideoEffectDefinition, IVideoEffectDefinitionFactory>()->_CreateWithProperties(activatableClassId, props, &value)); return value; }
};

template<typename X> struct statics<VideoEffectDefinition, X> : X, Windows::Media::Effects::VideoEffectDefinition_statics<void> {
	using Windows::Media::Effects::VideoEffectDefinition_statics<void>::activate;
	typedef typename X::root_type VideoEffectDefinition;
};
struct VideoEffectDefinition : generate<VideoEffectDefinition> {};

// IAudioEffectDefinition
struct IAudioEffectDefinition_raw : IInspectable {
	virtual STDMETHODIMP _get_ActivatableClassId(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_Properties(Foundation::Collections::IPropertySet* *value) = 0;
};
template<typename X> struct IAudioEffectDefinition_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAudioEffectDefinition_adaptor::ActivatableClassId)->_get_ActivatableClassId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ActivatableClassId;
		struct : property {
			ptr<Foundation::Collections::IPropertySet> get() { Foundation::Collections::IPropertySet* value; hrcheck(enc(&IAudioEffectDefinition_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IPropertySet> operator()() { return get(); }
			operator ptr<Foundation::Collections::IPropertySet> () { return get(); }
			ptr<Foundation::Collections::IPropertySet> operator->() { return get(); }
		} Properties;
	};
	IAudioEffectDefinition_adaptor() {}
};
template<typename X> struct adapt<IAudioEffectDefinition, X> : Windows::Media::Effects::IAudioEffectDefinition_adaptor<X> { typedef adapt IAudioEffectDefinition; };
template<typename X> struct IAudioEffectDefinition_unadaptor : X {
	STDMETHODIMP _get_ActivatableClassId(HSTRING *value) { return hrtry([&, this] { get_prop(value, ActivatableClassId); }); }
	STDMETHODIMP _get_Properties(Foundation::Collections::IPropertySet* *value) { return hrtry([&, this] { get_prop(value, Properties); }); }
};
template<typename X> struct unadapt<IAudioEffectDefinition, X> : Windows::Media::Effects::IAudioEffectDefinition_unadaptor<X> {};
struct IAudioEffectDefinition : IAudioEffectDefinition_raw, generate<IAudioEffectDefinition> {};

// IAudioEffectDefinitionFactory
struct IAudioEffectDefinitionFactory : IInspectable {
	virtual STDMETHODIMP _Create(HSTRING activatableClassId, AudioEffectDefinition* *value);
	virtual STDMETHODIMP _CreateWithProperties(HSTRING activatableClassId, Foundation::Collections::IPropertySet* props, AudioEffectDefinition* *value);
};

// AudioEffectDefinition
template<typename> struct AudioEffectDefinition_statics {
	static AudioEffectDefinition *activate(hstring_ref activatableClassId) { AudioEffectDefinition *value; hrcheck(get_activation_factory<AudioEffectDefinition, IAudioEffectDefinitionFactory>()->_Create(activatableClassId, &value)); return value; }
	static AudioEffectDefinition *activate(hstring_ref activatableClassId, pptr<Foundation::Collections::IPropertySet> props) { AudioEffectDefinition *value; hrcheck(get_activation_factory<AudioEffectDefinition, IAudioEffectDefinitionFactory>()->_CreateWithProperties(activatableClassId, props, &value)); return value; }
};

template<typename X> struct statics<AudioEffectDefinition, X> : X, Windows::Media::Effects::AudioEffectDefinition_statics<void> {
	using Windows::Media::Effects::AudioEffectDefinition_statics<void>::activate;
	typedef typename X::root_type AudioEffectDefinition;
};
struct AudioEffectDefinition : generate<AudioEffectDefinition> {};

// IProcessVideoFrameContext
struct IProcessVideoFrameContext_raw : IInspectable {
	virtual STDMETHODIMP _get_InputFrame(VideoFrame* *value);
	virtual STDMETHODIMP _get_OutputFrame(VideoFrame* *value);
};
template<typename X> struct IProcessVideoFrameContext_adaptor : X {
	union {
		struct : property {
			ptr<VideoFrame> get() { VideoFrame* value; hrcheck(enc(&IProcessVideoFrameContext_adaptor::InputFrame)->_get_InputFrame(&value)); return from_abi(value); }
			ptr<VideoFrame> operator()() { return get(); }
			operator ptr<VideoFrame> () { return get(); }
			ptr<VideoFrame> operator->() { return get(); }
		} InputFrame;
		struct : property {
			ptr<VideoFrame> get() { VideoFrame* value; hrcheck(enc(&IProcessVideoFrameContext_adaptor::OutputFrame)->_get_OutputFrame(&value)); return from_abi(value); }
			ptr<VideoFrame> operator()() { return get(); }
			operator ptr<VideoFrame> () { return get(); }
			ptr<VideoFrame> operator->() { return get(); }
		} OutputFrame;
	};
	IProcessVideoFrameContext_adaptor() {}
};
template<typename X> struct adapt<IProcessVideoFrameContext, X> : Windows::Media::Effects::IProcessVideoFrameContext_adaptor<X> { typedef adapt IProcessVideoFrameContext; };
struct IProcessVideoFrameContext : IProcessVideoFrameContext_raw, generate<IProcessVideoFrameContext> {};

// IBasicVideoEffect
struct IBasicVideoEffect_raw : IInspectable {
	virtual STDMETHODIMP _get_IsReadOnly(bool *value) = 0;
	virtual STDMETHODIMP _get_SupportedMemoryTypes(MediaMemoryTypes *value) = 0;
	virtual STDMETHODIMP _get_TimeIndependent(bool *value) = 0;
	virtual STDMETHODIMP _get_SupportedEncodingProperties(Foundation::Collections::IVectorView<MediaProperties::VideoEncodingProperties*>* *value) = 0;
	virtual STDMETHODIMP _SetEncodingProperties(MediaProperties::VideoEncodingProperties* encodingProperties, Graphics::DirectX::Direct3D11::IDirect3DDevice* device) = 0;
	virtual STDMETHODIMP _ProcessFrame(ProcessVideoFrameContext* context) = 0;
	virtual STDMETHODIMP _Close(MediaEffectClosedReason reason) = 0;
	virtual STDMETHODIMP _DiscardQueuedFrames() = 0;
};
template<typename X> struct IBasicVideoEffect_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBasicVideoEffect_adaptor::IsReadOnly)->_get_IsReadOnly(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsReadOnly;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<MediaProperties::VideoEncodingProperties>>> get() { Foundation::Collections::IVectorView<MediaProperties::VideoEncodingProperties*>* value; hrcheck(enc(&IBasicVideoEffect_adaptor::SupportedEncodingProperties)->_get_SupportedEncodingProperties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<MediaProperties::VideoEncodingProperties>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<MediaProperties::VideoEncodingProperties>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<MediaProperties::VideoEncodingProperties>>> operator->() { return get(); }
		} SupportedEncodingProperties;
		struct : property {
			MediaMemoryTypes get() { MediaMemoryTypes value; hrcheck(enc(&IBasicVideoEffect_adaptor::SupportedMemoryTypes)->_get_SupportedMemoryTypes(&value)); return value; }
			MediaMemoryTypes operator()() { return get(); }
			operator MediaMemoryTypes () { return get(); }
		} SupportedMemoryTypes;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBasicVideoEffect_adaptor::TimeIndependent)->_get_TimeIndependent(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} TimeIndependent;
	};
	void SetEncodingProperties(pptr<MediaProperties::VideoEncodingProperties> encodingProperties, pptr<Graphics::DirectX::Direct3D11::IDirect3DDevice> device) { hrcheck(X::get()->_SetEncodingProperties(encodingProperties, device)); }
	void ProcessFrame(pptr<ProcessVideoFrameContext> context) { hrcheck(X::get()->_ProcessFrame(context)); }
	void Close(MediaEffectClosedReason reason) { hrcheck(X::get()->_Close(reason)); }
	void DiscardQueuedFrames() { hrcheck(X::get()->_DiscardQueuedFrames()); }
	IBasicVideoEffect_adaptor() {}
};
template<typename X> struct adapt<IBasicVideoEffect, X> : Windows::Media::Effects::IBasicVideoEffect_adaptor<X> { typedef adapt IBasicVideoEffect; };
template<typename X> struct IBasicVideoEffect_unadaptor : X {
	STDMETHODIMP _get_IsReadOnly(bool *value) { return hrtry([&, this] { get_prop(value, IsReadOnly); }); }
	STDMETHODIMP _get_SupportedMemoryTypes(MediaMemoryTypes *value) { return hrtry([&, this] { get_prop(value, SupportedMemoryTypes); }); }
	STDMETHODIMP _get_TimeIndependent(bool *value) { return hrtry([&, this] { get_prop(value, TimeIndependent); }); }
	STDMETHODIMP _get_SupportedEncodingProperties(Foundation::Collections::IVectorView<MediaProperties::VideoEncodingProperties*>* *value) { return hrtry([&, this] { get_prop(value, SupportedEncodingProperties); }); }
	STDMETHODIMP _SetEncodingProperties(MediaProperties::VideoEncodingProperties* encodingProperties, Graphics::DirectX::Direct3D11::IDirect3DDevice* device) { return hrtry([&, this] { X::get()->SetEncodingProperties(encodingProperties, device); }); }
	STDMETHODIMP _ProcessFrame(ProcessVideoFrameContext* context) { return hrtry([&, this] { X::get()->ProcessFrame(context); }); }
	STDMETHODIMP _Close(MediaEffectClosedReason reason) { return hrtry([&, this] { X::get()->Close(reason); }); }
	STDMETHODIMP _DiscardQueuedFrames() { return hrtry([&, this] { X::get()->DiscardQueuedFrames(); }); }
};
template<typename X> struct unadapt<IBasicVideoEffect, X> : Windows::Media::Effects::IBasicVideoEffect_unadaptor<X> {};
struct IBasicVideoEffect : IBasicVideoEffect_raw, generate<IBasicVideoEffect> {};

// ProcessVideoFrameContext
template<typename X> struct statics<ProcessVideoFrameContext, X> : X {
	typedef typename X::root_type ProcessVideoFrameContext;
};
struct ProcessVideoFrameContext : generate<ProcessVideoFrameContext> {};

// IProcessAudioFrameContext
struct IProcessAudioFrameContext_raw : IInspectable {
	virtual STDMETHODIMP _get_InputFrame(AudioFrame* *value);
	virtual STDMETHODIMP _get_OutputFrame(AudioFrame* *value);
};
template<typename X> struct IProcessAudioFrameContext_adaptor : X {
	union {
		struct : property {
			ptr<AudioFrame> get() { AudioFrame* value; hrcheck(enc(&IProcessAudioFrameContext_adaptor::InputFrame)->_get_InputFrame(&value)); return from_abi(value); }
			ptr<AudioFrame> operator()() { return get(); }
			operator ptr<AudioFrame> () { return get(); }
			ptr<AudioFrame> operator->() { return get(); }
		} InputFrame;
		struct : property {
			ptr<AudioFrame> get() { AudioFrame* value; hrcheck(enc(&IProcessAudioFrameContext_adaptor::OutputFrame)->_get_OutputFrame(&value)); return from_abi(value); }
			ptr<AudioFrame> operator()() { return get(); }
			operator ptr<AudioFrame> () { return get(); }
			ptr<AudioFrame> operator->() { return get(); }
		} OutputFrame;
	};
	IProcessAudioFrameContext_adaptor() {}
};
template<typename X> struct adapt<IProcessAudioFrameContext, X> : Windows::Media::Effects::IProcessAudioFrameContext_adaptor<X> { typedef adapt IProcessAudioFrameContext; };
struct IProcessAudioFrameContext : IProcessAudioFrameContext_raw, generate<IProcessAudioFrameContext> {};

// IBasicAudioEffect
struct IBasicAudioEffect_raw : IInspectable {
	virtual STDMETHODIMP _get_UseInputFrameForOutput(bool *value) = 0;
	virtual STDMETHODIMP _get_SupportedEncodingProperties(Foundation::Collections::IVectorView<MediaProperties::AudioEncodingProperties*>* *value) = 0;
	virtual STDMETHODIMP _SetEncodingProperties(MediaProperties::AudioEncodingProperties* encodingProperties) = 0;
	virtual STDMETHODIMP _ProcessFrame(ProcessAudioFrameContext* context) = 0;
	virtual STDMETHODIMP _Close(MediaEffectClosedReason reason) = 0;
	virtual STDMETHODIMP _DiscardQueuedFrames() = 0;
};
template<typename X> struct IBasicAudioEffect_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<MediaProperties::AudioEncodingProperties>>> get() { Foundation::Collections::IVectorView<MediaProperties::AudioEncodingProperties*>* value; hrcheck(enc(&IBasicAudioEffect_adaptor::SupportedEncodingProperties)->_get_SupportedEncodingProperties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<MediaProperties::AudioEncodingProperties>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<MediaProperties::AudioEncodingProperties>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<MediaProperties::AudioEncodingProperties>>> operator->() { return get(); }
		} SupportedEncodingProperties;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBasicAudioEffect_adaptor::UseInputFrameForOutput)->_get_UseInputFrameForOutput(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} UseInputFrameForOutput;
	};
	void SetEncodingProperties(pptr<MediaProperties::AudioEncodingProperties> encodingProperties) { hrcheck(X::get()->_SetEncodingProperties(encodingProperties)); }
	void ProcessFrame(pptr<ProcessAudioFrameContext> context) { hrcheck(X::get()->_ProcessFrame(context)); }
	void Close(MediaEffectClosedReason reason) { hrcheck(X::get()->_Close(reason)); }
	void DiscardQueuedFrames() { hrcheck(X::get()->_DiscardQueuedFrames()); }
	IBasicAudioEffect_adaptor() {}
};
template<typename X> struct adapt<IBasicAudioEffect, X> : Windows::Media::Effects::IBasicAudioEffect_adaptor<X> { typedef adapt IBasicAudioEffect; };
template<typename X> struct IBasicAudioEffect_unadaptor : X {
	STDMETHODIMP _get_UseInputFrameForOutput(bool *value) { return hrtry([&, this] { get_prop(value, UseInputFrameForOutput); }); }
	STDMETHODIMP _get_SupportedEncodingProperties(Foundation::Collections::IVectorView<MediaProperties::AudioEncodingProperties*>* *value) { return hrtry([&, this] { get_prop(value, SupportedEncodingProperties); }); }
	STDMETHODIMP _SetEncodingProperties(MediaProperties::AudioEncodingProperties* encodingProperties) { return hrtry([&, this] { X::get()->SetEncodingProperties(encodingProperties); }); }
	STDMETHODIMP _ProcessFrame(ProcessAudioFrameContext* context) { return hrtry([&, this] { X::get()->ProcessFrame(context); }); }
	STDMETHODIMP _Close(MediaEffectClosedReason reason) { return hrtry([&, this] { X::get()->Close(reason); }); }
	STDMETHODIMP _DiscardQueuedFrames() { return hrtry([&, this] { X::get()->DiscardQueuedFrames(); }); }
};
template<typename X> struct unadapt<IBasicAudioEffect, X> : Windows::Media::Effects::IBasicAudioEffect_unadaptor<X> {};
struct IBasicAudioEffect : IBasicAudioEffect_raw, generate<IBasicAudioEffect> {};

// ProcessAudioFrameContext
template<typename X> struct statics<ProcessAudioFrameContext, X> : X {
	typedef typename X::root_type ProcessAudioFrameContext;
};
struct ProcessAudioFrameContext : generate<ProcessAudioFrameContext> {};

// IVideoTransformEffectDefinition
struct IVideoTransformEffectDefinition_raw : IInspectable {
	virtual STDMETHODIMP _get_PaddingColor(UI::Color *value);
	virtual STDMETHODIMP _put_PaddingColor(UI::Color value);
	virtual STDMETHODIMP _get_OutputSize(Foundation::Size *value);
	virtual STDMETHODIMP _put_OutputSize(Foundation::Size value);
	virtual STDMETHODIMP _get_CropRectangle(Foundation::Rect *value);
	virtual STDMETHODIMP _put_CropRectangle(Foundation::Rect value);
	virtual STDMETHODIMP _get_Rotation(MediaProperties::MediaRotation *value);
	virtual STDMETHODIMP _put_Rotation(MediaProperties::MediaRotation value);
	virtual STDMETHODIMP _get_Mirror(MediaProperties::MediaMirroringOptions *value);
	virtual STDMETHODIMP _put_Mirror(MediaProperties::MediaMirroringOptions value);
	virtual STDMETHODIMP _put_ProcessingAlgorithm(Transcoding::MediaVideoProcessingAlgorithm value);
	virtual STDMETHODIMP _get_ProcessingAlgorithm(Transcoding::MediaVideoProcessingAlgorithm *value);
};
template<typename X> struct IVideoTransformEffectDefinition_adaptor : X {
	union {
		struct : property {
			Foundation::Rect get() { Foundation::Rect value; hrcheck(enc(&IVideoTransformEffectDefinition_adaptor::CropRectangle)->_get_CropRectangle(&value)); return value; }
			Foundation::Rect operator()() { return get(); }
			operator Foundation::Rect () { return get(); }
			void put(const Foundation::Rect& value) { hrcheck(enc(&IVideoTransformEffectDefinition_adaptor::CropRectangle)->_put_CropRectangle(value)); }
			void operator=(const Foundation::Rect& value) { put(value); }
			void operator()(const Foundation::Rect& value) { put(value); }
		} CropRectangle;
		struct : property {
			MediaProperties::MediaMirroringOptions get() { MediaProperties::MediaMirroringOptions value; hrcheck(enc(&IVideoTransformEffectDefinition_adaptor::Mirror)->_get_Mirror(&value)); return value; }
			MediaProperties::MediaMirroringOptions operator()() { return get(); }
			operator MediaProperties::MediaMirroringOptions () { return get(); }
			void put(MediaProperties::MediaMirroringOptions value) { hrcheck(enc(&IVideoTransformEffectDefinition_adaptor::Mirror)->_put_Mirror(value)); }
			void operator=(MediaProperties::MediaMirroringOptions value) { put(value); }
			void operator()(MediaProperties::MediaMirroringOptions value) { put(value); }
		} Mirror;
		struct : property {
			Foundation::Size get() { Foundation::Size value; hrcheck(enc(&IVideoTransformEffectDefinition_adaptor::OutputSize)->_get_OutputSize(&value)); return value; }
			Foundation::Size operator()() { return get(); }
			operator Foundation::Size () { return get(); }
			void put(const Foundation::Size& value) { hrcheck(enc(&IVideoTransformEffectDefinition_adaptor::OutputSize)->_put_OutputSize(value)); }
			void operator=(const Foundation::Size& value) { put(value); }
			void operator()(const Foundation::Size& value) { put(value); }
		} OutputSize;
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&IVideoTransformEffectDefinition_adaptor::PaddingColor)->_get_PaddingColor(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&IVideoTransformEffectDefinition_adaptor::PaddingColor)->_put_PaddingColor(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} PaddingColor;
		struct : property {
			Transcoding::MediaVideoProcessingAlgorithm get() { Transcoding::MediaVideoProcessingAlgorithm value; hrcheck(enc(&IVideoTransformEffectDefinition_adaptor::ProcessingAlgorithm)->_get_ProcessingAlgorithm(&value)); return value; }
			Transcoding::MediaVideoProcessingAlgorithm operator()() { return get(); }
			operator Transcoding::MediaVideoProcessingAlgorithm () { return get(); }
			void put(Transcoding::MediaVideoProcessingAlgorithm value) { hrcheck(enc(&IVideoTransformEffectDefinition_adaptor::ProcessingAlgorithm)->_put_ProcessingAlgorithm(value)); }
			void operator=(Transcoding::MediaVideoProcessingAlgorithm value) { put(value); }
			void operator()(Transcoding::MediaVideoProcessingAlgorithm value) { put(value); }
		} ProcessingAlgorithm;
		struct : property {
			MediaProperties::MediaRotation get() { MediaProperties::MediaRotation value; hrcheck(enc(&IVideoTransformEffectDefinition_adaptor::Rotation)->_get_Rotation(&value)); return value; }
			MediaProperties::MediaRotation operator()() { return get(); }
			operator MediaProperties::MediaRotation () { return get(); }
			void put(MediaProperties::MediaRotation value) { hrcheck(enc(&IVideoTransformEffectDefinition_adaptor::Rotation)->_put_Rotation(value)); }
			void operator=(MediaProperties::MediaRotation value) { put(value); }
			void operator()(MediaProperties::MediaRotation value) { put(value); }
		} Rotation;
	};
	IVideoTransformEffectDefinition_adaptor() {}
};
template<typename X> struct adapt<IVideoTransformEffectDefinition, X> : Windows::Media::Effects::IVideoTransformEffectDefinition_adaptor<X> { typedef adapt IVideoTransformEffectDefinition; };
struct IVideoTransformEffectDefinition : IVideoTransformEffectDefinition_raw, generate<IVideoTransformEffectDefinition> {};

// IVideoTransformSphericalProjection
struct IVideoTransformSphericalProjection_raw : IInspectable {
	virtual STDMETHODIMP _get_IsEnabled(bool *value);
	virtual STDMETHODIMP _put_IsEnabled(bool value);
	virtual STDMETHODIMP _get_FrameFormat(MediaProperties::SphericalVideoFrameFormat *value);
	virtual STDMETHODIMP _put_FrameFormat(MediaProperties::SphericalVideoFrameFormat value);
	virtual STDMETHODIMP _get_ProjectionMode(Playback::SphericalVideoProjectionMode *value);
	virtual STDMETHODIMP _put_ProjectionMode(Playback::SphericalVideoProjectionMode value);
	virtual STDMETHODIMP _get_HorizontalFieldOfViewInDegrees(double *value);
	virtual STDMETHODIMP _put_HorizontalFieldOfViewInDegrees(double value);
	virtual STDMETHODIMP _get_ViewOrientation(Foundation::Numerics::Quaternion *value);
	virtual STDMETHODIMP _put_ViewOrientation(Foundation::Numerics::Quaternion value);
};
template<typename X> struct IVideoTransformSphericalProjection_adaptor : X {
	union {
		struct : property {
			MediaProperties::SphericalVideoFrameFormat get() { MediaProperties::SphericalVideoFrameFormat value; hrcheck(enc(&IVideoTransformSphericalProjection_adaptor::FrameFormat)->_get_FrameFormat(&value)); return value; }
			MediaProperties::SphericalVideoFrameFormat operator()() { return get(); }
			operator MediaProperties::SphericalVideoFrameFormat () { return get(); }
			void put(MediaProperties::SphericalVideoFrameFormat value) { hrcheck(enc(&IVideoTransformSphericalProjection_adaptor::FrameFormat)->_put_FrameFormat(value)); }
			void operator=(MediaProperties::SphericalVideoFrameFormat value) { put(value); }
			void operator()(MediaProperties::SphericalVideoFrameFormat value) { put(value); }
		} FrameFormat;
		struct : property {
			double get() { double value; hrcheck(enc(&IVideoTransformSphericalProjection_adaptor::HorizontalFieldOfViewInDegrees)->_get_HorizontalFieldOfViewInDegrees(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IVideoTransformSphericalProjection_adaptor::HorizontalFieldOfViewInDegrees)->_put_HorizontalFieldOfViewInDegrees(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} HorizontalFieldOfViewInDegrees;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IVideoTransformSphericalProjection_adaptor::IsEnabled)->_get_IsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IVideoTransformSphericalProjection_adaptor::IsEnabled)->_put_IsEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsEnabled;
		struct : property {
			Playback::SphericalVideoProjectionMode get() { Playback::SphericalVideoProjectionMode value; hrcheck(enc(&IVideoTransformSphericalProjection_adaptor::ProjectionMode)->_get_ProjectionMode(&value)); return value; }
			Playback::SphericalVideoProjectionMode operator()() { return get(); }
			operator Playback::SphericalVideoProjectionMode () { return get(); }
			void put(Playback::SphericalVideoProjectionMode value) { hrcheck(enc(&IVideoTransformSphericalProjection_adaptor::ProjectionMode)->_put_ProjectionMode(value)); }
			void operator=(Playback::SphericalVideoProjectionMode value) { put(value); }
			void operator()(Playback::SphericalVideoProjectionMode value) { put(value); }
		} ProjectionMode;
		struct : property {
			Foundation::Numerics::Quaternion get() { Foundation::Numerics::Quaternion value; hrcheck(enc(&IVideoTransformSphericalProjection_adaptor::ViewOrientation)->_get_ViewOrientation(&value)); return value; }
			Foundation::Numerics::Quaternion operator()() { return get(); }
			operator Foundation::Numerics::Quaternion () { return get(); }
			void put(const Foundation::Numerics::Quaternion& value) { hrcheck(enc(&IVideoTransformSphericalProjection_adaptor::ViewOrientation)->_put_ViewOrientation(value)); }
			void operator=(const Foundation::Numerics::Quaternion& value) { put(value); }
			void operator()(const Foundation::Numerics::Quaternion& value) { put(value); }
		} ViewOrientation;
	};
	IVideoTransformSphericalProjection_adaptor() {}
};
template<typename X> struct adapt<IVideoTransformSphericalProjection, X> : Windows::Media::Effects::IVideoTransformSphericalProjection_adaptor<X> { typedef adapt IVideoTransformSphericalProjection; };
struct IVideoTransformSphericalProjection : IVideoTransformSphericalProjection_raw, generate<IVideoTransformSphericalProjection> {};

// IVideoTransformEffectDefinition2
struct IVideoTransformEffectDefinition2_raw : IInspectable {
	virtual STDMETHODIMP _get_SphericalProjection(VideoTransformSphericalProjection* *value);
};
template<typename X> struct IVideoTransformEffectDefinition2_adaptor : X {
	union {
		struct : property {
			ptr<VideoTransformSphericalProjection> get() { VideoTransformSphericalProjection* value; hrcheck(enc(&IVideoTransformEffectDefinition2_adaptor::SphericalProjection)->_get_SphericalProjection(&value)); return from_abi(value); }
			ptr<VideoTransformSphericalProjection> operator()() { return get(); }
			operator ptr<VideoTransformSphericalProjection> () { return get(); }
			ptr<VideoTransformSphericalProjection> operator->() { return get(); }
		} SphericalProjection;
	};
	IVideoTransformEffectDefinition2_adaptor() {}
};
template<typename X> struct adapt<IVideoTransformEffectDefinition2, X> : Windows::Media::Effects::IVideoTransformEffectDefinition2_adaptor<X> { typedef adapt IVideoTransformEffectDefinition2; };
struct IVideoTransformEffectDefinition2 : IVideoTransformEffectDefinition2_raw, generate<IVideoTransformEffectDefinition2> {};

// VideoTransformSphericalProjection
template<typename X> struct statics<VideoTransformSphericalProjection, X> : X {
	typedef typename X::root_type VideoTransformSphericalProjection;
};
struct VideoTransformSphericalProjection : generate<VideoTransformSphericalProjection> {};

// VideoTransformEffectDefinition
template<typename X> struct statics<VideoTransformEffectDefinition, X> : X {
	typedef typename X::root_type VideoTransformEffectDefinition;
};
struct VideoTransformEffectDefinition : generate<VideoTransformEffectDefinition> {};

// ISlowMotionEffectDefinition
struct ISlowMotionEffectDefinition_raw : IInspectable {
	virtual STDMETHODIMP _get_TimeStretchRate(double *value);
	virtual STDMETHODIMP _put_TimeStretchRate(double value);
};
template<typename X> struct ISlowMotionEffectDefinition_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&ISlowMotionEffectDefinition_adaptor::TimeStretchRate)->_get_TimeStretchRate(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&ISlowMotionEffectDefinition_adaptor::TimeStretchRate)->_put_TimeStretchRate(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} TimeStretchRate;
	};
	ISlowMotionEffectDefinition_adaptor() {}
};
template<typename X> struct adapt<ISlowMotionEffectDefinition, X> : Windows::Media::Effects::ISlowMotionEffectDefinition_adaptor<X> { typedef adapt ISlowMotionEffectDefinition; };
struct ISlowMotionEffectDefinition : ISlowMotionEffectDefinition_raw, generate<ISlowMotionEffectDefinition> {};

// SlowMotionEffectDefinition
template<typename X> struct statics<SlowMotionEffectDefinition, X> : X {
	typedef typename X::root_type SlowMotionEffectDefinition;
};
struct SlowMotionEffectDefinition : generate<SlowMotionEffectDefinition> {};
}}}
} // namespace iso_winrt
