#pragma once
// generated by isopod tools
// namespaces:
// Windows.Gaming.Input.ForceFeedback

#include "Windows.Gaming.Input.ForceFeedback.0.h"
#include "Windows.Foundation.Numerics.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types


// defs

template<> struct def<Windows::Gaming::Input::ForceFeedback::ConditionForceEffectKind> : enum_type<int> {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::ForceFeedbackEffectAxes> : enum_type<unsigned> {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::ForceFeedbackEffectState> : enum_type<int> {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::ForceFeedbackLoadEffectResult> : enum_type<int> {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::PeriodicForceEffectKind> : enum_type<int> {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::IForceFeedbackEffect> : overridable_type<> {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::IConditionForceEffect> : interface_type<Windows::Gaming::Input::ForceFeedback::IForceFeedbackEffect> {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::IConditionForceEffectFactory> : interface_type<> {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::ConditionForceEffect> : class_type<Platform::Object, Windows::Gaming::Input::ForceFeedback::IForceFeedbackEffect, Windows::Gaming::Input::ForceFeedback::IConditionForceEffect>, custom_activators {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::IConstantForceEffect> : interface_type<Windows::Gaming::Input::ForceFeedback::IForceFeedbackEffect> {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::IPeriodicForceEffect> : interface_type<Windows::Gaming::Input::ForceFeedback::IForceFeedbackEffect> {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::IPeriodicForceEffectFactory> : interface_type<> {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::PeriodicForceEffect> : class_type<Platform::Object, Windows::Gaming::Input::ForceFeedback::IForceFeedbackEffect, Windows::Gaming::Input::ForceFeedback::IPeriodicForceEffect>, custom_activators {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::IRampForceEffect> : interface_type<Windows::Gaming::Input::ForceFeedback::IForceFeedbackEffect> {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::IForceFeedbackMotor> : interface_type<> {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::ConstantForceEffect> : class_type<Platform::Object, Windows::Gaming::Input::ForceFeedback::IForceFeedbackEffect, Windows::Gaming::Input::ForceFeedback::IConstantForceEffect> {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::RampForceEffect> : class_type<Platform::Object, Windows::Gaming::Input::ForceFeedback::IForceFeedbackEffect, Windows::Gaming::Input::ForceFeedback::IRampForceEffect> {};
template<> struct def<Windows::Gaming::Input::ForceFeedback::ForceFeedbackMotor> : class_type<Platform::Object, Windows::Gaming::Input::ForceFeedback::IForceFeedbackMotor> {};

// uuids

template<> struct uuid<Windows::Gaming::Input::ForceFeedback::IForceFeedbackEffect> { define_guid(0xA17FBA0C, 0x2AE4, 0x48C2, 0x80, 0x63, 0xEA, 0xBD, 0x7, 0x77, 0xCB, 0x89);};
template<> struct uuid<Windows::Gaming::Input::ForceFeedback::IConditionForceEffect> { define_guid(0x32D1EA68, 0x3695, 0x4E69, 0x85, 0xC0, 0xCD, 0x19, 0x44, 0x18, 0x91, 0x40);};
template<> struct uuid<Windows::Gaming::Input::ForceFeedback::IConditionForceEffectFactory> { define_guid(0x91A99264, 0x1810, 0x4EB6, 0xA7, 0x73, 0xBF, 0xD3, 0xB8, 0xCD, 0xDB, 0xAB);};
template<> struct uuid<Windows::Gaming::Input::ForceFeedback::IConstantForceEffect> { define_guid(0x9BFA0140, 0xF3C7, 0x415C, 0xB0, 0x68, 0xF, 0x6, 0x87, 0x34, 0xBC, 0xE0);};
template<> struct uuid<Windows::Gaming::Input::ForceFeedback::IPeriodicForceEffect> { define_guid(0x5C5138D7, 0xFC75, 0x4D52, 0x9A, 0xA, 0xEF, 0xE4, 0xCA, 0xB5, 0xFE, 0x64);};
template<> struct uuid<Windows::Gaming::Input::ForceFeedback::IPeriodicForceEffectFactory> { define_guid(0x6F62EB1A, 0x9851, 0x477B, 0xB3, 0x18, 0x35, 0xEC, 0xAA, 0x15, 0x7, 0xF);};
template<> struct uuid<Windows::Gaming::Input::ForceFeedback::IRampForceEffect> { define_guid(0xF1F81259, 0x1CA6, 0x4080, 0xB5, 0x6D, 0xB4, 0x3F, 0x33, 0x54, 0xD0, 0x52);};
template<> struct uuid<Windows::Gaming::Input::ForceFeedback::IForceFeedbackMotor> { define_guid(0x8D3D417C, 0xA5EA, 0x4516, 0x80, 0x26, 0x2B, 0x0, 0xF7, 0x4E, 0xF6, 0xE5);};

// types

namespace Windows { namespace Gaming { namespace Input { namespace ForceFeedback {

// IForceFeedbackEffect
struct IForceFeedbackEffect_raw : IInspectable {
	virtual STDMETHODIMP _get_Gain(double *value) = 0;
	virtual STDMETHODIMP _put_Gain(double value) = 0;
	virtual STDMETHODIMP _get_State(ForceFeedbackEffectState *value) = 0;
	virtual STDMETHODIMP _Start() = 0;
	virtual STDMETHODIMP _Stop() = 0;
};
template<typename X> struct IForceFeedbackEffect_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IForceFeedbackEffect_adaptor::Gain)->_get_Gain(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IForceFeedbackEffect_adaptor::Gain)->_put_Gain(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} Gain;
		struct : property {
			ForceFeedbackEffectState get() { ForceFeedbackEffectState value; hrcheck(enc(&IForceFeedbackEffect_adaptor::State)->_get_State(&value)); return value; }
			ForceFeedbackEffectState operator()() { return get(); }
			operator ForceFeedbackEffectState () { return get(); }
		} State;
	};
	void Start() { hrcheck(X::get()->_Start()); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	IForceFeedbackEffect_adaptor() {}
};
template<typename X> struct adapt<IForceFeedbackEffect, X> : Windows::Gaming::Input::ForceFeedback::IForceFeedbackEffect_adaptor<X> { typedef adapt IForceFeedbackEffect; };
template<typename X> struct IForceFeedbackEffect_unadaptor : X {
	STDMETHODIMP _get_Gain(double *value) { return hrtry([&, this] { get_prop(value, Gain); }); }
	STDMETHODIMP _put_Gain(double value) { return hrtry([&, this] { put_prop(value, Gain); }); }
	STDMETHODIMP _get_State(ForceFeedbackEffectState *value) { return hrtry([&, this] { get_prop(value, State); }); }
	STDMETHODIMP _Start() { return hrtry([&, this] { X::get()->Start(); }); }
	STDMETHODIMP _Stop() { return hrtry([&, this] { X::get()->Stop(); }); }
};
template<typename X> struct unadapt<IForceFeedbackEffect, X> : Windows::Gaming::Input::ForceFeedback::IForceFeedbackEffect_unadaptor<X> {};
struct IForceFeedbackEffect : IForceFeedbackEffect_raw, generate<IForceFeedbackEffect> {};

// IConditionForceEffect
struct IConditionForceEffect_raw : IInspectable {
	virtual STDMETHODIMP _get_Kind(ConditionForceEffectKind *value);
	virtual STDMETHODIMP _SetParameters(Foundation::Numerics::Vector3 direction, float positiveCoefficient, float negativeCoefficient, float maxPositiveMagnitude, float maxNegativeMagnitude, float deadZone, float bias);
};
template<typename X> struct IConditionForceEffect_adaptor : X {
	union {
		struct : property {
			ConditionForceEffectKind get() { ConditionForceEffectKind value; hrcheck(enc(&IConditionForceEffect_adaptor::Kind)->_get_Kind(&value)); return value; }
			ConditionForceEffectKind operator()() { return get(); }
			operator ConditionForceEffectKind () { return get(); }
		} Kind;
	};
	void SetParameters(const Foundation::Numerics::Vector3& direction, float positiveCoefficient, float negativeCoefficient, float maxPositiveMagnitude, float maxNegativeMagnitude, float deadZone, float bias) { hrcheck(X::get()->_SetParameters(direction, positiveCoefficient, negativeCoefficient, maxPositiveMagnitude, maxNegativeMagnitude, deadZone, bias)); }
	IConditionForceEffect_adaptor() {}
};
template<typename X> struct adapt<IConditionForceEffect, X> : Windows::Gaming::Input::ForceFeedback::IConditionForceEffect_adaptor<X> { typedef adapt IConditionForceEffect; };
struct IConditionForceEffect : IConditionForceEffect_raw, generate<IConditionForceEffect> {};

// IConditionForceEffectFactory
struct IConditionForceEffectFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(ConditionForceEffectKind effectKind, ConditionForceEffect* *value);
};

// ConditionForceEffect
template<typename> struct ConditionForceEffect_statics {
	static ConditionForceEffect *activate(ConditionForceEffectKind effectKind) { ConditionForceEffect *value; hrcheck(get_activation_factory<ConditionForceEffect, IConditionForceEffectFactory>()->_CreateInstance(effectKind, &value)); return value; }
};

template<typename X> struct statics<ConditionForceEffect, X> : X, Windows::Gaming::Input::ForceFeedback::ConditionForceEffect_statics<void> {
	using Windows::Gaming::Input::ForceFeedback::ConditionForceEffect_statics<void>::activate;
	typedef typename X::root_type ConditionForceEffect;
};
struct ConditionForceEffect : generate<ConditionForceEffect> {};

// IConstantForceEffect
struct IConstantForceEffect_raw : IInspectable {
	virtual STDMETHODIMP _SetParameters(Foundation::Numerics::Vector3 vector, Foundation::TimeSpan duration);
	virtual STDMETHODIMP _SetParametersWithEnvelope(Foundation::Numerics::Vector3 vector, float attackGain, float sustainGain, float releaseGain, Foundation::TimeSpan startDelay, Foundation::TimeSpan attackDuration, Foundation::TimeSpan sustainDuration, Foundation::TimeSpan releaseDuration, unsigned repeatCount);
};
template<typename X> struct IConstantForceEffect_adaptor : X {
	void SetParameters(const Foundation::Numerics::Vector3& vector, const Foundation::TimeSpan& duration) { hrcheck(X::get()->_SetParameters(vector, duration)); }
	void SetParametersWithEnvelope(const Foundation::Numerics::Vector3& vector, float attackGain, float sustainGain, float releaseGain, const Foundation::TimeSpan& startDelay, const Foundation::TimeSpan& attackDuration, const Foundation::TimeSpan& sustainDuration, const Foundation::TimeSpan& releaseDuration, unsigned repeatCount) { hrcheck(X::get()->_SetParametersWithEnvelope(vector, attackGain, sustainGain, releaseGain, startDelay, attackDuration, sustainDuration, releaseDuration, repeatCount)); }
};
template<typename X> struct adapt<IConstantForceEffect, X> : Windows::Gaming::Input::ForceFeedback::IConstantForceEffect_adaptor<X> { typedef adapt IConstantForceEffect; };
struct IConstantForceEffect : IConstantForceEffect_raw, generate<IConstantForceEffect> {};

// IPeriodicForceEffect
struct IPeriodicForceEffect_raw : IInspectable {
	virtual STDMETHODIMP _get_Kind(PeriodicForceEffectKind *value);
	virtual STDMETHODIMP _SetParameters(Foundation::Numerics::Vector3 vector, float frequency, float phase, float bias, Foundation::TimeSpan duration);
	virtual STDMETHODIMP _SetParametersWithEnvelope(Foundation::Numerics::Vector3 vector, float frequency, float phase, float bias, float attackGain, float sustainGain, float releaseGain, Foundation::TimeSpan startDelay, Foundation::TimeSpan attackDuration, Foundation::TimeSpan sustainDuration, Foundation::TimeSpan releaseDuration, unsigned repeatCount);
};
template<typename X> struct IPeriodicForceEffect_adaptor : X {
	union {
		struct : property {
			PeriodicForceEffectKind get() { PeriodicForceEffectKind value; hrcheck(enc(&IPeriodicForceEffect_adaptor::Kind)->_get_Kind(&value)); return value; }
			PeriodicForceEffectKind operator()() { return get(); }
			operator PeriodicForceEffectKind () { return get(); }
		} Kind;
	};
	void SetParameters(const Foundation::Numerics::Vector3& vector, float frequency, float phase, float bias, const Foundation::TimeSpan& duration) { hrcheck(X::get()->_SetParameters(vector, frequency, phase, bias, duration)); }
	void SetParametersWithEnvelope(const Foundation::Numerics::Vector3& vector, float frequency, float phase, float bias, float attackGain, float sustainGain, float releaseGain, const Foundation::TimeSpan& startDelay, const Foundation::TimeSpan& attackDuration, const Foundation::TimeSpan& sustainDuration, const Foundation::TimeSpan& releaseDuration, unsigned repeatCount) { hrcheck(X::get()->_SetParametersWithEnvelope(vector, frequency, phase, bias, attackGain, sustainGain, releaseGain, startDelay, attackDuration, sustainDuration, releaseDuration, repeatCount)); }
	IPeriodicForceEffect_adaptor() {}
};
template<typename X> struct adapt<IPeriodicForceEffect, X> : Windows::Gaming::Input::ForceFeedback::IPeriodicForceEffect_adaptor<X> { typedef adapt IPeriodicForceEffect; };
struct IPeriodicForceEffect : IPeriodicForceEffect_raw, generate<IPeriodicForceEffect> {};

// IPeriodicForceEffectFactory
struct IPeriodicForceEffectFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(PeriodicForceEffectKind effectKind, PeriodicForceEffect* *value);
};

// PeriodicForceEffect
template<typename> struct PeriodicForceEffect_statics {
	static PeriodicForceEffect *activate(PeriodicForceEffectKind effectKind) { PeriodicForceEffect *value; hrcheck(get_activation_factory<PeriodicForceEffect, IPeriodicForceEffectFactory>()->_CreateInstance(effectKind, &value)); return value; }
};

template<typename X> struct statics<PeriodicForceEffect, X> : X, Windows::Gaming::Input::ForceFeedback::PeriodicForceEffect_statics<void> {
	using Windows::Gaming::Input::ForceFeedback::PeriodicForceEffect_statics<void>::activate;
	typedef typename X::root_type PeriodicForceEffect;
};
struct PeriodicForceEffect : generate<PeriodicForceEffect> {};

// IRampForceEffect
struct IRampForceEffect_raw : IInspectable {
	virtual STDMETHODIMP _SetParameters(Foundation::Numerics::Vector3 startVector, Foundation::Numerics::Vector3 endVector, Foundation::TimeSpan duration);
	virtual STDMETHODIMP _SetParametersWithEnvelope(Foundation::Numerics::Vector3 startVector, Foundation::Numerics::Vector3 endVector, float attackGain, float sustainGain, float releaseGain, Foundation::TimeSpan startDelay, Foundation::TimeSpan attackDuration, Foundation::TimeSpan sustainDuration, Foundation::TimeSpan releaseDuration, unsigned repeatCount);
};
template<typename X> struct IRampForceEffect_adaptor : X {
	void SetParameters(const Foundation::Numerics::Vector3& startVector, const Foundation::Numerics::Vector3& endVector, const Foundation::TimeSpan& duration) { hrcheck(X::get()->_SetParameters(startVector, endVector, duration)); }
	void SetParametersWithEnvelope(const Foundation::Numerics::Vector3& startVector, const Foundation::Numerics::Vector3& endVector, float attackGain, float sustainGain, float releaseGain, const Foundation::TimeSpan& startDelay, const Foundation::TimeSpan& attackDuration, const Foundation::TimeSpan& sustainDuration, const Foundation::TimeSpan& releaseDuration, unsigned repeatCount) { hrcheck(X::get()->_SetParametersWithEnvelope(startVector, endVector, attackGain, sustainGain, releaseGain, startDelay, attackDuration, sustainDuration, releaseDuration, repeatCount)); }
};
template<typename X> struct adapt<IRampForceEffect, X> : Windows::Gaming::Input::ForceFeedback::IRampForceEffect_adaptor<X> { typedef adapt IRampForceEffect; };
struct IRampForceEffect : IRampForceEffect_raw, generate<IRampForceEffect> {};

// IForceFeedbackMotor
struct IForceFeedbackMotor_raw : IInspectable {
	virtual STDMETHODIMP _get_AreEffectsPaused(bool *value);
	virtual STDMETHODIMP _get_MasterGain(double *value);
	virtual STDMETHODIMP _put_MasterGain(double value);
	virtual STDMETHODIMP _get_IsEnabled(bool *value);
	virtual STDMETHODIMP _get_SupportedAxes(ForceFeedbackEffectAxes *value);
	virtual STDMETHODIMP _LoadEffectAsync(IForceFeedbackEffect* effect, Foundation::IAsyncOperation<ForceFeedbackLoadEffectResult>* *asyncOperation);
	virtual STDMETHODIMP _PauseAllEffects();
	virtual STDMETHODIMP _ResumeAllEffects();
	virtual STDMETHODIMP _StopAllEffects();
	virtual STDMETHODIMP _TryDisableAsync(Foundation::IAsyncOperation<bool>* *asyncOperation);
	virtual STDMETHODIMP _TryEnableAsync(Foundation::IAsyncOperation<bool>* *asyncOperation);
	virtual STDMETHODIMP _TryResetAsync(Foundation::IAsyncOperation<bool>* *asyncOperation);
	virtual STDMETHODIMP _TryUnloadEffectAsync(IForceFeedbackEffect* effect, Foundation::IAsyncOperation<bool>* *asyncOperation);
};
template<typename X> struct IForceFeedbackMotor_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IForceFeedbackMotor_adaptor::AreEffectsPaused)->_get_AreEffectsPaused(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} AreEffectsPaused;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IForceFeedbackMotor_adaptor::IsEnabled)->_get_IsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsEnabled;
		struct : property {
			double get() { double value; hrcheck(enc(&IForceFeedbackMotor_adaptor::MasterGain)->_get_MasterGain(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IForceFeedbackMotor_adaptor::MasterGain)->_put_MasterGain(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MasterGain;
		struct : property {
			ForceFeedbackEffectAxes get() { ForceFeedbackEffectAxes value; hrcheck(enc(&IForceFeedbackMotor_adaptor::SupportedAxes)->_get_SupportedAxes(&value)); return value; }
			ForceFeedbackEffectAxes operator()() { return get(); }
			operator ForceFeedbackEffectAxes () { return get(); }
		} SupportedAxes;
	};
	ptr<Foundation::IAsyncOperation<ForceFeedbackLoadEffectResult>> LoadEffectAsync(pptr<IForceFeedbackEffect> effect) { Foundation::IAsyncOperation<ForceFeedbackLoadEffectResult>* asyncOperation; hrcheck(X::get()->_LoadEffectAsync(effect, &asyncOperation)); return from_abi(asyncOperation); }
	void PauseAllEffects() { hrcheck(X::get()->_PauseAllEffects()); }
	void ResumeAllEffects() { hrcheck(X::get()->_ResumeAllEffects()); }
	void StopAllEffects() { hrcheck(X::get()->_StopAllEffects()); }
	ptr<Foundation::IAsyncOperation<bool>> TryDisableAsync() { Foundation::IAsyncOperation<bool>* asyncOperation; hrcheck(X::get()->_TryDisableAsync(&asyncOperation)); return from_abi(asyncOperation); }
	ptr<Foundation::IAsyncOperation<bool>> TryEnableAsync() { Foundation::IAsyncOperation<bool>* asyncOperation; hrcheck(X::get()->_TryEnableAsync(&asyncOperation)); return from_abi(asyncOperation); }
	ptr<Foundation::IAsyncOperation<bool>> TryResetAsync() { Foundation::IAsyncOperation<bool>* asyncOperation; hrcheck(X::get()->_TryResetAsync(&asyncOperation)); return from_abi(asyncOperation); }
	ptr<Foundation::IAsyncOperation<bool>> TryUnloadEffectAsync(pptr<IForceFeedbackEffect> effect) { Foundation::IAsyncOperation<bool>* asyncOperation; hrcheck(X::get()->_TryUnloadEffectAsync(effect, &asyncOperation)); return from_abi(asyncOperation); }
	IForceFeedbackMotor_adaptor() {}
};
template<typename X> struct adapt<IForceFeedbackMotor, X> : Windows::Gaming::Input::ForceFeedback::IForceFeedbackMotor_adaptor<X> { typedef adapt IForceFeedbackMotor; };
struct IForceFeedbackMotor : IForceFeedbackMotor_raw, generate<IForceFeedbackMotor> {};

// ConstantForceEffect
template<typename X> struct statics<ConstantForceEffect, X> : X {
	typedef typename X::root_type ConstantForceEffect;
};
struct ConstantForceEffect : generate<ConstantForceEffect> {};

// RampForceEffect
template<typename X> struct statics<RampForceEffect, X> : X {
	typedef typename X::root_type RampForceEffect;
};
struct RampForceEffect : generate<RampForceEffect> {};

// ForceFeedbackMotor
template<typename X> struct statics<ForceFeedbackMotor, X> : X {
	typedef typename X::root_type ForceFeedbackMotor;
};
struct ForceFeedbackMotor : generate<ForceFeedbackMotor> {};
}}}}
} // namespace iso_winrt
