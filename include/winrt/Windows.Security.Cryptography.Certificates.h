#pragma once
// generated by isopod tools
// namespaces:
// Windows.Security.Cryptography.Certificates

#include "Windows.Security.Cryptography.Certificates.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IVector;
template<typename T> struct IVectorView;
template<typename T> struct IIterable;
}}
namespace Networking {
struct HostName;
}
namespace Storage { namespace Streams {
struct IBuffer;
struct IInputStream;
}}}

// defs

template<> struct def<Windows::Security::Cryptography::Certificates::EnrollKeyUsages> : enum_type<unsigned> {};
template<> struct def<Windows::Security::Cryptography::Certificates::KeyProtectionLevel> : enum_type<int> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ExportOption> : enum_type<int> {};
template<> struct def<Windows::Security::Cryptography::Certificates::KeySize> : enum_type<int> {};
template<> struct def<Windows::Security::Cryptography::Certificates::InstallOptions> : enum_type<unsigned> {};
template<> struct def<Windows::Security::Cryptography::Certificates::CertificateChainPolicy> : enum_type<int> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ChainValidationResult> : enum_type<int> {};
template<> struct def<Windows::Security::Cryptography::Certificates::SignatureValidationResult> : enum_type<int> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateExtension> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::CertificateExtension> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::ICertificateExtension> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateRequestProperties> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateRequestProperties2> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateFactory> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificate3> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificate2> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificate> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::Certificate> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::ICertificate, Windows::Security::Cryptography::Certificates::ICertificate2, Windows::Security::Cryptography::Certificates::ICertificate3>, custom_activators {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateRequestProperties3> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateRequestProperties4> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ISubjectAlternativeNameInfo2> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ISubjectAlternativeNameInfo> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::ISubjectAlternativeNameInfo, Windows::Security::Cryptography::Certificates::ISubjectAlternativeNameInfo2> {};
template<> struct def<Windows::Security::Cryptography::Certificates::CertificateRequestProperties> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::ICertificateRequestProperties, Windows::Security::Cryptography::Certificates::ICertificateRequestProperties2, Windows::Security::Cryptography::Certificates::ICertificateRequestProperties3, Windows::Security::Cryptography::Certificates::ICertificateRequestProperties4> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateEnrollmentManagerStatics> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateEnrollmentManagerStatics2> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::IUserCertificateEnrollmentManager2> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::IUserCertificateEnrollmentManager> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::IUserCertificateEnrollmentManager, Windows::Security::Cryptography::Certificates::IUserCertificateEnrollmentManager2> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateEnrollmentManagerStatics3> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::IPfxImportParameters> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::PfxImportParameters> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::IPfxImportParameters> {};
template<> struct def<Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Security::Cryptography::Certificates::IKeyAttestationHelperStatics> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::IKeyAttestationHelperStatics2> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::KeyAttestationHelper> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateStoresStatics> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateQuery2> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateQuery> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::CertificateQuery> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::ICertificateQuery, Windows::Security::Cryptography::Certificates::ICertificateQuery2> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateStore2> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateStore> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::CertificateStore> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::ICertificateStore, Windows::Security::Cryptography::Certificates::ICertificateStore2> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateStoresStatics2> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::IUserCertificateStore> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::UserCertificateStore> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::IUserCertificateStore> {};
template<> struct def<Windows::Security::Cryptography::Certificates::CertificateStores> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Security::Cryptography::Certificates::IStandardCertificateStoreNamesStatics> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Security::Cryptography::Certificates::IKeyAlgorithmNamesStatics> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::IKeyAlgorithmNamesStatics2> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::KeyAlgorithmNames> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Security::Cryptography::Certificates::IKeyStorageProviderNamesStatics> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::IKeyStorageProviderNamesStatics2> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::KeyStorageProviderNames> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Security::Cryptography::Certificates::IChainBuildingParameters> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ChainBuildingParameters> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::IChainBuildingParameters> {};
template<> struct def<Windows::Security::Cryptography::Certificates::IChainValidationParameters> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ChainValidationParameters> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::IChainValidationParameters> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateChain> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::CertificateChain> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::ICertificateChain> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICertificateKeyUsages> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::CertificateKeyUsages> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::ICertificateKeyUsages> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICmsTimestampInfo> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::CmsTimestampInfo> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::ICmsTimestampInfo> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICmsSignerInfo> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::CmsSignerInfo> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::ICmsSignerInfo> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICmsAttachedSignature> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICmsAttachedSignatureFactory> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICmsAttachedSignatureStatics> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::CmsAttachedSignature> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::ICmsAttachedSignature>, custom_activators {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICmsDetachedSignature> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICmsDetachedSignatureFactory> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::ICmsDetachedSignatureStatics> : interface_type<> {};
template<> struct def<Windows::Security::Cryptography::Certificates::CmsDetachedSignature> : class_type<Platform::Object, Windows::Security::Cryptography::Certificates::ICmsDetachedSignature>, custom_activators {};

// uuids

template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateExtension> { define_guid(0x84CF0656, 0xA9E6, 0x454D, 0x8E, 0x45, 0x2E, 0xA7, 0xC4, 0xBC, 0xD5, 0x3B);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateRequestProperties> { define_guid(0x487E84F6, 0x94E2, 0x4DCE, 0x88, 0x33, 0x1A, 0x70, 0xA, 0x37, 0xA2, 0x9A);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateRequestProperties2> { define_guid(0x3DA0C954, 0xD73F, 0x4FF3, 0xA0, 0xA6, 0x6, 0x77, 0xC0, 0xAD, 0xA0, 0x5B);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateFactory> { define_guid(0x17B4221C, 0x4BAF, 0x44A2, 0x96, 0x8, 0x4, 0xFB, 0x62, 0xB1, 0x69, 0x42);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificate3> { define_guid(0xBE51A966, 0xAE5F, 0x4652, 0xAC, 0xE7, 0xC6, 0xD7, 0xE7, 0x72, 0x4C, 0xF3);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificate2> { define_guid(0x17B8374C, 0x8A25, 0x4D96, 0xA4, 0x92, 0x8F, 0xC2, 0x9A, 0xC4, 0xFD, 0xA6);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificate> { define_guid(0x333F740C, 0x4D8, 0x43B3, 0xB2, 0x78, 0x8C, 0x5F, 0xCC, 0x9B, 0xE5, 0xA0);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateRequestProperties3> { define_guid(0xE687F616, 0x734D, 0x46B1, 0x9D, 0x4C, 0x6E, 0xDF, 0xDB, 0xFC, 0x84, 0x5B);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateRequestProperties4> { define_guid(0x4E429AD2, 0x1C61, 0x4FEA, 0xB8, 0xFE, 0x13, 0x5F, 0xB1, 0x9C, 0xDC, 0xE4);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ISubjectAlternativeNameInfo2> { define_guid(0x437A78C6, 0x1C51, 0x41EA, 0xB3, 0x4A, 0x3D, 0x65, 0x43, 0x98, 0xA3, 0x70);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ISubjectAlternativeNameInfo> { define_guid(0x582859F1, 0x569D, 0x4C20, 0xBE, 0x7B, 0x4E, 0x1C, 0x9A, 0xB, 0xC5, 0x2B);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateEnrollmentManagerStatics> { define_guid(0x8846EF3F, 0xA986, 0x48FB, 0x9F, 0xD7, 0x9A, 0xEC, 0x6, 0x93, 0x5B, 0xF1);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateEnrollmentManagerStatics2> { define_guid(0xDC5B1C33, 0x6429, 0x4014, 0x99, 0x9C, 0x5D, 0x97, 0x35, 0x80, 0x2D, 0x1D);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::IUserCertificateEnrollmentManager2> { define_guid(0xDAD9CB1, 0x65DE, 0x492A, 0xB8, 0x6D, 0xFC, 0x5C, 0x48, 0x2C, 0x37, 0x47);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::IUserCertificateEnrollmentManager> { define_guid(0x96313718, 0x22E1, 0x4819, 0xB2, 0xB, 0xAB, 0x46, 0xA6, 0xEC, 0xA0, 0x6E);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateEnrollmentManagerStatics3> { define_guid(0xFDEC82BE, 0x617C, 0x425A, 0xB7, 0x2D, 0x39, 0x8B, 0x26, 0xAC, 0x72, 0x64);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::IPfxImportParameters> { define_guid(0x680D3511, 0x9A08, 0x47C8, 0x86, 0x4A, 0x2E, 0xDD, 0x4D, 0x8E, 0xB4, 0x6C);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::IKeyAttestationHelperStatics> { define_guid(0x1648E246, 0xF644, 0x4326, 0x88, 0xBE, 0x3A, 0xF1, 0x2, 0xD3, 0xE, 0xC);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::IKeyAttestationHelperStatics2> { define_guid(0x9C590B2C, 0xA6C6, 0x4A5E, 0x9E, 0x64, 0xE8, 0x5D, 0x52, 0x79, 0xDF, 0x97);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateStoresStatics> { define_guid(0xFBECC739, 0xC6FE, 0x4DE7, 0x99, 0xCF, 0x74, 0xC3, 0xE5, 0x96, 0xE0, 0x32);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateQuery2> { define_guid(0x935A0AF7, 0xBD9, 0x4F75, 0xB8, 0xC2, 0xE2, 0x7A, 0x7F, 0x74, 0xEE, 0xCD);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateQuery> { define_guid(0x5B082A31, 0xA728, 0x4916, 0xB5, 0xEE, 0xFF, 0xCB, 0x8A, 0xCF, 0x24, 0x17);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateStore2> { define_guid(0xC7E68E4A, 0x417D, 0x4D1A, 0xBA, 0xBD, 0x15, 0x68, 0x7E, 0x54, 0x99, 0x74);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateStore> { define_guid(0xB0BFF720, 0x344E, 0x4331, 0xAF, 0x14, 0xA7, 0xF7, 0xA7, 0xEB, 0xC9, 0x3A);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateStoresStatics2> { define_guid(0xFA900B79, 0xA0D4, 0x4B8C, 0xBC, 0x55, 0xC0, 0xA3, 0x7E, 0xB1, 0x41, 0xED);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::IUserCertificateStore> { define_guid(0xC9FB1D83, 0x789F, 0x4B4E, 0x91, 0x80, 0x4, 0x5A, 0x75, 0x7A, 0xAC, 0x6D);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::IStandardCertificateStoreNamesStatics> { define_guid(0xC154ADB, 0xA496, 0x41F8, 0x8F, 0xE5, 0x9E, 0x96, 0xF3, 0x6E, 0xFB, 0xF8);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::IKeyAlgorithmNamesStatics> { define_guid(0x479065D7, 0x7AC7, 0x4581, 0x8C, 0x3B, 0xD0, 0x70, 0x27, 0x14, 0x4, 0x48);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::IKeyAlgorithmNamesStatics2> { define_guid(0xC99B5686, 0xE1FD, 0x4A4A, 0x89, 0x3D, 0xA2, 0x6F, 0x33, 0xDD, 0x8B, 0xB4);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::IKeyStorageProviderNamesStatics> { define_guid(0xAF186AE0, 0x5529, 0x4602, 0xBD, 0x94, 0xA, 0xAB, 0x91, 0x95, 0x7B, 0x5C);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::IKeyStorageProviderNamesStatics2> { define_guid(0x262D743D, 0x9C2E, 0x41CC, 0x88, 0x12, 0xC4, 0xD9, 0x71, 0xDD, 0x7C, 0x60);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::IChainBuildingParameters> { define_guid(0x422BA922, 0x7C8D, 0x47B7, 0xB5, 0x9B, 0xB1, 0x27, 0x3, 0x73, 0x3A, 0xC3);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::IChainValidationParameters> { define_guid(0xC4743B4A, 0x7EB0, 0x4B56, 0xA0, 0x40, 0xB9, 0xC8, 0xE6, 0x55, 0xDD, 0xF3);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateChain> { define_guid(0x20BF5385, 0x3691, 0x4501, 0xA6, 0x2C, 0xFD, 0x97, 0x27, 0x8B, 0x31, 0xEE);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICertificateKeyUsages> { define_guid(0x6AC6206F, 0xE1CF, 0x486A, 0xB4, 0x85, 0xA6, 0x9C, 0x83, 0xE4, 0x6F, 0xD1);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICmsTimestampInfo> { define_guid(0x2F5F00F2, 0x2C18, 0x4F88, 0x84, 0x35, 0xC5, 0x34, 0x8, 0x60, 0x76, 0xF5);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICmsSignerInfo> { define_guid(0x50D020DB, 0x1D2F, 0x4C1A, 0xB5, 0xC5, 0xD0, 0x18, 0x8F, 0xF9, 0x1F, 0x47);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICmsAttachedSignature> { define_guid(0x61899D9D, 0x3757, 0x4ECB, 0xBD, 0xDC, 0xC, 0xA3, 0x57, 0xD7, 0xA9, 0x36);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICmsAttachedSignatureFactory> { define_guid(0xD0C8FC15, 0xF757, 0x4C64, 0xA3, 0x62, 0x52, 0xCC, 0x1C, 0x77, 0xCF, 0xFB);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICmsAttachedSignatureStatics> { define_guid(0x87989C8E, 0xB0AD, 0x498D, 0xA7, 0xF5, 0x78, 0xB5, 0x9B, 0xCE, 0x4B, 0x36);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICmsDetachedSignature> { define_guid(0xF1EF154, 0xF65E, 0x4536, 0x83, 0x39, 0x59, 0x44, 0x8, 0x1D, 0xB2, 0xCA);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICmsDetachedSignatureFactory> { define_guid(0xC4AB3503, 0xAE7F, 0x4387, 0xAD, 0x19, 0x0, 0xF1, 0x50, 0xE4, 0x8E, 0xBB);};
template<> struct uuid<Windows::Security::Cryptography::Certificates::ICmsDetachedSignatureStatics> { define_guid(0x3D114CFD, 0xBF9B, 0x4682, 0x9B, 0xE6, 0x91, 0xF5, 0x7C, 0x5, 0x38, 0x8);};

// types

namespace Windows { namespace Security { namespace Cryptography { namespace Certificates {

// ICertificateExtension
struct ICertificateExtension_raw : IInspectable {
	virtual STDMETHODIMP _get_ObjectId(HSTRING *value);
	virtual STDMETHODIMP _put_ObjectId(HSTRING value);
	virtual STDMETHODIMP _get_IsCritical(bool *value);
	virtual STDMETHODIMP _put_IsCritical(bool value);
	virtual STDMETHODIMP _EncodeValue(HSTRING value);
	virtual STDMETHODIMP _get_Value(unsigned *valueSize, unsigned char **value);
	virtual STDMETHODIMP _put_Value(unsigned valueSize, unsigned char *value);
};
template<typename X> struct ICertificateExtension_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificateExtension_adaptor::IsCritical)->_get_IsCritical(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICertificateExtension_adaptor::IsCritical)->_put_IsCritical(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsCritical;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificateExtension_adaptor::ObjectId)->_get_ObjectId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICertificateExtension_adaptor::ObjectId)->_put_ObjectId(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ObjectId;
		struct : property {
			szarray<unsigned char> get() { szarray<unsigned char> value; hrcheck(enc(&ICertificateExtension_adaptor::Value)->_get_Value(&value.size, &value.p)); return value; }
			szarray<unsigned char> operator()() { return get(); }
			operator szarray<unsigned char> () { return get(); }
			void put(const szarray<unsigned char>& value) { hrcheck(enc(&ICertificateExtension_adaptor::Value)->_put_Value(value.size, to_abi(value.p))); }
			void operator=(const szarray<unsigned char>& value) { put(value); }
			void operator()(const szarray<unsigned char>& value) { put(value); }
		} Value;
	};
	void EncodeValue(hstring_ref value) { hrcheck(X::get()->_EncodeValue(value)); }
	ICertificateExtension_adaptor() {}
};
template<typename X> struct adapt<ICertificateExtension, X> : Windows::Security::Cryptography::Certificates::ICertificateExtension_adaptor<X> { typedef adapt ICertificateExtension; };
struct ICertificateExtension : ICertificateExtension_raw, generate<ICertificateExtension> {};

// CertificateExtension
template<typename X> struct statics<CertificateExtension, X> : X {
	typedef typename X::root_type CertificateExtension;
};
struct CertificateExtension : generate<CertificateExtension> {};

// ICertificateRequestProperties
struct ICertificateRequestProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_Subject(HSTRING *value);
	virtual STDMETHODIMP _put_Subject(HSTRING value);
	virtual STDMETHODIMP _get_KeyAlgorithmName(HSTRING *value);
	virtual STDMETHODIMP _put_KeyAlgorithmName(HSTRING value);
	virtual STDMETHODIMP _get_KeySize(unsigned *value);
	virtual STDMETHODIMP _put_KeySize(unsigned value);
	virtual STDMETHODIMP _get_FriendlyName(HSTRING *value);
	virtual STDMETHODIMP _put_FriendlyName(HSTRING value);
	virtual STDMETHODIMP _get_HashAlgorithmName(HSTRING *value);
	virtual STDMETHODIMP _put_HashAlgorithmName(HSTRING value);
	virtual STDMETHODIMP _get_Exportable(ExportOption *value);
	virtual STDMETHODIMP _put_Exportable(ExportOption value);
	virtual STDMETHODIMP _get_KeyUsages(EnrollKeyUsages *value);
	virtual STDMETHODIMP _put_KeyUsages(EnrollKeyUsages value);
	virtual STDMETHODIMP _get_KeyProtectionLevel(Certificates::KeyProtectionLevel *value);
	virtual STDMETHODIMP _put_KeyProtectionLevel(Certificates::KeyProtectionLevel value);
	virtual STDMETHODIMP _get_KeyStorageProviderName(HSTRING *value);
	virtual STDMETHODIMP _put_KeyStorageProviderName(HSTRING value);
};
template<typename X> struct ICertificateRequestProperties_adaptor : X {
	union {
		struct : property {
			ExportOption get() { ExportOption value; hrcheck(enc(&ICertificateRequestProperties_adaptor::Exportable)->_get_Exportable(&value)); return value; }
			ExportOption operator()() { return get(); }
			operator ExportOption () { return get(); }
			void put(ExportOption value) { hrcheck(enc(&ICertificateRequestProperties_adaptor::Exportable)->_put_Exportable(value)); }
			void operator=(ExportOption value) { put(value); }
			void operator()(ExportOption value) { put(value); }
		} Exportable;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificateRequestProperties_adaptor::FriendlyName)->_get_FriendlyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICertificateRequestProperties_adaptor::FriendlyName)->_put_FriendlyName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} FriendlyName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificateRequestProperties_adaptor::HashAlgorithmName)->_get_HashAlgorithmName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICertificateRequestProperties_adaptor::HashAlgorithmName)->_put_HashAlgorithmName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} HashAlgorithmName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificateRequestProperties_adaptor::KeyAlgorithmName)->_get_KeyAlgorithmName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICertificateRequestProperties_adaptor::KeyAlgorithmName)->_put_KeyAlgorithmName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} KeyAlgorithmName;
		struct : property {
			Certificates::KeyProtectionLevel get() { Certificates::KeyProtectionLevel value; hrcheck(enc(&ICertificateRequestProperties_adaptor::KeyProtectionLevel)->_get_KeyProtectionLevel(&value)); return value; }
			Certificates::KeyProtectionLevel operator()() { return get(); }
			operator Certificates::KeyProtectionLevel () { return get(); }
			void put(Certificates::KeyProtectionLevel value) { hrcheck(enc(&ICertificateRequestProperties_adaptor::KeyProtectionLevel)->_put_KeyProtectionLevel(value)); }
			void operator=(Certificates::KeyProtectionLevel value) { put(value); }
			void operator()(Certificates::KeyProtectionLevel value) { put(value); }
		} KeyProtectionLevel;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&ICertificateRequestProperties_adaptor::KeySize)->_get_KeySize(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&ICertificateRequestProperties_adaptor::KeySize)->_put_KeySize(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} KeySize;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificateRequestProperties_adaptor::KeyStorageProviderName)->_get_KeyStorageProviderName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICertificateRequestProperties_adaptor::KeyStorageProviderName)->_put_KeyStorageProviderName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} KeyStorageProviderName;
		struct : property {
			EnrollKeyUsages get() { EnrollKeyUsages value; hrcheck(enc(&ICertificateRequestProperties_adaptor::KeyUsages)->_get_KeyUsages(&value)); return value; }
			EnrollKeyUsages operator()() { return get(); }
			operator EnrollKeyUsages () { return get(); }
			void put(EnrollKeyUsages value) { hrcheck(enc(&ICertificateRequestProperties_adaptor::KeyUsages)->_put_KeyUsages(value)); }
			void operator=(EnrollKeyUsages value) { put(value); }
			void operator()(EnrollKeyUsages value) { put(value); }
		} KeyUsages;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificateRequestProperties_adaptor::Subject)->_get_Subject(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICertificateRequestProperties_adaptor::Subject)->_put_Subject(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Subject;
	};
	ICertificateRequestProperties_adaptor() {}
};
template<typename X> struct adapt<ICertificateRequestProperties, X> : Windows::Security::Cryptography::Certificates::ICertificateRequestProperties_adaptor<X> { typedef adapt ICertificateRequestProperties; };
struct ICertificateRequestProperties : ICertificateRequestProperties_raw, generate<ICertificateRequestProperties> {};

// ICertificateRequestProperties2
struct ICertificateRequestProperties2_raw : IInspectable {
	virtual STDMETHODIMP _get_SmartcardReaderName(HSTRING *value);
	virtual STDMETHODIMP _put_SmartcardReaderName(HSTRING value);
	virtual STDMETHODIMP _get_SigningCertificate(Certificate* *value);
	virtual STDMETHODIMP _put_SigningCertificate(Certificate* value);
	virtual STDMETHODIMP _get_AttestationCredentialCertificate(Certificate* *value);
	virtual STDMETHODIMP _put_AttestationCredentialCertificate(Certificate* value);
};
template<typename X> struct ICertificateRequestProperties2_adaptor : X {
	union {
		struct : property {
			ptr<Certificate> get() { Certificate* value; hrcheck(enc(&ICertificateRequestProperties2_adaptor::AttestationCredentialCertificate)->_get_AttestationCredentialCertificate(&value)); return from_abi(value); }
			ptr<Certificate> operator()() { return get(); }
			operator ptr<Certificate> () { return get(); }
			ptr<Certificate> operator->() { return get(); }
			void put(pptr<Certificate> value) { hrcheck(enc(&ICertificateRequestProperties2_adaptor::AttestationCredentialCertificate)->_put_AttestationCredentialCertificate(value)); }
			void operator=(pptr<Certificate> value) { put(value); }
			void operator()(pptr<Certificate> value) { put(value); }
		} AttestationCredentialCertificate;
		struct : property {
			ptr<Certificate> get() { Certificate* value; hrcheck(enc(&ICertificateRequestProperties2_adaptor::SigningCertificate)->_get_SigningCertificate(&value)); return from_abi(value); }
			ptr<Certificate> operator()() { return get(); }
			operator ptr<Certificate> () { return get(); }
			ptr<Certificate> operator->() { return get(); }
			void put(pptr<Certificate> value) { hrcheck(enc(&ICertificateRequestProperties2_adaptor::SigningCertificate)->_put_SigningCertificate(value)); }
			void operator=(pptr<Certificate> value) { put(value); }
			void operator()(pptr<Certificate> value) { put(value); }
		} SigningCertificate;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificateRequestProperties2_adaptor::SmartcardReaderName)->_get_SmartcardReaderName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICertificateRequestProperties2_adaptor::SmartcardReaderName)->_put_SmartcardReaderName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} SmartcardReaderName;
	};
	ICertificateRequestProperties2_adaptor() {}
};
template<typename X> struct adapt<ICertificateRequestProperties2, X> : Windows::Security::Cryptography::Certificates::ICertificateRequestProperties2_adaptor<X> { typedef adapt ICertificateRequestProperties2; };
struct ICertificateRequestProperties2 : ICertificateRequestProperties2_raw, generate<ICertificateRequestProperties2> {};

// ICertificateFactory
struct ICertificateFactory : IInspectable {
	virtual STDMETHODIMP _CreateCertificate(Storage::Streams::IBuffer* certBlob, Certificate* *certificate);
};

// ICertificate3
struct ICertificate3_raw : IInspectable {
	virtual STDMETHODIMP _get_IsPerUser(bool *value);
	virtual STDMETHODIMP _get_StoreName(HSTRING *value);
	virtual STDMETHODIMP _get_KeyStorageProviderName(HSTRING *value);
};
template<typename X> struct ICertificate3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificate3_adaptor::IsPerUser)->_get_IsPerUser(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsPerUser;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificate3_adaptor::KeyStorageProviderName)->_get_KeyStorageProviderName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} KeyStorageProviderName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificate3_adaptor::StoreName)->_get_StoreName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} StoreName;
	};
	ICertificate3_adaptor() {}
};
template<typename X> struct adapt<ICertificate3, X> : Windows::Security::Cryptography::Certificates::ICertificate3_adaptor<X> { typedef adapt ICertificate3; };
struct ICertificate3 : ICertificate3_raw, generate<ICertificate3> {};

// ICertificate2
struct ICertificate2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsSecurityDeviceBound(bool *value);
	virtual STDMETHODIMP _get_KeyUsages(CertificateKeyUsages* *value);
	virtual STDMETHODIMP _get_KeyAlgorithmName(HSTRING *value);
	virtual STDMETHODIMP _get_SignatureAlgorithmName(HSTRING *value);
	virtual STDMETHODIMP _get_SignatureHashAlgorithmName(HSTRING *value);
	virtual STDMETHODIMP _get_SubjectAlternativeName(SubjectAlternativeNameInfo* *value);
};
template<typename X> struct ICertificate2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificate2_adaptor::IsSecurityDeviceBound)->_get_IsSecurityDeviceBound(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsSecurityDeviceBound;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificate2_adaptor::KeyAlgorithmName)->_get_KeyAlgorithmName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} KeyAlgorithmName;
		struct : property {
			ptr<CertificateKeyUsages> get() { CertificateKeyUsages* value; hrcheck(enc(&ICertificate2_adaptor::KeyUsages)->_get_KeyUsages(&value)); return from_abi(value); }
			ptr<CertificateKeyUsages> operator()() { return get(); }
			operator ptr<CertificateKeyUsages> () { return get(); }
			ptr<CertificateKeyUsages> operator->() { return get(); }
		} KeyUsages;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificate2_adaptor::SignatureAlgorithmName)->_get_SignatureAlgorithmName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} SignatureAlgorithmName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificate2_adaptor::SignatureHashAlgorithmName)->_get_SignatureHashAlgorithmName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} SignatureHashAlgorithmName;
		struct : property {
			ptr<SubjectAlternativeNameInfo> get() { SubjectAlternativeNameInfo* value; hrcheck(enc(&ICertificate2_adaptor::SubjectAlternativeName)->_get_SubjectAlternativeName(&value)); return from_abi(value); }
			ptr<SubjectAlternativeNameInfo> operator()() { return get(); }
			operator ptr<SubjectAlternativeNameInfo> () { return get(); }
			ptr<SubjectAlternativeNameInfo> operator->() { return get(); }
		} SubjectAlternativeName;
	};
	ICertificate2_adaptor() {}
};
template<typename X> struct adapt<ICertificate2, X> : Windows::Security::Cryptography::Certificates::ICertificate2_adaptor<X> { typedef adapt ICertificate2; };
struct ICertificate2 : ICertificate2_raw, generate<ICertificate2> {};

// ICertificate
struct ICertificate_raw : IInspectable {
	virtual STDMETHODIMP _BuildChainAsync(Foundation::Collections::IIterable<Certificate*>* certificates, Foundation::IAsyncOperation<CertificateChain*>* *value);
	virtual STDMETHODIMP _BuildChainWithParametersAsync(Foundation::Collections::IIterable<Certificate*>* certificates, ChainBuildingParameters* parameters, Foundation::IAsyncOperation<CertificateChain*>* *value);
	virtual STDMETHODIMP _get_SerialNumber(unsigned *valueSize, unsigned char **value);
	virtual STDMETHODIMP _GetHashValue(unsigned *valueSize, unsigned char **value);
	virtual STDMETHODIMP _GetHashValueWithAlgorithm(HSTRING hashAlgorithmName, unsigned *valueSize, unsigned char **value);
	virtual STDMETHODIMP _GetCertificateBlob(Storage::Streams::IBuffer* *value);
	virtual STDMETHODIMP _get_Subject(HSTRING *value);
	virtual STDMETHODIMP _get_Issuer(HSTRING *value);
	virtual STDMETHODIMP _get_HasPrivateKey(bool *value);
	virtual STDMETHODIMP _get_IsStronglyProtected(bool *value);
	virtual STDMETHODIMP _get_ValidFrom(Foundation::DateTime *value);
	virtual STDMETHODIMP _get_ValidTo(Foundation::DateTime *value);
	virtual STDMETHODIMP _get_EnhancedKeyUsages(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _put_FriendlyName(HSTRING value);
	virtual STDMETHODIMP _get_FriendlyName(HSTRING *value);
};
template<typename X> struct ICertificate_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&ICertificate_adaptor::EnhancedKeyUsages)->_get_EnhancedKeyUsages(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} EnhancedKeyUsages;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificate_adaptor::FriendlyName)->_get_FriendlyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICertificate_adaptor::FriendlyName)->_put_FriendlyName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} FriendlyName;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificate_adaptor::HasPrivateKey)->_get_HasPrivateKey(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasPrivateKey;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificate_adaptor::IsStronglyProtected)->_get_IsStronglyProtected(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsStronglyProtected;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificate_adaptor::Issuer)->_get_Issuer(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Issuer;
		struct : property {
			szarray<unsigned char> get() { szarray<unsigned char> value; hrcheck(enc(&ICertificate_adaptor::SerialNumber)->_get_SerialNumber(&value.size, &value.p)); return value; }
			szarray<unsigned char> operator()() { return get(); }
			operator szarray<unsigned char> () { return get(); }
		} SerialNumber;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificate_adaptor::Subject)->_get_Subject(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Subject;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&ICertificate_adaptor::ValidFrom)->_get_ValidFrom(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} ValidFrom;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&ICertificate_adaptor::ValidTo)->_get_ValidTo(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} ValidTo;
	};
	ptr<Foundation::IAsyncOperation<ptr<CertificateChain>>> BuildChainAsync(pptr<Foundation::Collections::IIterable<ptr<Certificate>>> certificates) { Foundation::IAsyncOperation<CertificateChain*>* value; hrcheck(X::get()->_BuildChainAsync(to_abi(certificates), &value)); return from_abi(value); }
	ptr<Foundation::IAsyncOperation<ptr<CertificateChain>>> BuildChainAsync(pptr<Foundation::Collections::IIterable<ptr<Certificate>>> certificates, pptr<ChainBuildingParameters> parameters) { Foundation::IAsyncOperation<CertificateChain*>* value; hrcheck(X::get()->_BuildChainWithParametersAsync(to_abi(certificates), parameters, &value)); return from_abi(value); }
	szarray<unsigned char> GetHashValue() { szarray<unsigned char> value; hrcheck(X::get()->_GetHashValue(&value.size, &value.p)); return value; }
	szarray<unsigned char> GetHashValue(hstring_ref hashAlgorithmName) { szarray<unsigned char> value; hrcheck(X::get()->_GetHashValueWithAlgorithm(hashAlgorithmName, &value.size, &value.p)); return value; }
	ptr<Storage::Streams::IBuffer> GetCertificateBlob() { Storage::Streams::IBuffer* value; hrcheck(X::get()->_GetCertificateBlob(&value)); return from_abi(value); }
	ICertificate_adaptor() {}
};
template<typename X> struct adapt<ICertificate, X> : Windows::Security::Cryptography::Certificates::ICertificate_adaptor<X> { typedef adapt ICertificate; };
struct ICertificate : ICertificate_raw, generate<ICertificate> {};

// Certificate
template<typename> struct Certificate_statics {
	static Certificate *activate(pptr<Storage::Streams::IBuffer> certBlob) { Certificate *certificate; hrcheck(get_activation_factory<Certificate, ICertificateFactory>()->_CreateCertificate(certBlob, &certificate)); return certificate; }
};

template<typename X> struct statics<Certificate, X> : X, Windows::Security::Cryptography::Certificates::Certificate_statics<void> {
	using Windows::Security::Cryptography::Certificates::Certificate_statics<void>::activate;
	typedef typename X::root_type Certificate;
};
struct Certificate : generate<Certificate> {
	using ICertificate::BuildChainAsync;
	using ICertificate::GetHashValue;
};

// ICertificateRequestProperties3
struct ICertificateRequestProperties3_raw : IInspectable {
	virtual STDMETHODIMP _get_CurveName(HSTRING *value);
	virtual STDMETHODIMP _put_CurveName(HSTRING value);
	virtual STDMETHODIMP _get_CurveParameters(unsigned *valueSize, unsigned char **value);
	virtual STDMETHODIMP _put_CurveParameters(unsigned valueSize, unsigned char *value);
	virtual STDMETHODIMP _get_ContainerNamePrefix(HSTRING *value);
	virtual STDMETHODIMP _put_ContainerNamePrefix(HSTRING value);
	virtual STDMETHODIMP _get_ContainerName(HSTRING *value);
	virtual STDMETHODIMP _put_ContainerName(HSTRING value);
	virtual STDMETHODIMP _get_UseExistingKey(bool *value);
	virtual STDMETHODIMP _put_UseExistingKey(bool value);
};
template<typename X> struct ICertificateRequestProperties3_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificateRequestProperties3_adaptor::ContainerName)->_get_ContainerName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICertificateRequestProperties3_adaptor::ContainerName)->_put_ContainerName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ContainerName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificateRequestProperties3_adaptor::ContainerNamePrefix)->_get_ContainerNamePrefix(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICertificateRequestProperties3_adaptor::ContainerNamePrefix)->_put_ContainerNamePrefix(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ContainerNamePrefix;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificateRequestProperties3_adaptor::CurveName)->_get_CurveName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICertificateRequestProperties3_adaptor::CurveName)->_put_CurveName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} CurveName;
		struct : property {
			szarray<unsigned char> get() { szarray<unsigned char> value; hrcheck(enc(&ICertificateRequestProperties3_adaptor::CurveParameters)->_get_CurveParameters(&value.size, &value.p)); return value; }
			szarray<unsigned char> operator()() { return get(); }
			operator szarray<unsigned char> () { return get(); }
			void put(const szarray<unsigned char>& value) { hrcheck(enc(&ICertificateRequestProperties3_adaptor::CurveParameters)->_put_CurveParameters(value.size, to_abi(value.p))); }
			void operator=(const szarray<unsigned char>& value) { put(value); }
			void operator()(const szarray<unsigned char>& value) { put(value); }
		} CurveParameters;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificateRequestProperties3_adaptor::UseExistingKey)->_get_UseExistingKey(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICertificateRequestProperties3_adaptor::UseExistingKey)->_put_UseExistingKey(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} UseExistingKey;
	};
	ICertificateRequestProperties3_adaptor() {}
};
template<typename X> struct adapt<ICertificateRequestProperties3, X> : Windows::Security::Cryptography::Certificates::ICertificateRequestProperties3_adaptor<X> { typedef adapt ICertificateRequestProperties3; };
struct ICertificateRequestProperties3 : ICertificateRequestProperties3_raw, generate<ICertificateRequestProperties3> {};

// ICertificateRequestProperties4
struct ICertificateRequestProperties4_raw : IInspectable {
	virtual STDMETHODIMP _get_SuppressedDefaults(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_SubjectAlternativeName(SubjectAlternativeNameInfo* *value);
	virtual STDMETHODIMP _get_Extensions(Foundation::Collections::IVector<CertificateExtension*>* *value);
};
template<typename X> struct ICertificateRequestProperties4_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<CertificateExtension>>> get() { Foundation::Collections::IVector<CertificateExtension*>* value; hrcheck(enc(&ICertificateRequestProperties4_adaptor::Extensions)->_get_Extensions(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<CertificateExtension>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<CertificateExtension>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<CertificateExtension>>> operator->() { return get(); }
		} Extensions;
		struct : property {
			ptr<SubjectAlternativeNameInfo> get() { SubjectAlternativeNameInfo* value; hrcheck(enc(&ICertificateRequestProperties4_adaptor::SubjectAlternativeName)->_get_SubjectAlternativeName(&value)); return from_abi(value); }
			ptr<SubjectAlternativeNameInfo> operator()() { return get(); }
			operator ptr<SubjectAlternativeNameInfo> () { return get(); }
			ptr<SubjectAlternativeNameInfo> operator->() { return get(); }
		} SubjectAlternativeName;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&ICertificateRequestProperties4_adaptor::SuppressedDefaults)->_get_SuppressedDefaults(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} SuppressedDefaults;
	};
	ICertificateRequestProperties4_adaptor() {}
};
template<typename X> struct adapt<ICertificateRequestProperties4, X> : Windows::Security::Cryptography::Certificates::ICertificateRequestProperties4_adaptor<X> { typedef adapt ICertificateRequestProperties4; };
struct ICertificateRequestProperties4 : ICertificateRequestProperties4_raw, generate<ICertificateRequestProperties4> {};

// ISubjectAlternativeNameInfo2
struct ISubjectAlternativeNameInfo2_raw : IInspectable {
	virtual STDMETHODIMP _get_EmailNames(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_IPAddresses(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_Urls(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_DnsNames(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_DistinguishedNames(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_PrincipalNames(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_Extension(CertificateExtension* *value);
};
template<typename X> struct ISubjectAlternativeNameInfo2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&ISubjectAlternativeNameInfo2_adaptor::DistinguishedNames)->_get_DistinguishedNames(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} DistinguishedNames;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&ISubjectAlternativeNameInfo2_adaptor::DnsNames)->_get_DnsNames(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} DnsNames;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&ISubjectAlternativeNameInfo2_adaptor::EmailNames)->_get_EmailNames(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} EmailNames;
		struct : property {
			ptr<CertificateExtension> get() { CertificateExtension* value; hrcheck(enc(&ISubjectAlternativeNameInfo2_adaptor::Extension)->_get_Extension(&value)); return from_abi(value); }
			ptr<CertificateExtension> operator()() { return get(); }
			operator ptr<CertificateExtension> () { return get(); }
			ptr<CertificateExtension> operator->() { return get(); }
		} Extension;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&ISubjectAlternativeNameInfo2_adaptor::IPAddresses)->_get_IPAddresses(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} IPAddresses;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&ISubjectAlternativeNameInfo2_adaptor::PrincipalNames)->_get_PrincipalNames(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} PrincipalNames;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&ISubjectAlternativeNameInfo2_adaptor::Urls)->_get_Urls(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} Urls;
	};
	ISubjectAlternativeNameInfo2_adaptor() {}
};
template<typename X> struct adapt<ISubjectAlternativeNameInfo2, X> : Windows::Security::Cryptography::Certificates::ISubjectAlternativeNameInfo2_adaptor<X> { typedef adapt ISubjectAlternativeNameInfo2; };
struct ISubjectAlternativeNameInfo2 : ISubjectAlternativeNameInfo2_raw, generate<ISubjectAlternativeNameInfo2> {};

// ISubjectAlternativeNameInfo
struct ISubjectAlternativeNameInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_EmailName(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _get_IPAddress(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _get_Url(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _get_DnsName(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _get_DistinguishedName(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _get_PrincipalName(Foundation::Collections::IVectorView<HSTRING>* *value);
};
template<typename X> struct ISubjectAlternativeNameInfo_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&ISubjectAlternativeNameInfo_adaptor::DistinguishedName)->_get_DistinguishedName(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} DistinguishedName;
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&ISubjectAlternativeNameInfo_adaptor::DnsName)->_get_DnsName(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} DnsName;
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&ISubjectAlternativeNameInfo_adaptor::EmailName)->_get_EmailName(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} EmailName;
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&ISubjectAlternativeNameInfo_adaptor::IPAddress)->_get_IPAddress(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} IPAddress;
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&ISubjectAlternativeNameInfo_adaptor::PrincipalName)->_get_PrincipalName(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} PrincipalName;
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&ISubjectAlternativeNameInfo_adaptor::Url)->_get_Url(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} Url;
	};
	ISubjectAlternativeNameInfo_adaptor() {}
};
template<typename X> struct adapt<ISubjectAlternativeNameInfo, X> : Windows::Security::Cryptography::Certificates::ISubjectAlternativeNameInfo_adaptor<X> { typedef adapt ISubjectAlternativeNameInfo; };
struct ISubjectAlternativeNameInfo : ISubjectAlternativeNameInfo_raw, generate<ISubjectAlternativeNameInfo> {};

// SubjectAlternativeNameInfo
template<typename X> struct statics<SubjectAlternativeNameInfo, X> : X {
	typedef typename X::root_type SubjectAlternativeNameInfo;
};
struct SubjectAlternativeNameInfo : generate<SubjectAlternativeNameInfo> {};

// CertificateRequestProperties
template<typename X> struct statics<CertificateRequestProperties, X> : X {
	typedef typename X::root_type CertificateRequestProperties;
};
struct CertificateRequestProperties : generate<CertificateRequestProperties> {};

// ICertificateEnrollmentManagerStatics
struct ICertificateEnrollmentManagerStatics : IInspectable {
	virtual STDMETHODIMP _CreateRequestAsync(CertificateRequestProperties* request, Foundation::IAsyncOperation<HSTRING>* *value);
	virtual STDMETHODIMP _InstallCertificateAsync(HSTRING certificate, InstallOptions installOption, Foundation::IAsyncAction* *value);
	virtual STDMETHODIMP _ImportPfxDataAsync(HSTRING pfxData, HSTRING password, ExportOption exportable, KeyProtectionLevel keyProtectionLevel, InstallOptions installOption, HSTRING friendlyName, Foundation::IAsyncAction* *value);
};

// ICertificateEnrollmentManagerStatics2
struct ICertificateEnrollmentManagerStatics2 : IInspectable {
	virtual STDMETHODIMP _get_UserCertificateEnrollmentManager(Certificates::UserCertificateEnrollmentManager* *value);
	virtual STDMETHODIMP _ImportPfxDataToKspAsync(HSTRING pfxData, HSTRING password, ExportOption exportable, KeyProtectionLevel keyProtectionLevel, InstallOptions installOption, HSTRING friendlyName, HSTRING keyStorageProvider, Foundation::IAsyncAction* *value);
};

// IUserCertificateEnrollmentManager2
struct IUserCertificateEnrollmentManager2_raw : IInspectable {
	virtual STDMETHODIMP _ImportPfxDataToKspWithParametersAsync(HSTRING pfxData, HSTRING password, PfxImportParameters* pfxImportParameters, Foundation::IAsyncAction* *value);
};
template<typename X> struct IUserCertificateEnrollmentManager2_adaptor : X {
	ptr<Foundation::IAsyncAction> ImportPfxDataAsync(hstring_ref pfxData, hstring_ref password, pptr<PfxImportParameters> pfxImportParameters) { Foundation::IAsyncAction* value; hrcheck(X::get()->_ImportPfxDataToKspWithParametersAsync(pfxData, password, pfxImportParameters, &value)); return from_abi(value); }
};
template<typename X> struct adapt<IUserCertificateEnrollmentManager2, X> : Windows::Security::Cryptography::Certificates::IUserCertificateEnrollmentManager2_adaptor<X> { typedef adapt IUserCertificateEnrollmentManager2; };
struct IUserCertificateEnrollmentManager2 : IUserCertificateEnrollmentManager2_raw, generate<IUserCertificateEnrollmentManager2> {};

// IUserCertificateEnrollmentManager
struct IUserCertificateEnrollmentManager_raw : IInspectable {
	virtual STDMETHODIMP _CreateRequestAsync(CertificateRequestProperties* request, Foundation::IAsyncOperation<HSTRING>* *value);
	virtual STDMETHODIMP _InstallCertificateAsync(HSTRING certificate, InstallOptions installOption, Foundation::IAsyncAction* *value);
	virtual STDMETHODIMP _ImportPfxDataAsync(HSTRING pfxData, HSTRING password, ExportOption exportable, KeyProtectionLevel keyProtectionLevel, InstallOptions installOption, HSTRING friendlyName, Foundation::IAsyncAction* *value);
	virtual STDMETHODIMP _ImportPfxDataToKspAsync(HSTRING pfxData, HSTRING password, ExportOption exportable, KeyProtectionLevel keyProtectionLevel, InstallOptions installOption, HSTRING friendlyName, HSTRING keyStorageProvider, Foundation::IAsyncAction* *value);
};
template<typename X> struct IUserCertificateEnrollmentManager_adaptor : X {
	ptr<Foundation::IAsyncOperation<hstring>> CreateRequestAsync(pptr<CertificateRequestProperties> request) { Foundation::IAsyncOperation<HSTRING>* value; hrcheck(X::get()->_CreateRequestAsync(request, &value)); return from_abi(value); }
	ptr<Foundation::IAsyncAction> InstallCertificateAsync(hstring_ref certificate, InstallOptions installOption) { Foundation::IAsyncAction* value; hrcheck(X::get()->_InstallCertificateAsync(certificate, installOption, &value)); return from_abi(value); }
	ptr<Foundation::IAsyncAction> ImportPfxDataAsync(hstring_ref pfxData, hstring_ref password, ExportOption exportable, KeyProtectionLevel keyProtectionLevel, InstallOptions installOption, hstring_ref friendlyName) { Foundation::IAsyncAction* value; hrcheck(X::get()->_ImportPfxDataAsync(pfxData, password, exportable, keyProtectionLevel, installOption, friendlyName, &value)); return from_abi(value); }
	ptr<Foundation::IAsyncAction> ImportPfxDataAsync(hstring_ref pfxData, hstring_ref password, ExportOption exportable, KeyProtectionLevel keyProtectionLevel, InstallOptions installOption, hstring_ref friendlyName, hstring_ref keyStorageProvider) { Foundation::IAsyncAction* value; hrcheck(X::get()->_ImportPfxDataToKspAsync(pfxData, password, exportable, keyProtectionLevel, installOption, friendlyName, keyStorageProvider, &value)); return from_abi(value); }
};
template<typename X> struct adapt<IUserCertificateEnrollmentManager, X> : Windows::Security::Cryptography::Certificates::IUserCertificateEnrollmentManager_adaptor<X> { typedef adapt IUserCertificateEnrollmentManager; };
struct IUserCertificateEnrollmentManager : IUserCertificateEnrollmentManager_raw, generate<IUserCertificateEnrollmentManager> {};

// UserCertificateEnrollmentManager
template<typename X> struct statics<UserCertificateEnrollmentManager, X> : X {
	typedef typename X::root_type UserCertificateEnrollmentManager;
};
struct UserCertificateEnrollmentManager : generate<UserCertificateEnrollmentManager> {
	using IUserCertificateEnrollmentManager::ImportPfxDataAsync;
	using IUserCertificateEnrollmentManager2::ImportPfxDataAsync;
};

// ICertificateEnrollmentManagerStatics3
struct ICertificateEnrollmentManagerStatics3 : IInspectable {
	virtual STDMETHODIMP _ImportPfxDataToKspWithParametersAsync(HSTRING pfxData, HSTRING password, PfxImportParameters* pfxImportParameters, Foundation::IAsyncAction* *value);
};

// IPfxImportParameters
struct IPfxImportParameters_raw : IInspectable {
	virtual STDMETHODIMP _get_Exportable(ExportOption *value);
	virtual STDMETHODIMP _put_Exportable(ExportOption value);
	virtual STDMETHODIMP _get_KeyProtectionLevel(Certificates::KeyProtectionLevel *value);
	virtual STDMETHODIMP _put_KeyProtectionLevel(Certificates::KeyProtectionLevel value);
	virtual STDMETHODIMP _get_InstallOptions(Certificates::InstallOptions *value);
	virtual STDMETHODIMP _put_InstallOptions(Certificates::InstallOptions value);
	virtual STDMETHODIMP _get_FriendlyName(HSTRING *value);
	virtual STDMETHODIMP _put_FriendlyName(HSTRING value);
	virtual STDMETHODIMP _get_KeyStorageProviderName(HSTRING *value);
	virtual STDMETHODIMP _put_KeyStorageProviderName(HSTRING value);
	virtual STDMETHODIMP _get_ContainerNamePrefix(HSTRING *value);
	virtual STDMETHODIMP _put_ContainerNamePrefix(HSTRING value);
	virtual STDMETHODIMP _get_ReaderName(HSTRING *value);
	virtual STDMETHODIMP _put_ReaderName(HSTRING value);
};
template<typename X> struct IPfxImportParameters_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPfxImportParameters_adaptor::ContainerNamePrefix)->_get_ContainerNamePrefix(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPfxImportParameters_adaptor::ContainerNamePrefix)->_put_ContainerNamePrefix(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ContainerNamePrefix;
		struct : property {
			ExportOption get() { ExportOption value; hrcheck(enc(&IPfxImportParameters_adaptor::Exportable)->_get_Exportable(&value)); return value; }
			ExportOption operator()() { return get(); }
			operator ExportOption () { return get(); }
			void put(ExportOption value) { hrcheck(enc(&IPfxImportParameters_adaptor::Exportable)->_put_Exportable(value)); }
			void operator=(ExportOption value) { put(value); }
			void operator()(ExportOption value) { put(value); }
		} Exportable;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPfxImportParameters_adaptor::FriendlyName)->_get_FriendlyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPfxImportParameters_adaptor::FriendlyName)->_put_FriendlyName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} FriendlyName;
		struct : property {
			Certificates::InstallOptions get() { Certificates::InstallOptions value; hrcheck(enc(&IPfxImportParameters_adaptor::InstallOptions)->_get_InstallOptions(&value)); return value; }
			Certificates::InstallOptions operator()() { return get(); }
			operator Certificates::InstallOptions () { return get(); }
			void put(Certificates::InstallOptions value) { hrcheck(enc(&IPfxImportParameters_adaptor::InstallOptions)->_put_InstallOptions(value)); }
			void operator=(Certificates::InstallOptions value) { put(value); }
			void operator()(Certificates::InstallOptions value) { put(value); }
		} InstallOptions;
		struct : property {
			Certificates::KeyProtectionLevel get() { Certificates::KeyProtectionLevel value; hrcheck(enc(&IPfxImportParameters_adaptor::KeyProtectionLevel)->_get_KeyProtectionLevel(&value)); return value; }
			Certificates::KeyProtectionLevel operator()() { return get(); }
			operator Certificates::KeyProtectionLevel () { return get(); }
			void put(Certificates::KeyProtectionLevel value) { hrcheck(enc(&IPfxImportParameters_adaptor::KeyProtectionLevel)->_put_KeyProtectionLevel(value)); }
			void operator=(Certificates::KeyProtectionLevel value) { put(value); }
			void operator()(Certificates::KeyProtectionLevel value) { put(value); }
		} KeyProtectionLevel;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPfxImportParameters_adaptor::KeyStorageProviderName)->_get_KeyStorageProviderName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPfxImportParameters_adaptor::KeyStorageProviderName)->_put_KeyStorageProviderName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} KeyStorageProviderName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPfxImportParameters_adaptor::ReaderName)->_get_ReaderName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IPfxImportParameters_adaptor::ReaderName)->_put_ReaderName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} ReaderName;
	};
	IPfxImportParameters_adaptor() {}
};
template<typename X> struct adapt<IPfxImportParameters, X> : Windows::Security::Cryptography::Certificates::IPfxImportParameters_adaptor<X> { typedef adapt IPfxImportParameters; };
struct IPfxImportParameters : IPfxImportParameters_raw, generate<IPfxImportParameters> {};

// PfxImportParameters
template<typename X> struct statics<PfxImportParameters, X> : X {
	typedef typename X::root_type PfxImportParameters;
};
struct PfxImportParameters : generate<PfxImportParameters> {};

// CertificateEnrollmentManager
template<typename> struct CertificateEnrollmentManager_statics {
	static struct _UserCertificateEnrollmentManager : property {
		ptr<Certificates::UserCertificateEnrollmentManager> get() { Certificates::UserCertificateEnrollmentManager* value; hrcheck(get_activation_factory<CertificateEnrollmentManager, ICertificateEnrollmentManagerStatics2>()->_get_UserCertificateEnrollmentManager(&value)); return from_abi(value); }
		ptr<Certificates::UserCertificateEnrollmentManager> operator()() { return get(); }
		operator ptr<Certificates::UserCertificateEnrollmentManager> () { return get(); }
		ptr<Certificates::UserCertificateEnrollmentManager> operator->() { return get(); }
	} UserCertificateEnrollmentManager;
	static ptr<Foundation::IAsyncAction> ImportPfxDataAsync(hstring_ref pfxData, hstring_ref password, pptr<PfxImportParameters> pfxImportParameters) { Foundation::IAsyncAction* value; hrcheck(get_activation_factory<CertificateEnrollmentManager, ICertificateEnrollmentManagerStatics3>()->_ImportPfxDataToKspWithParametersAsync(pfxData, password, pfxImportParameters, &value)); return from_abi(value); }
	static ptr<Foundation::IAsyncAction> ImportPfxDataAsync(hstring_ref pfxData, hstring_ref password, ExportOption exportable, KeyProtectionLevel keyProtectionLevel, InstallOptions installOption, hstring_ref friendlyName, hstring_ref keyStorageProvider) { Foundation::IAsyncAction* value; hrcheck(get_activation_factory<CertificateEnrollmentManager, ICertificateEnrollmentManagerStatics2>()->_ImportPfxDataToKspAsync(pfxData, password, exportable, keyProtectionLevel, installOption, friendlyName, keyStorageProvider, &value)); return from_abi(value); }
	static ptr<Foundation::IAsyncOperation<hstring>> CreateRequestAsync(pptr<CertificateRequestProperties> request) { Foundation::IAsyncOperation<HSTRING>* value; hrcheck(get_activation_factory<CertificateEnrollmentManager, ICertificateEnrollmentManagerStatics>()->_CreateRequestAsync(request, &value)); return from_abi(value); }
	static ptr<Foundation::IAsyncAction> InstallCertificateAsync(hstring_ref certificate, InstallOptions installOption) { Foundation::IAsyncAction* value; hrcheck(get_activation_factory<CertificateEnrollmentManager, ICertificateEnrollmentManagerStatics>()->_InstallCertificateAsync(certificate, installOption, &value)); return from_abi(value); }
	static ptr<Foundation::IAsyncAction> ImportPfxDataAsync(hstring_ref pfxData, hstring_ref password, ExportOption exportable, KeyProtectionLevel keyProtectionLevel, InstallOptions installOption, hstring_ref friendlyName) { Foundation::IAsyncAction* value; hrcheck(get_activation_factory<CertificateEnrollmentManager, ICertificateEnrollmentManagerStatics>()->_ImportPfxDataAsync(pfxData, password, exportable, keyProtectionLevel, installOption, friendlyName, &value)); return from_abi(value); }
};
template<typename X> typename CertificateEnrollmentManager_statics<X>::_UserCertificateEnrollmentManager CertificateEnrollmentManager_statics<X>::UserCertificateEnrollmentManager;

template<typename X> struct statics<CertificateEnrollmentManager, X> : X, Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager_statics<void> {
	typedef typename X::root_type CertificateEnrollmentManager;
};
struct CertificateEnrollmentManager : generate<CertificateEnrollmentManager> {};

// IKeyAttestationHelperStatics
struct IKeyAttestationHelperStatics : IInspectable {
	virtual STDMETHODIMP _DecryptTpmAttestationCredentialAsync(HSTRING credential, Foundation::IAsyncOperation<HSTRING>* *value);
	virtual STDMETHODIMP _GetTpmAttestationCredentialId(HSTRING credential, HSTRING *value);
};

// IKeyAttestationHelperStatics2
struct IKeyAttestationHelperStatics2 : IInspectable {
	virtual STDMETHODIMP _DecryptTpmAttestationCredentialWithContainerNameAsync(HSTRING credential, HSTRING containerName, Foundation::IAsyncOperation<HSTRING>* *value);
};

// KeyAttestationHelper
template<typename> struct KeyAttestationHelper_statics {
	static ptr<Foundation::IAsyncOperation<hstring>> DecryptTpmAttestationCredentialAsync(hstring_ref credential, hstring_ref containerName) { Foundation::IAsyncOperation<HSTRING>* value; hrcheck(get_activation_factory<KeyAttestationHelper, IKeyAttestationHelperStatics2>()->_DecryptTpmAttestationCredentialWithContainerNameAsync(credential, containerName, &value)); return from_abi(value); }
	static ptr<Foundation::IAsyncOperation<hstring>> DecryptTpmAttestationCredentialAsync(hstring_ref credential) { Foundation::IAsyncOperation<HSTRING>* value; hrcheck(get_activation_factory<KeyAttestationHelper, IKeyAttestationHelperStatics>()->_DecryptTpmAttestationCredentialAsync(credential, &value)); return from_abi(value); }
	static hstring GetTpmAttestationCredentialId(hstring_ref credential) { HSTRING value; hrcheck(get_activation_factory<KeyAttestationHelper, IKeyAttestationHelperStatics>()->_GetTpmAttestationCredentialId(credential, &value)); return from_abi(value); }
};

template<typename X> struct statics<KeyAttestationHelper, X> : X, Windows::Security::Cryptography::Certificates::KeyAttestationHelper_statics<void> {
	typedef typename X::root_type KeyAttestationHelper;
};
struct KeyAttestationHelper : generate<KeyAttestationHelper> {};

// ICertificateStoresStatics
struct ICertificateStoresStatics : IInspectable {
	virtual STDMETHODIMP _FindAllAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Certificate*>*>* *value);
	virtual STDMETHODIMP _FindAllWithQueryAsync(CertificateQuery* query, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Certificate*>*>* *value);
	virtual STDMETHODIMP _get_TrustedRootCertificationAuthorities(CertificateStore* *value);
	virtual STDMETHODIMP _get_IntermediateCertificationAuthorities(CertificateStore* *value);
	virtual STDMETHODIMP _GetStoreByName(HSTRING storeName, CertificateStore* *value);
};

// ICertificateQuery2
struct ICertificateQuery2_raw : IInspectable {
	virtual STDMETHODIMP _get_IncludeDuplicates(bool *value);
	virtual STDMETHODIMP _put_IncludeDuplicates(bool value);
	virtual STDMETHODIMP _get_IncludeExpiredCertificates(bool *value);
	virtual STDMETHODIMP _put_IncludeExpiredCertificates(bool value);
	virtual STDMETHODIMP _get_StoreName(HSTRING *value);
	virtual STDMETHODIMP _put_StoreName(HSTRING value);
};
template<typename X> struct ICertificateQuery2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificateQuery2_adaptor::IncludeDuplicates)->_get_IncludeDuplicates(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICertificateQuery2_adaptor::IncludeDuplicates)->_put_IncludeDuplicates(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IncludeDuplicates;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificateQuery2_adaptor::IncludeExpiredCertificates)->_get_IncludeExpiredCertificates(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICertificateQuery2_adaptor::IncludeExpiredCertificates)->_put_IncludeExpiredCertificates(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IncludeExpiredCertificates;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificateQuery2_adaptor::StoreName)->_get_StoreName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICertificateQuery2_adaptor::StoreName)->_put_StoreName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} StoreName;
	};
	ICertificateQuery2_adaptor() {}
};
template<typename X> struct adapt<ICertificateQuery2, X> : Windows::Security::Cryptography::Certificates::ICertificateQuery2_adaptor<X> { typedef adapt ICertificateQuery2; };
struct ICertificateQuery2 : ICertificateQuery2_raw, generate<ICertificateQuery2> {};

// ICertificateQuery
struct ICertificateQuery_raw : IInspectable {
	virtual STDMETHODIMP _get_EnhancedKeyUsages(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_IssuerName(HSTRING *value);
	virtual STDMETHODIMP _put_IssuerName(HSTRING value);
	virtual STDMETHODIMP _get_FriendlyName(HSTRING *value);
	virtual STDMETHODIMP _put_FriendlyName(HSTRING value);
	virtual STDMETHODIMP _get_Thumbprint(unsigned *valueSize, unsigned char **value);
	virtual STDMETHODIMP _put_Thumbprint(unsigned valueSize, unsigned char *value);
	virtual STDMETHODIMP _get_HardwareOnly(bool *value);
	virtual STDMETHODIMP _put_HardwareOnly(bool value);
};
template<typename X> struct ICertificateQuery_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&ICertificateQuery_adaptor::EnhancedKeyUsages)->_get_EnhancedKeyUsages(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} EnhancedKeyUsages;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificateQuery_adaptor::FriendlyName)->_get_FriendlyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICertificateQuery_adaptor::FriendlyName)->_put_FriendlyName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} FriendlyName;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificateQuery_adaptor::HardwareOnly)->_get_HardwareOnly(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICertificateQuery_adaptor::HardwareOnly)->_put_HardwareOnly(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} HardwareOnly;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificateQuery_adaptor::IssuerName)->_get_IssuerName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICertificateQuery_adaptor::IssuerName)->_put_IssuerName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} IssuerName;
		struct : property {
			szarray<unsigned char> get() { szarray<unsigned char> value; hrcheck(enc(&ICertificateQuery_adaptor::Thumbprint)->_get_Thumbprint(&value.size, &value.p)); return value; }
			szarray<unsigned char> operator()() { return get(); }
			operator szarray<unsigned char> () { return get(); }
			void put(const szarray<unsigned char>& value) { hrcheck(enc(&ICertificateQuery_adaptor::Thumbprint)->_put_Thumbprint(value.size, to_abi(value.p))); }
			void operator=(const szarray<unsigned char>& value) { put(value); }
			void operator()(const szarray<unsigned char>& value) { put(value); }
		} Thumbprint;
	};
	ICertificateQuery_adaptor() {}
};
template<typename X> struct adapt<ICertificateQuery, X> : Windows::Security::Cryptography::Certificates::ICertificateQuery_adaptor<X> { typedef adapt ICertificateQuery; };
struct ICertificateQuery : ICertificateQuery_raw, generate<ICertificateQuery> {};

// CertificateQuery
template<typename X> struct statics<CertificateQuery, X> : X {
	typedef typename X::root_type CertificateQuery;
};
struct CertificateQuery : generate<CertificateQuery> {};

// ICertificateStore2
struct ICertificateStore2_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
};
template<typename X> struct ICertificateStore2_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICertificateStore2_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
	};
	ICertificateStore2_adaptor() {}
};
template<typename X> struct adapt<ICertificateStore2, X> : Windows::Security::Cryptography::Certificates::ICertificateStore2_adaptor<X> { typedef adapt ICertificateStore2; };
struct ICertificateStore2 : ICertificateStore2_raw, generate<ICertificateStore2> {};

// ICertificateStore
struct ICertificateStore_raw : IInspectable {
	virtual STDMETHODIMP _Add(Certificate* certificate);
	virtual STDMETHODIMP _Delete(Certificate* certificate);
};
template<typename X> struct ICertificateStore_adaptor : X {
	void Add(pptr<Certificate> certificate) { hrcheck(X::get()->_Add(certificate)); }
	void Delete(pptr<Certificate> certificate) { hrcheck(X::get()->_Delete(certificate)); }
};
template<typename X> struct adapt<ICertificateStore, X> : Windows::Security::Cryptography::Certificates::ICertificateStore_adaptor<X> { typedef adapt ICertificateStore; };
struct ICertificateStore : ICertificateStore_raw, generate<ICertificateStore> {};

// CertificateStore
template<typename X> struct statics<CertificateStore, X> : X {
	typedef typename X::root_type CertificateStore;
};
struct CertificateStore : generate<CertificateStore> {};

// ICertificateStoresStatics2
struct ICertificateStoresStatics2 : IInspectable {
	virtual STDMETHODIMP _GetUserStoreByName(HSTRING storeName, UserCertificateStore* *result);
};

// IUserCertificateStore
struct IUserCertificateStore_raw : IInspectable {
	virtual STDMETHODIMP _RequestAddAsync(Certificate* certificate, Foundation::IAsyncOperation<bool>* *result);
	virtual STDMETHODIMP _RequestDeleteAsync(Certificate* certificate, Foundation::IAsyncOperation<bool>* *result);
	virtual STDMETHODIMP _get_Name(HSTRING *value);
};
template<typename X> struct IUserCertificateStore_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserCertificateStore_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
	};
	ptr<Foundation::IAsyncOperation<bool>> RequestAddAsync(pptr<Certificate> certificate) { Foundation::IAsyncOperation<bool>* result; hrcheck(X::get()->_RequestAddAsync(certificate, &result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<bool>> RequestDeleteAsync(pptr<Certificate> certificate) { Foundation::IAsyncOperation<bool>* result; hrcheck(X::get()->_RequestDeleteAsync(certificate, &result)); return from_abi(result); }
	IUserCertificateStore_adaptor() {}
};
template<typename X> struct adapt<IUserCertificateStore, X> : Windows::Security::Cryptography::Certificates::IUserCertificateStore_adaptor<X> { typedef adapt IUserCertificateStore; };
struct IUserCertificateStore : IUserCertificateStore_raw, generate<IUserCertificateStore> {};

// UserCertificateStore
template<typename X> struct statics<UserCertificateStore, X> : X {
	typedef typename X::root_type UserCertificateStore;
};
struct UserCertificateStore : generate<UserCertificateStore> {};

// CertificateStores
template<typename> struct CertificateStores_statics {
	static struct _IntermediateCertificationAuthorities : property {
		ptr<CertificateStore> get() { CertificateStore* value; hrcheck(get_activation_factory<CertificateStores, ICertificateStoresStatics>()->_get_IntermediateCertificationAuthorities(&value)); return from_abi(value); }
		ptr<CertificateStore> operator()() { return get(); }
		operator ptr<CertificateStore> () { return get(); }
		ptr<CertificateStore> operator->() { return get(); }
	} IntermediateCertificationAuthorities;
	static struct _TrustedRootCertificationAuthorities : property {
		ptr<CertificateStore> get() { CertificateStore* value; hrcheck(get_activation_factory<CertificateStores, ICertificateStoresStatics>()->_get_TrustedRootCertificationAuthorities(&value)); return from_abi(value); }
		ptr<CertificateStore> operator()() { return get(); }
		operator ptr<CertificateStore> () { return get(); }
		ptr<CertificateStore> operator->() { return get(); }
	} TrustedRootCertificationAuthorities;
	static ptr<UserCertificateStore> GetUserStoreByName(hstring_ref storeName) { UserCertificateStore* result; hrcheck(get_activation_factory<CertificateStores, ICertificateStoresStatics2>()->_GetUserStoreByName(storeName, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<Certificate>>>>> FindAllAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Certificate*>*>* value; hrcheck(get_activation_factory<CertificateStores, ICertificateStoresStatics>()->_FindAllAsync(&value)); return from_abi(value); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<Certificate>>>>> FindAllAsync(pptr<CertificateQuery> query) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Certificate*>*>* value; hrcheck(get_activation_factory<CertificateStores, ICertificateStoresStatics>()->_FindAllWithQueryAsync(query, &value)); return from_abi(value); }
	static ptr<CertificateStore> GetStoreByName(hstring_ref storeName) { CertificateStore* value; hrcheck(get_activation_factory<CertificateStores, ICertificateStoresStatics>()->_GetStoreByName(storeName, &value)); return from_abi(value); }
};
template<typename X> typename CertificateStores_statics<X>::_IntermediateCertificationAuthorities CertificateStores_statics<X>::IntermediateCertificationAuthorities;
template<typename X> typename CertificateStores_statics<X>::_TrustedRootCertificationAuthorities CertificateStores_statics<X>::TrustedRootCertificationAuthorities;

template<typename X> struct statics<CertificateStores, X> : X, Windows::Security::Cryptography::Certificates::CertificateStores_statics<void> {
	typedef typename X::root_type CertificateStores;
};
struct CertificateStores : generate<CertificateStores> {};

// IStandardCertificateStoreNamesStatics
struct IStandardCertificateStoreNamesStatics : IInspectable {
	virtual STDMETHODIMP _get_Personal(HSTRING *value);
	virtual STDMETHODIMP _get_TrustedRootCertificationAuthorities(HSTRING *value);
	virtual STDMETHODIMP _get_IntermediateCertificationAuthorities(HSTRING *value);
};

// StandardCertificateStoreNames
template<typename> struct StandardCertificateStoreNames_statics {
	static struct _IntermediateCertificationAuthorities : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<StandardCertificateStoreNames, IStandardCertificateStoreNamesStatics>()->_get_IntermediateCertificationAuthorities(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} IntermediateCertificationAuthorities;
	static struct _Personal : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<StandardCertificateStoreNames, IStandardCertificateStoreNamesStatics>()->_get_Personal(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Personal;
	static struct _TrustedRootCertificationAuthorities : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<StandardCertificateStoreNames, IStandardCertificateStoreNamesStatics>()->_get_TrustedRootCertificationAuthorities(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} TrustedRootCertificationAuthorities;
};
template<typename X> typename StandardCertificateStoreNames_statics<X>::_IntermediateCertificationAuthorities StandardCertificateStoreNames_statics<X>::IntermediateCertificationAuthorities;
template<typename X> typename StandardCertificateStoreNames_statics<X>::_Personal StandardCertificateStoreNames_statics<X>::Personal;
template<typename X> typename StandardCertificateStoreNames_statics<X>::_TrustedRootCertificationAuthorities StandardCertificateStoreNames_statics<X>::TrustedRootCertificationAuthorities;

template<typename X> struct statics<StandardCertificateStoreNames, X> : X, Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames_statics<void> {
	typedef typename X::root_type StandardCertificateStoreNames;
};
struct StandardCertificateStoreNames : generate<StandardCertificateStoreNames> {};

// IKeyAlgorithmNamesStatics
struct IKeyAlgorithmNamesStatics : IInspectable {
	virtual STDMETHODIMP _get_Rsa(HSTRING *value);
	virtual STDMETHODIMP _get_Dsa(HSTRING *value);
	virtual STDMETHODIMP _get_Ecdh256(HSTRING *value);
	virtual STDMETHODIMP _get_Ecdh384(HSTRING *value);
	virtual STDMETHODIMP _get_Ecdh521(HSTRING *value);
	virtual STDMETHODIMP _get_Ecdsa256(HSTRING *value);
	virtual STDMETHODIMP _get_Ecdsa384(HSTRING *value);
	virtual STDMETHODIMP _get_Ecdsa521(HSTRING *value);
};

// IKeyAlgorithmNamesStatics2
struct IKeyAlgorithmNamesStatics2 : IInspectable {
	virtual STDMETHODIMP _get_Ecdsa(HSTRING *value);
	virtual STDMETHODIMP _get_Ecdh(HSTRING *value);
};

// KeyAlgorithmNames
template<typename> struct KeyAlgorithmNames_statics {
	static struct _Dsa : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KeyAlgorithmNames, IKeyAlgorithmNamesStatics>()->_get_Dsa(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Dsa;
	static struct _Ecdh256 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KeyAlgorithmNames, IKeyAlgorithmNamesStatics>()->_get_Ecdh256(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Ecdh256;
	static struct _Ecdh384 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KeyAlgorithmNames, IKeyAlgorithmNamesStatics>()->_get_Ecdh384(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Ecdh384;
	static struct _Ecdh521 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KeyAlgorithmNames, IKeyAlgorithmNamesStatics>()->_get_Ecdh521(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Ecdh521;
	static struct _Ecdsa256 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KeyAlgorithmNames, IKeyAlgorithmNamesStatics>()->_get_Ecdsa256(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Ecdsa256;
	static struct _Ecdsa384 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KeyAlgorithmNames, IKeyAlgorithmNamesStatics>()->_get_Ecdsa384(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Ecdsa384;
	static struct _Ecdsa521 : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KeyAlgorithmNames, IKeyAlgorithmNamesStatics>()->_get_Ecdsa521(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Ecdsa521;
	static struct _Rsa : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KeyAlgorithmNames, IKeyAlgorithmNamesStatics>()->_get_Rsa(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Rsa;
	static struct _Ecdh : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KeyAlgorithmNames, IKeyAlgorithmNamesStatics2>()->_get_Ecdh(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Ecdh;
	static struct _Ecdsa : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KeyAlgorithmNames, IKeyAlgorithmNamesStatics2>()->_get_Ecdsa(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Ecdsa;
};
template<typename X> typename KeyAlgorithmNames_statics<X>::_Dsa KeyAlgorithmNames_statics<X>::Dsa;
template<typename X> typename KeyAlgorithmNames_statics<X>::_Ecdh256 KeyAlgorithmNames_statics<X>::Ecdh256;
template<typename X> typename KeyAlgorithmNames_statics<X>::_Ecdh384 KeyAlgorithmNames_statics<X>::Ecdh384;
template<typename X> typename KeyAlgorithmNames_statics<X>::_Ecdh521 KeyAlgorithmNames_statics<X>::Ecdh521;
template<typename X> typename KeyAlgorithmNames_statics<X>::_Ecdsa256 KeyAlgorithmNames_statics<X>::Ecdsa256;
template<typename X> typename KeyAlgorithmNames_statics<X>::_Ecdsa384 KeyAlgorithmNames_statics<X>::Ecdsa384;
template<typename X> typename KeyAlgorithmNames_statics<X>::_Ecdsa521 KeyAlgorithmNames_statics<X>::Ecdsa521;
template<typename X> typename KeyAlgorithmNames_statics<X>::_Rsa KeyAlgorithmNames_statics<X>::Rsa;
template<typename X> typename KeyAlgorithmNames_statics<X>::_Ecdh KeyAlgorithmNames_statics<X>::Ecdh;
template<typename X> typename KeyAlgorithmNames_statics<X>::_Ecdsa KeyAlgorithmNames_statics<X>::Ecdsa;

template<typename X> struct statics<KeyAlgorithmNames, X> : X, Windows::Security::Cryptography::Certificates::KeyAlgorithmNames_statics<void> {
	typedef typename X::root_type KeyAlgorithmNames;
};
struct KeyAlgorithmNames : generate<KeyAlgorithmNames> {};

// IKeyStorageProviderNamesStatics
struct IKeyStorageProviderNamesStatics : IInspectable {
	virtual STDMETHODIMP _get_SoftwareKeyStorageProvider(HSTRING *value);
	virtual STDMETHODIMP _get_SmartcardKeyStorageProvider(HSTRING *value);
	virtual STDMETHODIMP _get_PlatformKeyStorageProvider(HSTRING *value);
};

// IKeyStorageProviderNamesStatics2
struct IKeyStorageProviderNamesStatics2 : IInspectable {
	virtual STDMETHODIMP _get_PassportKeyStorageProvider(HSTRING *value);
};

// KeyStorageProviderNames
template<typename> struct KeyStorageProviderNames_statics {
	static struct _PlatformKeyStorageProvider : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KeyStorageProviderNames, IKeyStorageProviderNamesStatics>()->_get_PlatformKeyStorageProvider(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} PlatformKeyStorageProvider;
	static struct _SmartcardKeyStorageProvider : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KeyStorageProviderNames, IKeyStorageProviderNamesStatics>()->_get_SmartcardKeyStorageProvider(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} SmartcardKeyStorageProvider;
	static struct _SoftwareKeyStorageProvider : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KeyStorageProviderNames, IKeyStorageProviderNamesStatics>()->_get_SoftwareKeyStorageProvider(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} SoftwareKeyStorageProvider;
	static struct _PassportKeyStorageProvider : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<KeyStorageProviderNames, IKeyStorageProviderNamesStatics2>()->_get_PassportKeyStorageProvider(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} PassportKeyStorageProvider;
};
template<typename X> typename KeyStorageProviderNames_statics<X>::_PlatformKeyStorageProvider KeyStorageProviderNames_statics<X>::PlatformKeyStorageProvider;
template<typename X> typename KeyStorageProviderNames_statics<X>::_SmartcardKeyStorageProvider KeyStorageProviderNames_statics<X>::SmartcardKeyStorageProvider;
template<typename X> typename KeyStorageProviderNames_statics<X>::_SoftwareKeyStorageProvider KeyStorageProviderNames_statics<X>::SoftwareKeyStorageProvider;
template<typename X> typename KeyStorageProviderNames_statics<X>::_PassportKeyStorageProvider KeyStorageProviderNames_statics<X>::PassportKeyStorageProvider;

template<typename X> struct statics<KeyStorageProviderNames, X> : X, Windows::Security::Cryptography::Certificates::KeyStorageProviderNames_statics<void> {
	typedef typename X::root_type KeyStorageProviderNames;
};
struct KeyStorageProviderNames : generate<KeyStorageProviderNames> {};

// IChainBuildingParameters
struct IChainBuildingParameters_raw : IInspectable {
	virtual STDMETHODIMP _get_EnhancedKeyUsages(Foundation::Collections::IVector<HSTRING>* *value);
	virtual STDMETHODIMP _get_ValidationTimestamp(Foundation::DateTime *value);
	virtual STDMETHODIMP _put_ValidationTimestamp(Foundation::DateTime value);
	virtual STDMETHODIMP _get_RevocationCheckEnabled(bool *value);
	virtual STDMETHODIMP _put_RevocationCheckEnabled(bool value);
	virtual STDMETHODIMP _get_NetworkRetrievalEnabled(bool *value);
	virtual STDMETHODIMP _put_NetworkRetrievalEnabled(bool value);
	virtual STDMETHODIMP _get_AuthorityInformationAccessEnabled(bool *value);
	virtual STDMETHODIMP _put_AuthorityInformationAccessEnabled(bool value);
	virtual STDMETHODIMP _get_CurrentTimeValidationEnabled(bool *value);
	virtual STDMETHODIMP _put_CurrentTimeValidationEnabled(bool value);
	virtual STDMETHODIMP _get_ExclusiveTrustRoots(Foundation::Collections::IVector<Certificate*>* *certificates);
};
template<typename X> struct IChainBuildingParameters_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IChainBuildingParameters_adaptor::AuthorityInformationAccessEnabled)->_get_AuthorityInformationAccessEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IChainBuildingParameters_adaptor::AuthorityInformationAccessEnabled)->_put_AuthorityInformationAccessEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AuthorityInformationAccessEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IChainBuildingParameters_adaptor::CurrentTimeValidationEnabled)->_get_CurrentTimeValidationEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IChainBuildingParameters_adaptor::CurrentTimeValidationEnabled)->_put_CurrentTimeValidationEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} CurrentTimeValidationEnabled;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IChainBuildingParameters_adaptor::EnhancedKeyUsages)->_get_EnhancedKeyUsages(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} EnhancedKeyUsages;
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Certificate>>> get() { Foundation::Collections::IVector<Certificate*>* certificates; hrcheck(enc(&IChainBuildingParameters_adaptor::ExclusiveTrustRoots)->_get_ExclusiveTrustRoots(&certificates)); return from_abi(certificates); }
			ptr<Foundation::Collections::IVector<ptr<Certificate>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Certificate>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Certificate>>> operator->() { return get(); }
		} ExclusiveTrustRoots;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IChainBuildingParameters_adaptor::NetworkRetrievalEnabled)->_get_NetworkRetrievalEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IChainBuildingParameters_adaptor::NetworkRetrievalEnabled)->_put_NetworkRetrievalEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} NetworkRetrievalEnabled;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IChainBuildingParameters_adaptor::RevocationCheckEnabled)->_get_RevocationCheckEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IChainBuildingParameters_adaptor::RevocationCheckEnabled)->_put_RevocationCheckEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} RevocationCheckEnabled;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IChainBuildingParameters_adaptor::ValidationTimestamp)->_get_ValidationTimestamp(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
			void put(const Foundation::DateTime& value) { hrcheck(enc(&IChainBuildingParameters_adaptor::ValidationTimestamp)->_put_ValidationTimestamp(value)); }
			void operator=(const Foundation::DateTime& value) { put(value); }
			void operator()(const Foundation::DateTime& value) { put(value); }
		} ValidationTimestamp;
	};
	IChainBuildingParameters_adaptor() {}
};
template<typename X> struct adapt<IChainBuildingParameters, X> : Windows::Security::Cryptography::Certificates::IChainBuildingParameters_adaptor<X> { typedef adapt IChainBuildingParameters; };
struct IChainBuildingParameters : IChainBuildingParameters_raw, generate<IChainBuildingParameters> {};

// ChainBuildingParameters
template<typename X> struct statics<ChainBuildingParameters, X> : X {
	typedef typename X::root_type ChainBuildingParameters;
};
struct ChainBuildingParameters : generate<ChainBuildingParameters> {};

// IChainValidationParameters
struct IChainValidationParameters_raw : IInspectable {
	virtual STDMETHODIMP _get_CertificateChainPolicy(Certificates::CertificateChainPolicy *value);
	virtual STDMETHODIMP _put_CertificateChainPolicy(Certificates::CertificateChainPolicy value);
	virtual STDMETHODIMP _get_ServerDnsName(Networking::HostName* *value);
	virtual STDMETHODIMP _put_ServerDnsName(Networking::HostName* value);
};
template<typename X> struct IChainValidationParameters_adaptor : X {
	union {
		struct : property {
			Certificates::CertificateChainPolicy get() { Certificates::CertificateChainPolicy value; hrcheck(enc(&IChainValidationParameters_adaptor::CertificateChainPolicy)->_get_CertificateChainPolicy(&value)); return value; }
			Certificates::CertificateChainPolicy operator()() { return get(); }
			operator Certificates::CertificateChainPolicy () { return get(); }
			void put(Certificates::CertificateChainPolicy value) { hrcheck(enc(&IChainValidationParameters_adaptor::CertificateChainPolicy)->_put_CertificateChainPolicy(value)); }
			void operator=(Certificates::CertificateChainPolicy value) { put(value); }
			void operator()(Certificates::CertificateChainPolicy value) { put(value); }
		} CertificateChainPolicy;
		struct : property {
			ptr<Networking::HostName> get() { Networking::HostName* value; hrcheck(enc(&IChainValidationParameters_adaptor::ServerDnsName)->_get_ServerDnsName(&value)); return from_abi(value); }
			ptr<Networking::HostName> operator()() { return get(); }
			operator ptr<Networking::HostName> () { return get(); }
			ptr<Networking::HostName> operator->() { return get(); }
			void put(pptr<Networking::HostName> value) { hrcheck(enc(&IChainValidationParameters_adaptor::ServerDnsName)->_put_ServerDnsName(value)); }
			void operator=(pptr<Networking::HostName> value) { put(value); }
			void operator()(pptr<Networking::HostName> value) { put(value); }
		} ServerDnsName;
	};
	IChainValidationParameters_adaptor() {}
};
template<typename X> struct adapt<IChainValidationParameters, X> : Windows::Security::Cryptography::Certificates::IChainValidationParameters_adaptor<X> { typedef adapt IChainValidationParameters; };
struct IChainValidationParameters : IChainValidationParameters_raw, generate<IChainValidationParameters> {};

// ChainValidationParameters
template<typename X> struct statics<ChainValidationParameters, X> : X {
	typedef typename X::root_type ChainValidationParameters;
};
struct ChainValidationParameters : generate<ChainValidationParameters> {};

// ICertificateChain
struct ICertificateChain_raw : IInspectable {
	virtual STDMETHODIMP _Validate(ChainValidationResult *status);
	virtual STDMETHODIMP _ValidateWithParameters(ChainValidationParameters* parameter, ChainValidationResult *status);
	virtual STDMETHODIMP _GetCertificates(bool includeRoot, Foundation::Collections::IVectorView<Certificate*>* *certificates);
};
template<typename X> struct ICertificateChain_adaptor : X {
	ChainValidationResult Validate() { ChainValidationResult status; hrcheck(X::get()->_Validate(&status)); return status; }
	ChainValidationResult Validate(pptr<ChainValidationParameters> parameter) { ChainValidationResult status; hrcheck(X::get()->_ValidateWithParameters(parameter, &status)); return status; }
	ptr<Foundation::Collections::IVectorView<ptr<Certificate>>> GetCertificates(bool includeRoot) { Foundation::Collections::IVectorView<Certificate*>* certificates; hrcheck(X::get()->_GetCertificates(includeRoot, &certificates)); return from_abi(certificates); }
};
template<typename X> struct adapt<ICertificateChain, X> : Windows::Security::Cryptography::Certificates::ICertificateChain_adaptor<X> { typedef adapt ICertificateChain; };
struct ICertificateChain : ICertificateChain_raw, generate<ICertificateChain> {};

// CertificateChain
template<typename X> struct statics<CertificateChain, X> : X {
	typedef typename X::root_type CertificateChain;
};
struct CertificateChain : generate<CertificateChain> {
	using ICertificateChain::Validate;
};

// ICertificateKeyUsages
struct ICertificateKeyUsages_raw : IInspectable {
	virtual STDMETHODIMP _get_EncipherOnly(bool *value);
	virtual STDMETHODIMP _put_EncipherOnly(bool value);
	virtual STDMETHODIMP _get_CrlSign(bool *value);
	virtual STDMETHODIMP _put_CrlSign(bool value);
	virtual STDMETHODIMP _get_KeyCertificateSign(bool *value);
	virtual STDMETHODIMP _put_KeyCertificateSign(bool value);
	virtual STDMETHODIMP _get_KeyAgreement(bool *value);
	virtual STDMETHODIMP _put_KeyAgreement(bool value);
	virtual STDMETHODIMP _get_DataEncipherment(bool *value);
	virtual STDMETHODIMP _put_DataEncipherment(bool value);
	virtual STDMETHODIMP _get_KeyEncipherment(bool *value);
	virtual STDMETHODIMP _put_KeyEncipherment(bool value);
	virtual STDMETHODIMP _get_NonRepudiation(bool *value);
	virtual STDMETHODIMP _put_NonRepudiation(bool value);
	virtual STDMETHODIMP _get_DigitalSignature(bool *value);
	virtual STDMETHODIMP _put_DigitalSignature(bool value);
};
template<typename X> struct ICertificateKeyUsages_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificateKeyUsages_adaptor::CrlSign)->_get_CrlSign(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICertificateKeyUsages_adaptor::CrlSign)->_put_CrlSign(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} CrlSign;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificateKeyUsages_adaptor::DataEncipherment)->_get_DataEncipherment(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICertificateKeyUsages_adaptor::DataEncipherment)->_put_DataEncipherment(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} DataEncipherment;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificateKeyUsages_adaptor::DigitalSignature)->_get_DigitalSignature(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICertificateKeyUsages_adaptor::DigitalSignature)->_put_DigitalSignature(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} DigitalSignature;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificateKeyUsages_adaptor::EncipherOnly)->_get_EncipherOnly(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICertificateKeyUsages_adaptor::EncipherOnly)->_put_EncipherOnly(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} EncipherOnly;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificateKeyUsages_adaptor::KeyAgreement)->_get_KeyAgreement(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICertificateKeyUsages_adaptor::KeyAgreement)->_put_KeyAgreement(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} KeyAgreement;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificateKeyUsages_adaptor::KeyCertificateSign)->_get_KeyCertificateSign(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICertificateKeyUsages_adaptor::KeyCertificateSign)->_put_KeyCertificateSign(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} KeyCertificateSign;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificateKeyUsages_adaptor::KeyEncipherment)->_get_KeyEncipherment(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICertificateKeyUsages_adaptor::KeyEncipherment)->_put_KeyEncipherment(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} KeyEncipherment;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ICertificateKeyUsages_adaptor::NonRepudiation)->_get_NonRepudiation(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ICertificateKeyUsages_adaptor::NonRepudiation)->_put_NonRepudiation(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} NonRepudiation;
	};
	ICertificateKeyUsages_adaptor() {}
};
template<typename X> struct adapt<ICertificateKeyUsages, X> : Windows::Security::Cryptography::Certificates::ICertificateKeyUsages_adaptor<X> { typedef adapt ICertificateKeyUsages; };
struct ICertificateKeyUsages : ICertificateKeyUsages_raw, generate<ICertificateKeyUsages> {};

// CertificateKeyUsages
template<typename X> struct statics<CertificateKeyUsages, X> : X {
	typedef typename X::root_type CertificateKeyUsages;
};
struct CertificateKeyUsages : generate<CertificateKeyUsages> {};

// ICmsTimestampInfo
struct ICmsTimestampInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_SigningCertificate(Certificate* *value);
	virtual STDMETHODIMP _get_Certificates(Foundation::Collections::IVectorView<Certificate*>* *value);
	virtual STDMETHODIMP _get_Timestamp(Foundation::DateTime *value);
};
template<typename X> struct ICmsTimestampInfo_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Certificate>>> get() { Foundation::Collections::IVectorView<Certificate*>* value; hrcheck(enc(&ICmsTimestampInfo_adaptor::Certificates)->_get_Certificates(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Certificate>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Certificate>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Certificate>>> operator->() { return get(); }
		} Certificates;
		struct : property {
			ptr<Certificate> get() { Certificate* value; hrcheck(enc(&ICmsTimestampInfo_adaptor::SigningCertificate)->_get_SigningCertificate(&value)); return from_abi(value); }
			ptr<Certificate> operator()() { return get(); }
			operator ptr<Certificate> () { return get(); }
			ptr<Certificate> operator->() { return get(); }
		} SigningCertificate;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&ICmsTimestampInfo_adaptor::Timestamp)->_get_Timestamp(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} Timestamp;
	};
	ICmsTimestampInfo_adaptor() {}
};
template<typename X> struct adapt<ICmsTimestampInfo, X> : Windows::Security::Cryptography::Certificates::ICmsTimestampInfo_adaptor<X> { typedef adapt ICmsTimestampInfo; };
struct ICmsTimestampInfo : ICmsTimestampInfo_raw, generate<ICmsTimestampInfo> {};

// CmsTimestampInfo
template<typename X> struct statics<CmsTimestampInfo, X> : X {
	typedef typename X::root_type CmsTimestampInfo;
};
struct CmsTimestampInfo : generate<CmsTimestampInfo> {};

// ICmsSignerInfo
struct ICmsSignerInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_Certificate(Certificates::Certificate* *value);
	virtual STDMETHODIMP _put_Certificate(Certificates::Certificate* value);
	virtual STDMETHODIMP _get_HashAlgorithmName(HSTRING *value);
	virtual STDMETHODIMP _put_HashAlgorithmName(HSTRING value);
	virtual STDMETHODIMP _get_TimestampInfo(CmsTimestampInfo* *value);
};
template<typename X> struct ICmsSignerInfo_adaptor : X {
	union {
		struct : property {
			ptr<Certificates::Certificate> get() { Certificates::Certificate* value; hrcheck(enc(&ICmsSignerInfo_adaptor::Certificate)->_get_Certificate(&value)); return from_abi(value); }
			ptr<Certificates::Certificate> operator()() { return get(); }
			operator ptr<Certificates::Certificate> () { return get(); }
			ptr<Certificates::Certificate> operator->() { return get(); }
			void put(pptr<Certificates::Certificate> value) { hrcheck(enc(&ICmsSignerInfo_adaptor::Certificate)->_put_Certificate(value)); }
			void operator=(pptr<Certificates::Certificate> value) { put(value); }
			void operator()(pptr<Certificates::Certificate> value) { put(value); }
		} Certificate;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICmsSignerInfo_adaptor::HashAlgorithmName)->_get_HashAlgorithmName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&ICmsSignerInfo_adaptor::HashAlgorithmName)->_put_HashAlgorithmName(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} HashAlgorithmName;
		struct : property {
			ptr<CmsTimestampInfo> get() { CmsTimestampInfo* value; hrcheck(enc(&ICmsSignerInfo_adaptor::TimestampInfo)->_get_TimestampInfo(&value)); return from_abi(value); }
			ptr<CmsTimestampInfo> operator()() { return get(); }
			operator ptr<CmsTimestampInfo> () { return get(); }
			ptr<CmsTimestampInfo> operator->() { return get(); }
		} TimestampInfo;
	};
	ICmsSignerInfo_adaptor() {}
};
template<typename X> struct adapt<ICmsSignerInfo, X> : Windows::Security::Cryptography::Certificates::ICmsSignerInfo_adaptor<X> { typedef adapt ICmsSignerInfo; };
struct ICmsSignerInfo : ICmsSignerInfo_raw, generate<ICmsSignerInfo> {};

// CmsSignerInfo
template<typename X> struct statics<CmsSignerInfo, X> : X {
	typedef typename X::root_type CmsSignerInfo;
};
struct CmsSignerInfo : generate<CmsSignerInfo> {};

// ICmsAttachedSignature
struct ICmsAttachedSignature_raw : IInspectable {
	virtual STDMETHODIMP _get_Certificates(Foundation::Collections::IVectorView<Certificate*>* *value);
	virtual STDMETHODIMP _get_Content(unsigned *valueSize, unsigned char **value);
	virtual STDMETHODIMP _get_Signers(Foundation::Collections::IVectorView<CmsSignerInfo*>* *value);
	virtual STDMETHODIMP _VerifySignature(SignatureValidationResult *value);
};
template<typename X> struct ICmsAttachedSignature_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Certificate>>> get() { Foundation::Collections::IVectorView<Certificate*>* value; hrcheck(enc(&ICmsAttachedSignature_adaptor::Certificates)->_get_Certificates(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Certificate>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Certificate>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Certificate>>> operator->() { return get(); }
		} Certificates;
		struct : property {
			szarray<unsigned char> get() { szarray<unsigned char> value; hrcheck(enc(&ICmsAttachedSignature_adaptor::Content)->_get_Content(&value.size, &value.p)); return value; }
			szarray<unsigned char> operator()() { return get(); }
			operator szarray<unsigned char> () { return get(); }
		} Content;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<CmsSignerInfo>>> get() { Foundation::Collections::IVectorView<CmsSignerInfo*>* value; hrcheck(enc(&ICmsAttachedSignature_adaptor::Signers)->_get_Signers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<CmsSignerInfo>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<CmsSignerInfo>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<CmsSignerInfo>>> operator->() { return get(); }
		} Signers;
	};
	SignatureValidationResult VerifySignature() { SignatureValidationResult value; hrcheck(X::get()->_VerifySignature(&value)); return value; }
	ICmsAttachedSignature_adaptor() {}
};
template<typename X> struct adapt<ICmsAttachedSignature, X> : Windows::Security::Cryptography::Certificates::ICmsAttachedSignature_adaptor<X> { typedef adapt ICmsAttachedSignature; };
struct ICmsAttachedSignature : ICmsAttachedSignature_raw, generate<ICmsAttachedSignature> {};

// ICmsAttachedSignatureFactory
struct ICmsAttachedSignatureFactory : IInspectable {
	virtual STDMETHODIMP _CreateCmsAttachedSignature(Storage::Streams::IBuffer* inputBlob, CmsAttachedSignature* *cmsSignedData);
};

// ICmsAttachedSignatureStatics
struct ICmsAttachedSignatureStatics : IInspectable {
	virtual STDMETHODIMP _GenerateSignatureAsync(Storage::Streams::IBuffer* data, Foundation::Collections::IIterable<CmsSignerInfo*>* signers, Foundation::Collections::IIterable<Certificate*>* certificates, Foundation::IAsyncOperation<Storage::Streams::IBuffer*>* *outputBlob);
};

// CmsAttachedSignature
template<typename> struct CmsAttachedSignature_statics {
	static ptr<Foundation::IAsyncOperation<ptr<Storage::Streams::IBuffer>>> GenerateSignatureAsync(pptr<Storage::Streams::IBuffer> data, pptr<Foundation::Collections::IIterable<ptr<CmsSignerInfo>>> signers, pptr<Foundation::Collections::IIterable<ptr<Certificate>>> certificates) { Foundation::IAsyncOperation<Storage::Streams::IBuffer*>* outputBlob; hrcheck(get_activation_factory<CmsAttachedSignature, ICmsAttachedSignatureStatics>()->_GenerateSignatureAsync(data, to_abi(signers), to_abi(certificates), &outputBlob)); return from_abi(outputBlob); }
	static CmsAttachedSignature *activate(pptr<Storage::Streams::IBuffer> inputBlob) { CmsAttachedSignature *cmsSignedData; hrcheck(get_activation_factory<CmsAttachedSignature, ICmsAttachedSignatureFactory>()->_CreateCmsAttachedSignature(inputBlob, &cmsSignedData)); return cmsSignedData; }
};

template<typename X> struct statics<CmsAttachedSignature, X> : X, Windows::Security::Cryptography::Certificates::CmsAttachedSignature_statics<void> {
	using Windows::Security::Cryptography::Certificates::CmsAttachedSignature_statics<void>::activate;
	typedef typename X::root_type CmsAttachedSignature;
};
struct CmsAttachedSignature : generate<CmsAttachedSignature> {};

// ICmsDetachedSignature
struct ICmsDetachedSignature_raw : IInspectable {
	virtual STDMETHODIMP _get_Certificates(Foundation::Collections::IVectorView<Certificate*>* *value);
	virtual STDMETHODIMP _get_Signers(Foundation::Collections::IVectorView<CmsSignerInfo*>* *value);
	virtual STDMETHODIMP _VerifySignatureAsync(Storage::Streams::IInputStream* data, Foundation::IAsyncOperation<SignatureValidationResult>* *value);
};
template<typename X> struct ICmsDetachedSignature_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Certificate>>> get() { Foundation::Collections::IVectorView<Certificate*>* value; hrcheck(enc(&ICmsDetachedSignature_adaptor::Certificates)->_get_Certificates(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Certificate>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Certificate>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Certificate>>> operator->() { return get(); }
		} Certificates;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<CmsSignerInfo>>> get() { Foundation::Collections::IVectorView<CmsSignerInfo*>* value; hrcheck(enc(&ICmsDetachedSignature_adaptor::Signers)->_get_Signers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<CmsSignerInfo>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<CmsSignerInfo>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<CmsSignerInfo>>> operator->() { return get(); }
		} Signers;
	};
	ptr<Foundation::IAsyncOperation<SignatureValidationResult>> VerifySignatureAsync(pptr<Storage::Streams::IInputStream> data) { Foundation::IAsyncOperation<SignatureValidationResult>* value; hrcheck(X::get()->_VerifySignatureAsync(data, &value)); return from_abi(value); }
	ICmsDetachedSignature_adaptor() {}
};
template<typename X> struct adapt<ICmsDetachedSignature, X> : Windows::Security::Cryptography::Certificates::ICmsDetachedSignature_adaptor<X> { typedef adapt ICmsDetachedSignature; };
struct ICmsDetachedSignature : ICmsDetachedSignature_raw, generate<ICmsDetachedSignature> {};

// ICmsDetachedSignatureFactory
struct ICmsDetachedSignatureFactory : IInspectable {
	virtual STDMETHODIMP _CreateCmsDetachedSignature(Storage::Streams::IBuffer* inputBlob, CmsDetachedSignature* *cmsSignedData);
};

// ICmsDetachedSignatureStatics
struct ICmsDetachedSignatureStatics : IInspectable {
	virtual STDMETHODIMP _GenerateSignatureAsync(Storage::Streams::IInputStream* data, Foundation::Collections::IIterable<CmsSignerInfo*>* signers, Foundation::Collections::IIterable<Certificate*>* certificates, Foundation::IAsyncOperation<Storage::Streams::IBuffer*>* *outputBlob);
};

// CmsDetachedSignature
template<typename> struct CmsDetachedSignature_statics {
	static ptr<Foundation::IAsyncOperation<ptr<Storage::Streams::IBuffer>>> GenerateSignatureAsync(pptr<Storage::Streams::IInputStream> data, pptr<Foundation::Collections::IIterable<ptr<CmsSignerInfo>>> signers, pptr<Foundation::Collections::IIterable<ptr<Certificate>>> certificates) { Foundation::IAsyncOperation<Storage::Streams::IBuffer*>* outputBlob; hrcheck(get_activation_factory<CmsDetachedSignature, ICmsDetachedSignatureStatics>()->_GenerateSignatureAsync(data, to_abi(signers), to_abi(certificates), &outputBlob)); return from_abi(outputBlob); }
	static CmsDetachedSignature *activate(pptr<Storage::Streams::IBuffer> inputBlob) { CmsDetachedSignature *cmsSignedData; hrcheck(get_activation_factory<CmsDetachedSignature, ICmsDetachedSignatureFactory>()->_CreateCmsDetachedSignature(inputBlob, &cmsSignedData)); return cmsSignedData; }
};

template<typename X> struct statics<CmsDetachedSignature, X> : X, Windows::Security::Cryptography::Certificates::CmsDetachedSignature_statics<void> {
	using Windows::Security::Cryptography::Certificates::CmsDetachedSignature_statics<void>::activate;
	typedef typename X::root_type CmsDetachedSignature;
};
struct CmsDetachedSignature : generate<CmsDetachedSignature> {};
}}}}
} // namespace iso_winrt
