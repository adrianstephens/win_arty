#pragma once
// generated by isopod tools
// namespaces:
// Windows.Devices.Geolocation.Geofencing

#include "Windows.Devices.Geolocation.Geofencing.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Devices { namespace Geolocation {
struct IGeoshape;
struct Geoposition;
}}
namespace Foundation { namespace Collections {
template<typename T> struct IVector;
template<typename T> struct IVectorView;
}}}

// defs

template<> struct def<Windows::Devices::Geolocation::Geofencing::MonitoredGeofenceStates> : enum_type<unsigned> {};
template<> struct def<Windows::Devices::Geolocation::Geofencing::GeofenceState> : enum_type<unsigned> {};
template<> struct def<Windows::Devices::Geolocation::Geofencing::GeofenceMonitorStatus> : enum_type<int> {};
template<> struct def<Windows::Devices::Geolocation::Geofencing::GeofenceRemovalReason> : enum_type<int> {};
template<> struct def<Windows::Devices::Geolocation::Geofencing::IGeofenceFactory> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::Geofencing::IGeofence> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::Geofencing::Geofence> : class_type<Platform::Object, Windows::Devices::Geolocation::Geofencing::IGeofence>, custom_activators {};
template<> struct def<Windows::Devices::Geolocation::Geofencing::IGeofenceStateChangeReport> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::Geofencing::IGeofenceMonitorStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::Geofencing::IGeofenceMonitor> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::Geofencing::GeofenceMonitor> : class_type<Platform::Object, Windows::Devices::Geolocation::Geofencing::IGeofenceMonitor> {};
template<> struct def<Windows::Devices::Geolocation::Geofencing::GeofenceStateChangeReport> : class_type<Platform::Object, Windows::Devices::Geolocation::Geofencing::IGeofenceStateChangeReport> {};

// uuids

template<> struct uuid<Windows::Devices::Geolocation::Geofencing::IGeofenceFactory> { define_guid(0x841F624B, 0x325F, 0x4B90, 0xBC, 0xA7, 0x2B, 0x80, 0x22, 0xA9, 0x37, 0x96);};
template<> struct uuid<Windows::Devices::Geolocation::Geofencing::IGeofence> { define_guid(0x9C090823, 0xEDB8, 0x47E0, 0x82, 0x45, 0x5B, 0xF6, 0x1D, 0x32, 0x1F, 0x2D);};
template<> struct uuid<Windows::Devices::Geolocation::Geofencing::IGeofenceStateChangeReport> { define_guid(0x9A243C18, 0x2464, 0x4C89, 0xBE, 0x5, 0xB3, 0xFF, 0xFF, 0x5B, 0xAB, 0xC5);};
template<> struct uuid<Windows::Devices::Geolocation::Geofencing::IGeofenceMonitorStatics> { define_guid(0x2DD32FCF, 0x7E75, 0x4899, 0xAC, 0xE3, 0x2B, 0xD0, 0xA6, 0x5C, 0xCE, 0x6);};
template<> struct uuid<Windows::Devices::Geolocation::Geofencing::IGeofenceMonitor> { define_guid(0x4C0F5F78, 0x1C1F, 0x4621, 0xBB, 0xBD, 0x83, 0x3B, 0x92, 0x24, 0x72, 0x26);};

// types

namespace Windows { namespace Devices { namespace Geolocation { namespace Geofencing {

// IGeofenceFactory
struct IGeofenceFactory : IInspectable {
	virtual STDMETHODIMP _Create(HSTRING id, IGeoshape* geoshape, Geofence* *geofence);
	virtual STDMETHODIMP _CreateWithMonitorStates(HSTRING id, IGeoshape* geoshape, MonitoredGeofenceStates monitoredStates, bool singleUse, Geofence* *geofence);
	virtual STDMETHODIMP _CreateWithMonitorStatesAndDwellTime(HSTRING id, IGeoshape* geoshape, MonitoredGeofenceStates monitoredStates, bool singleUse, Foundation::TimeSpan dwellTime, Geofence* *geofence);
	virtual STDMETHODIMP _CreateWithMonitorStatesDwellTimeStartTimeAndDuration(HSTRING id, IGeoshape* geoshape, MonitoredGeofenceStates monitoredStates, bool singleUse, Foundation::TimeSpan dwellTime, Foundation::DateTime startTime, Foundation::TimeSpan duration, Geofence* *geofence);
};

// IGeofence
struct IGeofence_raw : IInspectable {
	virtual STDMETHODIMP _get_StartTime(Foundation::DateTime *value);
	virtual STDMETHODIMP _get_Duration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_DwellTime(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_Id(HSTRING *value);
	virtual STDMETHODIMP _get_MonitoredStates(MonitoredGeofenceStates *value);
	virtual STDMETHODIMP _get_Geoshape(IGeoshape* *value);
	virtual STDMETHODIMP _get_SingleUse(bool *value);
};
template<typename X> struct IGeofence_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IGeofence_adaptor::Duration)->_get_Duration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} Duration;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IGeofence_adaptor::DwellTime)->_get_DwellTime(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} DwellTime;
		struct : property {
			ptr<IGeoshape> get() { IGeoshape* value; hrcheck(enc(&IGeofence_adaptor::Geoshape)->_get_Geoshape(&value)); return from_abi(value); }
			ptr<IGeoshape> operator()() { return get(); }
			operator ptr<IGeoshape> () { return get(); }
			ptr<IGeoshape> operator->() { return get(); }
		} Geoshape;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGeofence_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
		struct : property {
			MonitoredGeofenceStates get() { MonitoredGeofenceStates value; hrcheck(enc(&IGeofence_adaptor::MonitoredStates)->_get_MonitoredStates(&value)); return value; }
			MonitoredGeofenceStates operator()() { return get(); }
			operator MonitoredGeofenceStates () { return get(); }
		} MonitoredStates;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGeofence_adaptor::SingleUse)->_get_SingleUse(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} SingleUse;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IGeofence_adaptor::StartTime)->_get_StartTime(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} StartTime;
	};
	IGeofence_adaptor() {}
};
template<typename X> struct adapt<IGeofence, X> : Windows::Devices::Geolocation::Geofencing::IGeofence_adaptor<X> { typedef adapt IGeofence; };
struct IGeofence : IGeofence_raw, generate<IGeofence> {};

// Geofence
template<typename> struct Geofence_statics {
	static Geofence *activate(hstring_ref id, pptr<IGeoshape> geoshape) { Geofence *geofence; hrcheck(get_activation_factory<Geofence, IGeofenceFactory>()->_Create(id, geoshape, &geofence)); return geofence; }
	static Geofence *activate(hstring_ref id, pptr<IGeoshape> geoshape, MonitoredGeofenceStates monitoredStates, bool singleUse) { Geofence *geofence; hrcheck(get_activation_factory<Geofence, IGeofenceFactory>()->_CreateWithMonitorStates(id, geoshape, monitoredStates, singleUse, &geofence)); return geofence; }
	static Geofence *activate(hstring_ref id, pptr<IGeoshape> geoshape, MonitoredGeofenceStates monitoredStates, bool singleUse, const Foundation::TimeSpan& dwellTime) { Geofence *geofence; hrcheck(get_activation_factory<Geofence, IGeofenceFactory>()->_CreateWithMonitorStatesAndDwellTime(id, geoshape, monitoredStates, singleUse, dwellTime, &geofence)); return geofence; }
	static Geofence *activate(hstring_ref id, pptr<IGeoshape> geoshape, MonitoredGeofenceStates monitoredStates, bool singleUse, const Foundation::TimeSpan& dwellTime, const Foundation::DateTime& startTime, const Foundation::TimeSpan& duration) { Geofence *geofence; hrcheck(get_activation_factory<Geofence, IGeofenceFactory>()->_CreateWithMonitorStatesDwellTimeStartTimeAndDuration(id, geoshape, monitoredStates, singleUse, dwellTime, startTime, duration, &geofence)); return geofence; }
};

template<typename X> struct statics<Geofence, X> : X, Windows::Devices::Geolocation::Geofencing::Geofence_statics<void> {
	using Windows::Devices::Geolocation::Geofencing::Geofence_statics<void>::activate;
	typedef typename X::root_type Geofence;
};
struct Geofence : generate<Geofence> {};

// IGeofenceStateChangeReport
struct IGeofenceStateChangeReport_raw : IInspectable {
	virtual STDMETHODIMP _get_NewState(GeofenceState *value);
	virtual STDMETHODIMP _get_Geofence(Geofencing::Geofence* *value);
	virtual STDMETHODIMP _get_Geoposition(Geolocation::Geoposition* *value);
	virtual STDMETHODIMP _get_RemovalReason(GeofenceRemovalReason *value);
};
template<typename X> struct IGeofenceStateChangeReport_adaptor : X {
	union {
		struct : property {
			ptr<Geofencing::Geofence> get() { Geofencing::Geofence* value; hrcheck(enc(&IGeofenceStateChangeReport_adaptor::Geofence)->_get_Geofence(&value)); return from_abi(value); }
			ptr<Geofencing::Geofence> operator()() { return get(); }
			operator ptr<Geofencing::Geofence> () { return get(); }
			ptr<Geofencing::Geofence> operator->() { return get(); }
		} Geofence;
		struct : property {
			ptr<Geolocation::Geoposition> get() { Geolocation::Geoposition* value; hrcheck(enc(&IGeofenceStateChangeReport_adaptor::Geoposition)->_get_Geoposition(&value)); return from_abi(value); }
			ptr<Geolocation::Geoposition> operator()() { return get(); }
			operator ptr<Geolocation::Geoposition> () { return get(); }
			ptr<Geolocation::Geoposition> operator->() { return get(); }
		} Geoposition;
		struct : property {
			GeofenceState get() { GeofenceState value; hrcheck(enc(&IGeofenceStateChangeReport_adaptor::NewState)->_get_NewState(&value)); return value; }
			GeofenceState operator()() { return get(); }
			operator GeofenceState () { return get(); }
		} NewState;
		struct : property {
			GeofenceRemovalReason get() { GeofenceRemovalReason value; hrcheck(enc(&IGeofenceStateChangeReport_adaptor::RemovalReason)->_get_RemovalReason(&value)); return value; }
			GeofenceRemovalReason operator()() { return get(); }
			operator GeofenceRemovalReason () { return get(); }
		} RemovalReason;
	};
	IGeofenceStateChangeReport_adaptor() {}
};
template<typename X> struct adapt<IGeofenceStateChangeReport, X> : Windows::Devices::Geolocation::Geofencing::IGeofenceStateChangeReport_adaptor<X> { typedef adapt IGeofenceStateChangeReport; };
struct IGeofenceStateChangeReport : IGeofenceStateChangeReport_raw, generate<IGeofenceStateChangeReport> {};

// IGeofenceMonitorStatics
struct IGeofenceMonitorStatics : IInspectable {
	virtual STDMETHODIMP _get_Current(GeofenceMonitor* *value);
};

// IGeofenceMonitor
struct IGeofenceMonitor_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(GeofenceMonitorStatus *value);
	virtual STDMETHODIMP _get_Geofences(Foundation::Collections::IVector<Geofence*>* *value);
	virtual STDMETHODIMP _get_LastKnownGeoposition(Geoposition* *value);
	virtual STDMETHODIMP _add_GeofenceStateChanged(Foundation::TypedEventHandler<GeofenceMonitor*, IInspectable*>* eventHandler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_GeofenceStateChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _ReadReports(Foundation::Collections::IVectorView<GeofenceStateChangeReport*>* *value);
	virtual STDMETHODIMP _add_StatusChanged(Foundation::TypedEventHandler<GeofenceMonitor*, IInspectable*>* eventHandler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_StatusChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IGeofenceMonitor_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<Geofence>>> get() { Foundation::Collections::IVector<Geofence*>* value; hrcheck(enc(&IGeofenceMonitor_adaptor::Geofences)->_get_Geofences(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<ptr<Geofence>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<Geofence>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<Geofence>>> operator->() { return get(); }
		} Geofences;
		struct : property {
			ptr<Geoposition> get() { Geoposition* value; hrcheck(enc(&IGeofenceMonitor_adaptor::LastKnownGeoposition)->_get_LastKnownGeoposition(&value)); return from_abi(value); }
			ptr<Geoposition> operator()() { return get(); }
			operator ptr<Geoposition> () { return get(); }
			ptr<Geoposition> operator->() { return get(); }
		} LastKnownGeoposition;
		struct : property {
			GeofenceMonitorStatus get() { GeofenceMonitorStatus value; hrcheck(enc(&IGeofenceMonitor_adaptor::Status)->_get_Status(&value)); return value; }
			GeofenceMonitorStatus operator()() { return get(); }
			operator GeofenceMonitorStatus () { return get(); }
		} Status;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<GeofenceMonitor>, object>> eventHandler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGeofenceMonitor_adaptor::GeofenceStateChanged)->_add_GeofenceStateChanged(to_abi(eventHandler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGeofenceMonitor_adaptor::GeofenceStateChanged)->_remove_GeofenceStateChanged(token)); }
		} GeofenceStateChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<GeofenceMonitor>, object>> eventHandler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGeofenceMonitor_adaptor::StatusChanged)->_add_StatusChanged(to_abi(eventHandler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGeofenceMonitor_adaptor::StatusChanged)->_remove_StatusChanged(token)); }
		} StatusChanged;
	};
	ptr<Foundation::Collections::IVectorView<ptr<GeofenceStateChangeReport>>> ReadReports() { Foundation::Collections::IVectorView<GeofenceStateChangeReport*>* value; hrcheck(X::get()->_ReadReports(&value)); return from_abi(value); }
	IGeofenceMonitor_adaptor() {}
};
template<typename X> struct adapt<IGeofenceMonitor, X> : Windows::Devices::Geolocation::Geofencing::IGeofenceMonitor_adaptor<X> { typedef adapt IGeofenceMonitor; };
struct IGeofenceMonitor : IGeofenceMonitor_raw, generate<IGeofenceMonitor> {};

// GeofenceMonitor
template<typename> struct GeofenceMonitor_statics {
	static struct _Current : property {
		ptr<GeofenceMonitor> get() { GeofenceMonitor* value; hrcheck(get_activation_factory<GeofenceMonitor, IGeofenceMonitorStatics>()->_get_Current(&value)); return from_abi(value); }
		ptr<GeofenceMonitor> operator()() { return get(); }
		operator ptr<GeofenceMonitor> () { return get(); }
		ptr<GeofenceMonitor> operator->() { return get(); }
	} Current;
};
template<typename X> typename GeofenceMonitor_statics<X>::_Current GeofenceMonitor_statics<X>::Current;

template<typename X> struct statics<GeofenceMonitor, X> : X, Windows::Devices::Geolocation::Geofencing::GeofenceMonitor_statics<void> {
	typedef typename X::root_type GeofenceMonitor;
};
struct GeofenceMonitor : generate<GeofenceMonitor> {};

// GeofenceStateChangeReport
template<typename X> struct statics<GeofenceStateChangeReport, X> : X {
	typedef typename X::root_type GeofenceStateChangeReport;
};
struct GeofenceStateChangeReport : generate<GeofenceStateChangeReport> {};
}}}}
} // namespace iso_winrt
