#pragma once
// generated by isopod tools
// namespaces:
// Windows.Perception.Spatial

#include "Windows.Perception.Spatial.0.h"
#include "Windows.Foundation.Numerics.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IIterable;
struct ValueSet;
template<typename K, typename V> struct IKeyValuePair;
template<typename K, typename V> struct IMapView;
}}
namespace Perception {
struct PerceptionTimestamp;
}
namespace Storage { namespace Streams {
struct IInputStream;
struct IOutputStream;
}}
namespace System { namespace RemoteSystems {
struct RemoteSystemSession;
}}}

// defs

template<> struct def<Windows::Perception::Spatial::ISpatialCoordinateSystem> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::SpatialCoordinateSystem> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialCoordinateSystem> {};
template<> struct def<Windows::Perception::Spatial::SpatialPerceptionAccessStatus> : enum_type<int> {};
template<> struct def<Windows::Perception::Spatial::SpatialLocatability> : enum_type<int> {};
template<> struct def<Windows::Perception::Spatial::ISpatialAnchorRawCoordinateSystemAdjustedEventArgs> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::ISpatialAnchor> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::ISpatialAnchorStatics> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::ISpatialAnchor2> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::SpatialAnchor> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialAnchor, Windows::Perception::Spatial::ISpatialAnchor2> {};
template<> struct def<Windows::Perception::Spatial::SpatialAnchorRawCoordinateSystemAdjustedEventArgs> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialAnchorRawCoordinateSystemAdjustedEventArgs> {};
template<> struct def<Windows::Perception::Spatial::ISpatialAnchorStore> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::ISpatialAnchorManagerStatics> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::SpatialAnchorStore> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialAnchorStore> {};
template<> struct def<Windows::Perception::Spatial::ISpatialAnchorTransferManagerStatics> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::ISpatialLocatorPositionalTrackingDeactivatingEventArgs> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::ISpatialLocatorAttachedFrameOfReference> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::ISpatialStationaryFrameOfReference> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::ISpatialLocation> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::ISpatialLocator> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::ISpatialLocatorStatics> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::SpatialLocator> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialLocator> {};
template<> struct def<Windows::Perception::Spatial::SpatialLocatorPositionalTrackingDeactivatingEventArgs> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialLocatorPositionalTrackingDeactivatingEventArgs> {};
template<> struct def<Windows::Perception::Spatial::SpatialLocation> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialLocation> {};
template<> struct def<Windows::Perception::Spatial::SpatialLocatorAttachedFrameOfReference> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialLocatorAttachedFrameOfReference> {};
template<> struct def<Windows::Perception::Spatial::SpatialStationaryFrameOfReference> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialStationaryFrameOfReference> {};
template<> struct def<Windows::Perception::Spatial::SpatialAnchorManager> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Perception::Spatial::SpatialAnchorTransferManager> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Perception::Spatial::SpatialBoundingFrustum> : value_type<Windows::Foundation::Numerics::Plane, Windows::Foundation::Numerics::Plane, Windows::Foundation::Numerics::Plane, Windows::Foundation::Numerics::Plane, Windows::Foundation::Numerics::Plane, Windows::Foundation::Numerics::Plane> {};
template<> struct def<Windows::Perception::Spatial::SpatialBoundingBox> : value_type<Windows::Foundation::Numerics::Vector3, Windows::Foundation::Numerics::Vector3> {};
template<> struct def<Windows::Perception::Spatial::SpatialBoundingOrientedBox> : value_type<Windows::Foundation::Numerics::Vector3, Windows::Foundation::Numerics::Vector3, Windows::Foundation::Numerics::Quaternion> {};
template<> struct def<Windows::Perception::Spatial::SpatialBoundingSphere> : value_type<Windows::Foundation::Numerics::Vector3, float> {};
template<> struct def<Windows::Perception::Spatial::ISpatialBoundingVolume> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::ISpatialBoundingVolumeStatics> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::SpatialBoundingVolume> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialBoundingVolume> {};
template<> struct def<Windows::Perception::Spatial::SpatialMovementRange> : enum_type<int> {};
template<> struct def<Windows::Perception::Spatial::SpatialLookDirectionRange> : enum_type<int> {};
template<> struct def<Windows::Perception::Spatial::ISpatialStageFrameOfReference> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::ISpatialStageFrameOfReferenceStatics> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::SpatialStageFrameOfReference> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialStageFrameOfReference> {};
template<> struct def<Windows::Perception::Spatial::ISpatialEntity> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::ISpatialEntityFactory> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::SpatialEntity> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialEntity>, custom_activators {};
template<> struct def<Windows::Perception::Spatial::SpatialEntityWatcherStatus> : enum_type<int> {};
template<> struct def<Windows::Perception::Spatial::ISpatialEntityAddedEventArgs> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::SpatialEntityAddedEventArgs> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialEntityAddedEventArgs> {};
template<> struct def<Windows::Perception::Spatial::ISpatialEntityUpdatedEventArgs> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::SpatialEntityUpdatedEventArgs> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialEntityUpdatedEventArgs> {};
template<> struct def<Windows::Perception::Spatial::ISpatialEntityRemovedEventArgs> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::SpatialEntityRemovedEventArgs> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialEntityRemovedEventArgs> {};
template<> struct def<Windows::Perception::Spatial::ISpatialEntityWatcher> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::SpatialEntityWatcher> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialEntityWatcher> {};
template<> struct def<Windows::Perception::Spatial::ISpatialEntityStore> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::ISpatialEntityStoreStatics> : interface_type<> {};
template<> struct def<Windows::Perception::Spatial::SpatialEntityStore> : class_type<Platform::Object, Windows::Perception::Spatial::ISpatialEntityStore> {};

// uuids

template<> struct uuid<Windows::Perception::Spatial::ISpatialCoordinateSystem> { define_guid(0x69EBCA4B, 0x60A3, 0x3586, 0xA6, 0x53, 0x59, 0xA7, 0xBD, 0x67, 0x6D, 0x7);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialAnchorRawCoordinateSystemAdjustedEventArgs> { define_guid(0xA1E81EB8, 0x56C7, 0x3117, 0xA2, 0xE4, 0x81, 0xE0, 0xFC, 0xF2, 0x8E, 0x0);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialAnchor> { define_guid(0x529E5CE, 0x1D34, 0x3702, 0xBC, 0xEC, 0xEA, 0xBF, 0xF5, 0x78, 0xA8, 0x69);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialAnchorStatics> { define_guid(0xA9928642, 0x174, 0x311C, 0xAE, 0x79, 0xE, 0x51, 0x7, 0x66, 0x9F, 0x16);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialAnchor2> { define_guid(0xED17C908, 0xA695, 0x4CF6, 0x92, 0xFD, 0x97, 0x26, 0x3B, 0xA7, 0x10, 0x47);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialAnchorStore> { define_guid(0xB0BC3636, 0x486A, 0x3CB0, 0x9E, 0x6F, 0x12, 0x45, 0x16, 0x5C, 0x4D, 0xB6);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialAnchorManagerStatics> { define_guid(0x88E30EAB, 0xF3B7, 0x420B, 0xB0, 0x86, 0x8A, 0x80, 0xC0, 0x7D, 0x91, 0xD);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialAnchorTransferManagerStatics> { define_guid(0x3BBF9B9, 0x12D8, 0x4BCE, 0x88, 0x35, 0xC5, 0xDF, 0x3A, 0xC0, 0xAD, 0xAB);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialLocatorPositionalTrackingDeactivatingEventArgs> { define_guid(0xB8A84063, 0xE3F4, 0x368B, 0x90, 0x61, 0x9E, 0xA9, 0xD1, 0xD6, 0xCC, 0x16);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialLocatorAttachedFrameOfReference> { define_guid(0xE1774EF6, 0x1F4F, 0x499C, 0x96, 0x25, 0xEF, 0x5E, 0x6E, 0xD7, 0xA0, 0x48);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialStationaryFrameOfReference> { define_guid(0x9DBCCB9, 0xBCF8, 0x3E7F, 0xBE, 0x7E, 0x7E, 0xDC, 0xCB, 0xB1, 0x78, 0xA8);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialLocation> { define_guid(0x1D81D29D, 0x24A1, 0x37D5, 0x8F, 0xA1, 0x39, 0xB4, 0xF9, 0xAD, 0x67, 0xE2);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialLocator> { define_guid(0xF6478925, 0x9E0C, 0x3BB6, 0x99, 0x7E, 0xB6, 0x4E, 0xCC, 0xA2, 0x4C, 0xF4);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialLocatorStatics> { define_guid(0xB76E3340, 0xA7C2, 0x361B, 0xBB, 0x82, 0x56, 0xE9, 0x3B, 0x89, 0xB1, 0xBB);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialBoundingVolume> { define_guid(0xFB2065DA, 0x68C3, 0x33DF, 0xB7, 0xAF, 0x4C, 0x78, 0x72, 0x7, 0x99, 0x9C);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialBoundingVolumeStatics> { define_guid(0x5889117, 0xB3E1, 0x36D8, 0xB0, 0x17, 0x56, 0x61, 0x81, 0xA5, 0xB1, 0x96);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialStageFrameOfReference> { define_guid(0x7A8A3464, 0xAD0D, 0x4590, 0xAB, 0x86, 0x33, 0x6, 0x2B, 0x67, 0x49, 0x26);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialStageFrameOfReferenceStatics> { define_guid(0xF78D5C4D, 0xA0A4, 0x499C, 0x8D, 0x91, 0xA8, 0xC9, 0x65, 0xD4, 0x6, 0x54);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialEntity> { define_guid(0x166DE955, 0xE1EB, 0x454C, 0xBA, 0x8, 0xE6, 0xC0, 0x66, 0x8D, 0xDC, 0x65);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialEntityFactory> { define_guid(0xE1F1E325, 0x349F, 0x4225, 0xA2, 0xF3, 0x4B, 0x1, 0xC1, 0x5F, 0xE0, 0x56);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialEntityAddedEventArgs> { define_guid(0xA397F49B, 0x156A, 0x4707, 0xAC, 0x2C, 0xD3, 0x1D, 0x57, 0xE, 0xD3, 0x99);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialEntityUpdatedEventArgs> { define_guid(0xE5671766, 0x627B, 0x43CB, 0xA4, 0x9F, 0xB3, 0xBE, 0x6D, 0x47, 0xDE, 0xED);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialEntityRemovedEventArgs> { define_guid(0x91741800, 0x536D, 0x4E9F, 0xAB, 0xF6, 0x41, 0x5B, 0x54, 0x44, 0xD6, 0x51);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialEntityWatcher> { define_guid(0xB3B85FA0, 0x6D5E, 0x4BBC, 0x80, 0x5D, 0x5F, 0xE5, 0xB9, 0xBA, 0x19, 0x59);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialEntityStore> { define_guid(0x329788BA, 0xE513, 0x4F06, 0x88, 0x9D, 0x1B, 0xE3, 0xE, 0xCF, 0x43, 0xE6);};
template<> struct uuid<Windows::Perception::Spatial::ISpatialEntityStoreStatics> { define_guid(0x6B4B389E, 0x7C50, 0x4E92, 0x8A, 0x62, 0x4D, 0x1D, 0x4B, 0x7C, 0xCD, 0x3E);};

// types

namespace Windows { namespace Perception { namespace Spatial {

// ISpatialCoordinateSystem
struct ISpatialCoordinateSystem_raw : IInspectable {
	virtual STDMETHODIMP _TryGetTransformTo(SpatialCoordinateSystem* target, Foundation::IReference<Foundation::Numerics::Matrix4x4>* *value);
};
template<typename X> struct ISpatialCoordinateSystem_adaptor : X {
	ptr<Foundation::IReference<Foundation::Numerics::Matrix4x4>> TryGetTransformTo(pptr<SpatialCoordinateSystem> target) { Foundation::IReference<Foundation::Numerics::Matrix4x4>* value; hrcheck(X::get()->_TryGetTransformTo(target, &value)); return from_abi(value); }
};
template<typename X> struct adapt<ISpatialCoordinateSystem, X> : Windows::Perception::Spatial::ISpatialCoordinateSystem_adaptor<X> { typedef adapt ISpatialCoordinateSystem; };
struct ISpatialCoordinateSystem : ISpatialCoordinateSystem_raw, generate<ISpatialCoordinateSystem> {};

// SpatialCoordinateSystem
template<typename X> struct statics<SpatialCoordinateSystem, X> : X {
	typedef typename X::root_type SpatialCoordinateSystem;
};
struct SpatialCoordinateSystem : generate<SpatialCoordinateSystem> {};

// ISpatialAnchorRawCoordinateSystemAdjustedEventArgs
struct ISpatialAnchorRawCoordinateSystemAdjustedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_OldRawCoordinateSystemToNewRawCoordinateSystemTransform(Foundation::Numerics::Matrix4x4 *value);
};
template<typename X> struct ISpatialAnchorRawCoordinateSystemAdjustedEventArgs_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Matrix4x4 get() { Foundation::Numerics::Matrix4x4 value; hrcheck(enc(&ISpatialAnchorRawCoordinateSystemAdjustedEventArgs_adaptor::OldRawCoordinateSystemToNewRawCoordinateSystemTransform)->_get_OldRawCoordinateSystemToNewRawCoordinateSystemTransform(&value)); return value; }
			Foundation::Numerics::Matrix4x4 operator()() { return get(); }
			operator Foundation::Numerics::Matrix4x4 () { return get(); }
		} OldRawCoordinateSystemToNewRawCoordinateSystemTransform;
	};
	ISpatialAnchorRawCoordinateSystemAdjustedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISpatialAnchorRawCoordinateSystemAdjustedEventArgs, X> : Windows::Perception::Spatial::ISpatialAnchorRawCoordinateSystemAdjustedEventArgs_adaptor<X> { typedef adapt ISpatialAnchorRawCoordinateSystemAdjustedEventArgs; };
struct ISpatialAnchorRawCoordinateSystemAdjustedEventArgs : ISpatialAnchorRawCoordinateSystemAdjustedEventArgs_raw, generate<ISpatialAnchorRawCoordinateSystemAdjustedEventArgs> {};

// ISpatialAnchor
struct ISpatialAnchor_raw : IInspectable {
	virtual STDMETHODIMP _get_CoordinateSystem(SpatialCoordinateSystem* *value);
	virtual STDMETHODIMP _get_RawCoordinateSystem(SpatialCoordinateSystem* *value);
	virtual STDMETHODIMP _add_RawCoordinateSystemAdjusted(Foundation::TypedEventHandler<SpatialAnchor*, SpatialAnchorRawCoordinateSystemAdjustedEventArgs*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_RawCoordinateSystemAdjusted(Foundation::EventRegistrationToken cookie);
};
template<typename X> struct ISpatialAnchor_adaptor : X {
	union {
		struct : property {
			ptr<SpatialCoordinateSystem> get() { SpatialCoordinateSystem* value; hrcheck(enc(&ISpatialAnchor_adaptor::CoordinateSystem)->_get_CoordinateSystem(&value)); return from_abi(value); }
			ptr<SpatialCoordinateSystem> operator()() { return get(); }
			operator ptr<SpatialCoordinateSystem> () { return get(); }
			ptr<SpatialCoordinateSystem> operator->() { return get(); }
		} CoordinateSystem;
		struct : property {
			ptr<SpatialCoordinateSystem> get() { SpatialCoordinateSystem* value; hrcheck(enc(&ISpatialAnchor_adaptor::RawCoordinateSystem)->_get_RawCoordinateSystem(&value)); return from_abi(value); }
			ptr<SpatialCoordinateSystem> operator()() { return get(); }
			operator ptr<SpatialCoordinateSystem> () { return get(); }
			ptr<SpatialCoordinateSystem> operator->() { return get(); }
		} RawCoordinateSystem;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SpatialAnchor>, ptr<SpatialAnchorRawCoordinateSystemAdjustedEventArgs>>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(enc(&ISpatialAnchor_adaptor::RawCoordinateSystemAdjusted)->_add_RawCoordinateSystemAdjusted(to_abi(handler), &cookie)); return cookie; }
			void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(enc(&ISpatialAnchor_adaptor::RawCoordinateSystemAdjusted)->_remove_RawCoordinateSystemAdjusted(cookie)); }
		} RawCoordinateSystemAdjusted;
	};
	ISpatialAnchor_adaptor() {}
};
template<typename X> struct adapt<ISpatialAnchor, X> : Windows::Perception::Spatial::ISpatialAnchor_adaptor<X> { typedef adapt ISpatialAnchor; };
struct ISpatialAnchor : ISpatialAnchor_raw, generate<ISpatialAnchor> {};

// ISpatialAnchorStatics
struct ISpatialAnchorStatics : IInspectable {
	virtual STDMETHODIMP _TryCreateRelativeTo(SpatialCoordinateSystem* coordinateSystem, SpatialAnchor* *value);
	virtual STDMETHODIMP _TryCreateWithPositionRelativeTo(SpatialCoordinateSystem* coordinateSystem, Foundation::Numerics::Vector3 position, SpatialAnchor* *value);
	virtual STDMETHODIMP _TryCreateWithPositionAndOrientationRelativeTo(SpatialCoordinateSystem* coordinateSystem, Foundation::Numerics::Vector3 position, Foundation::Numerics::Quaternion orientation, SpatialAnchor* *value);
};

// ISpatialAnchor2
struct ISpatialAnchor2_raw : IInspectable {
	virtual STDMETHODIMP _get_RemovedByUser(bool *value);
};
template<typename X> struct ISpatialAnchor2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISpatialAnchor2_adaptor::RemovedByUser)->_get_RemovedByUser(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} RemovedByUser;
	};
	ISpatialAnchor2_adaptor() {}
};
template<typename X> struct adapt<ISpatialAnchor2, X> : Windows::Perception::Spatial::ISpatialAnchor2_adaptor<X> { typedef adapt ISpatialAnchor2; };
struct ISpatialAnchor2 : ISpatialAnchor2_raw, generate<ISpatialAnchor2> {};

// SpatialAnchor
template<typename> struct SpatialAnchor_statics {
	static ptr<SpatialAnchor> TryCreateRelativeTo(pptr<SpatialCoordinateSystem> coordinateSystem) { SpatialAnchor* value; hrcheck(get_activation_factory<SpatialAnchor, ISpatialAnchorStatics>()->_TryCreateRelativeTo(coordinateSystem, &value)); return from_abi(value); }
	static ptr<SpatialAnchor> TryCreateRelativeTo(pptr<SpatialCoordinateSystem> coordinateSystem, const Foundation::Numerics::Vector3& position) { SpatialAnchor* value; hrcheck(get_activation_factory<SpatialAnchor, ISpatialAnchorStatics>()->_TryCreateWithPositionRelativeTo(coordinateSystem, position, &value)); return from_abi(value); }
	static ptr<SpatialAnchor> TryCreateRelativeTo(pptr<SpatialCoordinateSystem> coordinateSystem, const Foundation::Numerics::Vector3& position, const Foundation::Numerics::Quaternion& orientation) { SpatialAnchor* value; hrcheck(get_activation_factory<SpatialAnchor, ISpatialAnchorStatics>()->_TryCreateWithPositionAndOrientationRelativeTo(coordinateSystem, position, orientation, &value)); return from_abi(value); }
};

template<typename X> struct statics<SpatialAnchor, X> : X, Windows::Perception::Spatial::SpatialAnchor_statics<void> {
	typedef typename X::root_type SpatialAnchor;
};
struct SpatialAnchor : generate<SpatialAnchor> {};

// SpatialAnchorRawCoordinateSystemAdjustedEventArgs
template<typename X> struct statics<SpatialAnchorRawCoordinateSystemAdjustedEventArgs, X> : X {
	typedef typename X::root_type SpatialAnchorRawCoordinateSystemAdjustedEventArgs;
};
struct SpatialAnchorRawCoordinateSystemAdjustedEventArgs : generate<SpatialAnchorRawCoordinateSystemAdjustedEventArgs> {};

// ISpatialAnchorStore
struct ISpatialAnchorStore_raw : IInspectable {
	virtual STDMETHODIMP _GetAllSavedAnchors(Foundation::Collections::IMapView<HSTRING, SpatialAnchor*>* *value);
	virtual STDMETHODIMP _TrySave(HSTRING id, SpatialAnchor* anchor, bool *succeeded);
	virtual STDMETHODIMP _Remove(HSTRING id);
	virtual STDMETHODIMP _Clear();
};
template<typename X> struct ISpatialAnchorStore_adaptor : X {
	ptr<Foundation::Collections::IMapView<hstring, ptr<SpatialAnchor>>> GetAllSavedAnchors() { Foundation::Collections::IMapView<HSTRING, SpatialAnchor*>* value; hrcheck(X::get()->_GetAllSavedAnchors(&value)); return from_abi(value); }
	bool TrySave(hstring_ref id, pptr<SpatialAnchor> anchor) { bool succeeded; hrcheck(X::get()->_TrySave(id, anchor, &succeeded)); return succeeded; }
	void Remove(hstring_ref id) { hrcheck(X::get()->_Remove(id)); }
	void Clear() { hrcheck(X::get()->_Clear()); }
};
template<typename X> struct adapt<ISpatialAnchorStore, X> : Windows::Perception::Spatial::ISpatialAnchorStore_adaptor<X> { typedef adapt ISpatialAnchorStore; };
struct ISpatialAnchorStore : ISpatialAnchorStore_raw, generate<ISpatialAnchorStore> {};

// ISpatialAnchorManagerStatics
struct ISpatialAnchorManagerStatics : IInspectable {
	virtual STDMETHODIMP _RequestStoreAsync(Foundation::IAsyncOperation<SpatialAnchorStore*>* *value);
};

// SpatialAnchorStore
template<typename X> struct statics<SpatialAnchorStore, X> : X {
	typedef typename X::root_type SpatialAnchorStore;
};
struct SpatialAnchorStore : generate<SpatialAnchorStore> {};

// ISpatialAnchorTransferManagerStatics
struct ISpatialAnchorTransferManagerStatics : IInspectable {
	virtual STDMETHODIMP _TryImportAnchorsAsync(Storage::Streams::IInputStream* stream, Foundation::IAsyncOperation<Foundation::Collections::IMapView<HSTRING, SpatialAnchor*>*>* *operation);
	virtual STDMETHODIMP _TryExportAnchorsAsync(Foundation::Collections::IIterable<Foundation::Collections::IKeyValuePair<HSTRING, SpatialAnchor*>*>* anchors, Storage::Streams::IOutputStream* stream, Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _RequestAccessAsync(Foundation::IAsyncOperation<SpatialPerceptionAccessStatus>* *result);
};

// ISpatialLocatorPositionalTrackingDeactivatingEventArgs
struct ISpatialLocatorPositionalTrackingDeactivatingEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Canceled(bool *value);
	virtual STDMETHODIMP _put_Canceled(bool value);
};
template<typename X> struct ISpatialLocatorPositionalTrackingDeactivatingEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISpatialLocatorPositionalTrackingDeactivatingEventArgs_adaptor::Canceled)->_get_Canceled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ISpatialLocatorPositionalTrackingDeactivatingEventArgs_adaptor::Canceled)->_put_Canceled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Canceled;
	};
	ISpatialLocatorPositionalTrackingDeactivatingEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISpatialLocatorPositionalTrackingDeactivatingEventArgs, X> : Windows::Perception::Spatial::ISpatialLocatorPositionalTrackingDeactivatingEventArgs_adaptor<X> { typedef adapt ISpatialLocatorPositionalTrackingDeactivatingEventArgs; };
struct ISpatialLocatorPositionalTrackingDeactivatingEventArgs : ISpatialLocatorPositionalTrackingDeactivatingEventArgs_raw, generate<ISpatialLocatorPositionalTrackingDeactivatingEventArgs> {};

// ISpatialLocatorAttachedFrameOfReference
struct ISpatialLocatorAttachedFrameOfReference_raw : IInspectable {
	virtual STDMETHODIMP _get_RelativePosition(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _put_RelativePosition(Foundation::Numerics::Vector3 value);
	virtual STDMETHODIMP _get_RelativeOrientation(Foundation::Numerics::Quaternion *value);
	virtual STDMETHODIMP _put_RelativeOrientation(Foundation::Numerics::Quaternion value);
	virtual STDMETHODIMP _AdjustHeading(double headingOffsetInRadians);
	virtual STDMETHODIMP _GetStationaryCoordinateSystemAtTimestamp(PerceptionTimestamp* timestamp, SpatialCoordinateSystem* *value);
	virtual STDMETHODIMP _TryGetRelativeHeadingAtTimestamp(PerceptionTimestamp* timestamp, Foundation::IReference<double>* *value);
};
template<typename X> struct ISpatialLocatorAttachedFrameOfReference_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Quaternion get() { Foundation::Numerics::Quaternion value; hrcheck(enc(&ISpatialLocatorAttachedFrameOfReference_adaptor::RelativeOrientation)->_get_RelativeOrientation(&value)); return value; }
			Foundation::Numerics::Quaternion operator()() { return get(); }
			operator Foundation::Numerics::Quaternion () { return get(); }
			void put(const Foundation::Numerics::Quaternion& value) { hrcheck(enc(&ISpatialLocatorAttachedFrameOfReference_adaptor::RelativeOrientation)->_put_RelativeOrientation(value)); }
			void operator=(const Foundation::Numerics::Quaternion& value) { put(value); }
			void operator()(const Foundation::Numerics::Quaternion& value) { put(value); }
		} RelativeOrientation;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&ISpatialLocatorAttachedFrameOfReference_adaptor::RelativePosition)->_get_RelativePosition(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
			void put(const Foundation::Numerics::Vector3& value) { hrcheck(enc(&ISpatialLocatorAttachedFrameOfReference_adaptor::RelativePosition)->_put_RelativePosition(value)); }
			void operator=(const Foundation::Numerics::Vector3& value) { put(value); }
			void operator()(const Foundation::Numerics::Vector3& value) { put(value); }
		} RelativePosition;
	};
	void AdjustHeading(double headingOffsetInRadians) { hrcheck(X::get()->_AdjustHeading(headingOffsetInRadians)); }
	ptr<SpatialCoordinateSystem> GetStationaryCoordinateSystemAtTimestamp(pptr<PerceptionTimestamp> timestamp) { SpatialCoordinateSystem* value; hrcheck(X::get()->_GetStationaryCoordinateSystemAtTimestamp(timestamp, &value)); return from_abi(value); }
	ptr<Foundation::IReference<double>> TryGetRelativeHeadingAtTimestamp(pptr<PerceptionTimestamp> timestamp) { Foundation::IReference<double>* value; hrcheck(X::get()->_TryGetRelativeHeadingAtTimestamp(timestamp, &value)); return from_abi(value); }
	ISpatialLocatorAttachedFrameOfReference_adaptor() {}
};
template<typename X> struct adapt<ISpatialLocatorAttachedFrameOfReference, X> : Windows::Perception::Spatial::ISpatialLocatorAttachedFrameOfReference_adaptor<X> { typedef adapt ISpatialLocatorAttachedFrameOfReference; };
struct ISpatialLocatorAttachedFrameOfReference : ISpatialLocatorAttachedFrameOfReference_raw, generate<ISpatialLocatorAttachedFrameOfReference> {};

// ISpatialStationaryFrameOfReference
struct ISpatialStationaryFrameOfReference_raw : IInspectable {
	virtual STDMETHODIMP _get_CoordinateSystem(SpatialCoordinateSystem* *value);
};
template<typename X> struct ISpatialStationaryFrameOfReference_adaptor : X {
	union {
		struct : property {
			ptr<SpatialCoordinateSystem> get() { SpatialCoordinateSystem* value; hrcheck(enc(&ISpatialStationaryFrameOfReference_adaptor::CoordinateSystem)->_get_CoordinateSystem(&value)); return from_abi(value); }
			ptr<SpatialCoordinateSystem> operator()() { return get(); }
			operator ptr<SpatialCoordinateSystem> () { return get(); }
			ptr<SpatialCoordinateSystem> operator->() { return get(); }
		} CoordinateSystem;
	};
	ISpatialStationaryFrameOfReference_adaptor() {}
};
template<typename X> struct adapt<ISpatialStationaryFrameOfReference, X> : Windows::Perception::Spatial::ISpatialStationaryFrameOfReference_adaptor<X> { typedef adapt ISpatialStationaryFrameOfReference; };
struct ISpatialStationaryFrameOfReference : ISpatialStationaryFrameOfReference_raw, generate<ISpatialStationaryFrameOfReference> {};

// ISpatialLocation
struct ISpatialLocation_raw : IInspectable {
	virtual STDMETHODIMP _get_Position(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _get_Orientation(Foundation::Numerics::Quaternion *value);
	virtual STDMETHODIMP _get_AbsoluteLinearVelocity(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _get_AbsoluteLinearAcceleration(Foundation::Numerics::Vector3 *value);
	virtual STDMETHODIMP _get_AbsoluteAngularVelocity(Foundation::Numerics::Quaternion *value);
	virtual STDMETHODIMP _get_AbsoluteAngularAcceleration(Foundation::Numerics::Quaternion *value);
};
template<typename X> struct ISpatialLocation_adaptor : X {
	union {
		struct : property {
			Foundation::Numerics::Quaternion get() { Foundation::Numerics::Quaternion value; hrcheck(enc(&ISpatialLocation_adaptor::AbsoluteAngularAcceleration)->_get_AbsoluteAngularAcceleration(&value)); return value; }
			Foundation::Numerics::Quaternion operator()() { return get(); }
			operator Foundation::Numerics::Quaternion () { return get(); }
		} AbsoluteAngularAcceleration;
		struct : property {
			Foundation::Numerics::Quaternion get() { Foundation::Numerics::Quaternion value; hrcheck(enc(&ISpatialLocation_adaptor::AbsoluteAngularVelocity)->_get_AbsoluteAngularVelocity(&value)); return value; }
			Foundation::Numerics::Quaternion operator()() { return get(); }
			operator Foundation::Numerics::Quaternion () { return get(); }
		} AbsoluteAngularVelocity;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&ISpatialLocation_adaptor::AbsoluteLinearAcceleration)->_get_AbsoluteLinearAcceleration(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
		} AbsoluteLinearAcceleration;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&ISpatialLocation_adaptor::AbsoluteLinearVelocity)->_get_AbsoluteLinearVelocity(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
		} AbsoluteLinearVelocity;
		struct : property {
			Foundation::Numerics::Quaternion get() { Foundation::Numerics::Quaternion value; hrcheck(enc(&ISpatialLocation_adaptor::Orientation)->_get_Orientation(&value)); return value; }
			Foundation::Numerics::Quaternion operator()() { return get(); }
			operator Foundation::Numerics::Quaternion () { return get(); }
		} Orientation;
		struct : property {
			Foundation::Numerics::Vector3 get() { Foundation::Numerics::Vector3 value; hrcheck(enc(&ISpatialLocation_adaptor::Position)->_get_Position(&value)); return value; }
			Foundation::Numerics::Vector3 operator()() { return get(); }
			operator Foundation::Numerics::Vector3 () { return get(); }
		} Position;
	};
	ISpatialLocation_adaptor() {}
};
template<typename X> struct adapt<ISpatialLocation, X> : Windows::Perception::Spatial::ISpatialLocation_adaptor<X> { typedef adapt ISpatialLocation; };
struct ISpatialLocation : ISpatialLocation_raw, generate<ISpatialLocation> {};

// ISpatialLocator
struct ISpatialLocator_raw : IInspectable {
	virtual STDMETHODIMP _get_Locatability(SpatialLocatability *value);
	virtual STDMETHODIMP _add_LocatabilityChanged(Foundation::TypedEventHandler<SpatialLocator*, IInspectable*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_LocatabilityChanged(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _add_PositionalTrackingDeactivating(Foundation::TypedEventHandler<SpatialLocator*, SpatialLocatorPositionalTrackingDeactivatingEventArgs*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_PositionalTrackingDeactivating(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _TryLocateAtTimestamp(PerceptionTimestamp* timestamp, SpatialCoordinateSystem* coordinateSystem, SpatialLocation* *value);
	virtual STDMETHODIMP _CreateAttachedFrameOfReferenceAtCurrentHeading(SpatialLocatorAttachedFrameOfReference* *value);
	virtual STDMETHODIMP _CreateAttachedFrameOfReferenceAtCurrentHeadingWithPosition(Foundation::Numerics::Vector3 relativePosition, SpatialLocatorAttachedFrameOfReference* *value);
	virtual STDMETHODIMP _CreateAttachedFrameOfReferenceAtCurrentHeadingWithPositionAndOrientation(Foundation::Numerics::Vector3 relativePosition, Foundation::Numerics::Quaternion relativeOrientation, SpatialLocatorAttachedFrameOfReference* *value);
	virtual STDMETHODIMP _CreateAttachedFrameOfReferenceAtCurrentHeadingWithPositionAndOrientationAndRelativeHeading(Foundation::Numerics::Vector3 relativePosition, Foundation::Numerics::Quaternion relativeOrientation, double relativeHeadingInRadians, SpatialLocatorAttachedFrameOfReference* *value);
	virtual STDMETHODIMP _CreateStationaryFrameOfReferenceAtCurrentLocation(SpatialStationaryFrameOfReference* *value);
	virtual STDMETHODIMP _CreateStationaryFrameOfReferenceAtCurrentLocationWithPosition(Foundation::Numerics::Vector3 relativePosition, SpatialStationaryFrameOfReference* *value);
	virtual STDMETHODIMP _CreateStationaryFrameOfReferenceAtCurrentLocationWithPositionAndOrientation(Foundation::Numerics::Vector3 relativePosition, Foundation::Numerics::Quaternion relativeOrientation, SpatialStationaryFrameOfReference* *value);
	virtual STDMETHODIMP _CreateStationaryFrameOfReferenceAtCurrentLocationWithPositionAndOrientationAndRelativeHeading(Foundation::Numerics::Vector3 relativePosition, Foundation::Numerics::Quaternion relativeOrientation, double relativeHeadingInRadians, SpatialStationaryFrameOfReference* *value);
};
template<typename X> struct ISpatialLocator_adaptor : X {
	union {
		struct : property {
			SpatialLocatability get() { SpatialLocatability value; hrcheck(enc(&ISpatialLocator_adaptor::Locatability)->_get_Locatability(&value)); return value; }
			SpatialLocatability operator()() { return get(); }
			operator SpatialLocatability () { return get(); }
		} Locatability;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SpatialLocator>, object>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(enc(&ISpatialLocator_adaptor::LocatabilityChanged)->_add_LocatabilityChanged(to_abi(handler), &cookie)); return cookie; }
			void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(enc(&ISpatialLocator_adaptor::LocatabilityChanged)->_remove_LocatabilityChanged(cookie)); }
		} LocatabilityChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SpatialLocator>, ptr<SpatialLocatorPositionalTrackingDeactivatingEventArgs>>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(enc(&ISpatialLocator_adaptor::PositionalTrackingDeactivating)->_add_PositionalTrackingDeactivating(to_abi(handler), &cookie)); return cookie; }
			void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(enc(&ISpatialLocator_adaptor::PositionalTrackingDeactivating)->_remove_PositionalTrackingDeactivating(cookie)); }
		} PositionalTrackingDeactivating;
	};
	ptr<SpatialLocation> TryLocateAtTimestamp(pptr<PerceptionTimestamp> timestamp, pptr<SpatialCoordinateSystem> coordinateSystem) { SpatialLocation* value; hrcheck(X::get()->_TryLocateAtTimestamp(timestamp, coordinateSystem, &value)); return from_abi(value); }
	ptr<SpatialLocatorAttachedFrameOfReference> CreateAttachedFrameOfReferenceAtCurrentHeading() { SpatialLocatorAttachedFrameOfReference* value; hrcheck(X::get()->_CreateAttachedFrameOfReferenceAtCurrentHeading(&value)); return from_abi(value); }
	ptr<SpatialLocatorAttachedFrameOfReference> CreateAttachedFrameOfReferenceAtCurrentHeading(const Foundation::Numerics::Vector3& relativePosition) { SpatialLocatorAttachedFrameOfReference* value; hrcheck(X::get()->_CreateAttachedFrameOfReferenceAtCurrentHeadingWithPosition(relativePosition, &value)); return from_abi(value); }
	ptr<SpatialLocatorAttachedFrameOfReference> CreateAttachedFrameOfReferenceAtCurrentHeading(const Foundation::Numerics::Vector3& relativePosition, const Foundation::Numerics::Quaternion& relativeOrientation) { SpatialLocatorAttachedFrameOfReference* value; hrcheck(X::get()->_CreateAttachedFrameOfReferenceAtCurrentHeadingWithPositionAndOrientation(relativePosition, relativeOrientation, &value)); return from_abi(value); }
	ptr<SpatialLocatorAttachedFrameOfReference> CreateAttachedFrameOfReferenceAtCurrentHeading(const Foundation::Numerics::Vector3& relativePosition, const Foundation::Numerics::Quaternion& relativeOrientation, double relativeHeadingInRadians) { SpatialLocatorAttachedFrameOfReference* value; hrcheck(X::get()->_CreateAttachedFrameOfReferenceAtCurrentHeadingWithPositionAndOrientationAndRelativeHeading(relativePosition, relativeOrientation, relativeHeadingInRadians, &value)); return from_abi(value); }
	ptr<SpatialStationaryFrameOfReference> CreateStationaryFrameOfReferenceAtCurrentLocation() { SpatialStationaryFrameOfReference* value; hrcheck(X::get()->_CreateStationaryFrameOfReferenceAtCurrentLocation(&value)); return from_abi(value); }
	ptr<SpatialStationaryFrameOfReference> CreateStationaryFrameOfReferenceAtCurrentLocation(const Foundation::Numerics::Vector3& relativePosition) { SpatialStationaryFrameOfReference* value; hrcheck(X::get()->_CreateStationaryFrameOfReferenceAtCurrentLocationWithPosition(relativePosition, &value)); return from_abi(value); }
	ptr<SpatialStationaryFrameOfReference> CreateStationaryFrameOfReferenceAtCurrentLocation(const Foundation::Numerics::Vector3& relativePosition, const Foundation::Numerics::Quaternion& relativeOrientation) { SpatialStationaryFrameOfReference* value; hrcheck(X::get()->_CreateStationaryFrameOfReferenceAtCurrentLocationWithPositionAndOrientation(relativePosition, relativeOrientation, &value)); return from_abi(value); }
	ptr<SpatialStationaryFrameOfReference> CreateStationaryFrameOfReferenceAtCurrentLocation(const Foundation::Numerics::Vector3& relativePosition, const Foundation::Numerics::Quaternion& relativeOrientation, double relativeHeadingInRadians) { SpatialStationaryFrameOfReference* value; hrcheck(X::get()->_CreateStationaryFrameOfReferenceAtCurrentLocationWithPositionAndOrientationAndRelativeHeading(relativePosition, relativeOrientation, relativeHeadingInRadians, &value)); return from_abi(value); }
	ISpatialLocator_adaptor() {}
};
template<typename X> struct adapt<ISpatialLocator, X> : Windows::Perception::Spatial::ISpatialLocator_adaptor<X> { typedef adapt ISpatialLocator; };
struct ISpatialLocator : ISpatialLocator_raw, generate<ISpatialLocator> {};

// ISpatialLocatorStatics
struct ISpatialLocatorStatics : IInspectable {
	virtual STDMETHODIMP _GetDefault(SpatialLocator* *value);
};

// SpatialLocator
template<typename> struct SpatialLocator_statics {
	static ptr<SpatialLocator> GetDefault() { SpatialLocator* value; hrcheck(get_activation_factory<SpatialLocator, ISpatialLocatorStatics>()->_GetDefault(&value)); return from_abi(value); }
};

template<typename X> struct statics<SpatialLocator, X> : X, Windows::Perception::Spatial::SpatialLocator_statics<void> {
	typedef typename X::root_type SpatialLocator;
};
struct SpatialLocator : generate<SpatialLocator> {
	using ISpatialLocator::CreateStationaryFrameOfReferenceAtCurrentLocation;
	using ISpatialLocator::CreateAttachedFrameOfReferenceAtCurrentHeading;
};

// SpatialLocatorPositionalTrackingDeactivatingEventArgs
template<typename X> struct statics<SpatialLocatorPositionalTrackingDeactivatingEventArgs, X> : X {
	typedef typename X::root_type SpatialLocatorPositionalTrackingDeactivatingEventArgs;
};
struct SpatialLocatorPositionalTrackingDeactivatingEventArgs : generate<SpatialLocatorPositionalTrackingDeactivatingEventArgs> {};

// SpatialLocation
template<typename X> struct statics<SpatialLocation, X> : X {
	typedef typename X::root_type SpatialLocation;
};
struct SpatialLocation : generate<SpatialLocation> {};

// SpatialLocatorAttachedFrameOfReference
template<typename X> struct statics<SpatialLocatorAttachedFrameOfReference, X> : X {
	typedef typename X::root_type SpatialLocatorAttachedFrameOfReference;
};
struct SpatialLocatorAttachedFrameOfReference : generate<SpatialLocatorAttachedFrameOfReference> {};

// SpatialStationaryFrameOfReference
template<typename X> struct statics<SpatialStationaryFrameOfReference, X> : X {
	typedef typename X::root_type SpatialStationaryFrameOfReference;
};
struct SpatialStationaryFrameOfReference : generate<SpatialStationaryFrameOfReference> {};

// SpatialAnchorManager
template<typename> struct SpatialAnchorManager_statics {
	static ptr<Foundation::IAsyncOperation<ptr<SpatialAnchorStore>>> RequestStoreAsync() { Foundation::IAsyncOperation<SpatialAnchorStore*>* value; hrcheck(get_activation_factory<SpatialAnchorManager, ISpatialAnchorManagerStatics>()->_RequestStoreAsync(&value)); return from_abi(value); }
};

template<typename X> struct statics<SpatialAnchorManager, X> : X, Windows::Perception::Spatial::SpatialAnchorManager_statics<void> {
	typedef typename X::root_type SpatialAnchorManager;
};
struct SpatialAnchorManager : generate<SpatialAnchorManager> {};

// SpatialAnchorTransferManager
template<typename> struct SpatialAnchorTransferManager_statics {
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IMapView<hstring, ptr<SpatialAnchor>>>>> TryImportAnchorsAsync(pptr<Storage::Streams::IInputStream> stream) { Foundation::IAsyncOperation<Foundation::Collections::IMapView<HSTRING, SpatialAnchor*>*>* operation; hrcheck(get_activation_factory<SpatialAnchorTransferManager, ISpatialAnchorTransferManagerStatics>()->_TryImportAnchorsAsync(stream, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<bool>> TryExportAnchorsAsync(pptr<Foundation::Collections::IIterable<ptr<Foundation::Collections::IKeyValuePair<hstring, ptr<SpatialAnchor>>>>> anchors, pptr<Storage::Streams::IOutputStream> stream) { Foundation::IAsyncOperation<bool>* operation; hrcheck(get_activation_factory<SpatialAnchorTransferManager, ISpatialAnchorTransferManagerStatics>()->_TryExportAnchorsAsync(to_abi(anchors), stream, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<SpatialPerceptionAccessStatus>> RequestAccessAsync() { Foundation::IAsyncOperation<SpatialPerceptionAccessStatus>* result; hrcheck(get_activation_factory<SpatialAnchorTransferManager, ISpatialAnchorTransferManagerStatics>()->_RequestAccessAsync(&result)); return from_abi(result); }
};

template<typename X> struct statics<SpatialAnchorTransferManager, X> : X, Windows::Perception::Spatial::SpatialAnchorTransferManager_statics<void> {
	typedef typename X::root_type SpatialAnchorTransferManager;
};
struct SpatialAnchorTransferManager : generate<SpatialAnchorTransferManager> {};

// ISpatialBoundingVolume
struct ISpatialBoundingVolume : IInspectable, generate<ISpatialBoundingVolume> {};

// ISpatialBoundingVolumeStatics
struct ISpatialBoundingVolumeStatics : IInspectable {
	virtual STDMETHODIMP _FromBox(SpatialCoordinateSystem* coordinateSystem, SpatialBoundingBox box, SpatialBoundingVolume* *value);
	virtual STDMETHODIMP _FromOrientedBox(SpatialCoordinateSystem* coordinateSystem, SpatialBoundingOrientedBox box, SpatialBoundingVolume* *value);
	virtual STDMETHODIMP _FromSphere(SpatialCoordinateSystem* coordinateSystem, SpatialBoundingSphere sphere, SpatialBoundingVolume* *value);
	virtual STDMETHODIMP _FromFrustum(SpatialCoordinateSystem* coordinateSystem, SpatialBoundingFrustum frustum, SpatialBoundingVolume* *value);
};

// SpatialBoundingVolume
template<typename> struct SpatialBoundingVolume_statics {
	static ptr<SpatialBoundingVolume> FromBox(pptr<SpatialCoordinateSystem> coordinateSystem, const SpatialBoundingBox& box) { SpatialBoundingVolume* value; hrcheck(get_activation_factory<SpatialBoundingVolume, ISpatialBoundingVolumeStatics>()->_FromBox(coordinateSystem, box, &value)); return from_abi(value); }
	static ptr<SpatialBoundingVolume> FromOrientedBox(pptr<SpatialCoordinateSystem> coordinateSystem, const SpatialBoundingOrientedBox& box) { SpatialBoundingVolume* value; hrcheck(get_activation_factory<SpatialBoundingVolume, ISpatialBoundingVolumeStatics>()->_FromOrientedBox(coordinateSystem, box, &value)); return from_abi(value); }
	static ptr<SpatialBoundingVolume> FromSphere(pptr<SpatialCoordinateSystem> coordinateSystem, const SpatialBoundingSphere& sphere) { SpatialBoundingVolume* value; hrcheck(get_activation_factory<SpatialBoundingVolume, ISpatialBoundingVolumeStatics>()->_FromSphere(coordinateSystem, sphere, &value)); return from_abi(value); }
	static ptr<SpatialBoundingVolume> FromFrustum(pptr<SpatialCoordinateSystem> coordinateSystem, const SpatialBoundingFrustum& frustum) { SpatialBoundingVolume* value; hrcheck(get_activation_factory<SpatialBoundingVolume, ISpatialBoundingVolumeStatics>()->_FromFrustum(coordinateSystem, frustum, &value)); return from_abi(value); }
};

template<typename X> struct statics<SpatialBoundingVolume, X> : X, Windows::Perception::Spatial::SpatialBoundingVolume_statics<void> {
	typedef typename X::root_type SpatialBoundingVolume;
};
struct SpatialBoundingVolume : generate<SpatialBoundingVolume> {};

// ISpatialStageFrameOfReference
struct ISpatialStageFrameOfReference_raw : IInspectable {
	virtual STDMETHODIMP _get_CoordinateSystem(SpatialCoordinateSystem* *value);
	virtual STDMETHODIMP _get_MovementRange(SpatialMovementRange *value);
	virtual STDMETHODIMP _get_LookDirectionRange(SpatialLookDirectionRange *value);
	virtual STDMETHODIMP _GetCoordinateSystemAtCurrentLocation(SpatialLocator* locator, SpatialCoordinateSystem* *result);
	virtual STDMETHODIMP _TryGetMovementBounds(SpatialCoordinateSystem* coordinateSystem, unsigned *valueSize, Foundation::Numerics::Vector3 **value);
};
template<typename X> struct ISpatialStageFrameOfReference_adaptor : X {
	union {
		struct : property {
			ptr<SpatialCoordinateSystem> get() { SpatialCoordinateSystem* value; hrcheck(enc(&ISpatialStageFrameOfReference_adaptor::CoordinateSystem)->_get_CoordinateSystem(&value)); return from_abi(value); }
			ptr<SpatialCoordinateSystem> operator()() { return get(); }
			operator ptr<SpatialCoordinateSystem> () { return get(); }
			ptr<SpatialCoordinateSystem> operator->() { return get(); }
		} CoordinateSystem;
		struct : property {
			SpatialLookDirectionRange get() { SpatialLookDirectionRange value; hrcheck(enc(&ISpatialStageFrameOfReference_adaptor::LookDirectionRange)->_get_LookDirectionRange(&value)); return value; }
			SpatialLookDirectionRange operator()() { return get(); }
			operator SpatialLookDirectionRange () { return get(); }
		} LookDirectionRange;
		struct : property {
			SpatialMovementRange get() { SpatialMovementRange value; hrcheck(enc(&ISpatialStageFrameOfReference_adaptor::MovementRange)->_get_MovementRange(&value)); return value; }
			SpatialMovementRange operator()() { return get(); }
			operator SpatialMovementRange () { return get(); }
		} MovementRange;
	};
	ptr<SpatialCoordinateSystem> GetCoordinateSystemAtCurrentLocation(pptr<SpatialLocator> locator) { SpatialCoordinateSystem* result; hrcheck(X::get()->_GetCoordinateSystemAtCurrentLocation(locator, &result)); return from_abi(result); }
	szarray<Foundation::Numerics::Vector3> TryGetMovementBounds(pptr<SpatialCoordinateSystem> coordinateSystem) { szarray<Foundation::Numerics::Vector3> value; hrcheck(X::get()->_TryGetMovementBounds(coordinateSystem, &value.size, &value.p)); return value; }
	ISpatialStageFrameOfReference_adaptor() {}
};
template<typename X> struct adapt<ISpatialStageFrameOfReference, X> : Windows::Perception::Spatial::ISpatialStageFrameOfReference_adaptor<X> { typedef adapt ISpatialStageFrameOfReference; };
struct ISpatialStageFrameOfReference : ISpatialStageFrameOfReference_raw, generate<ISpatialStageFrameOfReference> {};

// ISpatialStageFrameOfReferenceStatics
struct ISpatialStageFrameOfReferenceStatics : IInspectable {
	virtual STDMETHODIMP _get_Current(SpatialStageFrameOfReference* *value);
	virtual STDMETHODIMP _add_CurrentChanged(Foundation::EventHandler<IInspectable*>* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_CurrentChanged(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _RequestNewStageAsync(Foundation::IAsyncOperation<SpatialStageFrameOfReference*>* *result);
};

// SpatialStageFrameOfReference
template<typename> struct SpatialStageFrameOfReference_statics {
	static struct _Current : property {
		ptr<SpatialStageFrameOfReference> get() { SpatialStageFrameOfReference* value; hrcheck(get_activation_factory<SpatialStageFrameOfReference, ISpatialStageFrameOfReferenceStatics>()->_get_Current(&value)); return from_abi(value); }
		ptr<SpatialStageFrameOfReference> operator()() { return get(); }
		operator ptr<SpatialStageFrameOfReference> () { return get(); }
		ptr<SpatialStageFrameOfReference> operator->() { return get(); }
	} Current;
	static struct _CurrentChanged : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<object>> handler) { Foundation::EventRegistrationToken cookie; hrcheck(get_activation_factory<SpatialStageFrameOfReference, ISpatialStageFrameOfReferenceStatics>()->_add_CurrentChanged(to_abi(handler), &cookie)); return cookie; }
		void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(get_activation_factory<SpatialStageFrameOfReference, ISpatialStageFrameOfReferenceStatics>()->_remove_CurrentChanged(cookie)); }
	} CurrentChanged;
	static ptr<Foundation::IAsyncOperation<ptr<SpatialStageFrameOfReference>>> RequestNewStageAsync() { Foundation::IAsyncOperation<SpatialStageFrameOfReference*>* result; hrcheck(get_activation_factory<SpatialStageFrameOfReference, ISpatialStageFrameOfReferenceStatics>()->_RequestNewStageAsync(&result)); return from_abi(result); }
};
template<typename X> typename SpatialStageFrameOfReference_statics<X>::_Current SpatialStageFrameOfReference_statics<X>::Current;
template<typename X> typename SpatialStageFrameOfReference_statics<X>::_CurrentChanged SpatialStageFrameOfReference_statics<X>::CurrentChanged;

template<typename X> struct statics<SpatialStageFrameOfReference, X> : X, Windows::Perception::Spatial::SpatialStageFrameOfReference_statics<void> {
	typedef typename X::root_type SpatialStageFrameOfReference;
};
struct SpatialStageFrameOfReference : generate<SpatialStageFrameOfReference> {};

// ISpatialEntity
struct ISpatialEntity_raw : IInspectable {
	virtual STDMETHODIMP _get_Id(HSTRING *value);
	virtual STDMETHODIMP _get_Anchor(SpatialAnchor* *value);
	virtual STDMETHODIMP _get_Properties(Foundation::Collections::ValueSet* *value);
};
template<typename X> struct ISpatialEntity_adaptor : X {
	union {
		struct : property {
			ptr<SpatialAnchor> get() { SpatialAnchor* value; hrcheck(enc(&ISpatialEntity_adaptor::Anchor)->_get_Anchor(&value)); return from_abi(value); }
			ptr<SpatialAnchor> operator()() { return get(); }
			operator ptr<SpatialAnchor> () { return get(); }
			ptr<SpatialAnchor> operator->() { return get(); }
		} Anchor;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISpatialEntity_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
		struct : property {
			ptr<Foundation::Collections::ValueSet> get() { Foundation::Collections::ValueSet* value; hrcheck(enc(&ISpatialEntity_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::ValueSet> operator()() { return get(); }
			operator ptr<Foundation::Collections::ValueSet> () { return get(); }
			ptr<Foundation::Collections::ValueSet> operator->() { return get(); }
		} Properties;
	};
	ISpatialEntity_adaptor() {}
};
template<typename X> struct adapt<ISpatialEntity, X> : Windows::Perception::Spatial::ISpatialEntity_adaptor<X> { typedef adapt ISpatialEntity; };
struct ISpatialEntity : ISpatialEntity_raw, generate<ISpatialEntity> {};

// ISpatialEntityFactory
struct ISpatialEntityFactory : IInspectable {
	virtual STDMETHODIMP _CreateWithSpatialAnchor(SpatialAnchor* spatialAnchor, SpatialEntity* *value);
	virtual STDMETHODIMP _CreateWithSpatialAnchorAndProperties(SpatialAnchor* spatialAnchor, Foundation::Collections::ValueSet* propertySet, SpatialEntity* *value);
};

// SpatialEntity
template<typename> struct SpatialEntity_statics {
	static SpatialEntity *activate(pptr<SpatialAnchor> spatialAnchor) { SpatialEntity *value; hrcheck(get_activation_factory<SpatialEntity, ISpatialEntityFactory>()->_CreateWithSpatialAnchor(spatialAnchor, &value)); return value; }
	static SpatialEntity *activate(pptr<SpatialAnchor> spatialAnchor, pptr<Foundation::Collections::ValueSet> propertySet) { SpatialEntity *value; hrcheck(get_activation_factory<SpatialEntity, ISpatialEntityFactory>()->_CreateWithSpatialAnchorAndProperties(spatialAnchor, propertySet, &value)); return value; }
};

template<typename X> struct statics<SpatialEntity, X> : X, Windows::Perception::Spatial::SpatialEntity_statics<void> {
	using Windows::Perception::Spatial::SpatialEntity_statics<void>::activate;
	typedef typename X::root_type SpatialEntity;
};
struct SpatialEntity : generate<SpatialEntity> {};

// ISpatialEntityAddedEventArgs
struct ISpatialEntityAddedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Entity(SpatialEntity* *value);
};
template<typename X> struct ISpatialEntityAddedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<SpatialEntity> get() { SpatialEntity* value; hrcheck(enc(&ISpatialEntityAddedEventArgs_adaptor::Entity)->_get_Entity(&value)); return from_abi(value); }
			ptr<SpatialEntity> operator()() { return get(); }
			operator ptr<SpatialEntity> () { return get(); }
			ptr<SpatialEntity> operator->() { return get(); }
		} Entity;
	};
	ISpatialEntityAddedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISpatialEntityAddedEventArgs, X> : Windows::Perception::Spatial::ISpatialEntityAddedEventArgs_adaptor<X> { typedef adapt ISpatialEntityAddedEventArgs; };
struct ISpatialEntityAddedEventArgs : ISpatialEntityAddedEventArgs_raw, generate<ISpatialEntityAddedEventArgs> {};

// SpatialEntityAddedEventArgs
template<typename X> struct statics<SpatialEntityAddedEventArgs, X> : X {
	typedef typename X::root_type SpatialEntityAddedEventArgs;
};
struct SpatialEntityAddedEventArgs : generate<SpatialEntityAddedEventArgs> {};

// ISpatialEntityUpdatedEventArgs
struct ISpatialEntityUpdatedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Entity(SpatialEntity* *value);
};
template<typename X> struct ISpatialEntityUpdatedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<SpatialEntity> get() { SpatialEntity* value; hrcheck(enc(&ISpatialEntityUpdatedEventArgs_adaptor::Entity)->_get_Entity(&value)); return from_abi(value); }
			ptr<SpatialEntity> operator()() { return get(); }
			operator ptr<SpatialEntity> () { return get(); }
			ptr<SpatialEntity> operator->() { return get(); }
		} Entity;
	};
	ISpatialEntityUpdatedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISpatialEntityUpdatedEventArgs, X> : Windows::Perception::Spatial::ISpatialEntityUpdatedEventArgs_adaptor<X> { typedef adapt ISpatialEntityUpdatedEventArgs; };
struct ISpatialEntityUpdatedEventArgs : ISpatialEntityUpdatedEventArgs_raw, generate<ISpatialEntityUpdatedEventArgs> {};

// SpatialEntityUpdatedEventArgs
template<typename X> struct statics<SpatialEntityUpdatedEventArgs, X> : X {
	typedef typename X::root_type SpatialEntityUpdatedEventArgs;
};
struct SpatialEntityUpdatedEventArgs : generate<SpatialEntityUpdatedEventArgs> {};

// ISpatialEntityRemovedEventArgs
struct ISpatialEntityRemovedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Entity(SpatialEntity* *value);
};
template<typename X> struct ISpatialEntityRemovedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<SpatialEntity> get() { SpatialEntity* value; hrcheck(enc(&ISpatialEntityRemovedEventArgs_adaptor::Entity)->_get_Entity(&value)); return from_abi(value); }
			ptr<SpatialEntity> operator()() { return get(); }
			operator ptr<SpatialEntity> () { return get(); }
			ptr<SpatialEntity> operator->() { return get(); }
		} Entity;
	};
	ISpatialEntityRemovedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ISpatialEntityRemovedEventArgs, X> : Windows::Perception::Spatial::ISpatialEntityRemovedEventArgs_adaptor<X> { typedef adapt ISpatialEntityRemovedEventArgs; };
struct ISpatialEntityRemovedEventArgs : ISpatialEntityRemovedEventArgs_raw, generate<ISpatialEntityRemovedEventArgs> {};

// SpatialEntityRemovedEventArgs
template<typename X> struct statics<SpatialEntityRemovedEventArgs, X> : X {
	typedef typename X::root_type SpatialEntityRemovedEventArgs;
};
struct SpatialEntityRemovedEventArgs : generate<SpatialEntityRemovedEventArgs> {};

// ISpatialEntityWatcher
struct ISpatialEntityWatcher_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(SpatialEntityWatcherStatus *value);
	virtual STDMETHODIMP _add_Added(Foundation::TypedEventHandler<SpatialEntityWatcher*, SpatialEntityAddedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Added(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Updated(Foundation::TypedEventHandler<SpatialEntityWatcher*, SpatialEntityUpdatedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Updated(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Removed(Foundation::TypedEventHandler<SpatialEntityWatcher*, SpatialEntityRemovedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Removed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_EnumerationCompleted(Foundation::TypedEventHandler<SpatialEntityWatcher*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_EnumerationCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _Start();
	virtual STDMETHODIMP _Stop();
};
template<typename X> struct ISpatialEntityWatcher_adaptor : X {
	union {
		struct : property {
			SpatialEntityWatcherStatus get() { SpatialEntityWatcherStatus value; hrcheck(enc(&ISpatialEntityWatcher_adaptor::Status)->_get_Status(&value)); return value; }
			SpatialEntityWatcherStatus operator()() { return get(); }
			operator SpatialEntityWatcherStatus () { return get(); }
		} Status;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SpatialEntityWatcher>, ptr<SpatialEntityAddedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISpatialEntityWatcher_adaptor::Added)->_add_Added(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISpatialEntityWatcher_adaptor::Added)->_remove_Added(token)); }
		} Added;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SpatialEntityWatcher>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISpatialEntityWatcher_adaptor::EnumerationCompleted)->_add_EnumerationCompleted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISpatialEntityWatcher_adaptor::EnumerationCompleted)->_remove_EnumerationCompleted(token)); }
		} EnumerationCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SpatialEntityWatcher>, ptr<SpatialEntityRemovedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISpatialEntityWatcher_adaptor::Removed)->_add_Removed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISpatialEntityWatcher_adaptor::Removed)->_remove_Removed(token)); }
		} Removed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<SpatialEntityWatcher>, ptr<SpatialEntityUpdatedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ISpatialEntityWatcher_adaptor::Updated)->_add_Updated(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ISpatialEntityWatcher_adaptor::Updated)->_remove_Updated(token)); }
		} Updated;
	};
	void Start() { hrcheck(X::get()->_Start()); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	ISpatialEntityWatcher_adaptor() {}
};
template<typename X> struct adapt<ISpatialEntityWatcher, X> : Windows::Perception::Spatial::ISpatialEntityWatcher_adaptor<X> { typedef adapt ISpatialEntityWatcher; };
struct ISpatialEntityWatcher : ISpatialEntityWatcher_raw, generate<ISpatialEntityWatcher> {};

// SpatialEntityWatcher
template<typename X> struct statics<SpatialEntityWatcher, X> : X {
	typedef typename X::root_type SpatialEntityWatcher;
};
struct SpatialEntityWatcher : generate<SpatialEntityWatcher> {};

// ISpatialEntityStore
struct ISpatialEntityStore_raw : IInspectable {
	virtual STDMETHODIMP _SaveAsync(SpatialEntity* entity, Foundation::IAsyncAction* *action);
	virtual STDMETHODIMP _RemoveAsync(SpatialEntity* entity, Foundation::IAsyncAction* *action);
	virtual STDMETHODIMP _CreateEntityWatcher(SpatialEntityWatcher* *value);
};
template<typename X> struct ISpatialEntityStore_adaptor : X {
	ptr<Foundation::IAsyncAction> SaveAsync(pptr<SpatialEntity> entity) { Foundation::IAsyncAction* action; hrcheck(X::get()->_SaveAsync(entity, &action)); return from_abi(action); }
	ptr<Foundation::IAsyncAction> RemoveAsync(pptr<SpatialEntity> entity) { Foundation::IAsyncAction* action; hrcheck(X::get()->_RemoveAsync(entity, &action)); return from_abi(action); }
	ptr<SpatialEntityWatcher> CreateEntityWatcher() { SpatialEntityWatcher* value; hrcheck(X::get()->_CreateEntityWatcher(&value)); return from_abi(value); }
};
template<typename X> struct adapt<ISpatialEntityStore, X> : Windows::Perception::Spatial::ISpatialEntityStore_adaptor<X> { typedef adapt ISpatialEntityStore; };
struct ISpatialEntityStore : ISpatialEntityStore_raw, generate<ISpatialEntityStore> {};

// ISpatialEntityStoreStatics
struct ISpatialEntityStoreStatics : IInspectable {
	virtual STDMETHODIMP _get_IsSupported(bool *value);
	virtual STDMETHODIMP _TryGetForRemoteSystemSession(System::RemoteSystems::RemoteSystemSession* session, SpatialEntityStore* *value);
};

// SpatialEntityStore
template<typename> struct SpatialEntityStore_statics {
	static struct _IsSupported : property {
		bool get() { bool value; hrcheck(get_activation_factory<SpatialEntityStore, ISpatialEntityStoreStatics>()->_get_IsSupported(&value)); return value; }
		bool operator()() { return get(); }
		operator bool () { return get(); }
	} IsSupported;
	static ptr<SpatialEntityStore> TryGet(pptr<System::RemoteSystems::RemoteSystemSession> session) { SpatialEntityStore* value; hrcheck(get_activation_factory<SpatialEntityStore, ISpatialEntityStoreStatics>()->_TryGetForRemoteSystemSession(session, &value)); return from_abi(value); }
};
template<typename X> typename SpatialEntityStore_statics<X>::_IsSupported SpatialEntityStore_statics<X>::IsSupported;

template<typename X> struct statics<SpatialEntityStore, X> : X, Windows::Perception::Spatial::SpatialEntityStore_statics<void> {
	typedef typename X::root_type SpatialEntityStore;
};
struct SpatialEntityStore : generate<SpatialEntityStore> {};
}}}
} // namespace iso_winrt
