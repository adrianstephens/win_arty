#pragma once
// generated by isopod tools
// namespaces:
// Windows.Devices.Enumeration.Pnp

#include "Windows.Devices.Enumeration.Pnp.0.h"
#include "Windows.Devices.Enumeration.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.Foundation.Collections.h"

namespace iso_winrt {

// forward types


// defs

template<> struct def<Windows::Devices::Enumeration::Pnp::PnpObjectType> : enum_type<int> {};
template<> struct def<Windows::Devices::Enumeration::Pnp::IPnpObjectUpdate> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::Pnp::PnpObjectUpdate> : class_type<Platform::Object, Windows::Devices::Enumeration::Pnp::IPnpObjectUpdate> {};
template<> struct def<Windows::Devices::Enumeration::Pnp::IPnpObjectStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::Pnp::IPnpObject> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::Pnp::PnpObject> : class_type<Platform::Object, Windows::Devices::Enumeration::Pnp::IPnpObject> {};
template<> struct def<Windows::Devices::Enumeration::Pnp::PnpObjectCollection> : class_type<Platform::Object, Windows::Foundation::Collections::IVectorView<ptr<Windows::Devices::Enumeration::Pnp::PnpObject>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Devices::Enumeration::Pnp::PnpObject>>> {};
template<> struct def<Windows::Devices::Enumeration::Pnp::IPnpObjectWatcher> : interface_type<> {};
template<> struct def<Windows::Devices::Enumeration::Pnp::PnpObjectWatcher> : class_type<Platform::Object, Windows::Devices::Enumeration::Pnp::IPnpObjectWatcher> {};

// uuids

template<> struct uuid<Windows::Devices::Enumeration::Pnp::IPnpObjectUpdate> { define_guid(0x6F59E812, 0x1E, 0x4844, 0xBC, 0xC6, 0x43, 0x28, 0x86, 0x85, 0x6A, 0x17);};
template<> struct uuid<Windows::Devices::Enumeration::Pnp::IPnpObjectStatics> { define_guid(0xB3C32A3D, 0xD168, 0x4660, 0xBB, 0xF3, 0xA7, 0x33, 0xB1, 0x4B, 0x6E, 0x1);};
template<> struct uuid<Windows::Devices::Enumeration::Pnp::IPnpObject> { define_guid(0x95C66258, 0x733B, 0x4A8F, 0x93, 0xA3, 0xDB, 0x7, 0x8A, 0xC8, 0x70, 0xC1);};
template<> struct uuid<Windows::Devices::Enumeration::Pnp::IPnpObjectWatcher> { define_guid(0x83C95CA8, 0x4772, 0x4A7A, 0xAC, 0xA8, 0xE4, 0x8C, 0x42, 0xA8, 0x9C, 0x44);};

// types

namespace Windows { namespace Devices { namespace Enumeration { namespace Pnp {

// IPnpObjectUpdate
struct IPnpObjectUpdate_raw : IInspectable {
	virtual STDMETHODIMP _get_Type(PnpObjectType *value);
	virtual STDMETHODIMP _get_Id(HSTRING *value);
	virtual STDMETHODIMP _get_Properties(Foundation::Collections::IMapView<HSTRING, IInspectable*>* *value);
};
template<typename X> struct IPnpObjectUpdate_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPnpObjectUpdate_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, object>> get() { Foundation::Collections::IMapView<HSTRING, IInspectable*>* value; hrcheck(enc(&IPnpObjectUpdate_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMapView<hstring, object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, object>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, object>> operator->() { return get(); }
		} Properties;
		struct : property {
			PnpObjectType get() { PnpObjectType value; hrcheck(enc(&IPnpObjectUpdate_adaptor::Type)->_get_Type(&value)); return value; }
			PnpObjectType operator()() { return get(); }
			operator PnpObjectType () { return get(); }
		} Type;
	};
	IPnpObjectUpdate_adaptor() {}
};
template<typename X> struct adapt<IPnpObjectUpdate, X> : Windows::Devices::Enumeration::Pnp::IPnpObjectUpdate_adaptor<X> { typedef adapt IPnpObjectUpdate; };
struct IPnpObjectUpdate : IPnpObjectUpdate_raw, generate<IPnpObjectUpdate> {};

// PnpObjectUpdate
template<typename X> struct statics<PnpObjectUpdate, X> : X {
	typedef typename X::root_type PnpObjectUpdate;
};
struct PnpObjectUpdate : generate<PnpObjectUpdate> {};

// IPnpObjectStatics
struct IPnpObjectStatics : IInspectable {
	virtual STDMETHODIMP _CreateFromIdAsync(PnpObjectType type, HSTRING id, Foundation::Collections::IIterable<HSTRING>* requestedProperties, Foundation::IAsyncOperation<PnpObject*>* *asyncOp);
	virtual STDMETHODIMP _FindAllAsync(PnpObjectType type, Foundation::Collections::IIterable<HSTRING>* requestedProperties, Foundation::IAsyncOperation<PnpObjectCollection*>* *asyncOp);
	virtual STDMETHODIMP _FindAllAsyncAqsFilter(PnpObjectType type, Foundation::Collections::IIterable<HSTRING>* requestedProperties, HSTRING aqsFilter, Foundation::IAsyncOperation<PnpObjectCollection*>* *asyncOp);
	virtual STDMETHODIMP _CreateWatcher(PnpObjectType type, Foundation::Collections::IIterable<HSTRING>* requestedProperties, PnpObjectWatcher* *watcher);
	virtual STDMETHODIMP _CreateWatcherAqsFilter(PnpObjectType type, Foundation::Collections::IIterable<HSTRING>* requestedProperties, HSTRING aqsFilter, PnpObjectWatcher* *watcher);
};

// IPnpObject
struct IPnpObject_raw : IInspectable {
	virtual STDMETHODIMP _get_Type(PnpObjectType *value);
	virtual STDMETHODIMP _get_Id(HSTRING *value);
	virtual STDMETHODIMP _get_Properties(Foundation::Collections::IMapView<HSTRING, IInspectable*>* *value);
	virtual STDMETHODIMP _Update(PnpObjectUpdate* updateInfo);
};
template<typename X> struct IPnpObject_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IPnpObject_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, object>> get() { Foundation::Collections::IMapView<HSTRING, IInspectable*>* value; hrcheck(enc(&IPnpObject_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMapView<hstring, object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, object>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, object>> operator->() { return get(); }
		} Properties;
		struct : property {
			PnpObjectType get() { PnpObjectType value; hrcheck(enc(&IPnpObject_adaptor::Type)->_get_Type(&value)); return value; }
			PnpObjectType operator()() { return get(); }
			operator PnpObjectType () { return get(); }
		} Type;
	};
	void Update(pptr<PnpObjectUpdate> updateInfo) { hrcheck(X::get()->_Update(updateInfo)); }
	IPnpObject_adaptor() {}
};
template<typename X> struct adapt<IPnpObject, X> : Windows::Devices::Enumeration::Pnp::IPnpObject_adaptor<X> { typedef adapt IPnpObject; };
struct IPnpObject : IPnpObject_raw, generate<IPnpObject> {};

// PnpObject
template<typename> struct PnpObject_statics {
	static ptr<Foundation::IAsyncOperation<ptr<PnpObject>>> CreateFromIdAsync(PnpObjectType type, hstring_ref id, pptr<Foundation::Collections::IIterable<hstring>> requestedProperties) { Foundation::IAsyncOperation<PnpObject*>* asyncOp; hrcheck(get_activation_factory<PnpObject, IPnpObjectStatics>()->_CreateFromIdAsync(type, id, to_abi(requestedProperties), &asyncOp)); return from_abi(asyncOp); }
	static ptr<Foundation::IAsyncOperation<ptr<PnpObjectCollection>>> FindAllAsync(PnpObjectType type, pptr<Foundation::Collections::IIterable<hstring>> requestedProperties) { Foundation::IAsyncOperation<PnpObjectCollection*>* asyncOp; hrcheck(get_activation_factory<PnpObject, IPnpObjectStatics>()->_FindAllAsync(type, to_abi(requestedProperties), &asyncOp)); return from_abi(asyncOp); }
	static ptr<Foundation::IAsyncOperation<ptr<PnpObjectCollection>>> FindAllAsync(PnpObjectType type, pptr<Foundation::Collections::IIterable<hstring>> requestedProperties, hstring_ref aqsFilter) { Foundation::IAsyncOperation<PnpObjectCollection*>* asyncOp; hrcheck(get_activation_factory<PnpObject, IPnpObjectStatics>()->_FindAllAsyncAqsFilter(type, to_abi(requestedProperties), aqsFilter, &asyncOp)); return from_abi(asyncOp); }
	static ptr<PnpObjectWatcher> CreateWatcher(PnpObjectType type, pptr<Foundation::Collections::IIterable<hstring>> requestedProperties) { PnpObjectWatcher* watcher; hrcheck(get_activation_factory<PnpObject, IPnpObjectStatics>()->_CreateWatcher(type, to_abi(requestedProperties), &watcher)); return from_abi(watcher); }
	static ptr<PnpObjectWatcher> CreateWatcher(PnpObjectType type, pptr<Foundation::Collections::IIterable<hstring>> requestedProperties, hstring_ref aqsFilter) { PnpObjectWatcher* watcher; hrcheck(get_activation_factory<PnpObject, IPnpObjectStatics>()->_CreateWatcherAqsFilter(type, to_abi(requestedProperties), aqsFilter, &watcher)); return from_abi(watcher); }
};

template<typename X> struct statics<PnpObject, X> : X, Windows::Devices::Enumeration::Pnp::PnpObject_statics<void> {
	typedef typename X::root_type PnpObject;
};
struct PnpObject : generate<PnpObject> {};

// PnpObjectCollection
template<typename X> struct statics<PnpObjectCollection, X> : X {
	typedef typename X::root_type PnpObjectCollection;
};
struct PnpObjectCollection : generate<PnpObjectCollection> {};

// IPnpObjectWatcher
struct IPnpObjectWatcher_raw : IInspectable {
	virtual STDMETHODIMP _add_Added(Foundation::TypedEventHandler<PnpObjectWatcher*, PnpObject*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Added(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Updated(Foundation::TypedEventHandler<PnpObjectWatcher*, PnpObjectUpdate*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Updated(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Removed(Foundation::TypedEventHandler<PnpObjectWatcher*, PnpObjectUpdate*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Removed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_EnumerationCompleted(Foundation::TypedEventHandler<PnpObjectWatcher*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_EnumerationCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_Stopped(Foundation::TypedEventHandler<PnpObjectWatcher*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Stopped(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_Status(DeviceWatcherStatus *status);
	virtual STDMETHODIMP _Start();
	virtual STDMETHODIMP _Stop();
};
template<typename X> struct IPnpObjectWatcher_adaptor : X {
	union {
		struct : property {
			DeviceWatcherStatus get() { DeviceWatcherStatus status; hrcheck(enc(&IPnpObjectWatcher_adaptor::Status)->_get_Status(&status)); return status; }
			DeviceWatcherStatus operator()() { return get(); }
			operator DeviceWatcherStatus () { return get(); }
		} Status;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<PnpObjectWatcher>, ptr<PnpObject>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPnpObjectWatcher_adaptor::Added)->_add_Added(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPnpObjectWatcher_adaptor::Added)->_remove_Added(token)); }
		} Added;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<PnpObjectWatcher>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPnpObjectWatcher_adaptor::EnumerationCompleted)->_add_EnumerationCompleted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPnpObjectWatcher_adaptor::EnumerationCompleted)->_remove_EnumerationCompleted(token)); }
		} EnumerationCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<PnpObjectWatcher>, ptr<PnpObjectUpdate>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPnpObjectWatcher_adaptor::Removed)->_add_Removed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPnpObjectWatcher_adaptor::Removed)->_remove_Removed(token)); }
		} Removed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<PnpObjectWatcher>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPnpObjectWatcher_adaptor::Stopped)->_add_Stopped(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPnpObjectWatcher_adaptor::Stopped)->_remove_Stopped(token)); }
		} Stopped;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<PnpObjectWatcher>, ptr<PnpObjectUpdate>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IPnpObjectWatcher_adaptor::Updated)->_add_Updated(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IPnpObjectWatcher_adaptor::Updated)->_remove_Updated(token)); }
		} Updated;
	};
	void Start() { hrcheck(X::get()->_Start()); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	IPnpObjectWatcher_adaptor() {}
};
template<typename X> struct adapt<IPnpObjectWatcher, X> : Windows::Devices::Enumeration::Pnp::IPnpObjectWatcher_adaptor<X> { typedef adapt IPnpObjectWatcher; };
struct IPnpObjectWatcher : IPnpObjectWatcher_raw, generate<IPnpObjectWatcher> {};

// PnpObjectWatcher
template<typename X> struct statics<PnpObjectWatcher, X> : X {
	typedef typename X::root_type PnpObjectWatcher;
};
struct PnpObjectWatcher : generate<PnpObjectWatcher> {};
}}}}
} // namespace iso_winrt
