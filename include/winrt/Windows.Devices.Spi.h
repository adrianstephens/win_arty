#pragma once
// generated by isopod tools
// namespaces:
// Windows.Devices.Spi

#include "Windows.Devices.Spi.0.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Devices { namespace Spi { namespace Provider {
struct ISpiProvider;
}}}
namespace Foundation { namespace Collections {
template<typename T> struct IVectorView;
}}}

// defs

template<> struct def<Windows::Devices::Spi::SpiMode> : enum_type<int> {};
template<> struct def<Windows::Devices::Spi::SpiSharingMode> : enum_type<int> {};
template<> struct def<Windows::Devices::Spi::ISpiConnectionSettingsFactory> : interface_type<> {};
template<> struct def<Windows::Devices::Spi::ISpiConnectionSettings> : interface_type<> {};
template<> struct def<Windows::Devices::Spi::SpiConnectionSettings> : class_type<Platform::Object, Windows::Devices::Spi::ISpiConnectionSettings>, custom_activators {};
template<> struct def<Windows::Devices::Spi::ISpiBusInfo> : interface_type<> {};
template<> struct def<Windows::Devices::Spi::SpiBusInfo> : class_type<Platform::Object, Windows::Devices::Spi::ISpiBusInfo> {};
template<> struct def<Windows::Devices::Spi::ISpiDeviceStatics> : overridable_type<> {};
template<> struct def<Windows::Devices::Spi::ISpiDevice> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Devices::Spi::SpiDevice> : class_type<Platform::Object, Windows::Devices::Spi::ISpiDevice> {};
template<> struct def<Windows::Devices::Spi::ISpiController> : interface_type<> {};
template<> struct def<Windows::Devices::Spi::ISpiControllerStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Spi::SpiController> : class_type<Platform::Object, Windows::Devices::Spi::ISpiController> {};

// uuids

template<> struct uuid<Windows::Devices::Spi::ISpiConnectionSettingsFactory> { define_guid(0xFF99081E, 0x10C4, 0x44B7, 0x9F, 0xEA, 0xA7, 0x48, 0xB5, 0xA4, 0x6F, 0x31);};
template<> struct uuid<Windows::Devices::Spi::ISpiConnectionSettings> { define_guid(0x5283A37F, 0xF935, 0x4B9F, 0xA7, 0xA7, 0x3A, 0x78, 0x90, 0xAF, 0xA5, 0xCE);};
template<> struct uuid<Windows::Devices::Spi::ISpiBusInfo> { define_guid(0x9929444A, 0x54F2, 0x48C6, 0xB9, 0x52, 0x9C, 0x32, 0xFC, 0x2, 0xC6, 0x69);};
template<> struct uuid<Windows::Devices::Spi::ISpiDeviceStatics> { define_guid(0xA278E559, 0x5720, 0x4D3F, 0xBD, 0x93, 0x56, 0xF5, 0xFF, 0x5A, 0x58, 0x79);};
template<> struct uuid<Windows::Devices::Spi::ISpiDevice> { define_guid(0x5D5356D, 0x11B6, 0x4D39, 0x84, 0xD5, 0x95, 0xDF, 0xB4, 0xC9, 0xF2, 0xCE);};
template<> struct uuid<Windows::Devices::Spi::ISpiController> { define_guid(0xA8D3C829, 0x9895, 0x4159, 0xA9, 0x34, 0x87, 0x41, 0xF1, 0xEE, 0x6D, 0x27);};
template<> struct uuid<Windows::Devices::Spi::ISpiControllerStatics> { define_guid(0xD5229E2, 0x138B, 0x4E48, 0xB9, 0x64, 0x4F, 0x2F, 0x79, 0xB9, 0xC5, 0xA2);};

// types

namespace Windows { namespace Devices { namespace Spi {

// ISpiConnectionSettingsFactory
struct ISpiConnectionSettingsFactory : IInspectable {
	virtual STDMETHODIMP _Create(int chipSelectLine, SpiConnectionSettings* *value);
};

// ISpiConnectionSettings
struct ISpiConnectionSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_ChipSelectLine(int *value);
	virtual STDMETHODIMP _put_ChipSelectLine(int value);
	virtual STDMETHODIMP _get_Mode(SpiMode *value);
	virtual STDMETHODIMP _put_Mode(SpiMode value);
	virtual STDMETHODIMP _get_DataBitLength(int *value);
	virtual STDMETHODIMP _put_DataBitLength(int value);
	virtual STDMETHODIMP _get_ClockFrequency(int *value);
	virtual STDMETHODIMP _put_ClockFrequency(int value);
	virtual STDMETHODIMP _get_SharingMode(SpiSharingMode *value);
	virtual STDMETHODIMP _put_SharingMode(SpiSharingMode value);
};
template<typename X> struct ISpiConnectionSettings_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&ISpiConnectionSettings_adaptor::ChipSelectLine)->_get_ChipSelectLine(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ISpiConnectionSettings_adaptor::ChipSelectLine)->_put_ChipSelectLine(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} ChipSelectLine;
		struct : property {
			int get() { int value; hrcheck(enc(&ISpiConnectionSettings_adaptor::ClockFrequency)->_get_ClockFrequency(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ISpiConnectionSettings_adaptor::ClockFrequency)->_put_ClockFrequency(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} ClockFrequency;
		struct : property {
			int get() { int value; hrcheck(enc(&ISpiConnectionSettings_adaptor::DataBitLength)->_get_DataBitLength(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&ISpiConnectionSettings_adaptor::DataBitLength)->_put_DataBitLength(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} DataBitLength;
		struct : property {
			SpiMode get() { SpiMode value; hrcheck(enc(&ISpiConnectionSettings_adaptor::Mode)->_get_Mode(&value)); return value; }
			SpiMode operator()() { return get(); }
			operator SpiMode () { return get(); }
			void put(SpiMode value) { hrcheck(enc(&ISpiConnectionSettings_adaptor::Mode)->_put_Mode(value)); }
			void operator=(SpiMode value) { put(value); }
			void operator()(SpiMode value) { put(value); }
		} Mode;
		struct : property {
			SpiSharingMode get() { SpiSharingMode value; hrcheck(enc(&ISpiConnectionSettings_adaptor::SharingMode)->_get_SharingMode(&value)); return value; }
			SpiSharingMode operator()() { return get(); }
			operator SpiSharingMode () { return get(); }
			void put(SpiSharingMode value) { hrcheck(enc(&ISpiConnectionSettings_adaptor::SharingMode)->_put_SharingMode(value)); }
			void operator=(SpiSharingMode value) { put(value); }
			void operator()(SpiSharingMode value) { put(value); }
		} SharingMode;
	};
	ISpiConnectionSettings_adaptor() {}
};
template<typename X> struct adapt<ISpiConnectionSettings, X> : Windows::Devices::Spi::ISpiConnectionSettings_adaptor<X> { typedef adapt ISpiConnectionSettings; };
struct ISpiConnectionSettings : ISpiConnectionSettings_raw, generate<ISpiConnectionSettings> {};

// SpiConnectionSettings
template<typename> struct SpiConnectionSettings_statics {
	static SpiConnectionSettings *activate(int chipSelectLine) { SpiConnectionSettings *value; hrcheck(get_activation_factory<SpiConnectionSettings, ISpiConnectionSettingsFactory>()->_Create(chipSelectLine, &value)); return value; }
};

template<typename X> struct statics<SpiConnectionSettings, X> : X, Windows::Devices::Spi::SpiConnectionSettings_statics<void> {
	using Windows::Devices::Spi::SpiConnectionSettings_statics<void>::activate;
	typedef typename X::root_type SpiConnectionSettings;
};
struct SpiConnectionSettings : generate<SpiConnectionSettings> {};

// ISpiBusInfo
struct ISpiBusInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_ChipSelectLineCount(int *value);
	virtual STDMETHODIMP _get_MinClockFrequency(int *value);
	virtual STDMETHODIMP _get_MaxClockFrequency(int *value);
	virtual STDMETHODIMP _get_SupportedDataBitLengths(Foundation::Collections::IVectorView<int>* *value);
};
template<typename X> struct ISpiBusInfo_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&ISpiBusInfo_adaptor::ChipSelectLineCount)->_get_ChipSelectLineCount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} ChipSelectLineCount;
		struct : property {
			int get() { int value; hrcheck(enc(&ISpiBusInfo_adaptor::MaxClockFrequency)->_get_MaxClockFrequency(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} MaxClockFrequency;
		struct : property {
			int get() { int value; hrcheck(enc(&ISpiBusInfo_adaptor::MinClockFrequency)->_get_MinClockFrequency(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} MinClockFrequency;
		struct : property {
			ptr<Foundation::Collections::IVectorView<int>> get() { Foundation::Collections::IVectorView<int>* value; hrcheck(enc(&ISpiBusInfo_adaptor::SupportedDataBitLengths)->_get_SupportedDataBitLengths(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<int>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<int>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<int>> operator->() { return get(); }
		} SupportedDataBitLengths;
	};
	ISpiBusInfo_adaptor() {}
};
template<typename X> struct adapt<ISpiBusInfo, X> : Windows::Devices::Spi::ISpiBusInfo_adaptor<X> { typedef adapt ISpiBusInfo; };
struct ISpiBusInfo : ISpiBusInfo_raw, generate<ISpiBusInfo> {};

// SpiBusInfo
template<typename X> struct statics<SpiBusInfo, X> : X {
	typedef typename X::root_type SpiBusInfo;
};
struct SpiBusInfo : generate<SpiBusInfo> {};

// ISpiDeviceStatics
struct ISpiDeviceStatics_raw : IInspectable {
	virtual STDMETHODIMP _GetDeviceSelector(HSTRING *value) = 0;
	virtual STDMETHODIMP _GetDeviceSelectorFromFriendlyName(HSTRING friendlyName, HSTRING *value) = 0;
	virtual STDMETHODIMP _GetBusInfo(HSTRING busId, SpiBusInfo* *busInfo) = 0;
	virtual STDMETHODIMP _FromIdAsync(HSTRING busId, SpiConnectionSettings* settings, Foundation::IAsyncOperation<SpiDevice*>* *operation) = 0;
};
template<typename X> struct ISpiDeviceStatics_adaptor : X {
	hstring GetDeviceSelector() { HSTRING value; hrcheck(X::get()->_GetDeviceSelector(&value)); return from_abi(value); }
	hstring GetDeviceSelector(hstring_ref friendlyName) { HSTRING value; hrcheck(X::get()->_GetDeviceSelectorFromFriendlyName(friendlyName, &value)); return from_abi(value); }
	ptr<SpiBusInfo> GetBusInfo(hstring_ref busId) { SpiBusInfo* busInfo; hrcheck(X::get()->_GetBusInfo(busId, &busInfo)); return from_abi(busInfo); }
	ptr<Foundation::IAsyncOperation<ptr<SpiDevice>>> FromIdAsync(hstring_ref busId, pptr<SpiConnectionSettings> settings) { Foundation::IAsyncOperation<SpiDevice*>* operation; hrcheck(X::get()->_FromIdAsync(busId, settings, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<ISpiDeviceStatics, X> : Windows::Devices::Spi::ISpiDeviceStatics_adaptor<X> { typedef adapt ISpiDeviceStatics; };
template<typename X> struct ISpiDeviceStatics_unadaptor : X {
	STDMETHODIMP _GetDeviceSelector(HSTRING *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetDeviceSelector()); }); }
	STDMETHODIMP _GetDeviceSelectorFromFriendlyName(HSTRING friendlyName, HSTRING *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetDeviceSelector(friendlyName)); }); }
	STDMETHODIMP _GetBusInfo(HSTRING busId, SpiBusInfo* *busInfo) { return hrtry([&, this] { *busInfo = to_abi(X::get()->GetBusInfo(busId)); }); }
	STDMETHODIMP _FromIdAsync(HSTRING busId, SpiConnectionSettings* settings, Foundation::IAsyncOperation<SpiDevice*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->FromIdAsync(busId, settings)); }); }
};
template<typename X> struct unadapt<ISpiDeviceStatics, X> : Windows::Devices::Spi::ISpiDeviceStatics_unadaptor<X> {};
struct ISpiDeviceStatics : ISpiDeviceStatics_raw, generate<ISpiDeviceStatics> {};

// ISpiDevice
struct ISpiDevice_raw : IInspectable {
	virtual STDMETHODIMP _get_DeviceId(HSTRING *value);
	virtual STDMETHODIMP _get_ConnectionSettings(SpiConnectionSettings* *value);
	virtual STDMETHODIMP _Write(unsigned bufferSize, unsigned char *buffer);
	virtual STDMETHODIMP _Read(unsigned bufferSize, unsigned char *buffer);
	virtual STDMETHODIMP _TransferSequential(unsigned writeBufferSize, unsigned char *writeBuffer, unsigned readBufferSize, unsigned char *readBuffer);
	virtual STDMETHODIMP _TransferFullDuplex(unsigned writeBufferSize, unsigned char *writeBuffer, unsigned readBufferSize, unsigned char *readBuffer);
};
template<typename X> struct ISpiDevice_adaptor : X {
	union {
		struct : property {
			ptr<SpiConnectionSettings> get() { SpiConnectionSettings* value; hrcheck(enc(&ISpiDevice_adaptor::ConnectionSettings)->_get_ConnectionSettings(&value)); return from_abi(value); }
			ptr<SpiConnectionSettings> operator()() { return get(); }
			operator ptr<SpiConnectionSettings> () { return get(); }
			ptr<SpiConnectionSettings> operator->() { return get(); }
		} ConnectionSettings;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISpiDevice_adaptor::DeviceId)->_get_DeviceId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DeviceId;
	};
	void Write(const szarray<unsigned char>& buffer) { hrcheck(X::get()->_Write(buffer.size, to_abi(buffer.p))); }
	void Read(const szarray<unsigned char>& buffer) { hrcheck(X::get()->_Read(buffer.size, to_abi(buffer.p))); }
	void TransferSequential(const szarray<unsigned char>& writeBuffer, const szarray<unsigned char>& readBuffer) { hrcheck(X::get()->_TransferSequential(writeBuffer.size, to_abi(writeBuffer.p), readBuffer.size, to_abi(readBuffer.p))); }
	void TransferFullDuplex(const szarray<unsigned char>& writeBuffer, const szarray<unsigned char>& readBuffer) { hrcheck(X::get()->_TransferFullDuplex(writeBuffer.size, to_abi(writeBuffer.p), readBuffer.size, to_abi(readBuffer.p))); }
	ISpiDevice_adaptor() {}
};
template<typename X> struct adapt<ISpiDevice, X> : Windows::Devices::Spi::ISpiDevice_adaptor<X> { typedef adapt ISpiDevice; };
struct ISpiDevice : ISpiDevice_raw, generate<ISpiDevice> {};

// SpiDevice
template<typename> struct SpiDevice_statics {
	static hstring GetDeviceSelector();
	static hstring GetDeviceSelector(hstring_ref friendlyName);
	static ptr<SpiBusInfo> GetBusInfo(hstring_ref busId);
	static ptr<Foundation::IAsyncOperation<ptr<SpiDevice>>> FromIdAsync(hstring_ref busId, pptr<SpiConnectionSettings> settings);
};

template<typename X> struct statics<SpiDevice, X> : X, Windows::Devices::Spi::SpiDevice_statics<void> {
	typedef typename X::root_type SpiDevice;
};
struct SpiDevice : generate<SpiDevice> {};

// ISpiController
struct ISpiController_raw : IInspectable {
	virtual STDMETHODIMP _GetDevice(SpiConnectionSettings* settings, SpiDevice* *device);
};
template<typename X> struct ISpiController_adaptor : X {
	ptr<SpiDevice> GetDevice(pptr<SpiConnectionSettings> settings) { SpiDevice* device; hrcheck(X::get()->_GetDevice(settings, &device)); return from_abi(device); }
};
template<typename X> struct adapt<ISpiController, X> : Windows::Devices::Spi::ISpiController_adaptor<X> { typedef adapt ISpiController; };
struct ISpiController : ISpiController_raw, generate<ISpiController> {};

// ISpiControllerStatics
struct ISpiControllerStatics : IInspectable {
	virtual STDMETHODIMP _GetDefaultAsync(Foundation::IAsyncOperation<SpiController*>* *operation);
	virtual STDMETHODIMP _GetControllersAsync(Provider::ISpiProvider* provider, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<SpiController*>*>* *operation);
};

// SpiController
template<typename> struct SpiController_statics {
	static ptr<Foundation::IAsyncOperation<ptr<SpiController>>> GetDefaultAsync() { Foundation::IAsyncOperation<SpiController*>* operation; hrcheck(get_activation_factory<SpiController, ISpiControllerStatics>()->_GetDefaultAsync(&operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<SpiController>>>>> GetControllersAsync(pptr<Provider::ISpiProvider> provider) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<SpiController*>*>* operation; hrcheck(get_activation_factory<SpiController, ISpiControllerStatics>()->_GetControllersAsync(provider, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<SpiController, X> : X, Windows::Devices::Spi::SpiController_statics<void> {
	typedef typename X::root_type SpiController;
};
struct SpiController : generate<SpiController> {};
}}}
} // namespace iso_winrt
