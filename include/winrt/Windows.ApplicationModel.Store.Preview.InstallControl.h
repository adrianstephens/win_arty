#pragma once
// generated by isopod tools
// namespaces:
// Windows.ApplicationModel.Store.Preview.InstallControl

#include "Windows.ApplicationModel.Store.Preview.InstallControl.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IVectorView;
}}
namespace Management { namespace Deployment {
struct PackageVolume;
}}
namespace System {
struct User;
}}

// defs

template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::GetEntitlementStatus> : enum_type<int> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::AppInstallState> : enum_type<int> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallStatus> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallStatus2> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallStatus3> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::AppInstallStatus> : class_type<Platform::Object, Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallStatus, Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallStatus2, Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallStatus3> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::AppInstallType> : enum_type<int> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem4> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem3> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem2> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::AppInstallItem> : class_type<Platform::Object, Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem, Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem2, Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem3, Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem4> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IGetEntitlementResult> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::GetEntitlementResult> : class_type<Platform::Object, Windows::ApplicationModel::Store::Preview::InstallControl::IGetEntitlementResult> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManagerItemEventArgs> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::AppInstallManagerItemEventArgs> : class_type<Platform::Object, Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManagerItemEventArgs> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::AutoUpdateSetting> : enum_type<int> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppUpdateOptions> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::AppUpdateOptions> : class_type<Platform::Object, Windows::ApplicationModel::Store::Preview::InstallControl::IAppUpdateOptions> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallOptions> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::AppInstallOptions> : class_type<Platform::Object, Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallOptions> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager6> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager5> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager4> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager3> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager2> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::Preview::InstallControl::AppInstallManager> : class_type<Platform::Object, Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager, Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager2, Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager3, Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager4, Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager5, Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager6> {};

// uuids

template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallStatus> { define_guid(0x936DCCFA, 0x2450, 0x4126, 0x88, 0xB1, 0x61, 0x27, 0xA6, 0x44, 0xDD, 0x5C);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallStatus2> { define_guid(0x96E7818A, 0x5E92, 0x4AA9, 0x8E, 0xDC, 0x58, 0xFE, 0xD4, 0xB8, 0x7E, 0x0);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallStatus3> { define_guid(0xCB880C56, 0x837B, 0x4B4C, 0x9E, 0xBB, 0x6D, 0x44, 0xA0, 0xA9, 0x63, 0x7);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem> { define_guid(0x49D3DFAB, 0x168A, 0x4CBF, 0xA9, 0x3A, 0x9E, 0x44, 0x8C, 0x82, 0x73, 0x7D);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem4> { define_guid(0xC2D1CE12, 0x71FF, 0x4FC8, 0xB5, 0x40, 0x45, 0x3D, 0x4B, 0x37, 0xE1, 0xD1);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem3> { define_guid(0x6F3DC998, 0xDD47, 0x433C, 0x92, 0x34, 0x56, 0x1, 0x72, 0xD6, 0x7A, 0x45);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem2> { define_guid(0xD3972AF8, 0x40C0, 0x4FD7, 0xAA, 0x6C, 0xA, 0xA1, 0x3C, 0xA6, 0x18, 0x8C);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IGetEntitlementResult> { define_guid(0x74FC843F, 0x1A9E, 0x4609, 0x8E, 0x4D, 0x81, 0x90, 0x86, 0xD0, 0x8A, 0x3D);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManagerItemEventArgs> { define_guid(0xBC505743, 0x4674, 0x4DD1, 0x95, 0x7E, 0xC2, 0x56, 0x82, 0x8, 0x6A, 0x14);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppUpdateOptions> { define_guid(0x26F0B02F, 0xC2F3, 0x4AEA, 0xAF, 0x8C, 0x63, 0x8, 0xDD, 0x9D, 0xB8, 0x5F);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallOptions> { define_guid(0xC9808300, 0x1CB8, 0x4EB6, 0x8C, 0x9F, 0x6A, 0x30, 0xC6, 0x4A, 0x5B, 0x51);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager> { define_guid(0x9353E170, 0x8441, 0x4B45, 0xBD, 0x72, 0x7C, 0x2F, 0xA9, 0x25, 0xBE, 0xEE);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager6> { define_guid(0xC9E7D408, 0xF27A, 0x4471, 0xB2, 0xF4, 0xE7, 0x6E, 0xFC, 0xBE, 0xBC, 0xCA);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager5> { define_guid(0x3CD7BE4C, 0x1BE9, 0x4F7F, 0xB6, 0x75, 0xAA, 0x1D, 0x64, 0xA5, 0x29, 0xB2);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager4> { define_guid(0x260A2A16, 0x5A9E, 0x4EBD, 0xB9, 0x44, 0xF2, 0xBA, 0x75, 0xC3, 0x11, 0x59);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager3> { define_guid(0x95B24B17, 0xE96A, 0x4D0E, 0x84, 0xE1, 0xC8, 0xCB, 0x41, 0x7A, 0x1, 0x78);};
template<> struct uuid<Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager2> { define_guid(0x16937851, 0xED37, 0x480D, 0x83, 0x14, 0x52, 0xE2, 0x7C, 0x3, 0xF0, 0x4A);};

// types

namespace Windows { namespace ApplicationModel { namespace Store { namespace Preview { namespace InstallControl {

// IAppInstallStatus
struct IAppInstallStatus_raw : IInspectable {
	virtual STDMETHODIMP _get_InstallState(AppInstallState *value);
	virtual STDMETHODIMP _get_DownloadSizeInBytes(unsigned __int64 *value);
	virtual STDMETHODIMP _get_BytesDownloaded(unsigned __int64 *value);
	virtual STDMETHODIMP _get_PercentComplete(double *value);
	virtual STDMETHODIMP _get_ErrorCode(Foundation::HResult *value);
};
template<typename X> struct IAppInstallStatus_adaptor : X {
	union {
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IAppInstallStatus_adaptor::BytesDownloaded)->_get_BytesDownloaded(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} BytesDownloaded;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IAppInstallStatus_adaptor::DownloadSizeInBytes)->_get_DownloadSizeInBytes(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} DownloadSizeInBytes;
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IAppInstallStatus_adaptor::ErrorCode)->_get_ErrorCode(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ErrorCode;
		struct : property {
			AppInstallState get() { AppInstallState value; hrcheck(enc(&IAppInstallStatus_adaptor::InstallState)->_get_InstallState(&value)); return value; }
			AppInstallState operator()() { return get(); }
			operator AppInstallState () { return get(); }
		} InstallState;
		struct : property {
			double get() { double value; hrcheck(enc(&IAppInstallStatus_adaptor::PercentComplete)->_get_PercentComplete(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} PercentComplete;
	};
	IAppInstallStatus_adaptor() {}
};
template<typename X> struct adapt<IAppInstallStatus, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallStatus_adaptor<X> { typedef adapt IAppInstallStatus; };
struct IAppInstallStatus : IAppInstallStatus_raw, generate<IAppInstallStatus> {};

// IAppInstallStatus2
struct IAppInstallStatus2_raw : IInspectable {
	virtual STDMETHODIMP _get_User(System::User* *value);
	virtual STDMETHODIMP _get_ReadyForLaunch(bool *value);
};
template<typename X> struct IAppInstallStatus2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppInstallStatus2_adaptor::ReadyForLaunch)->_get_ReadyForLaunch(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} ReadyForLaunch;
		struct : property {
			ptr<System::User> get() { System::User* value; hrcheck(enc(&IAppInstallStatus2_adaptor::User)->_get_User(&value)); return from_abi(value); }
			ptr<System::User> operator()() { return get(); }
			operator ptr<System::User> () { return get(); }
			ptr<System::User> operator->() { return get(); }
		} User;
	};
	IAppInstallStatus2_adaptor() {}
};
template<typename X> struct adapt<IAppInstallStatus2, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallStatus2_adaptor<X> { typedef adapt IAppInstallStatus2; };
struct IAppInstallStatus2 : IAppInstallStatus2_raw, generate<IAppInstallStatus2> {};

// IAppInstallStatus3
struct IAppInstallStatus3_raw : IInspectable {
	virtual STDMETHODIMP _get_IsStaged(bool *value);
};
template<typename X> struct IAppInstallStatus3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppInstallStatus3_adaptor::IsStaged)->_get_IsStaged(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsStaged;
	};
	IAppInstallStatus3_adaptor() {}
};
template<typename X> struct adapt<IAppInstallStatus3, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallStatus3_adaptor<X> { typedef adapt IAppInstallStatus3; };
struct IAppInstallStatus3 : IAppInstallStatus3_raw, generate<IAppInstallStatus3> {};

// AppInstallStatus
template<typename X> struct statics<AppInstallStatus, X> : X {
	typedef typename X::root_type AppInstallStatus;
};
struct AppInstallStatus : generate<AppInstallStatus> {};

// IAppInstallItem
struct IAppInstallItem_raw : IInspectable {
	virtual STDMETHODIMP _get_ProductId(HSTRING *value);
	virtual STDMETHODIMP _get_PackageFamilyName(HSTRING *value);
	virtual STDMETHODIMP _get_InstallType(AppInstallType *value);
	virtual STDMETHODIMP _get_IsUserInitiated(bool *value);
	virtual STDMETHODIMP _GetCurrentStatus(AppInstallStatus* *result);
	virtual STDMETHODIMP _Cancel();
	virtual STDMETHODIMP _Pause();
	virtual STDMETHODIMP _Restart();
	virtual STDMETHODIMP _add_Completed(Foundation::TypedEventHandler<AppInstallItem*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Completed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_StatusChanged(Foundation::TypedEventHandler<AppInstallItem*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_StatusChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IAppInstallItem_adaptor : X {
	union {
		struct : property {
			AppInstallType get() { AppInstallType value; hrcheck(enc(&IAppInstallItem_adaptor::InstallType)->_get_InstallType(&value)); return value; }
			AppInstallType operator()() { return get(); }
			operator AppInstallType () { return get(); }
		} InstallType;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppInstallItem_adaptor::IsUserInitiated)->_get_IsUserInitiated(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsUserInitiated;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppInstallItem_adaptor::PackageFamilyName)->_get_PackageFamilyName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PackageFamilyName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppInstallItem_adaptor::ProductId)->_get_ProductId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ProductId;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AppInstallItem>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppInstallItem_adaptor::Completed)->_add_Completed(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppInstallItem_adaptor::Completed)->_remove_Completed(token)); }
		} Completed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AppInstallItem>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppInstallItem_adaptor::StatusChanged)->_add_StatusChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppInstallItem_adaptor::StatusChanged)->_remove_StatusChanged(token)); }
		} StatusChanged;
	};
	ptr<AppInstallStatus> GetCurrentStatus() { AppInstallStatus* result; hrcheck(X::get()->_GetCurrentStatus(&result)); return from_abi(result); }
	void Cancel() { hrcheck(X::get()->_Cancel()); }
	void Pause() { hrcheck(X::get()->_Pause()); }
	void Restart() { hrcheck(X::get()->_Restart()); }
	IAppInstallItem_adaptor() {}
};
template<typename X> struct adapt<IAppInstallItem, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem_adaptor<X> { typedef adapt IAppInstallItem; };
struct IAppInstallItem : IAppInstallItem_raw, generate<IAppInstallItem> {};

// IAppInstallItem4
struct IAppInstallItem4_raw : IInspectable {
	virtual STDMETHODIMP _get_LaunchAfterInstall(bool *value);
	virtual STDMETHODIMP _put_LaunchAfterInstall(bool value);
};
template<typename X> struct IAppInstallItem4_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppInstallItem4_adaptor::LaunchAfterInstall)->_get_LaunchAfterInstall(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IAppInstallItem4_adaptor::LaunchAfterInstall)->_put_LaunchAfterInstall(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} LaunchAfterInstall;
	};
	IAppInstallItem4_adaptor() {}
};
template<typename X> struct adapt<IAppInstallItem4, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem4_adaptor<X> { typedef adapt IAppInstallItem4; };
struct IAppInstallItem4 : IAppInstallItem4_raw, generate<IAppInstallItem4> {};

// IAppInstallItem3
struct IAppInstallItem3_raw : IInspectable {
	virtual STDMETHODIMP _get_Children(Foundation::Collections::IVectorView<AppInstallItem*>* *value);
	virtual STDMETHODIMP _get_ItemOperationsMightAffectOtherItems(bool *value);
};
template<typename X> struct IAppInstallItem3_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>> get() { Foundation::Collections::IVectorView<AppInstallItem*>* value; hrcheck(enc(&IAppInstallItem3_adaptor::Children)->_get_Children(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>> operator->() { return get(); }
		} Children;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppInstallItem3_adaptor::ItemOperationsMightAffectOtherItems)->_get_ItemOperationsMightAffectOtherItems(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} ItemOperationsMightAffectOtherItems;
	};
	IAppInstallItem3_adaptor() {}
};
template<typename X> struct adapt<IAppInstallItem3, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem3_adaptor<X> { typedef adapt IAppInstallItem3; };
struct IAppInstallItem3 : IAppInstallItem3_raw, generate<IAppInstallItem3> {};

// IAppInstallItem2
struct IAppInstallItem2_raw : IInspectable {
	virtual STDMETHODIMP _CancelWithTelemetry(HSTRING correlationVector);
	virtual STDMETHODIMP _PauseWithTelemetry(HSTRING correlationVector);
	virtual STDMETHODIMP _RestartWithTelemetry(HSTRING correlationVector);
};
template<typename X> struct IAppInstallItem2_adaptor : X {
	void Cancel(hstring_ref correlationVector) { hrcheck(X::get()->_CancelWithTelemetry(correlationVector)); }
	void Pause(hstring_ref correlationVector) { hrcheck(X::get()->_PauseWithTelemetry(correlationVector)); }
	void Restart(hstring_ref correlationVector) { hrcheck(X::get()->_RestartWithTelemetry(correlationVector)); }
};
template<typename X> struct adapt<IAppInstallItem2, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallItem2_adaptor<X> { typedef adapt IAppInstallItem2; };
struct IAppInstallItem2 : IAppInstallItem2_raw, generate<IAppInstallItem2> {};

// AppInstallItem
template<typename X> struct statics<AppInstallItem, X> : X {
	typedef typename X::root_type AppInstallItem;
};
struct AppInstallItem : generate<AppInstallItem> {
	using IAppInstallItem::Cancel;
	using IAppInstallItem2::Cancel;
	using IAppInstallItem::Pause;
	using IAppInstallItem2::Pause;
	using IAppInstallItem::Restart;
	using IAppInstallItem2::Restart;
};

// IGetEntitlementResult
struct IGetEntitlementResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(GetEntitlementStatus *value);
};
template<typename X> struct IGetEntitlementResult_adaptor : X {
	union {
		struct : property {
			GetEntitlementStatus get() { GetEntitlementStatus value; hrcheck(enc(&IGetEntitlementResult_adaptor::Status)->_get_Status(&value)); return value; }
			GetEntitlementStatus operator()() { return get(); }
			operator GetEntitlementStatus () { return get(); }
		} Status;
	};
	IGetEntitlementResult_adaptor() {}
};
template<typename X> struct adapt<IGetEntitlementResult, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IGetEntitlementResult_adaptor<X> { typedef adapt IGetEntitlementResult; };
struct IGetEntitlementResult : IGetEntitlementResult_raw, generate<IGetEntitlementResult> {};

// GetEntitlementResult
template<typename X> struct statics<GetEntitlementResult, X> : X {
	typedef typename X::root_type GetEntitlementResult;
};
struct GetEntitlementResult : generate<GetEntitlementResult> {};

// IAppInstallManagerItemEventArgs
struct IAppInstallManagerItemEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Item(AppInstallItem* *value);
};
template<typename X> struct IAppInstallManagerItemEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<AppInstallItem> get() { AppInstallItem* value; hrcheck(enc(&IAppInstallManagerItemEventArgs_adaptor::Item)->_get_Item(&value)); return from_abi(value); }
			ptr<AppInstallItem> operator()() { return get(); }
			operator ptr<AppInstallItem> () { return get(); }
			ptr<AppInstallItem> operator->() { return get(); }
		} Item;
	};
	IAppInstallManagerItemEventArgs_adaptor() {}
};
template<typename X> struct adapt<IAppInstallManagerItemEventArgs, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManagerItemEventArgs_adaptor<X> { typedef adapt IAppInstallManagerItemEventArgs; };
struct IAppInstallManagerItemEventArgs : IAppInstallManagerItemEventArgs_raw, generate<IAppInstallManagerItemEventArgs> {};

// AppInstallManagerItemEventArgs
template<typename X> struct statics<AppInstallManagerItemEventArgs, X> : X {
	typedef typename X::root_type AppInstallManagerItemEventArgs;
};
struct AppInstallManagerItemEventArgs : generate<AppInstallManagerItemEventArgs> {};

// IAppUpdateOptions
struct IAppUpdateOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_CatalogId(HSTRING *value);
	virtual STDMETHODIMP _put_CatalogId(HSTRING value);
	virtual STDMETHODIMP _get_AllowForcedAppRestart(bool *value);
	virtual STDMETHODIMP _put_AllowForcedAppRestart(bool value);
};
template<typename X> struct IAppUpdateOptions_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppUpdateOptions_adaptor::AllowForcedAppRestart)->_get_AllowForcedAppRestart(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IAppUpdateOptions_adaptor::AllowForcedAppRestart)->_put_AllowForcedAppRestart(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AllowForcedAppRestart;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppUpdateOptions_adaptor::CatalogId)->_get_CatalogId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IAppUpdateOptions_adaptor::CatalogId)->_put_CatalogId(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} CatalogId;
	};
	IAppUpdateOptions_adaptor() {}
};
template<typename X> struct adapt<IAppUpdateOptions, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppUpdateOptions_adaptor<X> { typedef adapt IAppUpdateOptions; };
struct IAppUpdateOptions : IAppUpdateOptions_raw, generate<IAppUpdateOptions> {};

// AppUpdateOptions
template<typename X> struct statics<AppUpdateOptions, X> : X {
	typedef typename X::root_type AppUpdateOptions;
};
struct AppUpdateOptions : generate<AppUpdateOptions> {};

// IAppInstallOptions
struct IAppInstallOptions_raw : IInspectable {
	virtual STDMETHODIMP _get_CatalogId(HSTRING *value);
	virtual STDMETHODIMP _put_CatalogId(HSTRING value);
	virtual STDMETHODIMP _get_ForceUseOfNonRemovableStorage(bool *value);
	virtual STDMETHODIMP _put_ForceUseOfNonRemovableStorage(bool value);
	virtual STDMETHODIMP _get_AllowForcedAppRestart(bool *value);
	virtual STDMETHODIMP _put_AllowForcedAppRestart(bool value);
	virtual STDMETHODIMP _get_Repair(bool *value);
	virtual STDMETHODIMP _put_Repair(bool value);
	virtual STDMETHODIMP _get_TargetVolume(Management::Deployment::PackageVolume* *value);
	virtual STDMETHODIMP _put_TargetVolume(Management::Deployment::PackageVolume* value);
	virtual STDMETHODIMP _get_LaunchAfterInstall(bool *value);
	virtual STDMETHODIMP _put_LaunchAfterInstall(bool value);
};
template<typename X> struct IAppInstallOptions_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppInstallOptions_adaptor::AllowForcedAppRestart)->_get_AllowForcedAppRestart(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IAppInstallOptions_adaptor::AllowForcedAppRestart)->_put_AllowForcedAppRestart(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} AllowForcedAppRestart;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppInstallOptions_adaptor::CatalogId)->_get_CatalogId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IAppInstallOptions_adaptor::CatalogId)->_put_CatalogId(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} CatalogId;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppInstallOptions_adaptor::ForceUseOfNonRemovableStorage)->_get_ForceUseOfNonRemovableStorage(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IAppInstallOptions_adaptor::ForceUseOfNonRemovableStorage)->_put_ForceUseOfNonRemovableStorage(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ForceUseOfNonRemovableStorage;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppInstallOptions_adaptor::LaunchAfterInstall)->_get_LaunchAfterInstall(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IAppInstallOptions_adaptor::LaunchAfterInstall)->_put_LaunchAfterInstall(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} LaunchAfterInstall;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppInstallOptions_adaptor::Repair)->_get_Repair(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IAppInstallOptions_adaptor::Repair)->_put_Repair(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} Repair;
		struct : property {
			ptr<Management::Deployment::PackageVolume> get() { Management::Deployment::PackageVolume* value; hrcheck(enc(&IAppInstallOptions_adaptor::TargetVolume)->_get_TargetVolume(&value)); return from_abi(value); }
			ptr<Management::Deployment::PackageVolume> operator()() { return get(); }
			operator ptr<Management::Deployment::PackageVolume> () { return get(); }
			ptr<Management::Deployment::PackageVolume> operator->() { return get(); }
			void put(pptr<Management::Deployment::PackageVolume> value) { hrcheck(enc(&IAppInstallOptions_adaptor::TargetVolume)->_put_TargetVolume(value)); }
			void operator=(pptr<Management::Deployment::PackageVolume> value) { put(value); }
			void operator()(pptr<Management::Deployment::PackageVolume> value) { put(value); }
		} TargetVolume;
	};
	IAppInstallOptions_adaptor() {}
};
template<typename X> struct adapt<IAppInstallOptions, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallOptions_adaptor<X> { typedef adapt IAppInstallOptions; };
struct IAppInstallOptions : IAppInstallOptions_raw, generate<IAppInstallOptions> {};

// AppInstallOptions
template<typename X> struct statics<AppInstallOptions, X> : X {
	typedef typename X::root_type AppInstallOptions;
};
struct AppInstallOptions : generate<AppInstallOptions> {};

// IAppInstallManager
struct IAppInstallManager_raw : IInspectable {
	virtual STDMETHODIMP _get_AppInstallItems(Foundation::Collections::IVectorView<AppInstallItem*>* *value);
	virtual STDMETHODIMP _Cancel(HSTRING productId);
	virtual STDMETHODIMP _Pause(HSTRING productId);
	virtual STDMETHODIMP _Restart(HSTRING productId);
	virtual STDMETHODIMP _add_ItemCompleted(Foundation::TypedEventHandler<AppInstallManager*, AppInstallManagerItemEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ItemCompleted(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ItemStatusChanged(Foundation::TypedEventHandler<AppInstallManager*, AppInstallManagerItemEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ItemStatusChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_AutoUpdateSetting(InstallControl::AutoUpdateSetting *value);
	virtual STDMETHODIMP _put_AutoUpdateSetting(InstallControl::AutoUpdateSetting value);
	virtual STDMETHODIMP _get_AcquisitionIdentity(HSTRING *value);
	virtual STDMETHODIMP _put_AcquisitionIdentity(HSTRING value);
	virtual STDMETHODIMP _GetIsApplicableAsync(HSTRING productId, HSTRING skuId, Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _StartAppInstallAsync(HSTRING productId, HSTRING skuId, bool repair, bool forceUseOfNonRemovableStorage, Foundation::IAsyncOperation<AppInstallItem*>* *operation);
	virtual STDMETHODIMP _UpdateAppByPackageFamilyNameAsync(HSTRING packageFamilyName, Foundation::IAsyncOperation<AppInstallItem*>* *operation);
	virtual STDMETHODIMP _SearchForUpdatesAsync(HSTRING productId, HSTRING skuId, Foundation::IAsyncOperation<AppInstallItem*>* *operation);
	virtual STDMETHODIMP _SearchForAllUpdatesAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* *operation);
	virtual STDMETHODIMP _IsStoreBlockedByPolicyAsync(HSTRING storeClientName, HSTRING storeClientPublisher, Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _GetIsAppAllowedToInstallAsync(HSTRING productId, Foundation::IAsyncOperation<bool>* *operation);
};
template<typename X> struct IAppInstallManager_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppInstallManager_adaptor::AcquisitionIdentity)->_get_AcquisitionIdentity(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IAppInstallManager_adaptor::AcquisitionIdentity)->_put_AcquisitionIdentity(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} AcquisitionIdentity;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>> get() { Foundation::Collections::IVectorView<AppInstallItem*>* value; hrcheck(enc(&IAppInstallManager_adaptor::AppInstallItems)->_get_AppInstallItems(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>> operator->() { return get(); }
		} AppInstallItems;
		struct : property {
			InstallControl::AutoUpdateSetting get() { InstallControl::AutoUpdateSetting value; hrcheck(enc(&IAppInstallManager_adaptor::AutoUpdateSetting)->_get_AutoUpdateSetting(&value)); return value; }
			InstallControl::AutoUpdateSetting operator()() { return get(); }
			operator InstallControl::AutoUpdateSetting () { return get(); }
			void put(InstallControl::AutoUpdateSetting value) { hrcheck(enc(&IAppInstallManager_adaptor::AutoUpdateSetting)->_put_AutoUpdateSetting(value)); }
			void operator=(InstallControl::AutoUpdateSetting value) { put(value); }
			void operator()(InstallControl::AutoUpdateSetting value) { put(value); }
		} AutoUpdateSetting;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AppInstallManager>, ptr<AppInstallManagerItemEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppInstallManager_adaptor::ItemCompleted)->_add_ItemCompleted(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppInstallManager_adaptor::ItemCompleted)->_remove_ItemCompleted(token)); }
		} ItemCompleted;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<AppInstallManager>, ptr<AppInstallManagerItemEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IAppInstallManager_adaptor::ItemStatusChanged)->_add_ItemStatusChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IAppInstallManager_adaptor::ItemStatusChanged)->_remove_ItemStatusChanged(token)); }
		} ItemStatusChanged;
	};
	void Cancel(hstring_ref productId) { hrcheck(X::get()->_Cancel(productId)); }
	void Pause(hstring_ref productId) { hrcheck(X::get()->_Pause(productId)); }
	void Restart(hstring_ref productId) { hrcheck(X::get()->_Restart(productId)); }
	ptr<Foundation::IAsyncOperation<bool>> GetIsApplicableAsync(hstring_ref productId, hstring_ref skuId) { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_GetIsApplicableAsync(productId, skuId, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<AppInstallItem>>> StartAppInstallAsync(hstring_ref productId, hstring_ref skuId, bool repair, bool forceUseOfNonRemovableStorage) { Foundation::IAsyncOperation<AppInstallItem*>* operation; hrcheck(X::get()->_StartAppInstallAsync(productId, skuId, repair, forceUseOfNonRemovableStorage, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<AppInstallItem>>> UpdateAppByPackageFamilyNameAsync(hstring_ref packageFamilyName) { Foundation::IAsyncOperation<AppInstallItem*>* operation; hrcheck(X::get()->_UpdateAppByPackageFamilyNameAsync(packageFamilyName, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<AppInstallItem>>> SearchForUpdatesAsync(hstring_ref productId, hstring_ref skuId) { Foundation::IAsyncOperation<AppInstallItem*>* operation; hrcheck(X::get()->_SearchForUpdatesAsync(productId, skuId, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>>>> SearchForAllUpdatesAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* operation; hrcheck(X::get()->_SearchForAllUpdatesAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<bool>> IsStoreBlockedByPolicyAsync(hstring_ref storeClientName, hstring_ref storeClientPublisher) { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_IsStoreBlockedByPolicyAsync(storeClientName, storeClientPublisher, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<bool>> GetIsAppAllowedToInstallAsync(hstring_ref productId) { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_GetIsAppAllowedToInstallAsync(productId, &operation)); return from_abi(operation); }
	IAppInstallManager_adaptor() {}
};
template<typename X> struct adapt<IAppInstallManager, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager_adaptor<X> { typedef adapt IAppInstallManager; };
struct IAppInstallManager : IAppInstallManager_raw, generate<IAppInstallManager> {};

// IAppInstallManager6
struct IAppInstallManager6_raw : IInspectable {
	virtual STDMETHODIMP _SearchForAllUpdatesWithUpdateOptionsAsync(HSTRING correlationVector, HSTRING clientId, AppUpdateOptions* updateOptions, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* *operation);
	virtual STDMETHODIMP _SearchForAllUpdatesWithUpdateOptionsForUserAsync(System::User* user, HSTRING correlationVector, HSTRING clientId, AppUpdateOptions* updateOptions, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* *operation);
	virtual STDMETHODIMP _SearchForUpdatesWithUpdateOptionsAsync(HSTRING productId, HSTRING skuId, HSTRING correlationVector, HSTRING clientId, AppUpdateOptions* updateOptions, Foundation::IAsyncOperation<AppInstallItem*>* *operation);
	virtual STDMETHODIMP _SearchForUpdatesWithUpdateOptionsForUserAsync(System::User* user, HSTRING productId, HSTRING skuId, HSTRING correlationVector, HSTRING clientId, AppUpdateOptions* updateOptions, Foundation::IAsyncOperation<AppInstallItem*>* *operation);
	virtual STDMETHODIMP _StartProductInstallWithOptionsAsync(HSTRING productId, HSTRING flightId, HSTRING clientId, HSTRING correlationVector, AppInstallOptions* installOptions, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* *operation);
	virtual STDMETHODIMP _StartProductInstallWithOptionsForUserAsync(System::User* user, HSTRING productId, HSTRING flightId, HSTRING clientId, HSTRING correlationVector, AppInstallOptions* installOptions, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* *operation);
	virtual STDMETHODIMP _GetIsPackageIdentityAllowedToInstallAsync(HSTRING correlationVector, HSTRING packageIdentityName, HSTRING publisherCertificateName, Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _GetIsPackageIdentityAllowedToInstallForUserAsync(System::User* user, HSTRING correlationVector, HSTRING packageIdentityName, HSTRING publisherCertificateName, Foundation::IAsyncOperation<bool>* *operation);
};
template<typename X> struct IAppInstallManager6_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>>>> SearchForAllUpdatesAsync(hstring_ref correlationVector, hstring_ref clientId, pptr<AppUpdateOptions> updateOptions) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* operation; hrcheck(X::get()->_SearchForAllUpdatesWithUpdateOptionsAsync(correlationVector, clientId, updateOptions, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>>>> SearchForAllUpdatesForUserAsync(pptr<System::User> user, hstring_ref correlationVector, hstring_ref clientId, pptr<AppUpdateOptions> updateOptions) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* operation; hrcheck(X::get()->_SearchForAllUpdatesWithUpdateOptionsForUserAsync(user, correlationVector, clientId, updateOptions, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<AppInstallItem>>> SearchForUpdatesAsync(hstring_ref productId, hstring_ref skuId, hstring_ref correlationVector, hstring_ref clientId, pptr<AppUpdateOptions> updateOptions) { Foundation::IAsyncOperation<AppInstallItem*>* operation; hrcheck(X::get()->_SearchForUpdatesWithUpdateOptionsAsync(productId, skuId, correlationVector, clientId, updateOptions, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<AppInstallItem>>> SearchForUpdatesForUserAsync(pptr<System::User> user, hstring_ref productId, hstring_ref skuId, hstring_ref correlationVector, hstring_ref clientId, pptr<AppUpdateOptions> updateOptions) { Foundation::IAsyncOperation<AppInstallItem*>* operation; hrcheck(X::get()->_SearchForUpdatesWithUpdateOptionsForUserAsync(user, productId, skuId, correlationVector, clientId, updateOptions, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>>>> StartProductInstallAsync(hstring_ref productId, hstring_ref flightId, hstring_ref clientId, hstring_ref correlationVector, pptr<AppInstallOptions> installOptions) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* operation; hrcheck(X::get()->_StartProductInstallWithOptionsAsync(productId, flightId, clientId, correlationVector, installOptions, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>>>> StartProductInstallForUserAsync(pptr<System::User> user, hstring_ref productId, hstring_ref flightId, hstring_ref clientId, hstring_ref correlationVector, pptr<AppInstallOptions> installOptions) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* operation; hrcheck(X::get()->_StartProductInstallWithOptionsForUserAsync(user, productId, flightId, clientId, correlationVector, installOptions, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<bool>> GetIsPackageIdentityAllowedToInstallAsync(hstring_ref correlationVector, hstring_ref packageIdentityName, hstring_ref publisherCertificateName) { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_GetIsPackageIdentityAllowedToInstallAsync(correlationVector, packageIdentityName, publisherCertificateName, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<bool>> GetIsPackageIdentityAllowedToInstallForUserAsync(pptr<System::User> user, hstring_ref correlationVector, hstring_ref packageIdentityName, hstring_ref publisherCertificateName) { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_GetIsPackageIdentityAllowedToInstallForUserAsync(user, correlationVector, packageIdentityName, publisherCertificateName, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IAppInstallManager6, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager6_adaptor<X> { typedef adapt IAppInstallManager6; };
struct IAppInstallManager6 : IAppInstallManager6_raw, generate<IAppInstallManager6> {};

// IAppInstallManager5
struct IAppInstallManager5_raw : IInspectable {
	virtual STDMETHODIMP _get_AppInstallItemsWithGroupSupport(Foundation::Collections::IVectorView<AppInstallItem*>* *value);
};
template<typename X> struct IAppInstallManager5_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>> get() { Foundation::Collections::IVectorView<AppInstallItem*>* value; hrcheck(enc(&IAppInstallManager5_adaptor::AppInstallItemsWithGroupSupport)->_get_AppInstallItemsWithGroupSupport(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>> operator->() { return get(); }
		} AppInstallItemsWithGroupSupport;
	};
	IAppInstallManager5_adaptor() {}
};
template<typename X> struct adapt<IAppInstallManager5, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager5_adaptor<X> { typedef adapt IAppInstallManager5; };
struct IAppInstallManager5 : IAppInstallManager5_raw, generate<IAppInstallManager5> {};

// IAppInstallManager4
struct IAppInstallManager4_raw : IInspectable {
	virtual STDMETHODIMP _GetFreeUserEntitlementAsync(HSTRING storeId, HSTRING campaignId, HSTRING correlationVector, Foundation::IAsyncOperation<GetEntitlementResult*>* *ppAsyncOperation);
	virtual STDMETHODIMP _GetFreeUserEntitlementForUserAsync(System::User* user, HSTRING storeId, HSTRING campaignId, HSTRING correlationVector, Foundation::IAsyncOperation<GetEntitlementResult*>* *ppAsyncOperation);
	virtual STDMETHODIMP _GetFreeDeviceEntitlementAsync(HSTRING storeId, HSTRING campaignId, HSTRING correlationVector, Foundation::IAsyncOperation<GetEntitlementResult*>* *ppAsyncOperation);
};
template<typename X> struct IAppInstallManager4_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<GetEntitlementResult>>> GetFreeUserEntitlementAsync(hstring_ref storeId, hstring_ref campaignId, hstring_ref correlationVector) { Foundation::IAsyncOperation<GetEntitlementResult*>* ppAsyncOperation; hrcheck(X::get()->_GetFreeUserEntitlementAsync(storeId, campaignId, correlationVector, &ppAsyncOperation)); return from_abi(ppAsyncOperation); }
	ptr<Foundation::IAsyncOperation<ptr<GetEntitlementResult>>> GetFreeUserEntitlementForUserAsync(pptr<System::User> user, hstring_ref storeId, hstring_ref campaignId, hstring_ref correlationVector) { Foundation::IAsyncOperation<GetEntitlementResult*>* ppAsyncOperation; hrcheck(X::get()->_GetFreeUserEntitlementForUserAsync(user, storeId, campaignId, correlationVector, &ppAsyncOperation)); return from_abi(ppAsyncOperation); }
	ptr<Foundation::IAsyncOperation<ptr<GetEntitlementResult>>> GetFreeDeviceEntitlementAsync(hstring_ref storeId, hstring_ref campaignId, hstring_ref correlationVector) { Foundation::IAsyncOperation<GetEntitlementResult*>* ppAsyncOperation; hrcheck(X::get()->_GetFreeDeviceEntitlementAsync(storeId, campaignId, correlationVector, &ppAsyncOperation)); return from_abi(ppAsyncOperation); }
};
template<typename X> struct adapt<IAppInstallManager4, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager4_adaptor<X> { typedef adapt IAppInstallManager4; };
struct IAppInstallManager4 : IAppInstallManager4_raw, generate<IAppInstallManager4> {};

// IAppInstallManager3
struct IAppInstallManager3_raw : IInspectable {
	virtual STDMETHODIMP _StartProductInstallAsync(HSTRING productId, HSTRING catalogId, HSTRING flightId, HSTRING clientId, bool repair, bool forceUseOfNonRemovableStorage, HSTRING correlationVector, Management::Deployment::PackageVolume* targetVolume, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* *operation);
	virtual STDMETHODIMP _StartProductInstallForUserAsync(System::User* user, HSTRING productId, HSTRING catalogId, HSTRING flightId, HSTRING clientId, bool repair, bool forceUseOfNonRemovableStorage, HSTRING correlationVector, Management::Deployment::PackageVolume* targetVolume, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* *operation);
	virtual STDMETHODIMP _UpdateAppByPackageFamilyNameForUserAsync(System::User* user, HSTRING packageFamilyName, HSTRING correlationVector, Foundation::IAsyncOperation<AppInstallItem*>* *operation);
	virtual STDMETHODIMP _SearchForUpdatesForUserAsync(System::User* user, HSTRING productId, HSTRING skuId, HSTRING catalogId, HSTRING correlationVector, Foundation::IAsyncOperation<AppInstallItem*>* *operation);
	virtual STDMETHODIMP _SearchForAllUpdatesForUserAsync(System::User* user, HSTRING correlationVector, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* *operation);
	virtual STDMETHODIMP _GetIsAppAllowedToInstallForUserAsync(System::User* user, HSTRING productId, HSTRING skuId, HSTRING catalogId, HSTRING correlationVector, Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _GetIsApplicableForUserAsync(System::User* user, HSTRING productId, HSTRING skuId, Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _MoveToFrontOfDownloadQueue(HSTRING productId, HSTRING correlationVector);
};
template<typename X> struct IAppInstallManager3_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>>>> StartProductInstallAsync(hstring_ref productId, hstring_ref catalogId, hstring_ref flightId, hstring_ref clientId, bool repair, bool forceUseOfNonRemovableStorage, hstring_ref correlationVector, pptr<Management::Deployment::PackageVolume> targetVolume) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* operation; hrcheck(X::get()->_StartProductInstallAsync(productId, catalogId, flightId, clientId, repair, forceUseOfNonRemovableStorage, correlationVector, targetVolume, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>>>> StartProductInstallForUserAsync(pptr<System::User> user, hstring_ref productId, hstring_ref catalogId, hstring_ref flightId, hstring_ref clientId, bool repair, bool forceUseOfNonRemovableStorage, hstring_ref correlationVector, pptr<Management::Deployment::PackageVolume> targetVolume) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* operation; hrcheck(X::get()->_StartProductInstallForUserAsync(user, productId, catalogId, flightId, clientId, repair, forceUseOfNonRemovableStorage, correlationVector, targetVolume, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<AppInstallItem>>> UpdateAppByPackageFamilyNameForUserAsync(pptr<System::User> user, hstring_ref packageFamilyName, hstring_ref correlationVector) { Foundation::IAsyncOperation<AppInstallItem*>* operation; hrcheck(X::get()->_UpdateAppByPackageFamilyNameForUserAsync(user, packageFamilyName, correlationVector, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<AppInstallItem>>> SearchForUpdatesForUserAsync(pptr<System::User> user, hstring_ref productId, hstring_ref skuId, hstring_ref catalogId, hstring_ref correlationVector) { Foundation::IAsyncOperation<AppInstallItem*>* operation; hrcheck(X::get()->_SearchForUpdatesForUserAsync(user, productId, skuId, catalogId, correlationVector, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>>>> SearchForAllUpdatesForUserAsync(pptr<System::User> user, hstring_ref correlationVector) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* operation; hrcheck(X::get()->_SearchForAllUpdatesForUserAsync(user, correlationVector, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<bool>> GetIsAppAllowedToInstallForUserAsync(pptr<System::User> user, hstring_ref productId, hstring_ref skuId, hstring_ref catalogId, hstring_ref correlationVector) { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_GetIsAppAllowedToInstallForUserAsync(user, productId, skuId, catalogId, correlationVector, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<bool>> GetIsApplicableForUserAsync(pptr<System::User> user, hstring_ref productId, hstring_ref skuId) { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_GetIsApplicableForUserAsync(user, productId, skuId, &operation)); return from_abi(operation); }
	void MoveToFrontOfDownloadQueue(hstring_ref productId, hstring_ref correlationVector) { hrcheck(X::get()->_MoveToFrontOfDownloadQueue(productId, correlationVector)); }
};
template<typename X> struct adapt<IAppInstallManager3, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager3_adaptor<X> { typedef adapt IAppInstallManager3; };
struct IAppInstallManager3 : IAppInstallManager3_raw, generate<IAppInstallManager3> {};

// IAppInstallManager2
struct IAppInstallManager2_raw : IInspectable {
	virtual STDMETHODIMP _StartAppInstallWithTelemetryAsync(HSTRING productId, HSTRING skuId, bool repair, bool forceUseOfNonRemovableStorage, HSTRING catalogId, HSTRING bundleId, HSTRING correlationVector, Foundation::IAsyncOperation<AppInstallItem*>* *operation);
	virtual STDMETHODIMP _UpdateAppByPackageFamilyNameWithTelemetryAsync(HSTRING packageFamilyName, HSTRING correlationVector, Foundation::IAsyncOperation<AppInstallItem*>* *operation);
	virtual STDMETHODIMP _SearchForUpdatesWithTelemetryAsync(HSTRING productId, HSTRING skuId, HSTRING catalogId, HSTRING correlationVector, Foundation::IAsyncOperation<AppInstallItem*>* *operation);
	virtual STDMETHODIMP _SearchForAllUpdatesWithTelemetryAsync(HSTRING correlationVector, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* *operation);
	virtual STDMETHODIMP _GetIsAppAllowedToInstallWithTelemetryAsync(HSTRING productId, HSTRING skuId, HSTRING catalogId, HSTRING correlationVector, Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _CancelWithTelemetry(HSTRING productId, HSTRING correlationVector);
	virtual STDMETHODIMP _PauseWithTelemetry(HSTRING productId, HSTRING correlationVector);
	virtual STDMETHODIMP _RestartWithTelemetry(HSTRING productId, HSTRING correlationVector);
};
template<typename X> struct IAppInstallManager2_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<AppInstallItem>>> StartAppInstallAsync(hstring_ref productId, hstring_ref skuId, bool repair, bool forceUseOfNonRemovableStorage, hstring_ref catalogId, hstring_ref bundleId, hstring_ref correlationVector) { Foundation::IAsyncOperation<AppInstallItem*>* operation; hrcheck(X::get()->_StartAppInstallWithTelemetryAsync(productId, skuId, repair, forceUseOfNonRemovableStorage, catalogId, bundleId, correlationVector, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<AppInstallItem>>> UpdateAppByPackageFamilyNameAsync(hstring_ref packageFamilyName, hstring_ref correlationVector) { Foundation::IAsyncOperation<AppInstallItem*>* operation; hrcheck(X::get()->_UpdateAppByPackageFamilyNameWithTelemetryAsync(packageFamilyName, correlationVector, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<AppInstallItem>>> SearchForUpdatesAsync(hstring_ref productId, hstring_ref skuId, hstring_ref catalogId, hstring_ref correlationVector) { Foundation::IAsyncOperation<AppInstallItem*>* operation; hrcheck(X::get()->_SearchForUpdatesWithTelemetryAsync(productId, skuId, catalogId, correlationVector, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<AppInstallItem>>>>> SearchForAllUpdatesAsync(hstring_ref correlationVector) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<AppInstallItem*>*>* operation; hrcheck(X::get()->_SearchForAllUpdatesWithTelemetryAsync(correlationVector, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<bool>> GetIsAppAllowedToInstallAsync(hstring_ref productId, hstring_ref skuId, hstring_ref catalogId, hstring_ref correlationVector) { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_GetIsAppAllowedToInstallWithTelemetryAsync(productId, skuId, catalogId, correlationVector, &operation)); return from_abi(operation); }
	void Cancel(hstring_ref productId, hstring_ref correlationVector) { hrcheck(X::get()->_CancelWithTelemetry(productId, correlationVector)); }
	void Pause(hstring_ref productId, hstring_ref correlationVector) { hrcheck(X::get()->_PauseWithTelemetry(productId, correlationVector)); }
	void Restart(hstring_ref productId, hstring_ref correlationVector) { hrcheck(X::get()->_RestartWithTelemetry(productId, correlationVector)); }
};
template<typename X> struct adapt<IAppInstallManager2, X> : Windows::ApplicationModel::Store::Preview::InstallControl::IAppInstallManager2_adaptor<X> { typedef adapt IAppInstallManager2; };
struct IAppInstallManager2 : IAppInstallManager2_raw, generate<IAppInstallManager2> {};

// AppInstallManager
template<typename X> struct statics<AppInstallManager, X> : X {
	typedef typename X::root_type AppInstallManager;
};
struct AppInstallManager : generate<AppInstallManager> {
	using IAppInstallManager3::SearchForUpdatesForUserAsync;
	using IAppInstallManager6::SearchForUpdatesForUserAsync;
	using IAppInstallManager::Cancel;
	using IAppInstallManager2::Cancel;
	using IAppInstallManager::Pause;
	using IAppInstallManager2::Pause;
	using IAppInstallManager::GetIsAppAllowedToInstallAsync;
	using IAppInstallManager2::GetIsAppAllowedToInstallAsync;
	using IAppInstallManager3::StartProductInstallAsync;
	using IAppInstallManager6::StartProductInstallAsync;
	using IAppInstallManager::StartAppInstallAsync;
	using IAppInstallManager2::StartAppInstallAsync;
	using IAppInstallManager::UpdateAppByPackageFamilyNameAsync;
	using IAppInstallManager2::UpdateAppByPackageFamilyNameAsync;
	using IAppInstallManager::SearchForAllUpdatesAsync;
	using IAppInstallManager2::SearchForAllUpdatesAsync;
	using IAppInstallManager6::SearchForAllUpdatesAsync;
	using IAppInstallManager3::StartProductInstallForUserAsync;
	using IAppInstallManager6::StartProductInstallForUserAsync;
	using IAppInstallManager::SearchForUpdatesAsync;
	using IAppInstallManager2::SearchForUpdatesAsync;
	using IAppInstallManager6::SearchForUpdatesAsync;
	using IAppInstallManager::Restart;
	using IAppInstallManager2::Restart;
	using IAppInstallManager3::SearchForAllUpdatesForUserAsync;
	using IAppInstallManager6::SearchForAllUpdatesForUserAsync;
};
}}}}}
} // namespace iso_winrt
