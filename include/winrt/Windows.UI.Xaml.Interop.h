#pragma once
// generated by isopod tools
// namespaces:
// Windows.UI.Xaml.Interop

#include "Windows.UI.Xaml.Interop.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types


// defs

template<> struct def<Windows::UI::Xaml::Interop::NotifyCollectionChangedAction> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Interop::BindableVectorChangedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Interop::IBindableIterable> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Interop::IBindableVector> : overridable_type<Windows::UI::Xaml::Interop::IBindableIterable> {};
template<> struct def<Windows::UI::Xaml::Interop::IBindableObservableVector> : overridable_type<Windows::UI::Xaml::Interop::IBindableVector> {};
template<> struct def<Windows::UI::Xaml::Interop::IBindableVectorView> : overridable_type<Windows::UI::Xaml::Interop::IBindableIterable> {};
template<> struct def<Windows::UI::Xaml::Interop::IBindableIterator> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Interop::NotifyCollectionChangedEventHandler> : delegate_type {};
template<> struct def<Windows::UI::Xaml::Interop::INotifyCollectionChangedEventArgsFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Interop::INotifyCollectionChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs> : class_type<Platform::Object, Windows::UI::Xaml::Interop::INotifyCollectionChangedEventArgs>, composer_type<Windows::UI::Xaml::Interop::INotifyCollectionChangedEventArgsFactory> {};
template<> struct def<Windows::UI::Xaml::Interop::INotifyCollectionChanged> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Interop::TypeKind> : enum_type<int> {};
template<> struct def<Windows::UI::Xaml::Interop::TypeName> : value_type<HSTRING, Windows::UI::Xaml::Interop::TypeKind> {};

// uuids

template<> struct uuid<Windows::UI::Xaml::Interop::BindableVectorChangedEventHandler> { define_guid(0x624CD4E1, 0xD007, 0x43B1, 0x9C, 0x3, 0xAF, 0x4D, 0x3E, 0x62, 0x58, 0xC4);};
template<> struct uuid<Windows::UI::Xaml::Interop::IBindableIterable> { define_guid(0x36D2C08, 0xDF29, 0x41AF, 0x8A, 0xA2, 0xD7, 0x74, 0xBE, 0x62, 0xBA, 0x6F);};
template<> struct uuid<Windows::UI::Xaml::Interop::IBindableVector> { define_guid(0x393DE7DE, 0x6FD0, 0x4C0D, 0xBB, 0x71, 0x47, 0x24, 0x4A, 0x11, 0x3E, 0x93);};
template<> struct uuid<Windows::UI::Xaml::Interop::IBindableObservableVector> { define_guid(0xFE1EB536, 0x7E7F, 0x4F90, 0xAC, 0x9A, 0x47, 0x49, 0x84, 0xAA, 0xE5, 0x12);};
template<> struct uuid<Windows::UI::Xaml::Interop::IBindableVectorView> { define_guid(0x346DD6E7, 0x976E, 0x4BC3, 0x81, 0x5D, 0xEC, 0xE2, 0x43, 0xBC, 0xF, 0x33);};
template<> struct uuid<Windows::UI::Xaml::Interop::IBindableIterator> { define_guid(0x6A1D6C07, 0x76D, 0x49F2, 0x83, 0x14, 0xF5, 0x2C, 0x9C, 0x9A, 0x83, 0x31);};
template<> struct uuid<Windows::UI::Xaml::Interop::NotifyCollectionChangedEventHandler> { define_guid(0xCA10B37C, 0xF382, 0x4591, 0x85, 0x57, 0x5E, 0x24, 0x96, 0x52, 0x79, 0xB0);};
template<> struct uuid<Windows::UI::Xaml::Interop::INotifyCollectionChangedEventArgsFactory> { define_guid(0xB30C3E3A, 0xDF8D, 0x44A5, 0x9A, 0x38, 0x7A, 0xC0, 0xD0, 0x8C, 0xE6, 0x3D);};
template<> struct uuid<Windows::UI::Xaml::Interop::INotifyCollectionChangedEventArgs> { define_guid(0x4CF68D33, 0xE3F2, 0x4964, 0xB8, 0x5E, 0x94, 0x5B, 0x4F, 0x7E, 0x2F, 0x21);};
template<> struct uuid<Windows::UI::Xaml::Interop::INotifyCollectionChanged> { define_guid(0x28B167D5, 0x1A31, 0x465B, 0x9B, 0x25, 0xD5, 0xC3, 0xAE, 0x68, 0x6C, 0x40);};

// types

namespace Windows { namespace UI { namespace Xaml { namespace Interop {

// BindableVectorChangedEventHandler
struct BindableVectorChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IBindableObservableVector* vector, IInspectable* e) = 0;
};

// IBindableIterable
struct IBindableIterable_raw : IInspectable {
	virtual STDMETHODIMP _First(IBindableIterator* *returnValue) = 0;
};
template<typename X> struct IBindableIterable_adaptor : X {
	ptr<IBindableIterator> First() { IBindableIterator* returnValue; hrcheck(X::get()->_First(&returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IBindableIterable, X> : Windows::UI::Xaml::Interop::IBindableIterable_adaptor<X> { typedef adapt IBindableIterable; };
template<typename X> struct IBindableIterable_unadaptor : X {
	STDMETHODIMP _First(IBindableIterator* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->First()); }); }
};
template<typename X> struct unadapt<IBindableIterable, X> : Windows::UI::Xaml::Interop::IBindableIterable_unadaptor<X> {};
struct IBindableIterable : IBindableIterable_raw, generate<IBindableIterable> {};

// IBindableVector
struct IBindableVector_raw : IInspectable {
	virtual STDMETHODIMP _GetAt(unsigned index, IInspectable* *returnValue) = 0;
	virtual STDMETHODIMP _get_Size(unsigned *value) = 0;
	virtual STDMETHODIMP _GetView(IBindableVectorView* *returnValue) = 0;
	virtual STDMETHODIMP _IndexOf(IInspectable* value, unsigned *index, bool *returnValue) = 0;
	virtual STDMETHODIMP _SetAt(unsigned index, IInspectable* value) = 0;
	virtual STDMETHODIMP _InsertAt(unsigned index, IInspectable* value) = 0;
	virtual STDMETHODIMP _RemoveAt(unsigned index) = 0;
	virtual STDMETHODIMP _Append(IInspectable* value) = 0;
	virtual STDMETHODIMP _RemoveAtEnd() = 0;
	virtual STDMETHODIMP _Clear() = 0;
};
template<typename X> struct IBindableVector_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IBindableVector_adaptor::Size)->_get_Size(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Size;
	};
	object GetAt(unsigned index) { IInspectable* returnValue; hrcheck(X::get()->_GetAt(index, &returnValue)); return from_abi(returnValue); }
	ptr<IBindableVectorView> GetView() { IBindableVectorView* returnValue; hrcheck(X::get()->_GetView(&returnValue)); return from_abi(returnValue); }
	bool IndexOf(object_ref value, unsigned *index) { bool returnValue; hrcheck(X::get()->_IndexOf(value, index, &returnValue)); return returnValue; }
	void SetAt(unsigned index, object_ref value) { hrcheck(X::get()->_SetAt(index, value)); }
	void InsertAt(unsigned index, object_ref value) { hrcheck(X::get()->_InsertAt(index, value)); }
	void RemoveAt(unsigned index) { hrcheck(X::get()->_RemoveAt(index)); }
	void Append(object_ref value) { hrcheck(X::get()->_Append(value)); }
	void RemoveAtEnd() { hrcheck(X::get()->_RemoveAtEnd()); }
	void Clear() { hrcheck(X::get()->_Clear()); }
	IBindableVector_adaptor() {}
};
template<typename X> struct adapt<IBindableVector, X> : Windows::UI::Xaml::Interop::IBindableVector_adaptor<X> { typedef adapt IBindableVector; };
template<typename X> struct IBindableVector_unadaptor : X {
	STDMETHODIMP _GetAt(unsigned index, IInspectable* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetAt(index)); }); }
	STDMETHODIMP _get_Size(unsigned *value) { return hrtry([&, this] { get_prop(value, Size); }); }
	STDMETHODIMP _GetView(IBindableVectorView* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetView()); }); }
	STDMETHODIMP _IndexOf(IInspectable* value, unsigned *index, bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->IndexOf(value, index); }); }
	STDMETHODIMP _SetAt(unsigned index, IInspectable* value) { return hrtry([&, this] { X::get()->SetAt(index, value); }); }
	STDMETHODIMP _InsertAt(unsigned index, IInspectable* value) { return hrtry([&, this] { X::get()->InsertAt(index, value); }); }
	STDMETHODIMP _RemoveAt(unsigned index) { return hrtry([&, this] { X::get()->RemoveAt(index); }); }
	STDMETHODIMP _Append(IInspectable* value) { return hrtry([&, this] { X::get()->Append(value); }); }
	STDMETHODIMP _RemoveAtEnd() { return hrtry([&, this] { X::get()->RemoveAtEnd(); }); }
	STDMETHODIMP _Clear() { return hrtry([&, this] { X::get()->Clear(); }); }
};
template<typename X> struct unadapt<IBindableVector, X> : Windows::UI::Xaml::Interop::IBindableVector_unadaptor<X> {};
struct IBindableVector : IBindableVector_raw, generate<IBindableVector> {};

// IBindableObservableVector
struct IBindableObservableVector_raw : IInspectable {
	virtual STDMETHODIMP _add_VectorChanged(BindableVectorChangedEventHandler* value, Foundation::EventRegistrationToken *token) = 0;
	virtual STDMETHODIMP _remove_VectorChanged(Foundation::EventRegistrationToken token) = 0;
};
template<typename X> struct IBindableObservableVector_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<BindableVectorChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IBindableObservableVector_adaptor::VectorChanged)->_add_VectorChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IBindableObservableVector_adaptor::VectorChanged)->_remove_VectorChanged(token)); }
		} VectorChanged;
	};
	IBindableObservableVector_adaptor() {}
};
template<typename X> struct adapt<IBindableObservableVector, X> : Windows::UI::Xaml::Interop::IBindableObservableVector_adaptor<X> { typedef adapt IBindableObservableVector; };
template<typename X> struct IBindableObservableVector_unadaptor : X {
	STDMETHODIMP _add_VectorChanged(BindableVectorChangedEventHandler* value, Foundation::EventRegistrationToken *token) { return hrtry([&, this] { *token = X::get()->VectorChanged+=value; }); }
	STDMETHODIMP _remove_VectorChanged(Foundation::EventRegistrationToken token) { return hrtry([&, this] { X::get()->VectorChanged-=token; }); }
};
template<typename X> struct unadapt<IBindableObservableVector, X> : Windows::UI::Xaml::Interop::IBindableObservableVector_unadaptor<X> {};
struct IBindableObservableVector : IBindableObservableVector_raw, generate<IBindableObservableVector> {};

// IBindableVectorView
struct IBindableVectorView_raw : IInspectable {
	virtual STDMETHODIMP _GetAt(unsigned index, IInspectable* *returnValue) = 0;
	virtual STDMETHODIMP _get_Size(unsigned *value) = 0;
	virtual STDMETHODIMP _IndexOf(IInspectable* value, unsigned *index, bool *returnValue) = 0;
};
template<typename X> struct IBindableVectorView_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IBindableVectorView_adaptor::Size)->_get_Size(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Size;
	};
	object GetAt(unsigned index) { IInspectable* returnValue; hrcheck(X::get()->_GetAt(index, &returnValue)); return from_abi(returnValue); }
	bool IndexOf(object_ref value, unsigned *index) { bool returnValue; hrcheck(X::get()->_IndexOf(value, index, &returnValue)); return returnValue; }
	IBindableVectorView_adaptor() {}
};
template<typename X> struct adapt<IBindableVectorView, X> : Windows::UI::Xaml::Interop::IBindableVectorView_adaptor<X> { typedef adapt IBindableVectorView; };
template<typename X> struct IBindableVectorView_unadaptor : X {
	STDMETHODIMP _GetAt(unsigned index, IInspectable* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetAt(index)); }); }
	STDMETHODIMP _get_Size(unsigned *value) { return hrtry([&, this] { get_prop(value, Size); }); }
	STDMETHODIMP _IndexOf(IInspectable* value, unsigned *index, bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->IndexOf(value, index); }); }
};
template<typename X> struct unadapt<IBindableVectorView, X> : Windows::UI::Xaml::Interop::IBindableVectorView_unadaptor<X> {};
struct IBindableVectorView : IBindableVectorView_raw, generate<IBindableVectorView> {};

// IBindableIterator
struct IBindableIterator_raw : IInspectable {
	virtual STDMETHODIMP _get_Current(IInspectable* *value) = 0;
	virtual STDMETHODIMP _get_HasCurrent(bool *value) = 0;
	virtual STDMETHODIMP _MoveNext(bool *returnValue) = 0;
};
template<typename X> struct IBindableIterator_adaptor : X {
	union {
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IBindableIterator_adaptor::Current)->_get_Current(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} Current;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBindableIterator_adaptor::HasCurrent)->_get_HasCurrent(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasCurrent;
	};
	bool MoveNext() { bool returnValue; hrcheck(X::get()->_MoveNext(&returnValue)); return returnValue; }
	IBindableIterator_adaptor() {}
};
template<typename X> struct adapt<IBindableIterator, X> : Windows::UI::Xaml::Interop::IBindableIterator_adaptor<X> { typedef adapt IBindableIterator; };
template<typename X> struct IBindableIterator_unadaptor : X {
	STDMETHODIMP _get_Current(IInspectable* *value) { return hrtry([&, this] { get_prop(value, Current); }); }
	STDMETHODIMP _get_HasCurrent(bool *value) { return hrtry([&, this] { get_prop(value, HasCurrent); }); }
	STDMETHODIMP _MoveNext(bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->MoveNext(); }); }
};
template<typename X> struct unadapt<IBindableIterator, X> : Windows::UI::Xaml::Interop::IBindableIterator_unadaptor<X> {};
struct IBindableIterator : IBindableIterator_raw, generate<IBindableIterator> {};

// NotifyCollectionChangedEventHandler
struct NotifyCollectionChangedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(IInspectable* sender, NotifyCollectionChangedEventArgs* e) = 0;
};

// INotifyCollectionChangedEventArgsFactory
struct INotifyCollectionChangedEventArgsFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstanceWithAllParameters(NotifyCollectionChangedAction action, IBindableVector* newItems, IBindableVector* oldItems, int newIndex, int oldIndex, IInspectable* outer, IInspectable* *inner, NotifyCollectionChangedEventArgs* *instance);
};

// INotifyCollectionChangedEventArgs
struct INotifyCollectionChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Action(NotifyCollectionChangedAction *value);
	virtual STDMETHODIMP _get_NewItems(IBindableVector* *value);
	virtual STDMETHODIMP _get_OldItems(IBindableVector* *value);
	virtual STDMETHODIMP _get_NewStartingIndex(int *value);
	virtual STDMETHODIMP _get_OldStartingIndex(int *value);
};
template<typename X> struct INotifyCollectionChangedEventArgs_adaptor : X {
	union {
		struct : property {
			NotifyCollectionChangedAction get() { NotifyCollectionChangedAction value; hrcheck(enc(&INotifyCollectionChangedEventArgs_adaptor::Action)->_get_Action(&value)); return value; }
			NotifyCollectionChangedAction operator()() { return get(); }
			operator NotifyCollectionChangedAction () { return get(); }
		} Action;
		struct : property {
			ptr<IBindableVector> get() { IBindableVector* value; hrcheck(enc(&INotifyCollectionChangedEventArgs_adaptor::NewItems)->_get_NewItems(&value)); return from_abi(value); }
			ptr<IBindableVector> operator()() { return get(); }
			operator ptr<IBindableVector> () { return get(); }
			ptr<IBindableVector> operator->() { return get(); }
		} NewItems;
		struct : property {
			int get() { int value; hrcheck(enc(&INotifyCollectionChangedEventArgs_adaptor::NewStartingIndex)->_get_NewStartingIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} NewStartingIndex;
		struct : property {
			ptr<IBindableVector> get() { IBindableVector* value; hrcheck(enc(&INotifyCollectionChangedEventArgs_adaptor::OldItems)->_get_OldItems(&value)); return from_abi(value); }
			ptr<IBindableVector> operator()() { return get(); }
			operator ptr<IBindableVector> () { return get(); }
			ptr<IBindableVector> operator->() { return get(); }
		} OldItems;
		struct : property {
			int get() { int value; hrcheck(enc(&INotifyCollectionChangedEventArgs_adaptor::OldStartingIndex)->_get_OldStartingIndex(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} OldStartingIndex;
	};
	INotifyCollectionChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<INotifyCollectionChangedEventArgs, X> : Windows::UI::Xaml::Interop::INotifyCollectionChangedEventArgs_adaptor<X> { typedef adapt INotifyCollectionChangedEventArgs; };
struct INotifyCollectionChangedEventArgs : INotifyCollectionChangedEventArgs_raw, generate<INotifyCollectionChangedEventArgs> {};

// NotifyCollectionChangedEventArgs
template<typename> struct NotifyCollectionChangedEventArgs_statics {
	static NotifyCollectionChangedEventArgs *activate(NotifyCollectionChangedAction action, pptr<IBindableVector> newItems, pptr<IBindableVector> oldItems, int newIndex, int oldIndex, object_ref outer, IInspectable* *inner) { NotifyCollectionChangedEventArgs *instance; hrcheck(get_activation_factory<NotifyCollectionChangedEventArgs, INotifyCollectionChangedEventArgsFactory>()->_CreateInstanceWithAllParameters(action, newItems, oldItems, newIndex, oldIndex, outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<NotifyCollectionChangedEventArgs, X> : X, Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs_statics<void> {
	using Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs_statics<void>::activate;
	typedef typename X::root_type NotifyCollectionChangedEventArgs;
};
struct NotifyCollectionChangedEventArgs : generate<NotifyCollectionChangedEventArgs> {};

// INotifyCollectionChanged
struct INotifyCollectionChanged_raw : IInspectable {
	virtual STDMETHODIMP _add_CollectionChanged(NotifyCollectionChangedEventHandler* value, Foundation::EventRegistrationToken *token) = 0;
	virtual STDMETHODIMP _remove_CollectionChanged(Foundation::EventRegistrationToken token) = 0;
};
template<typename X> struct INotifyCollectionChanged_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<NotifyCollectionChangedEventHandler> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&INotifyCollectionChanged_adaptor::CollectionChanged)->_add_CollectionChanged(value, &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&INotifyCollectionChanged_adaptor::CollectionChanged)->_remove_CollectionChanged(token)); }
		} CollectionChanged;
	};
	INotifyCollectionChanged_adaptor() {}
};
template<typename X> struct adapt<INotifyCollectionChanged, X> : Windows::UI::Xaml::Interop::INotifyCollectionChanged_adaptor<X> { typedef adapt INotifyCollectionChanged; };
template<typename X> struct INotifyCollectionChanged_unadaptor : X {
	STDMETHODIMP _add_CollectionChanged(NotifyCollectionChangedEventHandler* value, Foundation::EventRegistrationToken *token) { return hrtry([&, this] { *token = X::get()->CollectionChanged+=value; }); }
	STDMETHODIMP _remove_CollectionChanged(Foundation::EventRegistrationToken token) { return hrtry([&, this] { X::get()->CollectionChanged-=token; }); }
};
template<typename X> struct unadapt<INotifyCollectionChanged, X> : Windows::UI::Xaml::Interop::INotifyCollectionChanged_unadaptor<X> {};
struct INotifyCollectionChanged : INotifyCollectionChanged_raw, generate<INotifyCollectionChanged> {};
}}}}
} // namespace iso_winrt
