#pragma once
// generated by isopod tools
// namespaces:
// Windows.UI.Xaml.Automation.Provider

#include "Windows.UI.Xaml.Automation.Provider.0.h"
#include "Windows.UI.Xaml.Automation.Text.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.UI.0.h"
#include "Windows.UI.Xaml.Automation.0.h"
#include "Windows.UI.Xaml.Automation.Peers.0.h"
#include "Windows.UI.Xaml.h"

namespace iso_winrt {

// forward types


// defs

template<> struct def<Windows::UI::Xaml::Automation::Provider::IAnnotationProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IDockProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IDragProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IDropTargetProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IGridItemProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IGridProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IInvokeProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IItemContainerProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IObjectModelProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IRangeValueProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IScrollItemProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IScrollProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ISelectionProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ISpreadsheetProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IStylesProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ISynchronizedInputProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ITableItemProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ITableProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ITextChildProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ITextRangeProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ITextProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ITextProvider2> : overridable_type<Windows::UI::Xaml::Automation::Provider::ITextProvider> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2> : overridable_type<Windows::UI::Xaml::Automation::Provider::ITextRangeProvider> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IToggleProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ITransformProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ITransformProvider2> : overridable_type<Windows::UI::Xaml::Automation::Provider::ITransformProvider> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IValueProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IVirtualizedItemProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IWindowProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IIRawElementProviderSimple> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple> : class_type<Windows::UI::Xaml::DependencyObject, Windows::UI::Xaml::Automation::Provider::IIRawElementProviderSimple> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ICustomNavigationProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Automation::Provider::ITextEditProvider> : overridable_type<Windows::UI::Xaml::Automation::Provider::ITextProvider> {};

// uuids

template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IAnnotationProvider> { define_guid(0x95BA1417, 0x4437, 0x451B, 0x94, 0x61, 0x5, 0xA, 0x49, 0xB5, 0x9D, 0x6);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IDockProvider> { define_guid(0x48C243F8, 0x78B1, 0x44A0, 0xAC, 0x5F, 0x75, 0x7, 0x57, 0xBC, 0xDE, 0x3C);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IDragProvider> { define_guid(0x2E7786A9, 0x7FFC, 0x4F57, 0xB9, 0x65, 0x1E, 0xF1, 0xF3, 0x73, 0xF5, 0x46);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IDropTargetProvider> { define_guid(0x7A245BDD, 0xB458, 0x4FE0, 0x98, 0xC8, 0xAA, 0xC8, 0x9D, 0xF5, 0x6D, 0x61);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider> { define_guid(0x49AC8399, 0xD626, 0x4543, 0x94, 0xB9, 0xA6, 0xD9, 0xA9, 0x59, 0x3A, 0xF6);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IGridItemProvider> { define_guid(0xFFF3683C, 0x7407, 0x45BB, 0xA9, 0x36, 0xDF, 0x3E, 0xD6, 0xD3, 0x83, 0x7D);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IGridProvider> { define_guid(0x8B62B7A0, 0x932C, 0x4490, 0x9A, 0x13, 0x2, 0xFD, 0xB3, 0x9A, 0x8F, 0x5B);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IInvokeProvider> { define_guid(0xF7D1A187, 0xB13C, 0x4540, 0xB0, 0x9E, 0x67, 0x78, 0xE2, 0xDC, 0x9B, 0xA5);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IItemContainerProvider> { define_guid(0xEF5CD845, 0xE1D4, 0x40F4, 0xBA, 0xD5, 0xC7, 0xFA, 0xD4, 0x4A, 0x70, 0x3E);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider> { define_guid(0xD014E196, 0xE50, 0x4843, 0xA5, 0xD2, 0xC2, 0x28, 0x97, 0xC8, 0x84, 0x5A);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IObjectModelProvider> { define_guid(0xC3CA36B9, 0x793, 0x4ED0, 0xBB, 0xF4, 0x9F, 0xF4, 0xE0, 0xF9, 0x8F, 0x80);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IRangeValueProvider> { define_guid(0x838A34A8, 0x7D5F, 0x4079, 0xAF, 0x3, 0xC3, 0xD0, 0x15, 0xE9, 0x34, 0x13);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IScrollItemProvider> { define_guid(0x9A3EC090, 0x5D2C, 0x4E42, 0x9E, 0xE6, 0x9D, 0x58, 0xDB, 0x10, 0xB, 0x55);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IScrollProvider> { define_guid(0x374BF581, 0x7716, 0x4BBC, 0x82, 0xEB, 0xD9, 0x97, 0x0, 0x6E, 0xA9, 0x99);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider> { define_guid(0x6A4977C1, 0x830D, 0x42D2, 0xBF, 0x62, 0x4, 0x2E, 0xBD, 0xDE, 0xCC, 0x19);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ISelectionProvider> { define_guid(0x1F018FCA, 0xB944, 0x4395, 0x8D, 0xE1, 0x88, 0xF6, 0x74, 0xAF, 0x51, 0xD3);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider> { define_guid(0xEBDE8F92, 0x6015, 0x4826, 0xB7, 0x19, 0x47, 0x52, 0x1A, 0x81, 0xC6, 0x7E);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ISpreadsheetProvider> { define_guid(0x15359093, 0xBD99, 0x4CFD, 0x9F, 0x7, 0x3B, 0x14, 0xB3, 0x15, 0xE2, 0x3D);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IStylesProvider> { define_guid(0x1A5B7A17, 0x7C01, 0x4BEC, 0x9C, 0xD4, 0x2D, 0xFA, 0x7D, 0xC2, 0x46, 0xCD);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ISynchronizedInputProvider> { define_guid(0x3D60CECB, 0xDA54, 0x4AA3, 0xB9, 0x15, 0xE3, 0x24, 0x44, 0x27, 0xD4, 0xAC);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ITableItemProvider> { define_guid(0x3B2C49CD, 0x1DE2, 0x4EE2, 0xA3, 0xE1, 0xFB, 0x55, 0x35, 0x59, 0xD1, 0x5D);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ITableProvider> { define_guid(0x7A8ED399, 0x6824, 0x4595, 0xBA, 0xB3, 0x46, 0x4B, 0xC9, 0xA0, 0x44, 0x17);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ITextChildProvider> { define_guid(0x1133C336, 0xA89B, 0x4130, 0x9B, 0xE6, 0x55, 0xE3, 0x33, 0x34, 0xF5, 0x57);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ITextRangeProvider> { define_guid(0x274688D, 0x6E9, 0x4F66, 0x94, 0x46, 0x28, 0xA5, 0xBE, 0x98, 0xFB, 0xD0);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ITextProvider> { define_guid(0xDB5BBC9F, 0x4807, 0x4F2A, 0x86, 0x78, 0x1B, 0x13, 0xF3, 0xC6, 0xE, 0x22);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ITextProvider2> { define_guid(0xDF1D48BC, 0x487, 0x4E7F, 0x9D, 0x5E, 0xF0, 0x9E, 0x77, 0xE4, 0x12, 0x46);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2> { define_guid(0xD3BE3DFB, 0x9F54, 0x4642, 0xA7, 0xA5, 0x5C, 0x18, 0xD5, 0xEE, 0x2A, 0x3F);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IToggleProvider> { define_guid(0x93B88290, 0x656F, 0x44F7, 0xAE, 0xAF, 0x78, 0xB8, 0xF9, 0x44, 0xD0, 0x62);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ITransformProvider> { define_guid(0x79670FDD, 0xF6A9, 0x4A65, 0xAF, 0x17, 0x86, 0x1D, 0xB7, 0x99, 0xA2, 0xDA);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ITransformProvider2> { define_guid(0xA8B11756, 0xA39F, 0x4E97, 0x8C, 0x7D, 0xC1, 0xEA, 0x8D, 0xD6, 0x33, 0xC5);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IValueProvider> { define_guid(0x2086B7A7, 0xAC0E, 0x47D1, 0xAB, 0x9B, 0x2A, 0x64, 0x29, 0x2A, 0xFD, 0xF8);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IVirtualizedItemProvider> { define_guid(0x17D4A04B, 0xD658, 0x48E0, 0xA5, 0x74, 0x5A, 0x51, 0x6C, 0x58, 0xDF, 0xA7);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IWindowProvider> { define_guid(0x1BAA8B3D, 0x38CF, 0x415A, 0x85, 0xD3, 0x20, 0xE4, 0x3A, 0xE, 0xC1, 0xB1);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::IIRawElementProviderSimple> { define_guid(0xEC752224, 0x9B77, 0x4720, 0xBB, 0x21, 0x4A, 0xC8, 0x9F, 0xDB, 0x1A, 0xFD);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ICustomNavigationProvider> { define_guid(0x2BD8A6D0, 0x2FA3, 0x4717, 0xB2, 0x8C, 0x49, 0x17, 0xCE, 0x54, 0x92, 0x8D);};
template<> struct uuid<Windows::UI::Xaml::Automation::Provider::ITextEditProvider> { define_guid(0xEA3605B4, 0x3A05, 0x400E, 0xB5, 0xF9, 0x4E, 0x91, 0xB4, 0xF, 0x61, 0x76);};

// types

namespace Windows { namespace UI { namespace Xaml { namespace Automation { namespace Provider {

// IAnnotationProvider
struct IAnnotationProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_AnnotationTypeId(int *value) = 0;
	virtual STDMETHODIMP _get_AnnotationTypeName(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_Author(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_DateTime(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_Target(IRawElementProviderSimple* *value) = 0;
};
template<typename X> struct IAnnotationProvider_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IAnnotationProvider_adaptor::AnnotationTypeId)->_get_AnnotationTypeId(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} AnnotationTypeId;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAnnotationProvider_adaptor::AnnotationTypeName)->_get_AnnotationTypeName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} AnnotationTypeName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAnnotationProvider_adaptor::Author)->_get_Author(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Author;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAnnotationProvider_adaptor::DateTime)->_get_DateTime(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DateTime;
		struct : property {
			ptr<IRawElementProviderSimple> get() { IRawElementProviderSimple* value; hrcheck(enc(&IAnnotationProvider_adaptor::Target)->_get_Target(&value)); return from_abi(value); }
			ptr<IRawElementProviderSimple> operator()() { return get(); }
			operator ptr<IRawElementProviderSimple> () { return get(); }
			ptr<IRawElementProviderSimple> operator->() { return get(); }
		} Target;
	};
	IAnnotationProvider_adaptor() {}
};
template<typename X> struct adapt<IAnnotationProvider, X> : Windows::UI::Xaml::Automation::Provider::IAnnotationProvider_adaptor<X> { typedef adapt IAnnotationProvider; };
template<typename X> struct IAnnotationProvider_unadaptor : X {
	STDMETHODIMP _get_AnnotationTypeId(int *value) { return hrtry([&, this] { get_prop(value, AnnotationTypeId); }); }
	STDMETHODIMP _get_AnnotationTypeName(HSTRING *value) { return hrtry([&, this] { get_prop(value, AnnotationTypeName); }); }
	STDMETHODIMP _get_Author(HSTRING *value) { return hrtry([&, this] { get_prop(value, Author); }); }
	STDMETHODIMP _get_DateTime(HSTRING *value) { return hrtry([&, this] { get_prop(value, DateTime); }); }
	STDMETHODIMP _get_Target(IRawElementProviderSimple* *value) { return hrtry([&, this] { get_prop(value, Target); }); }
};
template<typename X> struct unadapt<IAnnotationProvider, X> : Windows::UI::Xaml::Automation::Provider::IAnnotationProvider_unadaptor<X> {};
struct IAnnotationProvider : IAnnotationProvider_raw, generate<IAnnotationProvider> {};

// IDockProvider
struct IDockProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_DockPosition(Automation::DockPosition *value) = 0;
	virtual STDMETHODIMP _SetDockPosition(Automation::DockPosition dockPosition) = 0;
};
template<typename X> struct IDockProvider_adaptor : X {
	union {
		struct : property {
			Automation::DockPosition get() { Automation::DockPosition value; hrcheck(enc(&IDockProvider_adaptor::DockPosition)->_get_DockPosition(&value)); return value; }
			Automation::DockPosition operator()() { return get(); }
			operator Automation::DockPosition () { return get(); }
		} DockPosition;
	};
	void SetDockPosition(Automation::DockPosition dockPosition) { hrcheck(X::get()->_SetDockPosition(dockPosition)); }
	IDockProvider_adaptor() {}
};
template<typename X> struct adapt<IDockProvider, X> : Windows::UI::Xaml::Automation::Provider::IDockProvider_adaptor<X> { typedef adapt IDockProvider; };
template<typename X> struct IDockProvider_unadaptor : X {
	STDMETHODIMP _get_DockPosition(Automation::DockPosition *value) { return hrtry([&, this] { get_prop(value, DockPosition); }); }
	STDMETHODIMP _SetDockPosition(Automation::DockPosition dockPosition) { return hrtry([&, this] { X::get()->SetDockPosition(dockPosition); }); }
};
template<typename X> struct unadapt<IDockProvider, X> : Windows::UI::Xaml::Automation::Provider::IDockProvider_unadaptor<X> {};
struct IDockProvider : IDockProvider_raw, generate<IDockProvider> {};

// IDragProvider
struct IDragProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_IsGrabbed(bool *value) = 0;
	virtual STDMETHODIMP _get_DropEffect(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_DropEffects(unsigned *valueSize, HSTRING **value) = 0;
	virtual STDMETHODIMP _GetGrabbedItems(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) = 0;
};
template<typename X> struct IDragProvider_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDragProvider_adaptor::DropEffect)->_get_DropEffect(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DropEffect;
		struct : property {
			szarray<hstring> get() { szarray<HSTRING> value; hrcheck(enc(&IDragProvider_adaptor::DropEffects)->_get_DropEffects(&value.size, &value.p)); return from_abi(value); }
			szarray<hstring> operator()() { return get(); }
			operator szarray<hstring> () { return get(); }
		} DropEffects;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDragProvider_adaptor::IsGrabbed)->_get_IsGrabbed(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsGrabbed;
	};
	szarray<ptr<IRawElementProviderSimple>> GetGrabbedItems() { szarray<IRawElementProviderSimple*> returnValue; hrcheck(X::get()->_GetGrabbedItems(&returnValue.size, &returnValue.p)); return from_abi(returnValue); }
	IDragProvider_adaptor() {}
};
template<typename X> struct adapt<IDragProvider, X> : Windows::UI::Xaml::Automation::Provider::IDragProvider_adaptor<X> { typedef adapt IDragProvider; };
template<typename X> struct IDragProvider_unadaptor : X {
	STDMETHODIMP _get_IsGrabbed(bool *value) { return hrtry([&, this] { get_prop(value, IsGrabbed); }); }
	STDMETHODIMP _get_DropEffect(HSTRING *value) { return hrtry([&, this] { get_prop(value, DropEffect); }); }
	STDMETHODIMP _get_DropEffects(unsigned *valueSize, HSTRING **value) { return hrtry([&, this] { get_prop(value, DropEffects); }); }
	STDMETHODIMP _GetGrabbedItems(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetGrabbedItems().detach(returnValueSize)); }); }
};
template<typename X> struct unadapt<IDragProvider, X> : Windows::UI::Xaml::Automation::Provider::IDragProvider_unadaptor<X> {};
struct IDragProvider : IDragProvider_raw, generate<IDragProvider> {};

// IDropTargetProvider
struct IDropTargetProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_DropEffect(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_DropEffects(unsigned *valueSize, HSTRING **value) = 0;
};
template<typename X> struct IDropTargetProvider_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDropTargetProvider_adaptor::DropEffect)->_get_DropEffect(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DropEffect;
		struct : property {
			szarray<hstring> get() { szarray<HSTRING> value; hrcheck(enc(&IDropTargetProvider_adaptor::DropEffects)->_get_DropEffects(&value.size, &value.p)); return from_abi(value); }
			szarray<hstring> operator()() { return get(); }
			operator szarray<hstring> () { return get(); }
		} DropEffects;
	};
	IDropTargetProvider_adaptor() {}
};
template<typename X> struct adapt<IDropTargetProvider, X> : Windows::UI::Xaml::Automation::Provider::IDropTargetProvider_adaptor<X> { typedef adapt IDropTargetProvider; };
template<typename X> struct IDropTargetProvider_unadaptor : X {
	STDMETHODIMP _get_DropEffect(HSTRING *value) { return hrtry([&, this] { get_prop(value, DropEffect); }); }
	STDMETHODIMP _get_DropEffects(unsigned *valueSize, HSTRING **value) { return hrtry([&, this] { get_prop(value, DropEffects); }); }
};
template<typename X> struct unadapt<IDropTargetProvider, X> : Windows::UI::Xaml::Automation::Provider::IDropTargetProvider_unadaptor<X> {};
struct IDropTargetProvider : IDropTargetProvider_raw, generate<IDropTargetProvider> {};

// IExpandCollapseProvider
struct IExpandCollapseProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_ExpandCollapseState(Automation::ExpandCollapseState *value) = 0;
	virtual STDMETHODIMP _Collapse() = 0;
	virtual STDMETHODIMP _Expand() = 0;
};
template<typename X> struct IExpandCollapseProvider_adaptor : X {
	union {
		struct : property {
			Automation::ExpandCollapseState get() { Automation::ExpandCollapseState value; hrcheck(enc(&IExpandCollapseProvider_adaptor::ExpandCollapseState)->_get_ExpandCollapseState(&value)); return value; }
			Automation::ExpandCollapseState operator()() { return get(); }
			operator Automation::ExpandCollapseState () { return get(); }
		} ExpandCollapseState;
	};
	void Collapse() { hrcheck(X::get()->_Collapse()); }
	void Expand() { hrcheck(X::get()->_Expand()); }
	IExpandCollapseProvider_adaptor() {}
};
template<typename X> struct adapt<IExpandCollapseProvider, X> : Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider_adaptor<X> { typedef adapt IExpandCollapseProvider; };
template<typename X> struct IExpandCollapseProvider_unadaptor : X {
	STDMETHODIMP _get_ExpandCollapseState(Automation::ExpandCollapseState *value) { return hrtry([&, this] { get_prop(value, ExpandCollapseState); }); }
	STDMETHODIMP _Collapse() { return hrtry([&, this] { X::get()->Collapse(); }); }
	STDMETHODIMP _Expand() { return hrtry([&, this] { X::get()->Expand(); }); }
};
template<typename X> struct unadapt<IExpandCollapseProvider, X> : Windows::UI::Xaml::Automation::Provider::IExpandCollapseProvider_unadaptor<X> {};
struct IExpandCollapseProvider : IExpandCollapseProvider_raw, generate<IExpandCollapseProvider> {};

// IGridItemProvider
struct IGridItemProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_Column(int *value) = 0;
	virtual STDMETHODIMP _get_ColumnSpan(int *value) = 0;
	virtual STDMETHODIMP _get_ContainingGrid(IRawElementProviderSimple* *value) = 0;
	virtual STDMETHODIMP _get_Row(int *value) = 0;
	virtual STDMETHODIMP _get_RowSpan(int *value) = 0;
};
template<typename X> struct IGridItemProvider_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IGridItemProvider_adaptor::Column)->_get_Column(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} Column;
		struct : property {
			int get() { int value; hrcheck(enc(&IGridItemProvider_adaptor::ColumnSpan)->_get_ColumnSpan(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} ColumnSpan;
		struct : property {
			ptr<IRawElementProviderSimple> get() { IRawElementProviderSimple* value; hrcheck(enc(&IGridItemProvider_adaptor::ContainingGrid)->_get_ContainingGrid(&value)); return from_abi(value); }
			ptr<IRawElementProviderSimple> operator()() { return get(); }
			operator ptr<IRawElementProviderSimple> () { return get(); }
			ptr<IRawElementProviderSimple> operator->() { return get(); }
		} ContainingGrid;
		struct : property {
			int get() { int value; hrcheck(enc(&IGridItemProvider_adaptor::Row)->_get_Row(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} Row;
		struct : property {
			int get() { int value; hrcheck(enc(&IGridItemProvider_adaptor::RowSpan)->_get_RowSpan(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} RowSpan;
	};
	IGridItemProvider_adaptor() {}
};
template<typename X> struct adapt<IGridItemProvider, X> : Windows::UI::Xaml::Automation::Provider::IGridItemProvider_adaptor<X> { typedef adapt IGridItemProvider; };
template<typename X> struct IGridItemProvider_unadaptor : X {
	STDMETHODIMP _get_Column(int *value) { return hrtry([&, this] { get_prop(value, Column); }); }
	STDMETHODIMP _get_ColumnSpan(int *value) { return hrtry([&, this] { get_prop(value, ColumnSpan); }); }
	STDMETHODIMP _get_ContainingGrid(IRawElementProviderSimple* *value) { return hrtry([&, this] { get_prop(value, ContainingGrid); }); }
	STDMETHODIMP _get_Row(int *value) { return hrtry([&, this] { get_prop(value, Row); }); }
	STDMETHODIMP _get_RowSpan(int *value) { return hrtry([&, this] { get_prop(value, RowSpan); }); }
};
template<typename X> struct unadapt<IGridItemProvider, X> : Windows::UI::Xaml::Automation::Provider::IGridItemProvider_unadaptor<X> {};
struct IGridItemProvider : IGridItemProvider_raw, generate<IGridItemProvider> {};

// IGridProvider
struct IGridProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_ColumnCount(int *value) = 0;
	virtual STDMETHODIMP _get_RowCount(int *value) = 0;
	virtual STDMETHODIMP _GetItem(int row, int column, IRawElementProviderSimple* *returnValue) = 0;
};
template<typename X> struct IGridProvider_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IGridProvider_adaptor::ColumnCount)->_get_ColumnCount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} ColumnCount;
		struct : property {
			int get() { int value; hrcheck(enc(&IGridProvider_adaptor::RowCount)->_get_RowCount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} RowCount;
	};
	ptr<IRawElementProviderSimple> GetItem(int row, int column) { IRawElementProviderSimple* returnValue; hrcheck(X::get()->_GetItem(row, column, &returnValue)); return from_abi(returnValue); }
	IGridProvider_adaptor() {}
};
template<typename X> struct adapt<IGridProvider, X> : Windows::UI::Xaml::Automation::Provider::IGridProvider_adaptor<X> { typedef adapt IGridProvider; };
template<typename X> struct IGridProvider_unadaptor : X {
	STDMETHODIMP _get_ColumnCount(int *value) { return hrtry([&, this] { get_prop(value, ColumnCount); }); }
	STDMETHODIMP _get_RowCount(int *value) { return hrtry([&, this] { get_prop(value, RowCount); }); }
	STDMETHODIMP _GetItem(int row, int column, IRawElementProviderSimple* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetItem(row, column)); }); }
};
template<typename X> struct unadapt<IGridProvider, X> : Windows::UI::Xaml::Automation::Provider::IGridProvider_unadaptor<X> {};
struct IGridProvider : IGridProvider_raw, generate<IGridProvider> {};

// IInvokeProvider
struct IInvokeProvider_raw : IInspectable {
	virtual STDMETHODIMP _Invoke() = 0;
};
template<typename X> struct IInvokeProvider_adaptor : X {
	void Invoke() { hrcheck(X::get()->_Invoke()); }
};
template<typename X> struct adapt<IInvokeProvider, X> : Windows::UI::Xaml::Automation::Provider::IInvokeProvider_adaptor<X> { typedef adapt IInvokeProvider; };
template<typename X> struct IInvokeProvider_unadaptor : X {};
template<typename X> struct unadapt<IInvokeProvider, X> : Windows::UI::Xaml::Automation::Provider::IInvokeProvider_unadaptor<X> {};
struct IInvokeProvider : IInvokeProvider_raw, generate<IInvokeProvider> {};

// IItemContainerProvider
struct IItemContainerProvider_raw : IInspectable {
	virtual STDMETHODIMP _FindItemByProperty(IRawElementProviderSimple* startAfter, AutomationProperty* automationProperty, IInspectable* value, IRawElementProviderSimple* *returnValue) = 0;
};
template<typename X> struct IItemContainerProvider_adaptor : X {
	ptr<IRawElementProviderSimple> FindItemByProperty(pptr<IRawElementProviderSimple> startAfter, pptr<AutomationProperty> automationProperty, object_ref value) { IRawElementProviderSimple* returnValue; hrcheck(X::get()->_FindItemByProperty(startAfter, automationProperty, value, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IItemContainerProvider, X> : Windows::UI::Xaml::Automation::Provider::IItemContainerProvider_adaptor<X> { typedef adapt IItemContainerProvider; };
template<typename X> struct IItemContainerProvider_unadaptor : X {
	STDMETHODIMP _FindItemByProperty(IRawElementProviderSimple* startAfter, AutomationProperty* automationProperty, IInspectable* value, IRawElementProviderSimple* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->FindItemByProperty(startAfter, automationProperty, value)); }); }
};
template<typename X> struct unadapt<IItemContainerProvider, X> : Windows::UI::Xaml::Automation::Provider::IItemContainerProvider_unadaptor<X> {};
struct IItemContainerProvider : IItemContainerProvider_raw, generate<IItemContainerProvider> {};

// IMultipleViewProvider
struct IMultipleViewProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_CurrentView(int *value) = 0;
	virtual STDMETHODIMP _GetSupportedViews(unsigned *returnValueSize, int **returnValue) = 0;
	virtual STDMETHODIMP _GetViewName(int viewId, HSTRING *returnValue) = 0;
	virtual STDMETHODIMP _SetCurrentView(int viewId) = 0;
};
template<typename X> struct IMultipleViewProvider_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IMultipleViewProvider_adaptor::CurrentView)->_get_CurrentView(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} CurrentView;
	};
	szarray<int> GetSupportedViews() { szarray<int> returnValue; hrcheck(X::get()->_GetSupportedViews(&returnValue.size, &returnValue.p)); return returnValue; }
	hstring GetViewName(int viewId) { HSTRING returnValue; hrcheck(X::get()->_GetViewName(viewId, &returnValue)); return from_abi(returnValue); }
	void SetCurrentView(int viewId) { hrcheck(X::get()->_SetCurrentView(viewId)); }
	IMultipleViewProvider_adaptor() {}
};
template<typename X> struct adapt<IMultipleViewProvider, X> : Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider_adaptor<X> { typedef adapt IMultipleViewProvider; };
template<typename X> struct IMultipleViewProvider_unadaptor : X {
	STDMETHODIMP _get_CurrentView(int *value) { return hrtry([&, this] { get_prop(value, CurrentView); }); }
	STDMETHODIMP _GetSupportedViews(unsigned *returnValueSize, int **returnValue) { return hrtry([&, this] { *returnValue = X::get()->GetSupportedViews().detach(returnValueSize); }); }
	STDMETHODIMP _GetViewName(int viewId, HSTRING *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetViewName(viewId)); }); }
	STDMETHODIMP _SetCurrentView(int viewId) { return hrtry([&, this] { X::get()->SetCurrentView(viewId); }); }
};
template<typename X> struct unadapt<IMultipleViewProvider, X> : Windows::UI::Xaml::Automation::Provider::IMultipleViewProvider_unadaptor<X> {};
struct IMultipleViewProvider : IMultipleViewProvider_raw, generate<IMultipleViewProvider> {};

// IObjectModelProvider
struct IObjectModelProvider_raw : IInspectable {
	virtual STDMETHODIMP _GetUnderlyingObjectModel(IInspectable* *returnValue) = 0;
};
template<typename X> struct IObjectModelProvider_adaptor : X {
	object GetUnderlyingObjectModel() { IInspectable* returnValue; hrcheck(X::get()->_GetUnderlyingObjectModel(&returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IObjectModelProvider, X> : Windows::UI::Xaml::Automation::Provider::IObjectModelProvider_adaptor<X> { typedef adapt IObjectModelProvider; };
template<typename X> struct IObjectModelProvider_unadaptor : X {
	STDMETHODIMP _GetUnderlyingObjectModel(IInspectable* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetUnderlyingObjectModel()); }); }
};
template<typename X> struct unadapt<IObjectModelProvider, X> : Windows::UI::Xaml::Automation::Provider::IObjectModelProvider_unadaptor<X> {};
struct IObjectModelProvider : IObjectModelProvider_raw, generate<IObjectModelProvider> {};

// IRangeValueProvider
struct IRangeValueProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_IsReadOnly(bool *value) = 0;
	virtual STDMETHODIMP _get_LargeChange(double *value) = 0;
	virtual STDMETHODIMP _get_Maximum(double *value) = 0;
	virtual STDMETHODIMP _get_Minimum(double *value) = 0;
	virtual STDMETHODIMP _get_SmallChange(double *value) = 0;
	virtual STDMETHODIMP _get_Value(double *value) = 0;
	virtual STDMETHODIMP _SetValue(double value) = 0;
};
template<typename X> struct IRangeValueProvider_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRangeValueProvider_adaptor::IsReadOnly)->_get_IsReadOnly(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsReadOnly;
		struct : property {
			double get() { double value; hrcheck(enc(&IRangeValueProvider_adaptor::LargeChange)->_get_LargeChange(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} LargeChange;
		struct : property {
			double get() { double value; hrcheck(enc(&IRangeValueProvider_adaptor::Maximum)->_get_Maximum(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} Maximum;
		struct : property {
			double get() { double value; hrcheck(enc(&IRangeValueProvider_adaptor::Minimum)->_get_Minimum(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} Minimum;
		struct : property {
			double get() { double value; hrcheck(enc(&IRangeValueProvider_adaptor::SmallChange)->_get_SmallChange(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} SmallChange;
		struct : property {
			double get() { double value; hrcheck(enc(&IRangeValueProvider_adaptor::Value)->_get_Value(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} Value;
	};
	void SetValue(double value) { hrcheck(X::get()->_SetValue(value)); }
	IRangeValueProvider_adaptor() {}
};
template<typename X> struct adapt<IRangeValueProvider, X> : Windows::UI::Xaml::Automation::Provider::IRangeValueProvider_adaptor<X> { typedef adapt IRangeValueProvider; };
template<typename X> struct IRangeValueProvider_unadaptor : X {
	STDMETHODIMP _get_IsReadOnly(bool *value) { return hrtry([&, this] { get_prop(value, IsReadOnly); }); }
	STDMETHODIMP _get_LargeChange(double *value) { return hrtry([&, this] { get_prop(value, LargeChange); }); }
	STDMETHODIMP _get_Maximum(double *value) { return hrtry([&, this] { get_prop(value, Maximum); }); }
	STDMETHODIMP _get_Minimum(double *value) { return hrtry([&, this] { get_prop(value, Minimum); }); }
	STDMETHODIMP _get_SmallChange(double *value) { return hrtry([&, this] { get_prop(value, SmallChange); }); }
	STDMETHODIMP _get_Value(double *value) { return hrtry([&, this] { get_prop(value, Value); }); }
	STDMETHODIMP _SetValue(double value) { return hrtry([&, this] { X::get()->SetValue(value); }); }
};
template<typename X> struct unadapt<IRangeValueProvider, X> : Windows::UI::Xaml::Automation::Provider::IRangeValueProvider_unadaptor<X> {};
struct IRangeValueProvider : IRangeValueProvider_raw, generate<IRangeValueProvider> {};

// IScrollItemProvider
struct IScrollItemProvider_raw : IInspectable {
	virtual STDMETHODIMP _ScrollIntoView() = 0;
};
template<typename X> struct IScrollItemProvider_adaptor : X {
	void ScrollIntoView() { hrcheck(X::get()->_ScrollIntoView()); }
};
template<typename X> struct adapt<IScrollItemProvider, X> : Windows::UI::Xaml::Automation::Provider::IScrollItemProvider_adaptor<X> { typedef adapt IScrollItemProvider; };
template<typename X> struct IScrollItemProvider_unadaptor : X {
	STDMETHODIMP _ScrollIntoView() { return hrtry([&, this] { X::get()->ScrollIntoView(); }); }
};
template<typename X> struct unadapt<IScrollItemProvider, X> : Windows::UI::Xaml::Automation::Provider::IScrollItemProvider_unadaptor<X> {};
struct IScrollItemProvider : IScrollItemProvider_raw, generate<IScrollItemProvider> {};

// IScrollProvider
struct IScrollProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_HorizontallyScrollable(bool *value) = 0;
	virtual STDMETHODIMP _get_HorizontalScrollPercent(double *value) = 0;
	virtual STDMETHODIMP _get_HorizontalViewSize(double *value) = 0;
	virtual STDMETHODIMP _get_VerticallyScrollable(bool *value) = 0;
	virtual STDMETHODIMP _get_VerticalScrollPercent(double *value) = 0;
	virtual STDMETHODIMP _get_VerticalViewSize(double *value) = 0;
	virtual STDMETHODIMP _Scroll(ScrollAmount horizontalAmount, ScrollAmount verticalAmount) = 0;
	virtual STDMETHODIMP _SetScrollPercent(double horizontalPercent, double verticalPercent) = 0;
};
template<typename X> struct IScrollProvider_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollProvider_adaptor::HorizontalScrollPercent)->_get_HorizontalScrollPercent(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} HorizontalScrollPercent;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollProvider_adaptor::HorizontalViewSize)->_get_HorizontalViewSize(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} HorizontalViewSize;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollProvider_adaptor::HorizontallyScrollable)->_get_HorizontallyScrollable(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HorizontallyScrollable;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollProvider_adaptor::VerticalScrollPercent)->_get_VerticalScrollPercent(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} VerticalScrollPercent;
		struct : property {
			double get() { double value; hrcheck(enc(&IScrollProvider_adaptor::VerticalViewSize)->_get_VerticalViewSize(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} VerticalViewSize;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IScrollProvider_adaptor::VerticallyScrollable)->_get_VerticallyScrollable(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} VerticallyScrollable;
	};
	void Scroll(ScrollAmount horizontalAmount, ScrollAmount verticalAmount) { hrcheck(X::get()->_Scroll(horizontalAmount, verticalAmount)); }
	void SetScrollPercent(double horizontalPercent, double verticalPercent) { hrcheck(X::get()->_SetScrollPercent(horizontalPercent, verticalPercent)); }
	IScrollProvider_adaptor() {}
};
template<typename X> struct adapt<IScrollProvider, X> : Windows::UI::Xaml::Automation::Provider::IScrollProvider_adaptor<X> { typedef adapt IScrollProvider; };
template<typename X> struct IScrollProvider_unadaptor : X {
	STDMETHODIMP _get_HorizontallyScrollable(bool *value) { return hrtry([&, this] { get_prop(value, HorizontallyScrollable); }); }
	STDMETHODIMP _get_HorizontalScrollPercent(double *value) { return hrtry([&, this] { get_prop(value, HorizontalScrollPercent); }); }
	STDMETHODIMP _get_HorizontalViewSize(double *value) { return hrtry([&, this] { get_prop(value, HorizontalViewSize); }); }
	STDMETHODIMP _get_VerticallyScrollable(bool *value) { return hrtry([&, this] { get_prop(value, VerticallyScrollable); }); }
	STDMETHODIMP _get_VerticalScrollPercent(double *value) { return hrtry([&, this] { get_prop(value, VerticalScrollPercent); }); }
	STDMETHODIMP _get_VerticalViewSize(double *value) { return hrtry([&, this] { get_prop(value, VerticalViewSize); }); }
	STDMETHODIMP _Scroll(ScrollAmount horizontalAmount, ScrollAmount verticalAmount) { return hrtry([&, this] { X::get()->Scroll(horizontalAmount, verticalAmount); }); }
	STDMETHODIMP _SetScrollPercent(double horizontalPercent, double verticalPercent) { return hrtry([&, this] { X::get()->SetScrollPercent(horizontalPercent, verticalPercent); }); }
};
template<typename X> struct unadapt<IScrollProvider, X> : Windows::UI::Xaml::Automation::Provider::IScrollProvider_unadaptor<X> {};
struct IScrollProvider : IScrollProvider_raw, generate<IScrollProvider> {};

// ISelectionItemProvider
struct ISelectionItemProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_IsSelected(bool *value) = 0;
	virtual STDMETHODIMP _get_SelectionContainer(IRawElementProviderSimple* *value) = 0;
	virtual STDMETHODIMP _AddToSelection() = 0;
	virtual STDMETHODIMP _RemoveFromSelection() = 0;
	virtual STDMETHODIMP _Select() = 0;
};
template<typename X> struct ISelectionItemProvider_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISelectionItemProvider_adaptor::IsSelected)->_get_IsSelected(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsSelected;
		struct : property {
			ptr<IRawElementProviderSimple> get() { IRawElementProviderSimple* value; hrcheck(enc(&ISelectionItemProvider_adaptor::SelectionContainer)->_get_SelectionContainer(&value)); return from_abi(value); }
			ptr<IRawElementProviderSimple> operator()() { return get(); }
			operator ptr<IRawElementProviderSimple> () { return get(); }
			ptr<IRawElementProviderSimple> operator->() { return get(); }
		} SelectionContainer;
	};
	void AddToSelection() { hrcheck(X::get()->_AddToSelection()); }
	void RemoveFromSelection() { hrcheck(X::get()->_RemoveFromSelection()); }
	void Select() { hrcheck(X::get()->_Select()); }
	ISelectionItemProvider_adaptor() {}
};
template<typename X> struct adapt<ISelectionItemProvider, X> : Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider_adaptor<X> { typedef adapt ISelectionItemProvider; };
template<typename X> struct ISelectionItemProvider_unadaptor : X {
	STDMETHODIMP _get_IsSelected(bool *value) { return hrtry([&, this] { get_prop(value, IsSelected); }); }
	STDMETHODIMP _get_SelectionContainer(IRawElementProviderSimple* *value) { return hrtry([&, this] { get_prop(value, SelectionContainer); }); }
	STDMETHODIMP _AddToSelection() { return hrtry([&, this] { X::get()->AddToSelection(); }); }
	STDMETHODIMP _RemoveFromSelection() { return hrtry([&, this] { X::get()->RemoveFromSelection(); }); }
	STDMETHODIMP _Select() { return hrtry([&, this] { X::get()->Select(); }); }
};
template<typename X> struct unadapt<ISelectionItemProvider, X> : Windows::UI::Xaml::Automation::Provider::ISelectionItemProvider_unadaptor<X> {};
struct ISelectionItemProvider : ISelectionItemProvider_raw, generate<ISelectionItemProvider> {};

// ISelectionProvider
struct ISelectionProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_CanSelectMultiple(bool *value) = 0;
	virtual STDMETHODIMP _get_IsSelectionRequired(bool *value) = 0;
	virtual STDMETHODIMP _GetSelection(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) = 0;
};
template<typename X> struct ISelectionProvider_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISelectionProvider_adaptor::CanSelectMultiple)->_get_CanSelectMultiple(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanSelectMultiple;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ISelectionProvider_adaptor::IsSelectionRequired)->_get_IsSelectionRequired(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsSelectionRequired;
	};
	szarray<ptr<IRawElementProviderSimple>> GetSelection() { szarray<IRawElementProviderSimple*> returnValue; hrcheck(X::get()->_GetSelection(&returnValue.size, &returnValue.p)); return from_abi(returnValue); }
	ISelectionProvider_adaptor() {}
};
template<typename X> struct adapt<ISelectionProvider, X> : Windows::UI::Xaml::Automation::Provider::ISelectionProvider_adaptor<X> { typedef adapt ISelectionProvider; };
template<typename X> struct ISelectionProvider_unadaptor : X {
	STDMETHODIMP _get_CanSelectMultiple(bool *value) { return hrtry([&, this] { get_prop(value, CanSelectMultiple); }); }
	STDMETHODIMP _get_IsSelectionRequired(bool *value) { return hrtry([&, this] { get_prop(value, IsSelectionRequired); }); }
	STDMETHODIMP _GetSelection(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetSelection().detach(returnValueSize)); }); }
};
template<typename X> struct unadapt<ISelectionProvider, X> : Windows::UI::Xaml::Automation::Provider::ISelectionProvider_unadaptor<X> {};
struct ISelectionProvider : ISelectionProvider_raw, generate<ISelectionProvider> {};

// ISpreadsheetItemProvider
struct ISpreadsheetItemProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_Formula(HSTRING *value) = 0;
	virtual STDMETHODIMP _GetAnnotationObjects(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) = 0;
	virtual STDMETHODIMP _GetAnnotationTypes(unsigned *returnValueSize, AnnotationType **returnValue) = 0;
};
template<typename X> struct ISpreadsheetItemProvider_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISpreadsheetItemProvider_adaptor::Formula)->_get_Formula(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Formula;
	};
	szarray<ptr<IRawElementProviderSimple>> GetAnnotationObjects() { szarray<IRawElementProviderSimple*> returnValue; hrcheck(X::get()->_GetAnnotationObjects(&returnValue.size, &returnValue.p)); return from_abi(returnValue); }
	szarray<AnnotationType> GetAnnotationTypes() { szarray<AnnotationType> returnValue; hrcheck(X::get()->_GetAnnotationTypes(&returnValue.size, &returnValue.p)); return returnValue; }
	ISpreadsheetItemProvider_adaptor() {}
};
template<typename X> struct adapt<ISpreadsheetItemProvider, X> : Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider_adaptor<X> { typedef adapt ISpreadsheetItemProvider; };
template<typename X> struct ISpreadsheetItemProvider_unadaptor : X {
	STDMETHODIMP _get_Formula(HSTRING *value) { return hrtry([&, this] { get_prop(value, Formula); }); }
	STDMETHODIMP _GetAnnotationObjects(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetAnnotationObjects().detach(returnValueSize)); }); }
	STDMETHODIMP _GetAnnotationTypes(unsigned *returnValueSize, AnnotationType **returnValue) { return hrtry([&, this] { *returnValue = X::get()->GetAnnotationTypes().detach(returnValueSize); }); }
};
template<typename X> struct unadapt<ISpreadsheetItemProvider, X> : Windows::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider_unadaptor<X> {};
struct ISpreadsheetItemProvider : ISpreadsheetItemProvider_raw, generate<ISpreadsheetItemProvider> {};

// ISpreadsheetProvider
struct ISpreadsheetProvider_raw : IInspectable {
	virtual STDMETHODIMP _GetItemByName(HSTRING name, IRawElementProviderSimple* *returnValue) = 0;
};
template<typename X> struct ISpreadsheetProvider_adaptor : X {
	ptr<IRawElementProviderSimple> GetItemByName(hstring_ref name) { IRawElementProviderSimple* returnValue; hrcheck(X::get()->_GetItemByName(name, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<ISpreadsheetProvider, X> : Windows::UI::Xaml::Automation::Provider::ISpreadsheetProvider_adaptor<X> { typedef adapt ISpreadsheetProvider; };
template<typename X> struct ISpreadsheetProvider_unadaptor : X {
	STDMETHODIMP _GetItemByName(HSTRING name, IRawElementProviderSimple* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetItemByName(name)); }); }
};
template<typename X> struct unadapt<ISpreadsheetProvider, X> : Windows::UI::Xaml::Automation::Provider::ISpreadsheetProvider_unadaptor<X> {};
struct ISpreadsheetProvider : ISpreadsheetProvider_raw, generate<ISpreadsheetProvider> {};

// IStylesProvider
struct IStylesProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_ExtendedProperties(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_FillColor(Color *value) = 0;
	virtual STDMETHODIMP _get_FillPatternColor(Color *value) = 0;
	virtual STDMETHODIMP _get_FillPatternStyle(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_Shape(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_StyleId(int *value) = 0;
	virtual STDMETHODIMP _get_StyleName(HSTRING *value) = 0;
};
template<typename X> struct IStylesProvider_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStylesProvider_adaptor::ExtendedProperties)->_get_ExtendedProperties(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ExtendedProperties;
		struct : property {
			Color get() { Color value; hrcheck(enc(&IStylesProvider_adaptor::FillColor)->_get_FillColor(&value)); return value; }
			Color operator()() { return get(); }
			operator Color () { return get(); }
		} FillColor;
		struct : property {
			Color get() { Color value; hrcheck(enc(&IStylesProvider_adaptor::FillPatternColor)->_get_FillPatternColor(&value)); return value; }
			Color operator()() { return get(); }
			operator Color () { return get(); }
		} FillPatternColor;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStylesProvider_adaptor::FillPatternStyle)->_get_FillPatternStyle(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} FillPatternStyle;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStylesProvider_adaptor::Shape)->_get_Shape(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Shape;
		struct : property {
			int get() { int value; hrcheck(enc(&IStylesProvider_adaptor::StyleId)->_get_StyleId(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} StyleId;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStylesProvider_adaptor::StyleName)->_get_StyleName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} StyleName;
	};
	IStylesProvider_adaptor() {}
};
template<typename X> struct adapt<IStylesProvider, X> : Windows::UI::Xaml::Automation::Provider::IStylesProvider_adaptor<X> { typedef adapt IStylesProvider; };
template<typename X> struct IStylesProvider_unadaptor : X {
	STDMETHODIMP _get_ExtendedProperties(HSTRING *value) { return hrtry([&, this] { get_prop(value, ExtendedProperties); }); }
	STDMETHODIMP _get_FillColor(Color *value) { return hrtry([&, this] { get_prop(value, FillColor); }); }
	STDMETHODIMP _get_FillPatternColor(Color *value) { return hrtry([&, this] { get_prop(value, FillPatternColor); }); }
	STDMETHODIMP _get_FillPatternStyle(HSTRING *value) { return hrtry([&, this] { get_prop(value, FillPatternStyle); }); }
	STDMETHODIMP _get_Shape(HSTRING *value) { return hrtry([&, this] { get_prop(value, Shape); }); }
	STDMETHODIMP _get_StyleId(int *value) { return hrtry([&, this] { get_prop(value, StyleId); }); }
	STDMETHODIMP _get_StyleName(HSTRING *value) { return hrtry([&, this] { get_prop(value, StyleName); }); }
};
template<typename X> struct unadapt<IStylesProvider, X> : Windows::UI::Xaml::Automation::Provider::IStylesProvider_unadaptor<X> {};
struct IStylesProvider : IStylesProvider_raw, generate<IStylesProvider> {};

// ISynchronizedInputProvider
struct ISynchronizedInputProvider_raw : IInspectable {
	virtual STDMETHODIMP _Cancel() = 0;
	virtual STDMETHODIMP _StartListening(SynchronizedInputType inputType) = 0;
};
template<typename X> struct ISynchronizedInputProvider_adaptor : X {
	void Cancel() { hrcheck(X::get()->_Cancel()); }
	void StartListening(SynchronizedInputType inputType) { hrcheck(X::get()->_StartListening(inputType)); }
};
template<typename X> struct adapt<ISynchronizedInputProvider, X> : Windows::UI::Xaml::Automation::Provider::ISynchronizedInputProvider_adaptor<X> { typedef adapt ISynchronizedInputProvider; };
template<typename X> struct ISynchronizedInputProvider_unadaptor : X {
	STDMETHODIMP _Cancel() { return hrtry([&, this] { X::get()->Cancel(); }); }
	STDMETHODIMP _StartListening(SynchronizedInputType inputType) { return hrtry([&, this] { X::get()->StartListening(inputType); }); }
};
template<typename X> struct unadapt<ISynchronizedInputProvider, X> : Windows::UI::Xaml::Automation::Provider::ISynchronizedInputProvider_unadaptor<X> {};
struct ISynchronizedInputProvider : ISynchronizedInputProvider_raw, generate<ISynchronizedInputProvider> {};

// ITableItemProvider
struct ITableItemProvider_raw : IInspectable {
	virtual STDMETHODIMP _GetColumnHeaderItems(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) = 0;
	virtual STDMETHODIMP _GetRowHeaderItems(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) = 0;
};
template<typename X> struct ITableItemProvider_adaptor : X {
	szarray<ptr<IRawElementProviderSimple>> GetColumnHeaderItems() { szarray<IRawElementProviderSimple*> returnValue; hrcheck(X::get()->_GetColumnHeaderItems(&returnValue.size, &returnValue.p)); return from_abi(returnValue); }
	szarray<ptr<IRawElementProviderSimple>> GetRowHeaderItems() { szarray<IRawElementProviderSimple*> returnValue; hrcheck(X::get()->_GetRowHeaderItems(&returnValue.size, &returnValue.p)); return from_abi(returnValue); }
};
template<typename X> struct adapt<ITableItemProvider, X> : Windows::UI::Xaml::Automation::Provider::ITableItemProvider_adaptor<X> { typedef adapt ITableItemProvider; };
template<typename X> struct ITableItemProvider_unadaptor : X {
	STDMETHODIMP _GetColumnHeaderItems(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetColumnHeaderItems().detach(returnValueSize)); }); }
	STDMETHODIMP _GetRowHeaderItems(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetRowHeaderItems().detach(returnValueSize)); }); }
};
template<typename X> struct unadapt<ITableItemProvider, X> : Windows::UI::Xaml::Automation::Provider::ITableItemProvider_unadaptor<X> {};
struct ITableItemProvider : ITableItemProvider_raw, generate<ITableItemProvider> {};

// ITableProvider
struct ITableProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_RowOrColumnMajor(Automation::RowOrColumnMajor *value) = 0;
	virtual STDMETHODIMP _GetColumnHeaders(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) = 0;
	virtual STDMETHODIMP _GetRowHeaders(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) = 0;
};
template<typename X> struct ITableProvider_adaptor : X {
	union {
		struct : property {
			Automation::RowOrColumnMajor get() { Automation::RowOrColumnMajor value; hrcheck(enc(&ITableProvider_adaptor::RowOrColumnMajor)->_get_RowOrColumnMajor(&value)); return value; }
			Automation::RowOrColumnMajor operator()() { return get(); }
			operator Automation::RowOrColumnMajor () { return get(); }
		} RowOrColumnMajor;
	};
	szarray<ptr<IRawElementProviderSimple>> GetColumnHeaders() { szarray<IRawElementProviderSimple*> returnValue; hrcheck(X::get()->_GetColumnHeaders(&returnValue.size, &returnValue.p)); return from_abi(returnValue); }
	szarray<ptr<IRawElementProviderSimple>> GetRowHeaders() { szarray<IRawElementProviderSimple*> returnValue; hrcheck(X::get()->_GetRowHeaders(&returnValue.size, &returnValue.p)); return from_abi(returnValue); }
	ITableProvider_adaptor() {}
};
template<typename X> struct adapt<ITableProvider, X> : Windows::UI::Xaml::Automation::Provider::ITableProvider_adaptor<X> { typedef adapt ITableProvider; };
template<typename X> struct ITableProvider_unadaptor : X {
	STDMETHODIMP _get_RowOrColumnMajor(Automation::RowOrColumnMajor *value) { return hrtry([&, this] { get_prop(value, RowOrColumnMajor); }); }
	STDMETHODIMP _GetColumnHeaders(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetColumnHeaders().detach(returnValueSize)); }); }
	STDMETHODIMP _GetRowHeaders(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetRowHeaders().detach(returnValueSize)); }); }
};
template<typename X> struct unadapt<ITableProvider, X> : Windows::UI::Xaml::Automation::Provider::ITableProvider_unadaptor<X> {};
struct ITableProvider : ITableProvider_raw, generate<ITableProvider> {};

// ITextChildProvider
struct ITextChildProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_TextContainer(IRawElementProviderSimple* *value) = 0;
	virtual STDMETHODIMP _get_TextRange(ITextRangeProvider* *value) = 0;
};
template<typename X> struct ITextChildProvider_adaptor : X {
	union {
		struct : property {
			ptr<IRawElementProviderSimple> get() { IRawElementProviderSimple* value; hrcheck(enc(&ITextChildProvider_adaptor::TextContainer)->_get_TextContainer(&value)); return from_abi(value); }
			ptr<IRawElementProviderSimple> operator()() { return get(); }
			operator ptr<IRawElementProviderSimple> () { return get(); }
			ptr<IRawElementProviderSimple> operator->() { return get(); }
		} TextContainer;
		struct : property {
			ptr<ITextRangeProvider> get() { ITextRangeProvider* value; hrcheck(enc(&ITextChildProvider_adaptor::TextRange)->_get_TextRange(&value)); return from_abi(value); }
			ptr<ITextRangeProvider> operator()() { return get(); }
			operator ptr<ITextRangeProvider> () { return get(); }
			ptr<ITextRangeProvider> operator->() { return get(); }
		} TextRange;
	};
	ITextChildProvider_adaptor() {}
};
template<typename X> struct adapt<ITextChildProvider, X> : Windows::UI::Xaml::Automation::Provider::ITextChildProvider_adaptor<X> { typedef adapt ITextChildProvider; };
template<typename X> struct ITextChildProvider_unadaptor : X {
	STDMETHODIMP _get_TextContainer(IRawElementProviderSimple* *value) { return hrtry([&, this] { get_prop(value, TextContainer); }); }
	STDMETHODIMP _get_TextRange(ITextRangeProvider* *value) { return hrtry([&, this] { get_prop(value, TextRange); }); }
};
template<typename X> struct unadapt<ITextChildProvider, X> : Windows::UI::Xaml::Automation::Provider::ITextChildProvider_unadaptor<X> {};
struct ITextChildProvider : ITextChildProvider_raw, generate<ITextChildProvider> {};

// ITextRangeProvider
struct ITextRangeProvider_raw : IInspectable {
	virtual STDMETHODIMP _Clone(ITextRangeProvider* *returnValue) = 0;
	virtual STDMETHODIMP _Compare(ITextRangeProvider* textRangeProvider, bool *returnValue) = 0;
	virtual STDMETHODIMP _CompareEndpoints(Text::TextPatternRangeEndpoint endpoint, ITextRangeProvider* textRangeProvider, Text::TextPatternRangeEndpoint targetEndpoint, int *returnValue) = 0;
	virtual STDMETHODIMP _ExpandToEnclosingUnit(Text::TextUnit unit) = 0;
	virtual STDMETHODIMP _FindAttribute(int attributeId, IInspectable* value, bool backward, ITextRangeProvider* *returnValue) = 0;
	virtual STDMETHODIMP _FindText(HSTRING text, bool backward, bool ignoreCase, ITextRangeProvider* *returnValue) = 0;
	virtual STDMETHODIMP _GetAttributeValue(int attributeId, IInspectable* *returnValue) = 0;
	virtual STDMETHODIMP _GetBoundingRectangles(unsigned *returnValueSize, double **returnValue) = 0;
	virtual STDMETHODIMP _GetEnclosingElement(IRawElementProviderSimple* *returnValue) = 0;
	virtual STDMETHODIMP _GetText(int maxLength, HSTRING *returnValue) = 0;
	virtual STDMETHODIMP _Move(Text::TextUnit unit, int count, int *returnValue) = 0;
	virtual STDMETHODIMP _MoveEndpointByUnit(Text::TextPatternRangeEndpoint endpoint, Text::TextUnit unit, int count, int *returnValue) = 0;
	virtual STDMETHODIMP _MoveEndpointByRange(Text::TextPatternRangeEndpoint endpoint, ITextRangeProvider* textRangeProvider, Text::TextPatternRangeEndpoint targetEndpoint) = 0;
	virtual STDMETHODIMP _Select() = 0;
	virtual STDMETHODIMP _AddToSelection() = 0;
	virtual STDMETHODIMP _RemoveFromSelection() = 0;
	virtual STDMETHODIMP _ScrollIntoView(bool alignToTop) = 0;
	virtual STDMETHODIMP _GetChildren(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) = 0;
};
template<typename X> struct ITextRangeProvider_adaptor : X {
	ptr<ITextRangeProvider> Clone() { ITextRangeProvider* returnValue; hrcheck(X::get()->_Clone(&returnValue)); return from_abi(returnValue); }
	bool Compare(pptr<ITextRangeProvider> textRangeProvider) { bool returnValue; hrcheck(X::get()->_Compare(textRangeProvider, &returnValue)); return returnValue; }
	int CompareEndpoints(Text::TextPatternRangeEndpoint endpoint, pptr<ITextRangeProvider> textRangeProvider, Text::TextPatternRangeEndpoint targetEndpoint) { int returnValue; hrcheck(X::get()->_CompareEndpoints(endpoint, textRangeProvider, targetEndpoint, &returnValue)); return returnValue; }
	void ExpandToEnclosingUnit(Text::TextUnit unit) { hrcheck(X::get()->_ExpandToEnclosingUnit(unit)); }
	ptr<ITextRangeProvider> FindAttribute(int attributeId, object_ref value, bool backward) { ITextRangeProvider* returnValue; hrcheck(X::get()->_FindAttribute(attributeId, value, backward, &returnValue)); return from_abi(returnValue); }
	ptr<ITextRangeProvider> FindText(hstring_ref text, bool backward, bool ignoreCase) { ITextRangeProvider* returnValue; hrcheck(X::get()->_FindText(text, backward, ignoreCase, &returnValue)); return from_abi(returnValue); }
	object GetAttributeValue(int attributeId) { IInspectable* returnValue; hrcheck(X::get()->_GetAttributeValue(attributeId, &returnValue)); return from_abi(returnValue); }
	szarray<double> GetBoundingRectangles() { szarray<double> returnValue; hrcheck(X::get()->_GetBoundingRectangles(&returnValue.size, &returnValue.p)); return returnValue; }
	ptr<IRawElementProviderSimple> GetEnclosingElement() { IRawElementProviderSimple* returnValue; hrcheck(X::get()->_GetEnclosingElement(&returnValue)); return from_abi(returnValue); }
	hstring GetText(int maxLength) { HSTRING returnValue; hrcheck(X::get()->_GetText(maxLength, &returnValue)); return from_abi(returnValue); }
	int Move(Text::TextUnit unit, int count) { int returnValue; hrcheck(X::get()->_Move(unit, count, &returnValue)); return returnValue; }
	int MoveEndpointByUnit(Text::TextPatternRangeEndpoint endpoint, Text::TextUnit unit, int count) { int returnValue; hrcheck(X::get()->_MoveEndpointByUnit(endpoint, unit, count, &returnValue)); return returnValue; }
	void MoveEndpointByRange(Text::TextPatternRangeEndpoint endpoint, pptr<ITextRangeProvider> textRangeProvider, Text::TextPatternRangeEndpoint targetEndpoint) { hrcheck(X::get()->_MoveEndpointByRange(endpoint, textRangeProvider, targetEndpoint)); }
	void Select() { hrcheck(X::get()->_Select()); }
	void AddToSelection() { hrcheck(X::get()->_AddToSelection()); }
	void RemoveFromSelection() { hrcheck(X::get()->_RemoveFromSelection()); }
	void ScrollIntoView(bool alignToTop) { hrcheck(X::get()->_ScrollIntoView(alignToTop)); }
	szarray<ptr<IRawElementProviderSimple>> GetChildren() { szarray<IRawElementProviderSimple*> returnValue; hrcheck(X::get()->_GetChildren(&returnValue.size, &returnValue.p)); return from_abi(returnValue); }
};
template<typename X> struct adapt<ITextRangeProvider, X> : Windows::UI::Xaml::Automation::Provider::ITextRangeProvider_adaptor<X> { typedef adapt ITextRangeProvider; };
template<typename X> struct ITextRangeProvider_unadaptor : X {
	STDMETHODIMP _Clone(ITextRangeProvider* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->Clone()); }); }
	STDMETHODIMP _Compare(ITextRangeProvider* textRangeProvider, bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->Compare(textRangeProvider); }); }
	STDMETHODIMP _CompareEndpoints(Text::TextPatternRangeEndpoint endpoint, ITextRangeProvider* textRangeProvider, Text::TextPatternRangeEndpoint targetEndpoint, int *returnValue) { return hrtry([&, this] { *returnValue = X::get()->CompareEndpoints(endpoint, textRangeProvider, targetEndpoint); }); }
	STDMETHODIMP _ExpandToEnclosingUnit(Text::TextUnit unit) { return hrtry([&, this] { X::get()->ExpandToEnclosingUnit(unit); }); }
	STDMETHODIMP _FindAttribute(int attributeId, IInspectable* value, bool backward, ITextRangeProvider* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->FindAttribute(attributeId, value, backward)); }); }
	STDMETHODIMP _FindText(HSTRING text, bool backward, bool ignoreCase, ITextRangeProvider* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->FindText(text, backward, ignoreCase)); }); }
	STDMETHODIMP _GetAttributeValue(int attributeId, IInspectable* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetAttributeValue(attributeId)); }); }
	STDMETHODIMP _GetBoundingRectangles(unsigned *returnValueSize, double **returnValue) { return hrtry([&, this] { *returnValue = X::get()->GetBoundingRectangles().detach(returnValueSize); }); }
	STDMETHODIMP _GetEnclosingElement(IRawElementProviderSimple* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetEnclosingElement()); }); }
	STDMETHODIMP _GetText(int maxLength, HSTRING *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetText(maxLength)); }); }
	STDMETHODIMP _Move(Text::TextUnit unit, int count, int *returnValue) { return hrtry([&, this] { *returnValue = X::get()->Move(unit, count); }); }
	STDMETHODIMP _MoveEndpointByUnit(Text::TextPatternRangeEndpoint endpoint, Text::TextUnit unit, int count, int *returnValue) { return hrtry([&, this] { *returnValue = X::get()->MoveEndpointByUnit(endpoint, unit, count); }); }
	STDMETHODIMP _MoveEndpointByRange(Text::TextPatternRangeEndpoint endpoint, ITextRangeProvider* textRangeProvider, Text::TextPatternRangeEndpoint targetEndpoint) { return hrtry([&, this] { X::get()->MoveEndpointByRange(endpoint, textRangeProvider, targetEndpoint); }); }
	STDMETHODIMP _Select() { return hrtry([&, this] { X::get()->Select(); }); }
	STDMETHODIMP _AddToSelection() { return hrtry([&, this] { X::get()->AddToSelection(); }); }
	STDMETHODIMP _RemoveFromSelection() { return hrtry([&, this] { X::get()->RemoveFromSelection(); }); }
	STDMETHODIMP _ScrollIntoView(bool alignToTop) { return hrtry([&, this] { X::get()->ScrollIntoView(alignToTop); }); }
	STDMETHODIMP _GetChildren(unsigned *returnValueSize, IRawElementProviderSimple* **returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetChildren().detach(returnValueSize)); }); }
};
template<typename X> struct unadapt<ITextRangeProvider, X> : Windows::UI::Xaml::Automation::Provider::ITextRangeProvider_unadaptor<X> {};
struct ITextRangeProvider : ITextRangeProvider_raw, generate<ITextRangeProvider> {};

// ITextProvider
struct ITextProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_DocumentRange(ITextRangeProvider* *value) = 0;
	virtual STDMETHODIMP _get_SupportedTextSelection(Automation::SupportedTextSelection *value) = 0;
	virtual STDMETHODIMP _GetSelection(unsigned *returnValueSize, ITextRangeProvider* **returnValue) = 0;
	virtual STDMETHODIMP _GetVisibleRanges(unsigned *returnValueSize, ITextRangeProvider* **returnValue) = 0;
	virtual STDMETHODIMP _RangeFromChild(IRawElementProviderSimple* childElement, ITextRangeProvider* *returnValue) = 0;
	virtual STDMETHODIMP _RangeFromPoint(Foundation::Point screenLocation, ITextRangeProvider* *returnValue) = 0;
};
template<typename X> struct ITextProvider_adaptor : X {
	union {
		struct : property {
			ptr<ITextRangeProvider> get() { ITextRangeProvider* value; hrcheck(enc(&ITextProvider_adaptor::DocumentRange)->_get_DocumentRange(&value)); return from_abi(value); }
			ptr<ITextRangeProvider> operator()() { return get(); }
			operator ptr<ITextRangeProvider> () { return get(); }
			ptr<ITextRangeProvider> operator->() { return get(); }
		} DocumentRange;
		struct : property {
			Automation::SupportedTextSelection get() { Automation::SupportedTextSelection value; hrcheck(enc(&ITextProvider_adaptor::SupportedTextSelection)->_get_SupportedTextSelection(&value)); return value; }
			Automation::SupportedTextSelection operator()() { return get(); }
			operator Automation::SupportedTextSelection () { return get(); }
		} SupportedTextSelection;
	};
	szarray<ptr<ITextRangeProvider>> GetSelection() { szarray<ITextRangeProvider*> returnValue; hrcheck(X::get()->_GetSelection(&returnValue.size, &returnValue.p)); return from_abi(returnValue); }
	szarray<ptr<ITextRangeProvider>> GetVisibleRanges() { szarray<ITextRangeProvider*> returnValue; hrcheck(X::get()->_GetVisibleRanges(&returnValue.size, &returnValue.p)); return from_abi(returnValue); }
	ptr<ITextRangeProvider> RangeFromChild(pptr<IRawElementProviderSimple> childElement) { ITextRangeProvider* returnValue; hrcheck(X::get()->_RangeFromChild(childElement, &returnValue)); return from_abi(returnValue); }
	ptr<ITextRangeProvider> RangeFromPoint(const Foundation::Point& screenLocation) { ITextRangeProvider* returnValue; hrcheck(X::get()->_RangeFromPoint(screenLocation, &returnValue)); return from_abi(returnValue); }
	ITextProvider_adaptor() {}
};
template<typename X> struct adapt<ITextProvider, X> : Windows::UI::Xaml::Automation::Provider::ITextProvider_adaptor<X> { typedef adapt ITextProvider; };
template<typename X> struct ITextProvider_unadaptor : X {
	STDMETHODIMP _get_DocumentRange(ITextRangeProvider* *value) { return hrtry([&, this] { get_prop(value, DocumentRange); }); }
	STDMETHODIMP _get_SupportedTextSelection(Automation::SupportedTextSelection *value) { return hrtry([&, this] { get_prop(value, SupportedTextSelection); }); }
	STDMETHODIMP _GetSelection(unsigned *returnValueSize, ITextRangeProvider* **returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetSelection().detach(returnValueSize)); }); }
	STDMETHODIMP _GetVisibleRanges(unsigned *returnValueSize, ITextRangeProvider* **returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetVisibleRanges().detach(returnValueSize)); }); }
	STDMETHODIMP _RangeFromChild(IRawElementProviderSimple* childElement, ITextRangeProvider* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->RangeFromChild(childElement)); }); }
	STDMETHODIMP _RangeFromPoint(Foundation::Point screenLocation, ITextRangeProvider* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->RangeFromPoint(screenLocation)); }); }
};
template<typename X> struct unadapt<ITextProvider, X> : Windows::UI::Xaml::Automation::Provider::ITextProvider_unadaptor<X> {};
struct ITextProvider : ITextProvider_raw, generate<ITextProvider> {};

// ITextProvider2
struct ITextProvider2_raw : IInspectable {
	virtual STDMETHODIMP _RangeFromAnnotation(IRawElementProviderSimple* annotationElement, ITextRangeProvider* *returnValue) = 0;
	virtual STDMETHODIMP _GetCaretRange(bool *isActive, ITextRangeProvider* *returnValue) = 0;
};
template<typename X> struct ITextProvider2_adaptor : X {
	ptr<ITextRangeProvider> RangeFromAnnotation(pptr<IRawElementProviderSimple> annotationElement) { ITextRangeProvider* returnValue; hrcheck(X::get()->_RangeFromAnnotation(annotationElement, &returnValue)); return from_abi(returnValue); }
	ptr<ITextRangeProvider> GetCaretRange(bool *isActive) { ITextRangeProvider* returnValue; hrcheck(X::get()->_GetCaretRange(isActive, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<ITextProvider2, X> : Windows::UI::Xaml::Automation::Provider::ITextProvider2_adaptor<X> { typedef adapt ITextProvider2; };
template<typename X> struct ITextProvider2_unadaptor : X {
	STDMETHODIMP _RangeFromAnnotation(IRawElementProviderSimple* annotationElement, ITextRangeProvider* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->RangeFromAnnotation(annotationElement)); }); }
	STDMETHODIMP _GetCaretRange(bool *isActive, ITextRangeProvider* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetCaretRange(isActive)); }); }
};
template<typename X> struct unadapt<ITextProvider2, X> : Windows::UI::Xaml::Automation::Provider::ITextProvider2_unadaptor<X> {};
struct ITextProvider2 : ITextProvider2_raw, generate<ITextProvider2> {};

// ITextRangeProvider2
struct ITextRangeProvider2_raw : IInspectable {
	virtual STDMETHODIMP _ShowContextMenu() = 0;
};
template<typename X> struct ITextRangeProvider2_adaptor : X {
	void ShowContextMenu() { hrcheck(X::get()->_ShowContextMenu()); }
};
template<typename X> struct adapt<ITextRangeProvider2, X> : Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2_adaptor<X> { typedef adapt ITextRangeProvider2; };
template<typename X> struct ITextRangeProvider2_unadaptor : X {
	STDMETHODIMP _ShowContextMenu() { return hrtry([&, this] { X::get()->ShowContextMenu(); }); }
};
template<typename X> struct unadapt<ITextRangeProvider2, X> : Windows::UI::Xaml::Automation::Provider::ITextRangeProvider2_unadaptor<X> {};
struct ITextRangeProvider2 : ITextRangeProvider2_raw, generate<ITextRangeProvider2> {};

// IToggleProvider
struct IToggleProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_ToggleState(Automation::ToggleState *value) = 0;
	virtual STDMETHODIMP _Toggle() = 0;
};
template<typename X> struct IToggleProvider_adaptor : X {
	union {
		struct : property {
			Automation::ToggleState get() { Automation::ToggleState value; hrcheck(enc(&IToggleProvider_adaptor::ToggleState)->_get_ToggleState(&value)); return value; }
			Automation::ToggleState operator()() { return get(); }
			operator Automation::ToggleState () { return get(); }
		} ToggleState;
	};
	void Toggle() { hrcheck(X::get()->_Toggle()); }
	IToggleProvider_adaptor() {}
};
template<typename X> struct adapt<IToggleProvider, X> : Windows::UI::Xaml::Automation::Provider::IToggleProvider_adaptor<X> { typedef adapt IToggleProvider; };
template<typename X> struct IToggleProvider_unadaptor : X {
	STDMETHODIMP _get_ToggleState(Automation::ToggleState *value) { return hrtry([&, this] { get_prop(value, ToggleState); }); }
	STDMETHODIMP _Toggle() { return hrtry([&, this] { X::get()->Toggle(); }); }
};
template<typename X> struct unadapt<IToggleProvider, X> : Windows::UI::Xaml::Automation::Provider::IToggleProvider_unadaptor<X> {};
struct IToggleProvider : IToggleProvider_raw, generate<IToggleProvider> {};

// ITransformProvider
struct ITransformProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_CanMove(bool *value) = 0;
	virtual STDMETHODIMP _get_CanResize(bool *value) = 0;
	virtual STDMETHODIMP _get_CanRotate(bool *value) = 0;
	virtual STDMETHODIMP _Move(double x, double y) = 0;
	virtual STDMETHODIMP _Resize(double width, double height) = 0;
	virtual STDMETHODIMP _Rotate(double degrees) = 0;
};
template<typename X> struct ITransformProvider_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITransformProvider_adaptor::CanMove)->_get_CanMove(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanMove;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITransformProvider_adaptor::CanResize)->_get_CanResize(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanResize;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITransformProvider_adaptor::CanRotate)->_get_CanRotate(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanRotate;
	};
	void Move(double x, double y) { hrcheck(X::get()->_Move(x, y)); }
	void Resize(double width, double height) { hrcheck(X::get()->_Resize(width, height)); }
	void Rotate(double degrees) { hrcheck(X::get()->_Rotate(degrees)); }
	ITransformProvider_adaptor() {}
};
template<typename X> struct adapt<ITransformProvider, X> : Windows::UI::Xaml::Automation::Provider::ITransformProvider_adaptor<X> { typedef adapt ITransformProvider; };
template<typename X> struct ITransformProvider_unadaptor : X {
	STDMETHODIMP _get_CanMove(bool *value) { return hrtry([&, this] { get_prop(value, CanMove); }); }
	STDMETHODIMP _get_CanResize(bool *value) { return hrtry([&, this] { get_prop(value, CanResize); }); }
	STDMETHODIMP _get_CanRotate(bool *value) { return hrtry([&, this] { get_prop(value, CanRotate); }); }
	STDMETHODIMP _Move(double x, double y) { return hrtry([&, this] { X::get()->Move(x, y); }); }
	STDMETHODIMP _Resize(double width, double height) { return hrtry([&, this] { X::get()->Resize(width, height); }); }
	STDMETHODIMP _Rotate(double degrees) { return hrtry([&, this] { X::get()->Rotate(degrees); }); }
};
template<typename X> struct unadapt<ITransformProvider, X> : Windows::UI::Xaml::Automation::Provider::ITransformProvider_unadaptor<X> {};
struct ITransformProvider : ITransformProvider_raw, generate<ITransformProvider> {};

// ITransformProvider2
struct ITransformProvider2_raw : IInspectable {
	virtual STDMETHODIMP _get_CanZoom(bool *value) = 0;
	virtual STDMETHODIMP _get_ZoomLevel(double *value) = 0;
	virtual STDMETHODIMP _get_MaxZoom(double *value) = 0;
	virtual STDMETHODIMP _get_MinZoom(double *value) = 0;
	virtual STDMETHODIMP _Zoom(double zoom) = 0;
	virtual STDMETHODIMP _ZoomByUnit(ZoomUnit zoomUnit) = 0;
};
template<typename X> struct ITransformProvider2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ITransformProvider2_adaptor::CanZoom)->_get_CanZoom(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanZoom;
		struct : property {
			double get() { double value; hrcheck(enc(&ITransformProvider2_adaptor::MaxZoom)->_get_MaxZoom(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} MaxZoom;
		struct : property {
			double get() { double value; hrcheck(enc(&ITransformProvider2_adaptor::MinZoom)->_get_MinZoom(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} MinZoom;
		struct : property {
			double get() { double value; hrcheck(enc(&ITransformProvider2_adaptor::ZoomLevel)->_get_ZoomLevel(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} ZoomLevel;
	};
	void Zoom(double zoom) { hrcheck(X::get()->_Zoom(zoom)); }
	void ZoomByUnit(ZoomUnit zoomUnit) { hrcheck(X::get()->_ZoomByUnit(zoomUnit)); }
	ITransformProvider2_adaptor() {}
};
template<typename X> struct adapt<ITransformProvider2, X> : Windows::UI::Xaml::Automation::Provider::ITransformProvider2_adaptor<X> { typedef adapt ITransformProvider2; };
template<typename X> struct ITransformProvider2_unadaptor : X {
	STDMETHODIMP _get_CanZoom(bool *value) { return hrtry([&, this] { get_prop(value, CanZoom); }); }
	STDMETHODIMP _get_ZoomLevel(double *value) { return hrtry([&, this] { get_prop(value, ZoomLevel); }); }
	STDMETHODIMP _get_MaxZoom(double *value) { return hrtry([&, this] { get_prop(value, MaxZoom); }); }
	STDMETHODIMP _get_MinZoom(double *value) { return hrtry([&, this] { get_prop(value, MinZoom); }); }
	STDMETHODIMP _Zoom(double zoom) { return hrtry([&, this] { X::get()->Zoom(zoom); }); }
	STDMETHODIMP _ZoomByUnit(ZoomUnit zoomUnit) { return hrtry([&, this] { X::get()->ZoomByUnit(zoomUnit); }); }
};
template<typename X> struct unadapt<ITransformProvider2, X> : Windows::UI::Xaml::Automation::Provider::ITransformProvider2_unadaptor<X> {};
struct ITransformProvider2 : ITransformProvider2_raw, generate<ITransformProvider2> {};

// IValueProvider
struct IValueProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_IsReadOnly(bool *value) = 0;
	virtual STDMETHODIMP _get_Value(HSTRING *value) = 0;
	virtual STDMETHODIMP _SetValue(HSTRING value) = 0;
};
template<typename X> struct IValueProvider_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IValueProvider_adaptor::IsReadOnly)->_get_IsReadOnly(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsReadOnly;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IValueProvider_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Value;
	};
	void SetValue(hstring_ref value) { hrcheck(X::get()->_SetValue(value)); }
	IValueProvider_adaptor() {}
};
template<typename X> struct adapt<IValueProvider, X> : Windows::UI::Xaml::Automation::Provider::IValueProvider_adaptor<X> { typedef adapt IValueProvider; };
template<typename X> struct IValueProvider_unadaptor : X {
	STDMETHODIMP _get_IsReadOnly(bool *value) { return hrtry([&, this] { get_prop(value, IsReadOnly); }); }
	STDMETHODIMP _get_Value(HSTRING *value) { return hrtry([&, this] { get_prop(value, Value); }); }
	STDMETHODIMP _SetValue(HSTRING value) { return hrtry([&, this] { X::get()->SetValue(value); }); }
};
template<typename X> struct unadapt<IValueProvider, X> : Windows::UI::Xaml::Automation::Provider::IValueProvider_unadaptor<X> {};
struct IValueProvider : IValueProvider_raw, generate<IValueProvider> {};

// IVirtualizedItemProvider
struct IVirtualizedItemProvider_raw : IInspectable {
	virtual STDMETHODIMP _Realize() = 0;
};
template<typename X> struct IVirtualizedItemProvider_adaptor : X {
	void Realize() { hrcheck(X::get()->_Realize()); }
};
template<typename X> struct adapt<IVirtualizedItemProvider, X> : Windows::UI::Xaml::Automation::Provider::IVirtualizedItemProvider_adaptor<X> { typedef adapt IVirtualizedItemProvider; };
template<typename X> struct IVirtualizedItemProvider_unadaptor : X {
	STDMETHODIMP _Realize() { return hrtry([&, this] { X::get()->Realize(); }); }
};
template<typename X> struct unadapt<IVirtualizedItemProvider, X> : Windows::UI::Xaml::Automation::Provider::IVirtualizedItemProvider_unadaptor<X> {};
struct IVirtualizedItemProvider : IVirtualizedItemProvider_raw, generate<IVirtualizedItemProvider> {};

// IWindowProvider
struct IWindowProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_IsModal(bool *value) = 0;
	virtual STDMETHODIMP _get_IsTopmost(bool *value) = 0;
	virtual STDMETHODIMP _get_Maximizable(bool *value) = 0;
	virtual STDMETHODIMP _get_Minimizable(bool *value) = 0;
	virtual STDMETHODIMP _get_InteractionState(WindowInteractionState *value) = 0;
	virtual STDMETHODIMP _get_VisualState(WindowVisualState *value) = 0;
	virtual STDMETHODIMP _Close() = 0;
	virtual STDMETHODIMP _SetVisualState(WindowVisualState state) = 0;
	virtual STDMETHODIMP _WaitForInputIdle(int milliseconds, bool *returnValue) = 0;
};
template<typename X> struct IWindowProvider_adaptor : X {
	union {
		struct : property {
			WindowInteractionState get() { WindowInteractionState value; hrcheck(enc(&IWindowProvider_adaptor::InteractionState)->_get_InteractionState(&value)); return value; }
			WindowInteractionState operator()() { return get(); }
			operator WindowInteractionState () { return get(); }
		} InteractionState;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IWindowProvider_adaptor::IsModal)->_get_IsModal(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsModal;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IWindowProvider_adaptor::IsTopmost)->_get_IsTopmost(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsTopmost;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IWindowProvider_adaptor::Maximizable)->_get_Maximizable(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Maximizable;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IWindowProvider_adaptor::Minimizable)->_get_Minimizable(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Minimizable;
		struct : property {
			WindowVisualState get() { WindowVisualState value; hrcheck(enc(&IWindowProvider_adaptor::VisualState)->_get_VisualState(&value)); return value; }
			WindowVisualState operator()() { return get(); }
			operator WindowVisualState () { return get(); }
		} VisualState;
	};
	void Close() { hrcheck(X::get()->_Close()); }
	void SetVisualState(WindowVisualState state) { hrcheck(X::get()->_SetVisualState(state)); }
	bool WaitForInputIdle(int milliseconds) { bool returnValue; hrcheck(X::get()->_WaitForInputIdle(milliseconds, &returnValue)); return returnValue; }
	IWindowProvider_adaptor() {}
};
template<typename X> struct adapt<IWindowProvider, X> : Windows::UI::Xaml::Automation::Provider::IWindowProvider_adaptor<X> { typedef adapt IWindowProvider; };
template<typename X> struct IWindowProvider_unadaptor : X {
	STDMETHODIMP _get_IsModal(bool *value) { return hrtry([&, this] { get_prop(value, IsModal); }); }
	STDMETHODIMP _get_IsTopmost(bool *value) { return hrtry([&, this] { get_prop(value, IsTopmost); }); }
	STDMETHODIMP _get_Maximizable(bool *value) { return hrtry([&, this] { get_prop(value, Maximizable); }); }
	STDMETHODIMP _get_Minimizable(bool *value) { return hrtry([&, this] { get_prop(value, Minimizable); }); }
	STDMETHODIMP _get_InteractionState(WindowInteractionState *value) { return hrtry([&, this] { get_prop(value, InteractionState); }); }
	STDMETHODIMP _get_VisualState(WindowVisualState *value) { return hrtry([&, this] { get_prop(value, VisualState); }); }
	STDMETHODIMP _Close() { return hrtry([&, this] { X::get()->Close(); }); }
	STDMETHODIMP _SetVisualState(WindowVisualState state) { return hrtry([&, this] { X::get()->SetVisualState(state); }); }
	STDMETHODIMP _WaitForInputIdle(int milliseconds, bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->WaitForInputIdle(milliseconds); }); }
};
template<typename X> struct unadapt<IWindowProvider, X> : Windows::UI::Xaml::Automation::Provider::IWindowProvider_unadaptor<X> {};
struct IWindowProvider : IWindowProvider_raw, generate<IWindowProvider> {};

// IIRawElementProviderSimple
struct IIRawElementProviderSimple : IInspectable, generate<IIRawElementProviderSimple> {};

// IRawElementProviderSimple
template<typename X> struct statics<IRawElementProviderSimple, X> : X {
	typedef typename X::root_type IRawElementProviderSimple;
};
struct IRawElementProviderSimple : generate<IRawElementProviderSimple> {};

// ICustomNavigationProvider
struct ICustomNavigationProvider_raw : IInspectable {
	virtual STDMETHODIMP _NavigateCustom(Peers::AutomationNavigationDirection direction, IInspectable* *returnValue) = 0;
};
template<typename X> struct ICustomNavigationProvider_adaptor : X {
	object NavigateCustom(Peers::AutomationNavigationDirection direction) { IInspectable* returnValue; hrcheck(X::get()->_NavigateCustom(direction, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<ICustomNavigationProvider, X> : Windows::UI::Xaml::Automation::Provider::ICustomNavigationProvider_adaptor<X> { typedef adapt ICustomNavigationProvider; };
template<typename X> struct ICustomNavigationProvider_unadaptor : X {
	STDMETHODIMP _NavigateCustom(Peers::AutomationNavigationDirection direction, IInspectable* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->NavigateCustom(direction)); }); }
};
template<typename X> struct unadapt<ICustomNavigationProvider, X> : Windows::UI::Xaml::Automation::Provider::ICustomNavigationProvider_unadaptor<X> {};
struct ICustomNavigationProvider : ICustomNavigationProvider_raw, generate<ICustomNavigationProvider> {};

// ITextEditProvider
struct ITextEditProvider_raw : IInspectable {
	virtual STDMETHODIMP _GetActiveComposition(ITextRangeProvider* *returnValue) = 0;
	virtual STDMETHODIMP _GetConversionTarget(ITextRangeProvider* *returnValue) = 0;
};
template<typename X> struct ITextEditProvider_adaptor : X {
	ptr<ITextRangeProvider> GetActiveComposition() { ITextRangeProvider* returnValue; hrcheck(X::get()->_GetActiveComposition(&returnValue)); return from_abi(returnValue); }
	ptr<ITextRangeProvider> GetConversionTarget() { ITextRangeProvider* returnValue; hrcheck(X::get()->_GetConversionTarget(&returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<ITextEditProvider, X> : Windows::UI::Xaml::Automation::Provider::ITextEditProvider_adaptor<X> { typedef adapt ITextEditProvider; };
template<typename X> struct ITextEditProvider_unadaptor : X {
	STDMETHODIMP _GetActiveComposition(ITextRangeProvider* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetActiveComposition()); }); }
	STDMETHODIMP _GetConversionTarget(ITextRangeProvider* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetConversionTarget()); }); }
};
template<typename X> struct unadapt<ITextEditProvider, X> : Windows::UI::Xaml::Automation::Provider::ITextEditProvider_unadaptor<X> {};
struct ITextEditProvider : ITextEditProvider_raw, generate<ITextEditProvider> {};
}}}}}
} // namespace iso_winrt
