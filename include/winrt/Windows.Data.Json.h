#pragma once
// generated by isopod tools
// namespaces:
// Windows.Data.Json

#include "Windows.Data.Json.0.h"
#include "Windows.Foundation.Collections.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types


// defs

template<> struct def<Windows::Data::Json::JsonValueType> : enum_type<int> {};
template<> struct def<Windows::Data::Json::JsonErrorStatus> : enum_type<int> {};
template<> struct def<Windows::Data::Json::IJsonValue> : overridable_type<> {};
template<> struct def<Windows::Data::Json::IJsonArrayStatics> : interface_type<> {};
template<> struct def<Windows::Data::Json::IJsonArray> : interface_type<Windows::Data::Json::IJsonValue> {};
template<> struct def<Windows::Data::Json::JsonArray> : class_type<Platform::Object, Windows::Data::Json::IJsonArray, Windows::Foundation::IStringable, Windows::Foundation::Collections::IVector<ptr<Windows::Data::Json::IJsonValue>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Data::Json::IJsonValue>>> {};
template<> struct def<Windows::Data::Json::IJsonObjectStatics> : interface_type<> {};
template<> struct def<Windows::Data::Json::IJsonObject> : interface_type<Windows::Data::Json::IJsonValue> {};
template<> struct def<Windows::Data::Json::IJsonObjectWithDefaultValues> : interface_type<Windows::Data::Json::IJsonObject> {};
template<> struct def<Windows::Data::Json::JsonObject> : class_type<Platform::Object, Windows::Data::Json::IJsonObject, Windows::Foundation::IStringable, Windows::Foundation::Collections::IMap<HSTRING, ptr<Windows::Data::Json::IJsonValue>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, ptr<Windows::Data::Json::IJsonValue>>>>, Windows::Data::Json::IJsonObjectWithDefaultValues> {};
template<> struct def<Windows::Data::Json::IJsonValueStatics> : interface_type<> {};
template<> struct def<Windows::Data::Json::IJsonValueStatics2> : interface_type<> {};
template<> struct def<Windows::Data::Json::JsonValue> : class_type<Platform::Object, Windows::Data::Json::IJsonValue, Windows::Foundation::IStringable> {};
template<> struct def<Windows::Data::Json::IJsonErrorStatics2> : interface_type<> {};
template<> struct def<Windows::Data::Json::JsonError> : class_type<Platform::Object, Platform::Object> {};

// uuids

template<> struct uuid<Windows::Data::Json::IJsonValue> { define_guid(0xA3219ECB, 0xF0B3, 0x4DCD, 0xBE, 0xEE, 0x19, 0xD4, 0x8C, 0xD3, 0xED, 0x1E);};
template<> struct uuid<Windows::Data::Json::IJsonArrayStatics> { define_guid(0xDB1434A9, 0xE164, 0x499F, 0x93, 0xE2, 0x8A, 0x8F, 0x49, 0xBB, 0x90, 0xBA);};
template<> struct uuid<Windows::Data::Json::IJsonArray> { define_guid(0x8C1DDB6, 0xCBD, 0x4A9A, 0xB5, 0xD3, 0x2F, 0x85, 0x2D, 0xC3, 0x7E, 0x81);};
template<> struct uuid<Windows::Data::Json::IJsonObjectStatics> { define_guid(0x2289F159, 0x54DE, 0x45D8, 0xAB, 0xCC, 0x22, 0x60, 0x3F, 0xA0, 0x66, 0xA0);};
template<> struct uuid<Windows::Data::Json::IJsonObject> { define_guid(0x64E24DD, 0x29C2, 0x4F83, 0x9A, 0xC1, 0x9E, 0xE1, 0x15, 0x78, 0xBE, 0xB3);};
template<> struct uuid<Windows::Data::Json::IJsonObjectWithDefaultValues> { define_guid(0xD960D2A2, 0xB7F0, 0x4F00, 0x8E, 0x44, 0xD8, 0x2C, 0xF4, 0x15, 0xEA, 0x13);};
template<> struct uuid<Windows::Data::Json::IJsonValueStatics> { define_guid(0x5F6B544A, 0x2F53, 0x48E1, 0x91, 0xA3, 0xF7, 0x8B, 0x50, 0xA6, 0x34, 0x5C);};
template<> struct uuid<Windows::Data::Json::IJsonValueStatics2> { define_guid(0x1D9ECBE4, 0x3FE8, 0x4335, 0x83, 0x92, 0x93, 0xD8, 0xE3, 0x68, 0x65, 0xF0);};
template<> struct uuid<Windows::Data::Json::IJsonErrorStatics2> { define_guid(0x404030DA, 0x87D0, 0x436C, 0x83, 0xAB, 0xFC, 0x7B, 0x12, 0xC0, 0xCC, 0x26);};

// types

namespace Windows { namespace Data { namespace Json {

// IJsonValue
struct IJsonValue_raw : IInspectable {
	virtual STDMETHODIMP _get_ValueType(JsonValueType *value) = 0;
	virtual STDMETHODIMP _Stringify(HSTRING *returnValue) = 0;
	virtual STDMETHODIMP _GetString(HSTRING *returnValue) = 0;
	virtual STDMETHODIMP _GetNumber(double *returnValue) = 0;
	virtual STDMETHODIMP _GetBoolean(bool *returnValue) = 0;
	virtual STDMETHODIMP _GetArray(JsonArray* *returnValue) = 0;
	virtual STDMETHODIMP _GetObject(JsonObject* *returnValue) = 0;
};
template<typename X> struct IJsonValue_adaptor : X {
	union {
		struct : property {
			JsonValueType get() { JsonValueType value; hrcheck(enc(&IJsonValue_adaptor::ValueType)->_get_ValueType(&value)); return value; }
			JsonValueType operator()() { return get(); }
			operator JsonValueType () { return get(); }
		} ValueType;
	};
	hstring Stringify() { HSTRING returnValue; hrcheck(X::get()->_Stringify(&returnValue)); return from_abi(returnValue); }
	hstring GetString() { HSTRING returnValue; hrcheck(X::get()->_GetString(&returnValue)); return from_abi(returnValue); }
	double GetNumber() { double returnValue; hrcheck(X::get()->_GetNumber(&returnValue)); return returnValue; }
	bool GetBoolean() { bool returnValue; hrcheck(X::get()->_GetBoolean(&returnValue)); return returnValue; }
	ptr<JsonArray> GetArray() { JsonArray* returnValue; hrcheck(X::get()->_GetArray(&returnValue)); return from_abi(returnValue); }
	ptr<JsonObject> GetObject() { JsonObject* returnValue; hrcheck(X::get()->_GetObject(&returnValue)); return from_abi(returnValue); }
	IJsonValue_adaptor() {}
};
template<typename X> struct adapt<IJsonValue, X> : Windows::Data::Json::IJsonValue_adaptor<X> { typedef adapt IJsonValue; };
template<typename X> struct IJsonValue_unadaptor : X {
	STDMETHODIMP _get_ValueType(JsonValueType *value) { return hrtry([&, this] { get_prop(value, ValueType); }); }
	STDMETHODIMP _Stringify(HSTRING *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->Stringify()); }); }
	STDMETHODIMP _GetString(HSTRING *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetString()); }); }
	STDMETHODIMP _GetNumber(double *returnValue) { return hrtry([&, this] { *returnValue = X::get()->GetNumber(); }); }
	STDMETHODIMP _GetBoolean(bool *returnValue) { return hrtry([&, this] { *returnValue = X::get()->GetBoolean(); }); }
	STDMETHODIMP _GetArray(JsonArray* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetArray()); }); }
	STDMETHODIMP _GetObject(JsonObject* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetObject()); }); }
};
template<typename X> struct unadapt<IJsonValue, X> : Windows::Data::Json::IJsonValue_unadaptor<X> {};
struct IJsonValue : IJsonValue_raw, generate<IJsonValue> {};

// IJsonArrayStatics
struct IJsonArrayStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, JsonArray* *jsonArray);
	virtual STDMETHODIMP _TryParse(HSTRING input, JsonArray* *result, bool *succeeded);
};

// IJsonArray
struct IJsonArray_raw : IInspectable {
	virtual STDMETHODIMP _GetObjectAt(unsigned index, JsonObject* *returnValue);
	virtual STDMETHODIMP _GetArrayAt(unsigned index, JsonArray* *returnValue);
	virtual STDMETHODIMP _GetStringAt(unsigned index, HSTRING *returnValue);
	virtual STDMETHODIMP _GetNumberAt(unsigned index, double *returnValue);
	virtual STDMETHODIMP _GetBooleanAt(unsigned index, bool *returnValue);
};
template<typename X> struct IJsonArray_adaptor : X {
	ptr<JsonObject> GetObjectAt(unsigned index) { JsonObject* returnValue; hrcheck(X::get()->_GetObjectAt(index, &returnValue)); return from_abi(returnValue); }
	ptr<JsonArray> GetArrayAt(unsigned index) { JsonArray* returnValue; hrcheck(X::get()->_GetArrayAt(index, &returnValue)); return from_abi(returnValue); }
	hstring GetStringAt(unsigned index) { HSTRING returnValue; hrcheck(X::get()->_GetStringAt(index, &returnValue)); return from_abi(returnValue); }
	double GetNumberAt(unsigned index) { double returnValue; hrcheck(X::get()->_GetNumberAt(index, &returnValue)); return returnValue; }
	bool GetBooleanAt(unsigned index) { bool returnValue; hrcheck(X::get()->_GetBooleanAt(index, &returnValue)); return returnValue; }
};
template<typename X> struct adapt<IJsonArray, X> : Windows::Data::Json::IJsonArray_adaptor<X> { typedef adapt IJsonArray; };
struct IJsonArray : IJsonArray_raw, generate<IJsonArray> {};

// JsonArray
template<typename> struct JsonArray_statics {
	static ptr<JsonArray> Parse(hstring_ref input) { JsonArray* jsonArray; hrcheck(get_activation_factory<JsonArray, IJsonArrayStatics>()->_Parse(input, &jsonArray)); return from_abi(jsonArray); }
	static bool TryParse(hstring_ref input, pptr<JsonArray> *result) { bool succeeded; hrcheck(get_activation_factory<JsonArray, IJsonArrayStatics>()->_TryParse(input, result, &succeeded)); return succeeded; }
};

template<typename X> struct statics<JsonArray, X> : X, Windows::Data::Json::JsonArray_statics<void> {
	typedef typename X::root_type JsonArray;
};
struct JsonArray : generate<JsonArray> {};

// IJsonObjectStatics
struct IJsonObjectStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, JsonObject* *jsonObject);
	virtual STDMETHODIMP _TryParse(HSTRING input, JsonObject* *result, bool *succeeded);
};

// IJsonObject
struct IJsonObject_raw : IInspectable {
	virtual STDMETHODIMP _GetNamedValue(HSTRING name, JsonValue* *returnValue);
	virtual STDMETHODIMP _SetNamedValue(HSTRING name, IJsonValue* value);
	virtual STDMETHODIMP _GetNamedObject(HSTRING name, JsonObject* *returnValue);
	virtual STDMETHODIMP _GetNamedArray(HSTRING name, JsonArray* *returnValue);
	virtual STDMETHODIMP _GetNamedString(HSTRING name, HSTRING *returnValue);
	virtual STDMETHODIMP _GetNamedNumber(HSTRING name, double *returnValue);
	virtual STDMETHODIMP _GetNamedBoolean(HSTRING name, bool *returnValue);
};
template<typename X> struct IJsonObject_adaptor : X {
	ptr<JsonValue> GetNamedValue(hstring_ref name) { JsonValue* returnValue; hrcheck(X::get()->_GetNamedValue(name, &returnValue)); return from_abi(returnValue); }
	void SetNamedValue(hstring_ref name, pptr<IJsonValue> value) { hrcheck(X::get()->_SetNamedValue(name, value)); }
	ptr<JsonObject> GetNamedObject(hstring_ref name) { JsonObject* returnValue; hrcheck(X::get()->_GetNamedObject(name, &returnValue)); return from_abi(returnValue); }
	ptr<JsonArray> GetNamedArray(hstring_ref name) { JsonArray* returnValue; hrcheck(X::get()->_GetNamedArray(name, &returnValue)); return from_abi(returnValue); }
	hstring GetNamedString(hstring_ref name) { HSTRING returnValue; hrcheck(X::get()->_GetNamedString(name, &returnValue)); return from_abi(returnValue); }
	double GetNamedNumber(hstring_ref name) { double returnValue; hrcheck(X::get()->_GetNamedNumber(name, &returnValue)); return returnValue; }
	bool GetNamedBoolean(hstring_ref name) { bool returnValue; hrcheck(X::get()->_GetNamedBoolean(name, &returnValue)); return returnValue; }
};
template<typename X> struct adapt<IJsonObject, X> : Windows::Data::Json::IJsonObject_adaptor<X> { typedef adapt IJsonObject; };
struct IJsonObject : IJsonObject_raw, generate<IJsonObject> {};

// IJsonObjectWithDefaultValues
struct IJsonObjectWithDefaultValues_raw : IInspectable {
	virtual STDMETHODIMP _GetNamedValueOrDefault(HSTRING name, JsonValue* defaultValue, JsonValue* *returnValue);
	virtual STDMETHODIMP _GetNamedObjectOrDefault(HSTRING name, JsonObject* defaultValue, JsonObject* *returnValue);
	virtual STDMETHODIMP _GetNamedStringOrDefault(HSTRING name, HSTRING defaultValue, HSTRING *returnValue);
	virtual STDMETHODIMP _GetNamedArrayOrDefault(HSTRING name, JsonArray* defaultValue, JsonArray* *returnValue);
	virtual STDMETHODIMP _GetNamedNumberOrDefault(HSTRING name, double defaultValue, double *returnValue);
	virtual STDMETHODIMP _GetNamedBooleanOrDefault(HSTRING name, bool defaultValue, bool *returnValue);
};
template<typename X> struct IJsonObjectWithDefaultValues_adaptor : X {
	ptr<JsonValue> GetNamedValue(hstring_ref name, pptr<JsonValue> defaultValue) { JsonValue* returnValue; hrcheck(X::get()->_GetNamedValueOrDefault(name, defaultValue, &returnValue)); return from_abi(returnValue); }
	ptr<JsonObject> GetNamedObject(hstring_ref name, pptr<JsonObject> defaultValue) { JsonObject* returnValue; hrcheck(X::get()->_GetNamedObjectOrDefault(name, defaultValue, &returnValue)); return from_abi(returnValue); }
	hstring GetNamedString(hstring_ref name, hstring_ref defaultValue) { HSTRING returnValue; hrcheck(X::get()->_GetNamedStringOrDefault(name, defaultValue, &returnValue)); return from_abi(returnValue); }
	ptr<JsonArray> GetNamedArray(hstring_ref name, pptr<JsonArray> defaultValue) { JsonArray* returnValue; hrcheck(X::get()->_GetNamedArrayOrDefault(name, defaultValue, &returnValue)); return from_abi(returnValue); }
	double GetNamedNumber(hstring_ref name, double defaultValue) { double returnValue; hrcheck(X::get()->_GetNamedNumberOrDefault(name, defaultValue, &returnValue)); return returnValue; }
	bool GetNamedBoolean(hstring_ref name, bool defaultValue) { bool returnValue; hrcheck(X::get()->_GetNamedBooleanOrDefault(name, defaultValue, &returnValue)); return returnValue; }
};
template<typename X> struct adapt<IJsonObjectWithDefaultValues, X> : Windows::Data::Json::IJsonObjectWithDefaultValues_adaptor<X> { typedef adapt IJsonObjectWithDefaultValues; };
struct IJsonObjectWithDefaultValues : IJsonObjectWithDefaultValues_raw, generate<IJsonObjectWithDefaultValues> {};

// JsonObject
template<typename> struct JsonObject_statics {
	static ptr<JsonObject> Parse(hstring_ref input) { JsonObject* jsonObject; hrcheck(get_activation_factory<JsonObject, IJsonObjectStatics>()->_Parse(input, &jsonObject)); return from_abi(jsonObject); }
	static bool TryParse(hstring_ref input, pptr<JsonObject> *result) { bool succeeded; hrcheck(get_activation_factory<JsonObject, IJsonObjectStatics>()->_TryParse(input, result, &succeeded)); return succeeded; }
};

template<typename X> struct statics<JsonObject, X> : X, Windows::Data::Json::JsonObject_statics<void> {
	typedef typename X::root_type JsonObject;
};
struct JsonObject : generate<JsonObject> {
	using IJsonObject::GetNamedObject;
	using IJsonObjectWithDefaultValues::GetNamedObject;
	using IJsonObject::GetNamedValue;
	using IJsonObjectWithDefaultValues::GetNamedValue;
	using IJsonObject::GetNamedArray;
	using IJsonObjectWithDefaultValues::GetNamedArray;
	using IJsonObject::GetNamedNumber;
	using IJsonObjectWithDefaultValues::GetNamedNumber;
	using IJsonObject::GetNamedString;
	using IJsonObjectWithDefaultValues::GetNamedString;
	using IJsonObject::GetNamedBoolean;
	using IJsonObjectWithDefaultValues::GetNamedBoolean;
};

// IJsonValueStatics
struct IJsonValueStatics : IInspectable {
	virtual STDMETHODIMP _Parse(HSTRING input, JsonValue* *jsonValue);
	virtual STDMETHODIMP _TryParse(HSTRING input, JsonValue* *result, bool *succeeded);
	virtual STDMETHODIMP _CreateBooleanValue(bool input, JsonValue* *jsonValue);
	virtual STDMETHODIMP _CreateNumberValue(double input, JsonValue* *jsonValue);
	virtual STDMETHODIMP _CreateStringValue(HSTRING input, JsonValue* *jsonValue);
};

// IJsonValueStatics2
struct IJsonValueStatics2 : IInspectable {
	virtual STDMETHODIMP _CreateNullValue(JsonValue* *jsonValue);
};

// JsonValue
template<typename> struct JsonValue_statics {
	static ptr<JsonValue> CreateNullValue() { JsonValue* jsonValue; hrcheck(get_activation_factory<JsonValue, IJsonValueStatics2>()->_CreateNullValue(&jsonValue)); return from_abi(jsonValue); }
	static ptr<JsonValue> Parse(hstring_ref input) { JsonValue* jsonValue; hrcheck(get_activation_factory<JsonValue, IJsonValueStatics>()->_Parse(input, &jsonValue)); return from_abi(jsonValue); }
	static bool TryParse(hstring_ref input, pptr<JsonValue> *result) { bool succeeded; hrcheck(get_activation_factory<JsonValue, IJsonValueStatics>()->_TryParse(input, result, &succeeded)); return succeeded; }
	static ptr<JsonValue> CreateBooleanValue(bool input) { JsonValue* jsonValue; hrcheck(get_activation_factory<JsonValue, IJsonValueStatics>()->_CreateBooleanValue(input, &jsonValue)); return from_abi(jsonValue); }
	static ptr<JsonValue> CreateNumberValue(double input) { JsonValue* jsonValue; hrcheck(get_activation_factory<JsonValue, IJsonValueStatics>()->_CreateNumberValue(input, &jsonValue)); return from_abi(jsonValue); }
	static ptr<JsonValue> CreateStringValue(hstring_ref input) { JsonValue* jsonValue; hrcheck(get_activation_factory<JsonValue, IJsonValueStatics>()->_CreateStringValue(input, &jsonValue)); return from_abi(jsonValue); }
};

template<typename X> struct statics<JsonValue, X> : X, Windows::Data::Json::JsonValue_statics<void> {
	typedef typename X::root_type JsonValue;
};
struct JsonValue : generate<JsonValue> {};

// IJsonErrorStatics2
struct IJsonErrorStatics2 : IInspectable {
	virtual STDMETHODIMP _GetJsonStatus(int hresult, JsonErrorStatus *status);
};

// JsonError
template<typename> struct JsonError_statics {
	static JsonErrorStatus GetJsonStatus(int hresult) { JsonErrorStatus status; hrcheck(get_activation_factory<JsonError, IJsonErrorStatics2>()->_GetJsonStatus(hresult, &status)); return status; }
};

template<typename X> struct statics<JsonError, X> : X, Windows::Data::Json::JsonError_statics<void> {
	typedef typename X::root_type JsonError;
};
struct JsonError : generate<JsonError> {};
}}}
} // namespace iso_winrt
