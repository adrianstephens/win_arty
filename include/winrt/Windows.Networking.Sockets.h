#pragma once
// generated by isopod tools
// namespaces:
// Windows.Networking.Sockets

#include "Windows.Networking.Sockets.0.h"
#include "Windows.Web.0.h"
#include "Windows.Security.Cryptography.Certificates.0.h"
#include "Windows.Networking.0.h"
#include "Windows.ApplicationModel.Background.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IVector;
template<typename K, typename V> struct IMapView;
template<typename T> struct IVectorView;
}}
namespace Networking { namespace Connectivity {
struct NetworkAdapter;
}}
namespace Security { namespace Credentials {
struct PasswordCredential;
}}
namespace Storage { namespace Streams {
struct IBuffer;
struct IInputStream;
struct IOutputStream;
struct DataReader;
}}}

// defs

template<> struct def<Windows::Networking::Sockets::ControlChannelTriggerStatus> : enum_type<int> {};
template<> struct def<Windows::Networking::Sockets::SocketMessageType> : enum_type<int> {};
template<> struct def<Windows::Networking::Sockets::SocketProtectionLevel> : enum_type<int> {};
template<> struct def<Windows::Networking::Sockets::SocketQualityOfService> : enum_type<int> {};
template<> struct def<Windows::Networking::Sockets::SocketErrorStatus> : enum_type<int> {};
template<> struct def<Windows::Networking::Sockets::SocketSslErrorSeverity> : enum_type<int> {};
template<> struct def<Windows::Networking::Sockets::RoundTripTimeStatistics> : value_type<unsigned, unsigned, unsigned, unsigned> {};
template<> struct def<Windows::Networking::Sockets::BandwidthStatistics> : value_type<unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64, bool, bool> {};
template<> struct def<Windows::Networking::Sockets::SocketActivityKind> : enum_type<int> {};
template<> struct def<Windows::Networking::Sockets::SocketActivityTriggerReason> : enum_type<int> {};
template<> struct def<Windows::Networking::Sockets::SocketActivityConnectedStandbyAction> : enum_type<int> {};
template<> struct def<Windows::Networking::Sockets::MessageWebSocketReceiveMode> : enum_type<int> {};
template<> struct def<Windows::Networking::Sockets::ISocketActivityInformation> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::ISocketActivityContextFactory> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::ISocketActivityContext> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::SocketActivityContext> : class_type<Platform::Object, Windows::Networking::Sockets::ISocketActivityContext>, custom_activators {};
template<> struct def<Windows::Networking::Sockets::IDatagramSocketStatics> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IDatagramSocket3> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IDatagramSocket2> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Networking::Sockets::IDatagramSocket> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Networking::Sockets::DatagramSocket> : class_type<Platform::Object, Windows::Networking::Sockets::IDatagramSocket, Windows::Networking::Sockets::IDatagramSocket3, Windows::Networking::Sockets::IDatagramSocket2> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocketStatics> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocket3> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocket2> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocket> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Networking::Sockets::StreamSocket> : class_type<Platform::Object, Windows::Networking::Sockets::IStreamSocket, Windows::Networking::Sockets::IStreamSocket3, Windows::Networking::Sockets::IStreamSocket2> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocketListener3> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocketListener2> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocketListener> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Networking::Sockets::StreamSocketListener> : class_type<Platform::Object, Windows::Networking::Sockets::IStreamSocketListener, Windows::Networking::Sockets::IStreamSocketListener3, Windows::Networking::Sockets::IStreamSocketListener2> {};
template<> struct def<Windows::Networking::Sockets::ISocketActivityTriggerDetails> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::ISocketActivityInformationStatics> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::SocketActivityInformation> : class_type<Platform::Object, Windows::Networking::Sockets::ISocketActivityInformation> {};
template<> struct def<Windows::Networking::Sockets::IDatagramSocketMessageReceivedEventArgs> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IMessageWebSocketMessageReceivedEventArgs> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IMessageWebSocketMessageReceivedEventArgs2> : interface_type<Windows::Networking::Sockets::IMessageWebSocketMessageReceivedEventArgs> {};
template<> struct def<Windows::Networking::Sockets::IWebSocketClosedEventArgs> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IDatagramSocketInformation> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IDatagramSocketControl> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IDatagramSocketControl2> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IDatagramSocketControl3> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::DatagramSocketControl> : class_type<Platform::Object, Windows::Networking::Sockets::IDatagramSocketControl, Windows::Networking::Sockets::IDatagramSocketControl2, Windows::Networking::Sockets::IDatagramSocketControl3> {};
template<> struct def<Windows::Networking::Sockets::DatagramSocketInformation> : class_type<Platform::Object, Windows::Networking::Sockets::IDatagramSocketInformation> {};
template<> struct def<Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs> : class_type<Platform::Object, Windows::Networking::Sockets::IDatagramSocketMessageReceivedEventArgs> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocketInformation> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocketInformation2> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocketControl> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocketControl2> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocketControl3> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocketControl4> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::StreamSocketControl> : class_type<Platform::Object, Windows::Networking::Sockets::IStreamSocketControl, Windows::Networking::Sockets::IStreamSocketControl2, Windows::Networking::Sockets::IStreamSocketControl3, Windows::Networking::Sockets::IStreamSocketControl4> {};
template<> struct def<Windows::Networking::Sockets::StreamSocketInformation> : class_type<Platform::Object, Windows::Networking::Sockets::IStreamSocketInformation, Windows::Networking::Sockets::IStreamSocketInformation2> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocketListenerControl> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocketListenerControl2> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocketListenerInformation> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IStreamSocketListenerConnectionReceivedEventArgs> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::StreamSocketListenerControl> : class_type<Platform::Object, Windows::Networking::Sockets::IStreamSocketListenerControl, Windows::Networking::Sockets::IStreamSocketListenerControl2> {};
template<> struct def<Windows::Networking::Sockets::StreamSocketListenerInformation> : class_type<Platform::Object, Windows::Networking::Sockets::IStreamSocketListenerInformation> {};
template<> struct def<Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs> : class_type<Platform::Object, Windows::Networking::Sockets::IStreamSocketListenerConnectionReceivedEventArgs> {};
template<> struct def<Windows::Networking::Sockets::IWebSocketServerCustomValidationRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IWebSocketControl> : overridable_type<> {};
template<> struct def<Windows::Networking::Sockets::IWebSocketControl2> : overridable_type<Windows::Networking::Sockets::IWebSocketControl> {};
template<> struct def<Windows::Networking::Sockets::IWebSocketInformation> : overridable_type<> {};
template<> struct def<Windows::Networking::Sockets::IWebSocketInformation2> : overridable_type<Windows::Networking::Sockets::IWebSocketInformation> {};
template<> struct def<Windows::Networking::Sockets::IWebSocket> : overridable_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Networking::Sockets::WebSocketClosedEventArgs> : class_type<Platform::Object, Windows::Networking::Sockets::IWebSocketClosedEventArgs> {};
template<> struct def<Windows::Networking::Sockets::IMessageWebSocketControl> : interface_type<Windows::Networking::Sockets::IWebSocketControl> {};
template<> struct def<Windows::Networking::Sockets::IMessageWebSocketControl2> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IMessageWebSocket> : interface_type<Windows::Networking::Sockets::IWebSocket> {};
template<> struct def<Windows::Networking::Sockets::MessageWebSocketControl> : class_type<Platform::Object, Windows::Networking::Sockets::IMessageWebSocketControl, Windows::Networking::Sockets::IMessageWebSocketControl2, Windows::Networking::Sockets::IWebSocketControl2> {};
template<> struct def<Windows::Networking::Sockets::MessageWebSocketInformation> : class_type<Platform::Object, Windows::Networking::Sockets::IWebSocketInformation, Windows::Networking::Sockets::IWebSocketInformation2> {};
template<> struct def<Windows::Networking::Sockets::IMessageWebSocket3> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IMessageWebSocket2> : interface_type<Windows::Networking::Sockets::IMessageWebSocket> {};
template<> struct def<Windows::Networking::Sockets::MessageWebSocket> : class_type<Platform::Object, Windows::Networking::Sockets::IMessageWebSocket, Windows::Networking::Sockets::IMessageWebSocket3, Windows::Networking::Sockets::IMessageWebSocket2> {};
template<> struct def<Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs> : class_type<Platform::Object, Windows::Networking::Sockets::IMessageWebSocketMessageReceivedEventArgs, Windows::Networking::Sockets::IMessageWebSocketMessageReceivedEventArgs2> {};
template<> struct def<Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs> : class_type<Platform::Object, Windows::Networking::Sockets::IWebSocketServerCustomValidationRequestedEventArgs> {};
template<> struct def<Windows::Networking::Sockets::IStreamWebSocketControl> : interface_type<Windows::Networking::Sockets::IWebSocketControl> {};
template<> struct def<Windows::Networking::Sockets::IStreamWebSocketControl2> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IStreamWebSocket> : interface_type<Windows::Networking::Sockets::IWebSocket> {};
template<> struct def<Windows::Networking::Sockets::StreamWebSocketControl> : class_type<Platform::Object, Windows::Networking::Sockets::IStreamWebSocketControl, Windows::Networking::Sockets::IStreamWebSocketControl2, Windows::Networking::Sockets::IWebSocketControl2> {};
template<> struct def<Windows::Networking::Sockets::StreamWebSocketInformation> : class_type<Platform::Object, Windows::Networking::Sockets::IWebSocketInformation, Windows::Networking::Sockets::IWebSocketInformation2> {};
template<> struct def<Windows::Networking::Sockets::IStreamWebSocket2> : interface_type<Windows::Networking::Sockets::IStreamWebSocket> {};
template<> struct def<Windows::Networking::Sockets::StreamWebSocket> : class_type<Platform::Object, Windows::Networking::Sockets::IStreamWebSocket, Windows::Networking::Sockets::IStreamWebSocket2> {};
template<> struct def<Windows::Networking::Sockets::ISocketErrorStatics> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IWebSocketErrorStatics> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IServerMessageWebSocket> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Networking::Sockets::ServerMessageWebSocket> : class_type<Platform::Object, Windows::Networking::Sockets::IServerMessageWebSocket> {};
template<> struct def<Windows::Networking::Sockets::IServerMessageWebSocketControl> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::ServerMessageWebSocketControl> : class_type<Platform::Object, Windows::Networking::Sockets::IServerMessageWebSocketControl> {};
template<> struct def<Windows::Networking::Sockets::IServerMessageWebSocketInformation> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::ServerMessageWebSocketInformation> : class_type<Platform::Object, Windows::Networking::Sockets::IServerMessageWebSocketInformation> {};
template<> struct def<Windows::Networking::Sockets::IServerStreamWebSocketInformation> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IServerStreamWebSocket> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Networking::Sockets::ServerStreamWebSocketInformation> : class_type<Platform::Object, Windows::Networking::Sockets::IServerStreamWebSocketInformation> {};
template<> struct def<Windows::Networking::Sockets::ServerStreamWebSocket> : class_type<Platform::Object, Windows::Networking::Sockets::IServerStreamWebSocket> {};
template<> struct def<Windows::Networking::Sockets::WebSocketKeepAlive> : class_type<Platform::Object, Windows::ApplicationModel::Background::IBackgroundTask> {};
template<> struct def<Windows::Networking::Sockets::SocketError> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Networking::Sockets::WebSocketError> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Networking::Sockets::SocketActivityTriggerDetails> : class_type<Platform::Object, Windows::Networking::Sockets::ISocketActivityTriggerDetails> {};
template<> struct def<Windows::Networking::Sockets::ControlChannelTriggerContract> : value_type<> {};
template<> struct def<Windows::Networking::Sockets::ControlChannelTriggerResourceType> : enum_type<int> {};
template<> struct def<Windows::Networking::Sockets::ControlChannelTriggerResetReason> : enum_type<int> {};
template<> struct def<Windows::Networking::Sockets::IControlChannelTrigger> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Networking::Sockets::IControlChannelTriggerFactory> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::IControlChannelTrigger2> : interface_type<> {};
template<> struct def<Windows::Networking::Sockets::ControlChannelTrigger> : class_type<Platform::Object, Windows::Networking::Sockets::IControlChannelTrigger, Windows::Networking::Sockets::IControlChannelTrigger2>, custom_activators {};
template<> struct def<Windows::Networking::Sockets::IControlChannelTriggerEventDetails> : overridable_type<> {};
template<> struct def<Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails> : overridable_type<> {};

// uuids

template<> struct uuid<Windows::Networking::Sockets::ISocketActivityInformation> { define_guid(0x8D8A42E4, 0xA87E, 0x4B74, 0x99, 0x68, 0x18, 0x5B, 0x25, 0x11, 0xDE, 0xFE);};
template<> struct uuid<Windows::Networking::Sockets::ISocketActivityContextFactory> { define_guid(0xB99FC3C3, 0x88C, 0x4388, 0x83, 0xAE, 0x25, 0x25, 0x13, 0x8E, 0x4, 0x9A);};
template<> struct uuid<Windows::Networking::Sockets::ISocketActivityContext> { define_guid(0x43B04D64, 0x4C85, 0x4396, 0xA6, 0x37, 0x1D, 0x97, 0x3F, 0x6E, 0xBD, 0x49);};
template<> struct uuid<Windows::Networking::Sockets::IDatagramSocketStatics> { define_guid(0xE9C62AEE, 0x1494, 0x4A21, 0xBB, 0x7E, 0x85, 0x89, 0xFC, 0x75, 0x1D, 0x9D);};
template<> struct uuid<Windows::Networking::Sockets::IDatagramSocket3> { define_guid(0x37544F09, 0xAB92, 0x4306, 0x9A, 0xC1, 0xC, 0x38, 0x12, 0x83, 0xD9, 0xC6);};
template<> struct uuid<Windows::Networking::Sockets::IDatagramSocket2> { define_guid(0xD83BA354, 0x9A9D, 0x4185, 0xA2, 0xA, 0x14, 0x24, 0xC9, 0xC2, 0xA7, 0xCD);};
template<> struct uuid<Windows::Networking::Sockets::IDatagramSocket> { define_guid(0x7FE25BBB, 0xC3BC, 0x4677, 0x84, 0x46, 0xCA, 0x28, 0xA4, 0x65, 0xA3, 0xAF);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocketStatics> { define_guid(0xA420BC4A, 0x6E2E, 0x4AF5, 0xB5, 0x56, 0x35, 0x5A, 0xE0, 0xCD, 0x4F, 0x29);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocket3> { define_guid(0x3F430B00, 0x9D28, 0x4854, 0xBA, 0xC3, 0x23, 0x1, 0x94, 0x1E, 0xC2, 0x23);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocket2> { define_guid(0x29D0E575, 0xF314, 0x4D09, 0xAD, 0xF0, 0xF, 0xBD, 0x96, 0x7F, 0xBD, 0x9F);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocket> { define_guid(0x69A22CF3, 0xFC7B, 0x4857, 0xAF, 0x38, 0xF6, 0xE7, 0xDE, 0x6A, 0x5B, 0x49);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocketListener3> { define_guid(0x4798201C, 0xBDF8, 0x4919, 0x85, 0x42, 0x28, 0xD4, 0x50, 0xE7, 0x45, 0x7);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocketListener2> { define_guid(0x658DC13E, 0xBB3E, 0x4458, 0xB2, 0x32, 0xED, 0x10, 0x88, 0x69, 0x4B, 0x98);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocketListener> { define_guid(0xFF513437, 0xDF9F, 0x4DF0, 0xBF, 0x82, 0xE, 0xC5, 0xD7, 0xB3, 0x5A, 0xAE);};
template<> struct uuid<Windows::Networking::Sockets::ISocketActivityTriggerDetails> { define_guid(0x45F406A7, 0xFC9F, 0x4F81, 0xAC, 0xAD, 0x35, 0x5F, 0xEF, 0x51, 0xE6, 0x7B);};
template<> struct uuid<Windows::Networking::Sockets::ISocketActivityInformationStatics> { define_guid(0x8570B47A, 0x7E7D, 0x4736, 0x80, 0x41, 0x13, 0x27, 0xA6, 0x54, 0x3C, 0x56);};
template<> struct uuid<Windows::Networking::Sockets::IDatagramSocketMessageReceivedEventArgs> { define_guid(0x9E2DDCA2, 0x1712, 0x4CE4, 0xB1, 0x79, 0x8C, 0x65, 0x2C, 0x6D, 0x10, 0x7E);};
template<> struct uuid<Windows::Networking::Sockets::IMessageWebSocketMessageReceivedEventArgs> { define_guid(0x478C22AC, 0x4C4B, 0x42ED, 0x9E, 0xD7, 0x1E, 0xF9, 0xF9, 0x4F, 0xA3, 0xD5);};
template<> struct uuid<Windows::Networking::Sockets::IMessageWebSocketMessageReceivedEventArgs2> { define_guid(0x89CE06FD, 0xDD6F, 0x4A07, 0x87, 0xF9, 0xF9, 0xEB, 0x4D, 0x89, 0xD8, 0x3D);};
template<> struct uuid<Windows::Networking::Sockets::IWebSocketClosedEventArgs> { define_guid(0xCEB78D07, 0xD0A8, 0x4703, 0xA0, 0x91, 0xC8, 0xC2, 0xC0, 0x91, 0x5B, 0xC3);};
template<> struct uuid<Windows::Networking::Sockets::IDatagramSocketInformation> { define_guid(0x5F1A569A, 0x55FB, 0x48CD, 0x97, 0x6, 0x7A, 0x97, 0x4F, 0x7B, 0x15, 0x85);};
template<> struct uuid<Windows::Networking::Sockets::IDatagramSocketControl> { define_guid(0x52AC3F2E, 0x349A, 0x4135, 0xBB, 0x58, 0xB7, 0x9B, 0x26, 0x47, 0xD3, 0x90);};
template<> struct uuid<Windows::Networking::Sockets::IDatagramSocketControl2> { define_guid(0x33EAD5C2, 0x979C, 0x4415, 0x82, 0xA1, 0x3C, 0xFA, 0xF6, 0x46, 0xC1, 0x92);};
template<> struct uuid<Windows::Networking::Sockets::IDatagramSocketControl3> { define_guid(0xD4EB8256, 0x1F6D, 0x4598, 0x9B, 0x57, 0xD4, 0x2A, 0x0, 0x1D, 0xF3, 0x49);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocketInformation> { define_guid(0x3B80AE30, 0x5E68, 0x4205, 0x88, 0xF0, 0xDC, 0x85, 0xD2, 0xE2, 0x5D, 0xED);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocketInformation2> { define_guid(0x12C28452, 0x4BDC, 0x4EE4, 0x97, 0x6A, 0xCF, 0x13, 0xE, 0x9D, 0x92, 0xE3);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocketControl> { define_guid(0xFE25ADF1, 0x92AB, 0x4AF3, 0x99, 0x92, 0xF, 0x4C, 0x85, 0xE3, 0x6C, 0xC4);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocketControl2> { define_guid(0xC2D09A56, 0x60F, 0x44C1, 0xB8, 0xE2, 0x1F, 0xBF, 0x60, 0xBD, 0x62, 0xC5);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocketControl3> { define_guid(0xC56A444C, 0x4E74, 0x403E, 0x89, 0x4C, 0xB3, 0x1C, 0xAE, 0x5C, 0x73, 0x42);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocketControl4> { define_guid(0x964E2B3D, 0xEC27, 0x4888, 0xB3, 0xCE, 0xC7, 0x4B, 0x41, 0x84, 0x23, 0xAD);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocketListenerControl> { define_guid(0x20D8C576, 0x8D8A, 0x4DBA, 0x97, 0x22, 0xA1, 0x6C, 0x4D, 0x98, 0x49, 0x80);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocketListenerControl2> { define_guid(0x948BB665, 0x2C3E, 0x404B, 0xB8, 0xB0, 0x8E, 0xB2, 0x49, 0xA2, 0xB0, 0xA1);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocketListenerInformation> { define_guid(0xE62BA82F, 0xA63A, 0x430B, 0xBF, 0x62, 0x29, 0xE9, 0x3E, 0x56, 0x33, 0xB4);};
template<> struct uuid<Windows::Networking::Sockets::IStreamSocketListenerConnectionReceivedEventArgs> { define_guid(0xC472EA9, 0x373F, 0x447B, 0x85, 0xB1, 0xDD, 0xD4, 0x54, 0x88, 0x3, 0xBA);};
template<> struct uuid<Windows::Networking::Sockets::IWebSocketServerCustomValidationRequestedEventArgs> { define_guid(0xFFEFFE48, 0x22A, 0x4AB7, 0x8B, 0x36, 0xE1, 0xA, 0xF4, 0x64, 0xE, 0x6B);};
template<> struct uuid<Windows::Networking::Sockets::IWebSocketControl> { define_guid(0x2EC4BDC3, 0xD9A5, 0x455A, 0x98, 0x11, 0xDE, 0x24, 0xD4, 0x53, 0x37, 0xE9);};
template<> struct uuid<Windows::Networking::Sockets::IWebSocketControl2> { define_guid(0x79C3BE03, 0xF2CA, 0x461E, 0xAF, 0x4E, 0x96, 0x65, 0xBC, 0x2D, 0x6, 0x20);};
template<> struct uuid<Windows::Networking::Sockets::IWebSocketInformation> { define_guid(0x5E01E316, 0xC92A, 0x47A5, 0xB2, 0x5F, 0x7, 0x84, 0x76, 0x39, 0xD1, 0x81);};
template<> struct uuid<Windows::Networking::Sockets::IWebSocketInformation2> { define_guid(0xCE1D39CE, 0xA1B7, 0x4D43, 0x82, 0x69, 0x8D, 0x5B, 0x98, 0x1B, 0xD4, 0x7A);};
template<> struct uuid<Windows::Networking::Sockets::IWebSocket> { define_guid(0xF877396F, 0x99B1, 0x4E18, 0xBC, 0x8, 0x85, 0xC, 0x9A, 0xDF, 0x15, 0x6E);};
template<> struct uuid<Windows::Networking::Sockets::IMessageWebSocketControl> { define_guid(0x8118388A, 0xC629, 0x4F0A, 0x80, 0xFB, 0x81, 0xFC, 0x5, 0x53, 0x88, 0x62);};
template<> struct uuid<Windows::Networking::Sockets::IMessageWebSocketControl2> { define_guid(0xE30FD791, 0x80C, 0x400A, 0xA7, 0x12, 0x27, 0xDF, 0xA9, 0xE7, 0x44, 0xD8);};
template<> struct uuid<Windows::Networking::Sockets::IMessageWebSocket> { define_guid(0x33727D08, 0x34D5, 0x4746, 0xAD, 0x7B, 0x8D, 0xDE, 0x5B, 0xC2, 0xEF, 0x88);};
template<> struct uuid<Windows::Networking::Sockets::IMessageWebSocket3> { define_guid(0x59D9DEFB, 0x71AF, 0x4349, 0x84, 0x87, 0x91, 0x1F, 0xCF, 0x68, 0x15, 0x97);};
template<> struct uuid<Windows::Networking::Sockets::IMessageWebSocket2> { define_guid(0xBED0CEE7, 0xF9C8, 0x440A, 0x9A, 0xD5, 0x73, 0x72, 0x81, 0xD9, 0x74, 0x2E);};
template<> struct uuid<Windows::Networking::Sockets::IStreamWebSocketControl> { define_guid(0xB4F478B1, 0xA45A, 0x48DB, 0x95, 0x3A, 0x64, 0x5B, 0x7D, 0x96, 0x4C, 0x7);};
template<> struct uuid<Windows::Networking::Sockets::IStreamWebSocketControl2> { define_guid(0x215D9F7E, 0xFA58, 0x40DA, 0x9F, 0x11, 0xA4, 0x8D, 0xAF, 0xE9, 0x50, 0x37);};
template<> struct uuid<Windows::Networking::Sockets::IStreamWebSocket> { define_guid(0xBD4A49D8, 0xB289, 0x45BB, 0x97, 0xEB, 0xC7, 0x52, 0x52, 0x5, 0xA8, 0x43);};
template<> struct uuid<Windows::Networking::Sockets::IStreamWebSocket2> { define_guid(0xAA4D08CB, 0x93F5, 0x4678, 0x82, 0x36, 0x57, 0xCC, 0xE5, 0x41, 0x7E, 0xD5);};
template<> struct uuid<Windows::Networking::Sockets::ISocketErrorStatics> { define_guid(0x828337F4, 0x7D56, 0x4D8E, 0xB7, 0xB4, 0xA0, 0x7D, 0xD7, 0xC1, 0xBC, 0xA9);};
template<> struct uuid<Windows::Networking::Sockets::IWebSocketErrorStatics> { define_guid(0x27CDF35B, 0x1F61, 0x4709, 0x8E, 0x2, 0x61, 0x28, 0x3A, 0xDA, 0x4E, 0x9D);};
template<> struct uuid<Windows::Networking::Sockets::IServerMessageWebSocket> { define_guid(0xE3AC9240, 0x813B, 0x5EFD, 0x7E, 0x11, 0xAE, 0x23, 0x5, 0xFC, 0x77, 0xF1);};
template<> struct uuid<Windows::Networking::Sockets::IServerMessageWebSocketControl> { define_guid(0x69C2F051, 0x1C1F, 0x587A, 0x45, 0x19, 0x21, 0x81, 0x61, 0x1, 0x92, 0xB7);};
template<> struct uuid<Windows::Networking::Sockets::IServerMessageWebSocketInformation> { define_guid(0xFC32B45F, 0x4448, 0x5505, 0x6C, 0xC9, 0x9, 0xAF, 0xA8, 0x91, 0x5F, 0x5D);};
template<> struct uuid<Windows::Networking::Sockets::IServerStreamWebSocketInformation> { define_guid(0xFC32B45F, 0x4448, 0x5505, 0x6C, 0xC9, 0x9, 0xAB, 0xA8, 0x91, 0x5F, 0x5D);};
template<> struct uuid<Windows::Networking::Sockets::IServerStreamWebSocket> { define_guid(0x2CED5BBF, 0x74F6, 0x55E4, 0x79, 0xDF, 0x91, 0x32, 0x68, 0xD, 0xFE, 0xE8);};
template<> struct uuid<Windows::Networking::Sockets::IControlChannelTrigger> { define_guid(0x7D1431A7, 0xEE96, 0x40E8, 0xA1, 0x99, 0x87, 0x3, 0xCD, 0x96, 0x9E, 0xC3);};
template<> struct uuid<Windows::Networking::Sockets::IControlChannelTriggerFactory> { define_guid(0xDA4B7CF0, 0x8D71, 0x446F, 0x88, 0xC3, 0xB9, 0x51, 0x84, 0xA2, 0xD6, 0xCD);};
template<> struct uuid<Windows::Networking::Sockets::IControlChannelTrigger2> { define_guid(0xAF00D237, 0x51BE, 0x4514, 0x97, 0x25, 0x35, 0x56, 0xE1, 0x87, 0x95, 0x80);};
template<> struct uuid<Windows::Networking::Sockets::IControlChannelTriggerEventDetails> { define_guid(0x1B36E047, 0x89BB, 0x4236, 0x96, 0xAC, 0x71, 0xD0, 0x12, 0xBB, 0x48, 0x69);};
template<> struct uuid<Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails> { define_guid(0x6851038E, 0x8EC4, 0x42FE, 0x9B, 0xB2, 0x21, 0xE9, 0x1B, 0x7B, 0xFC, 0xB1);};

// types

namespace Windows { namespace Networking { namespace Sockets {

// ISocketActivityInformation
struct ISocketActivityInformation_raw : IInspectable {
	virtual STDMETHODIMP _get_TaskId(Platform::Guid *value);
	virtual STDMETHODIMP _get_Id(HSTRING *value);
	virtual STDMETHODIMP _get_SocketKind(SocketActivityKind *value);
	virtual STDMETHODIMP _get_Context(SocketActivityContext* *value);
	virtual STDMETHODIMP _get_DatagramSocket(Sockets::DatagramSocket* *value);
	virtual STDMETHODIMP _get_StreamSocket(Sockets::StreamSocket* *value);
	virtual STDMETHODIMP _get_StreamSocketListener(Sockets::StreamSocketListener* *value);
};
template<typename X> struct ISocketActivityInformation_adaptor : X {
	union {
		struct : property {
			ptr<SocketActivityContext> get() { SocketActivityContext* value; hrcheck(enc(&ISocketActivityInformation_adaptor::Context)->_get_Context(&value)); return from_abi(value); }
			ptr<SocketActivityContext> operator()() { return get(); }
			operator ptr<SocketActivityContext> () { return get(); }
			ptr<SocketActivityContext> operator->() { return get(); }
		} Context;
		struct : property {
			ptr<Sockets::DatagramSocket> get() { Sockets::DatagramSocket* value; hrcheck(enc(&ISocketActivityInformation_adaptor::DatagramSocket)->_get_DatagramSocket(&value)); return from_abi(value); }
			ptr<Sockets::DatagramSocket> operator()() { return get(); }
			operator ptr<Sockets::DatagramSocket> () { return get(); }
			ptr<Sockets::DatagramSocket> operator->() { return get(); }
		} DatagramSocket;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISocketActivityInformation_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
		struct : property {
			SocketActivityKind get() { SocketActivityKind value; hrcheck(enc(&ISocketActivityInformation_adaptor::SocketKind)->_get_SocketKind(&value)); return value; }
			SocketActivityKind operator()() { return get(); }
			operator SocketActivityKind () { return get(); }
		} SocketKind;
		struct : property {
			ptr<Sockets::StreamSocket> get() { Sockets::StreamSocket* value; hrcheck(enc(&ISocketActivityInformation_adaptor::StreamSocket)->_get_StreamSocket(&value)); return from_abi(value); }
			ptr<Sockets::StreamSocket> operator()() { return get(); }
			operator ptr<Sockets::StreamSocket> () { return get(); }
			ptr<Sockets::StreamSocket> operator->() { return get(); }
		} StreamSocket;
		struct : property {
			ptr<Sockets::StreamSocketListener> get() { Sockets::StreamSocketListener* value; hrcheck(enc(&ISocketActivityInformation_adaptor::StreamSocketListener)->_get_StreamSocketListener(&value)); return from_abi(value); }
			ptr<Sockets::StreamSocketListener> operator()() { return get(); }
			operator ptr<Sockets::StreamSocketListener> () { return get(); }
			ptr<Sockets::StreamSocketListener> operator->() { return get(); }
		} StreamSocketListener;
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&ISocketActivityInformation_adaptor::TaskId)->_get_TaskId(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} TaskId;
	};
	ISocketActivityInformation_adaptor() {}
};
template<typename X> struct adapt<ISocketActivityInformation, X> : Windows::Networking::Sockets::ISocketActivityInformation_adaptor<X> { typedef adapt ISocketActivityInformation; };
struct ISocketActivityInformation : ISocketActivityInformation_raw, generate<ISocketActivityInformation> {};

// ISocketActivityContextFactory
struct ISocketActivityContextFactory : IInspectable {
	virtual STDMETHODIMP _Create(Storage::Streams::IBuffer* data, SocketActivityContext* *context);
};

// ISocketActivityContext
struct ISocketActivityContext_raw : IInspectable {
	virtual STDMETHODIMP _get_Data(Storage::Streams::IBuffer* *value);
};
template<typename X> struct ISocketActivityContext_adaptor : X {
	union {
		struct : property {
			ptr<Storage::Streams::IBuffer> get() { Storage::Streams::IBuffer* value; hrcheck(enc(&ISocketActivityContext_adaptor::Data)->_get_Data(&value)); return from_abi(value); }
			ptr<Storage::Streams::IBuffer> operator()() { return get(); }
			operator ptr<Storage::Streams::IBuffer> () { return get(); }
			ptr<Storage::Streams::IBuffer> operator->() { return get(); }
		} Data;
	};
	ISocketActivityContext_adaptor() {}
};
template<typename X> struct adapt<ISocketActivityContext, X> : Windows::Networking::Sockets::ISocketActivityContext_adaptor<X> { typedef adapt ISocketActivityContext; };
struct ISocketActivityContext : ISocketActivityContext_raw, generate<ISocketActivityContext> {};

// SocketActivityContext
template<typename> struct SocketActivityContext_statics {
	static SocketActivityContext *activate(pptr<Storage::Streams::IBuffer> data) { SocketActivityContext *context; hrcheck(get_activation_factory<SocketActivityContext, ISocketActivityContextFactory>()->_Create(data, &context)); return context; }
};

template<typename X> struct statics<SocketActivityContext, X> : X, Windows::Networking::Sockets::SocketActivityContext_statics<void> {
	using Windows::Networking::Sockets::SocketActivityContext_statics<void>::activate;
	typedef typename X::root_type SocketActivityContext;
};
struct SocketActivityContext : generate<SocketActivityContext> {};

// IDatagramSocketStatics
struct IDatagramSocketStatics : IInspectable {
	virtual STDMETHODIMP _GetEndpointPairsAsync(HostName* remoteHostName, HSTRING remoteServiceName, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<EndpointPair*>*>* *operation);
	virtual STDMETHODIMP _GetEndpointPairsWithSortOptionsAsync(HostName* remoteHostName, HSTRING remoteServiceName, HostNameSortOptions sortOptions, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<EndpointPair*>*>* *operation);
};

// IDatagramSocket3
struct IDatagramSocket3_raw : IInspectable {
	virtual STDMETHODIMP _CancelIOAsync(Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _EnableTransferOwnership(Platform::Guid taskId);
	virtual STDMETHODIMP _EnableTransferOwnershipWithConnectedStandbyAction(Platform::Guid taskId, SocketActivityConnectedStandbyAction connectedStandbyAction);
	virtual STDMETHODIMP _TransferOwnership(HSTRING socketId);
	virtual STDMETHODIMP _TransferOwnershipWithContext(HSTRING socketId, SocketActivityContext* data);
	virtual STDMETHODIMP _TransferOwnershipWithContextAndKeepAliveTime(HSTRING socketId, SocketActivityContext* data, Foundation::TimeSpan keepAliveTime);
};
template<typename X> struct IDatagramSocket3_adaptor : X {
	ptr<Foundation::IAsyncAction> CancelIOAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_CancelIOAsync(&operation)); return from_abi(operation); }
	void EnableTransferOwnership(const Platform::Guid& taskId) { hrcheck(X::get()->_EnableTransferOwnership(taskId)); }
	void EnableTransferOwnership(const Platform::Guid& taskId, SocketActivityConnectedStandbyAction connectedStandbyAction) { hrcheck(X::get()->_EnableTransferOwnershipWithConnectedStandbyAction(taskId, connectedStandbyAction)); }
	void TransferOwnership(hstring_ref socketId) { hrcheck(X::get()->_TransferOwnership(socketId)); }
	void TransferOwnership(hstring_ref socketId, pptr<SocketActivityContext> data) { hrcheck(X::get()->_TransferOwnershipWithContext(socketId, data)); }
	void TransferOwnership(hstring_ref socketId, pptr<SocketActivityContext> data, const Foundation::TimeSpan& keepAliveTime) { hrcheck(X::get()->_TransferOwnershipWithContextAndKeepAliveTime(socketId, data, keepAliveTime)); }
};
template<typename X> struct adapt<IDatagramSocket3, X> : Windows::Networking::Sockets::IDatagramSocket3_adaptor<X> { typedef adapt IDatagramSocket3; };
struct IDatagramSocket3 : IDatagramSocket3_raw, generate<IDatagramSocket3> {};

// IDatagramSocket2
struct IDatagramSocket2_raw : IInspectable {
	virtual STDMETHODIMP _BindServiceNameAndAdapterAsync(HSTRING localServiceName, Connectivity::NetworkAdapter* adapter, Foundation::IAsyncAction* *operation);
};
template<typename X> struct IDatagramSocket2_adaptor : X {
	ptr<Foundation::IAsyncAction> BindServiceNameAsync(hstring_ref localServiceName, pptr<Connectivity::NetworkAdapter> adapter) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_BindServiceNameAndAdapterAsync(localServiceName, adapter, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IDatagramSocket2, X> : Windows::Networking::Sockets::IDatagramSocket2_adaptor<X> { typedef adapt IDatagramSocket2; };
struct IDatagramSocket2 : IDatagramSocket2_raw, generate<IDatagramSocket2> {};

// IDatagramSocket
struct IDatagramSocket_raw : IInspectable {
	virtual STDMETHODIMP _get_Control(DatagramSocketControl* *value);
	virtual STDMETHODIMP _get_Information(DatagramSocketInformation* *value);
	virtual STDMETHODIMP _get_OutputStream(Storage::Streams::IOutputStream* *value);
	virtual STDMETHODIMP _ConnectAsync(HostName* remoteHostName, HSTRING remoteServiceName, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _ConnectWithEndpointPairAsync(EndpointPair* endpointPair, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _BindServiceNameAsync(HSTRING localServiceName, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _BindEndpointAsync(HostName* localHostName, HSTRING localServiceName, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _JoinMulticastGroup(HostName* host);
	virtual STDMETHODIMP _GetOutputStreamAsync(HostName* remoteHostName, HSTRING remoteServiceName, Foundation::IAsyncOperation<Storage::Streams::IOutputStream*>* *value);
	virtual STDMETHODIMP _GetOutputStreamWithEndpointPairAsync(EndpointPair* endpointPair, Foundation::IAsyncOperation<Storage::Streams::IOutputStream*>* *value);
	virtual STDMETHODIMP _add_MessageReceived(Foundation::TypedEventHandler<DatagramSocket*, DatagramSocketMessageReceivedEventArgs*>* eventHandler, Foundation::EventRegistrationToken *eventCookie);
	virtual STDMETHODIMP _remove_MessageReceived(Foundation::EventRegistrationToken eventCookie);
};
template<typename X> struct IDatagramSocket_adaptor : X {
	union {
		struct : property {
			ptr<DatagramSocketControl> get() { DatagramSocketControl* value; hrcheck(enc(&IDatagramSocket_adaptor::Control)->_get_Control(&value)); return from_abi(value); }
			ptr<DatagramSocketControl> operator()() { return get(); }
			operator ptr<DatagramSocketControl> () { return get(); }
			ptr<DatagramSocketControl> operator->() { return get(); }
		} Control;
		struct : property {
			ptr<DatagramSocketInformation> get() { DatagramSocketInformation* value; hrcheck(enc(&IDatagramSocket_adaptor::Information)->_get_Information(&value)); return from_abi(value); }
			ptr<DatagramSocketInformation> operator()() { return get(); }
			operator ptr<DatagramSocketInformation> () { return get(); }
			ptr<DatagramSocketInformation> operator->() { return get(); }
		} Information;
		struct : property {
			ptr<Storage::Streams::IOutputStream> get() { Storage::Streams::IOutputStream* value; hrcheck(enc(&IDatagramSocket_adaptor::OutputStream)->_get_OutputStream(&value)); return from_abi(value); }
			ptr<Storage::Streams::IOutputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IOutputStream> () { return get(); }
			ptr<Storage::Streams::IOutputStream> operator->() { return get(); }
		} OutputStream;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DatagramSocket>, ptr<DatagramSocketMessageReceivedEventArgs>>> eventHandler) { Foundation::EventRegistrationToken eventCookie; hrcheck(enc(&IDatagramSocket_adaptor::MessageReceived)->_add_MessageReceived(to_abi(eventHandler), &eventCookie)); return eventCookie; }
			void operator-=(const Foundation::EventRegistrationToken& eventCookie) { hrcheck(enc(&IDatagramSocket_adaptor::MessageReceived)->_remove_MessageReceived(eventCookie)); }
		} MessageReceived;
	};
	ptr<Foundation::IAsyncAction> ConnectAsync(pptr<HostName> remoteHostName, hstring_ref remoteServiceName) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_ConnectAsync(remoteHostName, remoteServiceName, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> ConnectAsync(pptr<EndpointPair> endpointPair) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_ConnectWithEndpointPairAsync(endpointPair, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> BindServiceNameAsync(hstring_ref localServiceName) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_BindServiceNameAsync(localServiceName, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> BindEndpointAsync(pptr<HostName> localHostName, hstring_ref localServiceName) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_BindEndpointAsync(localHostName, localServiceName, &operation)); return from_abi(operation); }
	void JoinMulticastGroup(pptr<HostName> host) { hrcheck(X::get()->_JoinMulticastGroup(host)); }
	ptr<Foundation::IAsyncOperation<ptr<Storage::Streams::IOutputStream>>> GetOutputStreamAsync(pptr<HostName> remoteHostName, hstring_ref remoteServiceName) { Foundation::IAsyncOperation<Storage::Streams::IOutputStream*>* value; hrcheck(X::get()->_GetOutputStreamAsync(remoteHostName, remoteServiceName, &value)); return from_abi(value); }
	ptr<Foundation::IAsyncOperation<ptr<Storage::Streams::IOutputStream>>> GetOutputStreamAsync(pptr<EndpointPair> endpointPair) { Foundation::IAsyncOperation<Storage::Streams::IOutputStream*>* value; hrcheck(X::get()->_GetOutputStreamWithEndpointPairAsync(endpointPair, &value)); return from_abi(value); }
	IDatagramSocket_adaptor() {}
};
template<typename X> struct adapt<IDatagramSocket, X> : Windows::Networking::Sockets::IDatagramSocket_adaptor<X> { typedef adapt IDatagramSocket; };
struct IDatagramSocket : IDatagramSocket_raw, generate<IDatagramSocket> {};

// DatagramSocket
template<typename> struct DatagramSocket_statics {
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<EndpointPair>>>>> GetEndpointPairsAsync(pptr<HostName> remoteHostName, hstring_ref remoteServiceName) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<EndpointPair*>*>* operation; hrcheck(get_activation_factory<DatagramSocket, IDatagramSocketStatics>()->_GetEndpointPairsAsync(remoteHostName, remoteServiceName, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<EndpointPair>>>>> GetEndpointPairsAsync(pptr<HostName> remoteHostName, hstring_ref remoteServiceName, HostNameSortOptions sortOptions) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<EndpointPair*>*>* operation; hrcheck(get_activation_factory<DatagramSocket, IDatagramSocketStatics>()->_GetEndpointPairsWithSortOptionsAsync(remoteHostName, remoteServiceName, sortOptions, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<DatagramSocket, X> : X, Windows::Networking::Sockets::DatagramSocket_statics<void> {
	typedef typename X::root_type DatagramSocket;
};
struct DatagramSocket : generate<DatagramSocket> {
	using IDatagramSocket3::TransferOwnership;
	using IDatagramSocket::ConnectAsync;
	using IDatagramSocket::BindServiceNameAsync;
	using IDatagramSocket2::BindServiceNameAsync;
	using IDatagramSocket::GetOutputStreamAsync;
	using IDatagramSocket3::EnableTransferOwnership;
};

// IStreamSocketStatics
struct IStreamSocketStatics : IInspectable {
	virtual STDMETHODIMP _GetEndpointPairsAsync(HostName* remoteHostName, HSTRING remoteServiceName, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<EndpointPair*>*>* *operation);
	virtual STDMETHODIMP _GetEndpointPairsWithSortOptionsAsync(HostName* remoteHostName, HSTRING remoteServiceName, HostNameSortOptions sortOptions, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<EndpointPair*>*>* *operation);
};

// IStreamSocket3
struct IStreamSocket3_raw : IInspectable {
	virtual STDMETHODIMP _CancelIOAsync(Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _EnableTransferOwnership(Platform::Guid taskId);
	virtual STDMETHODIMP _EnableTransferOwnershipWithConnectedStandbyAction(Platform::Guid taskId, SocketActivityConnectedStandbyAction connectedStandbyAction);
	virtual STDMETHODIMP _TransferOwnership(HSTRING socketId);
	virtual STDMETHODIMP _TransferOwnershipWithContext(HSTRING socketId, SocketActivityContext* data);
	virtual STDMETHODIMP _TransferOwnershipWithContextAndKeepAliveTime(HSTRING socketId, SocketActivityContext* data, Foundation::TimeSpan keepAliveTime);
};
template<typename X> struct IStreamSocket3_adaptor : X {
	ptr<Foundation::IAsyncAction> CancelIOAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_CancelIOAsync(&operation)); return from_abi(operation); }
	void EnableTransferOwnership(const Platform::Guid& taskId) { hrcheck(X::get()->_EnableTransferOwnership(taskId)); }
	void EnableTransferOwnership(const Platform::Guid& taskId, SocketActivityConnectedStandbyAction connectedStandbyAction) { hrcheck(X::get()->_EnableTransferOwnershipWithConnectedStandbyAction(taskId, connectedStandbyAction)); }
	void TransferOwnership(hstring_ref socketId) { hrcheck(X::get()->_TransferOwnership(socketId)); }
	void TransferOwnership(hstring_ref socketId, pptr<SocketActivityContext> data) { hrcheck(X::get()->_TransferOwnershipWithContext(socketId, data)); }
	void TransferOwnership(hstring_ref socketId, pptr<SocketActivityContext> data, const Foundation::TimeSpan& keepAliveTime) { hrcheck(X::get()->_TransferOwnershipWithContextAndKeepAliveTime(socketId, data, keepAliveTime)); }
};
template<typename X> struct adapt<IStreamSocket3, X> : Windows::Networking::Sockets::IStreamSocket3_adaptor<X> { typedef adapt IStreamSocket3; };
struct IStreamSocket3 : IStreamSocket3_raw, generate<IStreamSocket3> {};

// IStreamSocket2
struct IStreamSocket2_raw : IInspectable {
	virtual STDMETHODIMP _ConnectWithProtectionLevelAndAdapterAsync(HostName* remoteHostName, HSTRING remoteServiceName, SocketProtectionLevel protectionLevel, Connectivity::NetworkAdapter* adapter, Foundation::IAsyncAction* *operation);
};
template<typename X> struct IStreamSocket2_adaptor : X {
	ptr<Foundation::IAsyncAction> ConnectAsync(pptr<HostName> remoteHostName, hstring_ref remoteServiceName, SocketProtectionLevel protectionLevel, pptr<Connectivity::NetworkAdapter> adapter) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_ConnectWithProtectionLevelAndAdapterAsync(remoteHostName, remoteServiceName, protectionLevel, adapter, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IStreamSocket2, X> : Windows::Networking::Sockets::IStreamSocket2_adaptor<X> { typedef adapt IStreamSocket2; };
struct IStreamSocket2 : IStreamSocket2_raw, generate<IStreamSocket2> {};

// IStreamSocket
struct IStreamSocket_raw : IInspectable {
	virtual STDMETHODIMP _get_Control(StreamSocketControl* *value);
	virtual STDMETHODIMP _get_Information(StreamSocketInformation* *value);
	virtual STDMETHODIMP _get_InputStream(Storage::Streams::IInputStream* *value);
	virtual STDMETHODIMP _get_OutputStream(Storage::Streams::IOutputStream* *value);
	virtual STDMETHODIMP _ConnectWithEndpointPairAsync(EndpointPair* endpointPair, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _ConnectAsync(HostName* remoteHostName, HSTRING remoteServiceName, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _ConnectWithEndpointPairAndProtectionLevelAsync(EndpointPair* endpointPair, SocketProtectionLevel protectionLevel, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _ConnectWithProtectionLevelAsync(HostName* remoteHostName, HSTRING remoteServiceName, SocketProtectionLevel protectionLevel, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _UpgradeToSslAsync(SocketProtectionLevel protectionLevel, HostName* validationHostName, Foundation::IAsyncAction* *operation);
};
template<typename X> struct IStreamSocket_adaptor : X {
	union {
		struct : property {
			ptr<StreamSocketControl> get() { StreamSocketControl* value; hrcheck(enc(&IStreamSocket_adaptor::Control)->_get_Control(&value)); return from_abi(value); }
			ptr<StreamSocketControl> operator()() { return get(); }
			operator ptr<StreamSocketControl> () { return get(); }
			ptr<StreamSocketControl> operator->() { return get(); }
		} Control;
		struct : property {
			ptr<StreamSocketInformation> get() { StreamSocketInformation* value; hrcheck(enc(&IStreamSocket_adaptor::Information)->_get_Information(&value)); return from_abi(value); }
			ptr<StreamSocketInformation> operator()() { return get(); }
			operator ptr<StreamSocketInformation> () { return get(); }
			ptr<StreamSocketInformation> operator->() { return get(); }
		} Information;
		struct : property {
			ptr<Storage::Streams::IInputStream> get() { Storage::Streams::IInputStream* value; hrcheck(enc(&IStreamSocket_adaptor::InputStream)->_get_InputStream(&value)); return from_abi(value); }
			ptr<Storage::Streams::IInputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IInputStream> () { return get(); }
			ptr<Storage::Streams::IInputStream> operator->() { return get(); }
		} InputStream;
		struct : property {
			ptr<Storage::Streams::IOutputStream> get() { Storage::Streams::IOutputStream* value; hrcheck(enc(&IStreamSocket_adaptor::OutputStream)->_get_OutputStream(&value)); return from_abi(value); }
			ptr<Storage::Streams::IOutputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IOutputStream> () { return get(); }
			ptr<Storage::Streams::IOutputStream> operator->() { return get(); }
		} OutputStream;
	};
	ptr<Foundation::IAsyncAction> ConnectAsync(pptr<EndpointPair> endpointPair) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_ConnectWithEndpointPairAsync(endpointPair, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> ConnectAsync(pptr<HostName> remoteHostName, hstring_ref remoteServiceName) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_ConnectAsync(remoteHostName, remoteServiceName, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> ConnectAsync(pptr<EndpointPair> endpointPair, SocketProtectionLevel protectionLevel) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_ConnectWithEndpointPairAndProtectionLevelAsync(endpointPair, protectionLevel, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> ConnectAsync(pptr<HostName> remoteHostName, hstring_ref remoteServiceName, SocketProtectionLevel protectionLevel) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_ConnectWithProtectionLevelAsync(remoteHostName, remoteServiceName, protectionLevel, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> UpgradeToSslAsync(SocketProtectionLevel protectionLevel, pptr<HostName> validationHostName) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_UpgradeToSslAsync(protectionLevel, validationHostName, &operation)); return from_abi(operation); }
	IStreamSocket_adaptor() {}
};
template<typename X> struct adapt<IStreamSocket, X> : Windows::Networking::Sockets::IStreamSocket_adaptor<X> { typedef adapt IStreamSocket; };
struct IStreamSocket : IStreamSocket_raw, generate<IStreamSocket> {};

// StreamSocket
template<typename> struct StreamSocket_statics {
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<EndpointPair>>>>> GetEndpointPairsAsync(pptr<HostName> remoteHostName, hstring_ref remoteServiceName) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<EndpointPair*>*>* operation; hrcheck(get_activation_factory<StreamSocket, IStreamSocketStatics>()->_GetEndpointPairsAsync(remoteHostName, remoteServiceName, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<EndpointPair>>>>> GetEndpointPairsAsync(pptr<HostName> remoteHostName, hstring_ref remoteServiceName, HostNameSortOptions sortOptions) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<EndpointPair*>*>* operation; hrcheck(get_activation_factory<StreamSocket, IStreamSocketStatics>()->_GetEndpointPairsWithSortOptionsAsync(remoteHostName, remoteServiceName, sortOptions, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<StreamSocket, X> : X, Windows::Networking::Sockets::StreamSocket_statics<void> {
	typedef typename X::root_type StreamSocket;
};
struct StreamSocket : generate<StreamSocket> {
	using IStreamSocket3::TransferOwnership;
	using IStreamSocket2::ConnectAsync;
	using IStreamSocket::ConnectAsync;
	using IStreamSocket3::EnableTransferOwnership;
};

// IStreamSocketListener3
struct IStreamSocketListener3_raw : IInspectable {
	virtual STDMETHODIMP _CancelIOAsync(Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _EnableTransferOwnership(Platform::Guid taskId);
	virtual STDMETHODIMP _EnableTransferOwnershipWithConnectedStandbyAction(Platform::Guid taskId, SocketActivityConnectedStandbyAction connectedStandbyAction);
	virtual STDMETHODIMP _TransferOwnership(HSTRING socketId);
	virtual STDMETHODIMP _TransferOwnershipWithContext(HSTRING socketId, SocketActivityContext* data);
};
template<typename X> struct IStreamSocketListener3_adaptor : X {
	ptr<Foundation::IAsyncAction> CancelIOAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_CancelIOAsync(&operation)); return from_abi(operation); }
	void EnableTransferOwnership(const Platform::Guid& taskId) { hrcheck(X::get()->_EnableTransferOwnership(taskId)); }
	void EnableTransferOwnership(const Platform::Guid& taskId, SocketActivityConnectedStandbyAction connectedStandbyAction) { hrcheck(X::get()->_EnableTransferOwnershipWithConnectedStandbyAction(taskId, connectedStandbyAction)); }
	void TransferOwnership(hstring_ref socketId) { hrcheck(X::get()->_TransferOwnership(socketId)); }
	void TransferOwnership(hstring_ref socketId, pptr<SocketActivityContext> data) { hrcheck(X::get()->_TransferOwnershipWithContext(socketId, data)); }
};
template<typename X> struct adapt<IStreamSocketListener3, X> : Windows::Networking::Sockets::IStreamSocketListener3_adaptor<X> { typedef adapt IStreamSocketListener3; };
struct IStreamSocketListener3 : IStreamSocketListener3_raw, generate<IStreamSocketListener3> {};

// IStreamSocketListener2
struct IStreamSocketListener2_raw : IInspectable {
	virtual STDMETHODIMP _BindServiceNameWithProtectionLevelAsync(HSTRING localServiceName, SocketProtectionLevel protectionLevel, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _BindServiceNameWithProtectionLevelAndAdapterAsync(HSTRING localServiceName, SocketProtectionLevel protectionLevel, Connectivity::NetworkAdapter* adapter, Foundation::IAsyncAction* *operation);
};
template<typename X> struct IStreamSocketListener2_adaptor : X {
	ptr<Foundation::IAsyncAction> BindServiceNameAsync(hstring_ref localServiceName, SocketProtectionLevel protectionLevel) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_BindServiceNameWithProtectionLevelAsync(localServiceName, protectionLevel, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> BindServiceNameAsync(hstring_ref localServiceName, SocketProtectionLevel protectionLevel, pptr<Connectivity::NetworkAdapter> adapter) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_BindServiceNameWithProtectionLevelAndAdapterAsync(localServiceName, protectionLevel, adapter, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IStreamSocketListener2, X> : Windows::Networking::Sockets::IStreamSocketListener2_adaptor<X> { typedef adapt IStreamSocketListener2; };
struct IStreamSocketListener2 : IStreamSocketListener2_raw, generate<IStreamSocketListener2> {};

// IStreamSocketListener
struct IStreamSocketListener_raw : IInspectable {
	virtual STDMETHODIMP _get_Control(StreamSocketListenerControl* *value);
	virtual STDMETHODIMP _get_Information(StreamSocketListenerInformation* *value);
	virtual STDMETHODIMP _BindServiceNameAsync(HSTRING localServiceName, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _BindEndpointAsync(HostName* localHostName, HSTRING localServiceName, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _add_ConnectionReceived(Foundation::TypedEventHandler<StreamSocketListener*, StreamSocketListenerConnectionReceivedEventArgs*>* eventHandler, Foundation::EventRegistrationToken *eventCookie);
	virtual STDMETHODIMP _remove_ConnectionReceived(Foundation::EventRegistrationToken eventCookie);
};
template<typename X> struct IStreamSocketListener_adaptor : X {
	union {
		struct : property {
			ptr<StreamSocketListenerControl> get() { StreamSocketListenerControl* value; hrcheck(enc(&IStreamSocketListener_adaptor::Control)->_get_Control(&value)); return from_abi(value); }
			ptr<StreamSocketListenerControl> operator()() { return get(); }
			operator ptr<StreamSocketListenerControl> () { return get(); }
			ptr<StreamSocketListenerControl> operator->() { return get(); }
		} Control;
		struct : property {
			ptr<StreamSocketListenerInformation> get() { StreamSocketListenerInformation* value; hrcheck(enc(&IStreamSocketListener_adaptor::Information)->_get_Information(&value)); return from_abi(value); }
			ptr<StreamSocketListenerInformation> operator()() { return get(); }
			operator ptr<StreamSocketListenerInformation> () { return get(); }
			ptr<StreamSocketListenerInformation> operator->() { return get(); }
		} Information;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<StreamSocketListener>, ptr<StreamSocketListenerConnectionReceivedEventArgs>>> eventHandler) { Foundation::EventRegistrationToken eventCookie; hrcheck(enc(&IStreamSocketListener_adaptor::ConnectionReceived)->_add_ConnectionReceived(to_abi(eventHandler), &eventCookie)); return eventCookie; }
			void operator-=(const Foundation::EventRegistrationToken& eventCookie) { hrcheck(enc(&IStreamSocketListener_adaptor::ConnectionReceived)->_remove_ConnectionReceived(eventCookie)); }
		} ConnectionReceived;
	};
	ptr<Foundation::IAsyncAction> BindServiceNameAsync(hstring_ref localServiceName) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_BindServiceNameAsync(localServiceName, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> BindEndpointAsync(pptr<HostName> localHostName, hstring_ref localServiceName) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_BindEndpointAsync(localHostName, localServiceName, &operation)); return from_abi(operation); }
	IStreamSocketListener_adaptor() {}
};
template<typename X> struct adapt<IStreamSocketListener, X> : Windows::Networking::Sockets::IStreamSocketListener_adaptor<X> { typedef adapt IStreamSocketListener; };
struct IStreamSocketListener : IStreamSocketListener_raw, generate<IStreamSocketListener> {};

// StreamSocketListener
template<typename X> struct statics<StreamSocketListener, X> : X {
	typedef typename X::root_type StreamSocketListener;
};
struct StreamSocketListener : generate<StreamSocketListener> {
	using IStreamSocketListener3::TransferOwnership;
	using IStreamSocketListener2::BindServiceNameAsync;
	using IStreamSocketListener::BindServiceNameAsync;
	using IStreamSocketListener3::EnableTransferOwnership;
};

// ISocketActivityTriggerDetails
struct ISocketActivityTriggerDetails_raw : IInspectable {
	virtual STDMETHODIMP _get_Reason(SocketActivityTriggerReason *value);
	virtual STDMETHODIMP _get_SocketInformation(SocketActivityInformation* *value);
};
template<typename X> struct ISocketActivityTriggerDetails_adaptor : X {
	union {
		struct : property {
			SocketActivityTriggerReason get() { SocketActivityTriggerReason value; hrcheck(enc(&ISocketActivityTriggerDetails_adaptor::Reason)->_get_Reason(&value)); return value; }
			SocketActivityTriggerReason operator()() { return get(); }
			operator SocketActivityTriggerReason () { return get(); }
		} Reason;
		struct : property {
			ptr<SocketActivityInformation> get() { SocketActivityInformation* value; hrcheck(enc(&ISocketActivityTriggerDetails_adaptor::SocketInformation)->_get_SocketInformation(&value)); return from_abi(value); }
			ptr<SocketActivityInformation> operator()() { return get(); }
			operator ptr<SocketActivityInformation> () { return get(); }
			ptr<SocketActivityInformation> operator->() { return get(); }
		} SocketInformation;
	};
	ISocketActivityTriggerDetails_adaptor() {}
};
template<typename X> struct adapt<ISocketActivityTriggerDetails, X> : Windows::Networking::Sockets::ISocketActivityTriggerDetails_adaptor<X> { typedef adapt ISocketActivityTriggerDetails; };
struct ISocketActivityTriggerDetails : ISocketActivityTriggerDetails_raw, generate<ISocketActivityTriggerDetails> {};

// ISocketActivityInformationStatics
struct ISocketActivityInformationStatics : IInspectable {
	virtual STDMETHODIMP _get_AllSockets(Foundation::Collections::IMapView<HSTRING, SocketActivityInformation*>* *sockets);
};

// SocketActivityInformation
template<typename> struct SocketActivityInformation_statics {
	static struct _AllSockets : property {
		ptr<Foundation::Collections::IMapView<hstring, ptr<SocketActivityInformation>>> get() { Foundation::Collections::IMapView<HSTRING, SocketActivityInformation*>* sockets; hrcheck(get_activation_factory<SocketActivityInformation, ISocketActivityInformationStatics>()->_get_AllSockets(&sockets)); return from_abi(sockets); }
		ptr<Foundation::Collections::IMapView<hstring, ptr<SocketActivityInformation>>> operator()() { return get(); }
		operator ptr<Foundation::Collections::IMapView<hstring, ptr<SocketActivityInformation>>> () { return get(); }
		ptr<Foundation::Collections::IMapView<hstring, ptr<SocketActivityInformation>>> operator->() { return get(); }
	} AllSockets;
};
template<typename X> typename SocketActivityInformation_statics<X>::_AllSockets SocketActivityInformation_statics<X>::AllSockets;

template<typename X> struct statics<SocketActivityInformation, X> : X, Windows::Networking::Sockets::SocketActivityInformation_statics<void> {
	typedef typename X::root_type SocketActivityInformation;
};
struct SocketActivityInformation : generate<SocketActivityInformation> {};

// IDatagramSocketMessageReceivedEventArgs
struct IDatagramSocketMessageReceivedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_RemoteAddress(HostName* *value);
	virtual STDMETHODIMP _get_RemotePort(HSTRING *value);
	virtual STDMETHODIMP _get_LocalAddress(HostName* *value);
	virtual STDMETHODIMP _GetDataReader(Storage::Streams::DataReader* *dataReader);
	virtual STDMETHODIMP _GetDataStream(Storage::Streams::IInputStream* *inputStream);
};
template<typename X> struct IDatagramSocketMessageReceivedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<HostName> get() { HostName* value; hrcheck(enc(&IDatagramSocketMessageReceivedEventArgs_adaptor::LocalAddress)->_get_LocalAddress(&value)); return from_abi(value); }
			ptr<HostName> operator()() { return get(); }
			operator ptr<HostName> () { return get(); }
			ptr<HostName> operator->() { return get(); }
		} LocalAddress;
		struct : property {
			ptr<HostName> get() { HostName* value; hrcheck(enc(&IDatagramSocketMessageReceivedEventArgs_adaptor::RemoteAddress)->_get_RemoteAddress(&value)); return from_abi(value); }
			ptr<HostName> operator()() { return get(); }
			operator ptr<HostName> () { return get(); }
			ptr<HostName> operator->() { return get(); }
		} RemoteAddress;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDatagramSocketMessageReceivedEventArgs_adaptor::RemotePort)->_get_RemotePort(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} RemotePort;
	};
	ptr<Storage::Streams::DataReader> GetDataReader() { Storage::Streams::DataReader* dataReader; hrcheck(X::get()->_GetDataReader(&dataReader)); return from_abi(dataReader); }
	ptr<Storage::Streams::IInputStream> GetDataStream() { Storage::Streams::IInputStream* inputStream; hrcheck(X::get()->_GetDataStream(&inputStream)); return from_abi(inputStream); }
	IDatagramSocketMessageReceivedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IDatagramSocketMessageReceivedEventArgs, X> : Windows::Networking::Sockets::IDatagramSocketMessageReceivedEventArgs_adaptor<X> { typedef adapt IDatagramSocketMessageReceivedEventArgs; };
struct IDatagramSocketMessageReceivedEventArgs : IDatagramSocketMessageReceivedEventArgs_raw, generate<IDatagramSocketMessageReceivedEventArgs> {};

// IMessageWebSocketMessageReceivedEventArgs
struct IMessageWebSocketMessageReceivedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_MessageType(SocketMessageType *value);
	virtual STDMETHODIMP _GetDataReader(Storage::Streams::DataReader* *dataReader);
	virtual STDMETHODIMP _GetDataStream(Storage::Streams::IInputStream* *inputStream);
};
template<typename X> struct IMessageWebSocketMessageReceivedEventArgs_adaptor : X {
	union {
		struct : property {
			SocketMessageType get() { SocketMessageType value; hrcheck(enc(&IMessageWebSocketMessageReceivedEventArgs_adaptor::MessageType)->_get_MessageType(&value)); return value; }
			SocketMessageType operator()() { return get(); }
			operator SocketMessageType () { return get(); }
		} MessageType;
	};
	ptr<Storage::Streams::DataReader> GetDataReader() { Storage::Streams::DataReader* dataReader; hrcheck(X::get()->_GetDataReader(&dataReader)); return from_abi(dataReader); }
	ptr<Storage::Streams::IInputStream> GetDataStream() { Storage::Streams::IInputStream* inputStream; hrcheck(X::get()->_GetDataStream(&inputStream)); return from_abi(inputStream); }
	IMessageWebSocketMessageReceivedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IMessageWebSocketMessageReceivedEventArgs, X> : Windows::Networking::Sockets::IMessageWebSocketMessageReceivedEventArgs_adaptor<X> { typedef adapt IMessageWebSocketMessageReceivedEventArgs; };
struct IMessageWebSocketMessageReceivedEventArgs : IMessageWebSocketMessageReceivedEventArgs_raw, generate<IMessageWebSocketMessageReceivedEventArgs> {};

// IMessageWebSocketMessageReceivedEventArgs2
struct IMessageWebSocketMessageReceivedEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsMessageComplete(bool *value);
};
template<typename X> struct IMessageWebSocketMessageReceivedEventArgs2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IMessageWebSocketMessageReceivedEventArgs2_adaptor::IsMessageComplete)->_get_IsMessageComplete(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsMessageComplete;
	};
	IMessageWebSocketMessageReceivedEventArgs2_adaptor() {}
};
template<typename X> struct adapt<IMessageWebSocketMessageReceivedEventArgs2, X> : Windows::Networking::Sockets::IMessageWebSocketMessageReceivedEventArgs2_adaptor<X> { typedef adapt IMessageWebSocketMessageReceivedEventArgs2; };
struct IMessageWebSocketMessageReceivedEventArgs2 : IMessageWebSocketMessageReceivedEventArgs2_raw, generate<IMessageWebSocketMessageReceivedEventArgs2> {};

// IWebSocketClosedEventArgs
struct IWebSocketClosedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Code(unsigned short *value);
	virtual STDMETHODIMP _get_Reason(HSTRING *value);
};
template<typename X> struct IWebSocketClosedEventArgs_adaptor : X {
	union {
		struct : property {
			unsigned short get() { unsigned short value; hrcheck(enc(&IWebSocketClosedEventArgs_adaptor::Code)->_get_Code(&value)); return value; }
			unsigned short operator()() { return get(); }
			operator unsigned short () { return get(); }
		} Code;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IWebSocketClosedEventArgs_adaptor::Reason)->_get_Reason(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Reason;
	};
	IWebSocketClosedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IWebSocketClosedEventArgs, X> : Windows::Networking::Sockets::IWebSocketClosedEventArgs_adaptor<X> { typedef adapt IWebSocketClosedEventArgs; };
struct IWebSocketClosedEventArgs : IWebSocketClosedEventArgs_raw, generate<IWebSocketClosedEventArgs> {};

// IDatagramSocketInformation
struct IDatagramSocketInformation_raw : IInspectable {
	virtual STDMETHODIMP _get_LocalAddress(HostName* *value);
	virtual STDMETHODIMP _get_LocalPort(HSTRING *value);
	virtual STDMETHODIMP _get_RemoteAddress(HostName* *value);
	virtual STDMETHODIMP _get_RemotePort(HSTRING *value);
};
template<typename X> struct IDatagramSocketInformation_adaptor : X {
	union {
		struct : property {
			ptr<HostName> get() { HostName* value; hrcheck(enc(&IDatagramSocketInformation_adaptor::LocalAddress)->_get_LocalAddress(&value)); return from_abi(value); }
			ptr<HostName> operator()() { return get(); }
			operator ptr<HostName> () { return get(); }
			ptr<HostName> operator->() { return get(); }
		} LocalAddress;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDatagramSocketInformation_adaptor::LocalPort)->_get_LocalPort(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} LocalPort;
		struct : property {
			ptr<HostName> get() { HostName* value; hrcheck(enc(&IDatagramSocketInformation_adaptor::RemoteAddress)->_get_RemoteAddress(&value)); return from_abi(value); }
			ptr<HostName> operator()() { return get(); }
			operator ptr<HostName> () { return get(); }
			ptr<HostName> operator->() { return get(); }
		} RemoteAddress;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IDatagramSocketInformation_adaptor::RemotePort)->_get_RemotePort(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} RemotePort;
	};
	IDatagramSocketInformation_adaptor() {}
};
template<typename X> struct adapt<IDatagramSocketInformation, X> : Windows::Networking::Sockets::IDatagramSocketInformation_adaptor<X> { typedef adapt IDatagramSocketInformation; };
struct IDatagramSocketInformation : IDatagramSocketInformation_raw, generate<IDatagramSocketInformation> {};

// IDatagramSocketControl
struct IDatagramSocketControl_raw : IInspectable {
	virtual STDMETHODIMP _get_QualityOfService(SocketQualityOfService *value);
	virtual STDMETHODIMP _put_QualityOfService(SocketQualityOfService value);
	virtual STDMETHODIMP _get_OutboundUnicastHopLimit(unsigned char *value);
	virtual STDMETHODIMP _put_OutboundUnicastHopLimit(unsigned char value);
};
template<typename X> struct IDatagramSocketControl_adaptor : X {
	union {
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IDatagramSocketControl_adaptor::OutboundUnicastHopLimit)->_get_OutboundUnicastHopLimit(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IDatagramSocketControl_adaptor::OutboundUnicastHopLimit)->_put_OutboundUnicastHopLimit(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} OutboundUnicastHopLimit;
		struct : property {
			SocketQualityOfService get() { SocketQualityOfService value; hrcheck(enc(&IDatagramSocketControl_adaptor::QualityOfService)->_get_QualityOfService(&value)); return value; }
			SocketQualityOfService operator()() { return get(); }
			operator SocketQualityOfService () { return get(); }
			void put(SocketQualityOfService value) { hrcheck(enc(&IDatagramSocketControl_adaptor::QualityOfService)->_put_QualityOfService(value)); }
			void operator=(SocketQualityOfService value) { put(value); }
			void operator()(SocketQualityOfService value) { put(value); }
		} QualityOfService;
	};
	IDatagramSocketControl_adaptor() {}
};
template<typename X> struct adapt<IDatagramSocketControl, X> : Windows::Networking::Sockets::IDatagramSocketControl_adaptor<X> { typedef adapt IDatagramSocketControl; };
struct IDatagramSocketControl : IDatagramSocketControl_raw, generate<IDatagramSocketControl> {};

// IDatagramSocketControl2
struct IDatagramSocketControl2_raw : IInspectable {
	virtual STDMETHODIMP _get_InboundBufferSizeInBytes(unsigned *value);
	virtual STDMETHODIMP _put_InboundBufferSizeInBytes(unsigned value);
	virtual STDMETHODIMP _get_DontFragment(bool *value);
	virtual STDMETHODIMP _put_DontFragment(bool value);
};
template<typename X> struct IDatagramSocketControl2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDatagramSocketControl2_adaptor::DontFragment)->_get_DontFragment(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDatagramSocketControl2_adaptor::DontFragment)->_put_DontFragment(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} DontFragment;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IDatagramSocketControl2_adaptor::InboundBufferSizeInBytes)->_get_InboundBufferSizeInBytes(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IDatagramSocketControl2_adaptor::InboundBufferSizeInBytes)->_put_InboundBufferSizeInBytes(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} InboundBufferSizeInBytes;
	};
	IDatagramSocketControl2_adaptor() {}
};
template<typename X> struct adapt<IDatagramSocketControl2, X> : Windows::Networking::Sockets::IDatagramSocketControl2_adaptor<X> { typedef adapt IDatagramSocketControl2; };
struct IDatagramSocketControl2 : IDatagramSocketControl2_raw, generate<IDatagramSocketControl2> {};

// IDatagramSocketControl3
struct IDatagramSocketControl3_raw : IInspectable {
	virtual STDMETHODIMP _get_MulticastOnly(bool *value);
	virtual STDMETHODIMP _put_MulticastOnly(bool value);
};
template<typename X> struct IDatagramSocketControl3_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDatagramSocketControl3_adaptor::MulticastOnly)->_get_MulticastOnly(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDatagramSocketControl3_adaptor::MulticastOnly)->_put_MulticastOnly(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} MulticastOnly;
	};
	IDatagramSocketControl3_adaptor() {}
};
template<typename X> struct adapt<IDatagramSocketControl3, X> : Windows::Networking::Sockets::IDatagramSocketControl3_adaptor<X> { typedef adapt IDatagramSocketControl3; };
struct IDatagramSocketControl3 : IDatagramSocketControl3_raw, generate<IDatagramSocketControl3> {};

// DatagramSocketControl
template<typename X> struct statics<DatagramSocketControl, X> : X {
	typedef typename X::root_type DatagramSocketControl;
};
struct DatagramSocketControl : generate<DatagramSocketControl> {};

// DatagramSocketInformation
template<typename X> struct statics<DatagramSocketInformation, X> : X {
	typedef typename X::root_type DatagramSocketInformation;
};
struct DatagramSocketInformation : generate<DatagramSocketInformation> {};

// DatagramSocketMessageReceivedEventArgs
template<typename X> struct statics<DatagramSocketMessageReceivedEventArgs, X> : X {
	typedef typename X::root_type DatagramSocketMessageReceivedEventArgs;
};
struct DatagramSocketMessageReceivedEventArgs : generate<DatagramSocketMessageReceivedEventArgs> {};

// IStreamSocketInformation
struct IStreamSocketInformation_raw : IInspectable {
	virtual STDMETHODIMP _get_LocalAddress(HostName* *value);
	virtual STDMETHODIMP _get_LocalPort(HSTRING *value);
	virtual STDMETHODIMP _get_RemoteHostName(HostName* *value);
	virtual STDMETHODIMP _get_RemoteAddress(HostName* *value);
	virtual STDMETHODIMP _get_RemoteServiceName(HSTRING *value);
	virtual STDMETHODIMP _get_RemotePort(HSTRING *value);
	virtual STDMETHODIMP _get_RoundTripTimeStatistics(Sockets::RoundTripTimeStatistics *value);
	virtual STDMETHODIMP _get_BandwidthStatistics(Sockets::BandwidthStatistics *value);
	virtual STDMETHODIMP _get_ProtectionLevel(SocketProtectionLevel *value);
	virtual STDMETHODIMP _get_SessionKey(Storage::Streams::IBuffer* *value);
};
template<typename X> struct IStreamSocketInformation_adaptor : X {
	union {
		struct : property {
			Sockets::BandwidthStatistics get() { Sockets::BandwidthStatistics value; hrcheck(enc(&IStreamSocketInformation_adaptor::BandwidthStatistics)->_get_BandwidthStatistics(&value)); return value; }
			Sockets::BandwidthStatistics operator()() { return get(); }
			operator Sockets::BandwidthStatistics () { return get(); }
		} BandwidthStatistics;
		struct : property {
			ptr<HostName> get() { HostName* value; hrcheck(enc(&IStreamSocketInformation_adaptor::LocalAddress)->_get_LocalAddress(&value)); return from_abi(value); }
			ptr<HostName> operator()() { return get(); }
			operator ptr<HostName> () { return get(); }
			ptr<HostName> operator->() { return get(); }
		} LocalAddress;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStreamSocketInformation_adaptor::LocalPort)->_get_LocalPort(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} LocalPort;
		struct : property {
			SocketProtectionLevel get() { SocketProtectionLevel value; hrcheck(enc(&IStreamSocketInformation_adaptor::ProtectionLevel)->_get_ProtectionLevel(&value)); return value; }
			SocketProtectionLevel operator()() { return get(); }
			operator SocketProtectionLevel () { return get(); }
		} ProtectionLevel;
		struct : property {
			ptr<HostName> get() { HostName* value; hrcheck(enc(&IStreamSocketInformation_adaptor::RemoteAddress)->_get_RemoteAddress(&value)); return from_abi(value); }
			ptr<HostName> operator()() { return get(); }
			operator ptr<HostName> () { return get(); }
			ptr<HostName> operator->() { return get(); }
		} RemoteAddress;
		struct : property {
			ptr<HostName> get() { HostName* value; hrcheck(enc(&IStreamSocketInformation_adaptor::RemoteHostName)->_get_RemoteHostName(&value)); return from_abi(value); }
			ptr<HostName> operator()() { return get(); }
			operator ptr<HostName> () { return get(); }
			ptr<HostName> operator->() { return get(); }
		} RemoteHostName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStreamSocketInformation_adaptor::RemotePort)->_get_RemotePort(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} RemotePort;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStreamSocketInformation_adaptor::RemoteServiceName)->_get_RemoteServiceName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} RemoteServiceName;
		struct : property {
			Sockets::RoundTripTimeStatistics get() { Sockets::RoundTripTimeStatistics value; hrcheck(enc(&IStreamSocketInformation_adaptor::RoundTripTimeStatistics)->_get_RoundTripTimeStatistics(&value)); return value; }
			Sockets::RoundTripTimeStatistics operator()() { return get(); }
			operator Sockets::RoundTripTimeStatistics () { return get(); }
		} RoundTripTimeStatistics;
		struct : property {
			ptr<Storage::Streams::IBuffer> get() { Storage::Streams::IBuffer* value; hrcheck(enc(&IStreamSocketInformation_adaptor::SessionKey)->_get_SessionKey(&value)); return from_abi(value); }
			ptr<Storage::Streams::IBuffer> operator()() { return get(); }
			operator ptr<Storage::Streams::IBuffer> () { return get(); }
			ptr<Storage::Streams::IBuffer> operator->() { return get(); }
		} SessionKey;
	};
	IStreamSocketInformation_adaptor() {}
};
template<typename X> struct adapt<IStreamSocketInformation, X> : Windows::Networking::Sockets::IStreamSocketInformation_adaptor<X> { typedef adapt IStreamSocketInformation; };
struct IStreamSocketInformation : IStreamSocketInformation_raw, generate<IStreamSocketInformation> {};

// IStreamSocketInformation2
struct IStreamSocketInformation2_raw : IInspectable {
	virtual STDMETHODIMP _get_ServerCertificateErrorSeverity(SocketSslErrorSeverity *value);
	virtual STDMETHODIMP _get_ServerCertificateErrors(Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>* *value);
	virtual STDMETHODIMP _get_ServerCertificate(Security::Cryptography::Certificates::Certificate* *value);
	virtual STDMETHODIMP _get_ServerIntermediateCertificates(Foundation::Collections::IVectorView<Security::Cryptography::Certificates::Certificate*>* *value);
};
template<typename X> struct IStreamSocketInformation2_adaptor : X {
	union {
		struct : property {
			ptr<Security::Cryptography::Certificates::Certificate> get() { Security::Cryptography::Certificates::Certificate* value; hrcheck(enc(&IStreamSocketInformation2_adaptor::ServerCertificate)->_get_ServerCertificate(&value)); return from_abi(value); }
			ptr<Security::Cryptography::Certificates::Certificate> operator()() { return get(); }
			operator ptr<Security::Cryptography::Certificates::Certificate> () { return get(); }
			ptr<Security::Cryptography::Certificates::Certificate> operator->() { return get(); }
		} ServerCertificate;
		struct : property {
			SocketSslErrorSeverity get() { SocketSslErrorSeverity value; hrcheck(enc(&IStreamSocketInformation2_adaptor::ServerCertificateErrorSeverity)->_get_ServerCertificateErrorSeverity(&value)); return value; }
			SocketSslErrorSeverity operator()() { return get(); }
			operator SocketSslErrorSeverity () { return get(); }
		} ServerCertificateErrorSeverity;
		struct : property {
			ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> get() { Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>* value; hrcheck(enc(&IStreamSocketInformation2_adaptor::ServerCertificateErrors)->_get_ServerCertificateErrors(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> operator->() { return get(); }
		} ServerCertificateErrors;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> get() { Foundation::Collections::IVectorView<Security::Cryptography::Certificates::Certificate*>* value; hrcheck(enc(&IStreamSocketInformation2_adaptor::ServerIntermediateCertificates)->_get_ServerIntermediateCertificates(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> operator->() { return get(); }
		} ServerIntermediateCertificates;
	};
	IStreamSocketInformation2_adaptor() {}
};
template<typename X> struct adapt<IStreamSocketInformation2, X> : Windows::Networking::Sockets::IStreamSocketInformation2_adaptor<X> { typedef adapt IStreamSocketInformation2; };
struct IStreamSocketInformation2 : IStreamSocketInformation2_raw, generate<IStreamSocketInformation2> {};

// IStreamSocketControl
struct IStreamSocketControl_raw : IInspectable {
	virtual STDMETHODIMP _get_NoDelay(bool *value);
	virtual STDMETHODIMP _put_NoDelay(bool value);
	virtual STDMETHODIMP _get_KeepAlive(bool *value);
	virtual STDMETHODIMP _put_KeepAlive(bool value);
	virtual STDMETHODIMP _get_OutboundBufferSizeInBytes(unsigned *value);
	virtual STDMETHODIMP _put_OutboundBufferSizeInBytes(unsigned value);
	virtual STDMETHODIMP _get_QualityOfService(SocketQualityOfService *value);
	virtual STDMETHODIMP _put_QualityOfService(SocketQualityOfService value);
	virtual STDMETHODIMP _get_OutboundUnicastHopLimit(unsigned char *value);
	virtual STDMETHODIMP _put_OutboundUnicastHopLimit(unsigned char value);
};
template<typename X> struct IStreamSocketControl_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStreamSocketControl_adaptor::KeepAlive)->_get_KeepAlive(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IStreamSocketControl_adaptor::KeepAlive)->_put_KeepAlive(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} KeepAlive;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStreamSocketControl_adaptor::NoDelay)->_get_NoDelay(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IStreamSocketControl_adaptor::NoDelay)->_put_NoDelay(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} NoDelay;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IStreamSocketControl_adaptor::OutboundBufferSizeInBytes)->_get_OutboundBufferSizeInBytes(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IStreamSocketControl_adaptor::OutboundBufferSizeInBytes)->_put_OutboundBufferSizeInBytes(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} OutboundBufferSizeInBytes;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IStreamSocketControl_adaptor::OutboundUnicastHopLimit)->_get_OutboundUnicastHopLimit(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IStreamSocketControl_adaptor::OutboundUnicastHopLimit)->_put_OutboundUnicastHopLimit(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} OutboundUnicastHopLimit;
		struct : property {
			SocketQualityOfService get() { SocketQualityOfService value; hrcheck(enc(&IStreamSocketControl_adaptor::QualityOfService)->_get_QualityOfService(&value)); return value; }
			SocketQualityOfService operator()() { return get(); }
			operator SocketQualityOfService () { return get(); }
			void put(SocketQualityOfService value) { hrcheck(enc(&IStreamSocketControl_adaptor::QualityOfService)->_put_QualityOfService(value)); }
			void operator=(SocketQualityOfService value) { put(value); }
			void operator()(SocketQualityOfService value) { put(value); }
		} QualityOfService;
	};
	IStreamSocketControl_adaptor() {}
};
template<typename X> struct adapt<IStreamSocketControl, X> : Windows::Networking::Sockets::IStreamSocketControl_adaptor<X> { typedef adapt IStreamSocketControl; };
struct IStreamSocketControl : IStreamSocketControl_raw, generate<IStreamSocketControl> {};

// IStreamSocketControl2
struct IStreamSocketControl2_raw : IInspectable {
	virtual STDMETHODIMP _get_IgnorableServerCertificateErrors(Foundation::Collections::IVector<Security::Cryptography::Certificates::ChainValidationResult>* *value);
};
template<typename X> struct IStreamSocketControl2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<Security::Cryptography::Certificates::ChainValidationResult>> get() { Foundation::Collections::IVector<Security::Cryptography::Certificates::ChainValidationResult>* value; hrcheck(enc(&IStreamSocketControl2_adaptor::IgnorableServerCertificateErrors)->_get_IgnorableServerCertificateErrors(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<Security::Cryptography::Certificates::ChainValidationResult>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<Security::Cryptography::Certificates::ChainValidationResult>> () { return get(); }
			ptr<Foundation::Collections::IVector<Security::Cryptography::Certificates::ChainValidationResult>> operator->() { return get(); }
		} IgnorableServerCertificateErrors;
	};
	IStreamSocketControl2_adaptor() {}
};
template<typename X> struct adapt<IStreamSocketControl2, X> : Windows::Networking::Sockets::IStreamSocketControl2_adaptor<X> { typedef adapt IStreamSocketControl2; };
struct IStreamSocketControl2 : IStreamSocketControl2_raw, generate<IStreamSocketControl2> {};

// IStreamSocketControl3
struct IStreamSocketControl3_raw : IInspectable {
	virtual STDMETHODIMP _get_SerializeConnectionAttempts(bool *value);
	virtual STDMETHODIMP _put_SerializeConnectionAttempts(bool value);
	virtual STDMETHODIMP _get_ClientCertificate(Security::Cryptography::Certificates::Certificate* *value);
	virtual STDMETHODIMP _put_ClientCertificate(Security::Cryptography::Certificates::Certificate* value);
};
template<typename X> struct IStreamSocketControl3_adaptor : X {
	union {
		struct : property {
			ptr<Security::Cryptography::Certificates::Certificate> get() { Security::Cryptography::Certificates::Certificate* value; hrcheck(enc(&IStreamSocketControl3_adaptor::ClientCertificate)->_get_ClientCertificate(&value)); return from_abi(value); }
			ptr<Security::Cryptography::Certificates::Certificate> operator()() { return get(); }
			operator ptr<Security::Cryptography::Certificates::Certificate> () { return get(); }
			ptr<Security::Cryptography::Certificates::Certificate> operator->() { return get(); }
			void put(pptr<Security::Cryptography::Certificates::Certificate> value) { hrcheck(enc(&IStreamSocketControl3_adaptor::ClientCertificate)->_put_ClientCertificate(value)); }
			void operator=(pptr<Security::Cryptography::Certificates::Certificate> value) { put(value); }
			void operator()(pptr<Security::Cryptography::Certificates::Certificate> value) { put(value); }
		} ClientCertificate;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStreamSocketControl3_adaptor::SerializeConnectionAttempts)->_get_SerializeConnectionAttempts(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IStreamSocketControl3_adaptor::SerializeConnectionAttempts)->_put_SerializeConnectionAttempts(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} SerializeConnectionAttempts;
	};
	IStreamSocketControl3_adaptor() {}
};
template<typename X> struct adapt<IStreamSocketControl3, X> : Windows::Networking::Sockets::IStreamSocketControl3_adaptor<X> { typedef adapt IStreamSocketControl3; };
struct IStreamSocketControl3 : IStreamSocketControl3_raw, generate<IStreamSocketControl3> {};

// IStreamSocketControl4
struct IStreamSocketControl4_raw : IInspectable {
	virtual STDMETHODIMP _get_MinProtectionLevel(SocketProtectionLevel *value);
	virtual STDMETHODIMP _put_MinProtectionLevel(SocketProtectionLevel value);
};
template<typename X> struct IStreamSocketControl4_adaptor : X {
	union {
		struct : property {
			SocketProtectionLevel get() { SocketProtectionLevel value; hrcheck(enc(&IStreamSocketControl4_adaptor::MinProtectionLevel)->_get_MinProtectionLevel(&value)); return value; }
			SocketProtectionLevel operator()() { return get(); }
			operator SocketProtectionLevel () { return get(); }
			void put(SocketProtectionLevel value) { hrcheck(enc(&IStreamSocketControl4_adaptor::MinProtectionLevel)->_put_MinProtectionLevel(value)); }
			void operator=(SocketProtectionLevel value) { put(value); }
			void operator()(SocketProtectionLevel value) { put(value); }
		} MinProtectionLevel;
	};
	IStreamSocketControl4_adaptor() {}
};
template<typename X> struct adapt<IStreamSocketControl4, X> : Windows::Networking::Sockets::IStreamSocketControl4_adaptor<X> { typedef adapt IStreamSocketControl4; };
struct IStreamSocketControl4 : IStreamSocketControl4_raw, generate<IStreamSocketControl4> {};

// StreamSocketControl
template<typename X> struct statics<StreamSocketControl, X> : X {
	typedef typename X::root_type StreamSocketControl;
};
struct StreamSocketControl : generate<StreamSocketControl> {};

// StreamSocketInformation
template<typename X> struct statics<StreamSocketInformation, X> : X {
	typedef typename X::root_type StreamSocketInformation;
};
struct StreamSocketInformation : generate<StreamSocketInformation> {};

// IStreamSocketListenerControl
struct IStreamSocketListenerControl_raw : IInspectable {
	virtual STDMETHODIMP _get_QualityOfService(SocketQualityOfService *value);
	virtual STDMETHODIMP _put_QualityOfService(SocketQualityOfService value);
};
template<typename X> struct IStreamSocketListenerControl_adaptor : X {
	union {
		struct : property {
			SocketQualityOfService get() { SocketQualityOfService value; hrcheck(enc(&IStreamSocketListenerControl_adaptor::QualityOfService)->_get_QualityOfService(&value)); return value; }
			SocketQualityOfService operator()() { return get(); }
			operator SocketQualityOfService () { return get(); }
			void put(SocketQualityOfService value) { hrcheck(enc(&IStreamSocketListenerControl_adaptor::QualityOfService)->_put_QualityOfService(value)); }
			void operator=(SocketQualityOfService value) { put(value); }
			void operator()(SocketQualityOfService value) { put(value); }
		} QualityOfService;
	};
	IStreamSocketListenerControl_adaptor() {}
};
template<typename X> struct adapt<IStreamSocketListenerControl, X> : Windows::Networking::Sockets::IStreamSocketListenerControl_adaptor<X> { typedef adapt IStreamSocketListenerControl; };
struct IStreamSocketListenerControl : IStreamSocketListenerControl_raw, generate<IStreamSocketListenerControl> {};

// IStreamSocketListenerControl2
struct IStreamSocketListenerControl2_raw : IInspectable {
	virtual STDMETHODIMP _get_NoDelay(bool *value);
	virtual STDMETHODIMP _put_NoDelay(bool value);
	virtual STDMETHODIMP _get_KeepAlive(bool *value);
	virtual STDMETHODIMP _put_KeepAlive(bool value);
	virtual STDMETHODIMP _get_OutboundBufferSizeInBytes(unsigned *value);
	virtual STDMETHODIMP _put_OutboundBufferSizeInBytes(unsigned value);
	virtual STDMETHODIMP _get_OutboundUnicastHopLimit(unsigned char *value);
	virtual STDMETHODIMP _put_OutboundUnicastHopLimit(unsigned char value);
};
template<typename X> struct IStreamSocketListenerControl2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStreamSocketListenerControl2_adaptor::KeepAlive)->_get_KeepAlive(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IStreamSocketListenerControl2_adaptor::KeepAlive)->_put_KeepAlive(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} KeepAlive;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStreamSocketListenerControl2_adaptor::NoDelay)->_get_NoDelay(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IStreamSocketListenerControl2_adaptor::NoDelay)->_put_NoDelay(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} NoDelay;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IStreamSocketListenerControl2_adaptor::OutboundBufferSizeInBytes)->_get_OutboundBufferSizeInBytes(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IStreamSocketListenerControl2_adaptor::OutboundBufferSizeInBytes)->_put_OutboundBufferSizeInBytes(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} OutboundBufferSizeInBytes;
		struct : property {
			unsigned char get() { unsigned char value; hrcheck(enc(&IStreamSocketListenerControl2_adaptor::OutboundUnicastHopLimit)->_get_OutboundUnicastHopLimit(&value)); return value; }
			unsigned char operator()() { return get(); }
			operator unsigned char () { return get(); }
			void put(unsigned char value) { hrcheck(enc(&IStreamSocketListenerControl2_adaptor::OutboundUnicastHopLimit)->_put_OutboundUnicastHopLimit(value)); }
			void operator=(unsigned char value) { put(value); }
			void operator()(unsigned char value) { put(value); }
		} OutboundUnicastHopLimit;
	};
	IStreamSocketListenerControl2_adaptor() {}
};
template<typename X> struct adapt<IStreamSocketListenerControl2, X> : Windows::Networking::Sockets::IStreamSocketListenerControl2_adaptor<X> { typedef adapt IStreamSocketListenerControl2; };
struct IStreamSocketListenerControl2 : IStreamSocketListenerControl2_raw, generate<IStreamSocketListenerControl2> {};

// IStreamSocketListenerInformation
struct IStreamSocketListenerInformation_raw : IInspectable {
	virtual STDMETHODIMP _get_LocalPort(HSTRING *value);
};
template<typename X> struct IStreamSocketListenerInformation_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStreamSocketListenerInformation_adaptor::LocalPort)->_get_LocalPort(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} LocalPort;
	};
	IStreamSocketListenerInformation_adaptor() {}
};
template<typename X> struct adapt<IStreamSocketListenerInformation, X> : Windows::Networking::Sockets::IStreamSocketListenerInformation_adaptor<X> { typedef adapt IStreamSocketListenerInformation; };
struct IStreamSocketListenerInformation : IStreamSocketListenerInformation_raw, generate<IStreamSocketListenerInformation> {};

// IStreamSocketListenerConnectionReceivedEventArgs
struct IStreamSocketListenerConnectionReceivedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Socket(StreamSocket* *value);
};
template<typename X> struct IStreamSocketListenerConnectionReceivedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<StreamSocket> get() { StreamSocket* value; hrcheck(enc(&IStreamSocketListenerConnectionReceivedEventArgs_adaptor::Socket)->_get_Socket(&value)); return from_abi(value); }
			ptr<StreamSocket> operator()() { return get(); }
			operator ptr<StreamSocket> () { return get(); }
			ptr<StreamSocket> operator->() { return get(); }
		} Socket;
	};
	IStreamSocketListenerConnectionReceivedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IStreamSocketListenerConnectionReceivedEventArgs, X> : Windows::Networking::Sockets::IStreamSocketListenerConnectionReceivedEventArgs_adaptor<X> { typedef adapt IStreamSocketListenerConnectionReceivedEventArgs; };
struct IStreamSocketListenerConnectionReceivedEventArgs : IStreamSocketListenerConnectionReceivedEventArgs_raw, generate<IStreamSocketListenerConnectionReceivedEventArgs> {};

// StreamSocketListenerControl
template<typename X> struct statics<StreamSocketListenerControl, X> : X {
	typedef typename X::root_type StreamSocketListenerControl;
};
struct StreamSocketListenerControl : generate<StreamSocketListenerControl> {};

// StreamSocketListenerInformation
template<typename X> struct statics<StreamSocketListenerInformation, X> : X {
	typedef typename X::root_type StreamSocketListenerInformation;
};
struct StreamSocketListenerInformation : generate<StreamSocketListenerInformation> {};

// StreamSocketListenerConnectionReceivedEventArgs
template<typename X> struct statics<StreamSocketListenerConnectionReceivedEventArgs, X> : X {
	typedef typename X::root_type StreamSocketListenerConnectionReceivedEventArgs;
};
struct StreamSocketListenerConnectionReceivedEventArgs : generate<StreamSocketListenerConnectionReceivedEventArgs> {};

// IWebSocketServerCustomValidationRequestedEventArgs
struct IWebSocketServerCustomValidationRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_ServerCertificate(Security::Cryptography::Certificates::Certificate* *value);
	virtual STDMETHODIMP _get_ServerCertificateErrorSeverity(SocketSslErrorSeverity *value);
	virtual STDMETHODIMP _get_ServerCertificateErrors(Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>* *value);
	virtual STDMETHODIMP _get_ServerIntermediateCertificates(Foundation::Collections::IVectorView<Security::Cryptography::Certificates::Certificate*>* *value);
	virtual STDMETHODIMP _Reject();
	virtual STDMETHODIMP _GetDeferral(Foundation::Deferral* *result);
};
template<typename X> struct IWebSocketServerCustomValidationRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Security::Cryptography::Certificates::Certificate> get() { Security::Cryptography::Certificates::Certificate* value; hrcheck(enc(&IWebSocketServerCustomValidationRequestedEventArgs_adaptor::ServerCertificate)->_get_ServerCertificate(&value)); return from_abi(value); }
			ptr<Security::Cryptography::Certificates::Certificate> operator()() { return get(); }
			operator ptr<Security::Cryptography::Certificates::Certificate> () { return get(); }
			ptr<Security::Cryptography::Certificates::Certificate> operator->() { return get(); }
		} ServerCertificate;
		struct : property {
			SocketSslErrorSeverity get() { SocketSslErrorSeverity value; hrcheck(enc(&IWebSocketServerCustomValidationRequestedEventArgs_adaptor::ServerCertificateErrorSeverity)->_get_ServerCertificateErrorSeverity(&value)); return value; }
			SocketSslErrorSeverity operator()() { return get(); }
			operator SocketSslErrorSeverity () { return get(); }
		} ServerCertificateErrorSeverity;
		struct : property {
			ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> get() { Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>* value; hrcheck(enc(&IWebSocketServerCustomValidationRequestedEventArgs_adaptor::ServerCertificateErrors)->_get_ServerCertificateErrors(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> operator->() { return get(); }
		} ServerCertificateErrors;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> get() { Foundation::Collections::IVectorView<Security::Cryptography::Certificates::Certificate*>* value; hrcheck(enc(&IWebSocketServerCustomValidationRequestedEventArgs_adaptor::ServerIntermediateCertificates)->_get_ServerIntermediateCertificates(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> operator->() { return get(); }
		} ServerIntermediateCertificates;
	};
	void Reject() { hrcheck(X::get()->_Reject()); }
	ptr<Foundation::Deferral> GetDeferral() { Foundation::Deferral* result; hrcheck(X::get()->_GetDeferral(&result)); return from_abi(result); }
	IWebSocketServerCustomValidationRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IWebSocketServerCustomValidationRequestedEventArgs, X> : Windows::Networking::Sockets::IWebSocketServerCustomValidationRequestedEventArgs_adaptor<X> { typedef adapt IWebSocketServerCustomValidationRequestedEventArgs; };
struct IWebSocketServerCustomValidationRequestedEventArgs : IWebSocketServerCustomValidationRequestedEventArgs_raw, generate<IWebSocketServerCustomValidationRequestedEventArgs> {};

// IWebSocketControl
struct IWebSocketControl_raw : IInspectable {
	virtual STDMETHODIMP _get_OutboundBufferSizeInBytes(unsigned *value) = 0;
	virtual STDMETHODIMP _put_OutboundBufferSizeInBytes(unsigned value) = 0;
	virtual STDMETHODIMP _get_ServerCredential(Security::Credentials::PasswordCredential* *value) = 0;
	virtual STDMETHODIMP _put_ServerCredential(Security::Credentials::PasswordCredential* value) = 0;
	virtual STDMETHODIMP _get_ProxyCredential(Security::Credentials::PasswordCredential* *value) = 0;
	virtual STDMETHODIMP _put_ProxyCredential(Security::Credentials::PasswordCredential* value) = 0;
	virtual STDMETHODIMP _get_SupportedProtocols(Foundation::Collections::IVector<HSTRING>* *value) = 0;
};
template<typename X> struct IWebSocketControl_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IWebSocketControl_adaptor::OutboundBufferSizeInBytes)->_get_OutboundBufferSizeInBytes(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IWebSocketControl_adaptor::OutboundBufferSizeInBytes)->_put_OutboundBufferSizeInBytes(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} OutboundBufferSizeInBytes;
		struct : property {
			ptr<Security::Credentials::PasswordCredential> get() { Security::Credentials::PasswordCredential* value; hrcheck(enc(&IWebSocketControl_adaptor::ProxyCredential)->_get_ProxyCredential(&value)); return from_abi(value); }
			ptr<Security::Credentials::PasswordCredential> operator()() { return get(); }
			operator ptr<Security::Credentials::PasswordCredential> () { return get(); }
			ptr<Security::Credentials::PasswordCredential> operator->() { return get(); }
			void put(pptr<Security::Credentials::PasswordCredential> value) { hrcheck(enc(&IWebSocketControl_adaptor::ProxyCredential)->_put_ProxyCredential(value)); }
			void operator=(pptr<Security::Credentials::PasswordCredential> value) { put(value); }
			void operator()(pptr<Security::Credentials::PasswordCredential> value) { put(value); }
		} ProxyCredential;
		struct : property {
			ptr<Security::Credentials::PasswordCredential> get() { Security::Credentials::PasswordCredential* value; hrcheck(enc(&IWebSocketControl_adaptor::ServerCredential)->_get_ServerCredential(&value)); return from_abi(value); }
			ptr<Security::Credentials::PasswordCredential> operator()() { return get(); }
			operator ptr<Security::Credentials::PasswordCredential> () { return get(); }
			ptr<Security::Credentials::PasswordCredential> operator->() { return get(); }
			void put(pptr<Security::Credentials::PasswordCredential> value) { hrcheck(enc(&IWebSocketControl_adaptor::ServerCredential)->_put_ServerCredential(value)); }
			void operator=(pptr<Security::Credentials::PasswordCredential> value) { put(value); }
			void operator()(pptr<Security::Credentials::PasswordCredential> value) { put(value); }
		} ServerCredential;
		struct : property {
			ptr<Foundation::Collections::IVector<hstring>> get() { Foundation::Collections::IVector<HSTRING>* value; hrcheck(enc(&IWebSocketControl_adaptor::SupportedProtocols)->_get_SupportedProtocols(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVector<hstring>> operator->() { return get(); }
		} SupportedProtocols;
	};
	IWebSocketControl_adaptor() {}
};
template<typename X> struct adapt<IWebSocketControl, X> : Windows::Networking::Sockets::IWebSocketControl_adaptor<X> { typedef adapt IWebSocketControl; };
template<typename X> struct IWebSocketControl_unadaptor : X {
	STDMETHODIMP _get_OutboundBufferSizeInBytes(unsigned *value) { return hrtry([&, this] { get_prop(value, OutboundBufferSizeInBytes); }); }
	STDMETHODIMP _put_OutboundBufferSizeInBytes(unsigned value) { return hrtry([&, this] { put_prop(value, OutboundBufferSizeInBytes); }); }
	STDMETHODIMP _get_ServerCredential(Security::Credentials::PasswordCredential* *value) { return hrtry([&, this] { get_prop(value, ServerCredential); }); }
	STDMETHODIMP _put_ServerCredential(Security::Credentials::PasswordCredential* value) { return hrtry([&, this] { put_prop(value, ServerCredential); }); }
	STDMETHODIMP _get_ProxyCredential(Security::Credentials::PasswordCredential* *value) { return hrtry([&, this] { get_prop(value, ProxyCredential); }); }
	STDMETHODIMP _put_ProxyCredential(Security::Credentials::PasswordCredential* value) { return hrtry([&, this] { put_prop(value, ProxyCredential); }); }
	STDMETHODIMP _get_SupportedProtocols(Foundation::Collections::IVector<HSTRING>* *value) { return hrtry([&, this] { get_prop(value, SupportedProtocols); }); }
};
template<typename X> struct unadapt<IWebSocketControl, X> : Windows::Networking::Sockets::IWebSocketControl_unadaptor<X> {};
struct IWebSocketControl : IWebSocketControl_raw, generate<IWebSocketControl> {};

// IWebSocketControl2
struct IWebSocketControl2_raw : IInspectable {
	virtual STDMETHODIMP _get_IgnorableServerCertificateErrors(Foundation::Collections::IVector<Security::Cryptography::Certificates::ChainValidationResult>* *value) = 0;
};
template<typename X> struct IWebSocketControl2_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<Security::Cryptography::Certificates::ChainValidationResult>> get() { Foundation::Collections::IVector<Security::Cryptography::Certificates::ChainValidationResult>* value; hrcheck(enc(&IWebSocketControl2_adaptor::IgnorableServerCertificateErrors)->_get_IgnorableServerCertificateErrors(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<Security::Cryptography::Certificates::ChainValidationResult>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<Security::Cryptography::Certificates::ChainValidationResult>> () { return get(); }
			ptr<Foundation::Collections::IVector<Security::Cryptography::Certificates::ChainValidationResult>> operator->() { return get(); }
		} IgnorableServerCertificateErrors;
	};
	IWebSocketControl2_adaptor() {}
};
template<typename X> struct adapt<IWebSocketControl2, X> : Windows::Networking::Sockets::IWebSocketControl2_adaptor<X> { typedef adapt IWebSocketControl2; };
template<typename X> struct IWebSocketControl2_unadaptor : X {
	STDMETHODIMP _get_IgnorableServerCertificateErrors(Foundation::Collections::IVector<Security::Cryptography::Certificates::ChainValidationResult>* *value) { return hrtry([&, this] { get_prop(value, IgnorableServerCertificateErrors); }); }
};
template<typename X> struct unadapt<IWebSocketControl2, X> : Windows::Networking::Sockets::IWebSocketControl2_unadaptor<X> {};
struct IWebSocketControl2 : IWebSocketControl2_raw, generate<IWebSocketControl2> {};

// IWebSocketInformation
struct IWebSocketInformation_raw : IInspectable {
	virtual STDMETHODIMP _get_LocalAddress(HostName* *value) = 0;
	virtual STDMETHODIMP _get_BandwidthStatistics(Sockets::BandwidthStatistics *value) = 0;
	virtual STDMETHODIMP _get_Protocol(HSTRING *value) = 0;
};
template<typename X> struct IWebSocketInformation_adaptor : X {
	union {
		struct : property {
			Sockets::BandwidthStatistics get() { Sockets::BandwidthStatistics value; hrcheck(enc(&IWebSocketInformation_adaptor::BandwidthStatistics)->_get_BandwidthStatistics(&value)); return value; }
			Sockets::BandwidthStatistics operator()() { return get(); }
			operator Sockets::BandwidthStatistics () { return get(); }
		} BandwidthStatistics;
		struct : property {
			ptr<HostName> get() { HostName* value; hrcheck(enc(&IWebSocketInformation_adaptor::LocalAddress)->_get_LocalAddress(&value)); return from_abi(value); }
			ptr<HostName> operator()() { return get(); }
			operator ptr<HostName> () { return get(); }
			ptr<HostName> operator->() { return get(); }
		} LocalAddress;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IWebSocketInformation_adaptor::Protocol)->_get_Protocol(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Protocol;
	};
	IWebSocketInformation_adaptor() {}
};
template<typename X> struct adapt<IWebSocketInformation, X> : Windows::Networking::Sockets::IWebSocketInformation_adaptor<X> { typedef adapt IWebSocketInformation; };
template<typename X> struct IWebSocketInformation_unadaptor : X {
	STDMETHODIMP _get_LocalAddress(HostName* *value) { return hrtry([&, this] { get_prop(value, LocalAddress); }); }
	STDMETHODIMP _get_BandwidthStatistics(Sockets::BandwidthStatistics *value) { return hrtry([&, this] { get_prop(value, BandwidthStatistics); }); }
	STDMETHODIMP _get_Protocol(HSTRING *value) { return hrtry([&, this] { get_prop(value, Protocol); }); }
};
template<typename X> struct unadapt<IWebSocketInformation, X> : Windows::Networking::Sockets::IWebSocketInformation_unadaptor<X> {};
struct IWebSocketInformation : IWebSocketInformation_raw, generate<IWebSocketInformation> {};

// IWebSocketInformation2
struct IWebSocketInformation2_raw : IInspectable {
	virtual STDMETHODIMP _get_ServerCertificate(Security::Cryptography::Certificates::Certificate* *value) = 0;
	virtual STDMETHODIMP _get_ServerCertificateErrorSeverity(SocketSslErrorSeverity *value) = 0;
	virtual STDMETHODIMP _get_ServerCertificateErrors(Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>* *value) = 0;
	virtual STDMETHODIMP _get_ServerIntermediateCertificates(Foundation::Collections::IVectorView<Security::Cryptography::Certificates::Certificate*>* *value) = 0;
};
template<typename X> struct IWebSocketInformation2_adaptor : X {
	union {
		struct : property {
			ptr<Security::Cryptography::Certificates::Certificate> get() { Security::Cryptography::Certificates::Certificate* value; hrcheck(enc(&IWebSocketInformation2_adaptor::ServerCertificate)->_get_ServerCertificate(&value)); return from_abi(value); }
			ptr<Security::Cryptography::Certificates::Certificate> operator()() { return get(); }
			operator ptr<Security::Cryptography::Certificates::Certificate> () { return get(); }
			ptr<Security::Cryptography::Certificates::Certificate> operator->() { return get(); }
		} ServerCertificate;
		struct : property {
			SocketSslErrorSeverity get() { SocketSslErrorSeverity value; hrcheck(enc(&IWebSocketInformation2_adaptor::ServerCertificateErrorSeverity)->_get_ServerCertificateErrorSeverity(&value)); return value; }
			SocketSslErrorSeverity operator()() { return get(); }
			operator SocketSslErrorSeverity () { return get(); }
		} ServerCertificateErrorSeverity;
		struct : property {
			ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> get() { Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>* value; hrcheck(enc(&IWebSocketInformation2_adaptor::ServerCertificateErrors)->_get_ServerCertificateErrors(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>> operator->() { return get(); }
		} ServerCertificateErrors;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> get() { Foundation::Collections::IVectorView<Security::Cryptography::Certificates::Certificate*>* value; hrcheck(enc(&IWebSocketInformation2_adaptor::ServerIntermediateCertificates)->_get_ServerIntermediateCertificates(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Security::Cryptography::Certificates::Certificate>>> operator->() { return get(); }
		} ServerIntermediateCertificates;
	};
	IWebSocketInformation2_adaptor() {}
};
template<typename X> struct adapt<IWebSocketInformation2, X> : Windows::Networking::Sockets::IWebSocketInformation2_adaptor<X> { typedef adapt IWebSocketInformation2; };
template<typename X> struct IWebSocketInformation2_unadaptor : X {
	STDMETHODIMP _get_ServerCertificate(Security::Cryptography::Certificates::Certificate* *value) { return hrtry([&, this] { get_prop(value, ServerCertificate); }); }
	STDMETHODIMP _get_ServerCertificateErrorSeverity(SocketSslErrorSeverity *value) { return hrtry([&, this] { get_prop(value, ServerCertificateErrorSeverity); }); }
	STDMETHODIMP _get_ServerCertificateErrors(Foundation::Collections::IVectorView<Security::Cryptography::Certificates::ChainValidationResult>* *value) { return hrtry([&, this] { get_prop(value, ServerCertificateErrors); }); }
	STDMETHODIMP _get_ServerIntermediateCertificates(Foundation::Collections::IVectorView<Security::Cryptography::Certificates::Certificate*>* *value) { return hrtry([&, this] { get_prop(value, ServerIntermediateCertificates); }); }
};
template<typename X> struct unadapt<IWebSocketInformation2, X> : Windows::Networking::Sockets::IWebSocketInformation2_unadaptor<X> {};
struct IWebSocketInformation2 : IWebSocketInformation2_raw, generate<IWebSocketInformation2> {};

// IWebSocket
struct IWebSocket_raw : IInspectable {
	virtual STDMETHODIMP _get_OutputStream(Storage::Streams::IOutputStream* *value) = 0;
	virtual STDMETHODIMP _ConnectAsync(Foundation::Uri* uri, Foundation::IAsyncAction* *operation) = 0;
	virtual STDMETHODIMP _SetRequestHeader(HSTRING headerName, HSTRING headerValue) = 0;
	virtual STDMETHODIMP _add_Closed(Foundation::TypedEventHandler<IWebSocket*, WebSocketClosedEventArgs*>* eventHandler, Foundation::EventRegistrationToken *eventCookie) = 0;
	virtual STDMETHODIMP _remove_Closed(Foundation::EventRegistrationToken eventCookie) = 0;
	virtual STDMETHODIMP _CloseWithStatus(unsigned short code, HSTRING reason) = 0;
};
template<typename X> struct IWebSocket_adaptor : X {
	union {
		struct : property {
			ptr<Storage::Streams::IOutputStream> get() { Storage::Streams::IOutputStream* value; hrcheck(enc(&IWebSocket_adaptor::OutputStream)->_get_OutputStream(&value)); return from_abi(value); }
			ptr<Storage::Streams::IOutputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IOutputStream> () { return get(); }
			ptr<Storage::Streams::IOutputStream> operator->() { return get(); }
		} OutputStream;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<IWebSocket>, ptr<WebSocketClosedEventArgs>>> eventHandler) { Foundation::EventRegistrationToken eventCookie; hrcheck(enc(&IWebSocket_adaptor::Closed)->_add_Closed(to_abi(eventHandler), &eventCookie)); return eventCookie; }
			void operator-=(const Foundation::EventRegistrationToken& eventCookie) { hrcheck(enc(&IWebSocket_adaptor::Closed)->_remove_Closed(eventCookie)); }
		} Closed;
	};
	ptr<Foundation::IAsyncAction> ConnectAsync(pptr<Foundation::Uri> uri) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_ConnectAsync(uri, &operation)); return from_abi(operation); }
	void SetRequestHeader(hstring_ref headerName, hstring_ref headerValue) { hrcheck(X::get()->_SetRequestHeader(headerName, headerValue)); }
	void Close(unsigned short code, hstring_ref reason) { hrcheck(X::get()->_CloseWithStatus(code, reason)); }
	IWebSocket_adaptor() {}
};
template<typename X> struct adapt<IWebSocket, X> : Windows::Networking::Sockets::IWebSocket_adaptor<X> { typedef adapt IWebSocket; };
template<typename X> struct IWebSocket_unadaptor : X {
	STDMETHODIMP _get_OutputStream(Storage::Streams::IOutputStream* *value) { return hrtry([&, this] { get_prop(value, OutputStream); }); }
	STDMETHODIMP _ConnectAsync(Foundation::Uri* uri, Foundation::IAsyncAction* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->ConnectAsync(uri)); }); }
	STDMETHODIMP _SetRequestHeader(HSTRING headerName, HSTRING headerValue) { return hrtry([&, this] { X::get()->SetRequestHeader(headerName, headerValue); }); }
	STDMETHODIMP _add_Closed(Foundation::TypedEventHandler<IWebSocket*, WebSocketClosedEventArgs*>* eventHandler, Foundation::EventRegistrationToken *eventCookie) { return hrtry([&, this] { *eventCookie = X::get()->Closed+=eventHandler; }); }
	STDMETHODIMP _remove_Closed(Foundation::EventRegistrationToken eventCookie) { return hrtry([&, this] { X::get()->Closed-=eventCookie; }); }
	STDMETHODIMP _CloseWithStatus(unsigned short code, HSTRING reason) { return hrtry([&, this] { X::get()->Close(code, reason); }); }
};
template<typename X> struct unadapt<IWebSocket, X> : Windows::Networking::Sockets::IWebSocket_unadaptor<X> {};
struct IWebSocket : IWebSocket_raw, generate<IWebSocket> {};

// WebSocketClosedEventArgs
template<typename X> struct statics<WebSocketClosedEventArgs, X> : X {
	typedef typename X::root_type WebSocketClosedEventArgs;
};
struct WebSocketClosedEventArgs : generate<WebSocketClosedEventArgs> {};

// IMessageWebSocketControl
struct IMessageWebSocketControl_raw : IInspectable {
	virtual STDMETHODIMP _get_MaxMessageSize(unsigned *value);
	virtual STDMETHODIMP _put_MaxMessageSize(unsigned value);
	virtual STDMETHODIMP _get_MessageType(SocketMessageType *value);
	virtual STDMETHODIMP _put_MessageType(SocketMessageType value);
};
template<typename X> struct IMessageWebSocketControl_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IMessageWebSocketControl_adaptor::MaxMessageSize)->_get_MaxMessageSize(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IMessageWebSocketControl_adaptor::MaxMessageSize)->_put_MaxMessageSize(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} MaxMessageSize;
		struct : property {
			SocketMessageType get() { SocketMessageType value; hrcheck(enc(&IMessageWebSocketControl_adaptor::MessageType)->_get_MessageType(&value)); return value; }
			SocketMessageType operator()() { return get(); }
			operator SocketMessageType () { return get(); }
			void put(SocketMessageType value) { hrcheck(enc(&IMessageWebSocketControl_adaptor::MessageType)->_put_MessageType(value)); }
			void operator=(SocketMessageType value) { put(value); }
			void operator()(SocketMessageType value) { put(value); }
		} MessageType;
	};
	IMessageWebSocketControl_adaptor() {}
};
template<typename X> struct adapt<IMessageWebSocketControl, X> : Windows::Networking::Sockets::IMessageWebSocketControl_adaptor<X> { typedef adapt IMessageWebSocketControl; };
struct IMessageWebSocketControl : IMessageWebSocketControl_raw, generate<IMessageWebSocketControl> {};

// IMessageWebSocketControl2
struct IMessageWebSocketControl2_raw : IInspectable {
	virtual STDMETHODIMP _get_DesiredUnsolicitedPongInterval(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_DesiredUnsolicitedPongInterval(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_ActualUnsolicitedPongInterval(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_ReceiveMode(MessageWebSocketReceiveMode *value);
	virtual STDMETHODIMP _put_ReceiveMode(MessageWebSocketReceiveMode value);
	virtual STDMETHODIMP _get_ClientCertificate(Security::Cryptography::Certificates::Certificate* *value);
	virtual STDMETHODIMP _put_ClientCertificate(Security::Cryptography::Certificates::Certificate* value);
};
template<typename X> struct IMessageWebSocketControl2_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMessageWebSocketControl2_adaptor::ActualUnsolicitedPongInterval)->_get_ActualUnsolicitedPongInterval(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} ActualUnsolicitedPongInterval;
		struct : property {
			ptr<Security::Cryptography::Certificates::Certificate> get() { Security::Cryptography::Certificates::Certificate* value; hrcheck(enc(&IMessageWebSocketControl2_adaptor::ClientCertificate)->_get_ClientCertificate(&value)); return from_abi(value); }
			ptr<Security::Cryptography::Certificates::Certificate> operator()() { return get(); }
			operator ptr<Security::Cryptography::Certificates::Certificate> () { return get(); }
			ptr<Security::Cryptography::Certificates::Certificate> operator->() { return get(); }
			void put(pptr<Security::Cryptography::Certificates::Certificate> value) { hrcheck(enc(&IMessageWebSocketControl2_adaptor::ClientCertificate)->_put_ClientCertificate(value)); }
			void operator=(pptr<Security::Cryptography::Certificates::Certificate> value) { put(value); }
			void operator()(pptr<Security::Cryptography::Certificates::Certificate> value) { put(value); }
		} ClientCertificate;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IMessageWebSocketControl2_adaptor::DesiredUnsolicitedPongInterval)->_get_DesiredUnsolicitedPongInterval(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IMessageWebSocketControl2_adaptor::DesiredUnsolicitedPongInterval)->_put_DesiredUnsolicitedPongInterval(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} DesiredUnsolicitedPongInterval;
		struct : property {
			MessageWebSocketReceiveMode get() { MessageWebSocketReceiveMode value; hrcheck(enc(&IMessageWebSocketControl2_adaptor::ReceiveMode)->_get_ReceiveMode(&value)); return value; }
			MessageWebSocketReceiveMode operator()() { return get(); }
			operator MessageWebSocketReceiveMode () { return get(); }
			void put(MessageWebSocketReceiveMode value) { hrcheck(enc(&IMessageWebSocketControl2_adaptor::ReceiveMode)->_put_ReceiveMode(value)); }
			void operator=(MessageWebSocketReceiveMode value) { put(value); }
			void operator()(MessageWebSocketReceiveMode value) { put(value); }
		} ReceiveMode;
	};
	IMessageWebSocketControl2_adaptor() {}
};
template<typename X> struct adapt<IMessageWebSocketControl2, X> : Windows::Networking::Sockets::IMessageWebSocketControl2_adaptor<X> { typedef adapt IMessageWebSocketControl2; };
struct IMessageWebSocketControl2 : IMessageWebSocketControl2_raw, generate<IMessageWebSocketControl2> {};

// IMessageWebSocket
struct IMessageWebSocket_raw : IInspectable {
	virtual STDMETHODIMP _get_Control(MessageWebSocketControl* *value);
	virtual STDMETHODIMP _get_Information(MessageWebSocketInformation* *value);
	virtual STDMETHODIMP _add_MessageReceived(Foundation::TypedEventHandler<MessageWebSocket*, MessageWebSocketMessageReceivedEventArgs*>* eventHandler, Foundation::EventRegistrationToken *eventCookie);
	virtual STDMETHODIMP _remove_MessageReceived(Foundation::EventRegistrationToken eventCookie);
};
template<typename X> struct IMessageWebSocket_adaptor : X {
	union {
		struct : property {
			ptr<MessageWebSocketControl> get() { MessageWebSocketControl* value; hrcheck(enc(&IMessageWebSocket_adaptor::Control)->_get_Control(&value)); return from_abi(value); }
			ptr<MessageWebSocketControl> operator()() { return get(); }
			operator ptr<MessageWebSocketControl> () { return get(); }
			ptr<MessageWebSocketControl> operator->() { return get(); }
		} Control;
		struct : property {
			ptr<MessageWebSocketInformation> get() { MessageWebSocketInformation* value; hrcheck(enc(&IMessageWebSocket_adaptor::Information)->_get_Information(&value)); return from_abi(value); }
			ptr<MessageWebSocketInformation> operator()() { return get(); }
			operator ptr<MessageWebSocketInformation> () { return get(); }
			ptr<MessageWebSocketInformation> operator->() { return get(); }
		} Information;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MessageWebSocket>, ptr<MessageWebSocketMessageReceivedEventArgs>>> eventHandler) { Foundation::EventRegistrationToken eventCookie; hrcheck(enc(&IMessageWebSocket_adaptor::MessageReceived)->_add_MessageReceived(to_abi(eventHandler), &eventCookie)); return eventCookie; }
			void operator-=(const Foundation::EventRegistrationToken& eventCookie) { hrcheck(enc(&IMessageWebSocket_adaptor::MessageReceived)->_remove_MessageReceived(eventCookie)); }
		} MessageReceived;
	};
	IMessageWebSocket_adaptor() {}
};
template<typename X> struct adapt<IMessageWebSocket, X> : Windows::Networking::Sockets::IMessageWebSocket_adaptor<X> { typedef adapt IMessageWebSocket; };
struct IMessageWebSocket : IMessageWebSocket_raw, generate<IMessageWebSocket> {};

// MessageWebSocketControl
template<typename X> struct statics<MessageWebSocketControl, X> : X {
	typedef typename X::root_type MessageWebSocketControl;
};
struct MessageWebSocketControl : generate<MessageWebSocketControl> {};

// MessageWebSocketInformation
template<typename X> struct statics<MessageWebSocketInformation, X> : X {
	typedef typename X::root_type MessageWebSocketInformation;
};
struct MessageWebSocketInformation : generate<MessageWebSocketInformation> {};

// IMessageWebSocket3
struct IMessageWebSocket3_raw : IInspectable {
	virtual STDMETHODIMP _SendNonfinalFrameAsync(Storage::Streams::IBuffer* data, Foundation::IAsyncOperationWithProgress<unsigned, unsigned>* *operation);
	virtual STDMETHODIMP _SendFinalFrameAsync(Storage::Streams::IBuffer* data, Foundation::IAsyncOperationWithProgress<unsigned, unsigned>* *operation);
};
template<typename X> struct IMessageWebSocket3_adaptor : X {
	ptr<Foundation::IAsyncOperationWithProgress<unsigned, unsigned>> SendNonfinalFrameAsync(pptr<Storage::Streams::IBuffer> data) { Foundation::IAsyncOperationWithProgress<unsigned, unsigned>* operation; hrcheck(X::get()->_SendNonfinalFrameAsync(data, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<unsigned, unsigned>> SendFinalFrameAsync(pptr<Storage::Streams::IBuffer> data) { Foundation::IAsyncOperationWithProgress<unsigned, unsigned>* operation; hrcheck(X::get()->_SendFinalFrameAsync(data, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IMessageWebSocket3, X> : Windows::Networking::Sockets::IMessageWebSocket3_adaptor<X> { typedef adapt IMessageWebSocket3; };
struct IMessageWebSocket3 : IMessageWebSocket3_raw, generate<IMessageWebSocket3> {};

// IMessageWebSocket2
struct IMessageWebSocket2_raw : IInspectable {
	virtual STDMETHODIMP _add_ServerCustomValidationRequested(Foundation::TypedEventHandler<MessageWebSocket*, WebSocketServerCustomValidationRequestedEventArgs*>* eventHandler, Foundation::EventRegistrationToken *eventCookie);
	virtual STDMETHODIMP _remove_ServerCustomValidationRequested(Foundation::EventRegistrationToken eventCookie);
};
template<typename X> struct IMessageWebSocket2_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<MessageWebSocket>, ptr<WebSocketServerCustomValidationRequestedEventArgs>>> eventHandler) { Foundation::EventRegistrationToken eventCookie; hrcheck(enc(&IMessageWebSocket2_adaptor::ServerCustomValidationRequested)->_add_ServerCustomValidationRequested(to_abi(eventHandler), &eventCookie)); return eventCookie; }
			void operator-=(const Foundation::EventRegistrationToken& eventCookie) { hrcheck(enc(&IMessageWebSocket2_adaptor::ServerCustomValidationRequested)->_remove_ServerCustomValidationRequested(eventCookie)); }
		} ServerCustomValidationRequested;
	};
	IMessageWebSocket2_adaptor() {}
};
template<typename X> struct adapt<IMessageWebSocket2, X> : Windows::Networking::Sockets::IMessageWebSocket2_adaptor<X> { typedef adapt IMessageWebSocket2; };
struct IMessageWebSocket2 : IMessageWebSocket2_raw, generate<IMessageWebSocket2> {};

// MessageWebSocket
template<typename X> struct statics<MessageWebSocket, X> : X {
	typedef typename X::root_type MessageWebSocket;
};
struct MessageWebSocket : generate<MessageWebSocket> {
	using IWebSocket::Close;
	using IClosable::Close;
};

// MessageWebSocketMessageReceivedEventArgs
template<typename X> struct statics<MessageWebSocketMessageReceivedEventArgs, X> : X {
	typedef typename X::root_type MessageWebSocketMessageReceivedEventArgs;
};
struct MessageWebSocketMessageReceivedEventArgs : generate<MessageWebSocketMessageReceivedEventArgs> {};

// WebSocketServerCustomValidationRequestedEventArgs
template<typename X> struct statics<WebSocketServerCustomValidationRequestedEventArgs, X> : X {
	typedef typename X::root_type WebSocketServerCustomValidationRequestedEventArgs;
};
struct WebSocketServerCustomValidationRequestedEventArgs : generate<WebSocketServerCustomValidationRequestedEventArgs> {};

// IStreamWebSocketControl
struct IStreamWebSocketControl_raw : IInspectable {
	virtual STDMETHODIMP _get_NoDelay(bool *value);
	virtual STDMETHODIMP _put_NoDelay(bool value);
};
template<typename X> struct IStreamWebSocketControl_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStreamWebSocketControl_adaptor::NoDelay)->_get_NoDelay(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IStreamWebSocketControl_adaptor::NoDelay)->_put_NoDelay(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} NoDelay;
	};
	IStreamWebSocketControl_adaptor() {}
};
template<typename X> struct adapt<IStreamWebSocketControl, X> : Windows::Networking::Sockets::IStreamWebSocketControl_adaptor<X> { typedef adapt IStreamWebSocketControl; };
struct IStreamWebSocketControl : IStreamWebSocketControl_raw, generate<IStreamWebSocketControl> {};

// IStreamWebSocketControl2
struct IStreamWebSocketControl2_raw : IInspectable {
	virtual STDMETHODIMP _get_DesiredUnsolicitedPongInterval(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _put_DesiredUnsolicitedPongInterval(Foundation::TimeSpan value);
	virtual STDMETHODIMP _get_ActualUnsolicitedPongInterval(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_ClientCertificate(Security::Cryptography::Certificates::Certificate* *value);
	virtual STDMETHODIMP _put_ClientCertificate(Security::Cryptography::Certificates::Certificate* value);
};
template<typename X> struct IStreamWebSocketControl2_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IStreamWebSocketControl2_adaptor::ActualUnsolicitedPongInterval)->_get_ActualUnsolicitedPongInterval(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} ActualUnsolicitedPongInterval;
		struct : property {
			ptr<Security::Cryptography::Certificates::Certificate> get() { Security::Cryptography::Certificates::Certificate* value; hrcheck(enc(&IStreamWebSocketControl2_adaptor::ClientCertificate)->_get_ClientCertificate(&value)); return from_abi(value); }
			ptr<Security::Cryptography::Certificates::Certificate> operator()() { return get(); }
			operator ptr<Security::Cryptography::Certificates::Certificate> () { return get(); }
			ptr<Security::Cryptography::Certificates::Certificate> operator->() { return get(); }
			void put(pptr<Security::Cryptography::Certificates::Certificate> value) { hrcheck(enc(&IStreamWebSocketControl2_adaptor::ClientCertificate)->_put_ClientCertificate(value)); }
			void operator=(pptr<Security::Cryptography::Certificates::Certificate> value) { put(value); }
			void operator()(pptr<Security::Cryptography::Certificates::Certificate> value) { put(value); }
		} ClientCertificate;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IStreamWebSocketControl2_adaptor::DesiredUnsolicitedPongInterval)->_get_DesiredUnsolicitedPongInterval(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
			void put(const Foundation::TimeSpan& value) { hrcheck(enc(&IStreamWebSocketControl2_adaptor::DesiredUnsolicitedPongInterval)->_put_DesiredUnsolicitedPongInterval(value)); }
			void operator=(const Foundation::TimeSpan& value) { put(value); }
			void operator()(const Foundation::TimeSpan& value) { put(value); }
		} DesiredUnsolicitedPongInterval;
	};
	IStreamWebSocketControl2_adaptor() {}
};
template<typename X> struct adapt<IStreamWebSocketControl2, X> : Windows::Networking::Sockets::IStreamWebSocketControl2_adaptor<X> { typedef adapt IStreamWebSocketControl2; };
struct IStreamWebSocketControl2 : IStreamWebSocketControl2_raw, generate<IStreamWebSocketControl2> {};

// IStreamWebSocket
struct IStreamWebSocket_raw : IInspectable {
	virtual STDMETHODIMP _get_Control(StreamWebSocketControl* *value);
	virtual STDMETHODIMP _get_Information(StreamWebSocketInformation* *value);
	virtual STDMETHODIMP _get_InputStream(Storage::Streams::IInputStream* *value);
};
template<typename X> struct IStreamWebSocket_adaptor : X {
	union {
		struct : property {
			ptr<StreamWebSocketControl> get() { StreamWebSocketControl* value; hrcheck(enc(&IStreamWebSocket_adaptor::Control)->_get_Control(&value)); return from_abi(value); }
			ptr<StreamWebSocketControl> operator()() { return get(); }
			operator ptr<StreamWebSocketControl> () { return get(); }
			ptr<StreamWebSocketControl> operator->() { return get(); }
		} Control;
		struct : property {
			ptr<StreamWebSocketInformation> get() { StreamWebSocketInformation* value; hrcheck(enc(&IStreamWebSocket_adaptor::Information)->_get_Information(&value)); return from_abi(value); }
			ptr<StreamWebSocketInformation> operator()() { return get(); }
			operator ptr<StreamWebSocketInformation> () { return get(); }
			ptr<StreamWebSocketInformation> operator->() { return get(); }
		} Information;
		struct : property {
			ptr<Storage::Streams::IInputStream> get() { Storage::Streams::IInputStream* value; hrcheck(enc(&IStreamWebSocket_adaptor::InputStream)->_get_InputStream(&value)); return from_abi(value); }
			ptr<Storage::Streams::IInputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IInputStream> () { return get(); }
			ptr<Storage::Streams::IInputStream> operator->() { return get(); }
		} InputStream;
	};
	IStreamWebSocket_adaptor() {}
};
template<typename X> struct adapt<IStreamWebSocket, X> : Windows::Networking::Sockets::IStreamWebSocket_adaptor<X> { typedef adapt IStreamWebSocket; };
struct IStreamWebSocket : IStreamWebSocket_raw, generate<IStreamWebSocket> {};

// StreamWebSocketControl
template<typename X> struct statics<StreamWebSocketControl, X> : X {
	typedef typename X::root_type StreamWebSocketControl;
};
struct StreamWebSocketControl : generate<StreamWebSocketControl> {};

// StreamWebSocketInformation
template<typename X> struct statics<StreamWebSocketInformation, X> : X {
	typedef typename X::root_type StreamWebSocketInformation;
};
struct StreamWebSocketInformation : generate<StreamWebSocketInformation> {};

// IStreamWebSocket2
struct IStreamWebSocket2_raw : IInspectable {
	virtual STDMETHODIMP _add_ServerCustomValidationRequested(Foundation::TypedEventHandler<StreamWebSocket*, WebSocketServerCustomValidationRequestedEventArgs*>* eventHandler, Foundation::EventRegistrationToken *eventCookie);
	virtual STDMETHODIMP _remove_ServerCustomValidationRequested(Foundation::EventRegistrationToken eventCookie);
};
template<typename X> struct IStreamWebSocket2_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<StreamWebSocket>, ptr<WebSocketServerCustomValidationRequestedEventArgs>>> eventHandler) { Foundation::EventRegistrationToken eventCookie; hrcheck(enc(&IStreamWebSocket2_adaptor::ServerCustomValidationRequested)->_add_ServerCustomValidationRequested(to_abi(eventHandler), &eventCookie)); return eventCookie; }
			void operator-=(const Foundation::EventRegistrationToken& eventCookie) { hrcheck(enc(&IStreamWebSocket2_adaptor::ServerCustomValidationRequested)->_remove_ServerCustomValidationRequested(eventCookie)); }
		} ServerCustomValidationRequested;
	};
	IStreamWebSocket2_adaptor() {}
};
template<typename X> struct adapt<IStreamWebSocket2, X> : Windows::Networking::Sockets::IStreamWebSocket2_adaptor<X> { typedef adapt IStreamWebSocket2; };
struct IStreamWebSocket2 : IStreamWebSocket2_raw, generate<IStreamWebSocket2> {};

// StreamWebSocket
template<typename X> struct statics<StreamWebSocket, X> : X {
	typedef typename X::root_type StreamWebSocket;
};
struct StreamWebSocket : generate<StreamWebSocket> {
	using IWebSocket::Close;
	using IClosable::Close;
};

// ISocketErrorStatics
struct ISocketErrorStatics : IInspectable {
	virtual STDMETHODIMP _GetStatus(int hresult, SocketErrorStatus *status);
};

// IWebSocketErrorStatics
struct IWebSocketErrorStatics : IInspectable {
	virtual STDMETHODIMP _GetStatus(int hresult, Web::WebErrorStatus *status);
};

// IServerMessageWebSocket
struct IServerMessageWebSocket_raw : IInspectable {
	virtual STDMETHODIMP _add_MessageReceived(Foundation::TypedEventHandler<ServerMessageWebSocket*, MessageWebSocketMessageReceivedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_MessageReceived(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_Control(ServerMessageWebSocketControl* *value);
	virtual STDMETHODIMP _get_Information(ServerMessageWebSocketInformation* *value);
	virtual STDMETHODIMP _get_OutputStream(Storage::Streams::IOutputStream* *value);
	virtual STDMETHODIMP _add_Closed(Foundation::TypedEventHandler<ServerMessageWebSocket*, WebSocketClosedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Closed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _CloseWithStatus(unsigned short code, HSTRING reason);
};
template<typename X> struct IServerMessageWebSocket_adaptor : X {
	union {
		struct : property {
			ptr<ServerMessageWebSocketControl> get() { ServerMessageWebSocketControl* value; hrcheck(enc(&IServerMessageWebSocket_adaptor::Control)->_get_Control(&value)); return from_abi(value); }
			ptr<ServerMessageWebSocketControl> operator()() { return get(); }
			operator ptr<ServerMessageWebSocketControl> () { return get(); }
			ptr<ServerMessageWebSocketControl> operator->() { return get(); }
		} Control;
		struct : property {
			ptr<ServerMessageWebSocketInformation> get() { ServerMessageWebSocketInformation* value; hrcheck(enc(&IServerMessageWebSocket_adaptor::Information)->_get_Information(&value)); return from_abi(value); }
			ptr<ServerMessageWebSocketInformation> operator()() { return get(); }
			operator ptr<ServerMessageWebSocketInformation> () { return get(); }
			ptr<ServerMessageWebSocketInformation> operator->() { return get(); }
		} Information;
		struct : property {
			ptr<Storage::Streams::IOutputStream> get() { Storage::Streams::IOutputStream* value; hrcheck(enc(&IServerMessageWebSocket_adaptor::OutputStream)->_get_OutputStream(&value)); return from_abi(value); }
			ptr<Storage::Streams::IOutputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IOutputStream> () { return get(); }
			ptr<Storage::Streams::IOutputStream> operator->() { return get(); }
		} OutputStream;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ServerMessageWebSocket>, ptr<WebSocketClosedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IServerMessageWebSocket_adaptor::Closed)->_add_Closed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IServerMessageWebSocket_adaptor::Closed)->_remove_Closed(token)); }
		} Closed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ServerMessageWebSocket>, ptr<MessageWebSocketMessageReceivedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IServerMessageWebSocket_adaptor::MessageReceived)->_add_MessageReceived(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IServerMessageWebSocket_adaptor::MessageReceived)->_remove_MessageReceived(token)); }
		} MessageReceived;
	};
	void Close(unsigned short code, hstring_ref reason) { hrcheck(X::get()->_CloseWithStatus(code, reason)); }
	IServerMessageWebSocket_adaptor() {}
};
template<typename X> struct adapt<IServerMessageWebSocket, X> : Windows::Networking::Sockets::IServerMessageWebSocket_adaptor<X> { typedef adapt IServerMessageWebSocket; };
struct IServerMessageWebSocket : IServerMessageWebSocket_raw, generate<IServerMessageWebSocket> {};

// ServerMessageWebSocket
template<typename X> struct statics<ServerMessageWebSocket, X> : X {
	typedef typename X::root_type ServerMessageWebSocket;
};
struct ServerMessageWebSocket : generate<ServerMessageWebSocket> {
	using IClosable::Close;
	using IServerMessageWebSocket::Close;
};

// IServerMessageWebSocketControl
struct IServerMessageWebSocketControl_raw : IInspectable {
	virtual STDMETHODIMP _get_MessageType(SocketMessageType *value);
	virtual STDMETHODIMP _put_MessageType(SocketMessageType value);
};
template<typename X> struct IServerMessageWebSocketControl_adaptor : X {
	union {
		struct : property {
			SocketMessageType get() { SocketMessageType value; hrcheck(enc(&IServerMessageWebSocketControl_adaptor::MessageType)->_get_MessageType(&value)); return value; }
			SocketMessageType operator()() { return get(); }
			operator SocketMessageType () { return get(); }
			void put(SocketMessageType value) { hrcheck(enc(&IServerMessageWebSocketControl_adaptor::MessageType)->_put_MessageType(value)); }
			void operator=(SocketMessageType value) { put(value); }
			void operator()(SocketMessageType value) { put(value); }
		} MessageType;
	};
	IServerMessageWebSocketControl_adaptor() {}
};
template<typename X> struct adapt<IServerMessageWebSocketControl, X> : Windows::Networking::Sockets::IServerMessageWebSocketControl_adaptor<X> { typedef adapt IServerMessageWebSocketControl; };
struct IServerMessageWebSocketControl : IServerMessageWebSocketControl_raw, generate<IServerMessageWebSocketControl> {};

// ServerMessageWebSocketControl
template<typename X> struct statics<ServerMessageWebSocketControl, X> : X {
	typedef typename X::root_type ServerMessageWebSocketControl;
};
struct ServerMessageWebSocketControl : generate<ServerMessageWebSocketControl> {};

// IServerMessageWebSocketInformation
struct IServerMessageWebSocketInformation_raw : IInspectable {
	virtual STDMETHODIMP _get_BandwidthStatistics(Sockets::BandwidthStatistics *value);
	virtual STDMETHODIMP _get_Protocol(HSTRING *value);
	virtual STDMETHODIMP _get_LocalAddress(HostName* *value);
};
template<typename X> struct IServerMessageWebSocketInformation_adaptor : X {
	union {
		struct : property {
			Sockets::BandwidthStatistics get() { Sockets::BandwidthStatistics value; hrcheck(enc(&IServerMessageWebSocketInformation_adaptor::BandwidthStatistics)->_get_BandwidthStatistics(&value)); return value; }
			Sockets::BandwidthStatistics operator()() { return get(); }
			operator Sockets::BandwidthStatistics () { return get(); }
		} BandwidthStatistics;
		struct : property {
			ptr<HostName> get() { HostName* value; hrcheck(enc(&IServerMessageWebSocketInformation_adaptor::LocalAddress)->_get_LocalAddress(&value)); return from_abi(value); }
			ptr<HostName> operator()() { return get(); }
			operator ptr<HostName> () { return get(); }
			ptr<HostName> operator->() { return get(); }
		} LocalAddress;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IServerMessageWebSocketInformation_adaptor::Protocol)->_get_Protocol(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Protocol;
	};
	IServerMessageWebSocketInformation_adaptor() {}
};
template<typename X> struct adapt<IServerMessageWebSocketInformation, X> : Windows::Networking::Sockets::IServerMessageWebSocketInformation_adaptor<X> { typedef adapt IServerMessageWebSocketInformation; };
struct IServerMessageWebSocketInformation : IServerMessageWebSocketInformation_raw, generate<IServerMessageWebSocketInformation> {};

// ServerMessageWebSocketInformation
template<typename X> struct statics<ServerMessageWebSocketInformation, X> : X {
	typedef typename X::root_type ServerMessageWebSocketInformation;
};
struct ServerMessageWebSocketInformation : generate<ServerMessageWebSocketInformation> {};

// IServerStreamWebSocketInformation
struct IServerStreamWebSocketInformation_raw : IInspectable {
	virtual STDMETHODIMP _get_BandwidthStatistics(Sockets::BandwidthStatistics *value);
	virtual STDMETHODIMP _get_Protocol(HSTRING *value);
	virtual STDMETHODIMP _get_LocalAddress(HostName* *value);
};
template<typename X> struct IServerStreamWebSocketInformation_adaptor : X {
	union {
		struct : property {
			Sockets::BandwidthStatistics get() { Sockets::BandwidthStatistics value; hrcheck(enc(&IServerStreamWebSocketInformation_adaptor::BandwidthStatistics)->_get_BandwidthStatistics(&value)); return value; }
			Sockets::BandwidthStatistics operator()() { return get(); }
			operator Sockets::BandwidthStatistics () { return get(); }
		} BandwidthStatistics;
		struct : property {
			ptr<HostName> get() { HostName* value; hrcheck(enc(&IServerStreamWebSocketInformation_adaptor::LocalAddress)->_get_LocalAddress(&value)); return from_abi(value); }
			ptr<HostName> operator()() { return get(); }
			operator ptr<HostName> () { return get(); }
			ptr<HostName> operator->() { return get(); }
		} LocalAddress;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IServerStreamWebSocketInformation_adaptor::Protocol)->_get_Protocol(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Protocol;
	};
	IServerStreamWebSocketInformation_adaptor() {}
};
template<typename X> struct adapt<IServerStreamWebSocketInformation, X> : Windows::Networking::Sockets::IServerStreamWebSocketInformation_adaptor<X> { typedef adapt IServerStreamWebSocketInformation; };
struct IServerStreamWebSocketInformation : IServerStreamWebSocketInformation_raw, generate<IServerStreamWebSocketInformation> {};

// IServerStreamWebSocket
struct IServerStreamWebSocket_raw : IInspectable {
	virtual STDMETHODIMP _get_Information(ServerStreamWebSocketInformation* *value);
	virtual STDMETHODIMP _get_InputStream(Storage::Streams::IInputStream* *value);
	virtual STDMETHODIMP _get_OutputStream(Storage::Streams::IOutputStream* *value);
	virtual STDMETHODIMP _add_Closed(Foundation::TypedEventHandler<ServerStreamWebSocket*, WebSocketClosedEventArgs*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_Closed(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _CloseWithStatus(unsigned short code, HSTRING reason);
};
template<typename X> struct IServerStreamWebSocket_adaptor : X {
	union {
		struct : property {
			ptr<ServerStreamWebSocketInformation> get() { ServerStreamWebSocketInformation* value; hrcheck(enc(&IServerStreamWebSocket_adaptor::Information)->_get_Information(&value)); return from_abi(value); }
			ptr<ServerStreamWebSocketInformation> operator()() { return get(); }
			operator ptr<ServerStreamWebSocketInformation> () { return get(); }
			ptr<ServerStreamWebSocketInformation> operator->() { return get(); }
		} Information;
		struct : property {
			ptr<Storage::Streams::IInputStream> get() { Storage::Streams::IInputStream* value; hrcheck(enc(&IServerStreamWebSocket_adaptor::InputStream)->_get_InputStream(&value)); return from_abi(value); }
			ptr<Storage::Streams::IInputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IInputStream> () { return get(); }
			ptr<Storage::Streams::IInputStream> operator->() { return get(); }
		} InputStream;
		struct : property {
			ptr<Storage::Streams::IOutputStream> get() { Storage::Streams::IOutputStream* value; hrcheck(enc(&IServerStreamWebSocket_adaptor::OutputStream)->_get_OutputStream(&value)); return from_abi(value); }
			ptr<Storage::Streams::IOutputStream> operator()() { return get(); }
			operator ptr<Storage::Streams::IOutputStream> () { return get(); }
			ptr<Storage::Streams::IOutputStream> operator->() { return get(); }
		} OutputStream;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ServerStreamWebSocket>, ptr<WebSocketClosedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IServerStreamWebSocket_adaptor::Closed)->_add_Closed(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IServerStreamWebSocket_adaptor::Closed)->_remove_Closed(token)); }
		} Closed;
	};
	void Close(unsigned short code, hstring_ref reason) { hrcheck(X::get()->_CloseWithStatus(code, reason)); }
	IServerStreamWebSocket_adaptor() {}
};
template<typename X> struct adapt<IServerStreamWebSocket, X> : Windows::Networking::Sockets::IServerStreamWebSocket_adaptor<X> { typedef adapt IServerStreamWebSocket; };
struct IServerStreamWebSocket : IServerStreamWebSocket_raw, generate<IServerStreamWebSocket> {};

// ServerStreamWebSocketInformation
template<typename X> struct statics<ServerStreamWebSocketInformation, X> : X {
	typedef typename X::root_type ServerStreamWebSocketInformation;
};
struct ServerStreamWebSocketInformation : generate<ServerStreamWebSocketInformation> {};

// ServerStreamWebSocket
template<typename X> struct statics<ServerStreamWebSocket, X> : X {
	typedef typename X::root_type ServerStreamWebSocket;
};
struct ServerStreamWebSocket : generate<ServerStreamWebSocket> {
	using IClosable::Close;
	using IServerStreamWebSocket::Close;
};

// WebSocketKeepAlive
template<typename X> struct statics<WebSocketKeepAlive, X> : X {
	typedef typename X::root_type WebSocketKeepAlive;
};
struct WebSocketKeepAlive : generate<WebSocketKeepAlive> {};

// SocketError
template<typename> struct SocketError_statics {
	static SocketErrorStatus GetStatus(int hresult) { SocketErrorStatus status; hrcheck(get_activation_factory<SocketError, ISocketErrorStatics>()->_GetStatus(hresult, &status)); return status; }
};

template<typename X> struct statics<SocketError, X> : X, Windows::Networking::Sockets::SocketError_statics<void> {
	typedef typename X::root_type SocketError;
};
struct SocketError : generate<SocketError> {};

// WebSocketError
template<typename> struct WebSocketError_statics {
	static Web::WebErrorStatus GetStatus(int hresult) { Web::WebErrorStatus status; hrcheck(get_activation_factory<WebSocketError, IWebSocketErrorStatics>()->_GetStatus(hresult, &status)); return status; }
};

template<typename X> struct statics<WebSocketError, X> : X, Windows::Networking::Sockets::WebSocketError_statics<void> {
	typedef typename X::root_type WebSocketError;
};
struct WebSocketError : generate<WebSocketError> {};

// SocketActivityTriggerDetails
template<typename X> struct statics<SocketActivityTriggerDetails, X> : X {
	typedef typename X::root_type SocketActivityTriggerDetails;
};
struct SocketActivityTriggerDetails : generate<SocketActivityTriggerDetails> {};

// IControlChannelTrigger
struct IControlChannelTrigger_raw : IInspectable {
	virtual STDMETHODIMP _get_ControlChannelTriggerId(HSTRING *value);
	virtual STDMETHODIMP _get_ServerKeepAliveIntervalInMinutes(unsigned *value);
	virtual STDMETHODIMP _put_ServerKeepAliveIntervalInMinutes(unsigned value);
	virtual STDMETHODIMP _get_CurrentKeepAliveIntervalInMinutes(unsigned *value);
	virtual STDMETHODIMP _get_TransportObject(IInspectable* *value);
	virtual STDMETHODIMP _get_KeepAliveTrigger(ApplicationModel::Background::IBackgroundTrigger* *trigger);
	virtual STDMETHODIMP _get_PushNotificationTrigger(ApplicationModel::Background::IBackgroundTrigger* *trigger);
	virtual STDMETHODIMP _UsingTransport(IInspectable* transport);
	virtual STDMETHODIMP _WaitForPushEnabled(ControlChannelTriggerStatus *channelTriggerStatus);
	virtual STDMETHODIMP _DecreaseNetworkKeepAliveInterval();
	virtual STDMETHODIMP _FlushTransport();
};
template<typename X> struct IControlChannelTrigger_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IControlChannelTrigger_adaptor::ControlChannelTriggerId)->_get_ControlChannelTriggerId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ControlChannelTriggerId;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IControlChannelTrigger_adaptor::CurrentKeepAliveIntervalInMinutes)->_get_CurrentKeepAliveIntervalInMinutes(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} CurrentKeepAliveIntervalInMinutes;
		struct : property {
			ptr<ApplicationModel::Background::IBackgroundTrigger> get() { ApplicationModel::Background::IBackgroundTrigger* trigger; hrcheck(enc(&IControlChannelTrigger_adaptor::KeepAliveTrigger)->_get_KeepAliveTrigger(&trigger)); return from_abi(trigger); }
			ptr<ApplicationModel::Background::IBackgroundTrigger> operator()() { return get(); }
			operator ptr<ApplicationModel::Background::IBackgroundTrigger> () { return get(); }
			ptr<ApplicationModel::Background::IBackgroundTrigger> operator->() { return get(); }
		} KeepAliveTrigger;
		struct : property {
			ptr<ApplicationModel::Background::IBackgroundTrigger> get() { ApplicationModel::Background::IBackgroundTrigger* trigger; hrcheck(enc(&IControlChannelTrigger_adaptor::PushNotificationTrigger)->_get_PushNotificationTrigger(&trigger)); return from_abi(trigger); }
			ptr<ApplicationModel::Background::IBackgroundTrigger> operator()() { return get(); }
			operator ptr<ApplicationModel::Background::IBackgroundTrigger> () { return get(); }
			ptr<ApplicationModel::Background::IBackgroundTrigger> operator->() { return get(); }
		} PushNotificationTrigger;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IControlChannelTrigger_adaptor::ServerKeepAliveIntervalInMinutes)->_get_ServerKeepAliveIntervalInMinutes(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IControlChannelTrigger_adaptor::ServerKeepAliveIntervalInMinutes)->_put_ServerKeepAliveIntervalInMinutes(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} ServerKeepAliveIntervalInMinutes;
		struct : property {
			object get() { IInspectable* value; hrcheck(enc(&IControlChannelTrigger_adaptor::TransportObject)->_get_TransportObject(&value)); return from_abi(value); }
			object operator()() { return get(); }
			operator object () { return get(); }
		} TransportObject;
	};
	void UsingTransport(object_ref transport) { hrcheck(X::get()->_UsingTransport(transport)); }
	ControlChannelTriggerStatus WaitForPushEnabled() { ControlChannelTriggerStatus channelTriggerStatus; hrcheck(X::get()->_WaitForPushEnabled(&channelTriggerStatus)); return channelTriggerStatus; }
	void DecreaseNetworkKeepAliveInterval() { hrcheck(X::get()->_DecreaseNetworkKeepAliveInterval()); }
	void FlushTransport() { hrcheck(X::get()->_FlushTransport()); }
	IControlChannelTrigger_adaptor() {}
};
template<typename X> struct adapt<IControlChannelTrigger, X> : Windows::Networking::Sockets::IControlChannelTrigger_adaptor<X> { typedef adapt IControlChannelTrigger; };
struct IControlChannelTrigger : IControlChannelTrigger_raw, generate<IControlChannelTrigger> {};

// IControlChannelTriggerFactory
struct IControlChannelTriggerFactory : IInspectable {
	virtual STDMETHODIMP _CreateControlChannelTrigger(HSTRING channelId, unsigned serverKeepAliveIntervalInMinutes, ControlChannelTrigger* *notificationChannel);
	virtual STDMETHODIMP _CreateControlChannelTriggerEx(HSTRING channelId, unsigned serverKeepAliveIntervalInMinutes, ControlChannelTriggerResourceType resourceRequestType, ControlChannelTrigger* *notificationChannel);
};

// IControlChannelTrigger2
struct IControlChannelTrigger2_raw : IInspectable {
	virtual STDMETHODIMP _get_IsWakeFromLowPowerSupported(bool *value);
};
template<typename X> struct IControlChannelTrigger2_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IControlChannelTrigger2_adaptor::IsWakeFromLowPowerSupported)->_get_IsWakeFromLowPowerSupported(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsWakeFromLowPowerSupported;
	};
	IControlChannelTrigger2_adaptor() {}
};
template<typename X> struct adapt<IControlChannelTrigger2, X> : Windows::Networking::Sockets::IControlChannelTrigger2_adaptor<X> { typedef adapt IControlChannelTrigger2; };
struct IControlChannelTrigger2 : IControlChannelTrigger2_raw, generate<IControlChannelTrigger2> {};

// ControlChannelTrigger
template<typename> struct ControlChannelTrigger_statics {
	static ControlChannelTrigger *activate(hstring_ref channelId, unsigned serverKeepAliveIntervalInMinutes) { ControlChannelTrigger *notificationChannel; hrcheck(get_activation_factory<ControlChannelTrigger, IControlChannelTriggerFactory>()->_CreateControlChannelTrigger(channelId, serverKeepAliveIntervalInMinutes, &notificationChannel)); return notificationChannel; }
	static ControlChannelTrigger *activate(hstring_ref channelId, unsigned serverKeepAliveIntervalInMinutes, ControlChannelTriggerResourceType resourceRequestType) { ControlChannelTrigger *notificationChannel; hrcheck(get_activation_factory<ControlChannelTrigger, IControlChannelTriggerFactory>()->_CreateControlChannelTriggerEx(channelId, serverKeepAliveIntervalInMinutes, resourceRequestType, &notificationChannel)); return notificationChannel; }
};

template<typename X> struct statics<ControlChannelTrigger, X> : X, Windows::Networking::Sockets::ControlChannelTrigger_statics<void> {
	using Windows::Networking::Sockets::ControlChannelTrigger_statics<void>::activate;
	typedef typename X::root_type ControlChannelTrigger;
};
struct ControlChannelTrigger : generate<ControlChannelTrigger> {};

// IControlChannelTriggerEventDetails
struct IControlChannelTriggerEventDetails_raw : IInspectable {
	virtual STDMETHODIMP _get_ControlChannelTrigger(Sockets::ControlChannelTrigger* *value) = 0;
};
template<typename X> struct IControlChannelTriggerEventDetails_adaptor : X {
	union {
		struct : property {
			ptr<Sockets::ControlChannelTrigger> get() { Sockets::ControlChannelTrigger* value; hrcheck(enc(&IControlChannelTriggerEventDetails_adaptor::ControlChannelTrigger)->_get_ControlChannelTrigger(&value)); return from_abi(value); }
			ptr<Sockets::ControlChannelTrigger> operator()() { return get(); }
			operator ptr<Sockets::ControlChannelTrigger> () { return get(); }
			ptr<Sockets::ControlChannelTrigger> operator->() { return get(); }
		} ControlChannelTrigger;
	};
	IControlChannelTriggerEventDetails_adaptor() {}
};
template<typename X> struct adapt<IControlChannelTriggerEventDetails, X> : Windows::Networking::Sockets::IControlChannelTriggerEventDetails_adaptor<X> { typedef adapt IControlChannelTriggerEventDetails; };
template<typename X> struct IControlChannelTriggerEventDetails_unadaptor : X {
	STDMETHODIMP _get_ControlChannelTrigger(Sockets::ControlChannelTrigger* *value) { return hrtry([&, this] { get_prop(value, ControlChannelTrigger); }); }
};
template<typename X> struct unadapt<IControlChannelTriggerEventDetails, X> : Windows::Networking::Sockets::IControlChannelTriggerEventDetails_unadaptor<X> {};
struct IControlChannelTriggerEventDetails : IControlChannelTriggerEventDetails_raw, generate<IControlChannelTriggerEventDetails> {};

// IControlChannelTriggerResetEventDetails
struct IControlChannelTriggerResetEventDetails_raw : IInspectable {
	virtual STDMETHODIMP _get_ResetReason(ControlChannelTriggerResetReason *value) = 0;
	virtual STDMETHODIMP _get_HardwareSlotReset(bool *value) = 0;
	virtual STDMETHODIMP _get_SoftwareSlotReset(bool *value) = 0;
};
template<typename X> struct IControlChannelTriggerResetEventDetails_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IControlChannelTriggerResetEventDetails_adaptor::HardwareSlotReset)->_get_HardwareSlotReset(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HardwareSlotReset;
		struct : property {
			ControlChannelTriggerResetReason get() { ControlChannelTriggerResetReason value; hrcheck(enc(&IControlChannelTriggerResetEventDetails_adaptor::ResetReason)->_get_ResetReason(&value)); return value; }
			ControlChannelTriggerResetReason operator()() { return get(); }
			operator ControlChannelTriggerResetReason () { return get(); }
		} ResetReason;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IControlChannelTriggerResetEventDetails_adaptor::SoftwareSlotReset)->_get_SoftwareSlotReset(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} SoftwareSlotReset;
	};
	IControlChannelTriggerResetEventDetails_adaptor() {}
};
template<typename X> struct adapt<IControlChannelTriggerResetEventDetails, X> : Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails_adaptor<X> { typedef adapt IControlChannelTriggerResetEventDetails; };
template<typename X> struct IControlChannelTriggerResetEventDetails_unadaptor : X {
	STDMETHODIMP _get_ResetReason(ControlChannelTriggerResetReason *value) { return hrtry([&, this] { get_prop(value, ResetReason); }); }
	STDMETHODIMP _get_HardwareSlotReset(bool *value) { return hrtry([&, this] { get_prop(value, HardwareSlotReset); }); }
	STDMETHODIMP _get_SoftwareSlotReset(bool *value) { return hrtry([&, this] { get_prop(value, SoftwareSlotReset); }); }
};
template<typename X> struct unadapt<IControlChannelTriggerResetEventDetails, X> : Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails_unadaptor<X> {};
struct IControlChannelTriggerResetEventDetails : IControlChannelTriggerResetEventDetails_raw, generate<IControlChannelTriggerResetEventDetails> {};
}}}
} // namespace iso_winrt
