#pragma once
// generated by isopod tools
// namespaces:
// Windows.Storage.Compression

#include "Windows.Storage.Compression.0.h"
#include "Windows.Storage.Streams.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types


// defs

template<> struct def<Windows::Storage::Compression::ICompressor> : interface_type<Windows::Storage::Streams::IOutputStream, Windows::Foundation::IClosable> {};
template<> struct def<Windows::Storage::Compression::CompressAlgorithm> : enum_type<int> {};
template<> struct def<Windows::Storage::Compression::ICompressorFactory> : interface_type<> {};
template<> struct def<Windows::Storage::Compression::Compressor> : class_type<Platform::Object, Windows::Storage::Compression::ICompressor>, custom_activators {};
template<> struct def<Windows::Storage::Compression::IDecompressor> : interface_type<Windows::Storage::Streams::IInputStream, Windows::Foundation::IClosable> {};
template<> struct def<Windows::Storage::Compression::IDecompressorFactory> : interface_type<> {};
template<> struct def<Windows::Storage::Compression::Decompressor> : class_type<Platform::Object, Windows::Storage::Compression::IDecompressor>, custom_activators {};

// uuids

template<> struct uuid<Windows::Storage::Compression::ICompressor> { define_guid(0xAC3645A, 0x57AC, 0x4EE1, 0xB7, 0x2, 0x84, 0xD3, 0x9D, 0x54, 0x24, 0xE0);};
template<> struct uuid<Windows::Storage::Compression::ICompressorFactory> { define_guid(0x5F3D96A4, 0x2CFB, 0x442C, 0xA8, 0xBA, 0xD7, 0xD1, 0x1B, 0x3, 0x9D, 0xA0);};
template<> struct uuid<Windows::Storage::Compression::IDecompressor> { define_guid(0xB883FE46, 0xD68A, 0x4C8B, 0xAD, 0xA0, 0x4E, 0xE8, 0x13, 0xFC, 0x52, 0x83);};
template<> struct uuid<Windows::Storage::Compression::IDecompressorFactory> { define_guid(0x5337E252, 0x1DA2, 0x42E1, 0x88, 0x34, 0x3, 0x79, 0xD2, 0x8D, 0x74, 0x2F);};

// types

namespace Windows { namespace Storage { namespace Compression {

// ICompressor
struct ICompressor_raw : IInspectable {
	virtual STDMETHODIMP _FinishAsync(Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _DetachStream(Streams::IOutputStream* *stream);
};
template<typename X> struct ICompressor_adaptor : X {
	ptr<Foundation::IAsyncOperation<bool>> FinishAsync() { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_FinishAsync(&operation)); return from_abi(operation); }
	ptr<Streams::IOutputStream> DetachStream() { Streams::IOutputStream* stream; hrcheck(X::get()->_DetachStream(&stream)); return from_abi(stream); }
};
template<typename X> struct adapt<ICompressor, X> : Windows::Storage::Compression::ICompressor_adaptor<X> { typedef adapt ICompressor; };
struct ICompressor : ICompressor_raw, generate<ICompressor> {};

// ICompressorFactory
struct ICompressorFactory : IInspectable {
	virtual STDMETHODIMP _CreateCompressor(Streams::IOutputStream* underlyingStream, Compressor* *createdCompressor);
	virtual STDMETHODIMP _CreateCompressorEx(Streams::IOutputStream* underlyingStream, CompressAlgorithm algorithm, unsigned blockSize, Compressor* *createdCompressor);
};

// Compressor
template<typename> struct Compressor_statics {
	static Compressor *activate(pptr<Streams::IOutputStream> underlyingStream) { Compressor *createdCompressor; hrcheck(get_activation_factory<Compressor, ICompressorFactory>()->_CreateCompressor(underlyingStream, &createdCompressor)); return createdCompressor; }
	static Compressor *activate(pptr<Streams::IOutputStream> underlyingStream, CompressAlgorithm algorithm, unsigned blockSize) { Compressor *createdCompressor; hrcheck(get_activation_factory<Compressor, ICompressorFactory>()->_CreateCompressorEx(underlyingStream, algorithm, blockSize, &createdCompressor)); return createdCompressor; }
};

template<typename X> struct statics<Compressor, X> : X, Windows::Storage::Compression::Compressor_statics<void> {
	using Windows::Storage::Compression::Compressor_statics<void>::activate;
	typedef typename X::root_type Compressor;
};
struct Compressor : generate<Compressor> {};

// IDecompressor
struct IDecompressor_raw : IInspectable {
	virtual STDMETHODIMP _DetachStream(Streams::IInputStream* *stream);
};
template<typename X> struct IDecompressor_adaptor : X {
	ptr<Streams::IInputStream> DetachStream() { Streams::IInputStream* stream; hrcheck(X::get()->_DetachStream(&stream)); return from_abi(stream); }
};
template<typename X> struct adapt<IDecompressor, X> : Windows::Storage::Compression::IDecompressor_adaptor<X> { typedef adapt IDecompressor; };
struct IDecompressor : IDecompressor_raw, generate<IDecompressor> {};

// IDecompressorFactory
struct IDecompressorFactory : IInspectable {
	virtual STDMETHODIMP _CreateDecompressor(Streams::IInputStream* underlyingStream, Decompressor* *createdDecompressor);
};

// Decompressor
template<typename> struct Decompressor_statics {
	static Decompressor *activate(pptr<Streams::IInputStream> underlyingStream) { Decompressor *createdDecompressor; hrcheck(get_activation_factory<Decompressor, IDecompressorFactory>()->_CreateDecompressor(underlyingStream, &createdDecompressor)); return createdDecompressor; }
};

template<typename X> struct statics<Decompressor, X> : X, Windows::Storage::Compression::Decompressor_statics<void> {
	using Windows::Storage::Compression::Decompressor_statics<void>::activate;
	typedef typename X::root_type Decompressor;
};
struct Decompressor : generate<Decompressor> {};
}}}
} // namespace iso_winrt
