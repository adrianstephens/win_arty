#pragma once
// generated by isopod tools
// namespaces:
// Windows.Devices.I2c.Provider

#include "Windows.Devices.I2c.Provider.0.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IVectorView;
}}}

// defs

template<> struct def<Windows::Devices::I2c::Provider::ProviderI2cBusSpeed> : enum_type<int> {};
template<> struct def<Windows::Devices::I2c::Provider::ProviderI2cTransferStatus> : enum_type<int> {};
template<> struct def<Windows::Devices::I2c::Provider::ProviderI2cSharingMode> : enum_type<int> {};
template<> struct def<Windows::Devices::I2c::Provider::ProviderI2cTransferResult> : value_type<Windows::Devices::I2c::Provider::ProviderI2cTransferStatus, unsigned> {};
template<> struct def<Windows::Devices::I2c::Provider::IProviderI2cConnectionSettings> : interface_type<> {};
template<> struct def<Windows::Devices::I2c::Provider::ProviderI2cConnectionSettings> : class_type<Platform::Object, Windows::Devices::I2c::Provider::IProviderI2cConnectionSettings> {};
template<> struct def<Windows::Devices::I2c::Provider::II2cControllerProvider> : overridable_type<> {};
template<> struct def<Windows::Devices::I2c::Provider::II2cProvider> : overridable_type<> {};
template<> struct def<Windows::Devices::I2c::Provider::II2cDeviceProvider> : overridable_type<Windows::Foundation::IClosable> {};

// uuids

template<> struct uuid<Windows::Devices::I2c::Provider::IProviderI2cConnectionSettings> { define_guid(0xE9DB4E34, 0xE510, 0x44B7, 0x80, 0x9D, 0xF2, 0xF8, 0x5B, 0x55, 0x53, 0x39);};
template<> struct uuid<Windows::Devices::I2c::Provider::II2cControllerProvider> { define_guid(0x61C2BB82, 0x4510, 0x4163, 0xA8, 0x7C, 0x4E, 0x15, 0xA9, 0x55, 0x89, 0x80);};
template<> struct uuid<Windows::Devices::I2c::Provider::II2cProvider> { define_guid(0x6F13083E, 0xBF62, 0x4FE2, 0xA9, 0x5A, 0xF0, 0x89, 0x99, 0x66, 0x98, 0x18);};
template<> struct uuid<Windows::Devices::I2c::Provider::II2cDeviceProvider> { define_guid(0xAD342654, 0x57E8, 0x453E, 0x83, 0x29, 0xD1, 0xE4, 0x47, 0xD1, 0x3, 0xA9);};

// types

namespace Windows { namespace Devices { namespace I2c { namespace Provider {

// IProviderI2cConnectionSettings
struct IProviderI2cConnectionSettings_raw : IInspectable {
	virtual STDMETHODIMP _get_SlaveAddress(int *value);
	virtual STDMETHODIMP _put_SlaveAddress(int value);
	virtual STDMETHODIMP _get_BusSpeed(ProviderI2cBusSpeed *value);
	virtual STDMETHODIMP _put_BusSpeed(ProviderI2cBusSpeed value);
	virtual STDMETHODIMP _get_SharingMode(ProviderI2cSharingMode *value);
	virtual STDMETHODIMP _put_SharingMode(ProviderI2cSharingMode value);
};
template<typename X> struct IProviderI2cConnectionSettings_adaptor : X {
	union {
		struct : property {
			ProviderI2cBusSpeed get() { ProviderI2cBusSpeed value; hrcheck(enc(&IProviderI2cConnectionSettings_adaptor::BusSpeed)->_get_BusSpeed(&value)); return value; }
			ProviderI2cBusSpeed operator()() { return get(); }
			operator ProviderI2cBusSpeed () { return get(); }
			void put(ProviderI2cBusSpeed value) { hrcheck(enc(&IProviderI2cConnectionSettings_adaptor::BusSpeed)->_put_BusSpeed(value)); }
			void operator=(ProviderI2cBusSpeed value) { put(value); }
			void operator()(ProviderI2cBusSpeed value) { put(value); }
		} BusSpeed;
		struct : property {
			ProviderI2cSharingMode get() { ProviderI2cSharingMode value; hrcheck(enc(&IProviderI2cConnectionSettings_adaptor::SharingMode)->_get_SharingMode(&value)); return value; }
			ProviderI2cSharingMode operator()() { return get(); }
			operator ProviderI2cSharingMode () { return get(); }
			void put(ProviderI2cSharingMode value) { hrcheck(enc(&IProviderI2cConnectionSettings_adaptor::SharingMode)->_put_SharingMode(value)); }
			void operator=(ProviderI2cSharingMode value) { put(value); }
			void operator()(ProviderI2cSharingMode value) { put(value); }
		} SharingMode;
		struct : property {
			int get() { int value; hrcheck(enc(&IProviderI2cConnectionSettings_adaptor::SlaveAddress)->_get_SlaveAddress(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IProviderI2cConnectionSettings_adaptor::SlaveAddress)->_put_SlaveAddress(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} SlaveAddress;
	};
	IProviderI2cConnectionSettings_adaptor() {}
};
template<typename X> struct adapt<IProviderI2cConnectionSettings, X> : Windows::Devices::I2c::Provider::IProviderI2cConnectionSettings_adaptor<X> { typedef adapt IProviderI2cConnectionSettings; };
struct IProviderI2cConnectionSettings : IProviderI2cConnectionSettings_raw, generate<IProviderI2cConnectionSettings> {};

// ProviderI2cConnectionSettings
template<typename X> struct statics<ProviderI2cConnectionSettings, X> : X {
	typedef typename X::root_type ProviderI2cConnectionSettings;
};
struct ProviderI2cConnectionSettings : generate<ProviderI2cConnectionSettings> {};

// II2cControllerProvider
struct II2cControllerProvider_raw : IInspectable {
	virtual STDMETHODIMP _GetDeviceProvider(ProviderI2cConnectionSettings* settings, II2cDeviceProvider* *device) = 0;
};
template<typename X> struct II2cControllerProvider_adaptor : X {
	ptr<II2cDeviceProvider> GetDeviceProvider(pptr<ProviderI2cConnectionSettings> settings) { II2cDeviceProvider* device; hrcheck(X::get()->_GetDeviceProvider(settings, &device)); return from_abi(device); }
};
template<typename X> struct adapt<II2cControllerProvider, X> : Windows::Devices::I2c::Provider::II2cControllerProvider_adaptor<X> { typedef adapt II2cControllerProvider; };
template<typename X> struct II2cControllerProvider_unadaptor : X {
	STDMETHODIMP _GetDeviceProvider(ProviderI2cConnectionSettings* settings, II2cDeviceProvider* *device) { return hrtry([&, this] { *device = to_abi(X::get()->GetDeviceProvider(settings)); }); }
};
template<typename X> struct unadapt<II2cControllerProvider, X> : Windows::Devices::I2c::Provider::II2cControllerProvider_unadaptor<X> {};
struct II2cControllerProvider : II2cControllerProvider_raw, generate<II2cControllerProvider> {};

// II2cProvider
struct II2cProvider_raw : IInspectable {
	virtual STDMETHODIMP _GetControllersAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<II2cControllerProvider*>*>* *operation) = 0;
};
template<typename X> struct II2cProvider_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<II2cControllerProvider>>>>> GetControllersAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<II2cControllerProvider*>*>* operation; hrcheck(X::get()->_GetControllersAsync(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<II2cProvider, X> : Windows::Devices::I2c::Provider::II2cProvider_adaptor<X> { typedef adapt II2cProvider; };
template<typename X> struct II2cProvider_unadaptor : X {
	STDMETHODIMP _GetControllersAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<II2cControllerProvider*>*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetControllersAsync()); }); }
};
template<typename X> struct unadapt<II2cProvider, X> : Windows::Devices::I2c::Provider::II2cProvider_unadaptor<X> {};
struct II2cProvider : II2cProvider_raw, generate<II2cProvider> {};

// II2cDeviceProvider
struct II2cDeviceProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_DeviceId(HSTRING *value) = 0;
	virtual STDMETHODIMP _Write(unsigned bufferSize, unsigned char *buffer) = 0;
	virtual STDMETHODIMP _WritePartial(unsigned bufferSize, unsigned char *buffer, ProviderI2cTransferResult *result) = 0;
	virtual STDMETHODIMP _Read(unsigned bufferSize, unsigned char *buffer) = 0;
	virtual STDMETHODIMP _ReadPartial(unsigned bufferSize, unsigned char *buffer, ProviderI2cTransferResult *result) = 0;
	virtual STDMETHODIMP _WriteRead(unsigned writeBufferSize, unsigned char *writeBuffer, unsigned readBufferSize, unsigned char *readBuffer) = 0;
	virtual STDMETHODIMP _WriteReadPartial(unsigned writeBufferSize, unsigned char *writeBuffer, unsigned readBufferSize, unsigned char *readBuffer, ProviderI2cTransferResult *result) = 0;
};
template<typename X> struct II2cDeviceProvider_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&II2cDeviceProvider_adaptor::DeviceId)->_get_DeviceId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DeviceId;
	};
	void Write(const szarray<unsigned char>& buffer) { hrcheck(X::get()->_Write(buffer.size, to_abi(buffer.p))); }
	ProviderI2cTransferResult WritePartial(const szarray<unsigned char>& buffer) { ProviderI2cTransferResult result; hrcheck(X::get()->_WritePartial(buffer.size, to_abi(buffer.p), &result)); return result; }
	void Read(const szarray<unsigned char>& buffer) { hrcheck(X::get()->_Read(buffer.size, to_abi(buffer.p))); }
	ProviderI2cTransferResult ReadPartial(const szarray<unsigned char>& buffer) { ProviderI2cTransferResult result; hrcheck(X::get()->_ReadPartial(buffer.size, to_abi(buffer.p), &result)); return result; }
	void WriteRead(const szarray<unsigned char>& writeBuffer, const szarray<unsigned char>& readBuffer) { hrcheck(X::get()->_WriteRead(writeBuffer.size, to_abi(writeBuffer.p), readBuffer.size, to_abi(readBuffer.p))); }
	ProviderI2cTransferResult WriteReadPartial(const szarray<unsigned char>& writeBuffer, const szarray<unsigned char>& readBuffer) { ProviderI2cTransferResult result; hrcheck(X::get()->_WriteReadPartial(writeBuffer.size, to_abi(writeBuffer.p), readBuffer.size, to_abi(readBuffer.p), &result)); return result; }
	II2cDeviceProvider_adaptor() {}
};
template<typename X> struct adapt<II2cDeviceProvider, X> : Windows::Devices::I2c::Provider::II2cDeviceProvider_adaptor<X> { typedef adapt II2cDeviceProvider; };
template<typename X> struct II2cDeviceProvider_unadaptor : X {
	STDMETHODIMP _get_DeviceId(HSTRING *value) { return hrtry([&, this] { get_prop(value, DeviceId); }); }
	STDMETHODIMP _Write(unsigned bufferSize, unsigned char *buffer) { return hrtry([&, this] { X::get()->Write({(unsigned char*)buffer, bufferSize}); }); }
	STDMETHODIMP _WritePartial(unsigned bufferSize, unsigned char *buffer, ProviderI2cTransferResult *result) { return hrtry([&, this] { *result = X::get()->WritePartial({(unsigned char*)buffer, bufferSize}); }); }
	STDMETHODIMP _Read(unsigned bufferSize, unsigned char *buffer) { return hrtry([&, this] { X::get()->Read({(unsigned char*)buffer, bufferSize}); }); }
	STDMETHODIMP _ReadPartial(unsigned bufferSize, unsigned char *buffer, ProviderI2cTransferResult *result) { return hrtry([&, this] { *result = X::get()->ReadPartial({(unsigned char*)buffer, bufferSize}); }); }
	STDMETHODIMP _WriteRead(unsigned writeBufferSize, unsigned char *writeBuffer, unsigned readBufferSize, unsigned char *readBuffer) { return hrtry([&, this] { X::get()->WriteRead({(unsigned char*)writeBuffer, writeBufferSize}, {(unsigned char*)readBuffer, readBufferSize}); }); }
	STDMETHODIMP _WriteReadPartial(unsigned writeBufferSize, unsigned char *writeBuffer, unsigned readBufferSize, unsigned char *readBuffer, ProviderI2cTransferResult *result) { return hrtry([&, this] { *result = X::get()->WriteReadPartial({(unsigned char*)writeBuffer, writeBufferSize}, {(unsigned char*)readBuffer, readBufferSize}); }); }
};
template<typename X> struct unadapt<II2cDeviceProvider, X> : Windows::Devices::I2c::Provider::II2cDeviceProvider_unadaptor<X> {};
struct II2cDeviceProvider : II2cDeviceProvider_raw, generate<II2cDeviceProvider> {};
}}}}
} // namespace iso_winrt
