#pragma once
// generated by isopod tools
// namespaces:
// Windows.Devices.Lights

#include "Windows.Devices.Lights.0.h"
#include "Windows.UI.0.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types


// defs

template<> struct def<Windows::Devices::Lights::ILampStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Lights::ILamp> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Devices::Lights::Lamp> : class_type<Platform::Object, Windows::Devices::Lights::ILamp> {};
template<> struct def<Windows::Devices::Lights::ILampAvailabilityChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::Devices::Lights::LampAvailabilityChangedEventArgs> : class_type<Platform::Object, Windows::Devices::Lights::ILampAvailabilityChangedEventArgs> {};

// uuids

template<> struct uuid<Windows::Devices::Lights::ILampStatics> { define_guid(0xA822416C, 0x8885, 0x401E, 0xB8, 0x21, 0x8E, 0x8B, 0x38, 0xA8, 0xE8, 0xEC);};
template<> struct uuid<Windows::Devices::Lights::ILamp> { define_guid(0x47D5B9A, 0xEA45, 0x4B2B, 0xB1, 0xA2, 0x14, 0xDF, 0xF0, 0xB, 0xDE, 0x7B);};
template<> struct uuid<Windows::Devices::Lights::ILampAvailabilityChangedEventArgs> { define_guid(0x4F6E3DED, 0x7A2, 0x499D, 0x92, 0x60, 0x67, 0xE3, 0x4, 0x53, 0x2B, 0xA4);};

// types

namespace Windows { namespace Devices { namespace Lights {

// ILampStatics
struct ILampStatics : IInspectable {
	virtual STDMETHODIMP _GetDeviceSelector(HSTRING *value);
	virtual STDMETHODIMP _FromIdAsync(HSTRING deviceId, Foundation::IAsyncOperation<Lamp*>* *operation);
	virtual STDMETHODIMP _GetDefaultAsync(Foundation::IAsyncOperation<Lamp*>* *operation);
};

// ILamp
struct ILamp_raw : IInspectable {
	virtual STDMETHODIMP _get_DeviceId(HSTRING *value);
	virtual STDMETHODIMP _get_IsEnabled(bool *value);
	virtual STDMETHODIMP _put_IsEnabled(bool value);
	virtual STDMETHODIMP _get_BrightnessLevel(float *value);
	virtual STDMETHODIMP _put_BrightnessLevel(float value);
	virtual STDMETHODIMP _get_IsColorSettable(bool *value);
	virtual STDMETHODIMP _get_Color(UI::Color *value);
	virtual STDMETHODIMP _put_Color(UI::Color value);
	virtual STDMETHODIMP _add_AvailabilityChanged(Foundation::TypedEventHandler<Lamp*, LampAvailabilityChangedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_AvailabilityChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct ILamp_adaptor : X {
	union {
		struct : property {
			float get() { float value; hrcheck(enc(&ILamp_adaptor::BrightnessLevel)->_get_BrightnessLevel(&value)); return value; }
			float operator()() { return get(); }
			operator float () { return get(); }
			void put(float value) { hrcheck(enc(&ILamp_adaptor::BrightnessLevel)->_put_BrightnessLevel(value)); }
			void operator=(float value) { put(value); }
			void operator()(float value) { put(value); }
		} BrightnessLevel;
		struct : property {
			UI::Color get() { UI::Color value; hrcheck(enc(&ILamp_adaptor::Color)->_get_Color(&value)); return value; }
			UI::Color operator()() { return get(); }
			operator UI::Color () { return get(); }
			void put(const UI::Color& value) { hrcheck(enc(&ILamp_adaptor::Color)->_put_Color(value)); }
			void operator=(const UI::Color& value) { put(value); }
			void operator()(const UI::Color& value) { put(value); }
		} Color;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ILamp_adaptor::DeviceId)->_get_DeviceId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DeviceId;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILamp_adaptor::IsColorSettable)->_get_IsColorSettable(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsColorSettable;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILamp_adaptor::IsEnabled)->_get_IsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&ILamp_adaptor::IsEnabled)->_put_IsEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsEnabled;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<Lamp>, ptr<LampAvailabilityChangedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&ILamp_adaptor::AvailabilityChanged)->_add_AvailabilityChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&ILamp_adaptor::AvailabilityChanged)->_remove_AvailabilityChanged(token)); }
		} AvailabilityChanged;
	};
	ILamp_adaptor() {}
};
template<typename X> struct adapt<ILamp, X> : Windows::Devices::Lights::ILamp_adaptor<X> { typedef adapt ILamp; };
struct ILamp : ILamp_raw, generate<ILamp> {};

// Lamp
template<typename> struct Lamp_statics {
	static hstring GetDeviceSelector() { HSTRING value; hrcheck(get_activation_factory<Lamp, ILampStatics>()->_GetDeviceSelector(&value)); return from_abi(value); }
	static ptr<Foundation::IAsyncOperation<ptr<Lamp>>> FromIdAsync(hstring_ref deviceId) { Foundation::IAsyncOperation<Lamp*>* operation; hrcheck(get_activation_factory<Lamp, ILampStatics>()->_FromIdAsync(deviceId, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Lamp>>> GetDefaultAsync() { Foundation::IAsyncOperation<Lamp*>* operation; hrcheck(get_activation_factory<Lamp, ILampStatics>()->_GetDefaultAsync(&operation)); return from_abi(operation); }
};

template<typename X> struct statics<Lamp, X> : X, Windows::Devices::Lights::Lamp_statics<void> {
	typedef typename X::root_type Lamp;
};
struct Lamp : generate<Lamp> {};

// ILampAvailabilityChangedEventArgs
struct ILampAvailabilityChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_IsAvailable(bool *value);
};
template<typename X> struct ILampAvailabilityChangedEventArgs_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILampAvailabilityChangedEventArgs_adaptor::IsAvailable)->_get_IsAvailable(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsAvailable;
	};
	ILampAvailabilityChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<ILampAvailabilityChangedEventArgs, X> : Windows::Devices::Lights::ILampAvailabilityChangedEventArgs_adaptor<X> { typedef adapt ILampAvailabilityChangedEventArgs; };
struct ILampAvailabilityChangedEventArgs : ILampAvailabilityChangedEventArgs_raw, generate<ILampAvailabilityChangedEventArgs> {};

// LampAvailabilityChangedEventArgs
template<typename X> struct statics<LampAvailabilityChangedEventArgs, X> : X {
	typedef typename X::root_type LampAvailabilityChangedEventArgs;
};
struct LampAvailabilityChangedEventArgs : generate<LampAvailabilityChangedEventArgs> {};
}}}
} // namespace iso_winrt
