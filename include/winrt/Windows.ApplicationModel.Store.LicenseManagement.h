#pragma once
// generated by isopod tools
// namespaces:
// Windows.ApplicationModel.Store.LicenseManagement

#include "Windows.ApplicationModel.Store.LicenseManagement.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IIterable;
template<typename K, typename V> struct IMapView;
}}
namespace Storage { namespace Streams {
struct IBuffer;
}}}

// defs

template<> struct def<Windows::ApplicationModel::Store::LicenseManagement::ILicenseSatisfactionResult> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::LicenseManagement::ILicenseSatisfactionInfo> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::LicenseManagement::LicenseSatisfactionInfo> : class_type<Platform::Object, Windows::ApplicationModel::Store::LicenseManagement::ILicenseSatisfactionInfo> {};
template<> struct def<Windows::ApplicationModel::Store::LicenseManagement::ILicenseManagerStatics> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::LicenseManagement::LicenseSatisfactionResult> : class_type<Platform::Object, Windows::ApplicationModel::Store::LicenseManagement::ILicenseSatisfactionResult> {};
template<> struct def<Windows::ApplicationModel::Store::LicenseManagement::LicenseRefreshOption> : enum_type<int> {};
template<> struct def<Windows::ApplicationModel::Store::LicenseManagement::ILicenseManagerStatics2> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Store::LicenseManagement::LicenseManager> : class_type<Platform::Object, Platform::Object> {};

// uuids

template<> struct uuid<Windows::ApplicationModel::Store::LicenseManagement::ILicenseSatisfactionResult> { define_guid(0x3C674F73, 0x3C87, 0x4EE1, 0x82, 0x1, 0xF4, 0x28, 0x35, 0x9B, 0xD3, 0xAF);};
template<> struct uuid<Windows::ApplicationModel::Store::LicenseManagement::ILicenseSatisfactionInfo> { define_guid(0x3CCBB08F, 0xDB31, 0x48D5, 0x83, 0x84, 0xFA, 0x17, 0xC8, 0x14, 0x74, 0xE2);};
template<> struct uuid<Windows::ApplicationModel::Store::LicenseManagement::ILicenseManagerStatics> { define_guid(0xB5AC3AE0, 0xDA47, 0x4F20, 0x9A, 0x23, 0x9, 0x18, 0x2C, 0x94, 0x76, 0xFF);};
template<> struct uuid<Windows::ApplicationModel::Store::LicenseManagement::ILicenseManagerStatics2> { define_guid(0xAB2EC47B, 0x1F79, 0x4480, 0xB8, 0x7E, 0x2C, 0x49, 0x9E, 0x60, 0x1B, 0xA3);};

// types

namespace Windows { namespace ApplicationModel { namespace Store { namespace LicenseManagement {

// ILicenseSatisfactionResult
struct ILicenseSatisfactionResult_raw : IInspectable {
	virtual STDMETHODIMP _get_LicenseSatisfactionInfos(Foundation::Collections::IMapView<HSTRING, LicenseSatisfactionInfo*>* *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
};
template<typename X> struct ILicenseSatisfactionResult_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&ILicenseSatisfactionResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, ptr<LicenseSatisfactionInfo>>> get() { Foundation::Collections::IMapView<HSTRING, LicenseSatisfactionInfo*>* value; hrcheck(enc(&ILicenseSatisfactionResult_adaptor::LicenseSatisfactionInfos)->_get_LicenseSatisfactionInfos(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<LicenseSatisfactionInfo>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, ptr<LicenseSatisfactionInfo>>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<LicenseSatisfactionInfo>>> operator->() { return get(); }
		} LicenseSatisfactionInfos;
	};
	ILicenseSatisfactionResult_adaptor() {}
};
template<typename X> struct adapt<ILicenseSatisfactionResult, X> : Windows::ApplicationModel::Store::LicenseManagement::ILicenseSatisfactionResult_adaptor<X> { typedef adapt ILicenseSatisfactionResult; };
struct ILicenseSatisfactionResult : ILicenseSatisfactionResult_raw, generate<ILicenseSatisfactionResult> {};

// ILicenseSatisfactionInfo
struct ILicenseSatisfactionInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_SatisfiedByDevice(bool *value);
	virtual STDMETHODIMP _get_SatisfiedByOpenLicense(bool *value);
	virtual STDMETHODIMP _get_SatisfiedByTrial(bool *value);
	virtual STDMETHODIMP _get_SatisfiedByPass(bool *value);
	virtual STDMETHODIMP _get_SatisfiedByInstallMedia(bool *value);
	virtual STDMETHODIMP _get_SatisfiedBySignedInUser(bool *value);
	virtual STDMETHODIMP _get_IsSatisfied(bool *value);
};
template<typename X> struct ILicenseSatisfactionInfo_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILicenseSatisfactionInfo_adaptor::IsSatisfied)->_get_IsSatisfied(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsSatisfied;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILicenseSatisfactionInfo_adaptor::SatisfiedByDevice)->_get_SatisfiedByDevice(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} SatisfiedByDevice;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILicenseSatisfactionInfo_adaptor::SatisfiedByInstallMedia)->_get_SatisfiedByInstallMedia(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} SatisfiedByInstallMedia;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILicenseSatisfactionInfo_adaptor::SatisfiedByOpenLicense)->_get_SatisfiedByOpenLicense(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} SatisfiedByOpenLicense;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILicenseSatisfactionInfo_adaptor::SatisfiedByPass)->_get_SatisfiedByPass(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} SatisfiedByPass;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILicenseSatisfactionInfo_adaptor::SatisfiedBySignedInUser)->_get_SatisfiedBySignedInUser(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} SatisfiedBySignedInUser;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILicenseSatisfactionInfo_adaptor::SatisfiedByTrial)->_get_SatisfiedByTrial(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} SatisfiedByTrial;
	};
	ILicenseSatisfactionInfo_adaptor() {}
};
template<typename X> struct adapt<ILicenseSatisfactionInfo, X> : Windows::ApplicationModel::Store::LicenseManagement::ILicenseSatisfactionInfo_adaptor<X> { typedef adapt ILicenseSatisfactionInfo; };
struct ILicenseSatisfactionInfo : ILicenseSatisfactionInfo_raw, generate<ILicenseSatisfactionInfo> {};

// LicenseSatisfactionInfo
template<typename X> struct statics<LicenseSatisfactionInfo, X> : X {
	typedef typename X::root_type LicenseSatisfactionInfo;
};
struct LicenseSatisfactionInfo : generate<LicenseSatisfactionInfo> {};

// ILicenseManagerStatics
struct ILicenseManagerStatics : IInspectable {
	virtual STDMETHODIMP _AddLicenseAsync(Storage::Streams::IBuffer* license, Foundation::IAsyncAction* *action);
	virtual STDMETHODIMP _GetSatisfactionInfosAsync(Foundation::Collections::IIterable<HSTRING>* contentIds, Foundation::Collections::IIterable<HSTRING>* keyIds, Foundation::IAsyncOperation<LicenseSatisfactionResult*>* *operation);
};

// LicenseSatisfactionResult
template<typename X> struct statics<LicenseSatisfactionResult, X> : X {
	typedef typename X::root_type LicenseSatisfactionResult;
};
struct LicenseSatisfactionResult : generate<LicenseSatisfactionResult> {};

// ILicenseManagerStatics2
struct ILicenseManagerStatics2 : IInspectable {
	virtual STDMETHODIMP _RefreshLicensesAsync(LicenseRefreshOption refreshOption, Foundation::IAsyncAction* *action);
};

// LicenseManager
template<typename> struct LicenseManager_statics {
	static ptr<Foundation::IAsyncAction> RefreshLicensesAsync(LicenseRefreshOption refreshOption) { Foundation::IAsyncAction* action; hrcheck(get_activation_factory<LicenseManager, ILicenseManagerStatics2>()->_RefreshLicensesAsync(refreshOption, &action)); return from_abi(action); }
	static ptr<Foundation::IAsyncAction> AddLicenseAsync(pptr<Storage::Streams::IBuffer> license) { Foundation::IAsyncAction* action; hrcheck(get_activation_factory<LicenseManager, ILicenseManagerStatics>()->_AddLicenseAsync(license, &action)); return from_abi(action); }
	static ptr<Foundation::IAsyncOperation<ptr<LicenseSatisfactionResult>>> GetSatisfactionInfosAsync(pptr<Foundation::Collections::IIterable<hstring>> contentIds, pptr<Foundation::Collections::IIterable<hstring>> keyIds) { Foundation::IAsyncOperation<LicenseSatisfactionResult*>* operation; hrcheck(get_activation_factory<LicenseManager, ILicenseManagerStatics>()->_GetSatisfactionInfosAsync(to_abi(contentIds), to_abi(keyIds), &operation)); return from_abi(operation); }
};

template<typename X> struct statics<LicenseManager, X> : X, Windows::ApplicationModel::Store::LicenseManagement::LicenseManager_statics<void> {
	typedef typename X::root_type LicenseManager;
};
struct LicenseManager : generate<LicenseManager> {};
}}}}
} // namespace iso_winrt
