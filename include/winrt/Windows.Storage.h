#pragma once
// generated by isopod tools
// namespaces:
// Windows.Storage

#include "Windows.Storage.0.h"
#include "Windows.Storage.FileProperties.0.h"
#include "Windows.Storage.Provider.0.h"
#include "Windows.Foundation.Collections.h"
#include "Windows.Storage.Streams.h"
#include "Windows.Foundation.h"
#include "Windows.Storage.Search.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace System {
struct User;
}}

// defs

template<> struct def<Windows::Storage::KnownLibraryId> : enum_type<int> {};
template<> struct def<Windows::Storage::IStorageLibraryStatics> : interface_type<> {};
template<> struct def<Windows::Storage::IStorageLibraryStatics2> : interface_type<> {};
template<> struct def<Windows::Storage::IStorageLibrary3> : interface_type<> {};
template<> struct def<Windows::Storage::IStorageLibrary2> : interface_type<> {};
template<> struct def<Windows::Storage::IStorageLibrary> : interface_type<> {};
template<> struct def<Windows::Storage::StorageLibrary> : class_type<Platform::Object, Windows::Storage::IStorageLibrary, Windows::Storage::IStorageLibrary2, Windows::Storage::IStorageLibrary3> {};
template<> struct def<Windows::Storage::IStorageFolderStatics> : interface_type<> {};
template<> struct def<Windows::Storage::StorageItemTypes> : enum_type<unsigned> {};
template<> struct def<Windows::Storage::FileAttributes> : enum_type<unsigned> {};
template<> struct def<Windows::Storage::StorageDeleteOption> : enum_type<int> {};
template<> struct def<Windows::Storage::NameCollisionOption> : enum_type<int> {};
template<> struct def<Windows::Storage::CreationCollisionOption> : enum_type<int> {};
template<> struct def<Windows::Storage::IStorageFolder3> : interface_type<> {};
template<> struct def<Windows::Storage::IStorageItemProperties> : overridable_type<> {};
template<> struct def<Windows::Storage::IStorageItemPropertiesWithProvider> : overridable_type<Windows::Storage::IStorageItemProperties> {};
template<> struct def<Windows::Storage::IStorageFolder2> : overridable_type<> {};
template<> struct def<Windows::Storage::IStorageItem> : overridable_type<> {};
template<> struct def<Windows::Storage::IStorageItem2> : overridable_type<Windows::Storage::IStorageItem> {};
template<> struct def<Windows::Storage::IStorageItemProperties2> : overridable_type<Windows::Storage::IStorageItemProperties> {};
template<> struct def<Windows::Storage::IStorageFolder> : overridable_type<Windows::Storage::IStorageItem> {};
template<> struct def<Windows::Storage::StorageFolder> : class_type<Platform::Object, Windows::Storage::IStorageFolder, Windows::Storage::IStorageFolder3, Windows::Storage::Search::IStorageFolderQueryOperations, Windows::Storage::IStorageItemPropertiesWithProvider, Windows::Storage::IStorageItemProperties2, Windows::Storage::IStorageItem2, Windows::Storage::IStorageFolder2> {};
template<> struct def<Windows::Storage::IStorageLibraryChangeTracker> : interface_type<> {};
template<> struct def<Windows::Storage::StorageLibraryChangeTracker> : class_type<Platform::Object, Windows::Storage::IStorageLibraryChangeTracker> {};
template<> struct def<Windows::Storage::KnownFolderId> : enum_type<int> {};
template<> struct def<Windows::Storage::IKnownFoldersStatics> : interface_type<> {};
template<> struct def<Windows::Storage::IKnownFoldersStatics2> : interface_type<> {};
template<> struct def<Windows::Storage::IKnownFoldersStatics3> : interface_type<> {};
template<> struct def<Windows::Storage::IKnownFoldersPlaylistsStatics> : interface_type<> {};
template<> struct def<Windows::Storage::IKnownFoldersCameraRollStatics> : interface_type<> {};
template<> struct def<Windows::Storage::IKnownFoldersSavedPicturesStatics> : interface_type<> {};
template<> struct def<Windows::Storage::KnownFolders> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Storage::IUserDataPathsStatics> : interface_type<> {};
template<> struct def<Windows::Storage::IUserDataPaths> : interface_type<> {};
template<> struct def<Windows::Storage::UserDataPaths> : class_type<Platform::Object, Windows::Storage::IUserDataPaths> {};
template<> struct def<Windows::Storage::IAppDataPathsStatics> : interface_type<> {};
template<> struct def<Windows::Storage::IAppDataPaths> : interface_type<> {};
template<> struct def<Windows::Storage::AppDataPaths> : class_type<Platform::Object, Windows::Storage::IAppDataPaths> {};
template<> struct def<Windows::Storage::ISystemDataPathsStatics> : interface_type<> {};
template<> struct def<Windows::Storage::ISystemDataPaths> : interface_type<> {};
template<> struct def<Windows::Storage::SystemDataPaths> : class_type<Platform::Object, Windows::Storage::ISystemDataPaths> {};
template<> struct def<Windows::Storage::IDownloadsFolderStatics> : interface_type<> {};
template<> struct def<Windows::Storage::IStorageFileStatics> : interface_type<> {};
template<> struct def<Windows::Storage::StorageOpenOptions> : enum_type<unsigned> {};
template<> struct def<Windows::Storage::FileAccessMode> : enum_type<int> {};
template<> struct def<Windows::Storage::IStorageFile2> : overridable_type<> {};
template<> struct def<Windows::Storage::IStorageFilePropertiesWithAvailability> : overridable_type<> {};
template<> struct def<Windows::Storage::IStorageFile> : overridable_type<Windows::Storage::IStorageItem, Windows::Storage::Streams::IRandomAccessStreamReference, Windows::Storage::Streams::IInputStreamReference> {};
template<> struct def<Windows::Storage::StorageFile> : class_type<Platform::Object, Windows::Storage::IStorageFile, Windows::Storage::IStorageFile2, Windows::Storage::IStorageFilePropertiesWithAvailability, Windows::Storage::IStorageItemPropertiesWithProvider, Windows::Storage::IStorageItem2, Windows::Storage::IStorageItemProperties2> {};
template<> struct def<Windows::Storage::IDownloadsFolderStatics2> : interface_type<> {};
template<> struct def<Windows::Storage::DownloadsFolder> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Storage::StorageLibraryChangeType> : enum_type<int> {};
template<> struct def<Windows::Storage::IStorageLibraryChange> : interface_type<> {};
template<> struct def<Windows::Storage::StorageLibraryChange> : class_type<Platform::Object, Windows::Storage::IStorageLibraryChange> {};
template<> struct def<Windows::Storage::IStorageLibraryChangeReader> : interface_type<> {};
template<> struct def<Windows::Storage::StorageLibraryChangeReader> : class_type<Platform::Object, Windows::Storage::IStorageLibraryChangeReader> {};
template<> struct def<Windows::Storage::StreamedFileFailureMode> : enum_type<int> {};
template<> struct def<Windows::Storage::IStreamedFileDataRequest> : overridable_type<> {};
template<> struct def<Windows::Storage::StreamedFileDataRequest> : class_type<Platform::Object, Windows::Storage::Streams::IOutputStream, Windows::Foundation::IClosable, Windows::Storage::IStreamedFileDataRequest> {};
template<> struct def<Windows::Storage::StreamedFileDataRequestedHandler> : delegate_type {};
template<> struct def<Windows::Storage::IStorageStreamTransaction> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Storage::StorageStreamTransaction> : class_type<Platform::Object, Windows::Storage::IStorageStreamTransaction> {};
template<> struct def<Windows::Storage::IStorageProvider> : interface_type<> {};
template<> struct def<Windows::Storage::IStorageProvider2> : interface_type<Windows::Storage::IStorageProvider> {};
template<> struct def<Windows::Storage::StorageProvider> : class_type<Platform::Object, Windows::Storage::IStorageProvider, Windows::Storage::IStorageProvider2> {};
template<> struct def<Windows::Storage::IFileIOStatics> : interface_type<> {};
template<> struct def<Windows::Storage::FileIO> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Storage::IPathIOStatics> : interface_type<> {};
template<> struct def<Windows::Storage::PathIO> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Storage::ICachedFileManagerStatics> : interface_type<> {};
template<> struct def<Windows::Storage::CachedFileManager> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Storage::ISystemAudioProperties> : interface_type<> {};
template<> struct def<Windows::Storage::SystemAudioProperties> : class_type<Platform::Object, Windows::Storage::ISystemAudioProperties> {};
template<> struct def<Windows::Storage::ISystemGPSProperties> : interface_type<> {};
template<> struct def<Windows::Storage::SystemGPSProperties> : class_type<Platform::Object, Windows::Storage::ISystemGPSProperties> {};
template<> struct def<Windows::Storage::ISystemImageProperties> : interface_type<> {};
template<> struct def<Windows::Storage::SystemImageProperties> : class_type<Platform::Object, Windows::Storage::ISystemImageProperties> {};
template<> struct def<Windows::Storage::ISystemMediaProperties> : interface_type<> {};
template<> struct def<Windows::Storage::SystemMediaProperties> : class_type<Platform::Object, Windows::Storage::ISystemMediaProperties> {};
template<> struct def<Windows::Storage::ISystemMusicProperties> : interface_type<> {};
template<> struct def<Windows::Storage::SystemMusicProperties> : class_type<Platform::Object, Windows::Storage::ISystemMusicProperties> {};
template<> struct def<Windows::Storage::ISystemPhotoProperties> : interface_type<> {};
template<> struct def<Windows::Storage::SystemPhotoProperties> : class_type<Platform::Object, Windows::Storage::ISystemPhotoProperties> {};
template<> struct def<Windows::Storage::ISystemVideoProperties> : interface_type<> {};
template<> struct def<Windows::Storage::SystemVideoProperties> : class_type<Platform::Object, Windows::Storage::ISystemVideoProperties> {};
template<> struct def<Windows::Storage::ISystemProperties> : interface_type<> {};
template<> struct def<Windows::Storage::SystemProperties> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Storage::ApplicationDataLocality> : enum_type<int> {};
template<> struct def<Windows::Storage::ApplicationDataCreateDisposition> : enum_type<int> {};
template<> struct def<Windows::Storage::IApplicationDataStatics> : interface_type<> {};
template<> struct def<Windows::Storage::IApplicationDataStatics2> : interface_type<> {};
template<> struct def<Windows::Storage::IApplicationData3> : interface_type<> {};
template<> struct def<Windows::Storage::IApplicationData2> : interface_type<> {};
template<> struct def<Windows::Storage::IApplicationData> : interface_type<> {};
template<> struct def<Windows::Storage::ApplicationData> : class_type<Platform::Object, Windows::Storage::IApplicationData, Windows::Storage::IApplicationData2, Windows::Storage::IApplicationData3> {};
template<> struct def<Windows::Storage::ApplicationDataSetVersionHandler> : delegate_type {};
template<> struct def<Windows::Storage::ISetVersionRequest> : interface_type<> {};
template<> struct def<Windows::Storage::SetVersionRequest> : class_type<Platform::Object, Windows::Storage::ISetVersionRequest> {};
template<> struct def<Windows::Storage::IApplicationDataContainer> : interface_type<> {};
template<> struct def<Windows::Storage::ApplicationDataContainer> : class_type<Platform::Object, Windows::Storage::IApplicationDataContainer> {};
template<> struct def<Windows::Storage::ISetVersionDeferral> : interface_type<> {};
template<> struct def<Windows::Storage::SetVersionDeferral> : class_type<Platform::Object, Windows::Storage::ISetVersionDeferral> {};
template<> struct def<Windows::Storage::ApplicationDataContainerSettings> : class_type<Platform::Object, Windows::Foundation::Collections::IPropertySet, Windows::Foundation::Collections::IObservableMap<HSTRING, object>, Windows::Foundation::Collections::IMap<HSTRING, object>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, object>>>> {};
template<> struct def<Windows::Storage::ApplicationDataCompositeValue> : class_type<Platform::Object, Windows::Foundation::Collections::IPropertySet, Windows::Foundation::Collections::IObservableMap<HSTRING, object>, Windows::Foundation::Collections::IMap<HSTRING, object>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, object>>>> {};

// uuids

template<> struct uuid<Windows::Storage::IStorageLibraryStatics> { define_guid(0x4208A6DB, 0x684A, 0x49C6, 0x9E, 0x59, 0x90, 0x12, 0x1E, 0xE0, 0x50, 0xD6);};
template<> struct uuid<Windows::Storage::IStorageLibraryStatics2> { define_guid(0xFFB08DDC, 0xFA75, 0x4695, 0xB9, 0xD1, 0x7F, 0x81, 0xF9, 0x78, 0x32, 0xE3);};
template<> struct uuid<Windows::Storage::IStorageLibrary3> { define_guid(0x8A281291, 0x2154, 0x4201, 0x81, 0x13, 0xD2, 0xC0, 0x5C, 0xE1, 0xAD, 0x23);};
template<> struct uuid<Windows::Storage::IStorageLibrary2> { define_guid(0x5B0CE348, 0xFCB3, 0x4031, 0xAF, 0xB0, 0xA6, 0x8D, 0x7B, 0xD4, 0x45, 0x34);};
template<> struct uuid<Windows::Storage::IStorageLibrary> { define_guid(0x1EDD7103, 0xE5E, 0x4D6C, 0xB5, 0xE8, 0x93, 0x18, 0x98, 0x3D, 0x6A, 0x3);};
template<> struct uuid<Windows::Storage::IStorageFolderStatics> { define_guid(0x8F327FF, 0x85D5, 0x48B9, 0xAE, 0xE9, 0x28, 0x51, 0x1E, 0x33, 0x9F, 0x9F);};
template<> struct uuid<Windows::Storage::IStorageFolder3> { define_guid(0x9F617899, 0xBDE1, 0x4124, 0xAE, 0xB3, 0xB0, 0x6A, 0xD9, 0x6F, 0x98, 0xD4);};
template<> struct uuid<Windows::Storage::IStorageItemProperties> { define_guid(0x86664478, 0x8029, 0x46FE, 0xA7, 0x89, 0x1C, 0x2F, 0x3E, 0x2F, 0xFB, 0x5C);};
template<> struct uuid<Windows::Storage::IStorageItemPropertiesWithProvider> { define_guid(0x861BF39B, 0x6368, 0x4DEE, 0xB4, 0xE, 0x74, 0x68, 0x4A, 0x5C, 0xE7, 0x14);};
template<> struct uuid<Windows::Storage::IStorageFolder2> { define_guid(0xE827E8B9, 0x8D9, 0x4A8E, 0xA0, 0xAC, 0xFE, 0x5E, 0xD3, 0xCB, 0xBB, 0xD3);};
template<> struct uuid<Windows::Storage::IStorageItem> { define_guid(0x4207A996, 0xCA2F, 0x42F7, 0xBD, 0xE8, 0x8B, 0x10, 0x45, 0x7A, 0x7F, 0x30);};
template<> struct uuid<Windows::Storage::IStorageItem2> { define_guid(0x53F926D2, 0x83C, 0x4283, 0xB4, 0x5B, 0x81, 0xC0, 0x7, 0x23, 0x7E, 0x44);};
template<> struct uuid<Windows::Storage::IStorageItemProperties2> { define_guid(0x8E86A951, 0x4B9, 0x4BD2, 0x92, 0x9D, 0xFE, 0xF3, 0xF7, 0x16, 0x21, 0xD0);};
template<> struct uuid<Windows::Storage::IStorageFolder> { define_guid(0x72D1CB78, 0xB3EF, 0x4F75, 0xA8, 0xB, 0x6F, 0xD9, 0xDA, 0xE2, 0x94, 0x4B);};
template<> struct uuid<Windows::Storage::IStorageLibraryChangeTracker> { define_guid(0x9E157316, 0x6073, 0x44F6, 0x96, 0x81, 0x74, 0x92, 0xD1, 0x28, 0x6C, 0x90);};
template<> struct uuid<Windows::Storage::IKnownFoldersStatics> { define_guid(0x5A2A7520, 0x4802, 0x452D, 0x9A, 0xD9, 0x43, 0x51, 0xAD, 0xA7, 0xEC, 0x35);};
template<> struct uuid<Windows::Storage::IKnownFoldersStatics2> { define_guid(0x194BD0CD, 0xCF6E, 0x4D07, 0x9D, 0x53, 0xE9, 0x16, 0x3A, 0x25, 0x36, 0xE9);};
template<> struct uuid<Windows::Storage::IKnownFoldersStatics3> { define_guid(0xC5194341, 0x9742, 0x4ED5, 0x82, 0x3D, 0xFC, 0x14, 0x1, 0x14, 0x87, 0x64);};
template<> struct uuid<Windows::Storage::IKnownFoldersPlaylistsStatics> { define_guid(0xDAD5ECD6, 0x306F, 0x4D6A, 0xB4, 0x96, 0x46, 0xBA, 0x8E, 0xB1, 0x6, 0xCE);};
template<> struct uuid<Windows::Storage::IKnownFoldersCameraRollStatics> { define_guid(0x5D115E66, 0x27E8, 0x492F, 0xB8, 0xE5, 0x2F, 0x90, 0x89, 0x6C, 0xD4, 0xCD);};
template<> struct uuid<Windows::Storage::IKnownFoldersSavedPicturesStatics> { define_guid(0x55C93EA, 0x253D, 0x467C, 0xB6, 0xCA, 0xA9, 0x7D, 0xA1, 0xE9, 0xA1, 0x8D);};
template<> struct uuid<Windows::Storage::IUserDataPathsStatics> { define_guid(0x1B29DEF, 0xE062, 0x48A1, 0x8B, 0xC, 0xF2, 0xC7, 0xA9, 0xCA, 0x56, 0xC0);};
template<> struct uuid<Windows::Storage::IUserDataPaths> { define_guid(0xF9C53912, 0xABC4, 0x46FF, 0x8A, 0x2B, 0xDC, 0x9D, 0x7F, 0xA6, 0xE5, 0x2F);};
template<> struct uuid<Windows::Storage::IAppDataPathsStatics> { define_guid(0xD8EB2AFE, 0xA9D9, 0x4B14, 0xB9, 0x99, 0xE3, 0x92, 0x13, 0x79, 0xD9, 0x3);};
template<> struct uuid<Windows::Storage::IAppDataPaths> { define_guid(0x7301D60A, 0x79A2, 0x48C9, 0x9E, 0xC0, 0x3F, 0xDA, 0x9, 0x2F, 0x79, 0xE1);};
template<> struct uuid<Windows::Storage::ISystemDataPathsStatics> { define_guid(0xE0F96FD0, 0x9920, 0x4BCA, 0xB3, 0x79, 0xF9, 0x6F, 0xDF, 0x7C, 0xAA, 0xD8);};
template<> struct uuid<Windows::Storage::ISystemDataPaths> { define_guid(0xE32ABF70, 0xD8FA, 0x45EC, 0xA9, 0x42, 0xD2, 0xE2, 0x6F, 0xB6, 0xB, 0xA5);};
template<> struct uuid<Windows::Storage::IDownloadsFolderStatics> { define_guid(0x27862ED0, 0x404E, 0x47DF, 0xA1, 0xE2, 0xE3, 0x73, 0x8, 0xBE, 0x7B, 0x37);};
template<> struct uuid<Windows::Storage::IStorageFileStatics> { define_guid(0x5984C710, 0xDAF2, 0x43C8, 0x8B, 0xB4, 0xA4, 0xD3, 0xEA, 0xCF, 0xD0, 0x3F);};
template<> struct uuid<Windows::Storage::IStorageFile2> { define_guid(0x954E4BCF, 0xA77, 0x42FB, 0xB7, 0x77, 0xC2, 0xED, 0x58, 0xA5, 0x2E, 0x44);};
template<> struct uuid<Windows::Storage::IStorageFilePropertiesWithAvailability> { define_guid(0xAFCBBE9B, 0x582B, 0x4133, 0x96, 0x48, 0xE4, 0x4C, 0xA4, 0x6E, 0xE4, 0x91);};
template<> struct uuid<Windows::Storage::IStorageFile> { define_guid(0xFA3F6186, 0x4214, 0x428C, 0xA6, 0x4C, 0x14, 0xC9, 0xAC, 0x73, 0x15, 0xEA);};
template<> struct uuid<Windows::Storage::IDownloadsFolderStatics2> { define_guid(0xE93045BD, 0x8EF8, 0x4F8E, 0x8D, 0x15, 0xAC, 0xE, 0x26, 0x5F, 0x39, 0xD);};
template<> struct uuid<Windows::Storage::IStorageLibraryChange> { define_guid(0x980B23, 0x2BE2, 0x4909, 0xAA, 0x48, 0x15, 0x9F, 0x52, 0x3, 0xA5, 0x1E);};
template<> struct uuid<Windows::Storage::IStorageLibraryChangeReader> { define_guid(0xF205BC83, 0xFCA2, 0x41F9, 0x89, 0x54, 0xEE, 0x2E, 0x99, 0x1E, 0xB9, 0x6F);};
template<> struct uuid<Windows::Storage::IStreamedFileDataRequest> { define_guid(0x1673FCCE, 0xDABD, 0x4D50, 0xBE, 0xEE, 0x18, 0xB, 0x8A, 0x81, 0x91, 0xB6);};
template<> struct uuid<Windows::Storage::StreamedFileDataRequestedHandler> { define_guid(0xFEF6A824, 0x2FE1, 0x4D07, 0xA3, 0x5B, 0xB7, 0x7C, 0x50, 0xB5, 0xF4, 0xCC);};
template<> struct uuid<Windows::Storage::IStorageStreamTransaction> { define_guid(0xF67CF363, 0xA53D, 0x4D94, 0xAE, 0x2C, 0x67, 0x23, 0x2D, 0x93, 0xAC, 0xDD);};
template<> struct uuid<Windows::Storage::IStorageProvider> { define_guid(0xE705EED4, 0xD478, 0x47D6, 0xBA, 0x46, 0x1A, 0x8E, 0xBE, 0x11, 0x4A, 0x20);};
template<> struct uuid<Windows::Storage::IStorageProvider2> { define_guid(0x10D1917, 0x3404, 0x414B, 0x9F, 0xD7, 0xCD, 0x44, 0x47, 0x2E, 0xAA, 0x39);};
template<> struct uuid<Windows::Storage::IFileIOStatics> { define_guid(0x887411EB, 0x7F54, 0x4732, 0xA5, 0xF0, 0x5E, 0x43, 0xE3, 0xB8, 0xC2, 0xF5);};
template<> struct uuid<Windows::Storage::IPathIOStatics> { define_guid(0xF2F3758, 0x8EC7, 0x4381, 0x92, 0x2B, 0x8F, 0x6C, 0x7, 0xD2, 0x88, 0xF3);};
template<> struct uuid<Windows::Storage::ICachedFileManagerStatics> { define_guid(0x8FFC224A, 0xE782, 0x495D, 0xB6, 0x14, 0x65, 0x4C, 0x4F, 0xB, 0x23, 0x70);};
template<> struct uuid<Windows::Storage::ISystemAudioProperties> { define_guid(0x3F8F38B7, 0x308C, 0x47E1, 0x92, 0x4D, 0x86, 0x45, 0x34, 0x8E, 0x5D, 0xB7);};
template<> struct uuid<Windows::Storage::ISystemGPSProperties> { define_guid(0xC0F46EB4, 0xC174, 0x481A, 0xBC, 0x25, 0x92, 0x19, 0x86, 0xF6, 0xA6, 0xF3);};
template<> struct uuid<Windows::Storage::ISystemImageProperties> { define_guid(0x11B2E30, 0x8B39, 0x4308, 0xBE, 0xA1, 0xE8, 0xAA, 0x61, 0xE4, 0x78, 0x26);};
template<> struct uuid<Windows::Storage::ISystemMediaProperties> { define_guid(0xA42B3316, 0x8415, 0x40DC, 0x8C, 0x44, 0x98, 0x36, 0x1D, 0x23, 0x54, 0x30);};
template<> struct uuid<Windows::Storage::ISystemMusicProperties> { define_guid(0xB47988D5, 0x67AF, 0x4BC3, 0x8D, 0x39, 0x5B, 0x89, 0x2, 0x20, 0x26, 0xA1);};
template<> struct uuid<Windows::Storage::ISystemPhotoProperties> { define_guid(0x4734FC3D, 0xAB21, 0x4424, 0xB7, 0x35, 0xF4, 0x35, 0x3A, 0x56, 0xC8, 0xFC);};
template<> struct uuid<Windows::Storage::ISystemVideoProperties> { define_guid(0x2040F715, 0x67F8, 0x4322, 0x9B, 0x80, 0x4F, 0xA9, 0xFE, 0xFB, 0x83, 0xE8);};
template<> struct uuid<Windows::Storage::ISystemProperties> { define_guid(0x917A71C1, 0x85F3, 0x4DD1, 0xB0, 0x1, 0xA5, 0xB, 0xFD, 0x21, 0xC8, 0xD2);};
template<> struct uuid<Windows::Storage::IApplicationDataStatics> { define_guid(0x5612147B, 0xE843, 0x45E3, 0x94, 0xD8, 0x6, 0x16, 0x9E, 0x3C, 0x8E, 0x17);};
template<> struct uuid<Windows::Storage::IApplicationDataStatics2> { define_guid(0xCD606211, 0xCF49, 0x40A4, 0xA4, 0x7C, 0xC7, 0xF0, 0xDB, 0xBA, 0x81, 0x7);};
template<> struct uuid<Windows::Storage::IApplicationData3> { define_guid(0xDC222CF4, 0x2772, 0x4C1D, 0xAA, 0x2C, 0xC9, 0xF7, 0x43, 0xAD, 0xE8, 0xD1);};
template<> struct uuid<Windows::Storage::IApplicationData2> { define_guid(0x9E65CD69, 0xBA3, 0x4E32, 0xBE, 0x29, 0xB0, 0x2D, 0xE6, 0x60, 0x76, 0x38);};
template<> struct uuid<Windows::Storage::IApplicationData> { define_guid(0xC3DA6FB7, 0xB744, 0x4B45, 0xB0, 0xB8, 0x22, 0x3A, 0x9, 0x38, 0xD0, 0xDC);};
template<> struct uuid<Windows::Storage::ApplicationDataSetVersionHandler> { define_guid(0xA05791E6, 0xCC9F, 0x4687, 0xAC, 0xAB, 0xA3, 0x64, 0xFD, 0x78, 0x54, 0x63);};
template<> struct uuid<Windows::Storage::ISetVersionRequest> { define_guid(0xB9C76B9B, 0x1056, 0x4E69, 0x83, 0x30, 0x16, 0x26, 0x19, 0x95, 0x6F, 0x9B);};
template<> struct uuid<Windows::Storage::IApplicationDataContainer> { define_guid(0xC5AEFD1E, 0xF467, 0x40BA, 0x85, 0x66, 0xAB, 0x64, 0xA, 0x44, 0x1E, 0x1D);};
template<> struct uuid<Windows::Storage::ISetVersionDeferral> { define_guid(0x33508A2, 0x781A, 0x437A, 0xB0, 0x78, 0x3F, 0x32, 0xBA, 0xDC, 0xFE, 0x47);};

// types

namespace Windows { namespace Storage {

// IStorageLibraryStatics
struct IStorageLibraryStatics : IInspectable {
	virtual STDMETHODIMP _GetLibraryAsync(KnownLibraryId libraryId, Foundation::IAsyncOperation<StorageLibrary*>* *operation);
};

// IStorageLibraryStatics2
struct IStorageLibraryStatics2 : IInspectable {
	virtual STDMETHODIMP _GetLibraryForUserAsync(System::User* user, KnownLibraryId libraryId, Foundation::IAsyncOperation<StorageLibrary*>* *operation);
};

// IStorageLibrary3
struct IStorageLibrary3_raw : IInspectable {
	virtual STDMETHODIMP _AreFolderSuggestionsAvailableAsync(Foundation::IAsyncOperation<bool>* *operation);
};
template<typename X> struct IStorageLibrary3_adaptor : X {
	ptr<Foundation::IAsyncOperation<bool>> AreFolderSuggestionsAvailableAsync() { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_AreFolderSuggestionsAvailableAsync(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IStorageLibrary3, X> : Windows::Storage::IStorageLibrary3_adaptor<X> { typedef adapt IStorageLibrary3; };
struct IStorageLibrary3 : IStorageLibrary3_raw, generate<IStorageLibrary3> {};

// IStorageLibrary2
struct IStorageLibrary2_raw : IInspectable {
	virtual STDMETHODIMP _get_ChangeTracker(StorageLibraryChangeTracker* *value);
};
template<typename X> struct IStorageLibrary2_adaptor : X {
	union {
		struct : property {
			ptr<StorageLibraryChangeTracker> get() { StorageLibraryChangeTracker* value; hrcheck(enc(&IStorageLibrary2_adaptor::ChangeTracker)->_get_ChangeTracker(&value)); return from_abi(value); }
			ptr<StorageLibraryChangeTracker> operator()() { return get(); }
			operator ptr<StorageLibraryChangeTracker> () { return get(); }
			ptr<StorageLibraryChangeTracker> operator->() { return get(); }
		} ChangeTracker;
	};
	IStorageLibrary2_adaptor() {}
};
template<typename X> struct adapt<IStorageLibrary2, X> : Windows::Storage::IStorageLibrary2_adaptor<X> { typedef adapt IStorageLibrary2; };
struct IStorageLibrary2 : IStorageLibrary2_raw, generate<IStorageLibrary2> {};

// IStorageLibrary
struct IStorageLibrary_raw : IInspectable {
	virtual STDMETHODIMP _RequestAddFolderAsync(Foundation::IAsyncOperation<StorageFolder*>* *operation);
	virtual STDMETHODIMP _RequestRemoveFolderAsync(StorageFolder* folder, Foundation::IAsyncOperation<bool>* *operation);
	virtual STDMETHODIMP _get_Folders(Foundation::Collections::IObservableVector<StorageFolder*>* *value);
	virtual STDMETHODIMP _get_SaveFolder(StorageFolder* *value);
	virtual STDMETHODIMP _add_DefinitionChanged(Foundation::TypedEventHandler<StorageLibrary*, IInspectable*>* handler, Foundation::EventRegistrationToken *eventCookie);
	virtual STDMETHODIMP _remove_DefinitionChanged(Foundation::EventRegistrationToken eventCookie);
};
template<typename X> struct IStorageLibrary_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IObservableVector<ptr<StorageFolder>>> get() { Foundation::Collections::IObservableVector<StorageFolder*>* value; hrcheck(enc(&IStorageLibrary_adaptor::Folders)->_get_Folders(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IObservableVector<ptr<StorageFolder>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IObservableVector<ptr<StorageFolder>>> () { return get(); }
			ptr<Foundation::Collections::IObservableVector<ptr<StorageFolder>>> operator->() { return get(); }
		} Folders;
		struct : property {
			ptr<StorageFolder> get() { StorageFolder* value; hrcheck(enc(&IStorageLibrary_adaptor::SaveFolder)->_get_SaveFolder(&value)); return from_abi(value); }
			ptr<StorageFolder> operator()() { return get(); }
			operator ptr<StorageFolder> () { return get(); }
			ptr<StorageFolder> operator->() { return get(); }
		} SaveFolder;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<StorageLibrary>, object>> handler) { Foundation::EventRegistrationToken eventCookie; hrcheck(enc(&IStorageLibrary_adaptor::DefinitionChanged)->_add_DefinitionChanged(to_abi(handler), &eventCookie)); return eventCookie; }
			void operator-=(const Foundation::EventRegistrationToken& eventCookie) { hrcheck(enc(&IStorageLibrary_adaptor::DefinitionChanged)->_remove_DefinitionChanged(eventCookie)); }
		} DefinitionChanged;
	};
	ptr<Foundation::IAsyncOperation<ptr<StorageFolder>>> RequestAddFolderAsync() { Foundation::IAsyncOperation<StorageFolder*>* operation; hrcheck(X::get()->_RequestAddFolderAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<bool>> RequestRemoveFolderAsync(pptr<StorageFolder> folder) { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_RequestRemoveFolderAsync(folder, &operation)); return from_abi(operation); }
	IStorageLibrary_adaptor() {}
};
template<typename X> struct adapt<IStorageLibrary, X> : Windows::Storage::IStorageLibrary_adaptor<X> { typedef adapt IStorageLibrary; };
struct IStorageLibrary : IStorageLibrary_raw, generate<IStorageLibrary> {};

// StorageLibrary
template<typename> struct StorageLibrary_statics {
	static ptr<Foundation::IAsyncOperation<ptr<StorageLibrary>>> GetLibraryForUserAsync(pptr<System::User> user, KnownLibraryId libraryId) { Foundation::IAsyncOperation<StorageLibrary*>* operation; hrcheck(get_activation_factory<StorageLibrary, IStorageLibraryStatics2>()->_GetLibraryForUserAsync(user, libraryId, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageLibrary>>> GetLibraryAsync(KnownLibraryId libraryId) { Foundation::IAsyncOperation<StorageLibrary*>* operation; hrcheck(get_activation_factory<StorageLibrary, IStorageLibraryStatics>()->_GetLibraryAsync(libraryId, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<StorageLibrary, X> : X, Windows::Storage::StorageLibrary_statics<void> {
	typedef typename X::root_type StorageLibrary;
};
struct StorageLibrary : generate<StorageLibrary> {};

// IStorageFolderStatics
struct IStorageFolderStatics : IInspectable {
	virtual STDMETHODIMP _GetFolderFromPathAsync(HSTRING path, Foundation::IAsyncOperation<StorageFolder*>* *operation);
};

// IStorageFolder3
struct IStorageFolder3_raw : IInspectable {
	virtual STDMETHODIMP _TryGetChangeTracker(StorageLibraryChangeTracker* *result);
};
template<typename X> struct IStorageFolder3_adaptor : X {
	ptr<StorageLibraryChangeTracker> TryGetChangeTracker() { StorageLibraryChangeTracker* result; hrcheck(X::get()->_TryGetChangeTracker(&result)); return from_abi(result); }
};
template<typename X> struct adapt<IStorageFolder3, X> : Windows::Storage::IStorageFolder3_adaptor<X> { typedef adapt IStorageFolder3; };
struct IStorageFolder3 : IStorageFolder3_raw, generate<IStorageFolder3> {};

// IStorageItemProperties
struct IStorageItemProperties_raw : IInspectable {
	virtual STDMETHODIMP _GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(FileProperties::ThumbnailMode mode, Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* *operation) = 0;
	virtual STDMETHODIMP _GetThumbnailAsyncOverloadDefaultOptions(FileProperties::ThumbnailMode mode, unsigned requestedSize, Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* *operation) = 0;
	virtual STDMETHODIMP _GetThumbnailAsync(FileProperties::ThumbnailMode mode, unsigned requestedSize, FileProperties::ThumbnailOptions options, Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* *operation) = 0;
	virtual STDMETHODIMP _get_DisplayName(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_DisplayType(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_FolderRelativeId(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_Properties(FileProperties::StorageItemContentProperties* *value) = 0;
};
template<typename X> struct IStorageItemProperties_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorageItemProperties_adaptor::DisplayName)->_get_DisplayName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DisplayName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorageItemProperties_adaptor::DisplayType)->_get_DisplayType(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DisplayType;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorageItemProperties_adaptor::FolderRelativeId)->_get_FolderRelativeId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} FolderRelativeId;
		struct : property {
			ptr<FileProperties::StorageItemContentProperties> get() { FileProperties::StorageItemContentProperties* value; hrcheck(enc(&IStorageItemProperties_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<FileProperties::StorageItemContentProperties> operator()() { return get(); }
			operator ptr<FileProperties::StorageItemContentProperties> () { return get(); }
			ptr<FileProperties::StorageItemContentProperties> operator->() { return get(); }
		} Properties;
	};
	ptr<Foundation::IAsyncOperation<ptr<FileProperties::StorageItemThumbnail>>> GetThumbnailAsync(FileProperties::ThumbnailMode mode) { Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* operation; hrcheck(X::get()->_GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(mode, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<FileProperties::StorageItemThumbnail>>> GetThumbnailAsync(FileProperties::ThumbnailMode mode, unsigned requestedSize) { Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* operation; hrcheck(X::get()->_GetThumbnailAsyncOverloadDefaultOptions(mode, requestedSize, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<FileProperties::StorageItemThumbnail>>> GetThumbnailAsync(FileProperties::ThumbnailMode mode, unsigned requestedSize, FileProperties::ThumbnailOptions options) { Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* operation; hrcheck(X::get()->_GetThumbnailAsync(mode, requestedSize, options, &operation)); return from_abi(operation); }
	IStorageItemProperties_adaptor() {}
};
template<typename X> struct adapt<IStorageItemProperties, X> : Windows::Storage::IStorageItemProperties_adaptor<X> { typedef adapt IStorageItemProperties; };
template<typename X> struct IStorageItemProperties_unadaptor : X {
	STDMETHODIMP _GetThumbnailAsyncOverloadDefaultSizeDefaultOptions(FileProperties::ThumbnailMode mode, Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetThumbnailAsync(mode)); }); }
	STDMETHODIMP _GetThumbnailAsyncOverloadDefaultOptions(FileProperties::ThumbnailMode mode, unsigned requestedSize, Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetThumbnailAsync(mode, requestedSize)); }); }
	STDMETHODIMP _GetThumbnailAsync(FileProperties::ThumbnailMode mode, unsigned requestedSize, FileProperties::ThumbnailOptions options, Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetThumbnailAsync(mode, requestedSize, options)); }); }
	STDMETHODIMP _get_DisplayName(HSTRING *value) { return hrtry([&, this] { get_prop(value, DisplayName); }); }
	STDMETHODIMP _get_DisplayType(HSTRING *value) { return hrtry([&, this] { get_prop(value, DisplayType); }); }
	STDMETHODIMP _get_FolderRelativeId(HSTRING *value) { return hrtry([&, this] { get_prop(value, FolderRelativeId); }); }
	STDMETHODIMP _get_Properties(FileProperties::StorageItemContentProperties* *value) { return hrtry([&, this] { get_prop(value, Properties); }); }
};
template<typename X> struct unadapt<IStorageItemProperties, X> : Windows::Storage::IStorageItemProperties_unadaptor<X> {};
struct IStorageItemProperties : IStorageItemProperties_raw, generate<IStorageItemProperties> {};

// IStorageItemPropertiesWithProvider
struct IStorageItemPropertiesWithProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_Provider(StorageProvider* *value) = 0;
};
template<typename X> struct IStorageItemPropertiesWithProvider_adaptor : X {
	union {
		struct : property {
			ptr<StorageProvider> get() { StorageProvider* value; hrcheck(enc(&IStorageItemPropertiesWithProvider_adaptor::Provider)->_get_Provider(&value)); return from_abi(value); }
			ptr<StorageProvider> operator()() { return get(); }
			operator ptr<StorageProvider> () { return get(); }
			ptr<StorageProvider> operator->() { return get(); }
		} Provider;
	};
	IStorageItemPropertiesWithProvider_adaptor() {}
};
template<typename X> struct adapt<IStorageItemPropertiesWithProvider, X> : Windows::Storage::IStorageItemPropertiesWithProvider_adaptor<X> { typedef adapt IStorageItemPropertiesWithProvider; };
template<typename X> struct IStorageItemPropertiesWithProvider_unadaptor : X {
	STDMETHODIMP _get_Provider(StorageProvider* *value) { return hrtry([&, this] { get_prop(value, Provider); }); }
};
template<typename X> struct unadapt<IStorageItemPropertiesWithProvider, X> : Windows::Storage::IStorageItemPropertiesWithProvider_unadaptor<X> {};
struct IStorageItemPropertiesWithProvider : IStorageItemPropertiesWithProvider_raw, generate<IStorageItemPropertiesWithProvider> {};

// IStorageFolder2
struct IStorageFolder2_raw : IInspectable {
	virtual STDMETHODIMP _TryGetItemAsync(HSTRING name, Foundation::IAsyncOperation<IStorageItem*>* *operation) = 0;
};
template<typename X> struct IStorageFolder2_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<IStorageItem>>> TryGetItemAsync(hstring_ref name) { Foundation::IAsyncOperation<IStorageItem*>* operation; hrcheck(X::get()->_TryGetItemAsync(name, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IStorageFolder2, X> : Windows::Storage::IStorageFolder2_adaptor<X> { typedef adapt IStorageFolder2; };
template<typename X> struct IStorageFolder2_unadaptor : X {
	STDMETHODIMP _TryGetItemAsync(HSTRING name, Foundation::IAsyncOperation<IStorageItem*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->TryGetItemAsync(name)); }); }
};
template<typename X> struct unadapt<IStorageFolder2, X> : Windows::Storage::IStorageFolder2_unadaptor<X> {};
struct IStorageFolder2 : IStorageFolder2_raw, generate<IStorageFolder2> {};

// IStorageItem
struct IStorageItem_raw : IInspectable {
	virtual STDMETHODIMP _RenameAsyncOverloadDefaultOptions(HSTRING desiredName, Foundation::IAsyncAction* *operation) = 0;
	virtual STDMETHODIMP _RenameAsync(HSTRING desiredName, NameCollisionOption option, Foundation::IAsyncAction* *operation) = 0;
	virtual STDMETHODIMP _DeleteAsyncOverloadDefaultOptions(Foundation::IAsyncAction* *operation) = 0;
	virtual STDMETHODIMP _DeleteAsync(StorageDeleteOption option, Foundation::IAsyncAction* *operation) = 0;
	virtual STDMETHODIMP _GetBasicPropertiesAsync(Foundation::IAsyncOperation<FileProperties::BasicProperties*>* *operation) = 0;
	virtual STDMETHODIMP _get_Name(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_Path(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_Attributes(FileAttributes *value) = 0;
	virtual STDMETHODIMP _get_DateCreated(Foundation::DateTime *value) = 0;
	virtual STDMETHODIMP _IsOfType(StorageItemTypes type, bool *value) = 0;
};
template<typename X> struct IStorageItem_adaptor : X {
	union {
		struct : property {
			FileAttributes get() { FileAttributes value; hrcheck(enc(&IStorageItem_adaptor::Attributes)->_get_Attributes(&value)); return value; }
			FileAttributes operator()() { return get(); }
			operator FileAttributes () { return get(); }
		} Attributes;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IStorageItem_adaptor::DateCreated)->_get_DateCreated(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} DateCreated;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorageItem_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorageItem_adaptor::Path)->_get_Path(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Path;
	};
	ptr<Foundation::IAsyncAction> RenameAsync(hstring_ref desiredName) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_RenameAsyncOverloadDefaultOptions(desiredName, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> RenameAsync(hstring_ref desiredName, NameCollisionOption option) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_RenameAsync(desiredName, option, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> DeleteAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_DeleteAsyncOverloadDefaultOptions(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> DeleteAsync(StorageDeleteOption option) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_DeleteAsync(option, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<FileProperties::BasicProperties>>> GetBasicPropertiesAsync() { Foundation::IAsyncOperation<FileProperties::BasicProperties*>* operation; hrcheck(X::get()->_GetBasicPropertiesAsync(&operation)); return from_abi(operation); }
	bool IsOfType(StorageItemTypes type) { bool value; hrcheck(X::get()->_IsOfType(type, &value)); return value; }
	IStorageItem_adaptor() {}
};
template<typename X> struct adapt<IStorageItem, X> : Windows::Storage::IStorageItem_adaptor<X> { typedef adapt IStorageItem; };
template<typename X> struct IStorageItem_unadaptor : X {
	STDMETHODIMP _RenameAsyncOverloadDefaultOptions(HSTRING desiredName, Foundation::IAsyncAction* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->RenameAsync(desiredName)); }); }
	STDMETHODIMP _RenameAsync(HSTRING desiredName, NameCollisionOption option, Foundation::IAsyncAction* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->RenameAsync(desiredName, option)); }); }
	STDMETHODIMP _DeleteAsyncOverloadDefaultOptions(Foundation::IAsyncAction* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->DeleteAsync()); }); }
	STDMETHODIMP _DeleteAsync(StorageDeleteOption option, Foundation::IAsyncAction* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->DeleteAsync(option)); }); }
	STDMETHODIMP _GetBasicPropertiesAsync(Foundation::IAsyncOperation<FileProperties::BasicProperties*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetBasicPropertiesAsync()); }); }
	STDMETHODIMP _get_Name(HSTRING *value) { return hrtry([&, this] { get_prop(value, Name); }); }
	STDMETHODIMP _get_Path(HSTRING *value) { return hrtry([&, this] { get_prop(value, Path); }); }
	STDMETHODIMP _get_Attributes(FileAttributes *value) { return hrtry([&, this] { get_prop(value, Attributes); }); }
	STDMETHODIMP _get_DateCreated(Foundation::DateTime *value) { return hrtry([&, this] { get_prop(value, DateCreated); }); }
	STDMETHODIMP _IsOfType(StorageItemTypes type, bool *value) { return hrtry([&, this] { *value = X::get()->IsOfType(type); }); }
};
template<typename X> struct unadapt<IStorageItem, X> : Windows::Storage::IStorageItem_unadaptor<X> {};
struct IStorageItem : IStorageItem_raw, generate<IStorageItem> {};

// IStorageItem2
struct IStorageItem2_raw : IInspectable {
	virtual STDMETHODIMP _GetParentAsync(Foundation::IAsyncOperation<StorageFolder*>* *operation) = 0;
	virtual STDMETHODIMP _IsEqual(IStorageItem* item, bool *value) = 0;
};
template<typename X> struct IStorageItem2_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<StorageFolder>>> GetParentAsync() { Foundation::IAsyncOperation<StorageFolder*>* operation; hrcheck(X::get()->_GetParentAsync(&operation)); return from_abi(operation); }
	bool IsEqual(pptr<IStorageItem> item) { bool value; hrcheck(X::get()->_IsEqual(item, &value)); return value; }
};
template<typename X> struct adapt<IStorageItem2, X> : Windows::Storage::IStorageItem2_adaptor<X> { typedef adapt IStorageItem2; };
template<typename X> struct IStorageItem2_unadaptor : X {
	STDMETHODIMP _GetParentAsync(Foundation::IAsyncOperation<StorageFolder*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetParentAsync()); }); }
	STDMETHODIMP _IsEqual(IStorageItem* item, bool *value) { return hrtry([&, this] { *value = X::get()->IsEqual(item); }); }
};
template<typename X> struct unadapt<IStorageItem2, X> : Windows::Storage::IStorageItem2_unadaptor<X> {};
struct IStorageItem2 : IStorageItem2_raw, generate<IStorageItem2> {};

// IStorageItemProperties2
struct IStorageItemProperties2_raw : IInspectable {
	virtual STDMETHODIMP _GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions(FileProperties::ThumbnailMode mode, Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* *operation) = 0;
	virtual STDMETHODIMP _GetScaledImageAsThumbnailAsyncOverloadDefaultOptions(FileProperties::ThumbnailMode mode, unsigned requestedSize, Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* *operation) = 0;
	virtual STDMETHODIMP _GetScaledImageAsThumbnailAsync(FileProperties::ThumbnailMode mode, unsigned requestedSize, FileProperties::ThumbnailOptions options, Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* *operation) = 0;
};
template<typename X> struct IStorageItemProperties2_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<FileProperties::StorageItemThumbnail>>> GetScaledImageAsThumbnailAsync(FileProperties::ThumbnailMode mode) { Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* operation; hrcheck(X::get()->_GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions(mode, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<FileProperties::StorageItemThumbnail>>> GetScaledImageAsThumbnailAsync(FileProperties::ThumbnailMode mode, unsigned requestedSize) { Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* operation; hrcheck(X::get()->_GetScaledImageAsThumbnailAsyncOverloadDefaultOptions(mode, requestedSize, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<FileProperties::StorageItemThumbnail>>> GetScaledImageAsThumbnailAsync(FileProperties::ThumbnailMode mode, unsigned requestedSize, FileProperties::ThumbnailOptions options) { Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* operation; hrcheck(X::get()->_GetScaledImageAsThumbnailAsync(mode, requestedSize, options, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IStorageItemProperties2, X> : Windows::Storage::IStorageItemProperties2_adaptor<X> { typedef adapt IStorageItemProperties2; };
template<typename X> struct IStorageItemProperties2_unadaptor : X {
	STDMETHODIMP _GetScaledImageAsThumbnailAsyncOverloadDefaultSizeDefaultOptions(FileProperties::ThumbnailMode mode, Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetScaledImageAsThumbnailAsync(mode)); }); }
	STDMETHODIMP _GetScaledImageAsThumbnailAsyncOverloadDefaultOptions(FileProperties::ThumbnailMode mode, unsigned requestedSize, Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetScaledImageAsThumbnailAsync(mode, requestedSize)); }); }
	STDMETHODIMP _GetScaledImageAsThumbnailAsync(FileProperties::ThumbnailMode mode, unsigned requestedSize, FileProperties::ThumbnailOptions options, Foundation::IAsyncOperation<FileProperties::StorageItemThumbnail*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetScaledImageAsThumbnailAsync(mode, requestedSize, options)); }); }
};
template<typename X> struct unadapt<IStorageItemProperties2, X> : Windows::Storage::IStorageItemProperties2_unadaptor<X> {};
struct IStorageItemProperties2 : IStorageItemProperties2_raw, generate<IStorageItemProperties2> {};

// IStorageFolder
struct IStorageFolder_raw : IInspectable {
	virtual STDMETHODIMP _CreateFileAsyncOverloadDefaultOptions(HSTRING desiredName, Foundation::IAsyncOperation<StorageFile*>* *operation) = 0;
	virtual STDMETHODIMP _CreateFileAsync(HSTRING desiredName, CreationCollisionOption options, Foundation::IAsyncOperation<StorageFile*>* *operation) = 0;
	virtual STDMETHODIMP _CreateFolderAsyncOverloadDefaultOptions(HSTRING desiredName, Foundation::IAsyncOperation<StorageFolder*>* *operation) = 0;
	virtual STDMETHODIMP _CreateFolderAsync(HSTRING desiredName, CreationCollisionOption options, Foundation::IAsyncOperation<StorageFolder*>* *operation) = 0;
	virtual STDMETHODIMP _GetFileAsync(HSTRING name, Foundation::IAsyncOperation<StorageFile*>* *operation) = 0;
	virtual STDMETHODIMP _GetFolderAsync(HSTRING name, Foundation::IAsyncOperation<StorageFolder*>* *operation) = 0;
	virtual STDMETHODIMP _GetItemAsync(HSTRING name, Foundation::IAsyncOperation<IStorageItem*>* *operation) = 0;
	virtual STDMETHODIMP _GetFilesAsyncOverloadDefaultOptionsStartAndCount(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFile*>*>* *operation) = 0;
	virtual STDMETHODIMP _GetFoldersAsyncOverloadDefaultOptionsStartAndCount(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFolder*>*>* *operation) = 0;
	virtual STDMETHODIMP _GetItemsAsyncOverloadDefaultStartAndCount(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IStorageItem*>*>* *operation) = 0;
};
template<typename X> struct IStorageFolder_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> CreateFileAsync(hstring_ref desiredName) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(X::get()->_CreateFileAsyncOverloadDefaultOptions(desiredName, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> CreateFileAsync(hstring_ref desiredName, CreationCollisionOption options) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(X::get()->_CreateFileAsync(desiredName, options, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorageFolder>>> CreateFolderAsync(hstring_ref desiredName) { Foundation::IAsyncOperation<StorageFolder*>* operation; hrcheck(X::get()->_CreateFolderAsyncOverloadDefaultOptions(desiredName, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorageFolder>>> CreateFolderAsync(hstring_ref desiredName, CreationCollisionOption options) { Foundation::IAsyncOperation<StorageFolder*>* operation; hrcheck(X::get()->_CreateFolderAsync(desiredName, options, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> GetFileAsync(hstring_ref name) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(X::get()->_GetFileAsync(name, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorageFolder>>> GetFolderAsync(hstring_ref name) { Foundation::IAsyncOperation<StorageFolder*>* operation; hrcheck(X::get()->_GetFolderAsync(name, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<IStorageItem>>> GetItemAsync(hstring_ref name) { Foundation::IAsyncOperation<IStorageItem*>* operation; hrcheck(X::get()->_GetItemAsync(name, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<StorageFile>>>>> GetFilesAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFile*>*>* operation; hrcheck(X::get()->_GetFilesAsyncOverloadDefaultOptionsStartAndCount(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<StorageFolder>>>>> GetFoldersAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFolder*>*>* operation; hrcheck(X::get()->_GetFoldersAsyncOverloadDefaultOptionsStartAndCount(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<IStorageItem>>>>> GetItemsAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IStorageItem*>*>* operation; hrcheck(X::get()->_GetItemsAsyncOverloadDefaultStartAndCount(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IStorageFolder, X> : Windows::Storage::IStorageFolder_adaptor<X> { typedef adapt IStorageFolder; };
template<typename X> struct IStorageFolder_unadaptor : X {
	STDMETHODIMP _CreateFileAsyncOverloadDefaultOptions(HSTRING desiredName, Foundation::IAsyncOperation<StorageFile*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->CreateFileAsync(desiredName)); }); }
	STDMETHODIMP _CreateFileAsync(HSTRING desiredName, CreationCollisionOption options, Foundation::IAsyncOperation<StorageFile*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->CreateFileAsync(desiredName, options)); }); }
	STDMETHODIMP _CreateFolderAsyncOverloadDefaultOptions(HSTRING desiredName, Foundation::IAsyncOperation<StorageFolder*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->CreateFolderAsync(desiredName)); }); }
	STDMETHODIMP _CreateFolderAsync(HSTRING desiredName, CreationCollisionOption options, Foundation::IAsyncOperation<StorageFolder*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->CreateFolderAsync(desiredName, options)); }); }
	STDMETHODIMP _GetFileAsync(HSTRING name, Foundation::IAsyncOperation<StorageFile*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetFileAsync(name)); }); }
	STDMETHODIMP _GetFolderAsync(HSTRING name, Foundation::IAsyncOperation<StorageFolder*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetFolderAsync(name)); }); }
	STDMETHODIMP _GetItemAsync(HSTRING name, Foundation::IAsyncOperation<IStorageItem*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetItemAsync(name)); }); }
	STDMETHODIMP _GetFilesAsyncOverloadDefaultOptionsStartAndCount(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFile*>*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetFilesAsync()); }); }
	STDMETHODIMP _GetFoldersAsyncOverloadDefaultOptionsStartAndCount(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageFolder*>*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetFoldersAsync()); }); }
	STDMETHODIMP _GetItemsAsyncOverloadDefaultStartAndCount(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<IStorageItem*>*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->GetItemsAsync()); }); }
};
template<typename X> struct unadapt<IStorageFolder, X> : Windows::Storage::IStorageFolder_unadaptor<X> {};
struct IStorageFolder : IStorageFolder_raw, generate<IStorageFolder> {};

// StorageFolder
template<typename> struct StorageFolder_statics {
	static ptr<Foundation::IAsyncOperation<ptr<StorageFolder>>> GetFolderFromPathAsync(hstring_ref path) { Foundation::IAsyncOperation<StorageFolder*>* operation; hrcheck(get_activation_factory<StorageFolder, IStorageFolderStatics>()->_GetFolderFromPathAsync(path, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<StorageFolder, X> : X, Windows::Storage::StorageFolder_statics<void> {
	typedef typename X::root_type StorageFolder;
};
struct StorageFolder : generate<StorageFolder> {
	using IStorageFolder::GetFilesAsync;
	using IStorageFolderQueryOperations::GetFilesAsync;
	using IStorageItemProperties2::GetScaledImageAsThumbnailAsync;
	using IStorageFolder::CreateFolderAsync;
	using IStorageItemProperties::GetThumbnailAsync;
	using IStorageItem::DeleteAsync;
	using IStorageFolder::CreateFileAsync;
	using IStorageFolderQueryOperations::CreateFileQuery;
	using IStorageFolder::GetFoldersAsync;
	using IStorageFolderQueryOperations::GetFoldersAsync;
	using IStorageFolder::GetItemsAsync;
	using IStorageFolderQueryOperations::GetItemsAsync;
	using IStorageItem::RenameAsync;
	using IStorageFolderQueryOperations::CreateFolderQuery;
};

// IStorageLibraryChangeTracker
struct IStorageLibraryChangeTracker_raw : IInspectable {
	virtual STDMETHODIMP _GetChangeReader(StorageLibraryChangeReader* *value);
	virtual STDMETHODIMP _Enable();
	virtual STDMETHODIMP _Reset();
};
template<typename X> struct IStorageLibraryChangeTracker_adaptor : X {
	ptr<StorageLibraryChangeReader> GetChangeReader() { StorageLibraryChangeReader* value; hrcheck(X::get()->_GetChangeReader(&value)); return from_abi(value); }
	void Enable() { hrcheck(X::get()->_Enable()); }
	void Reset() { hrcheck(X::get()->_Reset()); }
};
template<typename X> struct adapt<IStorageLibraryChangeTracker, X> : Windows::Storage::IStorageLibraryChangeTracker_adaptor<X> { typedef adapt IStorageLibraryChangeTracker; };
struct IStorageLibraryChangeTracker : IStorageLibraryChangeTracker_raw, generate<IStorageLibraryChangeTracker> {};

// StorageLibraryChangeTracker
template<typename X> struct statics<StorageLibraryChangeTracker, X> : X {
	typedef typename X::root_type StorageLibraryChangeTracker;
};
struct StorageLibraryChangeTracker : generate<StorageLibraryChangeTracker> {};

// IKnownFoldersStatics
struct IKnownFoldersStatics : IInspectable {
	virtual STDMETHODIMP _get_MusicLibrary(StorageFolder* *value);
	virtual STDMETHODIMP _get_PicturesLibrary(StorageFolder* *value);
	virtual STDMETHODIMP _get_VideosLibrary(StorageFolder* *value);
	virtual STDMETHODIMP _get_DocumentsLibrary(StorageFolder* *value);
	virtual STDMETHODIMP _get_HomeGroup(StorageFolder* *value);
	virtual STDMETHODIMP _get_RemovableDevices(StorageFolder* *value);
	virtual STDMETHODIMP _get_MediaServerDevices(StorageFolder* *value);
};

// IKnownFoldersStatics2
struct IKnownFoldersStatics2 : IInspectable {
	virtual STDMETHODIMP _get_Objects3D(StorageFolder* *value);
	virtual STDMETHODIMP _get_AppCaptures(StorageFolder* *value);
	virtual STDMETHODIMP _get_RecordedCalls(StorageFolder* *value);
};

// IKnownFoldersStatics3
struct IKnownFoldersStatics3 : IInspectable {
	virtual STDMETHODIMP _GetFolderForUserAsync(System::User* user, KnownFolderId folderId, Foundation::IAsyncOperation<StorageFolder*>* *operation);
};

// IKnownFoldersPlaylistsStatics
struct IKnownFoldersPlaylistsStatics : IInspectable {
	virtual STDMETHODIMP _get_Playlists(StorageFolder* *value);
};

// IKnownFoldersCameraRollStatics
struct IKnownFoldersCameraRollStatics : IInspectable {
	virtual STDMETHODIMP _get_CameraRoll(StorageFolder* *value);
};

// IKnownFoldersSavedPicturesStatics
struct IKnownFoldersSavedPicturesStatics : IInspectable {
	virtual STDMETHODIMP _get_SavedPictures(StorageFolder* *value);
};

// KnownFolders
template<typename> struct KnownFolders_statics {
	static struct _DocumentsLibrary : property {
		ptr<StorageFolder> get() { StorageFolder* value; hrcheck(get_activation_factory<KnownFolders, IKnownFoldersStatics>()->_get_DocumentsLibrary(&value)); return from_abi(value); }
		ptr<StorageFolder> operator()() { return get(); }
		operator ptr<StorageFolder> () { return get(); }
		ptr<StorageFolder> operator->() { return get(); }
	} DocumentsLibrary;
	static struct _HomeGroup : property {
		ptr<StorageFolder> get() { StorageFolder* value; hrcheck(get_activation_factory<KnownFolders, IKnownFoldersStatics>()->_get_HomeGroup(&value)); return from_abi(value); }
		ptr<StorageFolder> operator()() { return get(); }
		operator ptr<StorageFolder> () { return get(); }
		ptr<StorageFolder> operator->() { return get(); }
	} HomeGroup;
	static struct _MediaServerDevices : property {
		ptr<StorageFolder> get() { StorageFolder* value; hrcheck(get_activation_factory<KnownFolders, IKnownFoldersStatics>()->_get_MediaServerDevices(&value)); return from_abi(value); }
		ptr<StorageFolder> operator()() { return get(); }
		operator ptr<StorageFolder> () { return get(); }
		ptr<StorageFolder> operator->() { return get(); }
	} MediaServerDevices;
	static struct _MusicLibrary : property {
		ptr<StorageFolder> get() { StorageFolder* value; hrcheck(get_activation_factory<KnownFolders, IKnownFoldersStatics>()->_get_MusicLibrary(&value)); return from_abi(value); }
		ptr<StorageFolder> operator()() { return get(); }
		operator ptr<StorageFolder> () { return get(); }
		ptr<StorageFolder> operator->() { return get(); }
	} MusicLibrary;
	static struct _PicturesLibrary : property {
		ptr<StorageFolder> get() { StorageFolder* value; hrcheck(get_activation_factory<KnownFolders, IKnownFoldersStatics>()->_get_PicturesLibrary(&value)); return from_abi(value); }
		ptr<StorageFolder> operator()() { return get(); }
		operator ptr<StorageFolder> () { return get(); }
		ptr<StorageFolder> operator->() { return get(); }
	} PicturesLibrary;
	static struct _RemovableDevices : property {
		ptr<StorageFolder> get() { StorageFolder* value; hrcheck(get_activation_factory<KnownFolders, IKnownFoldersStatics>()->_get_RemovableDevices(&value)); return from_abi(value); }
		ptr<StorageFolder> operator()() { return get(); }
		operator ptr<StorageFolder> () { return get(); }
		ptr<StorageFolder> operator->() { return get(); }
	} RemovableDevices;
	static struct _VideosLibrary : property {
		ptr<StorageFolder> get() { StorageFolder* value; hrcheck(get_activation_factory<KnownFolders, IKnownFoldersStatics>()->_get_VideosLibrary(&value)); return from_abi(value); }
		ptr<StorageFolder> operator()() { return get(); }
		operator ptr<StorageFolder> () { return get(); }
		ptr<StorageFolder> operator->() { return get(); }
	} VideosLibrary;
	static struct _AppCaptures : property {
		ptr<StorageFolder> get() { StorageFolder* value; hrcheck(get_activation_factory<KnownFolders, IKnownFoldersStatics2>()->_get_AppCaptures(&value)); return from_abi(value); }
		ptr<StorageFolder> operator()() { return get(); }
		operator ptr<StorageFolder> () { return get(); }
		ptr<StorageFolder> operator->() { return get(); }
	} AppCaptures;
	static struct _Objects3D : property {
		ptr<StorageFolder> get() { StorageFolder* value; hrcheck(get_activation_factory<KnownFolders, IKnownFoldersStatics2>()->_get_Objects3D(&value)); return from_abi(value); }
		ptr<StorageFolder> operator()() { return get(); }
		operator ptr<StorageFolder> () { return get(); }
		ptr<StorageFolder> operator->() { return get(); }
	} Objects3D;
	static struct _RecordedCalls : property {
		ptr<StorageFolder> get() { StorageFolder* value; hrcheck(get_activation_factory<KnownFolders, IKnownFoldersStatics2>()->_get_RecordedCalls(&value)); return from_abi(value); }
		ptr<StorageFolder> operator()() { return get(); }
		operator ptr<StorageFolder> () { return get(); }
		ptr<StorageFolder> operator->() { return get(); }
	} RecordedCalls;
	static struct _Playlists : property {
		ptr<StorageFolder> get() { StorageFolder* value; hrcheck(get_activation_factory<KnownFolders, IKnownFoldersPlaylistsStatics>()->_get_Playlists(&value)); return from_abi(value); }
		ptr<StorageFolder> operator()() { return get(); }
		operator ptr<StorageFolder> () { return get(); }
		ptr<StorageFolder> operator->() { return get(); }
	} Playlists;
	static struct _CameraRoll : property {
		ptr<StorageFolder> get() { StorageFolder* value; hrcheck(get_activation_factory<KnownFolders, IKnownFoldersCameraRollStatics>()->_get_CameraRoll(&value)); return from_abi(value); }
		ptr<StorageFolder> operator()() { return get(); }
		operator ptr<StorageFolder> () { return get(); }
		ptr<StorageFolder> operator->() { return get(); }
	} CameraRoll;
	static struct _SavedPictures : property {
		ptr<StorageFolder> get() { StorageFolder* value; hrcheck(get_activation_factory<KnownFolders, IKnownFoldersSavedPicturesStatics>()->_get_SavedPictures(&value)); return from_abi(value); }
		ptr<StorageFolder> operator()() { return get(); }
		operator ptr<StorageFolder> () { return get(); }
		ptr<StorageFolder> operator->() { return get(); }
	} SavedPictures;
	static ptr<Foundation::IAsyncOperation<ptr<StorageFolder>>> GetFolderForUserAsync(pptr<System::User> user, KnownFolderId folderId) { Foundation::IAsyncOperation<StorageFolder*>* operation; hrcheck(get_activation_factory<KnownFolders, IKnownFoldersStatics3>()->_GetFolderForUserAsync(user, folderId, &operation)); return from_abi(operation); }
};
template<typename X> typename KnownFolders_statics<X>::_DocumentsLibrary KnownFolders_statics<X>::DocumentsLibrary;
template<typename X> typename KnownFolders_statics<X>::_HomeGroup KnownFolders_statics<X>::HomeGroup;
template<typename X> typename KnownFolders_statics<X>::_MediaServerDevices KnownFolders_statics<X>::MediaServerDevices;
template<typename X> typename KnownFolders_statics<X>::_MusicLibrary KnownFolders_statics<X>::MusicLibrary;
template<typename X> typename KnownFolders_statics<X>::_PicturesLibrary KnownFolders_statics<X>::PicturesLibrary;
template<typename X> typename KnownFolders_statics<X>::_RemovableDevices KnownFolders_statics<X>::RemovableDevices;
template<typename X> typename KnownFolders_statics<X>::_VideosLibrary KnownFolders_statics<X>::VideosLibrary;
template<typename X> typename KnownFolders_statics<X>::_AppCaptures KnownFolders_statics<X>::AppCaptures;
template<typename X> typename KnownFolders_statics<X>::_Objects3D KnownFolders_statics<X>::Objects3D;
template<typename X> typename KnownFolders_statics<X>::_RecordedCalls KnownFolders_statics<X>::RecordedCalls;
template<typename X> typename KnownFolders_statics<X>::_Playlists KnownFolders_statics<X>::Playlists;
template<typename X> typename KnownFolders_statics<X>::_CameraRoll KnownFolders_statics<X>::CameraRoll;
template<typename X> typename KnownFolders_statics<X>::_SavedPictures KnownFolders_statics<X>::SavedPictures;

template<typename X> struct statics<KnownFolders, X> : X, Windows::Storage::KnownFolders_statics<void> {
	typedef typename X::root_type KnownFolders;
};
struct KnownFolders : generate<KnownFolders> {};

// IUserDataPathsStatics
struct IUserDataPathsStatics : IInspectable {
	virtual STDMETHODIMP _GetForUser(System::User* user, UserDataPaths* *result);
	virtual STDMETHODIMP _GetDefault(UserDataPaths* *result);
};

// IUserDataPaths
struct IUserDataPaths_raw : IInspectable {
	virtual STDMETHODIMP _get_CameraRoll(HSTRING *value);
	virtual STDMETHODIMP _get_Cookies(HSTRING *value);
	virtual STDMETHODIMP _get_Desktop(HSTRING *value);
	virtual STDMETHODIMP _get_Documents(HSTRING *value);
	virtual STDMETHODIMP _get_Downloads(HSTRING *value);
	virtual STDMETHODIMP _get_Favorites(HSTRING *value);
	virtual STDMETHODIMP _get_History(HSTRING *value);
	virtual STDMETHODIMP _get_InternetCache(HSTRING *value);
	virtual STDMETHODIMP _get_LocalAppData(HSTRING *value);
	virtual STDMETHODIMP _get_LocalAppDataLow(HSTRING *value);
	virtual STDMETHODIMP _get_Music(HSTRING *value);
	virtual STDMETHODIMP _get_Pictures(HSTRING *value);
	virtual STDMETHODIMP _get_Profile(HSTRING *value);
	virtual STDMETHODIMP _get_Recent(HSTRING *value);
	virtual STDMETHODIMP _get_RoamingAppData(HSTRING *value);
	virtual STDMETHODIMP _get_SavedPictures(HSTRING *value);
	virtual STDMETHODIMP _get_Screenshots(HSTRING *value);
	virtual STDMETHODIMP _get_Templates(HSTRING *value);
	virtual STDMETHODIMP _get_Videos(HSTRING *value);
};
template<typename X> struct IUserDataPaths_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::CameraRoll)->_get_CameraRoll(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} CameraRoll;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::Cookies)->_get_Cookies(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Cookies;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::Desktop)->_get_Desktop(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Desktop;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::Documents)->_get_Documents(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Documents;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::Downloads)->_get_Downloads(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Downloads;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::Favorites)->_get_Favorites(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Favorites;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::History)->_get_History(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} History;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::InternetCache)->_get_InternetCache(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} InternetCache;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::LocalAppData)->_get_LocalAppData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} LocalAppData;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::LocalAppDataLow)->_get_LocalAppDataLow(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} LocalAppDataLow;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::Music)->_get_Music(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Music;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::Pictures)->_get_Pictures(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Pictures;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::Profile)->_get_Profile(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Profile;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::Recent)->_get_Recent(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Recent;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::RoamingAppData)->_get_RoamingAppData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} RoamingAppData;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::SavedPictures)->_get_SavedPictures(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} SavedPictures;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::Screenshots)->_get_Screenshots(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Screenshots;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::Templates)->_get_Templates(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Templates;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IUserDataPaths_adaptor::Videos)->_get_Videos(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Videos;
	};
	IUserDataPaths_adaptor() {}
};
template<typename X> struct adapt<IUserDataPaths, X> : Windows::Storage::IUserDataPaths_adaptor<X> { typedef adapt IUserDataPaths; };
struct IUserDataPaths : IUserDataPaths_raw, generate<IUserDataPaths> {};

// UserDataPaths
template<typename> struct UserDataPaths_statics {
	static ptr<UserDataPaths> GetForUser(pptr<System::User> user) { UserDataPaths* result; hrcheck(get_activation_factory<UserDataPaths, IUserDataPathsStatics>()->_GetForUser(user, &result)); return from_abi(result); }
	static ptr<UserDataPaths> GetDefault() { UserDataPaths* result; hrcheck(get_activation_factory<UserDataPaths, IUserDataPathsStatics>()->_GetDefault(&result)); return from_abi(result); }
};

template<typename X> struct statics<UserDataPaths, X> : X, Windows::Storage::UserDataPaths_statics<void> {
	typedef typename X::root_type UserDataPaths;
};
struct UserDataPaths : generate<UserDataPaths> {};

// IAppDataPathsStatics
struct IAppDataPathsStatics : IInspectable {
	virtual STDMETHODIMP _GetForUser(System::User* user, AppDataPaths* *result);
	virtual STDMETHODIMP _GetDefault(AppDataPaths* *result);
};

// IAppDataPaths
struct IAppDataPaths_raw : IInspectable {
	virtual STDMETHODIMP _get_Cookies(HSTRING *value);
	virtual STDMETHODIMP _get_Desktop(HSTRING *value);
	virtual STDMETHODIMP _get_Documents(HSTRING *value);
	virtual STDMETHODIMP _get_Favorites(HSTRING *value);
	virtual STDMETHODIMP _get_History(HSTRING *value);
	virtual STDMETHODIMP _get_InternetCache(HSTRING *value);
	virtual STDMETHODIMP _get_LocalAppData(HSTRING *value);
	virtual STDMETHODIMP _get_ProgramData(HSTRING *value);
	virtual STDMETHODIMP _get_RoamingAppData(HSTRING *value);
};
template<typename X> struct IAppDataPaths_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppDataPaths_adaptor::Cookies)->_get_Cookies(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Cookies;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppDataPaths_adaptor::Desktop)->_get_Desktop(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Desktop;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppDataPaths_adaptor::Documents)->_get_Documents(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Documents;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppDataPaths_adaptor::Favorites)->_get_Favorites(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Favorites;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppDataPaths_adaptor::History)->_get_History(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} History;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppDataPaths_adaptor::InternetCache)->_get_InternetCache(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} InternetCache;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppDataPaths_adaptor::LocalAppData)->_get_LocalAppData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} LocalAppData;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppDataPaths_adaptor::ProgramData)->_get_ProgramData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ProgramData;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppDataPaths_adaptor::RoamingAppData)->_get_RoamingAppData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} RoamingAppData;
	};
	IAppDataPaths_adaptor() {}
};
template<typename X> struct adapt<IAppDataPaths, X> : Windows::Storage::IAppDataPaths_adaptor<X> { typedef adapt IAppDataPaths; };
struct IAppDataPaths : IAppDataPaths_raw, generate<IAppDataPaths> {};

// AppDataPaths
template<typename> struct AppDataPaths_statics {
	static ptr<AppDataPaths> GetForUser(pptr<System::User> user) { AppDataPaths* result; hrcheck(get_activation_factory<AppDataPaths, IAppDataPathsStatics>()->_GetForUser(user, &result)); return from_abi(result); }
	static ptr<AppDataPaths> GetDefault() { AppDataPaths* result; hrcheck(get_activation_factory<AppDataPaths, IAppDataPathsStatics>()->_GetDefault(&result)); return from_abi(result); }
};

template<typename X> struct statics<AppDataPaths, X> : X, Windows::Storage::AppDataPaths_statics<void> {
	typedef typename X::root_type AppDataPaths;
};
struct AppDataPaths : generate<AppDataPaths> {};

// ISystemDataPathsStatics
struct ISystemDataPathsStatics : IInspectable {
	virtual STDMETHODIMP _GetDefault(SystemDataPaths* *result);
};

// ISystemDataPaths
struct ISystemDataPaths_raw : IInspectable {
	virtual STDMETHODIMP _get_Fonts(HSTRING *value);
	virtual STDMETHODIMP _get_ProgramData(HSTRING *value);
	virtual STDMETHODIMP _get_Public(HSTRING *value);
	virtual STDMETHODIMP _get_PublicDesktop(HSTRING *value);
	virtual STDMETHODIMP _get_PublicDocuments(HSTRING *value);
	virtual STDMETHODIMP _get_PublicDownloads(HSTRING *value);
	virtual STDMETHODIMP _get_PublicMusic(HSTRING *value);
	virtual STDMETHODIMP _get_PublicPictures(HSTRING *value);
	virtual STDMETHODIMP _get_PublicVideos(HSTRING *value);
	virtual STDMETHODIMP _get_System(HSTRING *value);
	virtual STDMETHODIMP _get_SystemHost(HSTRING *value);
	virtual STDMETHODIMP _get_SystemX86(HSTRING *value);
	virtual STDMETHODIMP _get_SystemX64(HSTRING *value);
	virtual STDMETHODIMP _get_SystemArm(HSTRING *value);
	virtual STDMETHODIMP _get_UserProfiles(HSTRING *value);
	virtual STDMETHODIMP _get_Windows(HSTRING *value);
};
template<typename X> struct ISystemDataPaths_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::Fonts)->_get_Fonts(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Fonts;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::ProgramData)->_get_ProgramData(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ProgramData;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::Public)->_get_Public(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Public;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::PublicDesktop)->_get_PublicDesktop(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PublicDesktop;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::PublicDocuments)->_get_PublicDocuments(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PublicDocuments;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::PublicDownloads)->_get_PublicDownloads(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PublicDownloads;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::PublicMusic)->_get_PublicMusic(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PublicMusic;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::PublicPictures)->_get_PublicPictures(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PublicPictures;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::PublicVideos)->_get_PublicVideos(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PublicVideos;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::System)->_get_System(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} System;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::SystemArm)->_get_SystemArm(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} SystemArm;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::SystemHost)->_get_SystemHost(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} SystemHost;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::SystemX64)->_get_SystemX64(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} SystemX64;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::SystemX86)->_get_SystemX86(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} SystemX86;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::UserProfiles)->_get_UserProfiles(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} UserProfiles;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemDataPaths_adaptor::Windows)->_get_Windows(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Windows;
	};
	ISystemDataPaths_adaptor() {}
};
template<typename X> struct adapt<ISystemDataPaths, X> : Windows::Storage::ISystemDataPaths_adaptor<X> { typedef adapt ISystemDataPaths; };
struct ISystemDataPaths : ISystemDataPaths_raw, generate<ISystemDataPaths> {};

// SystemDataPaths
template<typename> struct SystemDataPaths_statics {
	static ptr<SystemDataPaths> GetDefault() { SystemDataPaths* result; hrcheck(get_activation_factory<SystemDataPaths, ISystemDataPathsStatics>()->_GetDefault(&result)); return from_abi(result); }
};

template<typename X> struct statics<SystemDataPaths, X> : X, Windows::Storage::SystemDataPaths_statics<void> {
	typedef typename X::root_type SystemDataPaths;
};
struct SystemDataPaths : generate<SystemDataPaths> {};

// IDownloadsFolderStatics
struct IDownloadsFolderStatics : IInspectable {
	virtual STDMETHODIMP _CreateFileAsync(HSTRING desiredName, Foundation::IAsyncOperation<StorageFile*>* *operation);
	virtual STDMETHODIMP _CreateFolderAsync(HSTRING desiredName, Foundation::IAsyncOperation<StorageFolder*>* *operation);
	virtual STDMETHODIMP _CreateFileWithCollisionOptionAsync(HSTRING desiredName, CreationCollisionOption option, Foundation::IAsyncOperation<StorageFile*>* *operation);
	virtual STDMETHODIMP _CreateFolderWithCollisionOptionAsync(HSTRING desiredName, CreationCollisionOption option, Foundation::IAsyncOperation<StorageFolder*>* *operation);
};

// IStorageFileStatics
struct IStorageFileStatics : IInspectable {
	virtual STDMETHODIMP _GetFileFromPathAsync(HSTRING path, Foundation::IAsyncOperation<StorageFile*>* *operation);
	virtual STDMETHODIMP _GetFileFromApplicationUriAsync(Foundation::Uri* uri, Foundation::IAsyncOperation<StorageFile*>* *operation);
	virtual STDMETHODIMP _CreateStreamedFileAsync(HSTRING displayNameWithExtension, StreamedFileDataRequestedHandler* dataRequested, Streams::IRandomAccessStreamReference* thumbnail, Foundation::IAsyncOperation<StorageFile*>* *operation);
	virtual STDMETHODIMP _ReplaceWithStreamedFileAsync(IStorageFile* fileToReplace, StreamedFileDataRequestedHandler* dataRequested, Streams::IRandomAccessStreamReference* thumbnail, Foundation::IAsyncOperation<StorageFile*>* *operation);
	virtual STDMETHODIMP _CreateStreamedFileFromUriAsync(HSTRING displayNameWithExtension, Foundation::Uri* uri, Streams::IRandomAccessStreamReference* thumbnail, Foundation::IAsyncOperation<StorageFile*>* *operation);
	virtual STDMETHODIMP _ReplaceWithStreamedFileFromUriAsync(IStorageFile* fileToReplace, Foundation::Uri* uri, Streams::IRandomAccessStreamReference* thumbnail, Foundation::IAsyncOperation<StorageFile*>* *operation);
};

// IStorageFile2
struct IStorageFile2_raw : IInspectable {
	virtual STDMETHODIMP _OpenWithOptionsAsync(FileAccessMode accessMode, StorageOpenOptions options, Foundation::IAsyncOperation<Streams::IRandomAccessStream*>* *operation) = 0;
	virtual STDMETHODIMP _OpenTransactedWriteWithOptionsAsync(StorageOpenOptions options, Foundation::IAsyncOperation<StorageStreamTransaction*>* *operation) = 0;
};
template<typename X> struct IStorageFile2_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<Streams::IRandomAccessStream>>> OpenAsync(FileAccessMode accessMode, StorageOpenOptions options) { Foundation::IAsyncOperation<Streams::IRandomAccessStream*>* operation; hrcheck(X::get()->_OpenWithOptionsAsync(accessMode, options, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorageStreamTransaction>>> OpenTransactedWriteAsync(StorageOpenOptions options) { Foundation::IAsyncOperation<StorageStreamTransaction*>* operation; hrcheck(X::get()->_OpenTransactedWriteWithOptionsAsync(options, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IStorageFile2, X> : Windows::Storage::IStorageFile2_adaptor<X> { typedef adapt IStorageFile2; };
template<typename X> struct IStorageFile2_unadaptor : X {
	STDMETHODIMP _OpenWithOptionsAsync(FileAccessMode accessMode, StorageOpenOptions options, Foundation::IAsyncOperation<Streams::IRandomAccessStream*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->OpenAsync(accessMode, options)); }); }
	STDMETHODIMP _OpenTransactedWriteWithOptionsAsync(StorageOpenOptions options, Foundation::IAsyncOperation<StorageStreamTransaction*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->OpenTransactedWriteAsync(options)); }); }
};
template<typename X> struct unadapt<IStorageFile2, X> : Windows::Storage::IStorageFile2_unadaptor<X> {};
struct IStorageFile2 : IStorageFile2_raw, generate<IStorageFile2> {};

// IStorageFilePropertiesWithAvailability
struct IStorageFilePropertiesWithAvailability_raw : IInspectable {
	virtual STDMETHODIMP _get_IsAvailable(bool *value) = 0;
};
template<typename X> struct IStorageFilePropertiesWithAvailability_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IStorageFilePropertiesWithAvailability_adaptor::IsAvailable)->_get_IsAvailable(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsAvailable;
	};
	IStorageFilePropertiesWithAvailability_adaptor() {}
};
template<typename X> struct adapt<IStorageFilePropertiesWithAvailability, X> : Windows::Storage::IStorageFilePropertiesWithAvailability_adaptor<X> { typedef adapt IStorageFilePropertiesWithAvailability; };
template<typename X> struct IStorageFilePropertiesWithAvailability_unadaptor : X {
	STDMETHODIMP _get_IsAvailable(bool *value) { return hrtry([&, this] { get_prop(value, IsAvailable); }); }
};
template<typename X> struct unadapt<IStorageFilePropertiesWithAvailability, X> : Windows::Storage::IStorageFilePropertiesWithAvailability_unadaptor<X> {};
struct IStorageFilePropertiesWithAvailability : IStorageFilePropertiesWithAvailability_raw, generate<IStorageFilePropertiesWithAvailability> {};

// IStorageFile
struct IStorageFile_raw : IInspectable {
	virtual STDMETHODIMP _get_FileType(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_ContentType(HSTRING *value) = 0;
	virtual STDMETHODIMP _OpenAsync(FileAccessMode accessMode, Foundation::IAsyncOperation<Streams::IRandomAccessStream*>* *operation) = 0;
	virtual STDMETHODIMP _OpenTransactedWriteAsync(Foundation::IAsyncOperation<StorageStreamTransaction*>* *operation) = 0;
	virtual STDMETHODIMP _CopyOverloadDefaultNameAndOptions(IStorageFolder* destinationFolder, Foundation::IAsyncOperation<StorageFile*>* *operation) = 0;
	virtual STDMETHODIMP _CopyOverloadDefaultOptions(IStorageFolder* destinationFolder, HSTRING desiredNewName, Foundation::IAsyncOperation<StorageFile*>* *operation) = 0;
	virtual STDMETHODIMP _CopyOverload(IStorageFolder* destinationFolder, HSTRING desiredNewName, NameCollisionOption option, Foundation::IAsyncOperation<StorageFile*>* *operation) = 0;
	virtual STDMETHODIMP _CopyAndReplaceAsync(IStorageFile* fileToReplace, Foundation::IAsyncAction* *operation) = 0;
	virtual STDMETHODIMP _MoveOverloadDefaultNameAndOptions(IStorageFolder* destinationFolder, Foundation::IAsyncAction* *operation) = 0;
	virtual STDMETHODIMP _MoveOverloadDefaultOptions(IStorageFolder* destinationFolder, HSTRING desiredNewName, Foundation::IAsyncAction* *operation) = 0;
	virtual STDMETHODIMP _MoveOverload(IStorageFolder* destinationFolder, HSTRING desiredNewName, NameCollisionOption option, Foundation::IAsyncAction* *operation) = 0;
	virtual STDMETHODIMP _MoveAndReplaceAsync(IStorageFile* fileToReplace, Foundation::IAsyncAction* *operation) = 0;
};
template<typename X> struct IStorageFile_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorageFile_adaptor::ContentType)->_get_ContentType(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ContentType;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorageFile_adaptor::FileType)->_get_FileType(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} FileType;
	};
	ptr<Foundation::IAsyncOperation<ptr<Streams::IRandomAccessStream>>> OpenAsync(FileAccessMode accessMode) { Foundation::IAsyncOperation<Streams::IRandomAccessStream*>* operation; hrcheck(X::get()->_OpenAsync(accessMode, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorageStreamTransaction>>> OpenTransactedWriteAsync() { Foundation::IAsyncOperation<StorageStreamTransaction*>* operation; hrcheck(X::get()->_OpenTransactedWriteAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> CopyAsync(pptr<IStorageFolder> destinationFolder) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(X::get()->_CopyOverloadDefaultNameAndOptions(destinationFolder, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> CopyAsync(pptr<IStorageFolder> destinationFolder, hstring_ref desiredNewName) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(X::get()->_CopyOverloadDefaultOptions(destinationFolder, desiredNewName, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> CopyAsync(pptr<IStorageFolder> destinationFolder, hstring_ref desiredNewName, NameCollisionOption option) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(X::get()->_CopyOverload(destinationFolder, desiredNewName, option, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> CopyAndReplaceAsync(pptr<IStorageFile> fileToReplace) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_CopyAndReplaceAsync(fileToReplace, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> MoveAsync(pptr<IStorageFolder> destinationFolder) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_MoveOverloadDefaultNameAndOptions(destinationFolder, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> MoveAsync(pptr<IStorageFolder> destinationFolder, hstring_ref desiredNewName) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_MoveOverloadDefaultOptions(destinationFolder, desiredNewName, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> MoveAsync(pptr<IStorageFolder> destinationFolder, hstring_ref desiredNewName, NameCollisionOption option) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_MoveOverload(destinationFolder, desiredNewName, option, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> MoveAndReplaceAsync(pptr<IStorageFile> fileToReplace) { Foundation::IAsyncAction* operation; hrcheck(X::get()->_MoveAndReplaceAsync(fileToReplace, &operation)); return from_abi(operation); }
	IStorageFile_adaptor() {}
};
template<typename X> struct adapt<IStorageFile, X> : Windows::Storage::IStorageFile_adaptor<X> { typedef adapt IStorageFile; };
template<typename X> struct IStorageFile_unadaptor : X {
	STDMETHODIMP _get_FileType(HSTRING *value) { return hrtry([&, this] { get_prop(value, FileType); }); }
	STDMETHODIMP _get_ContentType(HSTRING *value) { return hrtry([&, this] { get_prop(value, ContentType); }); }
	STDMETHODIMP _OpenAsync(FileAccessMode accessMode, Foundation::IAsyncOperation<Streams::IRandomAccessStream*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->OpenAsync(accessMode)); }); }
	STDMETHODIMP _OpenTransactedWriteAsync(Foundation::IAsyncOperation<StorageStreamTransaction*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->OpenTransactedWriteAsync()); }); }
	STDMETHODIMP _CopyOverloadDefaultNameAndOptions(IStorageFolder* destinationFolder, Foundation::IAsyncOperation<StorageFile*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->CopyAsync(destinationFolder)); }); }
	STDMETHODIMP _CopyOverloadDefaultOptions(IStorageFolder* destinationFolder, HSTRING desiredNewName, Foundation::IAsyncOperation<StorageFile*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->CopyAsync(destinationFolder, desiredNewName)); }); }
	STDMETHODIMP _CopyOverload(IStorageFolder* destinationFolder, HSTRING desiredNewName, NameCollisionOption option, Foundation::IAsyncOperation<StorageFile*>* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->CopyAsync(destinationFolder, desiredNewName, option)); }); }
	STDMETHODIMP _CopyAndReplaceAsync(IStorageFile* fileToReplace, Foundation::IAsyncAction* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->CopyAndReplaceAsync(fileToReplace)); }); }
	STDMETHODIMP _MoveOverloadDefaultNameAndOptions(IStorageFolder* destinationFolder, Foundation::IAsyncAction* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->MoveAsync(destinationFolder)); }); }
	STDMETHODIMP _MoveOverloadDefaultOptions(IStorageFolder* destinationFolder, HSTRING desiredNewName, Foundation::IAsyncAction* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->MoveAsync(destinationFolder, desiredNewName)); }); }
	STDMETHODIMP _MoveOverload(IStorageFolder* destinationFolder, HSTRING desiredNewName, NameCollisionOption option, Foundation::IAsyncAction* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->MoveAsync(destinationFolder, desiredNewName, option)); }); }
	STDMETHODIMP _MoveAndReplaceAsync(IStorageFile* fileToReplace, Foundation::IAsyncAction* *operation) { return hrtry([&, this] { *operation = to_abi(X::get()->MoveAndReplaceAsync(fileToReplace)); }); }
};
template<typename X> struct unadapt<IStorageFile, X> : Windows::Storage::IStorageFile_unadaptor<X> {};
struct IStorageFile : IStorageFile_raw, generate<IStorageFile> {};

// StorageFile
template<typename> struct StorageFile_statics {
	static ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> GetFileFromPathAsync(hstring_ref path) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(get_activation_factory<StorageFile, IStorageFileStatics>()->_GetFileFromPathAsync(path, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> GetFileFromApplicationUriAsync(pptr<Foundation::Uri> uri) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(get_activation_factory<StorageFile, IStorageFileStatics>()->_GetFileFromApplicationUriAsync(uri, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> CreateStreamedFileAsync(hstring_ref displayNameWithExtension, handler_ref<StreamedFileDataRequestedHandler> dataRequested, pptr<Streams::IRandomAccessStreamReference> thumbnail) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(get_activation_factory<StorageFile, IStorageFileStatics>()->_CreateStreamedFileAsync(displayNameWithExtension, dataRequested, thumbnail, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> ReplaceWithStreamedFileAsync(pptr<IStorageFile> fileToReplace, handler_ref<StreamedFileDataRequestedHandler> dataRequested, pptr<Streams::IRandomAccessStreamReference> thumbnail) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(get_activation_factory<StorageFile, IStorageFileStatics>()->_ReplaceWithStreamedFileAsync(fileToReplace, dataRequested, thumbnail, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> CreateStreamedFileFromUriAsync(hstring_ref displayNameWithExtension, pptr<Foundation::Uri> uri, pptr<Streams::IRandomAccessStreamReference> thumbnail) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(get_activation_factory<StorageFile, IStorageFileStatics>()->_CreateStreamedFileFromUriAsync(displayNameWithExtension, uri, thumbnail, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> ReplaceWithStreamedFileFromUriAsync(pptr<IStorageFile> fileToReplace, pptr<Foundation::Uri> uri, pptr<Streams::IRandomAccessStreamReference> thumbnail) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(get_activation_factory<StorageFile, IStorageFileStatics>()->_ReplaceWithStreamedFileFromUriAsync(fileToReplace, uri, thumbnail, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<StorageFile, X> : X, Windows::Storage::StorageFile_statics<void> {
	typedef typename X::root_type StorageFile;
};
struct StorageFile : generate<StorageFile> {
	using IStorageItem::DeleteAsync;
	using IStorageFile::OpenTransactedWriteAsync;
	using IStorageFile2::OpenTransactedWriteAsync;
	using IStorageFile::MoveAsync;
	using IStorageItemProperties2::GetScaledImageAsThumbnailAsync;
	using IStorageItem::RenameAsync;
	using IStorageFile::OpenAsync;
	using IStorageFile2::OpenAsync;
	using IStorageFile::CopyAsync;
	using IStorageItemProperties::GetThumbnailAsync;
};

// IDownloadsFolderStatics2
struct IDownloadsFolderStatics2 : IInspectable {
	virtual STDMETHODIMP _CreateFileForUserAsync(System::User* user, HSTRING desiredName, Foundation::IAsyncOperation<StorageFile*>* *operation);
	virtual STDMETHODIMP _CreateFolderForUserAsync(System::User* user, HSTRING desiredName, Foundation::IAsyncOperation<StorageFolder*>* *operation);
	virtual STDMETHODIMP _CreateFileForUserWithCollisionOptionAsync(System::User* user, HSTRING desiredName, CreationCollisionOption option, Foundation::IAsyncOperation<StorageFile*>* *operation);
	virtual STDMETHODIMP _CreateFolderForUserWithCollisionOptionAsync(System::User* user, HSTRING desiredName, CreationCollisionOption option, Foundation::IAsyncOperation<StorageFolder*>* *operation);
};

// DownloadsFolder
template<typename> struct DownloadsFolder_statics {
	static ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> CreateFileForUserAsync(pptr<System::User> user, hstring_ref desiredName) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(get_activation_factory<DownloadsFolder, IDownloadsFolderStatics2>()->_CreateFileForUserAsync(user, desiredName, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageFolder>>> CreateFolderForUserAsync(pptr<System::User> user, hstring_ref desiredName) { Foundation::IAsyncOperation<StorageFolder*>* operation; hrcheck(get_activation_factory<DownloadsFolder, IDownloadsFolderStatics2>()->_CreateFolderForUserAsync(user, desiredName, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> CreateFileForUserAsync(pptr<System::User> user, hstring_ref desiredName, CreationCollisionOption option) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(get_activation_factory<DownloadsFolder, IDownloadsFolderStatics2>()->_CreateFileForUserWithCollisionOptionAsync(user, desiredName, option, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageFolder>>> CreateFolderForUserAsync(pptr<System::User> user, hstring_ref desiredName, CreationCollisionOption option) { Foundation::IAsyncOperation<StorageFolder*>* operation; hrcheck(get_activation_factory<DownloadsFolder, IDownloadsFolderStatics2>()->_CreateFolderForUserWithCollisionOptionAsync(user, desiredName, option, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> CreateFileAsync(hstring_ref desiredName) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(get_activation_factory<DownloadsFolder, IDownloadsFolderStatics>()->_CreateFileAsync(desiredName, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageFolder>>> CreateFolderAsync(hstring_ref desiredName) { Foundation::IAsyncOperation<StorageFolder*>* operation; hrcheck(get_activation_factory<DownloadsFolder, IDownloadsFolderStatics>()->_CreateFolderAsync(desiredName, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageFile>>> CreateFileAsync(hstring_ref desiredName, CreationCollisionOption option) { Foundation::IAsyncOperation<StorageFile*>* operation; hrcheck(get_activation_factory<DownloadsFolder, IDownloadsFolderStatics>()->_CreateFileWithCollisionOptionAsync(desiredName, option, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<StorageFolder>>> CreateFolderAsync(hstring_ref desiredName, CreationCollisionOption option) { Foundation::IAsyncOperation<StorageFolder*>* operation; hrcheck(get_activation_factory<DownloadsFolder, IDownloadsFolderStatics>()->_CreateFolderWithCollisionOptionAsync(desiredName, option, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<DownloadsFolder, X> : X, Windows::Storage::DownloadsFolder_statics<void> {
	typedef typename X::root_type DownloadsFolder;
};
struct DownloadsFolder : generate<DownloadsFolder> {};

// IStorageLibraryChange
struct IStorageLibraryChange_raw : IInspectable {
	virtual STDMETHODIMP _get_ChangeType(StorageLibraryChangeType *value);
	virtual STDMETHODIMP _get_Path(HSTRING *value);
	virtual STDMETHODIMP _get_PreviousPath(HSTRING *value);
	virtual STDMETHODIMP _IsOfType(StorageItemTypes type, bool *value);
	virtual STDMETHODIMP _GetStorageItemAsync(Foundation::IAsyncOperation<IStorageItem*>* *operation);
};
template<typename X> struct IStorageLibraryChange_adaptor : X {
	union {
		struct : property {
			StorageLibraryChangeType get() { StorageLibraryChangeType value; hrcheck(enc(&IStorageLibraryChange_adaptor::ChangeType)->_get_ChangeType(&value)); return value; }
			StorageLibraryChangeType operator()() { return get(); }
			operator StorageLibraryChangeType () { return get(); }
		} ChangeType;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorageLibraryChange_adaptor::Path)->_get_Path(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Path;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorageLibraryChange_adaptor::PreviousPath)->_get_PreviousPath(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PreviousPath;
	};
	bool IsOfType(StorageItemTypes type) { bool value; hrcheck(X::get()->_IsOfType(type, &value)); return value; }
	ptr<Foundation::IAsyncOperation<ptr<IStorageItem>>> GetStorageItemAsync() { Foundation::IAsyncOperation<IStorageItem*>* operation; hrcheck(X::get()->_GetStorageItemAsync(&operation)); return from_abi(operation); }
	IStorageLibraryChange_adaptor() {}
};
template<typename X> struct adapt<IStorageLibraryChange, X> : Windows::Storage::IStorageLibraryChange_adaptor<X> { typedef adapt IStorageLibraryChange; };
struct IStorageLibraryChange : IStorageLibraryChange_raw, generate<IStorageLibraryChange> {};

// StorageLibraryChange
template<typename X> struct statics<StorageLibraryChange, X> : X {
	typedef typename X::root_type StorageLibraryChange;
};
struct StorageLibraryChange : generate<StorageLibraryChange> {};

// IStorageLibraryChangeReader
struct IStorageLibraryChangeReader_raw : IInspectable {
	virtual STDMETHODIMP _ReadBatchAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageLibraryChange*>*>* *operation);
	virtual STDMETHODIMP _AcceptChangesAsync(Foundation::IAsyncAction* *operation);
};
template<typename X> struct IStorageLibraryChangeReader_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<StorageLibraryChange>>>>> ReadBatchAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<StorageLibraryChange*>*>* operation; hrcheck(X::get()->_ReadBatchAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncAction> AcceptChangesAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_AcceptChangesAsync(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IStorageLibraryChangeReader, X> : Windows::Storage::IStorageLibraryChangeReader_adaptor<X> { typedef adapt IStorageLibraryChangeReader; };
struct IStorageLibraryChangeReader : IStorageLibraryChangeReader_raw, generate<IStorageLibraryChangeReader> {};

// StorageLibraryChangeReader
template<typename X> struct statics<StorageLibraryChangeReader, X> : X {
	typedef typename X::root_type StorageLibraryChangeReader;
};
struct StorageLibraryChangeReader : generate<StorageLibraryChangeReader> {};

// IStreamedFileDataRequest
struct IStreamedFileDataRequest_raw : IInspectable {
	virtual STDMETHODIMP _FailAndClose(StreamedFileFailureMode failureMode) = 0;
};
template<typename X> struct IStreamedFileDataRequest_adaptor : X {
	void FailAndClose(StreamedFileFailureMode failureMode) { hrcheck(X::get()->_FailAndClose(failureMode)); }
};
template<typename X> struct adapt<IStreamedFileDataRequest, X> : Windows::Storage::IStreamedFileDataRequest_adaptor<X> { typedef adapt IStreamedFileDataRequest; };
template<typename X> struct IStreamedFileDataRequest_unadaptor : X {
	STDMETHODIMP _FailAndClose(StreamedFileFailureMode failureMode) { return hrtry([&, this] { X::get()->FailAndClose(failureMode); }); }
};
template<typename X> struct unadapt<IStreamedFileDataRequest, X> : Windows::Storage::IStreamedFileDataRequest_unadaptor<X> {};
struct IStreamedFileDataRequest : IStreamedFileDataRequest_raw, generate<IStreamedFileDataRequest> {};

// StreamedFileDataRequest
template<typename X> struct statics<StreamedFileDataRequest, X> : X {
	typedef typename X::root_type StreamedFileDataRequest;
};
struct StreamedFileDataRequest : generate<StreamedFileDataRequest> {};

// StreamedFileDataRequestedHandler
struct StreamedFileDataRequestedHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(StreamedFileDataRequest* stream) = 0;
};

// IStorageStreamTransaction
struct IStorageStreamTransaction_raw : IInspectable {
	virtual STDMETHODIMP _get_Stream(Streams::IRandomAccessStream* *value);
	virtual STDMETHODIMP _CommitAsync(Foundation::IAsyncAction* *operation);
};
template<typename X> struct IStorageStreamTransaction_adaptor : X {
	union {
		struct : property {
			ptr<Streams::IRandomAccessStream> get() { Streams::IRandomAccessStream* value; hrcheck(enc(&IStorageStreamTransaction_adaptor::Stream)->_get_Stream(&value)); return from_abi(value); }
			ptr<Streams::IRandomAccessStream> operator()() { return get(); }
			operator ptr<Streams::IRandomAccessStream> () { return get(); }
			ptr<Streams::IRandomAccessStream> operator->() { return get(); }
		} Stream;
	};
	ptr<Foundation::IAsyncAction> CommitAsync() { Foundation::IAsyncAction* operation; hrcheck(X::get()->_CommitAsync(&operation)); return from_abi(operation); }
	IStorageStreamTransaction_adaptor() {}
};
template<typename X> struct adapt<IStorageStreamTransaction, X> : Windows::Storage::IStorageStreamTransaction_adaptor<X> { typedef adapt IStorageStreamTransaction; };
struct IStorageStreamTransaction : IStorageStreamTransaction_raw, generate<IStorageStreamTransaction> {};

// StorageStreamTransaction
template<typename X> struct statics<StorageStreamTransaction, X> : X {
	typedef typename X::root_type StorageStreamTransaction;
};
struct StorageStreamTransaction : generate<StorageStreamTransaction> {};

// IStorageProvider
struct IStorageProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_Id(HSTRING *value);
	virtual STDMETHODIMP _get_DisplayName(HSTRING *value);
};
template<typename X> struct IStorageProvider_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorageProvider_adaptor::DisplayName)->_get_DisplayName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DisplayName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IStorageProvider_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
	};
	IStorageProvider_adaptor() {}
};
template<typename X> struct adapt<IStorageProvider, X> : Windows::Storage::IStorageProvider_adaptor<X> { typedef adapt IStorageProvider; };
struct IStorageProvider : IStorageProvider_raw, generate<IStorageProvider> {};

// IStorageProvider2
struct IStorageProvider2_raw : IInspectable {
	virtual STDMETHODIMP _IsPropertySupportedForPartialFileAsync(HSTRING propertyCanonicalName, Foundation::IAsyncOperation<bool>* *operation);
};
template<typename X> struct IStorageProvider2_adaptor : X {
	ptr<Foundation::IAsyncOperation<bool>> IsPropertySupportedForPartialFileAsync(hstring_ref propertyCanonicalName) { Foundation::IAsyncOperation<bool>* operation; hrcheck(X::get()->_IsPropertySupportedForPartialFileAsync(propertyCanonicalName, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IStorageProvider2, X> : Windows::Storage::IStorageProvider2_adaptor<X> { typedef adapt IStorageProvider2; };
struct IStorageProvider2 : IStorageProvider2_raw, generate<IStorageProvider2> {};

// StorageProvider
template<typename X> struct statics<StorageProvider, X> : X {
	typedef typename X::root_type StorageProvider;
};
struct StorageProvider : generate<StorageProvider> {};

// IFileIOStatics
struct IFileIOStatics : IInspectable {
	virtual STDMETHODIMP _ReadTextAsync(IStorageFile* file, Foundation::IAsyncOperation<HSTRING>* *textOperation);
	virtual STDMETHODIMP _ReadTextWithEncodingAsync(IStorageFile* file, Streams::UnicodeEncoding encoding, Foundation::IAsyncOperation<HSTRING>* *textOperation);
	virtual STDMETHODIMP _WriteTextAsync(IStorageFile* file, HSTRING contents, Foundation::IAsyncAction* *textOperation);
	virtual STDMETHODIMP _WriteTextWithEncodingAsync(IStorageFile* file, HSTRING contents, Streams::UnicodeEncoding encoding, Foundation::IAsyncAction* *textOperation);
	virtual STDMETHODIMP _AppendTextAsync(IStorageFile* file, HSTRING contents, Foundation::IAsyncAction* *textOperation);
	virtual STDMETHODIMP _AppendTextWithEncodingAsync(IStorageFile* file, HSTRING contents, Streams::UnicodeEncoding encoding, Foundation::IAsyncAction* *textOperation);
	virtual STDMETHODIMP _ReadLinesAsync(IStorageFile* file, Foundation::IAsyncOperation<Foundation::Collections::IVector<HSTRING>*>* *linesOperation);
	virtual STDMETHODIMP _ReadLinesWithEncodingAsync(IStorageFile* file, Streams::UnicodeEncoding encoding, Foundation::IAsyncOperation<Foundation::Collections::IVector<HSTRING>*>* *linesOperation);
	virtual STDMETHODIMP _WriteLinesAsync(IStorageFile* file, Foundation::Collections::IIterable<HSTRING>* lines, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _WriteLinesWithEncodingAsync(IStorageFile* file, Foundation::Collections::IIterable<HSTRING>* lines, Streams::UnicodeEncoding encoding, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _AppendLinesAsync(IStorageFile* file, Foundation::Collections::IIterable<HSTRING>* lines, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _AppendLinesWithEncodingAsync(IStorageFile* file, Foundation::Collections::IIterable<HSTRING>* lines, Streams::UnicodeEncoding encoding, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _ReadBufferAsync(IStorageFile* file, Foundation::IAsyncOperation<Streams::IBuffer*>* *operation);
	virtual STDMETHODIMP _WriteBufferAsync(IStorageFile* file, Streams::IBuffer* buffer, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _WriteBytesAsync(IStorageFile* file, unsigned bufferSize, unsigned char *buffer, Foundation::IAsyncAction* *operation);
};

// FileIO
template<typename> struct FileIO_statics {
	static ptr<Foundation::IAsyncOperation<hstring>> ReadTextAsync(pptr<IStorageFile> file) { Foundation::IAsyncOperation<HSTRING>* textOperation; hrcheck(get_activation_factory<FileIO, IFileIOStatics>()->_ReadTextAsync(file, &textOperation)); return from_abi(textOperation); }
	static ptr<Foundation::IAsyncOperation<hstring>> ReadTextAsync(pptr<IStorageFile> file, Streams::UnicodeEncoding encoding) { Foundation::IAsyncOperation<HSTRING>* textOperation; hrcheck(get_activation_factory<FileIO, IFileIOStatics>()->_ReadTextWithEncodingAsync(file, encoding, &textOperation)); return from_abi(textOperation); }
	static ptr<Foundation::IAsyncAction> WriteTextAsync(pptr<IStorageFile> file, hstring_ref contents) { Foundation::IAsyncAction* textOperation; hrcheck(get_activation_factory<FileIO, IFileIOStatics>()->_WriteTextAsync(file, contents, &textOperation)); return from_abi(textOperation); }
	static ptr<Foundation::IAsyncAction> WriteTextAsync(pptr<IStorageFile> file, hstring_ref contents, Streams::UnicodeEncoding encoding) { Foundation::IAsyncAction* textOperation; hrcheck(get_activation_factory<FileIO, IFileIOStatics>()->_WriteTextWithEncodingAsync(file, contents, encoding, &textOperation)); return from_abi(textOperation); }
	static ptr<Foundation::IAsyncAction> AppendTextAsync(pptr<IStorageFile> file, hstring_ref contents) { Foundation::IAsyncAction* textOperation; hrcheck(get_activation_factory<FileIO, IFileIOStatics>()->_AppendTextAsync(file, contents, &textOperation)); return from_abi(textOperation); }
	static ptr<Foundation::IAsyncAction> AppendTextAsync(pptr<IStorageFile> file, hstring_ref contents, Streams::UnicodeEncoding encoding) { Foundation::IAsyncAction* textOperation; hrcheck(get_activation_factory<FileIO, IFileIOStatics>()->_AppendTextWithEncodingAsync(file, contents, encoding, &textOperation)); return from_abi(textOperation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVector<hstring>>>> ReadLinesAsync(pptr<IStorageFile> file) { Foundation::IAsyncOperation<Foundation::Collections::IVector<HSTRING>*>* linesOperation; hrcheck(get_activation_factory<FileIO, IFileIOStatics>()->_ReadLinesAsync(file, &linesOperation)); return from_abi(linesOperation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVector<hstring>>>> ReadLinesAsync(pptr<IStorageFile> file, Streams::UnicodeEncoding encoding) { Foundation::IAsyncOperation<Foundation::Collections::IVector<HSTRING>*>* linesOperation; hrcheck(get_activation_factory<FileIO, IFileIOStatics>()->_ReadLinesWithEncodingAsync(file, encoding, &linesOperation)); return from_abi(linesOperation); }
	static ptr<Foundation::IAsyncAction> WriteLinesAsync(pptr<IStorageFile> file, pptr<Foundation::Collections::IIterable<hstring>> lines) { Foundation::IAsyncAction* operation; hrcheck(get_activation_factory<FileIO, IFileIOStatics>()->_WriteLinesAsync(file, to_abi(lines), &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncAction> WriteLinesAsync(pptr<IStorageFile> file, pptr<Foundation::Collections::IIterable<hstring>> lines, Streams::UnicodeEncoding encoding) { Foundation::IAsyncAction* operation; hrcheck(get_activation_factory<FileIO, IFileIOStatics>()->_WriteLinesWithEncodingAsync(file, to_abi(lines), encoding, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncAction> AppendLinesAsync(pptr<IStorageFile> file, pptr<Foundation::Collections::IIterable<hstring>> lines) { Foundation::IAsyncAction* operation; hrcheck(get_activation_factory<FileIO, IFileIOStatics>()->_AppendLinesAsync(file, to_abi(lines), &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncAction> AppendLinesAsync(pptr<IStorageFile> file, pptr<Foundation::Collections::IIterable<hstring>> lines, Streams::UnicodeEncoding encoding) { Foundation::IAsyncAction* operation; hrcheck(get_activation_factory<FileIO, IFileIOStatics>()->_AppendLinesWithEncodingAsync(file, to_abi(lines), encoding, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Streams::IBuffer>>> ReadBufferAsync(pptr<IStorageFile> file) { Foundation::IAsyncOperation<Streams::IBuffer*>* operation; hrcheck(get_activation_factory<FileIO, IFileIOStatics>()->_ReadBufferAsync(file, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncAction> WriteBufferAsync(pptr<IStorageFile> file, pptr<Streams::IBuffer> buffer) { Foundation::IAsyncAction* operation; hrcheck(get_activation_factory<FileIO, IFileIOStatics>()->_WriteBufferAsync(file, buffer, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncAction> WriteBytesAsync(pptr<IStorageFile> file, const szarray<unsigned char>& buffer) { Foundation::IAsyncAction* operation; hrcheck(get_activation_factory<FileIO, IFileIOStatics>()->_WriteBytesAsync(file, buffer.size, to_abi(buffer.p), &operation)); return from_abi(operation); }
};

template<typename X> struct statics<FileIO, X> : X, Windows::Storage::FileIO_statics<void> {
	typedef typename X::root_type FileIO;
};
struct FileIO : generate<FileIO> {};

// IPathIOStatics
struct IPathIOStatics : IInspectable {
	virtual STDMETHODIMP _ReadTextAsync(HSTRING absolutePath, Foundation::IAsyncOperation<HSTRING>* *textOperation);
	virtual STDMETHODIMP _ReadTextWithEncodingAsync(HSTRING absolutePath, Streams::UnicodeEncoding encoding, Foundation::IAsyncOperation<HSTRING>* *textOperation);
	virtual STDMETHODIMP _WriteTextAsync(HSTRING absolutePath, HSTRING contents, Foundation::IAsyncAction* *textOperation);
	virtual STDMETHODIMP _WriteTextWithEncodingAsync(HSTRING absolutePath, HSTRING contents, Streams::UnicodeEncoding encoding, Foundation::IAsyncAction* *textOperation);
	virtual STDMETHODIMP _AppendTextAsync(HSTRING absolutePath, HSTRING contents, Foundation::IAsyncAction* *textOperation);
	virtual STDMETHODIMP _AppendTextWithEncodingAsync(HSTRING absolutePath, HSTRING contents, Streams::UnicodeEncoding encoding, Foundation::IAsyncAction* *textOperation);
	virtual STDMETHODIMP _ReadLinesAsync(HSTRING absolutePath, Foundation::IAsyncOperation<Foundation::Collections::IVector<HSTRING>*>* *linesOperation);
	virtual STDMETHODIMP _ReadLinesWithEncodingAsync(HSTRING absolutePath, Streams::UnicodeEncoding encoding, Foundation::IAsyncOperation<Foundation::Collections::IVector<HSTRING>*>* *linesOperation);
	virtual STDMETHODIMP _WriteLinesAsync(HSTRING absolutePath, Foundation::Collections::IIterable<HSTRING>* lines, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _WriteLinesWithEncodingAsync(HSTRING absolutePath, Foundation::Collections::IIterable<HSTRING>* lines, Streams::UnicodeEncoding encoding, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _AppendLinesAsync(HSTRING absolutePath, Foundation::Collections::IIterable<HSTRING>* lines, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _AppendLinesWithEncodingAsync(HSTRING absolutePath, Foundation::Collections::IIterable<HSTRING>* lines, Streams::UnicodeEncoding encoding, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _ReadBufferAsync(HSTRING absolutePath, Foundation::IAsyncOperation<Streams::IBuffer*>* *operation);
	virtual STDMETHODIMP _WriteBufferAsync(HSTRING absolutePath, Streams::IBuffer* buffer, Foundation::IAsyncAction* *operation);
	virtual STDMETHODIMP _WriteBytesAsync(HSTRING absolutePath, unsigned bufferSize, unsigned char *buffer, Foundation::IAsyncAction* *operation);
};

// PathIO
template<typename> struct PathIO_statics {
	static ptr<Foundation::IAsyncOperation<hstring>> ReadTextAsync(hstring_ref absolutePath) { Foundation::IAsyncOperation<HSTRING>* textOperation; hrcheck(get_activation_factory<PathIO, IPathIOStatics>()->_ReadTextAsync(absolutePath, &textOperation)); return from_abi(textOperation); }
	static ptr<Foundation::IAsyncOperation<hstring>> ReadTextAsync(hstring_ref absolutePath, Streams::UnicodeEncoding encoding) { Foundation::IAsyncOperation<HSTRING>* textOperation; hrcheck(get_activation_factory<PathIO, IPathIOStatics>()->_ReadTextWithEncodingAsync(absolutePath, encoding, &textOperation)); return from_abi(textOperation); }
	static ptr<Foundation::IAsyncAction> WriteTextAsync(hstring_ref absolutePath, hstring_ref contents) { Foundation::IAsyncAction* textOperation; hrcheck(get_activation_factory<PathIO, IPathIOStatics>()->_WriteTextAsync(absolutePath, contents, &textOperation)); return from_abi(textOperation); }
	static ptr<Foundation::IAsyncAction> WriteTextAsync(hstring_ref absolutePath, hstring_ref contents, Streams::UnicodeEncoding encoding) { Foundation::IAsyncAction* textOperation; hrcheck(get_activation_factory<PathIO, IPathIOStatics>()->_WriteTextWithEncodingAsync(absolutePath, contents, encoding, &textOperation)); return from_abi(textOperation); }
	static ptr<Foundation::IAsyncAction> AppendTextAsync(hstring_ref absolutePath, hstring_ref contents) { Foundation::IAsyncAction* textOperation; hrcheck(get_activation_factory<PathIO, IPathIOStatics>()->_AppendTextAsync(absolutePath, contents, &textOperation)); return from_abi(textOperation); }
	static ptr<Foundation::IAsyncAction> AppendTextAsync(hstring_ref absolutePath, hstring_ref contents, Streams::UnicodeEncoding encoding) { Foundation::IAsyncAction* textOperation; hrcheck(get_activation_factory<PathIO, IPathIOStatics>()->_AppendTextWithEncodingAsync(absolutePath, contents, encoding, &textOperation)); return from_abi(textOperation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVector<hstring>>>> ReadLinesAsync(hstring_ref absolutePath) { Foundation::IAsyncOperation<Foundation::Collections::IVector<HSTRING>*>* linesOperation; hrcheck(get_activation_factory<PathIO, IPathIOStatics>()->_ReadLinesAsync(absolutePath, &linesOperation)); return from_abi(linesOperation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVector<hstring>>>> ReadLinesAsync(hstring_ref absolutePath, Streams::UnicodeEncoding encoding) { Foundation::IAsyncOperation<Foundation::Collections::IVector<HSTRING>*>* linesOperation; hrcheck(get_activation_factory<PathIO, IPathIOStatics>()->_ReadLinesWithEncodingAsync(absolutePath, encoding, &linesOperation)); return from_abi(linesOperation); }
	static ptr<Foundation::IAsyncAction> WriteLinesAsync(hstring_ref absolutePath, pptr<Foundation::Collections::IIterable<hstring>> lines) { Foundation::IAsyncAction* operation; hrcheck(get_activation_factory<PathIO, IPathIOStatics>()->_WriteLinesAsync(absolutePath, to_abi(lines), &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncAction> WriteLinesAsync(hstring_ref absolutePath, pptr<Foundation::Collections::IIterable<hstring>> lines, Streams::UnicodeEncoding encoding) { Foundation::IAsyncAction* operation; hrcheck(get_activation_factory<PathIO, IPathIOStatics>()->_WriteLinesWithEncodingAsync(absolutePath, to_abi(lines), encoding, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncAction> AppendLinesAsync(hstring_ref absolutePath, pptr<Foundation::Collections::IIterable<hstring>> lines) { Foundation::IAsyncAction* operation; hrcheck(get_activation_factory<PathIO, IPathIOStatics>()->_AppendLinesAsync(absolutePath, to_abi(lines), &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncAction> AppendLinesAsync(hstring_ref absolutePath, pptr<Foundation::Collections::IIterable<hstring>> lines, Streams::UnicodeEncoding encoding) { Foundation::IAsyncAction* operation; hrcheck(get_activation_factory<PathIO, IPathIOStatics>()->_AppendLinesWithEncodingAsync(absolutePath, to_abi(lines), encoding, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Streams::IBuffer>>> ReadBufferAsync(hstring_ref absolutePath) { Foundation::IAsyncOperation<Streams::IBuffer*>* operation; hrcheck(get_activation_factory<PathIO, IPathIOStatics>()->_ReadBufferAsync(absolutePath, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncAction> WriteBufferAsync(hstring_ref absolutePath, pptr<Streams::IBuffer> buffer) { Foundation::IAsyncAction* operation; hrcheck(get_activation_factory<PathIO, IPathIOStatics>()->_WriteBufferAsync(absolutePath, buffer, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncAction> WriteBytesAsync(hstring_ref absolutePath, const szarray<unsigned char>& buffer) { Foundation::IAsyncAction* operation; hrcheck(get_activation_factory<PathIO, IPathIOStatics>()->_WriteBytesAsync(absolutePath, buffer.size, to_abi(buffer.p), &operation)); return from_abi(operation); }
};

template<typename X> struct statics<PathIO, X> : X, Windows::Storage::PathIO_statics<void> {
	typedef typename X::root_type PathIO;
};
struct PathIO : generate<PathIO> {};

// ICachedFileManagerStatics
struct ICachedFileManagerStatics : IInspectable {
	virtual STDMETHODIMP _DeferUpdates(IStorageFile* file);
	virtual STDMETHODIMP _CompleteUpdatesAsync(IStorageFile* file, Foundation::IAsyncOperation<Provider::FileUpdateStatus>* *operation);
};

// CachedFileManager
template<typename> struct CachedFileManager_statics {
	static void DeferUpdates(pptr<IStorageFile> file) { hrcheck(get_activation_factory<CachedFileManager, ICachedFileManagerStatics>()->_DeferUpdates(file)); }
	static ptr<Foundation::IAsyncOperation<Provider::FileUpdateStatus>> CompleteUpdatesAsync(pptr<IStorageFile> file) { Foundation::IAsyncOperation<Provider::FileUpdateStatus>* operation; hrcheck(get_activation_factory<CachedFileManager, ICachedFileManagerStatics>()->_CompleteUpdatesAsync(file, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<CachedFileManager, X> : X, Windows::Storage::CachedFileManager_statics<void> {
	typedef typename X::root_type CachedFileManager;
};
struct CachedFileManager : generate<CachedFileManager> {};

// ISystemAudioProperties
struct ISystemAudioProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_EncodingBitrate(HSTRING *value);
};
template<typename X> struct ISystemAudioProperties_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemAudioProperties_adaptor::EncodingBitrate)->_get_EncodingBitrate(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} EncodingBitrate;
	};
	ISystemAudioProperties_adaptor() {}
};
template<typename X> struct adapt<ISystemAudioProperties, X> : Windows::Storage::ISystemAudioProperties_adaptor<X> { typedef adapt ISystemAudioProperties; };
struct ISystemAudioProperties : ISystemAudioProperties_raw, generate<ISystemAudioProperties> {};

// SystemAudioProperties
template<typename X> struct statics<SystemAudioProperties, X> : X {
	typedef typename X::root_type SystemAudioProperties;
};
struct SystemAudioProperties : generate<SystemAudioProperties> {};

// ISystemGPSProperties
struct ISystemGPSProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_LatitudeDecimal(HSTRING *value);
	virtual STDMETHODIMP _get_LongitudeDecimal(HSTRING *value);
};
template<typename X> struct ISystemGPSProperties_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemGPSProperties_adaptor::LatitudeDecimal)->_get_LatitudeDecimal(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} LatitudeDecimal;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemGPSProperties_adaptor::LongitudeDecimal)->_get_LongitudeDecimal(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} LongitudeDecimal;
	};
	ISystemGPSProperties_adaptor() {}
};
template<typename X> struct adapt<ISystemGPSProperties, X> : Windows::Storage::ISystemGPSProperties_adaptor<X> { typedef adapt ISystemGPSProperties; };
struct ISystemGPSProperties : ISystemGPSProperties_raw, generate<ISystemGPSProperties> {};

// SystemGPSProperties
template<typename X> struct statics<SystemGPSProperties, X> : X {
	typedef typename X::root_type SystemGPSProperties;
};
struct SystemGPSProperties : generate<SystemGPSProperties> {};

// ISystemImageProperties
struct ISystemImageProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_HorizontalSize(HSTRING *value);
	virtual STDMETHODIMP _get_VerticalSize(HSTRING *value);
};
template<typename X> struct ISystemImageProperties_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemImageProperties_adaptor::HorizontalSize)->_get_HorizontalSize(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} HorizontalSize;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemImageProperties_adaptor::VerticalSize)->_get_VerticalSize(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} VerticalSize;
	};
	ISystemImageProperties_adaptor() {}
};
template<typename X> struct adapt<ISystemImageProperties, X> : Windows::Storage::ISystemImageProperties_adaptor<X> { typedef adapt ISystemImageProperties; };
struct ISystemImageProperties : ISystemImageProperties_raw, generate<ISystemImageProperties> {};

// SystemImageProperties
template<typename X> struct statics<SystemImageProperties, X> : X {
	typedef typename X::root_type SystemImageProperties;
};
struct SystemImageProperties : generate<SystemImageProperties> {};

// ISystemMediaProperties
struct ISystemMediaProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_Duration(HSTRING *value);
	virtual STDMETHODIMP _get_Producer(HSTRING *value);
	virtual STDMETHODIMP _get_Publisher(HSTRING *value);
	virtual STDMETHODIMP _get_SubTitle(HSTRING *value);
	virtual STDMETHODIMP _get_Writer(HSTRING *value);
	virtual STDMETHODIMP _get_Year(HSTRING *value);
};
template<typename X> struct ISystemMediaProperties_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemMediaProperties_adaptor::Duration)->_get_Duration(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Duration;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemMediaProperties_adaptor::Producer)->_get_Producer(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Producer;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemMediaProperties_adaptor::Publisher)->_get_Publisher(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Publisher;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemMediaProperties_adaptor::SubTitle)->_get_SubTitle(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} SubTitle;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemMediaProperties_adaptor::Writer)->_get_Writer(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Writer;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemMediaProperties_adaptor::Year)->_get_Year(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Year;
	};
	ISystemMediaProperties_adaptor() {}
};
template<typename X> struct adapt<ISystemMediaProperties, X> : Windows::Storage::ISystemMediaProperties_adaptor<X> { typedef adapt ISystemMediaProperties; };
struct ISystemMediaProperties : ISystemMediaProperties_raw, generate<ISystemMediaProperties> {};

// SystemMediaProperties
template<typename X> struct statics<SystemMediaProperties, X> : X {
	typedef typename X::root_type SystemMediaProperties;
};
struct SystemMediaProperties : generate<SystemMediaProperties> {};

// ISystemMusicProperties
struct ISystemMusicProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_AlbumArtist(HSTRING *value);
	virtual STDMETHODIMP _get_AlbumTitle(HSTRING *value);
	virtual STDMETHODIMP _get_Artist(HSTRING *value);
	virtual STDMETHODIMP _get_Composer(HSTRING *value);
	virtual STDMETHODIMP _get_Conductor(HSTRING *value);
	virtual STDMETHODIMP _get_DisplayArtist(HSTRING *value);
	virtual STDMETHODIMP _get_Genre(HSTRING *value);
	virtual STDMETHODIMP _get_TrackNumber(HSTRING *value);
};
template<typename X> struct ISystemMusicProperties_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemMusicProperties_adaptor::AlbumArtist)->_get_AlbumArtist(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} AlbumArtist;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemMusicProperties_adaptor::AlbumTitle)->_get_AlbumTitle(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} AlbumTitle;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemMusicProperties_adaptor::Artist)->_get_Artist(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Artist;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemMusicProperties_adaptor::Composer)->_get_Composer(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Composer;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemMusicProperties_adaptor::Conductor)->_get_Conductor(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Conductor;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemMusicProperties_adaptor::DisplayArtist)->_get_DisplayArtist(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DisplayArtist;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemMusicProperties_adaptor::Genre)->_get_Genre(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Genre;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemMusicProperties_adaptor::TrackNumber)->_get_TrackNumber(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} TrackNumber;
	};
	ISystemMusicProperties_adaptor() {}
};
template<typename X> struct adapt<ISystemMusicProperties, X> : Windows::Storage::ISystemMusicProperties_adaptor<X> { typedef adapt ISystemMusicProperties; };
struct ISystemMusicProperties : ISystemMusicProperties_raw, generate<ISystemMusicProperties> {};

// SystemMusicProperties
template<typename X> struct statics<SystemMusicProperties, X> : X {
	typedef typename X::root_type SystemMusicProperties;
};
struct SystemMusicProperties : generate<SystemMusicProperties> {};

// ISystemPhotoProperties
struct ISystemPhotoProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_CameraManufacturer(HSTRING *value);
	virtual STDMETHODIMP _get_CameraModel(HSTRING *value);
	virtual STDMETHODIMP _get_DateTaken(HSTRING *value);
	virtual STDMETHODIMP _get_Orientation(HSTRING *value);
	virtual STDMETHODIMP _get_PeopleNames(HSTRING *value);
};
template<typename X> struct ISystemPhotoProperties_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemPhotoProperties_adaptor::CameraManufacturer)->_get_CameraManufacturer(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} CameraManufacturer;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemPhotoProperties_adaptor::CameraModel)->_get_CameraModel(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} CameraModel;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemPhotoProperties_adaptor::DateTaken)->_get_DateTaken(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DateTaken;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemPhotoProperties_adaptor::Orientation)->_get_Orientation(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Orientation;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemPhotoProperties_adaptor::PeopleNames)->_get_PeopleNames(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PeopleNames;
	};
	ISystemPhotoProperties_adaptor() {}
};
template<typename X> struct adapt<ISystemPhotoProperties, X> : Windows::Storage::ISystemPhotoProperties_adaptor<X> { typedef adapt ISystemPhotoProperties; };
struct ISystemPhotoProperties : ISystemPhotoProperties_raw, generate<ISystemPhotoProperties> {};

// SystemPhotoProperties
template<typename X> struct statics<SystemPhotoProperties, X> : X {
	typedef typename X::root_type SystemPhotoProperties;
};
struct SystemPhotoProperties : generate<SystemPhotoProperties> {};

// ISystemVideoProperties
struct ISystemVideoProperties_raw : IInspectable {
	virtual STDMETHODIMP _get_Director(HSTRING *value);
	virtual STDMETHODIMP _get_FrameHeight(HSTRING *value);
	virtual STDMETHODIMP _get_FrameWidth(HSTRING *value);
	virtual STDMETHODIMP _get_Orientation(HSTRING *value);
	virtual STDMETHODIMP _get_TotalBitrate(HSTRING *value);
};
template<typename X> struct ISystemVideoProperties_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemVideoProperties_adaptor::Director)->_get_Director(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Director;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemVideoProperties_adaptor::FrameHeight)->_get_FrameHeight(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} FrameHeight;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemVideoProperties_adaptor::FrameWidth)->_get_FrameWidth(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} FrameWidth;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemVideoProperties_adaptor::Orientation)->_get_Orientation(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Orientation;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ISystemVideoProperties_adaptor::TotalBitrate)->_get_TotalBitrate(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} TotalBitrate;
	};
	ISystemVideoProperties_adaptor() {}
};
template<typename X> struct adapt<ISystemVideoProperties, X> : Windows::Storage::ISystemVideoProperties_adaptor<X> { typedef adapt ISystemVideoProperties; };
struct ISystemVideoProperties : ISystemVideoProperties_raw, generate<ISystemVideoProperties> {};

// SystemVideoProperties
template<typename X> struct statics<SystemVideoProperties, X> : X {
	typedef typename X::root_type SystemVideoProperties;
};
struct SystemVideoProperties : generate<SystemVideoProperties> {};

// ISystemProperties
struct ISystemProperties : IInspectable {
	virtual STDMETHODIMP _get_Author(HSTRING *value);
	virtual STDMETHODIMP _get_Comment(HSTRING *value);
	virtual STDMETHODIMP _get_ItemNameDisplay(HSTRING *value);
	virtual STDMETHODIMP _get_Keywords(HSTRING *value);
	virtual STDMETHODIMP _get_Rating(HSTRING *value);
	virtual STDMETHODIMP _get_Title(HSTRING *value);
	virtual STDMETHODIMP _get_Audio(SystemAudioProperties* *value);
	virtual STDMETHODIMP _get_GPS(SystemGPSProperties* *value);
	virtual STDMETHODIMP _get_Media(SystemMediaProperties* *value);
	virtual STDMETHODIMP _get_Music(SystemMusicProperties* *value);
	virtual STDMETHODIMP _get_Photo(SystemPhotoProperties* *value);
	virtual STDMETHODIMP _get_Video(SystemVideoProperties* *value);
	virtual STDMETHODIMP _get_Image(SystemImageProperties* *value);
};

// SystemProperties
template<typename> struct SystemProperties_statics {
	static struct _Audio : property {
		ptr<SystemAudioProperties> get() { SystemAudioProperties* value; hrcheck(get_activation_factory<SystemProperties, ISystemProperties>()->_get_Audio(&value)); return from_abi(value); }
		ptr<SystemAudioProperties> operator()() { return get(); }
		operator ptr<SystemAudioProperties> () { return get(); }
		ptr<SystemAudioProperties> operator->() { return get(); }
	} Audio;
	static struct _Author : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<SystemProperties, ISystemProperties>()->_get_Author(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Author;
	static struct _Comment : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<SystemProperties, ISystemProperties>()->_get_Comment(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Comment;
	static struct _GPS : property {
		ptr<SystemGPSProperties> get() { SystemGPSProperties* value; hrcheck(get_activation_factory<SystemProperties, ISystemProperties>()->_get_GPS(&value)); return from_abi(value); }
		ptr<SystemGPSProperties> operator()() { return get(); }
		operator ptr<SystemGPSProperties> () { return get(); }
		ptr<SystemGPSProperties> operator->() { return get(); }
	} GPS;
	static struct _Image : property {
		ptr<SystemImageProperties> get() { SystemImageProperties* value; hrcheck(get_activation_factory<SystemProperties, ISystemProperties>()->_get_Image(&value)); return from_abi(value); }
		ptr<SystemImageProperties> operator()() { return get(); }
		operator ptr<SystemImageProperties> () { return get(); }
		ptr<SystemImageProperties> operator->() { return get(); }
	} Image;
	static struct _ItemNameDisplay : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<SystemProperties, ISystemProperties>()->_get_ItemNameDisplay(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} ItemNameDisplay;
	static struct _Keywords : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<SystemProperties, ISystemProperties>()->_get_Keywords(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Keywords;
	static struct _Media : property {
		ptr<SystemMediaProperties> get() { SystemMediaProperties* value; hrcheck(get_activation_factory<SystemProperties, ISystemProperties>()->_get_Media(&value)); return from_abi(value); }
		ptr<SystemMediaProperties> operator()() { return get(); }
		operator ptr<SystemMediaProperties> () { return get(); }
		ptr<SystemMediaProperties> operator->() { return get(); }
	} Media;
	static struct _Music : property {
		ptr<SystemMusicProperties> get() { SystemMusicProperties* value; hrcheck(get_activation_factory<SystemProperties, ISystemProperties>()->_get_Music(&value)); return from_abi(value); }
		ptr<SystemMusicProperties> operator()() { return get(); }
		operator ptr<SystemMusicProperties> () { return get(); }
		ptr<SystemMusicProperties> operator->() { return get(); }
	} Music;
	static struct _Photo : property {
		ptr<SystemPhotoProperties> get() { SystemPhotoProperties* value; hrcheck(get_activation_factory<SystemProperties, ISystemProperties>()->_get_Photo(&value)); return from_abi(value); }
		ptr<SystemPhotoProperties> operator()() { return get(); }
		operator ptr<SystemPhotoProperties> () { return get(); }
		ptr<SystemPhotoProperties> operator->() { return get(); }
	} Photo;
	static struct _Rating : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<SystemProperties, ISystemProperties>()->_get_Rating(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Rating;
	static struct _Title : property {
		hstring get() { HSTRING value; hrcheck(get_activation_factory<SystemProperties, ISystemProperties>()->_get_Title(&value)); return from_abi(value); }
		hstring operator()() { return get(); }
		operator hstring_ref () { return get(); }
	} Title;
	static struct _Video : property {
		ptr<SystemVideoProperties> get() { SystemVideoProperties* value; hrcheck(get_activation_factory<SystemProperties, ISystemProperties>()->_get_Video(&value)); return from_abi(value); }
		ptr<SystemVideoProperties> operator()() { return get(); }
		operator ptr<SystemVideoProperties> () { return get(); }
		ptr<SystemVideoProperties> operator->() { return get(); }
	} Video;
};
template<typename X> typename SystemProperties_statics<X>::_Audio SystemProperties_statics<X>::Audio;
template<typename X> typename SystemProperties_statics<X>::_Author SystemProperties_statics<X>::Author;
template<typename X> typename SystemProperties_statics<X>::_Comment SystemProperties_statics<X>::Comment;
template<typename X> typename SystemProperties_statics<X>::_GPS SystemProperties_statics<X>::GPS;
template<typename X> typename SystemProperties_statics<X>::_Image SystemProperties_statics<X>::Image;
template<typename X> typename SystemProperties_statics<X>::_ItemNameDisplay SystemProperties_statics<X>::ItemNameDisplay;
template<typename X> typename SystemProperties_statics<X>::_Keywords SystemProperties_statics<X>::Keywords;
template<typename X> typename SystemProperties_statics<X>::_Media SystemProperties_statics<X>::Media;
template<typename X> typename SystemProperties_statics<X>::_Music SystemProperties_statics<X>::Music;
template<typename X> typename SystemProperties_statics<X>::_Photo SystemProperties_statics<X>::Photo;
template<typename X> typename SystemProperties_statics<X>::_Rating SystemProperties_statics<X>::Rating;
template<typename X> typename SystemProperties_statics<X>::_Title SystemProperties_statics<X>::Title;
template<typename X> typename SystemProperties_statics<X>::_Video SystemProperties_statics<X>::Video;

template<typename X> struct statics<SystemProperties, X> : X, Windows::Storage::SystemProperties_statics<void> {
	typedef typename X::root_type SystemProperties;
};
struct SystemProperties : generate<SystemProperties> {};

// IApplicationDataStatics
struct IApplicationDataStatics : IInspectable {
	virtual STDMETHODIMP _get_Current(ApplicationData* *value);
};

// IApplicationDataStatics2
struct IApplicationDataStatics2 : IInspectable {
	virtual STDMETHODIMP _GetForUserAsync(System::User* user, Foundation::IAsyncOperation<ApplicationData*>* *getForUserOperation);
};

// IApplicationData3
struct IApplicationData3_raw : IInspectable {
	virtual STDMETHODIMP _GetPublisherCacheFolder(HSTRING folderName, StorageFolder* *value);
	virtual STDMETHODIMP _ClearPublisherCacheFolderAsync(HSTRING folderName, Foundation::IAsyncAction* *clearOperation);
	virtual STDMETHODIMP _get_SharedLocalFolder(StorageFolder* *value);
};
template<typename X> struct IApplicationData3_adaptor : X {
	union {
		struct : property {
			ptr<StorageFolder> get() { StorageFolder* value; hrcheck(enc(&IApplicationData3_adaptor::SharedLocalFolder)->_get_SharedLocalFolder(&value)); return from_abi(value); }
			ptr<StorageFolder> operator()() { return get(); }
			operator ptr<StorageFolder> () { return get(); }
			ptr<StorageFolder> operator->() { return get(); }
		} SharedLocalFolder;
	};
	ptr<StorageFolder> GetPublisherCacheFolder(hstring_ref folderName) { StorageFolder* value; hrcheck(X::get()->_GetPublisherCacheFolder(folderName, &value)); return from_abi(value); }
	ptr<Foundation::IAsyncAction> ClearPublisherCacheFolderAsync(hstring_ref folderName) { Foundation::IAsyncAction* clearOperation; hrcheck(X::get()->_ClearPublisherCacheFolderAsync(folderName, &clearOperation)); return from_abi(clearOperation); }
	IApplicationData3_adaptor() {}
};
template<typename X> struct adapt<IApplicationData3, X> : Windows::Storage::IApplicationData3_adaptor<X> { typedef adapt IApplicationData3; };
struct IApplicationData3 : IApplicationData3_raw, generate<IApplicationData3> {};

// IApplicationData2
struct IApplicationData2_raw : IInspectable {
	virtual STDMETHODIMP _get_LocalCacheFolder(StorageFolder* *value);
};
template<typename X> struct IApplicationData2_adaptor : X {
	union {
		struct : property {
			ptr<StorageFolder> get() { StorageFolder* value; hrcheck(enc(&IApplicationData2_adaptor::LocalCacheFolder)->_get_LocalCacheFolder(&value)); return from_abi(value); }
			ptr<StorageFolder> operator()() { return get(); }
			operator ptr<StorageFolder> () { return get(); }
			ptr<StorageFolder> operator->() { return get(); }
		} LocalCacheFolder;
	};
	IApplicationData2_adaptor() {}
};
template<typename X> struct adapt<IApplicationData2, X> : Windows::Storage::IApplicationData2_adaptor<X> { typedef adapt IApplicationData2; };
struct IApplicationData2 : IApplicationData2_raw, generate<IApplicationData2> {};

// IApplicationData
struct IApplicationData_raw : IInspectable {
	virtual STDMETHODIMP _get_Version(unsigned *value);
	virtual STDMETHODIMP _SetVersionAsync(unsigned desiredVersion, ApplicationDataSetVersionHandler* handler, Foundation::IAsyncAction* *setVersionOperation);
	virtual STDMETHODIMP _ClearAllAsync(Foundation::IAsyncAction* *clearOperation);
	virtual STDMETHODIMP _ClearAsync(ApplicationDataLocality locality, Foundation::IAsyncAction* *clearOperation);
	virtual STDMETHODIMP _get_LocalSettings(ApplicationDataContainer* *value);
	virtual STDMETHODIMP _get_RoamingSettings(ApplicationDataContainer* *value);
	virtual STDMETHODIMP _get_LocalFolder(StorageFolder* *value);
	virtual STDMETHODIMP _get_RoamingFolder(StorageFolder* *value);
	virtual STDMETHODIMP _get_TemporaryFolder(StorageFolder* *value);
	virtual STDMETHODIMP _add_DataChanged(Foundation::TypedEventHandler<ApplicationData*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_DataChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _SignalDataChanged();
	virtual STDMETHODIMP _get_RoamingStorageQuota(unsigned __int64 *value);
};
template<typename X> struct IApplicationData_adaptor : X {
	union {
		struct : property {
			ptr<StorageFolder> get() { StorageFolder* value; hrcheck(enc(&IApplicationData_adaptor::LocalFolder)->_get_LocalFolder(&value)); return from_abi(value); }
			ptr<StorageFolder> operator()() { return get(); }
			operator ptr<StorageFolder> () { return get(); }
			ptr<StorageFolder> operator->() { return get(); }
		} LocalFolder;
		struct : property {
			ptr<ApplicationDataContainer> get() { ApplicationDataContainer* value; hrcheck(enc(&IApplicationData_adaptor::LocalSettings)->_get_LocalSettings(&value)); return from_abi(value); }
			ptr<ApplicationDataContainer> operator()() { return get(); }
			operator ptr<ApplicationDataContainer> () { return get(); }
			ptr<ApplicationDataContainer> operator->() { return get(); }
		} LocalSettings;
		struct : property {
			ptr<StorageFolder> get() { StorageFolder* value; hrcheck(enc(&IApplicationData_adaptor::RoamingFolder)->_get_RoamingFolder(&value)); return from_abi(value); }
			ptr<StorageFolder> operator()() { return get(); }
			operator ptr<StorageFolder> () { return get(); }
			ptr<StorageFolder> operator->() { return get(); }
		} RoamingFolder;
		struct : property {
			ptr<ApplicationDataContainer> get() { ApplicationDataContainer* value; hrcheck(enc(&IApplicationData_adaptor::RoamingSettings)->_get_RoamingSettings(&value)); return from_abi(value); }
			ptr<ApplicationDataContainer> operator()() { return get(); }
			operator ptr<ApplicationDataContainer> () { return get(); }
			ptr<ApplicationDataContainer> operator->() { return get(); }
		} RoamingSettings;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IApplicationData_adaptor::RoamingStorageQuota)->_get_RoamingStorageQuota(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} RoamingStorageQuota;
		struct : property {
			ptr<StorageFolder> get() { StorageFolder* value; hrcheck(enc(&IApplicationData_adaptor::TemporaryFolder)->_get_TemporaryFolder(&value)); return from_abi(value); }
			ptr<StorageFolder> operator()() { return get(); }
			operator ptr<StorageFolder> () { return get(); }
			ptr<StorageFolder> operator->() { return get(); }
		} TemporaryFolder;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IApplicationData_adaptor::Version)->_get_Version(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Version;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<ApplicationData>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IApplicationData_adaptor::DataChanged)->_add_DataChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IApplicationData_adaptor::DataChanged)->_remove_DataChanged(token)); }
		} DataChanged;
	};
	ptr<Foundation::IAsyncAction> SetVersionAsync(unsigned desiredVersion, handler_ref<ApplicationDataSetVersionHandler> handler) { Foundation::IAsyncAction* setVersionOperation; hrcheck(X::get()->_SetVersionAsync(desiredVersion, handler, &setVersionOperation)); return from_abi(setVersionOperation); }
	ptr<Foundation::IAsyncAction> ClearAsync() { Foundation::IAsyncAction* clearOperation; hrcheck(X::get()->_ClearAllAsync(&clearOperation)); return from_abi(clearOperation); }
	ptr<Foundation::IAsyncAction> ClearAsync(ApplicationDataLocality locality) { Foundation::IAsyncAction* clearOperation; hrcheck(X::get()->_ClearAsync(locality, &clearOperation)); return from_abi(clearOperation); }
	void SignalDataChanged() { hrcheck(X::get()->_SignalDataChanged()); }
	IApplicationData_adaptor() {}
};
template<typename X> struct adapt<IApplicationData, X> : Windows::Storage::IApplicationData_adaptor<X> { typedef adapt IApplicationData; };
struct IApplicationData : IApplicationData_raw, generate<IApplicationData> {};

// ApplicationData
template<typename> struct ApplicationData_statics {
	static struct _Current : property {
		ptr<ApplicationData> get() { ApplicationData* value; hrcheck(get_activation_factory<ApplicationData, IApplicationDataStatics>()->_get_Current(&value)); return from_abi(value); }
		ptr<ApplicationData> operator()() { return get(); }
		operator ptr<ApplicationData> () { return get(); }
		ptr<ApplicationData> operator->() { return get(); }
	} Current;
	static ptr<Foundation::IAsyncOperation<ptr<ApplicationData>>> GetForUserAsync(pptr<System::User> user) { Foundation::IAsyncOperation<ApplicationData*>* getForUserOperation; hrcheck(get_activation_factory<ApplicationData, IApplicationDataStatics2>()->_GetForUserAsync(user, &getForUserOperation)); return from_abi(getForUserOperation); }
};
template<typename X> typename ApplicationData_statics<X>::_Current ApplicationData_statics<X>::Current;

template<typename X> struct statics<ApplicationData, X> : X, Windows::Storage::ApplicationData_statics<void> {
	typedef typename X::root_type ApplicationData;
};
struct ApplicationData : generate<ApplicationData> {
	using IApplicationData::ClearAsync;
};

// ApplicationDataSetVersionHandler
struct ApplicationDataSetVersionHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(SetVersionRequest* setVersionRequest) = 0;
};

// ISetVersionRequest
struct ISetVersionRequest_raw : IInspectable {
	virtual STDMETHODIMP _get_CurrentVersion(unsigned *currentVersion);
	virtual STDMETHODIMP _get_DesiredVersion(unsigned *desiredVersion);
	virtual STDMETHODIMP _GetDeferral(SetVersionDeferral* *deferral);
};
template<typename X> struct ISetVersionRequest_adaptor : X {
	union {
		struct : property {
			unsigned get() { unsigned currentVersion; hrcheck(enc(&ISetVersionRequest_adaptor::CurrentVersion)->_get_CurrentVersion(&currentVersion)); return currentVersion; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} CurrentVersion;
		struct : property {
			unsigned get() { unsigned desiredVersion; hrcheck(enc(&ISetVersionRequest_adaptor::DesiredVersion)->_get_DesiredVersion(&desiredVersion)); return desiredVersion; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} DesiredVersion;
	};
	ptr<SetVersionDeferral> GetDeferral() { SetVersionDeferral* deferral; hrcheck(X::get()->_GetDeferral(&deferral)); return from_abi(deferral); }
	ISetVersionRequest_adaptor() {}
};
template<typename X> struct adapt<ISetVersionRequest, X> : Windows::Storage::ISetVersionRequest_adaptor<X> { typedef adapt ISetVersionRequest; };
struct ISetVersionRequest : ISetVersionRequest_raw, generate<ISetVersionRequest> {};

// SetVersionRequest
template<typename X> struct statics<SetVersionRequest, X> : X {
	typedef typename X::root_type SetVersionRequest;
};
struct SetVersionRequest : generate<SetVersionRequest> {};

// IApplicationDataContainer
struct IApplicationDataContainer_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_Locality(ApplicationDataLocality *value);
	virtual STDMETHODIMP _get_Values(Foundation::Collections::IPropertySet* *value);
	virtual STDMETHODIMP _get_Containers(Foundation::Collections::IMapView<HSTRING, ApplicationDataContainer*>* *value);
	virtual STDMETHODIMP _CreateContainer(HSTRING name, ApplicationDataCreateDisposition disposition, ApplicationDataContainer* *container);
	virtual STDMETHODIMP _DeleteContainer(HSTRING name);
};
template<typename X> struct IApplicationDataContainer_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, ptr<ApplicationDataContainer>>> get() { Foundation::Collections::IMapView<HSTRING, ApplicationDataContainer*>* value; hrcheck(enc(&IApplicationDataContainer_adaptor::Containers)->_get_Containers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<ApplicationDataContainer>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, ptr<ApplicationDataContainer>>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<ApplicationDataContainer>>> operator->() { return get(); }
		} Containers;
		struct : property {
			ApplicationDataLocality get() { ApplicationDataLocality value; hrcheck(enc(&IApplicationDataContainer_adaptor::Locality)->_get_Locality(&value)); return value; }
			ApplicationDataLocality operator()() { return get(); }
			operator ApplicationDataLocality () { return get(); }
		} Locality;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IApplicationDataContainer_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			ptr<Foundation::Collections::IPropertySet> get() { Foundation::Collections::IPropertySet* value; hrcheck(enc(&IApplicationDataContainer_adaptor::Values)->_get_Values(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IPropertySet> operator()() { return get(); }
			operator ptr<Foundation::Collections::IPropertySet> () { return get(); }
			ptr<Foundation::Collections::IPropertySet> operator->() { return get(); }
		} Values;
	};
	ptr<ApplicationDataContainer> CreateContainer(hstring_ref name, ApplicationDataCreateDisposition disposition) { ApplicationDataContainer* container; hrcheck(X::get()->_CreateContainer(name, disposition, &container)); return from_abi(container); }
	void DeleteContainer(hstring_ref name) { hrcheck(X::get()->_DeleteContainer(name)); }
	IApplicationDataContainer_adaptor() {}
};
template<typename X> struct adapt<IApplicationDataContainer, X> : Windows::Storage::IApplicationDataContainer_adaptor<X> { typedef adapt IApplicationDataContainer; };
struct IApplicationDataContainer : IApplicationDataContainer_raw, generate<IApplicationDataContainer> {};

// ApplicationDataContainer
template<typename X> struct statics<ApplicationDataContainer, X> : X {
	typedef typename X::root_type ApplicationDataContainer;
};
struct ApplicationDataContainer : generate<ApplicationDataContainer> {};

// ISetVersionDeferral
struct ISetVersionDeferral_raw : IInspectable {
	virtual STDMETHODIMP _Complete();
};
template<typename X> struct ISetVersionDeferral_adaptor : X {
	void Complete() { hrcheck(X::get()->_Complete()); }
};
template<typename X> struct adapt<ISetVersionDeferral, X> : Windows::Storage::ISetVersionDeferral_adaptor<X> { typedef adapt ISetVersionDeferral; };
struct ISetVersionDeferral : ISetVersionDeferral_raw, generate<ISetVersionDeferral> {};

// SetVersionDeferral
template<typename X> struct statics<SetVersionDeferral, X> : X {
	typedef typename X::root_type SetVersionDeferral;
};
struct SetVersionDeferral : generate<SetVersionDeferral> {};

// ApplicationDataContainerSettings
template<typename X> struct statics<ApplicationDataContainerSettings, X> : X {
	typedef typename X::root_type ApplicationDataContainerSettings;
};
struct ApplicationDataContainerSettings : generate<ApplicationDataContainerSettings> {};

// ApplicationDataCompositeValue
template<typename X> struct statics<ApplicationDataCompositeValue, X> : X {
	typedef typename X::root_type ApplicationDataCompositeValue;
};
struct ApplicationDataCompositeValue : generate<ApplicationDataCompositeValue> {};
}}
} // namespace iso_winrt
