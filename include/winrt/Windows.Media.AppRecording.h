#pragma once
// generated by isopod tools
// namespaces:
// Windows.Media.AppRecording

#include "Windows.Media.AppRecording.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IVectorView;
template<typename T> struct IIterable;
}}
namespace Storage {
struct StorageFolder;
struct StorageFile;
}}

// defs

template<> struct def<Windows::Media::AppRecording::AppRecordingContract> : value_type<> {};
template<> struct def<Windows::Media::AppRecording::AppRecordingSaveScreenshotOption> : enum_type<int> {};
template<> struct def<Windows::Media::AppRecording::IAppRecordingManager> : interface_type<> {};
template<> struct def<Windows::Media::AppRecording::IAppRecordingStatus> : interface_type<> {};
template<> struct def<Windows::Media::AppRecording::AppRecordingStatus> : class_type<Platform::Object, Windows::Media::AppRecording::IAppRecordingStatus> {};
template<> struct def<Windows::Media::AppRecording::IAppRecordingResult> : interface_type<> {};
template<> struct def<Windows::Media::AppRecording::AppRecordingResult> : class_type<Platform::Object, Windows::Media::AppRecording::IAppRecordingResult> {};
template<> struct def<Windows::Media::AppRecording::IAppRecordingSaveScreenshotResult> : interface_type<> {};
template<> struct def<Windows::Media::AppRecording::AppRecordingSaveScreenshotResult> : class_type<Platform::Object, Windows::Media::AppRecording::IAppRecordingSaveScreenshotResult> {};
template<> struct def<Windows::Media::AppRecording::IAppRecordingManagerStatics> : interface_type<> {};
template<> struct def<Windows::Media::AppRecording::AppRecordingManager> : class_type<Platform::Object, Windows::Media::AppRecording::IAppRecordingManager> {};
template<> struct def<Windows::Media::AppRecording::IAppRecordingStatusDetails> : interface_type<> {};
template<> struct def<Windows::Media::AppRecording::AppRecordingStatusDetails> : class_type<Platform::Object, Windows::Media::AppRecording::IAppRecordingStatusDetails> {};
template<> struct def<Windows::Media::AppRecording::IAppRecordingSavedScreenshotInfo> : interface_type<> {};
template<> struct def<Windows::Media::AppRecording::AppRecordingSavedScreenshotInfo> : class_type<Platform::Object, Windows::Media::AppRecording::IAppRecordingSavedScreenshotInfo> {};

// uuids

template<> struct uuid<Windows::Media::AppRecording::IAppRecordingManager> { define_guid(0xE7E26076, 0xA044, 0x48E2, 0xA5, 0x12, 0x30, 0x94, 0xD5, 0x74, 0xC7, 0xCC);};
template<> struct uuid<Windows::Media::AppRecording::IAppRecordingStatus> { define_guid(0x1D0CC82C, 0xBC18, 0x4B8A, 0xA6, 0xEF, 0x12, 0x7E, 0xFA, 0xB3, 0xB5, 0xD9);};
template<> struct uuid<Windows::Media::AppRecording::IAppRecordingResult> { define_guid(0x3A900864, 0xC66D, 0x46F9, 0xB2, 0xD9, 0x5B, 0xC2, 0xDA, 0xD0, 0x70, 0xD7);};
template<> struct uuid<Windows::Media::AppRecording::IAppRecordingSaveScreenshotResult> { define_guid(0x9C5B8D0A, 0xABB, 0x4457, 0xAA, 0xEE, 0x24, 0xF9, 0xC1, 0x2E, 0xC7, 0x78);};
template<> struct uuid<Windows::Media::AppRecording::IAppRecordingManagerStatics> { define_guid(0x50E709F7, 0x38CE, 0x4BD3, 0x9D, 0xB2, 0xE7, 0x2B, 0xBE, 0x9D, 0xE1, 0x1D);};
template<> struct uuid<Windows::Media::AppRecording::IAppRecordingStatusDetails> { define_guid(0xB538A9B0, 0x14ED, 0x4412, 0xAC, 0x45, 0x6D, 0x67, 0x2C, 0x9C, 0x99, 0x49);};
template<> struct uuid<Windows::Media::AppRecording::IAppRecordingSavedScreenshotInfo> { define_guid(0x9B642D0A, 0x189A, 0x4D00, 0xBF, 0x25, 0xE1, 0xBB, 0x12, 0x49, 0xD5, 0x94);};

// types

namespace Windows { namespace Media { namespace AppRecording {

// IAppRecordingManager
struct IAppRecordingManager_raw : IInspectable {
	virtual STDMETHODIMP _GetStatus(AppRecordingStatus* *result);
	virtual STDMETHODIMP _StartRecordingToFileAsync(Storage::StorageFile* file, Foundation::IAsyncOperation<AppRecordingResult*>* *operation);
	virtual STDMETHODIMP _RecordTimeSpanToFileAsync(Foundation::DateTime startTime, Foundation::TimeSpan duration, Storage::StorageFile* file, Foundation::IAsyncOperation<AppRecordingResult*>* *operation);
	virtual STDMETHODIMP _get_SupportedScreenshotMediaEncodingSubtypes(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _SaveScreenshotToFilesAsync(Storage::StorageFolder* folder, HSTRING filenamePrefix, AppRecordingSaveScreenshotOption option, Foundation::Collections::IIterable<HSTRING>* requestedFormats, Foundation::IAsyncOperation<AppRecordingSaveScreenshotResult*>* *operation);
};
template<typename X> struct IAppRecordingManager_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&IAppRecordingManager_adaptor::SupportedScreenshotMediaEncodingSubtypes)->_get_SupportedScreenshotMediaEncodingSubtypes(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} SupportedScreenshotMediaEncodingSubtypes;
	};
	ptr<AppRecordingStatus> GetStatus() { AppRecordingStatus* result; hrcheck(X::get()->_GetStatus(&result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<AppRecordingResult>>> StartRecordingToFileAsync(pptr<Storage::StorageFile> file) { Foundation::IAsyncOperation<AppRecordingResult*>* operation; hrcheck(X::get()->_StartRecordingToFileAsync(file, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<AppRecordingResult>>> RecordTimeSpanToFileAsync(const Foundation::DateTime& startTime, const Foundation::TimeSpan& duration, pptr<Storage::StorageFile> file) { Foundation::IAsyncOperation<AppRecordingResult*>* operation; hrcheck(X::get()->_RecordTimeSpanToFileAsync(startTime, duration, file, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<AppRecordingSaveScreenshotResult>>> SaveScreenshotToFilesAsync(pptr<Storage::StorageFolder> folder, hstring_ref filenamePrefix, AppRecordingSaveScreenshotOption option, pptr<Foundation::Collections::IIterable<hstring>> requestedFormats) { Foundation::IAsyncOperation<AppRecordingSaveScreenshotResult*>* operation; hrcheck(X::get()->_SaveScreenshotToFilesAsync(folder, filenamePrefix, option, to_abi(requestedFormats), &operation)); return from_abi(operation); }
	IAppRecordingManager_adaptor() {}
};
template<typename X> struct adapt<IAppRecordingManager, X> : Windows::Media::AppRecording::IAppRecordingManager_adaptor<X> { typedef adapt IAppRecordingManager; };
struct IAppRecordingManager : IAppRecordingManager_raw, generate<IAppRecordingManager> {};

// IAppRecordingStatus
struct IAppRecordingStatus_raw : IInspectable {
	virtual STDMETHODIMP _get_CanRecord(bool *value);
	virtual STDMETHODIMP _get_CanRecordTimeSpan(bool *value);
	virtual STDMETHODIMP _get_HistoricalBufferDuration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_Details(AppRecordingStatusDetails* *value);
};
template<typename X> struct IAppRecordingStatus_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppRecordingStatus_adaptor::CanRecord)->_get_CanRecord(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanRecord;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppRecordingStatus_adaptor::CanRecordTimeSpan)->_get_CanRecordTimeSpan(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} CanRecordTimeSpan;
		struct : property {
			ptr<AppRecordingStatusDetails> get() { AppRecordingStatusDetails* value; hrcheck(enc(&IAppRecordingStatus_adaptor::Details)->_get_Details(&value)); return from_abi(value); }
			ptr<AppRecordingStatusDetails> operator()() { return get(); }
			operator ptr<AppRecordingStatusDetails> () { return get(); }
			ptr<AppRecordingStatusDetails> operator->() { return get(); }
		} Details;
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IAppRecordingStatus_adaptor::HistoricalBufferDuration)->_get_HistoricalBufferDuration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} HistoricalBufferDuration;
	};
	IAppRecordingStatus_adaptor() {}
};
template<typename X> struct adapt<IAppRecordingStatus, X> : Windows::Media::AppRecording::IAppRecordingStatus_adaptor<X> { typedef adapt IAppRecordingStatus; };
struct IAppRecordingStatus : IAppRecordingStatus_raw, generate<IAppRecordingStatus> {};

// AppRecordingStatus
template<typename X> struct statics<AppRecordingStatus, X> : X {
	typedef typename X::root_type AppRecordingStatus;
};
struct AppRecordingStatus : generate<AppRecordingStatus> {};

// IAppRecordingResult
struct IAppRecordingResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Succeeded(bool *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
	virtual STDMETHODIMP _get_Duration(Foundation::TimeSpan *value);
	virtual STDMETHODIMP _get_IsFileTruncated(bool *value);
};
template<typename X> struct IAppRecordingResult_adaptor : X {
	union {
		struct : property {
			Foundation::TimeSpan get() { Foundation::TimeSpan value; hrcheck(enc(&IAppRecordingResult_adaptor::Duration)->_get_Duration(&value)); return value; }
			Foundation::TimeSpan operator()() { return get(); }
			operator Foundation::TimeSpan () { return get(); }
		} Duration;
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IAppRecordingResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppRecordingResult_adaptor::IsFileTruncated)->_get_IsFileTruncated(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsFileTruncated;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppRecordingResult_adaptor::Succeeded)->_get_Succeeded(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Succeeded;
	};
	IAppRecordingResult_adaptor() {}
};
template<typename X> struct adapt<IAppRecordingResult, X> : Windows::Media::AppRecording::IAppRecordingResult_adaptor<X> { typedef adapt IAppRecordingResult; };
struct IAppRecordingResult : IAppRecordingResult_raw, generate<IAppRecordingResult> {};

// AppRecordingResult
template<typename X> struct statics<AppRecordingResult, X> : X {
	typedef typename X::root_type AppRecordingResult;
};
struct AppRecordingResult : generate<AppRecordingResult> {};

// IAppRecordingSaveScreenshotResult
struct IAppRecordingSaveScreenshotResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Succeeded(bool *value);
	virtual STDMETHODIMP _get_ExtendedError(Foundation::HResult *value);
	virtual STDMETHODIMP _get_SavedScreenshotInfos(Foundation::Collections::IVectorView<AppRecordingSavedScreenshotInfo*>* *value);
};
template<typename X> struct IAppRecordingSaveScreenshotResult_adaptor : X {
	union {
		struct : property {
			Foundation::HResult get() { Foundation::HResult value; hrcheck(enc(&IAppRecordingSaveScreenshotResult_adaptor::ExtendedError)->_get_ExtendedError(&value)); return value; }
			Foundation::HResult operator()() { return get(); }
			operator Foundation::HResult () { return get(); }
		} ExtendedError;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<AppRecordingSavedScreenshotInfo>>> get() { Foundation::Collections::IVectorView<AppRecordingSavedScreenshotInfo*>* value; hrcheck(enc(&IAppRecordingSaveScreenshotResult_adaptor::SavedScreenshotInfos)->_get_SavedScreenshotInfos(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<AppRecordingSavedScreenshotInfo>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<AppRecordingSavedScreenshotInfo>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<AppRecordingSavedScreenshotInfo>>> operator->() { return get(); }
		} SavedScreenshotInfos;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppRecordingSaveScreenshotResult_adaptor::Succeeded)->_get_Succeeded(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} Succeeded;
	};
	IAppRecordingSaveScreenshotResult_adaptor() {}
};
template<typename X> struct adapt<IAppRecordingSaveScreenshotResult, X> : Windows::Media::AppRecording::IAppRecordingSaveScreenshotResult_adaptor<X> { typedef adapt IAppRecordingSaveScreenshotResult; };
struct IAppRecordingSaveScreenshotResult : IAppRecordingSaveScreenshotResult_raw, generate<IAppRecordingSaveScreenshotResult> {};

// AppRecordingSaveScreenshotResult
template<typename X> struct statics<AppRecordingSaveScreenshotResult, X> : X {
	typedef typename X::root_type AppRecordingSaveScreenshotResult;
};
struct AppRecordingSaveScreenshotResult : generate<AppRecordingSaveScreenshotResult> {};

// IAppRecordingManagerStatics
struct IAppRecordingManagerStatics : IInspectable {
	virtual STDMETHODIMP _GetDefault(AppRecordingManager* *result);
};

// AppRecordingManager
template<typename> struct AppRecordingManager_statics {
	static ptr<AppRecordingManager> GetDefault() { AppRecordingManager* result; hrcheck(get_activation_factory<AppRecordingManager, IAppRecordingManagerStatics>()->_GetDefault(&result)); return from_abi(result); }
};

template<typename X> struct statics<AppRecordingManager, X> : X, Windows::Media::AppRecording::AppRecordingManager_statics<void> {
	typedef typename X::root_type AppRecordingManager;
};
struct AppRecordingManager : generate<AppRecordingManager> {};

// IAppRecordingStatusDetails
struct IAppRecordingStatusDetails_raw : IInspectable {
	virtual STDMETHODIMP _get_IsAnyAppBroadcasting(bool *value);
	virtual STDMETHODIMP _get_IsCaptureResourceUnavailable(bool *value);
	virtual STDMETHODIMP _get_IsGameStreamInProgress(bool *value);
	virtual STDMETHODIMP _get_IsTimeSpanRecordingDisabled(bool *value);
	virtual STDMETHODIMP _get_IsGpuConstrained(bool *value);
	virtual STDMETHODIMP _get_IsAppInactive(bool *value);
	virtual STDMETHODIMP _get_IsBlockedForApp(bool *value);
	virtual STDMETHODIMP _get_IsDisabledByUser(bool *value);
	virtual STDMETHODIMP _get_IsDisabledBySystem(bool *value);
};
template<typename X> struct IAppRecordingStatusDetails_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppRecordingStatusDetails_adaptor::IsAnyAppBroadcasting)->_get_IsAnyAppBroadcasting(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsAnyAppBroadcasting;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppRecordingStatusDetails_adaptor::IsAppInactive)->_get_IsAppInactive(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsAppInactive;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppRecordingStatusDetails_adaptor::IsBlockedForApp)->_get_IsBlockedForApp(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsBlockedForApp;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppRecordingStatusDetails_adaptor::IsCaptureResourceUnavailable)->_get_IsCaptureResourceUnavailable(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsCaptureResourceUnavailable;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppRecordingStatusDetails_adaptor::IsDisabledBySystem)->_get_IsDisabledBySystem(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsDisabledBySystem;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppRecordingStatusDetails_adaptor::IsDisabledByUser)->_get_IsDisabledByUser(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsDisabledByUser;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppRecordingStatusDetails_adaptor::IsGameStreamInProgress)->_get_IsGameStreamInProgress(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsGameStreamInProgress;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppRecordingStatusDetails_adaptor::IsGpuConstrained)->_get_IsGpuConstrained(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsGpuConstrained;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IAppRecordingStatusDetails_adaptor::IsTimeSpanRecordingDisabled)->_get_IsTimeSpanRecordingDisabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsTimeSpanRecordingDisabled;
	};
	IAppRecordingStatusDetails_adaptor() {}
};
template<typename X> struct adapt<IAppRecordingStatusDetails, X> : Windows::Media::AppRecording::IAppRecordingStatusDetails_adaptor<X> { typedef adapt IAppRecordingStatusDetails; };
struct IAppRecordingStatusDetails : IAppRecordingStatusDetails_raw, generate<IAppRecordingStatusDetails> {};

// AppRecordingStatusDetails
template<typename X> struct statics<AppRecordingStatusDetails, X> : X {
	typedef typename X::root_type AppRecordingStatusDetails;
};
struct AppRecordingStatusDetails : generate<AppRecordingStatusDetails> {};

// IAppRecordingSavedScreenshotInfo
struct IAppRecordingSavedScreenshotInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_File(Storage::StorageFile* *value);
	virtual STDMETHODIMP _get_MediaEncodingSubtype(HSTRING *value);
};
template<typename X> struct IAppRecordingSavedScreenshotInfo_adaptor : X {
	union {
		struct : property {
			ptr<Storage::StorageFile> get() { Storage::StorageFile* value; hrcheck(enc(&IAppRecordingSavedScreenshotInfo_adaptor::File)->_get_File(&value)); return from_abi(value); }
			ptr<Storage::StorageFile> operator()() { return get(); }
			operator ptr<Storage::StorageFile> () { return get(); }
			ptr<Storage::StorageFile> operator->() { return get(); }
		} File;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IAppRecordingSavedScreenshotInfo_adaptor::MediaEncodingSubtype)->_get_MediaEncodingSubtype(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} MediaEncodingSubtype;
	};
	IAppRecordingSavedScreenshotInfo_adaptor() {}
};
template<typename X> struct adapt<IAppRecordingSavedScreenshotInfo, X> : Windows::Media::AppRecording::IAppRecordingSavedScreenshotInfo_adaptor<X> { typedef adapt IAppRecordingSavedScreenshotInfo; };
struct IAppRecordingSavedScreenshotInfo : IAppRecordingSavedScreenshotInfo_raw, generate<IAppRecordingSavedScreenshotInfo> {};

// AppRecordingSavedScreenshotInfo
template<typename X> struct statics<AppRecordingSavedScreenshotInfo, X> : X {
	typedef typename X::root_type AppRecordingSavedScreenshotInfo;
};
struct AppRecordingSavedScreenshotInfo : generate<AppRecordingSavedScreenshotInfo> {};
}}}
} // namespace iso_winrt
