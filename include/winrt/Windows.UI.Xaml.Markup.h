#pragma once
// generated by isopod tools
// namespaces:
// Windows.UI.Xaml.Markup

#include "Windows.UI.Xaml.Markup.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.UI.Xaml.Interop.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IVector;
}}
namespace Storage { namespace Streams {
struct IRandomAccessStream;
}}
namespace UI { namespace Xaml {
struct UIElement;
struct DependencyProperty;
struct DependencyObject;
}}}

// defs

template<> struct def<Windows::UI::Xaml::Markup::ContentPropertyAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::UI::Xaml::Markup::XamlBinaryWriterErrorInformation> : value_type<unsigned, unsigned, unsigned> {};
template<> struct def<Windows::UI::Xaml::Markup::XmlnsDefinition> : value_type<HSTRING, HSTRING> {};
template<> struct def<Windows::UI::Xaml::Markup::MarkupExtensionReturnTypeAttribute> : class_type<Platform::Attribute, Platform::Object> {};
template<> struct def<Windows::UI::Xaml::Markup::IComponentConnector> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::IComponentConnector2> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::IDataTemplateComponent> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::IXamlMember> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::IXamlType> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::IXamlMetadataProvider> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::IMarkupExtension> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::IMarkupExtensionOverrides> : overridable_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::IMarkupExtensionFactory> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::MarkupExtension> : class_type<Platform::Object, Windows::UI::Xaml::Markup::IMarkupExtension, Windows::UI::Xaml::Markup::IMarkupExtensionOverrides>, composer_type<Windows::UI::Xaml::Markup::IMarkupExtensionFactory> {};
template<> struct def<Windows::UI::Xaml::Markup::IXamlBinaryWriter> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::IXamlBinaryWriterStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::XamlBinaryWriter> : class_type<Platform::Object, Windows::UI::Xaml::Markup::IXamlBinaryWriter> {};
template<> struct def<Windows::UI::Xaml::Markup::IXamlBindingHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::IXamlBindingHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::XamlBindingHelper> : class_type<Platform::Object, Windows::UI::Xaml::Markup::IXamlBindingHelper> {};
template<> struct def<Windows::UI::Xaml::Markup::IXamlMarkupHelper> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::IXamlMarkupHelperStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::XamlMarkupHelper> : class_type<Platform::Object, Windows::UI::Xaml::Markup::IXamlMarkupHelper> {};
template<> struct def<Windows::UI::Xaml::Markup::IXamlReader> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::IXamlReaderStatics> : interface_type<> {};
template<> struct def<Windows::UI::Xaml::Markup::XamlReader> : class_type<Platform::Object, Windows::UI::Xaml::Markup::IXamlReader> {};

// uuids

template<> struct uuid<Windows::UI::Xaml::Markup::IComponentConnector> { define_guid(0xF6790987, 0xE6E5, 0x47F2, 0x92, 0xC6, 0xEC, 0xCC, 0xE4, 0xBA, 0x15, 0x9A);};
template<> struct uuid<Windows::UI::Xaml::Markup::IComponentConnector2> { define_guid(0xDC8F368B, 0xECCC, 0x498E, 0xB1, 0x39, 0x91, 0x14, 0x22, 0x54, 0xD7, 0xAE);};
template<> struct uuid<Windows::UI::Xaml::Markup::IDataTemplateComponent> { define_guid(0x8429DC8, 0x8AB0, 0x4747, 0xAA, 0x9A, 0xFE, 0xAD, 0xFC, 0x8D, 0xA8, 0xE1);};
template<> struct uuid<Windows::UI::Xaml::Markup::IXamlMember> { define_guid(0xC541F58C, 0x43A9, 0x4216, 0xB7, 0x18, 0xE0, 0xB1, 0x1B, 0x14, 0xE9, 0x3E);};
template<> struct uuid<Windows::UI::Xaml::Markup::IXamlType> { define_guid(0x7920EAB1, 0xA2E5, 0x479A, 0xBD, 0x50, 0x6C, 0xEF, 0x3C, 0xB, 0x49, 0x70);};
template<> struct uuid<Windows::UI::Xaml::Markup::IXamlMetadataProvider> { define_guid(0xB3765D69, 0x68A5, 0x4B32, 0x88, 0x61, 0xFD, 0xB9, 0xC, 0x1F, 0x58, 0x36);};
template<> struct uuid<Windows::UI::Xaml::Markup::IMarkupExtension> { define_guid(0x1EE3416D, 0x562B, 0x486E, 0x9E, 0xE5, 0xF, 0xC, 0xBC, 0xC8, 0x4, 0x8C);};
template<> struct uuid<Windows::UI::Xaml::Markup::IMarkupExtensionOverrides> { define_guid(0x393779BF, 0xB9C0, 0x4FFB, 0xA5, 0x7F, 0x58, 0xE7, 0x35, 0x6E, 0x42, 0x5F);};
template<> struct uuid<Windows::UI::Xaml::Markup::IMarkupExtensionFactory> { define_guid(0x65329C05, 0xFB5A, 0x4567, 0x9D, 0x55, 0x5C, 0xDF, 0xBA, 0xDA, 0x27, 0x39);};
template<> struct uuid<Windows::UI::Xaml::Markup::IXamlBinaryWriter> { define_guid(0x829D2AD3, 0x620A, 0x46F6, 0x84, 0x5D, 0x43, 0x6A, 0x5, 0x92, 0x71, 0x0);};
template<> struct uuid<Windows::UI::Xaml::Markup::IXamlBinaryWriterStatics> { define_guid(0xD8ED07A, 0x9B82, 0x4AA8, 0xB6, 0x8B, 0x2, 0x6F, 0x2D, 0xE1, 0xCC, 0x86);};
template<> struct uuid<Windows::UI::Xaml::Markup::IXamlBindingHelper> { define_guid(0xFAA6FB06, 0x8AB9, 0x4EF7, 0x8A, 0xE7, 0xFB, 0xD3, 0xB, 0xBF, 0xD0, 0x6D);};
template<> struct uuid<Windows::UI::Xaml::Markup::IXamlBindingHelperStatics> { define_guid(0xF65CFB71, 0xC80C, 0x4FFA, 0x86, 0xEE, 0x55, 0x87, 0x54, 0xEE, 0x33, 0x6D);};
template<> struct uuid<Windows::UI::Xaml::Markup::IXamlMarkupHelper> { define_guid(0xD0E6673C, 0x5342, 0x44EF, 0x85, 0xA7, 0xED, 0x32, 0x7A, 0x73, 0x9D, 0x9A);};
template<> struct uuid<Windows::UI::Xaml::Markup::IXamlMarkupHelperStatics> { define_guid(0xC9BC3725, 0xF34F, 0x445C, 0x81, 0xA2, 0x6B, 0x72, 0xA5, 0xE8, 0xF0, 0x72);};
template<> struct uuid<Windows::UI::Xaml::Markup::IXamlReader> { define_guid(0x24374CF1, 0xCCEB, 0x48BF, 0xA5, 0x14, 0x41, 0xB0, 0x18, 0x6F, 0x84, 0xC2);};
template<> struct uuid<Windows::UI::Xaml::Markup::IXamlReaderStatics> { define_guid(0x9891C6BD, 0x534F, 0x4955, 0xB8, 0x5A, 0x8A, 0x8D, 0xC0, 0xDC, 0xA6, 0x2);};

// types

namespace Windows { namespace UI { namespace Xaml { namespace Markup {

// ContentPropertyAttribute
template<typename X> struct statics<ContentPropertyAttribute, X> : X {
	typedef typename X::root_type ContentPropertyAttribute;
};
struct ContentPropertyAttribute : generate<ContentPropertyAttribute> {};

// MarkupExtensionReturnTypeAttribute
template<typename X> struct statics<MarkupExtensionReturnTypeAttribute, X> : X {
	typedef typename X::root_type MarkupExtensionReturnTypeAttribute;
};
struct MarkupExtensionReturnTypeAttribute : generate<MarkupExtensionReturnTypeAttribute> {};

// IComponentConnector
struct IComponentConnector_raw : IInspectable {
	virtual STDMETHODIMP _Connect(int connectionId, IInspectable* target) = 0;
};
template<typename X> struct IComponentConnector_adaptor : X {
	void Connect(int connectionId, object_ref target) { hrcheck(X::get()->_Connect(connectionId, target)); }
};
template<typename X> struct adapt<IComponentConnector, X> : Windows::UI::Xaml::Markup::IComponentConnector_adaptor<X> { typedef adapt IComponentConnector; };
template<typename X> struct IComponentConnector_unadaptor : X {
	STDMETHODIMP _Connect(int connectionId, IInspectable* target) { return hrtry([&, this] { X::get()->Connect(connectionId, target); }); }
};
template<typename X> struct unadapt<IComponentConnector, X> : Windows::UI::Xaml::Markup::IComponentConnector_unadaptor<X> {};
struct IComponentConnector : IComponentConnector_raw, generate<IComponentConnector> {};

// IComponentConnector2
struct IComponentConnector2_raw : IInspectable {
	virtual STDMETHODIMP _GetBindingConnector(int connectionId, IInspectable* target, IComponentConnector* *returnValue) = 0;
};
template<typename X> struct IComponentConnector2_adaptor : X {
	ptr<IComponentConnector> GetBindingConnector(int connectionId, object_ref target) { IComponentConnector* returnValue; hrcheck(X::get()->_GetBindingConnector(connectionId, target, &returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IComponentConnector2, X> : Windows::UI::Xaml::Markup::IComponentConnector2_adaptor<X> { typedef adapt IComponentConnector2; };
template<typename X> struct IComponentConnector2_unadaptor : X {
	STDMETHODIMP _GetBindingConnector(int connectionId, IInspectable* target, IComponentConnector* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->GetBindingConnector(connectionId, target)); }); }
};
template<typename X> struct unadapt<IComponentConnector2, X> : Windows::UI::Xaml::Markup::IComponentConnector2_unadaptor<X> {};
struct IComponentConnector2 : IComponentConnector2_raw, generate<IComponentConnector2> {};

// IDataTemplateComponent
struct IDataTemplateComponent_raw : IInspectable {
	virtual STDMETHODIMP _Recycle() = 0;
	virtual STDMETHODIMP _ProcessBindings(IInspectable* item, int itemIndex, int phase, int *nextPhase) = 0;
};
template<typename X> struct IDataTemplateComponent_adaptor : X {
	void Recycle() { hrcheck(X::get()->_Recycle()); }
	int ProcessBindings(object_ref item, int itemIndex, int phase) { int nextPhase; hrcheck(X::get()->_ProcessBindings(item, itemIndex, phase, &nextPhase)); return nextPhase; }
};
template<typename X> struct adapt<IDataTemplateComponent, X> : Windows::UI::Xaml::Markup::IDataTemplateComponent_adaptor<X> { typedef adapt IDataTemplateComponent; };
template<typename X> struct IDataTemplateComponent_unadaptor : X {
	STDMETHODIMP _Recycle() { return hrtry([&, this] { X::get()->Recycle(); }); }
	STDMETHODIMP _ProcessBindings(IInspectable* item, int itemIndex, int phase, int *nextPhase) { return hrtry([&, this] { *nextPhase = X::get()->ProcessBindings(item, itemIndex, phase, ); }); }
};
template<typename X> struct unadapt<IDataTemplateComponent, X> : Windows::UI::Xaml::Markup::IDataTemplateComponent_unadaptor<X> {};
struct IDataTemplateComponent : IDataTemplateComponent_raw, generate<IDataTemplateComponent> {};

// IXamlMember
struct IXamlMember_raw : IInspectable {
	virtual STDMETHODIMP _get_IsAttachable(bool *value) = 0;
	virtual STDMETHODIMP _get_IsDependencyProperty(bool *value) = 0;
	virtual STDMETHODIMP _get_IsReadOnly(bool *value) = 0;
	virtual STDMETHODIMP _get_Name(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_TargetType(IXamlType* *value) = 0;
	virtual STDMETHODIMP _get_Type(IXamlType* *value) = 0;
	virtual STDMETHODIMP _GetValue(IInspectable* instance, IInspectable* *value) = 0;
	virtual STDMETHODIMP _SetValue(IInspectable* instance, IInspectable* value) = 0;
};
template<typename X> struct IXamlMember_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IXamlMember_adaptor::IsAttachable)->_get_IsAttachable(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsAttachable;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IXamlMember_adaptor::IsDependencyProperty)->_get_IsDependencyProperty(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsDependencyProperty;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IXamlMember_adaptor::IsReadOnly)->_get_IsReadOnly(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsReadOnly;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IXamlMember_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			ptr<IXamlType> get() { IXamlType* value; hrcheck(enc(&IXamlMember_adaptor::TargetType)->_get_TargetType(&value)); return from_abi(value); }
			ptr<IXamlType> operator()() { return get(); }
			operator ptr<IXamlType> () { return get(); }
			ptr<IXamlType> operator->() { return get(); }
		} TargetType;
		struct : property {
			ptr<IXamlType> get() { IXamlType* value; hrcheck(enc(&IXamlMember_adaptor::Type)->_get_Type(&value)); return from_abi(value); }
			ptr<IXamlType> operator()() { return get(); }
			operator ptr<IXamlType> () { return get(); }
			ptr<IXamlType> operator->() { return get(); }
		} Type;
	};
	object GetValue(object_ref instance) { IInspectable* value; hrcheck(X::get()->_GetValue(instance, &value)); return from_abi(value); }
	void SetValue(object_ref instance, object_ref value) { hrcheck(X::get()->_SetValue(instance, value)); }
	IXamlMember_adaptor() {}
};
template<typename X> struct adapt<IXamlMember, X> : Windows::UI::Xaml::Markup::IXamlMember_adaptor<X> { typedef adapt IXamlMember; };
template<typename X> struct IXamlMember_unadaptor : X {
	STDMETHODIMP _get_IsAttachable(bool *value) { return hrtry([&, this] { get_prop(value, IsAttachable); }); }
	STDMETHODIMP _get_IsDependencyProperty(bool *value) { return hrtry([&, this] { get_prop(value, IsDependencyProperty); }); }
	STDMETHODIMP _get_IsReadOnly(bool *value) { return hrtry([&, this] { get_prop(value, IsReadOnly); }); }
	STDMETHODIMP _get_Name(HSTRING *value) { return hrtry([&, this] { get_prop(value, Name); }); }
	STDMETHODIMP _get_TargetType(IXamlType* *value) { return hrtry([&, this] { get_prop(value, TargetType); }); }
	STDMETHODIMP _get_Type(IXamlType* *value) { return hrtry([&, this] { get_prop(value, Type); }); }
	STDMETHODIMP _GetValue(IInspectable* instance, IInspectable* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetValue(instance)); }); }
	STDMETHODIMP _SetValue(IInspectable* instance, IInspectable* value) { return hrtry([&, this] { X::get()->SetValue(instance, value); }); }
};
template<typename X> struct unadapt<IXamlMember, X> : Windows::UI::Xaml::Markup::IXamlMember_unadaptor<X> {};
struct IXamlMember : IXamlMember_raw, generate<IXamlMember> {};

// IXamlType
struct IXamlType_raw : IInspectable {
	virtual STDMETHODIMP _get_BaseType(IXamlType* *value) = 0;
	virtual STDMETHODIMP _get_ContentProperty(IXamlMember* *value) = 0;
	virtual STDMETHODIMP _get_FullName(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_IsArray(bool *value) = 0;
	virtual STDMETHODIMP _get_IsCollection(bool *value) = 0;
	virtual STDMETHODIMP _get_IsConstructible(bool *value) = 0;
	virtual STDMETHODIMP _get_IsDictionary(bool *value) = 0;
	virtual STDMETHODIMP _get_IsMarkupExtension(bool *value) = 0;
	virtual STDMETHODIMP _get_IsBindable(bool *value) = 0;
	virtual STDMETHODIMP _get_ItemType(IXamlType* *value) = 0;
	virtual STDMETHODIMP _get_KeyType(IXamlType* *value) = 0;
	virtual STDMETHODIMP _get_UnderlyingType(Interop::TypeName *value) = 0;
	virtual STDMETHODIMP _ActivateInstance(IInspectable* *instance) = 0;
	virtual STDMETHODIMP _CreateFromString(HSTRING value, IInspectable* *instance) = 0;
	virtual STDMETHODIMP _GetMember(HSTRING name, IXamlMember* *xamlMember) = 0;
	virtual STDMETHODIMP _AddToVector(IInspectable* instance, IInspectable* value) = 0;
	virtual STDMETHODIMP _AddToMap(IInspectable* instance, IInspectable* key, IInspectable* value) = 0;
	virtual STDMETHODIMP _RunInitializer() = 0;
};
template<typename X> struct IXamlType_adaptor : X {
	union {
		struct : property {
			ptr<IXamlType> get() { IXamlType* value; hrcheck(enc(&IXamlType_adaptor::BaseType)->_get_BaseType(&value)); return from_abi(value); }
			ptr<IXamlType> operator()() { return get(); }
			operator ptr<IXamlType> () { return get(); }
			ptr<IXamlType> operator->() { return get(); }
		} BaseType;
		struct : property {
			ptr<IXamlMember> get() { IXamlMember* value; hrcheck(enc(&IXamlType_adaptor::ContentProperty)->_get_ContentProperty(&value)); return from_abi(value); }
			ptr<IXamlMember> operator()() { return get(); }
			operator ptr<IXamlMember> () { return get(); }
			ptr<IXamlMember> operator->() { return get(); }
		} ContentProperty;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IXamlType_adaptor::FullName)->_get_FullName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} FullName;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IXamlType_adaptor::IsArray)->_get_IsArray(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsArray;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IXamlType_adaptor::IsBindable)->_get_IsBindable(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsBindable;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IXamlType_adaptor::IsCollection)->_get_IsCollection(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsCollection;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IXamlType_adaptor::IsConstructible)->_get_IsConstructible(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsConstructible;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IXamlType_adaptor::IsDictionary)->_get_IsDictionary(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsDictionary;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IXamlType_adaptor::IsMarkupExtension)->_get_IsMarkupExtension(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsMarkupExtension;
		struct : property {
			ptr<IXamlType> get() { IXamlType* value; hrcheck(enc(&IXamlType_adaptor::ItemType)->_get_ItemType(&value)); return from_abi(value); }
			ptr<IXamlType> operator()() { return get(); }
			operator ptr<IXamlType> () { return get(); }
			ptr<IXamlType> operator->() { return get(); }
		} ItemType;
		struct : property {
			ptr<IXamlType> get() { IXamlType* value; hrcheck(enc(&IXamlType_adaptor::KeyType)->_get_KeyType(&value)); return from_abi(value); }
			ptr<IXamlType> operator()() { return get(); }
			operator ptr<IXamlType> () { return get(); }
			ptr<IXamlType> operator->() { return get(); }
		} KeyType;
		struct : property {
			Interop::TypeName get() { Interop::TypeName value; hrcheck(enc(&IXamlType_adaptor::UnderlyingType)->_get_UnderlyingType(&value)); return value; }
			Interop::TypeName operator()() { return get(); }
			operator Interop::TypeName () { return get(); }
		} UnderlyingType;
	};
	object ActivateInstance() { IInspectable* instance; hrcheck(X::get()->_ActivateInstance(&instance)); return from_abi(instance); }
	object CreateFromString(hstring_ref value) { IInspectable* instance; hrcheck(X::get()->_CreateFromString(value, &instance)); return from_abi(instance); }
	ptr<IXamlMember> GetMember(hstring_ref name) { IXamlMember* xamlMember; hrcheck(X::get()->_GetMember(name, &xamlMember)); return from_abi(xamlMember); }
	void AddToVector(object_ref instance, object_ref value) { hrcheck(X::get()->_AddToVector(instance, value)); }
	void AddToMap(object_ref instance, object_ref key, object_ref value) { hrcheck(X::get()->_AddToMap(instance, key, value)); }
	void RunInitializer() { hrcheck(X::get()->_RunInitializer()); }
	IXamlType_adaptor() {}
};
template<typename X> struct adapt<IXamlType, X> : Windows::UI::Xaml::Markup::IXamlType_adaptor<X> { typedef adapt IXamlType; };
template<typename X> struct IXamlType_unadaptor : X {
	STDMETHODIMP _get_BaseType(IXamlType* *value) { return hrtry([&, this] { get_prop(value, BaseType); }); }
	STDMETHODIMP _get_ContentProperty(IXamlMember* *value) { return hrtry([&, this] { get_prop(value, ContentProperty); }); }
	STDMETHODIMP _get_FullName(HSTRING *value) { return hrtry([&, this] { get_prop(value, FullName); }); }
	STDMETHODIMP _get_IsArray(bool *value) { return hrtry([&, this] { get_prop(value, IsArray); }); }
	STDMETHODIMP _get_IsCollection(bool *value) { return hrtry([&, this] { get_prop(value, IsCollection); }); }
	STDMETHODIMP _get_IsConstructible(bool *value) { return hrtry([&, this] { get_prop(value, IsConstructible); }); }
	STDMETHODIMP _get_IsDictionary(bool *value) { return hrtry([&, this] { get_prop(value, IsDictionary); }); }
	STDMETHODIMP _get_IsMarkupExtension(bool *value) { return hrtry([&, this] { get_prop(value, IsMarkupExtension); }); }
	STDMETHODIMP _get_IsBindable(bool *value) { return hrtry([&, this] { get_prop(value, IsBindable); }); }
	STDMETHODIMP _get_ItemType(IXamlType* *value) { return hrtry([&, this] { get_prop(value, ItemType); }); }
	STDMETHODIMP _get_KeyType(IXamlType* *value) { return hrtry([&, this] { get_prop(value, KeyType); }); }
	STDMETHODIMP _get_UnderlyingType(Interop::TypeName *value) { return hrtry([&, this] { get_prop(value, UnderlyingType); }); }
	STDMETHODIMP _ActivateInstance(IInspectable* *instance) { return hrtry([&, this] { *instance = to_abi(X::get()->ActivateInstance()); }); }
	STDMETHODIMP _CreateFromString(HSTRING value, IInspectable* *instance) { return hrtry([&, this] { *instance = to_abi(X::get()->CreateFromString(value)); }); }
	STDMETHODIMP _GetMember(HSTRING name, IXamlMember* *xamlMember) { return hrtry([&, this] { *xamlMember = to_abi(X::get()->GetMember(name)); }); }
	STDMETHODIMP _AddToVector(IInspectable* instance, IInspectable* value) { return hrtry([&, this] { X::get()->AddToVector(instance, value); }); }
	STDMETHODIMP _AddToMap(IInspectable* instance, IInspectable* key, IInspectable* value) { return hrtry([&, this] { X::get()->AddToMap(instance, key, value); }); }
	STDMETHODIMP _RunInitializer() { return hrtry([&, this] { X::get()->RunInitializer(); }); }
};
template<typename X> struct unadapt<IXamlType, X> : Windows::UI::Xaml::Markup::IXamlType_unadaptor<X> {};
struct IXamlType : IXamlType_raw, generate<IXamlType> {};

// IXamlMetadataProvider
struct IXamlMetadataProvider_raw : IInspectable {
	virtual STDMETHODIMP _GetXamlType(Interop::TypeName type, IXamlType* *xamlType) = 0;
	virtual STDMETHODIMP _GetXamlTypeByFullName(HSTRING fullName, IXamlType* *xamlType) = 0;
	virtual STDMETHODIMP _GetXmlnsDefinitions(unsigned *definitionsSize, XmlnsDefinition **definitions) = 0;
};
template<typename X> struct IXamlMetadataProvider_adaptor : X {
	ptr<IXamlType> GetXamlType(const Interop::TypeName& type) { IXamlType* xamlType; hrcheck(X::get()->_GetXamlType(type, &xamlType)); return from_abi(xamlType); }
	ptr<IXamlType> GetXamlType(hstring_ref fullName) { IXamlType* xamlType; hrcheck(X::get()->_GetXamlTypeByFullName(fullName, &xamlType)); return from_abi(xamlType); }
	szarray<XmlnsDefinition> GetXmlnsDefinitions() { szarray<XmlnsDefinition> definitions; hrcheck(X::get()->_GetXmlnsDefinitions(&definitions.size, &definitions.p)); return definitions; }
};
template<typename X> struct adapt<IXamlMetadataProvider, X> : Windows::UI::Xaml::Markup::IXamlMetadataProvider_adaptor<X> { typedef adapt IXamlMetadataProvider; };
template<typename X> struct IXamlMetadataProvider_unadaptor : X {
	STDMETHODIMP _GetXamlType(Interop::TypeName type, IXamlType* *xamlType) { return hrtry([&, this] { *xamlType = to_abi(X::get()->GetXamlType(type)); }); }
	STDMETHODIMP _GetXamlTypeByFullName(HSTRING fullName, IXamlType* *xamlType) { return hrtry([&, this] { *xamlType = to_abi(X::get()->GetXamlType(fullName)); }); }
	STDMETHODIMP _GetXmlnsDefinitions(unsigned *definitionsSize, XmlnsDefinition **definitions) { return hrtry([&, this] { *definitions = X::get()->GetXmlnsDefinitions().detach(definitionsSize); }); }
};
template<typename X> struct unadapt<IXamlMetadataProvider, X> : Windows::UI::Xaml::Markup::IXamlMetadataProvider_unadaptor<X> {};
struct IXamlMetadataProvider : IXamlMetadataProvider_raw, generate<IXamlMetadataProvider> {};

// IMarkupExtension
struct IMarkupExtension : IInspectable, generate<IMarkupExtension> {};

// IMarkupExtensionOverrides
struct IMarkupExtensionOverrides_raw : IInspectable {
	virtual STDMETHODIMP _ProvideValue(IInspectable* *returnValue) = 0;
};
template<typename X> struct IMarkupExtensionOverrides_adaptor : X {
	object ProvideValue() { IInspectable* returnValue; hrcheck(X::get()->_ProvideValue(&returnValue)); return from_abi(returnValue); }
};
template<typename X> struct adapt<IMarkupExtensionOverrides, X> : Windows::UI::Xaml::Markup::IMarkupExtensionOverrides_adaptor<X> { typedef adapt IMarkupExtensionOverrides; };
template<typename X> struct IMarkupExtensionOverrides_unadaptor : X {
	STDMETHODIMP _ProvideValue(IInspectable* *returnValue) { return hrtry([&, this] { *returnValue = to_abi(X::get()->ProvideValue()); }); }
};
template<typename X> struct unadapt<IMarkupExtensionOverrides, X> : Windows::UI::Xaml::Markup::IMarkupExtensionOverrides_unadaptor<X> {};
struct IMarkupExtensionOverrides : IMarkupExtensionOverrides_raw, generate<IMarkupExtensionOverrides> {};

// IMarkupExtensionFactory
struct IMarkupExtensionFactory : IInspectable {
	virtual STDMETHODIMP _CreateInstance(IInspectable* outer, IInspectable* *inner, MarkupExtension* *instance);
};

// MarkupExtension
template<typename> struct MarkupExtension_statics {
	static MarkupExtension *activate(object_ref outer, IInspectable* *inner) { MarkupExtension *instance; hrcheck(get_activation_factory<MarkupExtension, IMarkupExtensionFactory>()->_CreateInstance(outer, inner, &instance)); return instance; }
};

template<typename X> struct statics<MarkupExtension, X> : X, Windows::UI::Xaml::Markup::MarkupExtension_statics<void> {
	using Windows::UI::Xaml::Markup::MarkupExtension_statics<void>::activate;
	typedef typename X::root_type MarkupExtension;
};
struct MarkupExtension : generate<MarkupExtension> {};

// IXamlBinaryWriter
struct IXamlBinaryWriter : IInspectable, generate<IXamlBinaryWriter> {};

// IXamlBinaryWriterStatics
struct IXamlBinaryWriterStatics : IInspectable {
	virtual STDMETHODIMP _Write(Foundation::Collections::IVector<Storage::Streams::IRandomAccessStream*>* inputStreams, Foundation::Collections::IVector<Storage::Streams::IRandomAccessStream*>* outputStreams, IXamlMetadataProvider* xamlMetadataProvider, XamlBinaryWriterErrorInformation *returnValue);
};

// XamlBinaryWriter
template<typename> struct XamlBinaryWriter_statics {
	static XamlBinaryWriterErrorInformation Write(pptr<Foundation::Collections::IVector<ptr<Storage::Streams::IRandomAccessStream>>> inputStreams, pptr<Foundation::Collections::IVector<ptr<Storage::Streams::IRandomAccessStream>>> outputStreams, pptr<IXamlMetadataProvider> xamlMetadataProvider) { XamlBinaryWriterErrorInformation returnValue; hrcheck(get_activation_factory<XamlBinaryWriter, IXamlBinaryWriterStatics>()->_Write(to_abi(inputStreams), to_abi(outputStreams), xamlMetadataProvider, &returnValue)); return returnValue; }
};

template<typename X> struct statics<XamlBinaryWriter, X> : X, Windows::UI::Xaml::Markup::XamlBinaryWriter_statics<void> {
	typedef typename X::root_type XamlBinaryWriter;
};
struct XamlBinaryWriter : generate<XamlBinaryWriter> {};

// IXamlBindingHelper
struct IXamlBindingHelper : IInspectable, generate<IXamlBindingHelper> {};

// IXamlBindingHelperStatics
struct IXamlBindingHelperStatics : IInspectable {
	virtual STDMETHODIMP _get_DataTemplateComponentProperty(DependencyProperty* *value);
	virtual STDMETHODIMP _GetDataTemplateComponent(DependencyObject* element, IDataTemplateComponent* *value);
	virtual STDMETHODIMP _SetDataTemplateComponent(DependencyObject* element, IDataTemplateComponent* value);
	virtual STDMETHODIMP _SuspendRendering(UIElement* target);
	virtual STDMETHODIMP _ResumeRendering(UIElement* target);
	virtual STDMETHODIMP _ConvertValue(Interop::TypeName type, IInspectable* value, IInspectable* *returnValue);
	virtual STDMETHODIMP _SetPropertyFromString(IInspectable* dependencyObject, DependencyProperty* propertyToSet, HSTRING value);
	virtual STDMETHODIMP _SetPropertyFromBoolean(IInspectable* dependencyObject, DependencyProperty* propertyToSet, bool value);
	virtual STDMETHODIMP _SetPropertyFromChar16(IInspectable* dependencyObject, DependencyProperty* propertyToSet, char value);
	virtual STDMETHODIMP _SetPropertyFromDateTime(IInspectable* dependencyObject, DependencyProperty* propertyToSet, Foundation::DateTime value);
	virtual STDMETHODIMP _SetPropertyFromDouble(IInspectable* dependencyObject, DependencyProperty* propertyToSet, double value);
	virtual STDMETHODIMP _SetPropertyFromInt32(IInspectable* dependencyObject, DependencyProperty* propertyToSet, int value);
	virtual STDMETHODIMP _SetPropertyFromUInt32(IInspectable* dependencyObject, DependencyProperty* propertyToSet, unsigned value);
	virtual STDMETHODIMP _SetPropertyFromInt64(IInspectable* dependencyObject, DependencyProperty* propertyToSet, __int64 value);
	virtual STDMETHODIMP _SetPropertyFromUInt64(IInspectable* dependencyObject, DependencyProperty* propertyToSet, unsigned __int64 value);
	virtual STDMETHODIMP _SetPropertyFromSingle(IInspectable* dependencyObject, DependencyProperty* propertyToSet, float value);
	virtual STDMETHODIMP _SetPropertyFromPoint(IInspectable* dependencyObject, DependencyProperty* propertyToSet, Foundation::Point value);
	virtual STDMETHODIMP _SetPropertyFromRect(IInspectable* dependencyObject, DependencyProperty* propertyToSet, Foundation::Rect value);
	virtual STDMETHODIMP _SetPropertyFromSize(IInspectable* dependencyObject, DependencyProperty* propertyToSet, Foundation::Size value);
	virtual STDMETHODIMP _SetPropertyFromTimeSpan(IInspectable* dependencyObject, DependencyProperty* propertyToSet, Foundation::TimeSpan value);
	virtual STDMETHODIMP _SetPropertyFromByte(IInspectable* dependencyObject, DependencyProperty* propertyToSet, unsigned char value);
	virtual STDMETHODIMP _SetPropertyFromUri(IInspectable* dependencyObject, DependencyProperty* propertyToSet, Foundation::Uri* value);
	virtual STDMETHODIMP _SetPropertyFromObject(IInspectable* dependencyObject, DependencyProperty* propertyToSet, IInspectable* value);
};

// XamlBindingHelper
template<typename> struct XamlBindingHelper_statics {
	static struct _DataTemplateComponentProperty : property {
		ptr<DependencyProperty> get() { DependencyProperty* value; hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_get_DataTemplateComponentProperty(&value)); return from_abi(value); }
		ptr<DependencyProperty> operator()() { return get(); }
		operator ptr<DependencyProperty> () { return get(); }
		ptr<DependencyProperty> operator->() { return get(); }
	} DataTemplateComponentProperty;
	static ptr<IDataTemplateComponent> GetDataTemplateComponent(pptr<DependencyObject> element) { IDataTemplateComponent* value; hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_GetDataTemplateComponent(element, &value)); return from_abi(value); }
	static void SetDataTemplateComponent(pptr<DependencyObject> element, pptr<IDataTemplateComponent> value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetDataTemplateComponent(element, value)); }
	static void SuspendRendering(pptr<UIElement> target) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SuspendRendering(target)); }
	static void ResumeRendering(pptr<UIElement> target) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_ResumeRendering(target)); }
	static object ConvertValue(const Interop::TypeName& type, object_ref value) { IInspectable* returnValue; hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_ConvertValue(type, value, &returnValue)); return from_abi(returnValue); }
	static void SetPropertyFromString(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, hstring_ref value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromString(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromBoolean(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, bool value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromBoolean(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromChar16(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, char value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromChar16(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromDateTime(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, const Foundation::DateTime& value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromDateTime(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromDouble(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, double value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromDouble(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromInt32(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, int value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromInt32(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromUInt32(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, unsigned value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromUInt32(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromInt64(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, __int64 value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromInt64(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromUInt64(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, unsigned __int64 value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromUInt64(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromSingle(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, float value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromSingle(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromPoint(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, const Foundation::Point& value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromPoint(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromRect(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, const Foundation::Rect& value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromRect(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromSize(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, const Foundation::Size& value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromSize(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromTimeSpan(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, const Foundation::TimeSpan& value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromTimeSpan(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromByte(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, unsigned char value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromByte(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromUri(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, pptr<Foundation::Uri> value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromUri(dependencyObject, propertyToSet, value)); }
	static void SetPropertyFromObject(object_ref dependencyObject, pptr<DependencyProperty> propertyToSet, object_ref value) { hrcheck(get_activation_factory<XamlBindingHelper, IXamlBindingHelperStatics>()->_SetPropertyFromObject(dependencyObject, propertyToSet, value)); }
};
template<typename X> typename XamlBindingHelper_statics<X>::_DataTemplateComponentProperty XamlBindingHelper_statics<X>::DataTemplateComponentProperty;

template<typename X> struct statics<XamlBindingHelper, X> : X, Windows::UI::Xaml::Markup::XamlBindingHelper_statics<void> {
	typedef typename X::root_type XamlBindingHelper;
};
struct XamlBindingHelper : generate<XamlBindingHelper> {};

// IXamlMarkupHelper
struct IXamlMarkupHelper : IInspectable, generate<IXamlMarkupHelper> {};

// IXamlMarkupHelperStatics
struct IXamlMarkupHelperStatics : IInspectable {
	virtual STDMETHODIMP _UnloadObject(DependencyObject* element);
};

// XamlMarkupHelper
template<typename> struct XamlMarkupHelper_statics {
	static void UnloadObject(pptr<DependencyObject> element) { hrcheck(get_activation_factory<XamlMarkupHelper, IXamlMarkupHelperStatics>()->_UnloadObject(element)); }
};

template<typename X> struct statics<XamlMarkupHelper, X> : X, Windows::UI::Xaml::Markup::XamlMarkupHelper_statics<void> {
	typedef typename X::root_type XamlMarkupHelper;
};
struct XamlMarkupHelper : generate<XamlMarkupHelper> {};

// IXamlReader
struct IXamlReader : IInspectable, generate<IXamlReader> {};

// IXamlReaderStatics
struct IXamlReaderStatics : IInspectable {
	virtual STDMETHODIMP _Load(HSTRING xaml, IInspectable* *returnValue);
	virtual STDMETHODIMP _LoadWithInitialTemplateValidation(HSTRING xaml, IInspectable* *returnValue);
};

// XamlReader
template<typename> struct XamlReader_statics {
	static object Load(hstring_ref xaml) { IInspectable* returnValue; hrcheck(get_activation_factory<XamlReader, IXamlReaderStatics>()->_Load(xaml, &returnValue)); return from_abi(returnValue); }
	static object LoadWithInitialTemplateValidation(hstring_ref xaml) { IInspectable* returnValue; hrcheck(get_activation_factory<XamlReader, IXamlReaderStatics>()->_LoadWithInitialTemplateValidation(xaml, &returnValue)); return from_abi(returnValue); }
};

template<typename X> struct statics<XamlReader, X> : X, Windows::UI::Xaml::Markup::XamlReader_statics<void> {
	typedef typename X::root_type XamlReader;
};
struct XamlReader : generate<XamlReader> {};
}}}}
} // namespace iso_winrt
