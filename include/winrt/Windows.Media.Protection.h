#pragma once
// generated by isopod tools
// namespaces:
// Windows.Media.Protection

#include "Windows.Media.Protection.0.h"
#include "Windows.Foundation.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IVector;
struct IPropertySet;
}}
namespace Media { namespace Playback {
struct MediaPlaybackItem;
}}}

// defs

template<> struct def<Windows::Media::Protection::IMediaProtectionManager> : interface_type<> {};
template<> struct def<Windows::Media::Protection::MediaProtectionManager> : class_type<Platform::Object, Windows::Media::Protection::IMediaProtectionManager> {};
template<> struct def<Windows::Media::Protection::IServiceRequestedEventArgs2> : interface_type<> {};
template<> struct def<Windows::Media::Protection::IServiceRequestedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Protection::ServiceRequestedEventArgs> : class_type<Platform::Object, Windows::Media::Protection::IServiceRequestedEventArgs, Windows::Media::Protection::IServiceRequestedEventArgs2> {};
template<> struct def<Windows::Media::Protection::IComponentLoadFailedEventArgs> : interface_type<> {};
template<> struct def<Windows::Media::Protection::ComponentLoadFailedEventArgs> : class_type<Platform::Object, Windows::Media::Protection::IComponentLoadFailedEventArgs> {};
template<> struct def<Windows::Media::Protection::IMediaProtectionServiceCompletion> : interface_type<> {};
template<> struct def<Windows::Media::Protection::MediaProtectionServiceCompletion> : class_type<Platform::Object, Windows::Media::Protection::IMediaProtectionServiceCompletion> {};
template<> struct def<Windows::Media::Protection::IRevocationAndRenewalInformation> : interface_type<> {};
template<> struct def<Windows::Media::Protection::RevocationAndRenewalInformation> : class_type<Platform::Object, Windows::Media::Protection::IRevocationAndRenewalInformation> {};
template<> struct def<Windows::Media::Protection::RevocationAndRenewalReasons> : enum_type<unsigned> {};
template<> struct def<Windows::Media::Protection::IRevocationAndRenewalItem> : interface_type<> {};
template<> struct def<Windows::Media::Protection::RevocationAndRenewalItem> : class_type<Platform::Object, Windows::Media::Protection::IRevocationAndRenewalItem> {};
template<> struct def<Windows::Media::Protection::IMediaProtectionPMPServerFactory> : interface_type<> {};
template<> struct def<Windows::Media::Protection::IMediaProtectionPMPServer> : interface_type<> {};
template<> struct def<Windows::Media::Protection::MediaProtectionPMPServer> : class_type<Platform::Object, Windows::Media::Protection::IMediaProtectionPMPServer>, custom_activators {};
template<> struct def<Windows::Media::Protection::ServiceRequestedEventHandler> : delegate_type {};
template<> struct def<Windows::Media::Protection::RebootNeededEventHandler> : delegate_type {};
template<> struct def<Windows::Media::Protection::ComponentLoadFailedEventHandler> : delegate_type {};
template<> struct def<Windows::Media::Protection::IMediaProtectionServiceRequest> : overridable_type<> {};
template<> struct def<Windows::Media::Protection::GraphicsTrustStatus> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::ProtectionCapabilityResult> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::IProtectionCapabilities> : interface_type<> {};
template<> struct def<Windows::Media::Protection::ProtectionCapabilities> : class_type<Platform::Object, Windows::Media::Protection::IProtectionCapabilities> {};
template<> struct def<Windows::Media::Protection::HdcpProtection> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::HdcpSetProtectionResult> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::IHdcpSession> : interface_type<Windows::Foundation::IClosable> {};
template<> struct def<Windows::Media::Protection::HdcpSession> : class_type<Platform::Object, Windows::Media::Protection::IHdcpSession> {};
template<> struct def<Windows::Media::Protection::ProtectionRenewalContract> : value_type<> {};
template<> struct def<Windows::Media::Protection::RenewalStatus> : enum_type<int> {};
template<> struct def<Windows::Media::Protection::IComponentRenewalStatics> : interface_type<> {};
template<> struct def<Windows::Media::Protection::ComponentRenewal> : class_type<Platform::Object, Platform::Object> {};

// uuids

template<> struct uuid<Windows::Media::Protection::IMediaProtectionManager> { define_guid(0x45694947, 0xC741, 0x434B, 0xA7, 0x9E, 0x47, 0x4C, 0x12, 0xD9, 0x3D, 0x2F);};
template<> struct uuid<Windows::Media::Protection::IServiceRequestedEventArgs2> { define_guid(0x553C69D6, 0xFAFE, 0x4128, 0x8D, 0xFA, 0x13, 0xE, 0x39, 0x8A, 0x13, 0xA7);};
template<> struct uuid<Windows::Media::Protection::IServiceRequestedEventArgs> { define_guid(0x34283BAF, 0xABB4, 0x4FC1, 0xBD, 0x89, 0x93, 0xF1, 0x6, 0x57, 0x3A, 0x49);};
template<> struct uuid<Windows::Media::Protection::IComponentLoadFailedEventArgs> { define_guid(0x95972E93, 0x7746, 0x417E, 0x84, 0x95, 0xF0, 0x31, 0xBB, 0xC5, 0x86, 0x2C);};
template<> struct uuid<Windows::Media::Protection::IMediaProtectionServiceCompletion> { define_guid(0x8B5CCA18, 0xCFD5, 0x44EE, 0xA2, 0xED, 0xDF, 0x76, 0x1, 0xC, 0x14, 0xB5);};
template<> struct uuid<Windows::Media::Protection::IRevocationAndRenewalInformation> { define_guid(0xF3A1937B, 0x2501, 0x439E, 0xA6, 0xE7, 0x6F, 0xC9, 0x5E, 0x17, 0x5F, 0xCF);};
template<> struct uuid<Windows::Media::Protection::IRevocationAndRenewalItem> { define_guid(0x3099C20C, 0x3CF0, 0x49EA, 0x90, 0x2D, 0xCA, 0xF3, 0x2D, 0x2D, 0xDE, 0x2C);};
template<> struct uuid<Windows::Media::Protection::IMediaProtectionPMPServerFactory> { define_guid(0x602C8E5E, 0xF7D2, 0x487E, 0xAF, 0x91, 0xDB, 0xC4, 0x25, 0x2B, 0x21, 0x82);};
template<> struct uuid<Windows::Media::Protection::IMediaProtectionPMPServer> { define_guid(0xC111226, 0x7B26, 0x4D31, 0x95, 0xBB, 0x9C, 0x1B, 0x8, 0xEF, 0x7F, 0xC0);};
template<> struct uuid<Windows::Media::Protection::ServiceRequestedEventHandler> { define_guid(0xD2D690BA, 0xCAC9, 0x48E1, 0x95, 0xC0, 0xD3, 0x84, 0x95, 0xA8, 0x40, 0x55);};
template<> struct uuid<Windows::Media::Protection::RebootNeededEventHandler> { define_guid(0x64E12A45, 0x973B, 0x4A3A, 0xB2, 0x60, 0x91, 0x89, 0x8A, 0x49, 0xA8, 0x2C);};
template<> struct uuid<Windows::Media::Protection::ComponentLoadFailedEventHandler> { define_guid(0x95DA643C, 0x6DB9, 0x424B, 0x86, 0xCA, 0x9, 0x1A, 0xF4, 0x32, 0x8, 0x1C);};
template<> struct uuid<Windows::Media::Protection::IMediaProtectionServiceRequest> { define_guid(0xB1DE0EA6, 0x2094, 0x478D, 0x87, 0xA4, 0x8B, 0x95, 0x20, 0xF, 0x85, 0xC6);};
template<> struct uuid<Windows::Media::Protection::IProtectionCapabilities> { define_guid(0xC7AC5D7E, 0x7480, 0x4D29, 0xA4, 0x64, 0x7B, 0xCD, 0x91, 0x3D, 0xD8, 0xE4);};
template<> struct uuid<Windows::Media::Protection::IHdcpSession> { define_guid(0x718845E9, 0x64D7, 0x426D, 0x80, 0x9B, 0x1B, 0xE4, 0x61, 0x94, 0x1A, 0x2A);};
template<> struct uuid<Windows::Media::Protection::IComponentRenewalStatics> { define_guid(0x6FFBCD67, 0xB795, 0x48C5, 0x8B, 0x7B, 0xA7, 0xC4, 0xEF, 0xE2, 0x2, 0xE3);};

// types

namespace Windows { namespace Media { namespace Protection {

// IMediaProtectionManager
struct IMediaProtectionManager_raw : IInspectable {
	virtual STDMETHODIMP _add_ServiceRequested(ServiceRequestedEventHandler* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_ServiceRequested(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _add_RebootNeeded(RebootNeededEventHandler* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_RebootNeeded(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _add_ComponentLoadFailed(ComponentLoadFailedEventHandler* handler, Foundation::EventRegistrationToken *cookie);
	virtual STDMETHODIMP _remove_ComponentLoadFailed(Foundation::EventRegistrationToken cookie);
	virtual STDMETHODIMP _get_Properties(Foundation::Collections::IPropertySet* *value);
};
template<typename X> struct IMediaProtectionManager_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IPropertySet> get() { Foundation::Collections::IPropertySet* value; hrcheck(enc(&IMediaProtectionManager_adaptor::Properties)->_get_Properties(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IPropertySet> operator()() { return get(); }
			operator ptr<Foundation::Collections::IPropertySet> () { return get(); }
			ptr<Foundation::Collections::IPropertySet> operator->() { return get(); }
		} Properties;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<ComponentLoadFailedEventHandler> handler) { Foundation::EventRegistrationToken cookie; hrcheck(enc(&IMediaProtectionManager_adaptor::ComponentLoadFailed)->_add_ComponentLoadFailed(handler, &cookie)); return cookie; }
			void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(enc(&IMediaProtectionManager_adaptor::ComponentLoadFailed)->_remove_ComponentLoadFailed(cookie)); }
		} ComponentLoadFailed;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<RebootNeededEventHandler> handler) { Foundation::EventRegistrationToken cookie; hrcheck(enc(&IMediaProtectionManager_adaptor::RebootNeeded)->_add_RebootNeeded(handler, &cookie)); return cookie; }
			void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(enc(&IMediaProtectionManager_adaptor::RebootNeeded)->_remove_RebootNeeded(cookie)); }
		} RebootNeeded;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<ServiceRequestedEventHandler> handler) { Foundation::EventRegistrationToken cookie; hrcheck(enc(&IMediaProtectionManager_adaptor::ServiceRequested)->_add_ServiceRequested(handler, &cookie)); return cookie; }
			void operator-=(const Foundation::EventRegistrationToken& cookie) { hrcheck(enc(&IMediaProtectionManager_adaptor::ServiceRequested)->_remove_ServiceRequested(cookie)); }
		} ServiceRequested;
	};
	IMediaProtectionManager_adaptor() {}
};
template<typename X> struct adapt<IMediaProtectionManager, X> : Windows::Media::Protection::IMediaProtectionManager_adaptor<X> { typedef adapt IMediaProtectionManager; };
struct IMediaProtectionManager : IMediaProtectionManager_raw, generate<IMediaProtectionManager> {};

// MediaProtectionManager
template<typename X> struct statics<MediaProtectionManager, X> : X {
	typedef typename X::root_type MediaProtectionManager;
};
struct MediaProtectionManager : generate<MediaProtectionManager> {};

// IServiceRequestedEventArgs2
struct IServiceRequestedEventArgs2_raw : IInspectable {
	virtual STDMETHODIMP _get_MediaPlaybackItem(Playback::MediaPlaybackItem* *value);
};
template<typename X> struct IServiceRequestedEventArgs2_adaptor : X {
	union {
		struct : property {
			ptr<Playback::MediaPlaybackItem> get() { Playback::MediaPlaybackItem* value; hrcheck(enc(&IServiceRequestedEventArgs2_adaptor::MediaPlaybackItem)->_get_MediaPlaybackItem(&value)); return from_abi(value); }
			ptr<Playback::MediaPlaybackItem> operator()() { return get(); }
			operator ptr<Playback::MediaPlaybackItem> () { return get(); }
			ptr<Playback::MediaPlaybackItem> operator->() { return get(); }
		} MediaPlaybackItem;
	};
	IServiceRequestedEventArgs2_adaptor() {}
};
template<typename X> struct adapt<IServiceRequestedEventArgs2, X> : Windows::Media::Protection::IServiceRequestedEventArgs2_adaptor<X> { typedef adapt IServiceRequestedEventArgs2; };
struct IServiceRequestedEventArgs2 : IServiceRequestedEventArgs2_raw, generate<IServiceRequestedEventArgs2> {};

// IServiceRequestedEventArgs
struct IServiceRequestedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Request(IMediaProtectionServiceRequest* *value);
	virtual STDMETHODIMP _get_Completion(MediaProtectionServiceCompletion* *value);
};
template<typename X> struct IServiceRequestedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<MediaProtectionServiceCompletion> get() { MediaProtectionServiceCompletion* value; hrcheck(enc(&IServiceRequestedEventArgs_adaptor::Completion)->_get_Completion(&value)); return from_abi(value); }
			ptr<MediaProtectionServiceCompletion> operator()() { return get(); }
			operator ptr<MediaProtectionServiceCompletion> () { return get(); }
			ptr<MediaProtectionServiceCompletion> operator->() { return get(); }
		} Completion;
		struct : property {
			ptr<IMediaProtectionServiceRequest> get() { IMediaProtectionServiceRequest* value; hrcheck(enc(&IServiceRequestedEventArgs_adaptor::Request)->_get_Request(&value)); return from_abi(value); }
			ptr<IMediaProtectionServiceRequest> operator()() { return get(); }
			operator ptr<IMediaProtectionServiceRequest> () { return get(); }
			ptr<IMediaProtectionServiceRequest> operator->() { return get(); }
		} Request;
	};
	IServiceRequestedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IServiceRequestedEventArgs, X> : Windows::Media::Protection::IServiceRequestedEventArgs_adaptor<X> { typedef adapt IServiceRequestedEventArgs; };
struct IServiceRequestedEventArgs : IServiceRequestedEventArgs_raw, generate<IServiceRequestedEventArgs> {};

// ServiceRequestedEventArgs
template<typename X> struct statics<ServiceRequestedEventArgs, X> : X {
	typedef typename X::root_type ServiceRequestedEventArgs;
};
struct ServiceRequestedEventArgs : generate<ServiceRequestedEventArgs> {};

// IComponentLoadFailedEventArgs
struct IComponentLoadFailedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Information(RevocationAndRenewalInformation* *value);
	virtual STDMETHODIMP _get_Completion(MediaProtectionServiceCompletion* *value);
};
template<typename X> struct IComponentLoadFailedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<MediaProtectionServiceCompletion> get() { MediaProtectionServiceCompletion* value; hrcheck(enc(&IComponentLoadFailedEventArgs_adaptor::Completion)->_get_Completion(&value)); return from_abi(value); }
			ptr<MediaProtectionServiceCompletion> operator()() { return get(); }
			operator ptr<MediaProtectionServiceCompletion> () { return get(); }
			ptr<MediaProtectionServiceCompletion> operator->() { return get(); }
		} Completion;
		struct : property {
			ptr<RevocationAndRenewalInformation> get() { RevocationAndRenewalInformation* value; hrcheck(enc(&IComponentLoadFailedEventArgs_adaptor::Information)->_get_Information(&value)); return from_abi(value); }
			ptr<RevocationAndRenewalInformation> operator()() { return get(); }
			operator ptr<RevocationAndRenewalInformation> () { return get(); }
			ptr<RevocationAndRenewalInformation> operator->() { return get(); }
		} Information;
	};
	IComponentLoadFailedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IComponentLoadFailedEventArgs, X> : Windows::Media::Protection::IComponentLoadFailedEventArgs_adaptor<X> { typedef adapt IComponentLoadFailedEventArgs; };
struct IComponentLoadFailedEventArgs : IComponentLoadFailedEventArgs_raw, generate<IComponentLoadFailedEventArgs> {};

// ComponentLoadFailedEventArgs
template<typename X> struct statics<ComponentLoadFailedEventArgs, X> : X {
	typedef typename X::root_type ComponentLoadFailedEventArgs;
};
struct ComponentLoadFailedEventArgs : generate<ComponentLoadFailedEventArgs> {};

// IMediaProtectionServiceCompletion
struct IMediaProtectionServiceCompletion_raw : IInspectable {
	virtual STDMETHODIMP _Complete(bool success);
};
template<typename X> struct IMediaProtectionServiceCompletion_adaptor : X {
	void Complete(bool success) { hrcheck(X::get()->_Complete(success)); }
};
template<typename X> struct adapt<IMediaProtectionServiceCompletion, X> : Windows::Media::Protection::IMediaProtectionServiceCompletion_adaptor<X> { typedef adapt IMediaProtectionServiceCompletion; };
struct IMediaProtectionServiceCompletion : IMediaProtectionServiceCompletion_raw, generate<IMediaProtectionServiceCompletion> {};

// MediaProtectionServiceCompletion
template<typename X> struct statics<MediaProtectionServiceCompletion, X> : X {
	typedef typename X::root_type MediaProtectionServiceCompletion;
};
struct MediaProtectionServiceCompletion : generate<MediaProtectionServiceCompletion> {};

// IRevocationAndRenewalInformation
struct IRevocationAndRenewalInformation_raw : IInspectable {
	virtual STDMETHODIMP _get_Items(Foundation::Collections::IVector<RevocationAndRenewalItem*>* *items);
};
template<typename X> struct IRevocationAndRenewalInformation_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<ptr<RevocationAndRenewalItem>>> get() { Foundation::Collections::IVector<RevocationAndRenewalItem*>* items; hrcheck(enc(&IRevocationAndRenewalInformation_adaptor::Items)->_get_Items(&items)); return from_abi(items); }
			ptr<Foundation::Collections::IVector<ptr<RevocationAndRenewalItem>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<ptr<RevocationAndRenewalItem>>> () { return get(); }
			ptr<Foundation::Collections::IVector<ptr<RevocationAndRenewalItem>>> operator->() { return get(); }
		} Items;
	};
	IRevocationAndRenewalInformation_adaptor() {}
};
template<typename X> struct adapt<IRevocationAndRenewalInformation, X> : Windows::Media::Protection::IRevocationAndRenewalInformation_adaptor<X> { typedef adapt IRevocationAndRenewalInformation; };
struct IRevocationAndRenewalInformation : IRevocationAndRenewalInformation_raw, generate<IRevocationAndRenewalInformation> {};

// RevocationAndRenewalInformation
template<typename X> struct statics<RevocationAndRenewalInformation, X> : X {
	typedef typename X::root_type RevocationAndRenewalInformation;
};
struct RevocationAndRenewalInformation : generate<RevocationAndRenewalInformation> {};

// IRevocationAndRenewalItem
struct IRevocationAndRenewalItem_raw : IInspectable {
	virtual STDMETHODIMP _get_Reasons(RevocationAndRenewalReasons *reasons);
	virtual STDMETHODIMP _get_HeaderHash(HSTRING *value);
	virtual STDMETHODIMP _get_PublicKeyHash(HSTRING *value);
	virtual STDMETHODIMP _get_Name(HSTRING *name);
	virtual STDMETHODIMP _get_RenewalId(HSTRING *value);
};
template<typename X> struct IRevocationAndRenewalItem_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRevocationAndRenewalItem_adaptor::HeaderHash)->_get_HeaderHash(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} HeaderHash;
		struct : property {
			hstring get() { HSTRING name; hrcheck(enc(&IRevocationAndRenewalItem_adaptor::Name)->_get_Name(&name)); return from_abi(name); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRevocationAndRenewalItem_adaptor::PublicKeyHash)->_get_PublicKeyHash(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PublicKeyHash;
		struct : property {
			RevocationAndRenewalReasons get() { RevocationAndRenewalReasons reasons; hrcheck(enc(&IRevocationAndRenewalItem_adaptor::Reasons)->_get_Reasons(&reasons)); return reasons; }
			RevocationAndRenewalReasons operator()() { return get(); }
			operator RevocationAndRenewalReasons () { return get(); }
		} Reasons;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRevocationAndRenewalItem_adaptor::RenewalId)->_get_RenewalId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} RenewalId;
	};
	IRevocationAndRenewalItem_adaptor() {}
};
template<typename X> struct adapt<IRevocationAndRenewalItem, X> : Windows::Media::Protection::IRevocationAndRenewalItem_adaptor<X> { typedef adapt IRevocationAndRenewalItem; };
struct IRevocationAndRenewalItem : IRevocationAndRenewalItem_raw, generate<IRevocationAndRenewalItem> {};

// RevocationAndRenewalItem
template<typename X> struct statics<RevocationAndRenewalItem, X> : X {
	typedef typename X::root_type RevocationAndRenewalItem;
};
struct RevocationAndRenewalItem : generate<RevocationAndRenewalItem> {};

// IMediaProtectionPMPServerFactory
struct IMediaProtectionPMPServerFactory : IInspectable {
	virtual STDMETHODIMP _CreatePMPServer(Foundation::Collections::IPropertySet* pProperties, MediaProtectionPMPServer* *ppObject);
};

// IMediaProtectionPMPServer
struct IMediaProtectionPMPServer_raw : IInspectable {
	virtual STDMETHODIMP _get_Properties(Foundation::Collections::IPropertySet* *ppProperties);
};
template<typename X> struct IMediaProtectionPMPServer_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IPropertySet> get() { Foundation::Collections::IPropertySet* ppProperties; hrcheck(enc(&IMediaProtectionPMPServer_adaptor::Properties)->_get_Properties(&ppProperties)); return from_abi(ppProperties); }
			ptr<Foundation::Collections::IPropertySet> operator()() { return get(); }
			operator ptr<Foundation::Collections::IPropertySet> () { return get(); }
			ptr<Foundation::Collections::IPropertySet> operator->() { return get(); }
		} Properties;
	};
	IMediaProtectionPMPServer_adaptor() {}
};
template<typename X> struct adapt<IMediaProtectionPMPServer, X> : Windows::Media::Protection::IMediaProtectionPMPServer_adaptor<X> { typedef adapt IMediaProtectionPMPServer; };
struct IMediaProtectionPMPServer : IMediaProtectionPMPServer_raw, generate<IMediaProtectionPMPServer> {};

// MediaProtectionPMPServer
template<typename> struct MediaProtectionPMPServer_statics {
	static MediaProtectionPMPServer *activate(pptr<Foundation::Collections::IPropertySet> pProperties) { MediaProtectionPMPServer *ppObject; hrcheck(get_activation_factory<MediaProtectionPMPServer, IMediaProtectionPMPServerFactory>()->_CreatePMPServer(pProperties, &ppObject)); return ppObject; }
};

template<typename X> struct statics<MediaProtectionPMPServer, X> : X, Windows::Media::Protection::MediaProtectionPMPServer_statics<void> {
	using Windows::Media::Protection::MediaProtectionPMPServer_statics<void>::activate;
	typedef typename X::root_type MediaProtectionPMPServer;
};
struct MediaProtectionPMPServer : generate<MediaProtectionPMPServer> {};

// ServiceRequestedEventHandler
struct ServiceRequestedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(MediaProtectionManager* sender, ServiceRequestedEventArgs* e) = 0;
};

// RebootNeededEventHandler
struct RebootNeededEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(MediaProtectionManager* sender) = 0;
};

// ComponentLoadFailedEventHandler
struct ComponentLoadFailedEventHandler : IUnknown {
	virtual STDMETHODIMP _Invoke(MediaProtectionManager* sender, ComponentLoadFailedEventArgs* e) = 0;
};

// IMediaProtectionServiceRequest
struct IMediaProtectionServiceRequest_raw : IInspectable {
	virtual STDMETHODIMP _get_ProtectionSystem(Platform::Guid *system) = 0;
	virtual STDMETHODIMP _get_Type(Platform::Guid *type) = 0;
};
template<typename X> struct IMediaProtectionServiceRequest_adaptor : X {
	union {
		struct : property {
			Platform::Guid get() { Platform::Guid system; hrcheck(enc(&IMediaProtectionServiceRequest_adaptor::ProtectionSystem)->_get_ProtectionSystem(&system)); return system; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} ProtectionSystem;
		struct : property {
			Platform::Guid get() { Platform::Guid type; hrcheck(enc(&IMediaProtectionServiceRequest_adaptor::Type)->_get_Type(&type)); return type; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} Type;
	};
	IMediaProtectionServiceRequest_adaptor() {}
};
template<typename X> struct adapt<IMediaProtectionServiceRequest, X> : Windows::Media::Protection::IMediaProtectionServiceRequest_adaptor<X> { typedef adapt IMediaProtectionServiceRequest; };
template<typename X> struct IMediaProtectionServiceRequest_unadaptor : X {
	STDMETHODIMP _get_ProtectionSystem(Platform::Guid *system) { return hrtry([&, this] { get_prop(system, ProtectionSystem); }); }
	STDMETHODIMP _get_Type(Platform::Guid *type) { return hrtry([&, this] { get_prop(type, Type); }); }
};
template<typename X> struct unadapt<IMediaProtectionServiceRequest, X> : Windows::Media::Protection::IMediaProtectionServiceRequest_unadaptor<X> {};
struct IMediaProtectionServiceRequest : IMediaProtectionServiceRequest_raw, generate<IMediaProtectionServiceRequest> {};

// IProtectionCapabilities
struct IProtectionCapabilities_raw : IInspectable {
	virtual STDMETHODIMP _IsTypeSupported(HSTRING type, HSTRING keySystem, ProtectionCapabilityResult *value);
};
template<typename X> struct IProtectionCapabilities_adaptor : X {
	ProtectionCapabilityResult IsTypeSupported(hstring_ref type, hstring_ref keySystem) { ProtectionCapabilityResult value; hrcheck(X::get()->_IsTypeSupported(type, keySystem, &value)); return value; }
};
template<typename X> struct adapt<IProtectionCapabilities, X> : Windows::Media::Protection::IProtectionCapabilities_adaptor<X> { typedef adapt IProtectionCapabilities; };
struct IProtectionCapabilities : IProtectionCapabilities_raw, generate<IProtectionCapabilities> {};

// ProtectionCapabilities
template<typename X> struct statics<ProtectionCapabilities, X> : X {
	typedef typename X::root_type ProtectionCapabilities;
};
struct ProtectionCapabilities : generate<ProtectionCapabilities> {};

// IHdcpSession
struct IHdcpSession_raw : IInspectable {
	virtual STDMETHODIMP _IsEffectiveProtectionAtLeast(HdcpProtection protection, bool *value);
	virtual STDMETHODIMP _GetEffectiveProtection(Foundation::IReference<HdcpProtection>* *value);
	virtual STDMETHODIMP _SetDesiredMinProtectionAsync(HdcpProtection protection, Foundation::IAsyncOperation<HdcpSetProtectionResult>* *value);
	virtual STDMETHODIMP _add_ProtectionChanged(Foundation::TypedEventHandler<HdcpSession*, IInspectable*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ProtectionChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IHdcpSession_adaptor : X {
	union {
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<HdcpSession>, object>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IHdcpSession_adaptor::ProtectionChanged)->_add_ProtectionChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IHdcpSession_adaptor::ProtectionChanged)->_remove_ProtectionChanged(token)); }
		} ProtectionChanged;
	};
	bool IsEffectiveProtectionAtLeast(HdcpProtection protection) { bool value; hrcheck(X::get()->_IsEffectiveProtectionAtLeast(protection, &value)); return value; }
	ptr<Foundation::IReference<HdcpProtection>> GetEffectiveProtection() { Foundation::IReference<HdcpProtection>* value; hrcheck(X::get()->_GetEffectiveProtection(&value)); return from_abi(value); }
	ptr<Foundation::IAsyncOperation<HdcpSetProtectionResult>> SetDesiredMinProtectionAsync(HdcpProtection protection) { Foundation::IAsyncOperation<HdcpSetProtectionResult>* value; hrcheck(X::get()->_SetDesiredMinProtectionAsync(protection, &value)); return from_abi(value); }
	IHdcpSession_adaptor() {}
};
template<typename X> struct adapt<IHdcpSession, X> : Windows::Media::Protection::IHdcpSession_adaptor<X> { typedef adapt IHdcpSession; };
struct IHdcpSession : IHdcpSession_raw, generate<IHdcpSession> {};

// HdcpSession
template<typename X> struct statics<HdcpSession, X> : X {
	typedef typename X::root_type HdcpSession;
};
struct HdcpSession : generate<HdcpSession> {};

// IComponentRenewalStatics
struct IComponentRenewalStatics : IInspectable {
	virtual STDMETHODIMP _RenewSystemComponentsAsync(RevocationAndRenewalInformation* information, Foundation::IAsyncOperationWithProgress<RenewalStatus, unsigned>* *operation);
};

// ComponentRenewal
template<typename> struct ComponentRenewal_statics {
	static ptr<Foundation::IAsyncOperationWithProgress<RenewalStatus, unsigned>> RenewSystemComponentsAsync(pptr<RevocationAndRenewalInformation> information) { Foundation::IAsyncOperationWithProgress<RenewalStatus, unsigned>* operation; hrcheck(get_activation_factory<ComponentRenewal, IComponentRenewalStatics>()->_RenewSystemComponentsAsync(information, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<ComponentRenewal, X> : X, Windows::Media::Protection::ComponentRenewal_statics<void> {
	typedef typename X::root_type ComponentRenewal;
};
struct ComponentRenewal : generate<ComponentRenewal> {};
}}}
} // namespace iso_winrt
