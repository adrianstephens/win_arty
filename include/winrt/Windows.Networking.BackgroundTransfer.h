#pragma once
// generated by isopod tools
// namespaces:
// Windows.Networking.BackgroundTransfer

#include "Windows.Networking.BackgroundTransfer.0.h"
#include "Windows.Web.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace ApplicationModel { namespace Background {
struct IBackgroundTrigger;
}}
namespace Foundation { namespace Collections {
template<typename T> struct IVector;
template<typename T> struct IVectorView;
template<typename K, typename V> struct IMapView;
template<typename T> struct IIterable;
}}
namespace Security { namespace Credentials {
struct PasswordCredential;
}}
namespace Storage { namespace Streams {
struct IRandomAccessStreamReference;
struct IInputStream;
}
struct IStorageFile;
}
namespace UI { namespace Notifications {
struct ToastNotification;
struct TileNotification;
}}}

// defs

template<> struct def<Windows::Networking::BackgroundTransfer::BackgroundTransferStatus> : enum_type<int> {};
template<> struct def<Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy> : enum_type<int> {};
template<> struct def<Windows::Networking::BackgroundTransfer::BackgroundTransferPriority> : enum_type<int> {};
template<> struct def<Windows::Networking::BackgroundTransfer::BackgroundTransferBehavior> : enum_type<int> {};
template<> struct def<Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress> : value_type<unsigned __int64, unsigned __int64, Windows::Networking::BackgroundTransfer::BackgroundTransferStatus, bool, bool> {};
template<> struct def<Windows::Networking::BackgroundTransfer::BackgroundUploadProgress> : value_type<unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64, Windows::Networking::BackgroundTransfer::BackgroundTransferStatus, bool, bool> {};
template<> struct def<Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange> : value_type<unsigned __int64, unsigned __int64> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundTransferBase> : overridable_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IUnconstrainedTransferRequestResult> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundDownloaderUserConsent> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IDownloadOperation4> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IDownloadOperation3> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IDownloadOperation2> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority> : overridable_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation> : overridable_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IDownloadOperation> : interface_type<Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation> {};
template<> struct def<Windows::Networking::BackgroundTransfer::DownloadOperation> : class_type<Platform::Object, Windows::Networking::BackgroundTransfer::IDownloadOperation, Windows::Networking::BackgroundTransfer::IDownloadOperation4, Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority, Windows::Networking::BackgroundTransfer::IDownloadOperation2, Windows::Networking::BackgroundTransfer::IDownloadOperation3> {};
template<> struct def<Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult> : class_type<Platform::Object, Windows::Networking::BackgroundTransfer::IUnconstrainedTransferRequestResult> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundUploaderUserConsent> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IUploadOperation3> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IUploadOperation2> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IUploadOperation> : interface_type<Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation> {};
template<> struct def<Windows::Networking::BackgroundTransfer::UploadOperation> : class_type<Platform::Object, Windows::Networking::BackgroundTransfer::IUploadOperation, Windows::Networking::BackgroundTransfer::IUploadOperation3, Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority, Windows::Networking::BackgroundTransfer::IUploadOperation2> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundDownloader> : interface_type<Windows::Networking::BackgroundTransfer::IBackgroundTransferBase> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundDownloader2> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundTransferGroupStatics> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundTransferGroup> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::BackgroundTransferGroup> : class_type<Platform::Object, Windows::Networking::BackgroundTransfer::IBackgroundTransferGroup> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundDownloader3> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundTransferCompletionGroup> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup> : class_type<Platform::Object, Windows::Networking::BackgroundTransfer::IBackgroundTransferCompletionGroup> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundUploader> : interface_type<Windows::Networking::BackgroundTransfer::IBackgroundTransferBase> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory> : overridable_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPart> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart> : class_type<Platform::Object, Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPart>, custom_activators {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundUploader2> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundUploader3> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IResponseInformation> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::ResponseInformation> : class_type<Platform::Object, Windows::Networking::BackgroundTransfer::IResponseInformation> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundTransferRangesDownloadedEventArgs> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs> : class_type<Platform::Object, Windows::Networking::BackgroundTransfer::IBackgroundTransferRangesDownloadedEventArgs> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundDownloaderFactory> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundDownloaderStaticMethods2> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundDownloaderStaticMethods> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::BackgroundDownloader> : class_type<Platform::Object, Windows::Networking::BackgroundTransfer::IBackgroundDownloader, Windows::Networking::BackgroundTransfer::IBackgroundDownloader3, Windows::Networking::BackgroundTransfer::IBackgroundDownloader2>, custom_activators {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundUploaderFactory> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundUploaderStaticMethods2> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundUploaderStaticMethods> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::BackgroundUploader> : class_type<Platform::Object, Windows::Networking::BackgroundTransfer::IBackgroundUploader, Windows::Networking::BackgroundTransfer::IBackgroundUploader3, Windows::Networking::BackgroundTransfer::IBackgroundUploader2>, custom_activators {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundTransferErrorStaticMethods> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IContentPrefetcherTime> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IContentPrefetcher> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::IBackgroundTransferCompletionGroupTriggerDetails> : interface_type<> {};
template<> struct def<Windows::Networking::BackgroundTransfer::BackgroundTransferError> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Networking::BackgroundTransfer::ContentPrefetcher> : class_type<Platform::Object, Platform::Object> {};
template<> struct def<Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails> : class_type<Platform::Object, Windows::Networking::BackgroundTransfer::IBackgroundTransferCompletionGroupTriggerDetails> {};

// uuids

template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundTransferBase> { define_guid(0x2A9DA250, 0xC769, 0x458C, 0xAF, 0xE8, 0xFE, 0xB8, 0xD4, 0xD3, 0xB2, 0xEF);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IUnconstrainedTransferRequestResult> { define_guid(0x4C24B81F, 0xD944, 0x4112, 0xA9, 0x8E, 0x6A, 0x69, 0x52, 0x2B, 0x7E, 0xBB);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundDownloaderUserConsent> { define_guid(0x5D14E906, 0x9266, 0x4808, 0xBD, 0x71, 0x59, 0x25, 0xF2, 0xA3, 0x13, 0xA);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IDownloadOperation4> { define_guid(0xCDAAEF4, 0x8CEF, 0x404A, 0x96, 0x6D, 0xF0, 0x58, 0x40, 0xB, 0xED, 0x80);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IDownloadOperation3> { define_guid(0x5027351C, 0x7D5E, 0x4ADC, 0xB8, 0xD3, 0xDF, 0x5C, 0x60, 0x31, 0xB9, 0xCC);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IDownloadOperation2> { define_guid(0xA3CCED40, 0x8F9C, 0x4353, 0x9C, 0xD4, 0x29, 0xD, 0xEE, 0x38, 0x7C, 0x38);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority> { define_guid(0x4854327, 0x5254, 0x4B3A, 0x91, 0x5E, 0xA, 0xA4, 0x92, 0x75, 0xC0, 0xF9);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation> { define_guid(0xDED06846, 0x90CA, 0x44FB, 0x8F, 0xB1, 0x12, 0x41, 0x54, 0xC0, 0xD5, 0x39);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IDownloadOperation> { define_guid(0xBD87EBB0, 0x5714, 0x4E09, 0xBA, 0x68, 0xBE, 0xF7, 0x39, 0x3, 0xB0, 0xD7);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundUploaderUserConsent> { define_guid(0x3BB384CB, 0x760, 0x461D, 0x90, 0x7F, 0x51, 0x38, 0xF8, 0x4D, 0x44, 0xC1);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IUploadOperation3> { define_guid(0x42C92CA3, 0xDE39, 0x4546, 0xBC, 0x62, 0x37, 0x74, 0xB4, 0x29, 0x4D, 0xE3);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IUploadOperation2> { define_guid(0x556189F2, 0x2774, 0x4DF6, 0x9F, 0xA5, 0x20, 0x9F, 0x2B, 0xFB, 0x12, 0xF7);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IUploadOperation> { define_guid(0x3E5624E0, 0x7389, 0x434C, 0x8B, 0x35, 0x42, 0x7F, 0xD3, 0x6B, 0xBD, 0xAE);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundDownloader> { define_guid(0xC1C79333, 0x6649, 0x4B1D, 0xA8, 0x26, 0xA4, 0xB3, 0xDD, 0x23, 0x4D, 0xB);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundDownloader2> { define_guid(0xA94A5847, 0x348D, 0x4A35, 0x89, 0xE, 0x8A, 0x1E, 0xF3, 0x79, 0x84, 0x79);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundTransferGroupStatics> { define_guid(0x2EC50B2, 0x7D18, 0x495B, 0xAA, 0x22, 0x32, 0xA9, 0x7D, 0x45, 0xD3, 0xE2);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundTransferGroup> { define_guid(0xD8C3E3E4, 0x6459, 0x4540, 0x85, 0xEB, 0xAA, 0xA1, 0xC8, 0x90, 0x36, 0x77);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundDownloader3> { define_guid(0xD11A8C48, 0x86E8, 0x48E2, 0xB6, 0x15, 0x69, 0x76, 0xAA, 0xBF, 0x86, 0x1D);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundTransferCompletionGroup> { define_guid(0x2D930225, 0x986B, 0x574D, 0x79, 0x50, 0xA, 0xDD, 0x47, 0xF5, 0xD7, 0x6);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundUploader> { define_guid(0xC595C9AE, 0xCEAD, 0x465B, 0x88, 0x1, 0xC5, 0x5A, 0xC9, 0xA, 0x1, 0xCE);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory> { define_guid(0x90EF98A9, 0x7A01, 0x4A0B, 0x9F, 0x80, 0xA0, 0xB0, 0xBB, 0x37, 0xF, 0x8D);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPart> { define_guid(0xE8E15657, 0xD7D1, 0x4ED8, 0x83, 0x8E, 0x67, 0x4A, 0xC2, 0x17, 0xAC, 0xE6);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundUploader2> { define_guid(0x8E0612CE, 0xC34, 0x4463, 0x80, 0x7F, 0x19, 0x8A, 0x1B, 0x8B, 0xD4, 0xAD);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundUploader3> { define_guid(0xB95E9439, 0x5BF0, 0x4B3A, 0x8C, 0x47, 0x2C, 0x61, 0x99, 0xA8, 0x54, 0xB9);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IResponseInformation> { define_guid(0xF8BB9A12, 0xF713, 0x4792, 0x8B, 0x68, 0xD9, 0xD2, 0x97, 0xF9, 0x1D, 0x2E);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundTransferRangesDownloadedEventArgs> { define_guid(0x3EBC7453, 0xBF48, 0x4A88, 0x92, 0x48, 0xB0, 0xC1, 0x65, 0x18, 0x4F, 0x5C);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundDownloaderFactory> { define_guid(0x26836C24, 0xD89E, 0x46F4, 0xA2, 0x9A, 0x4F, 0x4D, 0x4F, 0x14, 0x41, 0x55);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundDownloaderStaticMethods2> { define_guid(0x2FAA1327, 0x1AD4, 0x4CA5, 0xB2, 0xCD, 0x8, 0xDB, 0xF0, 0x74, 0x6A, 0xFE);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundDownloaderStaticMethods> { define_guid(0x52A65A35, 0xC64E, 0x426C, 0x99, 0x19, 0x54, 0xD, 0xD, 0x21, 0xA6, 0x50);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundUploaderFactory> { define_guid(0x736203C7, 0x10E7, 0x48A0, 0xAC, 0x3C, 0x1A, 0xC7, 0x10, 0x95, 0xEC, 0x57);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundUploaderStaticMethods2> { define_guid(0xE919AC62, 0xEA08, 0x42F0, 0xA2, 0xAC, 0x7, 0xE4, 0x67, 0x54, 0x90, 0x80);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundUploaderStaticMethods> { define_guid(0xF2875CFB, 0x9B05, 0x4741, 0x91, 0x21, 0x74, 0xA, 0x83, 0xE2, 0x47, 0xDF);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundTransferErrorStaticMethods> { define_guid(0xAAD33B04, 0x1192, 0x4BF4, 0x8B, 0x68, 0x39, 0xC5, 0xAD, 0xD2, 0x44, 0xE2);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IContentPrefetcherTime> { define_guid(0xE361FD08, 0x132A, 0x4FDE, 0xA7, 0xCC, 0xFC, 0xB0, 0xE6, 0x65, 0x23, 0xAF);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IContentPrefetcher> { define_guid(0xA8D6F754, 0x7DC1, 0x4CD9, 0x88, 0x10, 0x2A, 0x6A, 0xA9, 0x41, 0x7E, 0x11);};
template<> struct uuid<Windows::Networking::BackgroundTransfer::IBackgroundTransferCompletionGroupTriggerDetails> { define_guid(0x7B6BE286, 0x6E47, 0x5136, 0x7F, 0xCB, 0xFA, 0x43, 0x89, 0xF4, 0x6F, 0x5B);};

// types

namespace Windows { namespace Networking { namespace BackgroundTransfer {

// IBackgroundTransferBase
struct IBackgroundTransferBase_raw : IInspectable {
	virtual STDMETHODIMP _SetRequestHeader(HSTRING headerName, HSTRING headerValue) = 0;
	virtual STDMETHODIMP _get_ServerCredential(Security::Credentials::PasswordCredential* *credential) = 0;
	virtual STDMETHODIMP _put_ServerCredential(Security::Credentials::PasswordCredential* credential) = 0;
	virtual STDMETHODIMP _get_ProxyCredential(Security::Credentials::PasswordCredential* *credential) = 0;
	virtual STDMETHODIMP _put_ProxyCredential(Security::Credentials::PasswordCredential* credential) = 0;
	virtual STDMETHODIMP _get_Method(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_Method(HSTRING value) = 0;
	virtual STDMETHODIMP _get_Group(HSTRING *value) = 0;
	virtual STDMETHODIMP _put_Group(HSTRING value) = 0;
	virtual STDMETHODIMP _get_CostPolicy(BackgroundTransferCostPolicy *value) = 0;
	virtual STDMETHODIMP _put_CostPolicy(BackgroundTransferCostPolicy value) = 0;
};
template<typename X> struct IBackgroundTransferBase_adaptor : X {
	union {
		struct : property {
			BackgroundTransferCostPolicy get() { BackgroundTransferCostPolicy value; hrcheck(enc(&IBackgroundTransferBase_adaptor::CostPolicy)->_get_CostPolicy(&value)); return value; }
			BackgroundTransferCostPolicy operator()() { return get(); }
			operator BackgroundTransferCostPolicy () { return get(); }
			void put(BackgroundTransferCostPolicy value) { hrcheck(enc(&IBackgroundTransferBase_adaptor::CostPolicy)->_put_CostPolicy(value)); }
			void operator=(BackgroundTransferCostPolicy value) { put(value); }
			void operator()(BackgroundTransferCostPolicy value) { put(value); }
		} CostPolicy;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IBackgroundTransferBase_adaptor::Group)->_get_Group(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IBackgroundTransferBase_adaptor::Group)->_put_Group(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Group;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IBackgroundTransferBase_adaptor::Method)->_get_Method(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
			void put(hstring_ref value) { hrcheck(enc(&IBackgroundTransferBase_adaptor::Method)->_put_Method(value)); }
			void operator=(hstring_ref value) { put(value); }
			void operator()(hstring_ref value) { put(value); }
		} Method;
		struct : property {
			ptr<Security::Credentials::PasswordCredential> get() { Security::Credentials::PasswordCredential* credential; hrcheck(enc(&IBackgroundTransferBase_adaptor::ProxyCredential)->_get_ProxyCredential(&credential)); return from_abi(credential); }
			ptr<Security::Credentials::PasswordCredential> operator()() { return get(); }
			operator ptr<Security::Credentials::PasswordCredential> () { return get(); }
			ptr<Security::Credentials::PasswordCredential> operator->() { return get(); }
			void put(pptr<Security::Credentials::PasswordCredential> credential) { hrcheck(enc(&IBackgroundTransferBase_adaptor::ProxyCredential)->_put_ProxyCredential(credential)); }
			void operator=(pptr<Security::Credentials::PasswordCredential> credential) { put(credential); }
			void operator()(pptr<Security::Credentials::PasswordCredential> credential) { put(credential); }
		} ProxyCredential;
		struct : property {
			ptr<Security::Credentials::PasswordCredential> get() { Security::Credentials::PasswordCredential* credential; hrcheck(enc(&IBackgroundTransferBase_adaptor::ServerCredential)->_get_ServerCredential(&credential)); return from_abi(credential); }
			ptr<Security::Credentials::PasswordCredential> operator()() { return get(); }
			operator ptr<Security::Credentials::PasswordCredential> () { return get(); }
			ptr<Security::Credentials::PasswordCredential> operator->() { return get(); }
			void put(pptr<Security::Credentials::PasswordCredential> credential) { hrcheck(enc(&IBackgroundTransferBase_adaptor::ServerCredential)->_put_ServerCredential(credential)); }
			void operator=(pptr<Security::Credentials::PasswordCredential> credential) { put(credential); }
			void operator()(pptr<Security::Credentials::PasswordCredential> credential) { put(credential); }
		} ServerCredential;
	};
	void SetRequestHeader(hstring_ref headerName, hstring_ref headerValue) { hrcheck(X::get()->_SetRequestHeader(headerName, headerValue)); }
	IBackgroundTransferBase_adaptor() {}
};
template<typename X> struct adapt<IBackgroundTransferBase, X> : Windows::Networking::BackgroundTransfer::IBackgroundTransferBase_adaptor<X> { typedef adapt IBackgroundTransferBase; };
template<typename X> struct IBackgroundTransferBase_unadaptor : X {
	STDMETHODIMP _SetRequestHeader(HSTRING headerName, HSTRING headerValue) { return hrtry([&, this] { X::get()->SetRequestHeader(headerName, headerValue); }); }
	STDMETHODIMP _get_ServerCredential(Security::Credentials::PasswordCredential* *credential) { return hrtry([&, this] { get_prop(credential, ServerCredential); }); }
	STDMETHODIMP _put_ServerCredential(Security::Credentials::PasswordCredential* credential) { return hrtry([&, this] { put_prop(credential, ServerCredential); }); }
	STDMETHODIMP _get_ProxyCredential(Security::Credentials::PasswordCredential* *credential) { return hrtry([&, this] { get_prop(credential, ProxyCredential); }); }
	STDMETHODIMP _put_ProxyCredential(Security::Credentials::PasswordCredential* credential) { return hrtry([&, this] { put_prop(credential, ProxyCredential); }); }
	STDMETHODIMP _get_Method(HSTRING *value) { return hrtry([&, this] { get_prop(value, Method); }); }
	STDMETHODIMP _put_Method(HSTRING value) { return hrtry([&, this] { put_prop(value, Method); }); }
	STDMETHODIMP _get_Group(HSTRING *value) { return hrtry([&, this] { get_prop(value, Group); }); }
	STDMETHODIMP _put_Group(HSTRING value) { return hrtry([&, this] { put_prop(value, Group); }); }
	STDMETHODIMP _get_CostPolicy(BackgroundTransferCostPolicy *value) { return hrtry([&, this] { get_prop(value, CostPolicy); }); }
	STDMETHODIMP _put_CostPolicy(BackgroundTransferCostPolicy value) { return hrtry([&, this] { put_prop(value, CostPolicy); }); }
};
template<typename X> struct unadapt<IBackgroundTransferBase, X> : Windows::Networking::BackgroundTransfer::IBackgroundTransferBase_unadaptor<X> {};
struct IBackgroundTransferBase : IBackgroundTransferBase_raw, generate<IBackgroundTransferBase> {};

// IUnconstrainedTransferRequestResult
struct IUnconstrainedTransferRequestResult_raw : IInspectable {
	virtual STDMETHODIMP _get_IsUnconstrained(bool *value);
};
template<typename X> struct IUnconstrainedTransferRequestResult_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IUnconstrainedTransferRequestResult_adaptor::IsUnconstrained)->_get_IsUnconstrained(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsUnconstrained;
	};
	IUnconstrainedTransferRequestResult_adaptor() {}
};
template<typename X> struct adapt<IUnconstrainedTransferRequestResult, X> : Windows::Networking::BackgroundTransfer::IUnconstrainedTransferRequestResult_adaptor<X> { typedef adapt IUnconstrainedTransferRequestResult; };
struct IUnconstrainedTransferRequestResult : IUnconstrainedTransferRequestResult_raw, generate<IUnconstrainedTransferRequestResult> {};

// IBackgroundDownloaderUserConsent
struct IBackgroundDownloaderUserConsent : IInspectable {
	virtual STDMETHODIMP _RequestUnconstrainedDownloadsAsync(Foundation::Collections::IIterable<DownloadOperation*>* operations, Foundation::IAsyncOperation<UnconstrainedTransferRequestResult*>* *operation);
};

// IDownloadOperation4
struct IDownloadOperation4_raw : IInspectable {
	virtual STDMETHODIMP _MakeCurrentInTransferGroup();
};
template<typename X> struct IDownloadOperation4_adaptor : X {
	void MakeCurrentInTransferGroup() { hrcheck(X::get()->_MakeCurrentInTransferGroup()); }
};
template<typename X> struct adapt<IDownloadOperation4, X> : Windows::Networking::BackgroundTransfer::IDownloadOperation4_adaptor<X> { typedef adapt IDownloadOperation4; };
struct IDownloadOperation4 : IDownloadOperation4_raw, generate<IDownloadOperation4> {};

// IDownloadOperation3
struct IDownloadOperation3_raw : IInspectable {
	virtual STDMETHODIMP _get_IsRandomAccessRequired(bool *value);
	virtual STDMETHODIMP _put_IsRandomAccessRequired(bool value);
	virtual STDMETHODIMP _GetResultRandomAccessStreamReference(Storage::Streams::IRandomAccessStreamReference* *stream);
	virtual STDMETHODIMP _GetDownloadedRanges(Foundation::Collections::IVector<BackgroundTransferFileRange>* *value);
	virtual STDMETHODIMP _add_RangesDownloaded(Foundation::TypedEventHandler<DownloadOperation*, BackgroundTransferRangesDownloadedEventArgs*>* eventHandler, Foundation::EventRegistrationToken *eventCookie);
	virtual STDMETHODIMP _remove_RangesDownloaded(Foundation::EventRegistrationToken eventCookie);
	virtual STDMETHODIMP _put_RequestedUri(Foundation::Uri* value);
	virtual STDMETHODIMP _get_RecoverableWebErrorStatuses(Foundation::Collections::IVector<Web::WebErrorStatus>* *value);
	virtual STDMETHODIMP _get_CurrentWebErrorStatus(Foundation::IReference<Web::WebErrorStatus>* *value);
};
template<typename X> struct IDownloadOperation3_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Web::WebErrorStatus>> get() { Foundation::IReference<Web::WebErrorStatus>* value; hrcheck(enc(&IDownloadOperation3_adaptor::CurrentWebErrorStatus)->_get_CurrentWebErrorStatus(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Web::WebErrorStatus>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Web::WebErrorStatus>> () { return get(); }
			ptr<Foundation::IReference<Web::WebErrorStatus>> operator->() { return get(); }
		} CurrentWebErrorStatus;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IDownloadOperation3_adaptor::IsRandomAccessRequired)->_get_IsRandomAccessRequired(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IDownloadOperation3_adaptor::IsRandomAccessRequired)->_put_IsRandomAccessRequired(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsRandomAccessRequired;
		struct : property {
			ptr<Foundation::Collections::IVector<Web::WebErrorStatus>> get() { Foundation::Collections::IVector<Web::WebErrorStatus>* value; hrcheck(enc(&IDownloadOperation3_adaptor::RecoverableWebErrorStatuses)->_get_RecoverableWebErrorStatuses(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<Web::WebErrorStatus>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<Web::WebErrorStatus>> () { return get(); }
			ptr<Foundation::Collections::IVector<Web::WebErrorStatus>> operator->() { return get(); }
		} RecoverableWebErrorStatuses;
		struct : property {
			void put(pptr<Foundation::Uri> value) { hrcheck(enc(&IDownloadOperation3_adaptor::RequestedUri)->_put_RequestedUri(value)); }
			void operator=(pptr<Foundation::Uri> value) { put(value); }
			void operator()(pptr<Foundation::Uri> value) { put(value); }
		} RequestedUri;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<DownloadOperation>, ptr<BackgroundTransferRangesDownloadedEventArgs>>> eventHandler) { Foundation::EventRegistrationToken eventCookie; hrcheck(enc(&IDownloadOperation3_adaptor::RangesDownloaded)->_add_RangesDownloaded(to_abi(eventHandler), &eventCookie)); return eventCookie; }
			void operator-=(const Foundation::EventRegistrationToken& eventCookie) { hrcheck(enc(&IDownloadOperation3_adaptor::RangesDownloaded)->_remove_RangesDownloaded(eventCookie)); }
		} RangesDownloaded;
	};
	ptr<Storage::Streams::IRandomAccessStreamReference> GetResultRandomAccessStreamReference() { Storage::Streams::IRandomAccessStreamReference* stream; hrcheck(X::get()->_GetResultRandomAccessStreamReference(&stream)); return from_abi(stream); }
	ptr<Foundation::Collections::IVector<BackgroundTransferFileRange>> GetDownloadedRanges() { Foundation::Collections::IVector<BackgroundTransferFileRange>* value; hrcheck(X::get()->_GetDownloadedRanges(&value)); return from_abi(value); }
	IDownloadOperation3_adaptor() {}
};
template<typename X> struct adapt<IDownloadOperation3, X> : Windows::Networking::BackgroundTransfer::IDownloadOperation3_adaptor<X> { typedef adapt IDownloadOperation3; };
struct IDownloadOperation3 : IDownloadOperation3_raw, generate<IDownloadOperation3> {};

// IDownloadOperation2
struct IDownloadOperation2_raw : IInspectable {
	virtual STDMETHODIMP _get_TransferGroup(BackgroundTransferGroup* *value);
};
template<typename X> struct IDownloadOperation2_adaptor : X {
	union {
		struct : property {
			ptr<BackgroundTransferGroup> get() { BackgroundTransferGroup* value; hrcheck(enc(&IDownloadOperation2_adaptor::TransferGroup)->_get_TransferGroup(&value)); return from_abi(value); }
			ptr<BackgroundTransferGroup> operator()() { return get(); }
			operator ptr<BackgroundTransferGroup> () { return get(); }
			ptr<BackgroundTransferGroup> operator->() { return get(); }
		} TransferGroup;
	};
	IDownloadOperation2_adaptor() {}
};
template<typename X> struct adapt<IDownloadOperation2, X> : Windows::Networking::BackgroundTransfer::IDownloadOperation2_adaptor<X> { typedef adapt IDownloadOperation2; };
struct IDownloadOperation2 : IDownloadOperation2_raw, generate<IDownloadOperation2> {};

// IBackgroundTransferOperationPriority
struct IBackgroundTransferOperationPriority_raw : IInspectable {
	virtual STDMETHODIMP _get_Priority(BackgroundTransferPriority *value) = 0;
	virtual STDMETHODIMP _put_Priority(BackgroundTransferPriority value) = 0;
};
template<typename X> struct IBackgroundTransferOperationPriority_adaptor : X {
	union {
		struct : property {
			BackgroundTransferPriority get() { BackgroundTransferPriority value; hrcheck(enc(&IBackgroundTransferOperationPriority_adaptor::Priority)->_get_Priority(&value)); return value; }
			BackgroundTransferPriority operator()() { return get(); }
			operator BackgroundTransferPriority () { return get(); }
			void put(BackgroundTransferPriority value) { hrcheck(enc(&IBackgroundTransferOperationPriority_adaptor::Priority)->_put_Priority(value)); }
			void operator=(BackgroundTransferPriority value) { put(value); }
			void operator()(BackgroundTransferPriority value) { put(value); }
		} Priority;
	};
	IBackgroundTransferOperationPriority_adaptor() {}
};
template<typename X> struct adapt<IBackgroundTransferOperationPriority, X> : Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority_adaptor<X> { typedef adapt IBackgroundTransferOperationPriority; };
template<typename X> struct IBackgroundTransferOperationPriority_unadaptor : X {
	STDMETHODIMP _get_Priority(BackgroundTransferPriority *value) { return hrtry([&, this] { get_prop(value, Priority); }); }
	STDMETHODIMP _put_Priority(BackgroundTransferPriority value) { return hrtry([&, this] { put_prop(value, Priority); }); }
};
template<typename X> struct unadapt<IBackgroundTransferOperationPriority, X> : Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority_unadaptor<X> {};
struct IBackgroundTransferOperationPriority : IBackgroundTransferOperationPriority_raw, generate<IBackgroundTransferOperationPriority> {};

// IBackgroundTransferOperation
struct IBackgroundTransferOperation_raw : IInspectable {
	virtual STDMETHODIMP _get_Guid(Platform::Guid *value) = 0;
	virtual STDMETHODIMP _get_RequestedUri(Foundation::Uri* *value) = 0;
	virtual STDMETHODIMP _get_Method(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_Group(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_CostPolicy(BackgroundTransferCostPolicy *value) = 0;
	virtual STDMETHODIMP _put_CostPolicy(BackgroundTransferCostPolicy value) = 0;
	virtual STDMETHODIMP _GetResultStreamAt(unsigned __int64 position, Storage::Streams::IInputStream* *value) = 0;
	virtual STDMETHODIMP _GetResponseInformation(ResponseInformation* *value) = 0;
};
template<typename X> struct IBackgroundTransferOperation_adaptor : X {
	union {
		struct : property {
			BackgroundTransferCostPolicy get() { BackgroundTransferCostPolicy value; hrcheck(enc(&IBackgroundTransferOperation_adaptor::CostPolicy)->_get_CostPolicy(&value)); return value; }
			BackgroundTransferCostPolicy operator()() { return get(); }
			operator BackgroundTransferCostPolicy () { return get(); }
			void put(BackgroundTransferCostPolicy value) { hrcheck(enc(&IBackgroundTransferOperation_adaptor::CostPolicy)->_put_CostPolicy(value)); }
			void operator=(BackgroundTransferCostPolicy value) { put(value); }
			void operator()(BackgroundTransferCostPolicy value) { put(value); }
		} CostPolicy;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IBackgroundTransferOperation_adaptor::Group)->_get_Group(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Group;
		struct : property {
			Platform::Guid get() { Platform::Guid value; hrcheck(enc(&IBackgroundTransferOperation_adaptor::Guid)->_get_Guid(&value)); return value; }
			Platform::Guid operator()() { return get(); }
			operator Platform::Guid () { return get(); }
		} Guid;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IBackgroundTransferOperation_adaptor::Method)->_get_Method(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Method;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IBackgroundTransferOperation_adaptor::RequestedUri)->_get_RequestedUri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} RequestedUri;
	};
	ptr<Storage::Streams::IInputStream> GetResultStreamAt(unsigned __int64 position) { Storage::Streams::IInputStream* value; hrcheck(X::get()->_GetResultStreamAt(position, &value)); return from_abi(value); }
	ptr<ResponseInformation> GetResponseInformation() { ResponseInformation* value; hrcheck(X::get()->_GetResponseInformation(&value)); return from_abi(value); }
	IBackgroundTransferOperation_adaptor() {}
};
template<typename X> struct adapt<IBackgroundTransferOperation, X> : Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation_adaptor<X> { typedef adapt IBackgroundTransferOperation; };
template<typename X> struct IBackgroundTransferOperation_unadaptor : X {
	STDMETHODIMP _get_Guid(Platform::Guid *value) { return hrtry([&, this] { get_prop(value, Guid); }); }
	STDMETHODIMP _get_RequestedUri(Foundation::Uri* *value) { return hrtry([&, this] { get_prop(value, RequestedUri); }); }
	STDMETHODIMP _get_Method(HSTRING *value) { return hrtry([&, this] { get_prop(value, Method); }); }
	STDMETHODIMP _get_Group(HSTRING *value) { return hrtry([&, this] { get_prop(value, Group); }); }
	STDMETHODIMP _get_CostPolicy(BackgroundTransferCostPolicy *value) { return hrtry([&, this] { get_prop(value, CostPolicy); }); }
	STDMETHODIMP _put_CostPolicy(BackgroundTransferCostPolicy value) { return hrtry([&, this] { put_prop(value, CostPolicy); }); }
	STDMETHODIMP _GetResultStreamAt(unsigned __int64 position, Storage::Streams::IInputStream* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetResultStreamAt(position)); }); }
	STDMETHODIMP _GetResponseInformation(ResponseInformation* *value) { return hrtry([&, this] { *value = to_abi(X::get()->GetResponseInformation()); }); }
};
template<typename X> struct unadapt<IBackgroundTransferOperation, X> : Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation_unadaptor<X> {};
struct IBackgroundTransferOperation : IBackgroundTransferOperation_raw, generate<IBackgroundTransferOperation> {};

// IDownloadOperation
struct IDownloadOperation_raw : IInspectable {
	virtual STDMETHODIMP _get_ResultFile(Storage::IStorageFile* *value);
	virtual STDMETHODIMP _get_Progress(BackgroundDownloadProgress *value);
	virtual STDMETHODIMP _StartAsync(Foundation::IAsyncOperationWithProgress<DownloadOperation*, DownloadOperation*>* *operation);
	virtual STDMETHODIMP _AttachAsync(Foundation::IAsyncOperationWithProgress<DownloadOperation*, DownloadOperation*>* *operation);
	virtual STDMETHODIMP _Pause();
	virtual STDMETHODIMP _Resume();
};
template<typename X> struct IDownloadOperation_adaptor : X {
	union {
		struct : property {
			BackgroundDownloadProgress get() { BackgroundDownloadProgress value; hrcheck(enc(&IDownloadOperation_adaptor::Progress)->_get_Progress(&value)); return value; }
			BackgroundDownloadProgress operator()() { return get(); }
			operator BackgroundDownloadProgress () { return get(); }
		} Progress;
		struct : property {
			ptr<Storage::IStorageFile> get() { Storage::IStorageFile* value; hrcheck(enc(&IDownloadOperation_adaptor::ResultFile)->_get_ResultFile(&value)); return from_abi(value); }
			ptr<Storage::IStorageFile> operator()() { return get(); }
			operator ptr<Storage::IStorageFile> () { return get(); }
			ptr<Storage::IStorageFile> operator->() { return get(); }
		} ResultFile;
	};
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DownloadOperation>, ptr<DownloadOperation>>> StartAsync() { Foundation::IAsyncOperationWithProgress<DownloadOperation*, DownloadOperation*>* operation; hrcheck(X::get()->_StartAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<DownloadOperation>, ptr<DownloadOperation>>> AttachAsync() { Foundation::IAsyncOperationWithProgress<DownloadOperation*, DownloadOperation*>* operation; hrcheck(X::get()->_AttachAsync(&operation)); return from_abi(operation); }
	void Pause() { hrcheck(X::get()->_Pause()); }
	void Resume() { hrcheck(X::get()->_Resume()); }
	IDownloadOperation_adaptor() {}
};
template<typename X> struct adapt<IDownloadOperation, X> : Windows::Networking::BackgroundTransfer::IDownloadOperation_adaptor<X> { typedef adapt IDownloadOperation; };
struct IDownloadOperation : IDownloadOperation_raw, generate<IDownloadOperation> {};

// DownloadOperation
template<typename X> struct statics<DownloadOperation, X> : X {
	typedef typename X::root_type DownloadOperation;
};
struct DownloadOperation : generate<DownloadOperation> {
	using IBackgroundTransferOperation::RequestedUri;
};

// UnconstrainedTransferRequestResult
template<typename X> struct statics<UnconstrainedTransferRequestResult, X> : X {
	typedef typename X::root_type UnconstrainedTransferRequestResult;
};
struct UnconstrainedTransferRequestResult : generate<UnconstrainedTransferRequestResult> {};

// IBackgroundUploaderUserConsent
struct IBackgroundUploaderUserConsent : IInspectable {
	virtual STDMETHODIMP _RequestUnconstrainedUploadsAsync(Foundation::Collections::IIterable<UploadOperation*>* operations, Foundation::IAsyncOperation<UnconstrainedTransferRequestResult*>* *operation);
};

// IUploadOperation3
struct IUploadOperation3_raw : IInspectable {
	virtual STDMETHODIMP _MakeCurrentInTransferGroup();
};
template<typename X> struct IUploadOperation3_adaptor : X {
	void MakeCurrentInTransferGroup() { hrcheck(X::get()->_MakeCurrentInTransferGroup()); }
};
template<typename X> struct adapt<IUploadOperation3, X> : Windows::Networking::BackgroundTransfer::IUploadOperation3_adaptor<X> { typedef adapt IUploadOperation3; };
struct IUploadOperation3 : IUploadOperation3_raw, generate<IUploadOperation3> {};

// IUploadOperation2
struct IUploadOperation2_raw : IInspectable {
	virtual STDMETHODIMP _get_TransferGroup(BackgroundTransferGroup* *value);
};
template<typename X> struct IUploadOperation2_adaptor : X {
	union {
		struct : property {
			ptr<BackgroundTransferGroup> get() { BackgroundTransferGroup* value; hrcheck(enc(&IUploadOperation2_adaptor::TransferGroup)->_get_TransferGroup(&value)); return from_abi(value); }
			ptr<BackgroundTransferGroup> operator()() { return get(); }
			operator ptr<BackgroundTransferGroup> () { return get(); }
			ptr<BackgroundTransferGroup> operator->() { return get(); }
		} TransferGroup;
	};
	IUploadOperation2_adaptor() {}
};
template<typename X> struct adapt<IUploadOperation2, X> : Windows::Networking::BackgroundTransfer::IUploadOperation2_adaptor<X> { typedef adapt IUploadOperation2; };
struct IUploadOperation2 : IUploadOperation2_raw, generate<IUploadOperation2> {};

// IUploadOperation
struct IUploadOperation_raw : IInspectable {
	virtual STDMETHODIMP _get_SourceFile(Storage::IStorageFile* *value);
	virtual STDMETHODIMP _get_Progress(BackgroundUploadProgress *value);
	virtual STDMETHODIMP _StartAsync(Foundation::IAsyncOperationWithProgress<UploadOperation*, UploadOperation*>* *operation);
	virtual STDMETHODIMP _AttachAsync(Foundation::IAsyncOperationWithProgress<UploadOperation*, UploadOperation*>* *operation);
};
template<typename X> struct IUploadOperation_adaptor : X {
	union {
		struct : property {
			BackgroundUploadProgress get() { BackgroundUploadProgress value; hrcheck(enc(&IUploadOperation_adaptor::Progress)->_get_Progress(&value)); return value; }
			BackgroundUploadProgress operator()() { return get(); }
			operator BackgroundUploadProgress () { return get(); }
		} Progress;
		struct : property {
			ptr<Storage::IStorageFile> get() { Storage::IStorageFile* value; hrcheck(enc(&IUploadOperation_adaptor::SourceFile)->_get_SourceFile(&value)); return from_abi(value); }
			ptr<Storage::IStorageFile> operator()() { return get(); }
			operator ptr<Storage::IStorageFile> () { return get(); }
			ptr<Storage::IStorageFile> operator->() { return get(); }
		} SourceFile;
	};
	ptr<Foundation::IAsyncOperationWithProgress<ptr<UploadOperation>, ptr<UploadOperation>>> StartAsync() { Foundation::IAsyncOperationWithProgress<UploadOperation*, UploadOperation*>* operation; hrcheck(X::get()->_StartAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperationWithProgress<ptr<UploadOperation>, ptr<UploadOperation>>> AttachAsync() { Foundation::IAsyncOperationWithProgress<UploadOperation*, UploadOperation*>* operation; hrcheck(X::get()->_AttachAsync(&operation)); return from_abi(operation); }
	IUploadOperation_adaptor() {}
};
template<typename X> struct adapt<IUploadOperation, X> : Windows::Networking::BackgroundTransfer::IUploadOperation_adaptor<X> { typedef adapt IUploadOperation; };
struct IUploadOperation : IUploadOperation_raw, generate<IUploadOperation> {};

// UploadOperation
template<typename X> struct statics<UploadOperation, X> : X {
	typedef typename X::root_type UploadOperation;
};
struct UploadOperation : generate<UploadOperation> {};

// IBackgroundDownloader
struct IBackgroundDownloader_raw : IInspectable {
	virtual STDMETHODIMP _CreateDownload(Foundation::Uri* uri, Storage::IStorageFile* resultFile, DownloadOperation* *operation);
	virtual STDMETHODIMP _CreateDownloadFromFile(Foundation::Uri* uri, Storage::IStorageFile* resultFile, Storage::IStorageFile* requestBodyFile, DownloadOperation* *operation);
	virtual STDMETHODIMP _CreateDownloadAsync(Foundation::Uri* uri, Storage::IStorageFile* resultFile, Storage::Streams::IInputStream* requestBodyStream, Foundation::IAsyncOperation<DownloadOperation*>* *operation);
};
template<typename X> struct IBackgroundDownloader_adaptor : X {
	ptr<DownloadOperation> CreateDownload(pptr<Foundation::Uri> uri, pptr<Storage::IStorageFile> resultFile) { DownloadOperation* operation; hrcheck(X::get()->_CreateDownload(uri, resultFile, &operation)); return from_abi(operation); }
	ptr<DownloadOperation> CreateDownload(pptr<Foundation::Uri> uri, pptr<Storage::IStorageFile> resultFile, pptr<Storage::IStorageFile> requestBodyFile) { DownloadOperation* operation; hrcheck(X::get()->_CreateDownloadFromFile(uri, resultFile, requestBodyFile, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<DownloadOperation>>> CreateDownloadAsync(pptr<Foundation::Uri> uri, pptr<Storage::IStorageFile> resultFile, pptr<Storage::Streams::IInputStream> requestBodyStream) { Foundation::IAsyncOperation<DownloadOperation*>* operation; hrcheck(X::get()->_CreateDownloadAsync(uri, resultFile, requestBodyStream, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IBackgroundDownloader, X> : Windows::Networking::BackgroundTransfer::IBackgroundDownloader_adaptor<X> { typedef adapt IBackgroundDownloader; };
struct IBackgroundDownloader : IBackgroundDownloader_raw, generate<IBackgroundDownloader> {};

// IBackgroundDownloader2
struct IBackgroundDownloader2_raw : IInspectable {
	virtual STDMETHODIMP _get_TransferGroup(BackgroundTransferGroup* *value);
	virtual STDMETHODIMP _put_TransferGroup(BackgroundTransferGroup* value);
	virtual STDMETHODIMP _get_SuccessToastNotification(UI::Notifications::ToastNotification* *value);
	virtual STDMETHODIMP _put_SuccessToastNotification(UI::Notifications::ToastNotification* value);
	virtual STDMETHODIMP _get_FailureToastNotification(UI::Notifications::ToastNotification* *value);
	virtual STDMETHODIMP _put_FailureToastNotification(UI::Notifications::ToastNotification* value);
	virtual STDMETHODIMP _get_SuccessTileNotification(UI::Notifications::TileNotification* *value);
	virtual STDMETHODIMP _put_SuccessTileNotification(UI::Notifications::TileNotification* value);
	virtual STDMETHODIMP _get_FailureTileNotification(UI::Notifications::TileNotification* *value);
	virtual STDMETHODIMP _put_FailureTileNotification(UI::Notifications::TileNotification* value);
};
template<typename X> struct IBackgroundDownloader2_adaptor : X {
	union {
		struct : property {
			ptr<UI::Notifications::TileNotification> get() { UI::Notifications::TileNotification* value; hrcheck(enc(&IBackgroundDownloader2_adaptor::FailureTileNotification)->_get_FailureTileNotification(&value)); return from_abi(value); }
			ptr<UI::Notifications::TileNotification> operator()() { return get(); }
			operator ptr<UI::Notifications::TileNotification> () { return get(); }
			ptr<UI::Notifications::TileNotification> operator->() { return get(); }
			void put(pptr<UI::Notifications::TileNotification> value) { hrcheck(enc(&IBackgroundDownloader2_adaptor::FailureTileNotification)->_put_FailureTileNotification(value)); }
			void operator=(pptr<UI::Notifications::TileNotification> value) { put(value); }
			void operator()(pptr<UI::Notifications::TileNotification> value) { put(value); }
		} FailureTileNotification;
		struct : property {
			ptr<UI::Notifications::ToastNotification> get() { UI::Notifications::ToastNotification* value; hrcheck(enc(&IBackgroundDownloader2_adaptor::FailureToastNotification)->_get_FailureToastNotification(&value)); return from_abi(value); }
			ptr<UI::Notifications::ToastNotification> operator()() { return get(); }
			operator ptr<UI::Notifications::ToastNotification> () { return get(); }
			ptr<UI::Notifications::ToastNotification> operator->() { return get(); }
			void put(pptr<UI::Notifications::ToastNotification> value) { hrcheck(enc(&IBackgroundDownloader2_adaptor::FailureToastNotification)->_put_FailureToastNotification(value)); }
			void operator=(pptr<UI::Notifications::ToastNotification> value) { put(value); }
			void operator()(pptr<UI::Notifications::ToastNotification> value) { put(value); }
		} FailureToastNotification;
		struct : property {
			ptr<UI::Notifications::TileNotification> get() { UI::Notifications::TileNotification* value; hrcheck(enc(&IBackgroundDownloader2_adaptor::SuccessTileNotification)->_get_SuccessTileNotification(&value)); return from_abi(value); }
			ptr<UI::Notifications::TileNotification> operator()() { return get(); }
			operator ptr<UI::Notifications::TileNotification> () { return get(); }
			ptr<UI::Notifications::TileNotification> operator->() { return get(); }
			void put(pptr<UI::Notifications::TileNotification> value) { hrcheck(enc(&IBackgroundDownloader2_adaptor::SuccessTileNotification)->_put_SuccessTileNotification(value)); }
			void operator=(pptr<UI::Notifications::TileNotification> value) { put(value); }
			void operator()(pptr<UI::Notifications::TileNotification> value) { put(value); }
		} SuccessTileNotification;
		struct : property {
			ptr<UI::Notifications::ToastNotification> get() { UI::Notifications::ToastNotification* value; hrcheck(enc(&IBackgroundDownloader2_adaptor::SuccessToastNotification)->_get_SuccessToastNotification(&value)); return from_abi(value); }
			ptr<UI::Notifications::ToastNotification> operator()() { return get(); }
			operator ptr<UI::Notifications::ToastNotification> () { return get(); }
			ptr<UI::Notifications::ToastNotification> operator->() { return get(); }
			void put(pptr<UI::Notifications::ToastNotification> value) { hrcheck(enc(&IBackgroundDownloader2_adaptor::SuccessToastNotification)->_put_SuccessToastNotification(value)); }
			void operator=(pptr<UI::Notifications::ToastNotification> value) { put(value); }
			void operator()(pptr<UI::Notifications::ToastNotification> value) { put(value); }
		} SuccessToastNotification;
		struct : property {
			ptr<BackgroundTransferGroup> get() { BackgroundTransferGroup* value; hrcheck(enc(&IBackgroundDownloader2_adaptor::TransferGroup)->_get_TransferGroup(&value)); return from_abi(value); }
			ptr<BackgroundTransferGroup> operator()() { return get(); }
			operator ptr<BackgroundTransferGroup> () { return get(); }
			ptr<BackgroundTransferGroup> operator->() { return get(); }
			void put(pptr<BackgroundTransferGroup> value) { hrcheck(enc(&IBackgroundDownloader2_adaptor::TransferGroup)->_put_TransferGroup(value)); }
			void operator=(pptr<BackgroundTransferGroup> value) { put(value); }
			void operator()(pptr<BackgroundTransferGroup> value) { put(value); }
		} TransferGroup;
	};
	IBackgroundDownloader2_adaptor() {}
};
template<typename X> struct adapt<IBackgroundDownloader2, X> : Windows::Networking::BackgroundTransfer::IBackgroundDownloader2_adaptor<X> { typedef adapt IBackgroundDownloader2; };
struct IBackgroundDownloader2 : IBackgroundDownloader2_raw, generate<IBackgroundDownloader2> {};

// IBackgroundTransferGroupStatics
struct IBackgroundTransferGroupStatics : IInspectable {
	virtual STDMETHODIMP _CreateGroup(HSTRING name, BackgroundTransferGroup* *value);
};

// IBackgroundTransferGroup
struct IBackgroundTransferGroup_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_TransferBehavior(BackgroundTransferBehavior *value);
	virtual STDMETHODIMP _put_TransferBehavior(BackgroundTransferBehavior value);
};
template<typename X> struct IBackgroundTransferGroup_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IBackgroundTransferGroup_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			BackgroundTransferBehavior get() { BackgroundTransferBehavior value; hrcheck(enc(&IBackgroundTransferGroup_adaptor::TransferBehavior)->_get_TransferBehavior(&value)); return value; }
			BackgroundTransferBehavior operator()() { return get(); }
			operator BackgroundTransferBehavior () { return get(); }
			void put(BackgroundTransferBehavior value) { hrcheck(enc(&IBackgroundTransferGroup_adaptor::TransferBehavior)->_put_TransferBehavior(value)); }
			void operator=(BackgroundTransferBehavior value) { put(value); }
			void operator()(BackgroundTransferBehavior value) { put(value); }
		} TransferBehavior;
	};
	IBackgroundTransferGroup_adaptor() {}
};
template<typename X> struct adapt<IBackgroundTransferGroup, X> : Windows::Networking::BackgroundTransfer::IBackgroundTransferGroup_adaptor<X> { typedef adapt IBackgroundTransferGroup; };
struct IBackgroundTransferGroup : IBackgroundTransferGroup_raw, generate<IBackgroundTransferGroup> {};

// BackgroundTransferGroup
template<typename> struct BackgroundTransferGroup_statics {
	static ptr<BackgroundTransferGroup> CreateGroup(hstring_ref name) { BackgroundTransferGroup* value; hrcheck(get_activation_factory<BackgroundTransferGroup, IBackgroundTransferGroupStatics>()->_CreateGroup(name, &value)); return from_abi(value); }
};

template<typename X> struct statics<BackgroundTransferGroup, X> : X, Windows::Networking::BackgroundTransfer::BackgroundTransferGroup_statics<void> {
	typedef typename X::root_type BackgroundTransferGroup;
};
struct BackgroundTransferGroup : generate<BackgroundTransferGroup> {};

// IBackgroundDownloader3
struct IBackgroundDownloader3_raw : IInspectable {
	virtual STDMETHODIMP _get_CompletionGroup(BackgroundTransferCompletionGroup* *value);
};
template<typename X> struct IBackgroundDownloader3_adaptor : X {
	union {
		struct : property {
			ptr<BackgroundTransferCompletionGroup> get() { BackgroundTransferCompletionGroup* value; hrcheck(enc(&IBackgroundDownloader3_adaptor::CompletionGroup)->_get_CompletionGroup(&value)); return from_abi(value); }
			ptr<BackgroundTransferCompletionGroup> operator()() { return get(); }
			operator ptr<BackgroundTransferCompletionGroup> () { return get(); }
			ptr<BackgroundTransferCompletionGroup> operator->() { return get(); }
		} CompletionGroup;
	};
	IBackgroundDownloader3_adaptor() {}
};
template<typename X> struct adapt<IBackgroundDownloader3, X> : Windows::Networking::BackgroundTransfer::IBackgroundDownloader3_adaptor<X> { typedef adapt IBackgroundDownloader3; };
struct IBackgroundDownloader3 : IBackgroundDownloader3_raw, generate<IBackgroundDownloader3> {};

// IBackgroundTransferCompletionGroup
struct IBackgroundTransferCompletionGroup_raw : IInspectable {
	virtual STDMETHODIMP _get_Trigger(ApplicationModel::Background::IBackgroundTrigger* *value);
	virtual STDMETHODIMP _get_IsEnabled(bool *value);
	virtual STDMETHODIMP _Enable();
};
template<typename X> struct IBackgroundTransferCompletionGroup_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBackgroundTransferCompletionGroup_adaptor::IsEnabled)->_get_IsEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsEnabled;
		struct : property {
			ptr<ApplicationModel::Background::IBackgroundTrigger> get() { ApplicationModel::Background::IBackgroundTrigger* value; hrcheck(enc(&IBackgroundTransferCompletionGroup_adaptor::Trigger)->_get_Trigger(&value)); return from_abi(value); }
			ptr<ApplicationModel::Background::IBackgroundTrigger> operator()() { return get(); }
			operator ptr<ApplicationModel::Background::IBackgroundTrigger> () { return get(); }
			ptr<ApplicationModel::Background::IBackgroundTrigger> operator->() { return get(); }
		} Trigger;
	};
	void Enable() { hrcheck(X::get()->_Enable()); }
	IBackgroundTransferCompletionGroup_adaptor() {}
};
template<typename X> struct adapt<IBackgroundTransferCompletionGroup, X> : Windows::Networking::BackgroundTransfer::IBackgroundTransferCompletionGroup_adaptor<X> { typedef adapt IBackgroundTransferCompletionGroup; };
struct IBackgroundTransferCompletionGroup : IBackgroundTransferCompletionGroup_raw, generate<IBackgroundTransferCompletionGroup> {};

// BackgroundTransferCompletionGroup
template<typename X> struct statics<BackgroundTransferCompletionGroup, X> : X {
	typedef typename X::root_type BackgroundTransferCompletionGroup;
};
struct BackgroundTransferCompletionGroup : generate<BackgroundTransferCompletionGroup> {};

// IBackgroundUploader
struct IBackgroundUploader_raw : IInspectable {
	virtual STDMETHODIMP _CreateUpload(Foundation::Uri* uri, Storage::IStorageFile* sourceFile, UploadOperation* *operation);
	virtual STDMETHODIMP _CreateUploadFromStreamAsync(Foundation::Uri* uri, Storage::Streams::IInputStream* sourceStream, Foundation::IAsyncOperation<UploadOperation*>* *operation);
	virtual STDMETHODIMP _CreateUploadWithFormDataAndAutoBoundaryAsync(Foundation::Uri* uri, Foundation::Collections::IIterable<BackgroundTransferContentPart*>* parts, Foundation::IAsyncOperation<UploadOperation*>* *operation);
	virtual STDMETHODIMP _CreateUploadWithSubTypeAsync(Foundation::Uri* uri, Foundation::Collections::IIterable<BackgroundTransferContentPart*>* parts, HSTRING subType, Foundation::IAsyncOperation<UploadOperation*>* *operation);
	virtual STDMETHODIMP _CreateUploadWithSubTypeAndBoundaryAsync(Foundation::Uri* uri, Foundation::Collections::IIterable<BackgroundTransferContentPart*>* parts, HSTRING subType, HSTRING boundary, Foundation::IAsyncOperation<UploadOperation*>* *operation);
};
template<typename X> struct IBackgroundUploader_adaptor : X {
	ptr<UploadOperation> CreateUpload(pptr<Foundation::Uri> uri, pptr<Storage::IStorageFile> sourceFile) { UploadOperation* operation; hrcheck(X::get()->_CreateUpload(uri, sourceFile, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<UploadOperation>>> CreateUploadFromStreamAsync(pptr<Foundation::Uri> uri, pptr<Storage::Streams::IInputStream> sourceStream) { Foundation::IAsyncOperation<UploadOperation*>* operation; hrcheck(X::get()->_CreateUploadFromStreamAsync(uri, sourceStream, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<UploadOperation>>> CreateUploadAsync(pptr<Foundation::Uri> uri, pptr<Foundation::Collections::IIterable<ptr<BackgroundTransferContentPart>>> parts) { Foundation::IAsyncOperation<UploadOperation*>* operation; hrcheck(X::get()->_CreateUploadWithFormDataAndAutoBoundaryAsync(uri, to_abi(parts), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<UploadOperation>>> CreateUploadAsync(pptr<Foundation::Uri> uri, pptr<Foundation::Collections::IIterable<ptr<BackgroundTransferContentPart>>> parts, hstring_ref subType) { Foundation::IAsyncOperation<UploadOperation*>* operation; hrcheck(X::get()->_CreateUploadWithSubTypeAsync(uri, to_abi(parts), subType, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<UploadOperation>>> CreateUploadAsync(pptr<Foundation::Uri> uri, pptr<Foundation::Collections::IIterable<ptr<BackgroundTransferContentPart>>> parts, hstring_ref subType, hstring_ref boundary) { Foundation::IAsyncOperation<UploadOperation*>* operation; hrcheck(X::get()->_CreateUploadWithSubTypeAndBoundaryAsync(uri, to_abi(parts), subType, boundary, &operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IBackgroundUploader, X> : Windows::Networking::BackgroundTransfer::IBackgroundUploader_adaptor<X> { typedef adapt IBackgroundUploader; };
struct IBackgroundUploader : IBackgroundUploader_raw, generate<IBackgroundUploader> {};

// IBackgroundTransferContentPartFactory
struct IBackgroundTransferContentPartFactory_raw : IInspectable {
	virtual STDMETHODIMP _CreateWithName(HSTRING name, BackgroundTransferContentPart* *value) = 0;
	virtual STDMETHODIMP _CreateWithNameAndFileName(HSTRING name, HSTRING fileName, BackgroundTransferContentPart* *value) = 0;
};
template<typename X> struct IBackgroundTransferContentPartFactory_adaptor : X {
	ptr<BackgroundTransferContentPart> CreateWithName(hstring_ref name) { BackgroundTransferContentPart* value; hrcheck(X::get()->_CreateWithName(name, &value)); return from_abi(value); }
	ptr<BackgroundTransferContentPart> CreateWithNameAndFileName(hstring_ref name, hstring_ref fileName) { BackgroundTransferContentPart* value; hrcheck(X::get()->_CreateWithNameAndFileName(name, fileName, &value)); return from_abi(value); }
};
template<typename X> struct adapt<IBackgroundTransferContentPartFactory, X> : Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory_adaptor<X> { typedef adapt IBackgroundTransferContentPartFactory; };
template<typename X> struct IBackgroundTransferContentPartFactory_unadaptor : X {
	STDMETHODIMP _CreateWithName(HSTRING name, BackgroundTransferContentPart* *value) { return hrtry([&, this] { *value = to_abi(X::get()->CreateWithName(name)); }); }
	STDMETHODIMP _CreateWithNameAndFileName(HSTRING name, HSTRING fileName, BackgroundTransferContentPart* *value) { return hrtry([&, this] { *value = to_abi(X::get()->CreateWithNameAndFileName(name, fileName)); }); }
};
template<typename X> struct unadapt<IBackgroundTransferContentPartFactory, X> : Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory_unadaptor<X> {};
struct IBackgroundTransferContentPartFactory : IBackgroundTransferContentPartFactory_raw, generate<IBackgroundTransferContentPartFactory> {};

// IBackgroundTransferContentPart
struct IBackgroundTransferContentPart_raw : IInspectable {
	virtual STDMETHODIMP _SetHeader(HSTRING headerName, HSTRING headerValue);
	virtual STDMETHODIMP _SetText(HSTRING value);
	virtual STDMETHODIMP _SetFile(Storage::IStorageFile* value);
};
template<typename X> struct IBackgroundTransferContentPart_adaptor : X {
	void SetHeader(hstring_ref headerName, hstring_ref headerValue) { hrcheck(X::get()->_SetHeader(headerName, headerValue)); }
	void SetText(hstring_ref value) { hrcheck(X::get()->_SetText(value)); }
	void SetFile(pptr<Storage::IStorageFile> value) { hrcheck(X::get()->_SetFile(value)); }
};
template<typename X> struct adapt<IBackgroundTransferContentPart, X> : Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPart_adaptor<X> { typedef adapt IBackgroundTransferContentPart; };
struct IBackgroundTransferContentPart : IBackgroundTransferContentPart_raw, generate<IBackgroundTransferContentPart> {};

// BackgroundTransferContentPart
template<typename> struct BackgroundTransferContentPart_statics {
	static BackgroundTransferContentPart *activate() { BackgroundTransferContentPart *t; get_activation_factory<BackgroundTransferContentPart>()->ActivateInstance((IInspectable**)&t); return t; }
	static BackgroundTransferContentPart *activate(hstring_ref name) { BackgroundTransferContentPart *value; hrcheck(get_activation_factory<BackgroundTransferContentPart, IBackgroundTransferContentPartFactory>()->_CreateWithName(name, &value)); return value; }
	static BackgroundTransferContentPart *activate(hstring_ref name, hstring_ref fileName) { BackgroundTransferContentPart *value; hrcheck(get_activation_factory<BackgroundTransferContentPart, IBackgroundTransferContentPartFactory>()->_CreateWithNameAndFileName(name, fileName, &value)); return value; }
};

template<typename X> struct statics<BackgroundTransferContentPart, X> : X, Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart_statics<void> {
	using Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart_statics<void>::activate;
	typedef typename X::root_type BackgroundTransferContentPart;
};
struct BackgroundTransferContentPart : generate<BackgroundTransferContentPart> {};

// IBackgroundUploader2
struct IBackgroundUploader2_raw : IInspectable {
	virtual STDMETHODIMP _get_TransferGroup(BackgroundTransferGroup* *value);
	virtual STDMETHODIMP _put_TransferGroup(BackgroundTransferGroup* value);
	virtual STDMETHODIMP _get_SuccessToastNotification(UI::Notifications::ToastNotification* *value);
	virtual STDMETHODIMP _put_SuccessToastNotification(UI::Notifications::ToastNotification* value);
	virtual STDMETHODIMP _get_FailureToastNotification(UI::Notifications::ToastNotification* *value);
	virtual STDMETHODIMP _put_FailureToastNotification(UI::Notifications::ToastNotification* value);
	virtual STDMETHODIMP _get_SuccessTileNotification(UI::Notifications::TileNotification* *value);
	virtual STDMETHODIMP _put_SuccessTileNotification(UI::Notifications::TileNotification* value);
	virtual STDMETHODIMP _get_FailureTileNotification(UI::Notifications::TileNotification* *value);
	virtual STDMETHODIMP _put_FailureTileNotification(UI::Notifications::TileNotification* value);
};
template<typename X> struct IBackgroundUploader2_adaptor : X {
	union {
		struct : property {
			ptr<UI::Notifications::TileNotification> get() { UI::Notifications::TileNotification* value; hrcheck(enc(&IBackgroundUploader2_adaptor::FailureTileNotification)->_get_FailureTileNotification(&value)); return from_abi(value); }
			ptr<UI::Notifications::TileNotification> operator()() { return get(); }
			operator ptr<UI::Notifications::TileNotification> () { return get(); }
			ptr<UI::Notifications::TileNotification> operator->() { return get(); }
			void put(pptr<UI::Notifications::TileNotification> value) { hrcheck(enc(&IBackgroundUploader2_adaptor::FailureTileNotification)->_put_FailureTileNotification(value)); }
			void operator=(pptr<UI::Notifications::TileNotification> value) { put(value); }
			void operator()(pptr<UI::Notifications::TileNotification> value) { put(value); }
		} FailureTileNotification;
		struct : property {
			ptr<UI::Notifications::ToastNotification> get() { UI::Notifications::ToastNotification* value; hrcheck(enc(&IBackgroundUploader2_adaptor::FailureToastNotification)->_get_FailureToastNotification(&value)); return from_abi(value); }
			ptr<UI::Notifications::ToastNotification> operator()() { return get(); }
			operator ptr<UI::Notifications::ToastNotification> () { return get(); }
			ptr<UI::Notifications::ToastNotification> operator->() { return get(); }
			void put(pptr<UI::Notifications::ToastNotification> value) { hrcheck(enc(&IBackgroundUploader2_adaptor::FailureToastNotification)->_put_FailureToastNotification(value)); }
			void operator=(pptr<UI::Notifications::ToastNotification> value) { put(value); }
			void operator()(pptr<UI::Notifications::ToastNotification> value) { put(value); }
		} FailureToastNotification;
		struct : property {
			ptr<UI::Notifications::TileNotification> get() { UI::Notifications::TileNotification* value; hrcheck(enc(&IBackgroundUploader2_adaptor::SuccessTileNotification)->_get_SuccessTileNotification(&value)); return from_abi(value); }
			ptr<UI::Notifications::TileNotification> operator()() { return get(); }
			operator ptr<UI::Notifications::TileNotification> () { return get(); }
			ptr<UI::Notifications::TileNotification> operator->() { return get(); }
			void put(pptr<UI::Notifications::TileNotification> value) { hrcheck(enc(&IBackgroundUploader2_adaptor::SuccessTileNotification)->_put_SuccessTileNotification(value)); }
			void operator=(pptr<UI::Notifications::TileNotification> value) { put(value); }
			void operator()(pptr<UI::Notifications::TileNotification> value) { put(value); }
		} SuccessTileNotification;
		struct : property {
			ptr<UI::Notifications::ToastNotification> get() { UI::Notifications::ToastNotification* value; hrcheck(enc(&IBackgroundUploader2_adaptor::SuccessToastNotification)->_get_SuccessToastNotification(&value)); return from_abi(value); }
			ptr<UI::Notifications::ToastNotification> operator()() { return get(); }
			operator ptr<UI::Notifications::ToastNotification> () { return get(); }
			ptr<UI::Notifications::ToastNotification> operator->() { return get(); }
			void put(pptr<UI::Notifications::ToastNotification> value) { hrcheck(enc(&IBackgroundUploader2_adaptor::SuccessToastNotification)->_put_SuccessToastNotification(value)); }
			void operator=(pptr<UI::Notifications::ToastNotification> value) { put(value); }
			void operator()(pptr<UI::Notifications::ToastNotification> value) { put(value); }
		} SuccessToastNotification;
		struct : property {
			ptr<BackgroundTransferGroup> get() { BackgroundTransferGroup* value; hrcheck(enc(&IBackgroundUploader2_adaptor::TransferGroup)->_get_TransferGroup(&value)); return from_abi(value); }
			ptr<BackgroundTransferGroup> operator()() { return get(); }
			operator ptr<BackgroundTransferGroup> () { return get(); }
			ptr<BackgroundTransferGroup> operator->() { return get(); }
			void put(pptr<BackgroundTransferGroup> value) { hrcheck(enc(&IBackgroundUploader2_adaptor::TransferGroup)->_put_TransferGroup(value)); }
			void operator=(pptr<BackgroundTransferGroup> value) { put(value); }
			void operator()(pptr<BackgroundTransferGroup> value) { put(value); }
		} TransferGroup;
	};
	IBackgroundUploader2_adaptor() {}
};
template<typename X> struct adapt<IBackgroundUploader2, X> : Windows::Networking::BackgroundTransfer::IBackgroundUploader2_adaptor<X> { typedef adapt IBackgroundUploader2; };
struct IBackgroundUploader2 : IBackgroundUploader2_raw, generate<IBackgroundUploader2> {};

// IBackgroundUploader3
struct IBackgroundUploader3_raw : IInspectable {
	virtual STDMETHODIMP _get_CompletionGroup(BackgroundTransferCompletionGroup* *value);
};
template<typename X> struct IBackgroundUploader3_adaptor : X {
	union {
		struct : property {
			ptr<BackgroundTransferCompletionGroup> get() { BackgroundTransferCompletionGroup* value; hrcheck(enc(&IBackgroundUploader3_adaptor::CompletionGroup)->_get_CompletionGroup(&value)); return from_abi(value); }
			ptr<BackgroundTransferCompletionGroup> operator()() { return get(); }
			operator ptr<BackgroundTransferCompletionGroup> () { return get(); }
			ptr<BackgroundTransferCompletionGroup> operator->() { return get(); }
		} CompletionGroup;
	};
	IBackgroundUploader3_adaptor() {}
};
template<typename X> struct adapt<IBackgroundUploader3, X> : Windows::Networking::BackgroundTransfer::IBackgroundUploader3_adaptor<X> { typedef adapt IBackgroundUploader3; };
struct IBackgroundUploader3 : IBackgroundUploader3_raw, generate<IBackgroundUploader3> {};

// IResponseInformation
struct IResponseInformation_raw : IInspectable {
	virtual STDMETHODIMP _get_IsResumable(bool *value);
	virtual STDMETHODIMP _get_ActualUri(Foundation::Uri* *value);
	virtual STDMETHODIMP _get_StatusCode(unsigned *value);
	virtual STDMETHODIMP _get_Headers(Foundation::Collections::IMapView<HSTRING, HSTRING>* *value);
};
template<typename X> struct IResponseInformation_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(enc(&IResponseInformation_adaptor::ActualUri)->_get_ActualUri(&value)); return from_abi(value); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} ActualUri;
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, hstring>> get() { Foundation::Collections::IMapView<HSTRING, HSTRING>* value; hrcheck(enc(&IResponseInformation_adaptor::Headers)->_get_Headers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMapView<hstring, hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, hstring>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, hstring>> operator->() { return get(); }
		} Headers;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IResponseInformation_adaptor::IsResumable)->_get_IsResumable(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsResumable;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IResponseInformation_adaptor::StatusCode)->_get_StatusCode(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} StatusCode;
	};
	IResponseInformation_adaptor() {}
};
template<typename X> struct adapt<IResponseInformation, X> : Windows::Networking::BackgroundTransfer::IResponseInformation_adaptor<X> { typedef adapt IResponseInformation; };
struct IResponseInformation : IResponseInformation_raw, generate<IResponseInformation> {};

// ResponseInformation
template<typename X> struct statics<ResponseInformation, X> : X {
	typedef typename X::root_type ResponseInformation;
};
struct ResponseInformation : generate<ResponseInformation> {};

// IBackgroundTransferRangesDownloadedEventArgs
struct IBackgroundTransferRangesDownloadedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_WasDownloadRestarted(bool *value);
	virtual STDMETHODIMP _get_AddedRanges(Foundation::Collections::IVector<BackgroundTransferFileRange>* *value);
	virtual STDMETHODIMP _GetDeferral(Foundation::Deferral* *result);
};
template<typename X> struct IBackgroundTransferRangesDownloadedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVector<BackgroundTransferFileRange>> get() { Foundation::Collections::IVector<BackgroundTransferFileRange>* value; hrcheck(enc(&IBackgroundTransferRangesDownloadedEventArgs_adaptor::AddedRanges)->_get_AddedRanges(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVector<BackgroundTransferFileRange>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVector<BackgroundTransferFileRange>> () { return get(); }
			ptr<Foundation::Collections::IVector<BackgroundTransferFileRange>> operator->() { return get(); }
		} AddedRanges;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IBackgroundTransferRangesDownloadedEventArgs_adaptor::WasDownloadRestarted)->_get_WasDownloadRestarted(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} WasDownloadRestarted;
	};
	ptr<Foundation::Deferral> GetDeferral() { Foundation::Deferral* result; hrcheck(X::get()->_GetDeferral(&result)); return from_abi(result); }
	IBackgroundTransferRangesDownloadedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IBackgroundTransferRangesDownloadedEventArgs, X> : Windows::Networking::BackgroundTransfer::IBackgroundTransferRangesDownloadedEventArgs_adaptor<X> { typedef adapt IBackgroundTransferRangesDownloadedEventArgs; };
struct IBackgroundTransferRangesDownloadedEventArgs : IBackgroundTransferRangesDownloadedEventArgs_raw, generate<IBackgroundTransferRangesDownloadedEventArgs> {};

// BackgroundTransferRangesDownloadedEventArgs
template<typename X> struct statics<BackgroundTransferRangesDownloadedEventArgs, X> : X {
	typedef typename X::root_type BackgroundTransferRangesDownloadedEventArgs;
};
struct BackgroundTransferRangesDownloadedEventArgs : generate<BackgroundTransferRangesDownloadedEventArgs> {};

// IBackgroundDownloaderFactory
struct IBackgroundDownloaderFactory : IInspectable {
	virtual STDMETHODIMP _CreateWithCompletionGroup(BackgroundTransferCompletionGroup* completionGroup, BackgroundDownloader* *backgroundDownloader);
};

// IBackgroundDownloaderStaticMethods2
struct IBackgroundDownloaderStaticMethods2 : IInspectable {
	virtual STDMETHODIMP _GetCurrentDownloadsForTransferGroupAsync(BackgroundTransferGroup* group, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<DownloadOperation*>*>* *operation);
};

// IBackgroundDownloaderStaticMethods
struct IBackgroundDownloaderStaticMethods : IInspectable {
	virtual STDMETHODIMP _GetCurrentDownloadsAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<DownloadOperation*>*>* *operation);
	virtual STDMETHODIMP _GetCurrentDownloadsForGroupAsync(HSTRING group, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<DownloadOperation*>*>* *operation);
};

// BackgroundDownloader
template<typename> struct BackgroundDownloader_statics {
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<DownloadOperation>>>>> GetCurrentDownloadsForTransferGroupAsync(pptr<BackgroundTransferGroup> group) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<DownloadOperation*>*>* operation; hrcheck(get_activation_factory<BackgroundDownloader, IBackgroundDownloaderStaticMethods2>()->_GetCurrentDownloadsForTransferGroupAsync(group, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<UnconstrainedTransferRequestResult>>> RequestUnconstrainedDownloadsAsync(pptr<Foundation::Collections::IIterable<ptr<DownloadOperation>>> operations) { Foundation::IAsyncOperation<UnconstrainedTransferRequestResult*>* operation; hrcheck(get_activation_factory<BackgroundDownloader, IBackgroundDownloaderUserConsent>()->_RequestUnconstrainedDownloadsAsync(to_abi(operations), &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<DownloadOperation>>>>> GetCurrentDownloadsAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<DownloadOperation*>*>* operation; hrcheck(get_activation_factory<BackgroundDownloader, IBackgroundDownloaderStaticMethods>()->_GetCurrentDownloadsAsync(&operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<DownloadOperation>>>>> GetCurrentDownloadsAsync(hstring_ref group) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<DownloadOperation*>*>* operation; hrcheck(get_activation_factory<BackgroundDownloader, IBackgroundDownloaderStaticMethods>()->_GetCurrentDownloadsForGroupAsync(group, &operation)); return from_abi(operation); }
	static BackgroundDownloader *activate(pptr<BackgroundTransferCompletionGroup> completionGroup) { BackgroundDownloader *backgroundDownloader; hrcheck(get_activation_factory<BackgroundDownloader, IBackgroundDownloaderFactory>()->_CreateWithCompletionGroup(completionGroup, &backgroundDownloader)); return backgroundDownloader; }
	static BackgroundDownloader *activate() { BackgroundDownloader *t; get_activation_factory<BackgroundDownloader>()->ActivateInstance((IInspectable**)&t); return t; }
};

template<typename X> struct statics<BackgroundDownloader, X> : X, Windows::Networking::BackgroundTransfer::BackgroundDownloader_statics<void> {
	using Windows::Networking::BackgroundTransfer::BackgroundDownloader_statics<void>::activate;
	typedef typename X::root_type BackgroundDownloader;
};
struct BackgroundDownloader : generate<BackgroundDownloader> {
	using IBackgroundDownloader::CreateDownload;
};

// IBackgroundUploaderFactory
struct IBackgroundUploaderFactory : IInspectable {
	virtual STDMETHODIMP _CreateWithCompletionGroup(BackgroundTransferCompletionGroup* completionGroup, BackgroundUploader* *backgroundUploader);
};

// IBackgroundUploaderStaticMethods2
struct IBackgroundUploaderStaticMethods2 : IInspectable {
	virtual STDMETHODIMP _GetCurrentUploadsForTransferGroupAsync(BackgroundTransferGroup* group, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<UploadOperation*>*>* *operation);
};

// IBackgroundUploaderStaticMethods
struct IBackgroundUploaderStaticMethods : IInspectable {
	virtual STDMETHODIMP _GetCurrentUploadsAsync(Foundation::IAsyncOperation<Foundation::Collections::IVectorView<UploadOperation*>*>* *operation);
	virtual STDMETHODIMP _GetCurrentUploadsForGroupAsync(HSTRING group, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<UploadOperation*>*>* *operation);
};

// BackgroundUploader
template<typename> struct BackgroundUploader_statics {
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<UploadOperation>>>>> GetCurrentUploadsForTransferGroupAsync(pptr<BackgroundTransferGroup> group) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<UploadOperation*>*>* operation; hrcheck(get_activation_factory<BackgroundUploader, IBackgroundUploaderStaticMethods2>()->_GetCurrentUploadsForTransferGroupAsync(group, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<UnconstrainedTransferRequestResult>>> RequestUnconstrainedUploadsAsync(pptr<Foundation::Collections::IIterable<ptr<UploadOperation>>> operations) { Foundation::IAsyncOperation<UnconstrainedTransferRequestResult*>* operation; hrcheck(get_activation_factory<BackgroundUploader, IBackgroundUploaderUserConsent>()->_RequestUnconstrainedUploadsAsync(to_abi(operations), &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<UploadOperation>>>>> GetCurrentUploadsAsync() { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<UploadOperation*>*>* operation; hrcheck(get_activation_factory<BackgroundUploader, IBackgroundUploaderStaticMethods>()->_GetCurrentUploadsAsync(&operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<UploadOperation>>>>> GetCurrentUploadsAsync(hstring_ref group) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<UploadOperation*>*>* operation; hrcheck(get_activation_factory<BackgroundUploader, IBackgroundUploaderStaticMethods>()->_GetCurrentUploadsForGroupAsync(group, &operation)); return from_abi(operation); }
	static BackgroundUploader *activate(pptr<BackgroundTransferCompletionGroup> completionGroup) { BackgroundUploader *backgroundUploader; hrcheck(get_activation_factory<BackgroundUploader, IBackgroundUploaderFactory>()->_CreateWithCompletionGroup(completionGroup, &backgroundUploader)); return backgroundUploader; }
	static BackgroundUploader *activate() { BackgroundUploader *t; get_activation_factory<BackgroundUploader>()->ActivateInstance((IInspectable**)&t); return t; }
};

template<typename X> struct statics<BackgroundUploader, X> : X, Windows::Networking::BackgroundTransfer::BackgroundUploader_statics<void> {
	using Windows::Networking::BackgroundTransfer::BackgroundUploader_statics<void>::activate;
	typedef typename X::root_type BackgroundUploader;
};
struct BackgroundUploader : generate<BackgroundUploader> {
	using IBackgroundUploader::CreateUploadAsync;
};

// IBackgroundTransferErrorStaticMethods
struct IBackgroundTransferErrorStaticMethods : IInspectable {
	virtual STDMETHODIMP _GetStatus(int hresult, Web::WebErrorStatus *status);
};

// IContentPrefetcherTime
struct IContentPrefetcherTime : IInspectable {
	virtual STDMETHODIMP _get_LastSuccessfulPrefetchTime(Foundation::IReference<Foundation::DateTime>* *value);
};

// IContentPrefetcher
struct IContentPrefetcher : IInspectable {
	virtual STDMETHODIMP _get_ContentUris(Foundation::Collections::IVector<Foundation::Uri*>* *value);
	virtual STDMETHODIMP _put_IndirectContentUri(Foundation::Uri* value);
	virtual STDMETHODIMP _get_IndirectContentUri(Foundation::Uri* *value);
};

// IBackgroundTransferCompletionGroupTriggerDetails
struct IBackgroundTransferCompletionGroupTriggerDetails_raw : IInspectable {
	virtual STDMETHODIMP _get_Downloads(Foundation::Collections::IVectorView<DownloadOperation*>* *value);
	virtual STDMETHODIMP _get_Uploads(Foundation::Collections::IVectorView<UploadOperation*>* *value);
};
template<typename X> struct IBackgroundTransferCompletionGroupTriggerDetails_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<DownloadOperation>>> get() { Foundation::Collections::IVectorView<DownloadOperation*>* value; hrcheck(enc(&IBackgroundTransferCompletionGroupTriggerDetails_adaptor::Downloads)->_get_Downloads(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<DownloadOperation>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<DownloadOperation>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<DownloadOperation>>> operator->() { return get(); }
		} Downloads;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<UploadOperation>>> get() { Foundation::Collections::IVectorView<UploadOperation*>* value; hrcheck(enc(&IBackgroundTransferCompletionGroupTriggerDetails_adaptor::Uploads)->_get_Uploads(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<UploadOperation>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<UploadOperation>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<UploadOperation>>> operator->() { return get(); }
		} Uploads;
	};
	IBackgroundTransferCompletionGroupTriggerDetails_adaptor() {}
};
template<typename X> struct adapt<IBackgroundTransferCompletionGroupTriggerDetails, X> : Windows::Networking::BackgroundTransfer::IBackgroundTransferCompletionGroupTriggerDetails_adaptor<X> { typedef adapt IBackgroundTransferCompletionGroupTriggerDetails; };
struct IBackgroundTransferCompletionGroupTriggerDetails : IBackgroundTransferCompletionGroupTriggerDetails_raw, generate<IBackgroundTransferCompletionGroupTriggerDetails> {};

// BackgroundTransferError
template<typename> struct BackgroundTransferError_statics {
	static Web::WebErrorStatus GetStatus(int hresult) { Web::WebErrorStatus status; hrcheck(get_activation_factory<BackgroundTransferError, IBackgroundTransferErrorStaticMethods>()->_GetStatus(hresult, &status)); return status; }
};

template<typename X> struct statics<BackgroundTransferError, X> : X, Windows::Networking::BackgroundTransfer::BackgroundTransferError_statics<void> {
	typedef typename X::root_type BackgroundTransferError;
};
struct BackgroundTransferError : generate<BackgroundTransferError> {};

// ContentPrefetcher
template<typename> struct ContentPrefetcher_statics {
	static struct _LastSuccessfulPrefetchTime : property {
		ptr<Foundation::IReference<Foundation::DateTime>> get() { Foundation::IReference<Foundation::DateTime>* value; hrcheck(get_activation_factory<ContentPrefetcher, IContentPrefetcherTime>()->_get_LastSuccessfulPrefetchTime(&value)); return from_abi(value); }
		ptr<Foundation::IReference<Foundation::DateTime>> operator()() { return get(); }
		operator ptr<Foundation::IReference<Foundation::DateTime>> () { return get(); }
		ptr<Foundation::IReference<Foundation::DateTime>> operator->() { return get(); }
	} LastSuccessfulPrefetchTime;
	static struct _ContentUris : property {
		ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> get() { Foundation::Collections::IVector<Foundation::Uri*>* value; hrcheck(get_activation_factory<ContentPrefetcher, IContentPrefetcher>()->_get_ContentUris(&value)); return from_abi(value); }
		ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> operator()() { return get(); }
		operator ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> () { return get(); }
		ptr<Foundation::Collections::IVector<ptr<Foundation::Uri>>> operator->() { return get(); }
	} ContentUris;
	static struct _IndirectContentUri : property {
		ptr<Foundation::Uri> get() { Foundation::Uri* value; hrcheck(get_activation_factory<ContentPrefetcher, IContentPrefetcher>()->_get_IndirectContentUri(&value)); return from_abi(value); }
		ptr<Foundation::Uri> operator()() { return get(); }
		operator ptr<Foundation::Uri> () { return get(); }
		ptr<Foundation::Uri> operator->() { return get(); }
		void put(pptr<Foundation::Uri> value) { hrcheck(get_activation_factory<ContentPrefetcher, IContentPrefetcher>()->_put_IndirectContentUri(value)); }
		void operator=(pptr<Foundation::Uri> value) { put(value); }
		void operator()(pptr<Foundation::Uri> value) { put(value); }
	} IndirectContentUri;
};
template<typename X> typename ContentPrefetcher_statics<X>::_LastSuccessfulPrefetchTime ContentPrefetcher_statics<X>::LastSuccessfulPrefetchTime;
template<typename X> typename ContentPrefetcher_statics<X>::_ContentUris ContentPrefetcher_statics<X>::ContentUris;
template<typename X> typename ContentPrefetcher_statics<X>::_IndirectContentUri ContentPrefetcher_statics<X>::IndirectContentUri;

template<typename X> struct statics<ContentPrefetcher, X> : X, Windows::Networking::BackgroundTransfer::ContentPrefetcher_statics<void> {
	typedef typename X::root_type ContentPrefetcher;
};
struct ContentPrefetcher : generate<ContentPrefetcher> {};

// BackgroundTransferCompletionGroupTriggerDetails
template<typename X> struct statics<BackgroundTransferCompletionGroupTriggerDetails, X> : X {
	typedef typename X::root_type BackgroundTransferCompletionGroupTriggerDetails;
};
struct BackgroundTransferCompletionGroupTriggerDetails : generate<BackgroundTransferCompletionGroupTriggerDetails> {};
}}}
} // namespace iso_winrt
