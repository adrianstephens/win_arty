#pragma once
// generated by isopod tools
// namespaces:
// Windows.Gaming.XboxLive.Storage

#include "Windows.Gaming.XboxLive.Storage.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
struct IPropertySet;
template<typename K, typename V> struct IMapView;
template<typename T> struct IVectorView;
template<typename T> struct IIterable;
}}
namespace Storage { namespace Streams {
struct IBuffer;
}}
namespace System {
struct User;
}}

// defs

template<> struct def<Windows::Gaming::XboxLive::Storage::GameSaveErrorStatus> : enum_type<int> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::IGameSaveProvider> : interface_type<> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::IGameSaveContainer> : interface_type<> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::GameSaveContainer> : class_type<Platform::Object, Windows::Gaming::XboxLive::Storage::IGameSaveContainer> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::IGameSaveOperationResult> : interface_type<> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::GameSaveOperationResult> : class_type<Platform::Object, Windows::Gaming::XboxLive::Storage::IGameSaveOperationResult> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::IGameSaveContainerInfoQuery> : interface_type<> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::GameSaveContainerInfoQuery> : class_type<Platform::Object, Windows::Gaming::XboxLive::Storage::IGameSaveContainerInfoQuery> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::IGameSaveProviderStatics> : interface_type<> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::IGameSaveProviderGetResult> : interface_type<> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::GameSaveProviderGetResult> : class_type<Platform::Object, Windows::Gaming::XboxLive::Storage::IGameSaveProviderGetResult> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::GameSaveProvider> : class_type<Platform::Object, Windows::Gaming::XboxLive::Storage::IGameSaveProvider> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::IGameSaveBlobGetResult> : interface_type<> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::GameSaveBlobGetResult> : class_type<Platform::Object, Windows::Gaming::XboxLive::Storage::IGameSaveBlobGetResult> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::IGameSaveBlobInfoQuery> : interface_type<> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::GameSaveBlobInfoQuery> : class_type<Platform::Object, Windows::Gaming::XboxLive::Storage::IGameSaveBlobInfoQuery> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::IGameSaveContainerInfo> : interface_type<> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::GameSaveContainerInfo> : class_type<Platform::Object, Windows::Gaming::XboxLive::Storage::IGameSaveContainerInfo> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::IGameSaveBlobInfo> : interface_type<> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::GameSaveBlobInfo> : class_type<Platform::Object, Windows::Gaming::XboxLive::Storage::IGameSaveBlobInfo> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::IGameSaveContainerInfoGetResult> : interface_type<> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::GameSaveContainerInfoGetResult> : class_type<Platform::Object, Windows::Gaming::XboxLive::Storage::IGameSaveContainerInfoGetResult> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::IGameSaveBlobInfoGetResult> : interface_type<> {};
template<> struct def<Windows::Gaming::XboxLive::Storage::GameSaveBlobInfoGetResult> : class_type<Platform::Object, Windows::Gaming::XboxLive::Storage::IGameSaveBlobInfoGetResult> {};

// uuids

template<> struct uuid<Windows::Gaming::XboxLive::Storage::IGameSaveProvider> { define_guid(0x90A60394, 0x80FE, 0x4211, 0x97, 0xF8, 0xA5, 0xDE, 0x14, 0xDD, 0x95, 0xD2);};
template<> struct uuid<Windows::Gaming::XboxLive::Storage::IGameSaveContainer> { define_guid(0xC3C08F89, 0x563F, 0x4ECD, 0x9C, 0x6F, 0x33, 0xFD, 0xE, 0x32, 0x3D, 0x10);};
template<> struct uuid<Windows::Gaming::XboxLive::Storage::IGameSaveOperationResult> { define_guid(0xCF0F1A05, 0x24A0, 0x4582, 0x9A, 0x55, 0xB1, 0xBB, 0xBB, 0x93, 0x88, 0xD8);};
template<> struct uuid<Windows::Gaming::XboxLive::Storage::IGameSaveContainerInfoQuery> { define_guid(0x3C94E863, 0x6F80, 0x4327, 0x93, 0x27, 0xFF, 0xC1, 0x1A, 0xFD, 0x42, 0xB3);};
template<> struct uuid<Windows::Gaming::XboxLive::Storage::IGameSaveProviderStatics> { define_guid(0xD01D3ED0, 0x7B03, 0x449D, 0x8C, 0xBD, 0x34, 0x2, 0x84, 0x2A, 0x10, 0x48);};
template<> struct uuid<Windows::Gaming::XboxLive::Storage::IGameSaveProviderGetResult> { define_guid(0x3AB90816, 0xD393, 0x4D65, 0xAC, 0x16, 0x41, 0xC3, 0xE6, 0x7A, 0xB9, 0x45);};
template<> struct uuid<Windows::Gaming::XboxLive::Storage::IGameSaveBlobGetResult> { define_guid(0x917281E0, 0x7201, 0x4953, 0xAA, 0x2C, 0x40, 0x8, 0xF0, 0x3A, 0xEF, 0x45);};
template<> struct uuid<Windows::Gaming::XboxLive::Storage::IGameSaveBlobInfoQuery> { define_guid(0x9FDD74B2, 0xEEEE, 0x447B, 0xA9, 0xD2, 0x7F, 0x96, 0xC0, 0xF8, 0x32, 0x8);};
template<> struct uuid<Windows::Gaming::XboxLive::Storage::IGameSaveContainerInfo> { define_guid(0xB7E27300, 0x155D, 0x4BB4, 0xB2, 0xBA, 0x93, 0x3, 0x6, 0xF3, 0x91, 0xB5);};
template<> struct uuid<Windows::Gaming::XboxLive::Storage::IGameSaveBlobInfo> { define_guid(0xADD38034, 0xBAF0, 0x4645, 0xB6, 0xD0, 0x46, 0xED, 0xAF, 0xFB, 0x3C, 0x2B);};
template<> struct uuid<Windows::Gaming::XboxLive::Storage::IGameSaveContainerInfoGetResult> { define_guid(0xFFC50D74, 0xC581, 0x4F9D, 0x9E, 0x39, 0x30, 0xA1, 0xC, 0x1E, 0x4C, 0x50);};
template<> struct uuid<Windows::Gaming::XboxLive::Storage::IGameSaveBlobInfoGetResult> { define_guid(0xC7578582, 0x3697, 0x42BF, 0x98, 0x9C, 0x66, 0x5D, 0x92, 0x3B, 0x52, 0x31);};

// types

namespace Windows { namespace Gaming { namespace XboxLive { namespace Storage {

// IGameSaveProvider
struct IGameSaveProvider_raw : IInspectable {
	virtual STDMETHODIMP _get_User(System::User* *value);
	virtual STDMETHODIMP _CreateContainer(HSTRING name, GameSaveContainer* *result);
	virtual STDMETHODIMP _DeleteContainerAsync(HSTRING name, Foundation::IAsyncOperation<GameSaveOperationResult*>* *action);
	virtual STDMETHODIMP _CreateContainerInfoQuery(GameSaveContainerInfoQuery* *query);
	virtual STDMETHODIMP _CreateContainerInfoQueryWithName(HSTRING containerNamePrefix, GameSaveContainerInfoQuery* *query);
	virtual STDMETHODIMP _GetRemainingBytesInQuotaAsync(Foundation::IAsyncOperation<__int64>* *operation);
	virtual STDMETHODIMP _get_ContainersChangedSinceLastSync(Foundation::Collections::IVectorView<HSTRING>* *value);
};
template<typename X> struct IGameSaveProvider_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&IGameSaveProvider_adaptor::ContainersChangedSinceLastSync)->_get_ContainersChangedSinceLastSync(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
		} ContainersChangedSinceLastSync;
		struct : property {
			ptr<System::User> get() { System::User* value; hrcheck(enc(&IGameSaveProvider_adaptor::User)->_get_User(&value)); return from_abi(value); }
			ptr<System::User> operator()() { return get(); }
			operator ptr<System::User> () { return get(); }
			ptr<System::User> operator->() { return get(); }
		} User;
	};
	ptr<GameSaveContainer> CreateContainer(hstring_ref name) { GameSaveContainer* result; hrcheck(X::get()->_CreateContainer(name, &result)); return from_abi(result); }
	ptr<Foundation::IAsyncOperation<ptr<GameSaveOperationResult>>> DeleteContainerAsync(hstring_ref name) { Foundation::IAsyncOperation<GameSaveOperationResult*>* action; hrcheck(X::get()->_DeleteContainerAsync(name, &action)); return from_abi(action); }
	ptr<GameSaveContainerInfoQuery> CreateContainerInfoQuery() { GameSaveContainerInfoQuery* query; hrcheck(X::get()->_CreateContainerInfoQuery(&query)); return from_abi(query); }
	ptr<GameSaveContainerInfoQuery> CreateContainerInfoQuery(hstring_ref containerNamePrefix) { GameSaveContainerInfoQuery* query; hrcheck(X::get()->_CreateContainerInfoQueryWithName(containerNamePrefix, &query)); return from_abi(query); }
	ptr<Foundation::IAsyncOperation<__int64>> GetRemainingBytesInQuotaAsync() { Foundation::IAsyncOperation<__int64>* operation; hrcheck(X::get()->_GetRemainingBytesInQuotaAsync(&operation)); return from_abi(operation); }
	IGameSaveProvider_adaptor() {}
};
template<typename X> struct adapt<IGameSaveProvider, X> : Windows::Gaming::XboxLive::Storage::IGameSaveProvider_adaptor<X> { typedef adapt IGameSaveProvider; };
struct IGameSaveProvider : IGameSaveProvider_raw, generate<IGameSaveProvider> {};

// IGameSaveContainer
struct IGameSaveContainer_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_Provider(GameSaveProvider* *value);
	virtual STDMETHODIMP _SubmitUpdatesAsync(Foundation::Collections::IMapView<HSTRING, Windows::Storage::Streams::IBuffer*>* blobsToWrite, Foundation::Collections::IIterable<HSTRING>* blobsToDelete, HSTRING displayName, Foundation::IAsyncOperation<GameSaveOperationResult*>* *operation);
	virtual STDMETHODIMP _ReadAsync(Foundation::Collections::IMapView<HSTRING, Windows::Storage::Streams::IBuffer*>* blobsToRead, Foundation::IAsyncOperation<GameSaveOperationResult*>* *action);
	virtual STDMETHODIMP _GetAsync(Foundation::Collections::IIterable<HSTRING>* blobsToRead, Foundation::IAsyncOperation<GameSaveBlobGetResult*>* *operation);
	virtual STDMETHODIMP _SubmitPropertySetUpdatesAsync(Foundation::Collections::IPropertySet* blobsToWrite, Foundation::Collections::IIterable<HSTRING>* blobsToDelete, HSTRING displayName, Foundation::IAsyncOperation<GameSaveOperationResult*>* *operation);
	virtual STDMETHODIMP _CreateBlobInfoQuery(HSTRING blobNamePrefix, GameSaveBlobInfoQuery* *query);
};
template<typename X> struct IGameSaveContainer_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGameSaveContainer_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			ptr<GameSaveProvider> get() { GameSaveProvider* value; hrcheck(enc(&IGameSaveContainer_adaptor::Provider)->_get_Provider(&value)); return from_abi(value); }
			ptr<GameSaveProvider> operator()() { return get(); }
			operator ptr<GameSaveProvider> () { return get(); }
			ptr<GameSaveProvider> operator->() { return get(); }
		} Provider;
	};
	ptr<Foundation::IAsyncOperation<ptr<GameSaveOperationResult>>> SubmitUpdatesAsync(pptr<Foundation::Collections::IMapView<hstring, ptr<Windows::Storage::Streams::IBuffer>>> blobsToWrite, pptr<Foundation::Collections::IIterable<hstring>> blobsToDelete, hstring_ref displayName) { Foundation::IAsyncOperation<GameSaveOperationResult*>* operation; hrcheck(X::get()->_SubmitUpdatesAsync(to_abi(blobsToWrite), to_abi(blobsToDelete), displayName, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<GameSaveOperationResult>>> ReadAsync(pptr<Foundation::Collections::IMapView<hstring, ptr<Windows::Storage::Streams::IBuffer>>> blobsToRead) { Foundation::IAsyncOperation<GameSaveOperationResult*>* action; hrcheck(X::get()->_ReadAsync(to_abi(blobsToRead), &action)); return from_abi(action); }
	ptr<Foundation::IAsyncOperation<ptr<GameSaveBlobGetResult>>> GetAsync(pptr<Foundation::Collections::IIterable<hstring>> blobsToRead) { Foundation::IAsyncOperation<GameSaveBlobGetResult*>* operation; hrcheck(X::get()->_GetAsync(to_abi(blobsToRead), &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<GameSaveOperationResult>>> SubmitPropertySetUpdatesAsync(pptr<Foundation::Collections::IPropertySet> blobsToWrite, pptr<Foundation::Collections::IIterable<hstring>> blobsToDelete, hstring_ref displayName) { Foundation::IAsyncOperation<GameSaveOperationResult*>* operation; hrcheck(X::get()->_SubmitPropertySetUpdatesAsync(blobsToWrite, to_abi(blobsToDelete), displayName, &operation)); return from_abi(operation); }
	ptr<GameSaveBlobInfoQuery> CreateBlobInfoQuery(hstring_ref blobNamePrefix) { GameSaveBlobInfoQuery* query; hrcheck(X::get()->_CreateBlobInfoQuery(blobNamePrefix, &query)); return from_abi(query); }
	IGameSaveContainer_adaptor() {}
};
template<typename X> struct adapt<IGameSaveContainer, X> : Windows::Gaming::XboxLive::Storage::IGameSaveContainer_adaptor<X> { typedef adapt IGameSaveContainer; };
struct IGameSaveContainer : IGameSaveContainer_raw, generate<IGameSaveContainer> {};

// GameSaveContainer
template<typename X> struct statics<GameSaveContainer, X> : X {
	typedef typename X::root_type GameSaveContainer;
};
struct GameSaveContainer : generate<GameSaveContainer> {};

// IGameSaveOperationResult
struct IGameSaveOperationResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(GameSaveErrorStatus *value);
};
template<typename X> struct IGameSaveOperationResult_adaptor : X {
	union {
		struct : property {
			GameSaveErrorStatus get() { GameSaveErrorStatus value; hrcheck(enc(&IGameSaveOperationResult_adaptor::Status)->_get_Status(&value)); return value; }
			GameSaveErrorStatus operator()() { return get(); }
			operator GameSaveErrorStatus () { return get(); }
		} Status;
	};
	IGameSaveOperationResult_adaptor() {}
};
template<typename X> struct adapt<IGameSaveOperationResult, X> : Windows::Gaming::XboxLive::Storage::IGameSaveOperationResult_adaptor<X> { typedef adapt IGameSaveOperationResult; };
struct IGameSaveOperationResult : IGameSaveOperationResult_raw, generate<IGameSaveOperationResult> {};

// GameSaveOperationResult
template<typename X> struct statics<GameSaveOperationResult, X> : X {
	typedef typename X::root_type GameSaveOperationResult;
};
struct GameSaveOperationResult : generate<GameSaveOperationResult> {};

// IGameSaveContainerInfoQuery
struct IGameSaveContainerInfoQuery_raw : IInspectable {
	virtual STDMETHODIMP _GetContainerInfoAsync(Foundation::IAsyncOperation<GameSaveContainerInfoGetResult*>* *operation);
	virtual STDMETHODIMP _GetContainerInfoWithIndexAndMaxAsync(unsigned startIndex, unsigned maxNumberOfItems, Foundation::IAsyncOperation<GameSaveContainerInfoGetResult*>* *operation);
	virtual STDMETHODIMP _GetItemCountAsync(Foundation::IAsyncOperation<unsigned>* *operation);
};
template<typename X> struct IGameSaveContainerInfoQuery_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<GameSaveContainerInfoGetResult>>> GetContainerInfoAsync() { Foundation::IAsyncOperation<GameSaveContainerInfoGetResult*>* operation; hrcheck(X::get()->_GetContainerInfoAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<GameSaveContainerInfoGetResult>>> GetContainerInfoAsync(unsigned startIndex, unsigned maxNumberOfItems) { Foundation::IAsyncOperation<GameSaveContainerInfoGetResult*>* operation; hrcheck(X::get()->_GetContainerInfoWithIndexAndMaxAsync(startIndex, maxNumberOfItems, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<unsigned>> GetItemCountAsync() { Foundation::IAsyncOperation<unsigned>* operation; hrcheck(X::get()->_GetItemCountAsync(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IGameSaveContainerInfoQuery, X> : Windows::Gaming::XboxLive::Storage::IGameSaveContainerInfoQuery_adaptor<X> { typedef adapt IGameSaveContainerInfoQuery; };
struct IGameSaveContainerInfoQuery : IGameSaveContainerInfoQuery_raw, generate<IGameSaveContainerInfoQuery> {};

// GameSaveContainerInfoQuery
template<typename X> struct statics<GameSaveContainerInfoQuery, X> : X {
	typedef typename X::root_type GameSaveContainerInfoQuery;
};
struct GameSaveContainerInfoQuery : generate<GameSaveContainerInfoQuery> {
	using IGameSaveContainerInfoQuery::GetContainerInfoAsync;
};

// IGameSaveProviderStatics
struct IGameSaveProviderStatics : IInspectable {
	virtual STDMETHODIMP _GetForUserAsync(System::User* user, HSTRING serviceConfigId, Foundation::IAsyncOperation<GameSaveProviderGetResult*>* *operation);
	virtual STDMETHODIMP _GetSyncOnDemandForUserAsync(System::User* user, HSTRING serviceConfigId, Foundation::IAsyncOperation<GameSaveProviderGetResult*>* *operation);
};

// IGameSaveProviderGetResult
struct IGameSaveProviderGetResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(GameSaveErrorStatus *value);
	virtual STDMETHODIMP _get_Value(GameSaveProvider* *value);
};
template<typename X> struct IGameSaveProviderGetResult_adaptor : X {
	union {
		struct : property {
			GameSaveErrorStatus get() { GameSaveErrorStatus value; hrcheck(enc(&IGameSaveProviderGetResult_adaptor::Status)->_get_Status(&value)); return value; }
			GameSaveErrorStatus operator()() { return get(); }
			operator GameSaveErrorStatus () { return get(); }
		} Status;
		struct : property {
			ptr<GameSaveProvider> get() { GameSaveProvider* value; hrcheck(enc(&IGameSaveProviderGetResult_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			ptr<GameSaveProvider> operator()() { return get(); }
			operator ptr<GameSaveProvider> () { return get(); }
			ptr<GameSaveProvider> operator->() { return get(); }
		} Value;
	};
	IGameSaveProviderGetResult_adaptor() {}
};
template<typename X> struct adapt<IGameSaveProviderGetResult, X> : Windows::Gaming::XboxLive::Storage::IGameSaveProviderGetResult_adaptor<X> { typedef adapt IGameSaveProviderGetResult; };
struct IGameSaveProviderGetResult : IGameSaveProviderGetResult_raw, generate<IGameSaveProviderGetResult> {};

// GameSaveProviderGetResult
template<typename X> struct statics<GameSaveProviderGetResult, X> : X {
	typedef typename X::root_type GameSaveProviderGetResult;
};
struct GameSaveProviderGetResult : generate<GameSaveProviderGetResult> {};

// GameSaveProvider
template<typename> struct GameSaveProvider_statics {
	static ptr<Foundation::IAsyncOperation<ptr<GameSaveProviderGetResult>>> GetForUserAsync(pptr<System::User> user, hstring_ref serviceConfigId) { Foundation::IAsyncOperation<GameSaveProviderGetResult*>* operation; hrcheck(get_activation_factory<GameSaveProvider, IGameSaveProviderStatics>()->_GetForUserAsync(user, serviceConfigId, &operation)); return from_abi(operation); }
	static ptr<Foundation::IAsyncOperation<ptr<GameSaveProviderGetResult>>> GetSyncOnDemandForUserAsync(pptr<System::User> user, hstring_ref serviceConfigId) { Foundation::IAsyncOperation<GameSaveProviderGetResult*>* operation; hrcheck(get_activation_factory<GameSaveProvider, IGameSaveProviderStatics>()->_GetSyncOnDemandForUserAsync(user, serviceConfigId, &operation)); return from_abi(operation); }
};

template<typename X> struct statics<GameSaveProvider, X> : X, Windows::Gaming::XboxLive::Storage::GameSaveProvider_statics<void> {
	typedef typename X::root_type GameSaveProvider;
};
struct GameSaveProvider : generate<GameSaveProvider> {
	using IGameSaveProvider::CreateContainerInfoQuery;
};

// IGameSaveBlobGetResult
struct IGameSaveBlobGetResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(GameSaveErrorStatus *value);
	virtual STDMETHODIMP _get_Value(Foundation::Collections::IMapView<HSTRING, Windows::Storage::Streams::IBuffer*>* *value);
};
template<typename X> struct IGameSaveBlobGetResult_adaptor : X {
	union {
		struct : property {
			GameSaveErrorStatus get() { GameSaveErrorStatus value; hrcheck(enc(&IGameSaveBlobGetResult_adaptor::Status)->_get_Status(&value)); return value; }
			GameSaveErrorStatus operator()() { return get(); }
			operator GameSaveErrorStatus () { return get(); }
		} Status;
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, ptr<Windows::Storage::Streams::IBuffer>>> get() { Foundation::Collections::IMapView<HSTRING, Windows::Storage::Streams::IBuffer*>* value; hrcheck(enc(&IGameSaveBlobGetResult_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<Windows::Storage::Streams::IBuffer>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, ptr<Windows::Storage::Streams::IBuffer>>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<Windows::Storage::Streams::IBuffer>>> operator->() { return get(); }
		} Value;
	};
	IGameSaveBlobGetResult_adaptor() {}
};
template<typename X> struct adapt<IGameSaveBlobGetResult, X> : Windows::Gaming::XboxLive::Storage::IGameSaveBlobGetResult_adaptor<X> { typedef adapt IGameSaveBlobGetResult; };
struct IGameSaveBlobGetResult : IGameSaveBlobGetResult_raw, generate<IGameSaveBlobGetResult> {};

// GameSaveBlobGetResult
template<typename X> struct statics<GameSaveBlobGetResult, X> : X {
	typedef typename X::root_type GameSaveBlobGetResult;
};
struct GameSaveBlobGetResult : generate<GameSaveBlobGetResult> {};

// IGameSaveBlobInfoQuery
struct IGameSaveBlobInfoQuery_raw : IInspectable {
	virtual STDMETHODIMP _GetBlobInfoAsync(Foundation::IAsyncOperation<GameSaveBlobInfoGetResult*>* *operation);
	virtual STDMETHODIMP _GetBlobInfoWithIndexAndMaxAsync(unsigned startIndex, unsigned maxNumberOfItems, Foundation::IAsyncOperation<GameSaveBlobInfoGetResult*>* *operation);
	virtual STDMETHODIMP _GetItemCountAsync(Foundation::IAsyncOperation<unsigned>* *operation);
};
template<typename X> struct IGameSaveBlobInfoQuery_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<GameSaveBlobInfoGetResult>>> GetBlobInfoAsync() { Foundation::IAsyncOperation<GameSaveBlobInfoGetResult*>* operation; hrcheck(X::get()->_GetBlobInfoAsync(&operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<ptr<GameSaveBlobInfoGetResult>>> GetBlobInfoAsync(unsigned startIndex, unsigned maxNumberOfItems) { Foundation::IAsyncOperation<GameSaveBlobInfoGetResult*>* operation; hrcheck(X::get()->_GetBlobInfoWithIndexAndMaxAsync(startIndex, maxNumberOfItems, &operation)); return from_abi(operation); }
	ptr<Foundation::IAsyncOperation<unsigned>> GetItemCountAsync() { Foundation::IAsyncOperation<unsigned>* operation; hrcheck(X::get()->_GetItemCountAsync(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IGameSaveBlobInfoQuery, X> : Windows::Gaming::XboxLive::Storage::IGameSaveBlobInfoQuery_adaptor<X> { typedef adapt IGameSaveBlobInfoQuery; };
struct IGameSaveBlobInfoQuery : IGameSaveBlobInfoQuery_raw, generate<IGameSaveBlobInfoQuery> {};

// GameSaveBlobInfoQuery
template<typename X> struct statics<GameSaveBlobInfoQuery, X> : X {
	typedef typename X::root_type GameSaveBlobInfoQuery;
};
struct GameSaveBlobInfoQuery : generate<GameSaveBlobInfoQuery> {
	using IGameSaveBlobInfoQuery::GetBlobInfoAsync;
};

// IGameSaveContainerInfo
struct IGameSaveContainerInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_TotalSize(unsigned __int64 *value);
	virtual STDMETHODIMP _get_DisplayName(HSTRING *value);
	virtual STDMETHODIMP _get_LastModifiedTime(Foundation::DateTime *value);
	virtual STDMETHODIMP _get_NeedsSync(bool *value);
};
template<typename X> struct IGameSaveContainerInfo_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGameSaveContainerInfo_adaptor::DisplayName)->_get_DisplayName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DisplayName;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IGameSaveContainerInfo_adaptor::LastModifiedTime)->_get_LastModifiedTime(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} LastModifiedTime;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGameSaveContainerInfo_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGameSaveContainerInfo_adaptor::NeedsSync)->_get_NeedsSync(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} NeedsSync;
		struct : property {
			unsigned __int64 get() { unsigned __int64 value; hrcheck(enc(&IGameSaveContainerInfo_adaptor::TotalSize)->_get_TotalSize(&value)); return value; }
			unsigned __int64 operator()() { return get(); }
			operator unsigned __int64 () { return get(); }
		} TotalSize;
	};
	IGameSaveContainerInfo_adaptor() {}
};
template<typename X> struct adapt<IGameSaveContainerInfo, X> : Windows::Gaming::XboxLive::Storage::IGameSaveContainerInfo_adaptor<X> { typedef adapt IGameSaveContainerInfo; };
struct IGameSaveContainerInfo : IGameSaveContainerInfo_raw, generate<IGameSaveContainerInfo> {};

// GameSaveContainerInfo
template<typename X> struct statics<GameSaveContainerInfo, X> : X {
	typedef typename X::root_type GameSaveContainerInfo;
};
struct GameSaveContainerInfo : generate<GameSaveContainerInfo> {};

// IGameSaveBlobInfo
struct IGameSaveBlobInfo_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_Size(unsigned *value);
};
template<typename X> struct IGameSaveBlobInfo_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IGameSaveBlobInfo_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IGameSaveBlobInfo_adaptor::Size)->_get_Size(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Size;
	};
	IGameSaveBlobInfo_adaptor() {}
};
template<typename X> struct adapt<IGameSaveBlobInfo, X> : Windows::Gaming::XboxLive::Storage::IGameSaveBlobInfo_adaptor<X> { typedef adapt IGameSaveBlobInfo; };
struct IGameSaveBlobInfo : IGameSaveBlobInfo_raw, generate<IGameSaveBlobInfo> {};

// GameSaveBlobInfo
template<typename X> struct statics<GameSaveBlobInfo, X> : X {
	typedef typename X::root_type GameSaveBlobInfo;
};
struct GameSaveBlobInfo : generate<GameSaveBlobInfo> {};

// IGameSaveContainerInfoGetResult
struct IGameSaveContainerInfoGetResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(GameSaveErrorStatus *value);
	virtual STDMETHODIMP _get_Value(Foundation::Collections::IVectorView<GameSaveContainerInfo*>* *value);
};
template<typename X> struct IGameSaveContainerInfoGetResult_adaptor : X {
	union {
		struct : property {
			GameSaveErrorStatus get() { GameSaveErrorStatus value; hrcheck(enc(&IGameSaveContainerInfoGetResult_adaptor::Status)->_get_Status(&value)); return value; }
			GameSaveErrorStatus operator()() { return get(); }
			operator GameSaveErrorStatus () { return get(); }
		} Status;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<GameSaveContainerInfo>>> get() { Foundation::Collections::IVectorView<GameSaveContainerInfo*>* value; hrcheck(enc(&IGameSaveContainerInfoGetResult_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<GameSaveContainerInfo>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<GameSaveContainerInfo>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<GameSaveContainerInfo>>> operator->() { return get(); }
		} Value;
	};
	IGameSaveContainerInfoGetResult_adaptor() {}
};
template<typename X> struct adapt<IGameSaveContainerInfoGetResult, X> : Windows::Gaming::XboxLive::Storage::IGameSaveContainerInfoGetResult_adaptor<X> { typedef adapt IGameSaveContainerInfoGetResult; };
struct IGameSaveContainerInfoGetResult : IGameSaveContainerInfoGetResult_raw, generate<IGameSaveContainerInfoGetResult> {};

// GameSaveContainerInfoGetResult
template<typename X> struct statics<GameSaveContainerInfoGetResult, X> : X {
	typedef typename X::root_type GameSaveContainerInfoGetResult;
};
struct GameSaveContainerInfoGetResult : generate<GameSaveContainerInfoGetResult> {};

// IGameSaveBlobInfoGetResult
struct IGameSaveBlobInfoGetResult_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(GameSaveErrorStatus *value);
	virtual STDMETHODIMP _get_Value(Foundation::Collections::IVectorView<GameSaveBlobInfo*>* *value);
};
template<typename X> struct IGameSaveBlobInfoGetResult_adaptor : X {
	union {
		struct : property {
			GameSaveErrorStatus get() { GameSaveErrorStatus value; hrcheck(enc(&IGameSaveBlobInfoGetResult_adaptor::Status)->_get_Status(&value)); return value; }
			GameSaveErrorStatus operator()() { return get(); }
			operator GameSaveErrorStatus () { return get(); }
		} Status;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<GameSaveBlobInfo>>> get() { Foundation::Collections::IVectorView<GameSaveBlobInfo*>* value; hrcheck(enc(&IGameSaveBlobInfoGetResult_adaptor::Value)->_get_Value(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<GameSaveBlobInfo>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<GameSaveBlobInfo>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<GameSaveBlobInfo>>> operator->() { return get(); }
		} Value;
	};
	IGameSaveBlobInfoGetResult_adaptor() {}
};
template<typename X> struct adapt<IGameSaveBlobInfoGetResult, X> : Windows::Gaming::XboxLive::Storage::IGameSaveBlobInfoGetResult_adaptor<X> { typedef adapt IGameSaveBlobInfoGetResult; };
struct IGameSaveBlobInfoGetResult : IGameSaveBlobInfoGetResult_raw, generate<IGameSaveBlobInfoGetResult> {};

// GameSaveBlobInfoGetResult
template<typename X> struct statics<GameSaveBlobInfoGetResult, X> : X {
	typedef typename X::root_type GameSaveBlobInfoGetResult;
};
struct GameSaveBlobInfoGetResult : generate<GameSaveBlobInfoGetResult> {};
}}}}
} // namespace iso_winrt
