#pragma once
// generated by isopod tools
// namespaces:
// Windows.ApplicationModel.Resources.Core

#include "Windows.ApplicationModel.Resources.Core.0.h"
#include "Windows.Foundation.0.h"
#include "Windows.Foundation.Collections.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Storage { namespace Streams {
struct IRandomAccessStream;
}
struct IStorageFile;
struct StorageFile;
}}

// defs

template<> struct def<Windows::ApplicationModel::Resources::Core::ResourceLayoutInfo> : value_type<unsigned, unsigned, unsigned, unsigned, int> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::IResourceManager> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::INamedResource> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::NamedResource> : class_type<Platform::Object, Windows::ApplicationModel::Resources::Core::INamedResource> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::IResourceMap> : interface_type<Windows::Foundation::Collections::IMapView<HSTRING, ptr<Windows::ApplicationModel::Resources::Core::NamedResource>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, ptr<Windows::ApplicationModel::Resources::Core::NamedResource>>>>> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::ResourceMap> : class_type<Platform::Object, Windows::ApplicationModel::Resources::Core::IResourceMap> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::ResourceQualifierPersistence> : enum_type<int> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::IResourceContextStatics3> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::IResourceContextStatics2> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::IResourceContextStatics> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::IResourceContext> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::ResourceContext> : class_type<Platform::Object, Windows::ApplicationModel::Resources::Core::IResourceContext> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::IResourceManager2> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::IResourceManagerStatics> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::ResourceManager> : class_type<Platform::Object, Windows::ApplicationModel::Resources::Core::IResourceManager, Windows::ApplicationModel::Resources::Core::IResourceManager2> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::IResourceQualifier> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::ResourceQualifier> : class_type<Platform::Object, Windows::ApplicationModel::Resources::Core::IResourceQualifier> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::IResourceCandidate> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::IResourceCandidate2> : interface_type<> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::ResourceCandidate> : class_type<Platform::Object, Windows::ApplicationModel::Resources::Core::IResourceCandidate, Windows::ApplicationModel::Resources::Core::IResourceCandidate2> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::ResourceMapIterator> : class_type<Platform::Object, Windows::Foundation::Collections::IIterator<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, ptr<Windows::ApplicationModel::Resources::Core::NamedResource>>>>> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::ResourceMapMapView> : class_type<Platform::Object, Windows::Foundation::Collections::IMapView<HSTRING, ptr<Windows::ApplicationModel::Resources::Core::ResourceMap>>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, ptr<Windows::ApplicationModel::Resources::Core::ResourceMap>>>>> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::ResourceMapMapViewIterator> : class_type<Platform::Object, Windows::Foundation::Collections::IIterator<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, ptr<Windows::ApplicationModel::Resources::Core::ResourceMap>>>>> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::ResourceQualifierObservableMap> : class_type<Platform::Object, Windows::Foundation::Collections::IObservableMap<HSTRING, HSTRING>, Windows::Foundation::Collections::IMap<HSTRING, HSTRING>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, HSTRING>>>> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::ResourceQualifierMapView> : class_type<Platform::Object, Windows::Foundation::Collections::IMapView<HSTRING, HSTRING>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, HSTRING>>>> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::ResourceQualifierVectorView> : class_type<Platform::Object, Windows::Foundation::Collections::IVectorView<ptr<Windows::ApplicationModel::Resources::Core::ResourceQualifier>>, Windows::Foundation::Collections::IIterable<ptr<Windows::ApplicationModel::Resources::Core::ResourceQualifier>>> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::ResourceCandidateVectorView> : class_type<Platform::Object, Windows::Foundation::Collections::IVectorView<ptr<Windows::ApplicationModel::Resources::Core::ResourceCandidate>>, Windows::Foundation::Collections::IIterable<ptr<Windows::ApplicationModel::Resources::Core::ResourceCandidate>>> {};
template<> struct def<Windows::ApplicationModel::Resources::Core::ResourceContextLanguagesVectorView> : class_type<Platform::Object, Windows::Foundation::Collections::IVectorView<HSTRING>, Windows::Foundation::Collections::IIterable<HSTRING>> {};

// uuids

template<> struct uuid<Windows::ApplicationModel::Resources::Core::IResourceManager> { define_guid(0xF744D97B, 0x9988, 0x44FB, 0xAB, 0xD6, 0x53, 0x78, 0x84, 0x4C, 0xFA, 0x8B);};
template<> struct uuid<Windows::ApplicationModel::Resources::Core::INamedResource> { define_guid(0x1C98C219, 0xB13, 0x4240, 0x89, 0xA5, 0xD4, 0x95, 0xDC, 0x18, 0x9A, 0x0);};
template<> struct uuid<Windows::ApplicationModel::Resources::Core::IResourceMap> { define_guid(0x72284824, 0xDB8C, 0x42F8, 0xB0, 0x8C, 0x53, 0xFF, 0x35, 0x7D, 0xAD, 0x82);};
template<> struct uuid<Windows::ApplicationModel::Resources::Core::IResourceContextStatics3> { define_guid(0x20CF492C, 0xAF0F, 0x450B, 0x9D, 0xA6, 0x10, 0x6D, 0xD0, 0xC2, 0x9A, 0x39);};
template<> struct uuid<Windows::ApplicationModel::Resources::Core::IResourceContextStatics2> { define_guid(0x41F752EF, 0x12AF, 0x41B9, 0xAB, 0x36, 0xB1, 0xEB, 0x4B, 0x51, 0x24, 0x60);};
template<> struct uuid<Windows::ApplicationModel::Resources::Core::IResourceContextStatics> { define_guid(0x98BE9D6C, 0x6338, 0x4B31, 0x99, 0xDF, 0xB2, 0xB4, 0x42, 0xF1, 0x71, 0x49);};
template<> struct uuid<Windows::ApplicationModel::Resources::Core::IResourceContext> { define_guid(0x2FA22F4B, 0x707E, 0x4B27, 0xAD, 0xD, 0xD0, 0xD8, 0xCD, 0x46, 0x8F, 0xD2);};
template<> struct uuid<Windows::ApplicationModel::Resources::Core::IResourceManager2> { define_guid(0x9D66FE6C, 0xA4D7, 0x4C23, 0x9E, 0x85, 0x67, 0x5F, 0x30, 0x4C, 0x25, 0x2D);};
template<> struct uuid<Windows::ApplicationModel::Resources::Core::IResourceManagerStatics> { define_guid(0x1CC0FDFC, 0x69EE, 0x4E43, 0x99, 0x1, 0x47, 0xF1, 0x26, 0x87, 0xBA, 0xF7);};
template<> struct uuid<Windows::ApplicationModel::Resources::Core::IResourceQualifier> { define_guid(0x785DA5B2, 0x4AFD, 0x4376, 0xA8, 0x88, 0xC5, 0xF9, 0xA6, 0xB7, 0xA0, 0x5C);};
template<> struct uuid<Windows::ApplicationModel::Resources::Core::IResourceCandidate> { define_guid(0xAF5207D9, 0xC433, 0x4764, 0xB3, 0xFD, 0x8F, 0xA6, 0xBF, 0xBC, 0xBA, 0xDC);};
template<> struct uuid<Windows::ApplicationModel::Resources::Core::IResourceCandidate2> { define_guid(0x69E5B468, 0xF6FC, 0x4013, 0xAA, 0xA2, 0xD5, 0x3F, 0x17, 0x57, 0xD3, 0xB5);};

// types

namespace Windows { namespace ApplicationModel { namespace Resources { namespace Core {

// IResourceManager
struct IResourceManager_raw : IInspectable {
	virtual STDMETHODIMP _get_MainResourceMap(ResourceMap* *value);
	virtual STDMETHODIMP _get_AllResourceMaps(Foundation::Collections::IMapView<HSTRING, ResourceMap*>* *maps);
	virtual STDMETHODIMP _get_DefaultContext(ResourceContext* *value);
	virtual STDMETHODIMP _LoadPriFiles(Foundation::Collections::IIterable<Storage::IStorageFile*>* files);
	virtual STDMETHODIMP _UnloadPriFiles(Foundation::Collections::IIterable<Storage::IStorageFile*>* files);
};
template<typename X> struct IResourceManager_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, ptr<ResourceMap>>> get() { Foundation::Collections::IMapView<HSTRING, ResourceMap*>* maps; hrcheck(enc(&IResourceManager_adaptor::AllResourceMaps)->_get_AllResourceMaps(&maps)); return from_abi(maps); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<ResourceMap>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, ptr<ResourceMap>>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, ptr<ResourceMap>>> operator->() { return get(); }
		} AllResourceMaps;
		struct : property {
			ptr<ResourceContext> get() { ResourceContext* value; hrcheck(enc(&IResourceManager_adaptor::DefaultContext)->_get_DefaultContext(&value)); return from_abi(value); }
			ptr<ResourceContext> operator()() { return get(); }
			operator ptr<ResourceContext> () { return get(); }
			ptr<ResourceContext> operator->() { return get(); }
		} DefaultContext;
		struct : property {
			ptr<ResourceMap> get() { ResourceMap* value; hrcheck(enc(&IResourceManager_adaptor::MainResourceMap)->_get_MainResourceMap(&value)); return from_abi(value); }
			ptr<ResourceMap> operator()() { return get(); }
			operator ptr<ResourceMap> () { return get(); }
			ptr<ResourceMap> operator->() { return get(); }
		} MainResourceMap;
	};
	void LoadPriFiles(pptr<Foundation::Collections::IIterable<ptr<Storage::IStorageFile>>> files) { hrcheck(X::get()->_LoadPriFiles(to_abi(files))); }
	void UnloadPriFiles(pptr<Foundation::Collections::IIterable<ptr<Storage::IStorageFile>>> files) { hrcheck(X::get()->_UnloadPriFiles(to_abi(files))); }
	IResourceManager_adaptor() {}
};
template<typename X> struct adapt<IResourceManager, X> : Windows::ApplicationModel::Resources::Core::IResourceManager_adaptor<X> { typedef adapt IResourceManager; };
struct IResourceManager : IResourceManager_raw, generate<IResourceManager> {};

// INamedResource
struct INamedResource_raw : IInspectable {
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *uri);
	virtual STDMETHODIMP _get_Candidates(Foundation::Collections::IVectorView<ResourceCandidate*>* *value);
	virtual STDMETHODIMP _Resolve(ResourceCandidate* *result);
	virtual STDMETHODIMP _ResolveForContext(ResourceContext* resourceContext, ResourceCandidate* *result);
	virtual STDMETHODIMP _ResolveAll(Foundation::Collections::IVectorView<ResourceCandidate*>* *result);
	virtual STDMETHODIMP _ResolveAllForContext(ResourceContext* resourceContext, Foundation::Collections::IVectorView<ResourceCandidate*>* *instances);
};
template<typename X> struct INamedResource_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<ResourceCandidate>>> get() { Foundation::Collections::IVectorView<ResourceCandidate*>* value; hrcheck(enc(&INamedResource_adaptor::Candidates)->_get_Candidates(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<ResourceCandidate>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<ResourceCandidate>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<ResourceCandidate>>> operator->() { return get(); }
		} Candidates;
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* uri; hrcheck(enc(&INamedResource_adaptor::Uri)->_get_Uri(&uri)); return from_abi(uri); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
	};
	ptr<ResourceCandidate> Resolve() { ResourceCandidate* result; hrcheck(X::get()->_Resolve(&result)); return from_abi(result); }
	ptr<ResourceCandidate> Resolve(pptr<ResourceContext> resourceContext) { ResourceCandidate* result; hrcheck(X::get()->_ResolveForContext(resourceContext, &result)); return from_abi(result); }
	ptr<Foundation::Collections::IVectorView<ptr<ResourceCandidate>>> ResolveAll() { Foundation::Collections::IVectorView<ResourceCandidate*>* result; hrcheck(X::get()->_ResolveAll(&result)); return from_abi(result); }
	ptr<Foundation::Collections::IVectorView<ptr<ResourceCandidate>>> ResolveAll(pptr<ResourceContext> resourceContext) { Foundation::Collections::IVectorView<ResourceCandidate*>* instances; hrcheck(X::get()->_ResolveAllForContext(resourceContext, &instances)); return from_abi(instances); }
	INamedResource_adaptor() {}
};
template<typename X> struct adapt<INamedResource, X> : Windows::ApplicationModel::Resources::Core::INamedResource_adaptor<X> { typedef adapt INamedResource; };
struct INamedResource : INamedResource_raw, generate<INamedResource> {};

// NamedResource
template<typename X> struct statics<NamedResource, X> : X {
	typedef typename X::root_type NamedResource;
};
struct NamedResource : generate<NamedResource> {
	using INamedResource::ResolveAll;
	using INamedResource::Resolve;
};

// IResourceMap
struct IResourceMap_raw : IInspectable {
	virtual STDMETHODIMP _get_Uri(Foundation::Uri* *uri);
	virtual STDMETHODIMP _GetValue(HSTRING resource, ResourceCandidate* *value);
	virtual STDMETHODIMP _GetValueForContext(HSTRING resource, ResourceContext* context, ResourceCandidate* *value);
	virtual STDMETHODIMP _GetSubtree(HSTRING reference, ResourceMap* *map);
};
template<typename X> struct IResourceMap_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Uri> get() { Foundation::Uri* uri; hrcheck(enc(&IResourceMap_adaptor::Uri)->_get_Uri(&uri)); return from_abi(uri); }
			ptr<Foundation::Uri> operator()() { return get(); }
			operator ptr<Foundation::Uri> () { return get(); }
			ptr<Foundation::Uri> operator->() { return get(); }
		} Uri;
	};
	ptr<ResourceCandidate> GetValue(hstring_ref resource) { ResourceCandidate* value; hrcheck(X::get()->_GetValue(resource, &value)); return from_abi(value); }
	ptr<ResourceCandidate> GetValue(hstring_ref resource, pptr<ResourceContext> context) { ResourceCandidate* value; hrcheck(X::get()->_GetValueForContext(resource, context, &value)); return from_abi(value); }
	ptr<ResourceMap> GetSubtree(hstring_ref reference) { ResourceMap* map; hrcheck(X::get()->_GetSubtree(reference, &map)); return from_abi(map); }
	IResourceMap_adaptor() {}
};
template<typename X> struct adapt<IResourceMap, X> : Windows::ApplicationModel::Resources::Core::IResourceMap_adaptor<X> { typedef adapt IResourceMap; };
struct IResourceMap : IResourceMap_raw, generate<IResourceMap> {};

// ResourceMap
template<typename X> struct statics<ResourceMap, X> : X {
	typedef typename X::root_type ResourceMap;
};
struct ResourceMap : generate<ResourceMap> {
	using IResourceMap::GetValue;
};

// IResourceContextStatics3
struct IResourceContextStatics3 : IInspectable {
	virtual STDMETHODIMP _SetGlobalQualifierValueWithPersistence(HSTRING key, HSTRING value, ResourceQualifierPersistence persistence);
};

// IResourceContextStatics2
struct IResourceContextStatics2 : IInspectable {
	virtual STDMETHODIMP _GetForCurrentView(ResourceContext* *value);
	virtual STDMETHODIMP _SetGlobalQualifierValue(HSTRING key, HSTRING value);
	virtual STDMETHODIMP _ResetGlobalQualifierValues();
	virtual STDMETHODIMP _ResetGlobalQualifierValuesForSpecifiedQualifiers(Foundation::Collections::IIterable<HSTRING>* qualifierNames);
	virtual STDMETHODIMP _GetForViewIndependentUse(ResourceContext* *loader);
};

// IResourceContextStatics
struct IResourceContextStatics : IInspectable {
	virtual STDMETHODIMP _CreateMatchingContext(Foundation::Collections::IIterable<ResourceQualifier*>* result, ResourceContext* *value);
};

// IResourceContext
struct IResourceContext_raw : IInspectable {
	virtual STDMETHODIMP _get_QualifierValues(Foundation::Collections::IObservableMap<HSTRING, HSTRING>* *value);
	virtual STDMETHODIMP _Reset();
	virtual STDMETHODIMP _ResetQualifierValues(Foundation::Collections::IIterable<HSTRING>* qualifierNames);
	virtual STDMETHODIMP _OverrideToMatch(Foundation::Collections::IIterable<ResourceQualifier*>* result);
	virtual STDMETHODIMP _Clone(ResourceContext* *clone);
	virtual STDMETHODIMP _get_Languages(Foundation::Collections::IVectorView<HSTRING>* *value);
	virtual STDMETHODIMP _put_Languages(Foundation::Collections::IVectorView<HSTRING>* languages);
};
template<typename X> struct IResourceContext_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<hstring>> get() { Foundation::Collections::IVectorView<HSTRING>* value; hrcheck(enc(&IResourceContext_adaptor::Languages)->_get_Languages(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<hstring>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<hstring>> operator->() { return get(); }
			void put(pptr<Foundation::Collections::IVectorView<hstring>> languages) { hrcheck(enc(&IResourceContext_adaptor::Languages)->_put_Languages(to_abi(languages))); }
			void operator=(pptr<Foundation::Collections::IVectorView<hstring>> languages) { put(to_abi(languages)); }
			void operator()(pptr<Foundation::Collections::IVectorView<hstring>> languages) { put(to_abi(languages)); }
		} Languages;
		struct : property {
			ptr<Foundation::Collections::IObservableMap<hstring, hstring>> get() { Foundation::Collections::IObservableMap<HSTRING, HSTRING>* value; hrcheck(enc(&IResourceContext_adaptor::QualifierValues)->_get_QualifierValues(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IObservableMap<hstring, hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IObservableMap<hstring, hstring>> () { return get(); }
			ptr<Foundation::Collections::IObservableMap<hstring, hstring>> operator->() { return get(); }
		} QualifierValues;
	};
	void Reset() { hrcheck(X::get()->_Reset()); }
	void Reset(pptr<Foundation::Collections::IIterable<hstring>> qualifierNames) { hrcheck(X::get()->_ResetQualifierValues(to_abi(qualifierNames))); }
	void OverrideToMatch(pptr<Foundation::Collections::IIterable<ptr<ResourceQualifier>>> result) { hrcheck(X::get()->_OverrideToMatch(to_abi(result))); }
	ptr<ResourceContext> Clone() { ResourceContext* clone; hrcheck(X::get()->_Clone(&clone)); return from_abi(clone); }
	IResourceContext_adaptor() {}
};
template<typename X> struct adapt<IResourceContext, X> : Windows::ApplicationModel::Resources::Core::IResourceContext_adaptor<X> { typedef adapt IResourceContext; };
struct IResourceContext : IResourceContext_raw, generate<IResourceContext> {};

// ResourceContext
template<typename> struct ResourceContext_statics {
	static void SetGlobalQualifierValue(hstring_ref key, hstring_ref value, ResourceQualifierPersistence persistence) { hrcheck(get_activation_factory<ResourceContext, IResourceContextStatics3>()->_SetGlobalQualifierValueWithPersistence(key, value, persistence)); }
	static ptr<ResourceContext> GetForCurrentView() { ResourceContext* value; hrcheck(get_activation_factory<ResourceContext, IResourceContextStatics2>()->_GetForCurrentView(&value)); return from_abi(value); }
	static void SetGlobalQualifierValue(hstring_ref key, hstring_ref value) { hrcheck(get_activation_factory<ResourceContext, IResourceContextStatics2>()->_SetGlobalQualifierValue(key, value)); }
	static void ResetGlobalQualifierValues() { hrcheck(get_activation_factory<ResourceContext, IResourceContextStatics2>()->_ResetGlobalQualifierValues()); }
	static void ResetGlobalQualifierValues(pptr<Foundation::Collections::IIterable<hstring>> qualifierNames) { hrcheck(get_activation_factory<ResourceContext, IResourceContextStatics2>()->_ResetGlobalQualifierValuesForSpecifiedQualifiers(to_abi(qualifierNames))); }
	static ptr<ResourceContext> GetForViewIndependentUse() { ResourceContext* loader; hrcheck(get_activation_factory<ResourceContext, IResourceContextStatics2>()->_GetForViewIndependentUse(&loader)); return from_abi(loader); }
	static ptr<ResourceContext> CreateMatchingContext(pptr<Foundation::Collections::IIterable<ptr<ResourceQualifier>>> result) { ResourceContext* value; hrcheck(get_activation_factory<ResourceContext, IResourceContextStatics>()->_CreateMatchingContext(to_abi(result), &value)); return from_abi(value); }
};

template<typename X> struct statics<ResourceContext, X> : X, Windows::ApplicationModel::Resources::Core::ResourceContext_statics<void> {
	typedef typename X::root_type ResourceContext;
};
struct ResourceContext : generate<ResourceContext> {
	using IResourceContext::Reset;
};

// IResourceManager2
struct IResourceManager2_raw : IInspectable {
	virtual STDMETHODIMP _GetAllNamedResourcesForPackage(HSTRING packageName, ResourceLayoutInfo resourceLayoutInfo, Foundation::Collections::IVectorView<NamedResource*>* *table);
	virtual STDMETHODIMP _GetAllSubtreesForPackage(HSTRING packageName, ResourceLayoutInfo resourceLayoutInfo, Foundation::Collections::IVectorView<ResourceMap*>* *table);
};
template<typename X> struct IResourceManager2_adaptor : X {
	ptr<Foundation::Collections::IVectorView<ptr<NamedResource>>> GetAllNamedResourcesForPackage(hstring_ref packageName, const ResourceLayoutInfo& resourceLayoutInfo) { Foundation::Collections::IVectorView<NamedResource*>* table; hrcheck(X::get()->_GetAllNamedResourcesForPackage(packageName, resourceLayoutInfo, &table)); return from_abi(table); }
	ptr<Foundation::Collections::IVectorView<ptr<ResourceMap>>> GetAllSubtreesForPackage(hstring_ref packageName, const ResourceLayoutInfo& resourceLayoutInfo) { Foundation::Collections::IVectorView<ResourceMap*>* table; hrcheck(X::get()->_GetAllSubtreesForPackage(packageName, resourceLayoutInfo, &table)); return from_abi(table); }
};
template<typename X> struct adapt<IResourceManager2, X> : Windows::ApplicationModel::Resources::Core::IResourceManager2_adaptor<X> { typedef adapt IResourceManager2; };
struct IResourceManager2 : IResourceManager2_raw, generate<IResourceManager2> {};

// IResourceManagerStatics
struct IResourceManagerStatics : IInspectable {
	virtual STDMETHODIMP _get_Current(ResourceManager* *value);
	virtual STDMETHODIMP _IsResourceReference(HSTRING resourceReference, bool *isReference);
};

// ResourceManager
template<typename> struct ResourceManager_statics {
	static struct _Current : property {
		ptr<ResourceManager> get() { ResourceManager* value; hrcheck(get_activation_factory<ResourceManager, IResourceManagerStatics>()->_get_Current(&value)); return from_abi(value); }
		ptr<ResourceManager> operator()() { return get(); }
		operator ptr<ResourceManager> () { return get(); }
		ptr<ResourceManager> operator->() { return get(); }
	} Current;
	static bool IsResourceReference(hstring_ref resourceReference) { bool isReference; hrcheck(get_activation_factory<ResourceManager, IResourceManagerStatics>()->_IsResourceReference(resourceReference, &isReference)); return isReference; }
};
template<typename X> typename ResourceManager_statics<X>::_Current ResourceManager_statics<X>::Current;

template<typename X> struct statics<ResourceManager, X> : X, Windows::ApplicationModel::Resources::Core::ResourceManager_statics<void> {
	typedef typename X::root_type ResourceManager;
};
struct ResourceManager : generate<ResourceManager> {};

// IResourceQualifier
struct IResourceQualifier_raw : IInspectable {
	virtual STDMETHODIMP _get_QualifierName(HSTRING *value);
	virtual STDMETHODIMP _get_QualifierValue(HSTRING *value);
	virtual STDMETHODIMP _get_IsDefault(bool *value);
	virtual STDMETHODIMP _get_IsMatch(bool *value);
	virtual STDMETHODIMP _get_Score(double *value);
};
template<typename X> struct IResourceQualifier_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IResourceQualifier_adaptor::IsDefault)->_get_IsDefault(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsDefault;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IResourceQualifier_adaptor::IsMatch)->_get_IsMatch(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsMatch;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IResourceQualifier_adaptor::QualifierName)->_get_QualifierName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} QualifierName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IResourceQualifier_adaptor::QualifierValue)->_get_QualifierValue(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} QualifierValue;
		struct : property {
			double get() { double value; hrcheck(enc(&IResourceQualifier_adaptor::Score)->_get_Score(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} Score;
	};
	IResourceQualifier_adaptor() {}
};
template<typename X> struct adapt<IResourceQualifier, X> : Windows::ApplicationModel::Resources::Core::IResourceQualifier_adaptor<X> { typedef adapt IResourceQualifier; };
struct IResourceQualifier : IResourceQualifier_raw, generate<IResourceQualifier> {};

// ResourceQualifier
template<typename X> struct statics<ResourceQualifier, X> : X {
	typedef typename X::root_type ResourceQualifier;
};
struct ResourceQualifier : generate<ResourceQualifier> {};

// IResourceCandidate
struct IResourceCandidate_raw : IInspectable {
	virtual STDMETHODIMP _get_Qualifiers(Foundation::Collections::IVectorView<ResourceQualifier*>* *value);
	virtual STDMETHODIMP _get_IsMatch(bool *value);
	virtual STDMETHODIMP _get_IsMatchAsDefault(bool *value);
	virtual STDMETHODIMP _get_IsDefault(bool *value);
	virtual STDMETHODIMP _get_ValueAsString(HSTRING *result);
	virtual STDMETHODIMP _GetValueAsFileAsync(Foundation::IAsyncOperation<Storage::StorageFile*>* *operation);
	virtual STDMETHODIMP _GetQualifierValue(HSTRING qualifierName, HSTRING *value);
};
template<typename X> struct IResourceCandidate_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IResourceCandidate_adaptor::IsDefault)->_get_IsDefault(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsDefault;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IResourceCandidate_adaptor::IsMatch)->_get_IsMatch(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsMatch;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IResourceCandidate_adaptor::IsMatchAsDefault)->_get_IsMatchAsDefault(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsMatchAsDefault;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<ResourceQualifier>>> get() { Foundation::Collections::IVectorView<ResourceQualifier*>* value; hrcheck(enc(&IResourceCandidate_adaptor::Qualifiers)->_get_Qualifiers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<ResourceQualifier>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<ResourceQualifier>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<ResourceQualifier>>> operator->() { return get(); }
		} Qualifiers;
		struct : property {
			hstring get() { HSTRING result; hrcheck(enc(&IResourceCandidate_adaptor::ValueAsString)->_get_ValueAsString(&result)); return from_abi(result); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} ValueAsString;
	};
	ptr<Foundation::IAsyncOperation<ptr<Storage::StorageFile>>> GetValueAsFileAsync() { Foundation::IAsyncOperation<Storage::StorageFile*>* operation; hrcheck(X::get()->_GetValueAsFileAsync(&operation)); return from_abi(operation); }
	hstring GetQualifierValue(hstring_ref qualifierName) { HSTRING value; hrcheck(X::get()->_GetQualifierValue(qualifierName, &value)); return from_abi(value); }
	IResourceCandidate_adaptor() {}
};
template<typename X> struct adapt<IResourceCandidate, X> : Windows::ApplicationModel::Resources::Core::IResourceCandidate_adaptor<X> { typedef adapt IResourceCandidate; };
struct IResourceCandidate : IResourceCandidate_raw, generate<IResourceCandidate> {};

// IResourceCandidate2
struct IResourceCandidate2_raw : IInspectable {
	virtual STDMETHODIMP _GetValueAsStreamAsync(Foundation::IAsyncOperation<Storage::Streams::IRandomAccessStream*>* *operation);
};
template<typename X> struct IResourceCandidate2_adaptor : X {
	ptr<Foundation::IAsyncOperation<ptr<Storage::Streams::IRandomAccessStream>>> GetValueAsStreamAsync() { Foundation::IAsyncOperation<Storage::Streams::IRandomAccessStream*>* operation; hrcheck(X::get()->_GetValueAsStreamAsync(&operation)); return from_abi(operation); }
};
template<typename X> struct adapt<IResourceCandidate2, X> : Windows::ApplicationModel::Resources::Core::IResourceCandidate2_adaptor<X> { typedef adapt IResourceCandidate2; };
struct IResourceCandidate2 : IResourceCandidate2_raw, generate<IResourceCandidate2> {};

// ResourceCandidate
template<typename X> struct statics<ResourceCandidate, X> : X {
	typedef typename X::root_type ResourceCandidate;
};
struct ResourceCandidate : generate<ResourceCandidate> {};

// ResourceMapIterator
template<typename X> struct statics<ResourceMapIterator, X> : X {
	typedef typename X::root_type ResourceMapIterator;
};
struct ResourceMapIterator : generate<ResourceMapIterator> {};

// ResourceMapMapView
template<typename X> struct statics<ResourceMapMapView, X> : X {
	typedef typename X::root_type ResourceMapMapView;
};
struct ResourceMapMapView : generate<ResourceMapMapView> {};

// ResourceMapMapViewIterator
template<typename X> struct statics<ResourceMapMapViewIterator, X> : X {
	typedef typename X::root_type ResourceMapMapViewIterator;
};
struct ResourceMapMapViewIterator : generate<ResourceMapMapViewIterator> {};

// ResourceQualifierObservableMap
template<typename X> struct statics<ResourceQualifierObservableMap, X> : X {
	typedef typename X::root_type ResourceQualifierObservableMap;
};
struct ResourceQualifierObservableMap : generate<ResourceQualifierObservableMap> {};

// ResourceQualifierMapView
template<typename X> struct statics<ResourceQualifierMapView, X> : X {
	typedef typename X::root_type ResourceQualifierMapView;
};
struct ResourceQualifierMapView : generate<ResourceQualifierMapView> {};

// ResourceQualifierVectorView
template<typename X> struct statics<ResourceQualifierVectorView, X> : X {
	typedef typename X::root_type ResourceQualifierVectorView;
};
struct ResourceQualifierVectorView : generate<ResourceQualifierVectorView> {};

// ResourceCandidateVectorView
template<typename X> struct statics<ResourceCandidateVectorView, X> : X {
	typedef typename X::root_type ResourceCandidateVectorView;
};
struct ResourceCandidateVectorView : generate<ResourceCandidateVectorView> {};

// ResourceContextLanguagesVectorView
template<typename X> struct statics<ResourceContextLanguagesVectorView, X> : X {
	typedef typename X::root_type ResourceContextLanguagesVectorView;
};
struct ResourceContextLanguagesVectorView : generate<ResourceContextLanguagesVectorView> {};
}}}}
} // namespace iso_winrt
