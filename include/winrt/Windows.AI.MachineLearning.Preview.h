#pragma once
// generated by isopod tools
// namespaces:
// Windows.AI.MachineLearning.Preview

#include "Windows.AI.MachineLearning.Preview.0.h"
#include "Windows.Graphics.Imaging.0.h"
#include "Windows.Foundation.Collections.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation {
template<typename TResult> struct IAsyncOperation;
}
namespace Storage { namespace Streams {
struct IRandomAccessStreamReference;
}
struct IStorageFile;
}}

// defs

template<> struct def<Windows::AI::MachineLearning::Preview::MachineLearningPreviewContract> : value_type<> {};
template<> struct def<Windows::AI::MachineLearning::Preview::LearningModelDeviceKindPreview> : enum_type<int> {};
template<> struct def<Windows::AI::MachineLearning::Preview::IInferencingOptionsPreview> : interface_type<> {};
template<> struct def<Windows::AI::MachineLearning::Preview::ILearningModelBindingPreview> : interface_type<Windows::Foundation::Collections::IMapView<HSTRING, object>, Windows::Foundation::Collections::IIterable<ptr<Windows::Foundation::Collections::IKeyValuePair<HSTRING, object>>>> {};
template<> struct def<Windows::AI::MachineLearning::Preview::ILearningModelBindingPreviewFactory> : interface_type<> {};
template<> struct def<Windows::AI::MachineLearning::Preview::ILearningModelPreviewStatics> : interface_type<> {};
template<> struct def<Windows::AI::MachineLearning::Preview::ILearningModelPreview> : interface_type<> {};
template<> struct def<Windows::AI::MachineLearning::Preview::LearningModelPreview> : class_type<Platform::Object, Windows::AI::MachineLearning::Preview::ILearningModelPreview> {};
template<> struct def<Windows::AI::MachineLearning::Preview::LearningModelBindingPreview> : class_type<Platform::Object, Windows::AI::MachineLearning::Preview::ILearningModelBindingPreview>, custom_activators {};
template<> struct def<Windows::AI::MachineLearning::Preview::ILearningModelEvaluationResultPreview> : interface_type<> {};
template<> struct def<Windows::AI::MachineLearning::Preview::LearningModelEvaluationResultPreview> : class_type<Platform::Object, Windows::AI::MachineLearning::Preview::ILearningModelEvaluationResultPreview> {};
template<> struct def<Windows::AI::MachineLearning::Preview::ILearningModelDescriptionPreview> : interface_type<> {};
template<> struct def<Windows::AI::MachineLearning::Preview::LearningModelDescriptionPreview> : class_type<Platform::Object, Windows::AI::MachineLearning::Preview::ILearningModelDescriptionPreview> {};
template<> struct def<Windows::AI::MachineLearning::Preview::InferencingOptionsPreview> : class_type<Platform::Object, Windows::AI::MachineLearning::Preview::IInferencingOptionsPreview> {};
template<> struct def<Windows::AI::MachineLearning::Preview::LearningModelFeatureKindPreview> : enum_type<int> {};
template<> struct def<Windows::AI::MachineLearning::Preview::ILearningModelVariableDescriptorPreview> : overridable_type<> {};
template<> struct def<Windows::AI::MachineLearning::Preview::FeatureElementKindPreview> : enum_type<int> {};
template<> struct def<Windows::AI::MachineLearning::Preview::ITensorVariableDescriptorPreview> : interface_type<Windows::AI::MachineLearning::Preview::ILearningModelVariableDescriptorPreview> {};
template<> struct def<Windows::AI::MachineLearning::Preview::ISequenceVariableDescriptorPreview> : interface_type<Windows::AI::MachineLearning::Preview::ILearningModelVariableDescriptorPreview> {};
template<> struct def<Windows::AI::MachineLearning::Preview::IMapVariableDescriptorPreview> : interface_type<Windows::AI::MachineLearning::Preview::ILearningModelVariableDescriptorPreview> {};
template<> struct def<Windows::AI::MachineLearning::Preview::IImageVariableDescriptorPreview> : interface_type<Windows::AI::MachineLearning::Preview::ILearningModelVariableDescriptorPreview> {};
template<> struct def<Windows::AI::MachineLearning::Preview::LearningModelVariableDescriptorPreview> : class_type<Platform::Object, Windows::AI::MachineLearning::Preview::ILearningModelVariableDescriptorPreview> {};
template<> struct def<Windows::AI::MachineLearning::Preview::TensorVariableDescriptorPreview> : class_type<Platform::Object, Windows::AI::MachineLearning::Preview::ITensorVariableDescriptorPreview> {};
template<> struct def<Windows::AI::MachineLearning::Preview::SequenceVariableDescriptorPreview> : class_type<Platform::Object, Windows::AI::MachineLearning::Preview::ISequenceVariableDescriptorPreview> {};
template<> struct def<Windows::AI::MachineLearning::Preview::MapVariableDescriptorPreview> : class_type<Platform::Object, Windows::AI::MachineLearning::Preview::IMapVariableDescriptorPreview> {};
template<> struct def<Windows::AI::MachineLearning::Preview::ImageVariableDescriptorPreview> : class_type<Platform::Object, Windows::AI::MachineLearning::Preview::IImageVariableDescriptorPreview> {};

// uuids

template<> struct uuid<Windows::AI::MachineLearning::Preview::IInferencingOptionsPreview> { define_guid(0x47BC8205, 0x4D36, 0x47A9, 0x8F, 0x68, 0xFF, 0xCB, 0x33, 0x9D, 0xD0, 0xFC);};
template<> struct uuid<Windows::AI::MachineLearning::Preview::ILearningModelBindingPreview> { define_guid(0x93C901E8, 0x6C78, 0x4B4F, 0xAE, 0xC1, 0xA6, 0xBB, 0x9E, 0x69, 0x16, 0x24);};
template<> struct uuid<Windows::AI::MachineLearning::Preview::ILearningModelBindingPreviewFactory> { define_guid(0x48B8219F, 0x1E51, 0x4D77, 0xAE, 0x50, 0x3E, 0xC1, 0x64, 0xAD, 0x34, 0x80);};
template<> struct uuid<Windows::AI::MachineLearning::Preview::ILearningModelPreviewStatics> { define_guid(0x164BBB60, 0x8465, 0x4786, 0x8B, 0x93, 0x2C, 0x16, 0xA8, 0x92, 0x89, 0xD7);};
template<> struct uuid<Windows::AI::MachineLearning::Preview::ILearningModelPreview> { define_guid(0x49C266A, 0x93B4, 0x478C, 0xAE, 0xB8, 0x70, 0x15, 0x7B, 0xF0, 0xFF, 0x94);};
template<> struct uuid<Windows::AI::MachineLearning::Preview::ILearningModelEvaluationResultPreview> { define_guid(0xDF25EA9F, 0x9863, 0x4088, 0x84, 0x98, 0x87, 0xA1, 0xF4, 0x68, 0x6F, 0x92);};
template<> struct uuid<Windows::AI::MachineLearning::Preview::ILearningModelDescriptionPreview> { define_guid(0xF52C09C6, 0x8611, 0x40AD, 0x8E, 0x59, 0xDE, 0x3F, 0xD7, 0x3, 0xA, 0x40);};
template<> struct uuid<Windows::AI::MachineLearning::Preview::ILearningModelVariableDescriptorPreview> { define_guid(0xB13DF682, 0xFC30, 0x492B, 0x8E, 0xA0, 0xED, 0x1F, 0x53, 0xC0, 0xB0, 0x38);};
template<> struct uuid<Windows::AI::MachineLearning::Preview::ITensorVariableDescriptorPreview> { define_guid(0xA80F501A, 0x9AAC, 0x4233, 0x97, 0x84, 0xAC, 0xEA, 0xF9, 0x25, 0x10, 0xB5);};
template<> struct uuid<Windows::AI::MachineLearning::Preview::ISequenceVariableDescriptorPreview> { define_guid(0x9CD8F292, 0x98B2, 0x4530, 0xA1, 0xB6, 0x2D, 0xED, 0x5F, 0xEC, 0xBC, 0x26);};
template<> struct uuid<Windows::AI::MachineLearning::Preview::IMapVariableDescriptorPreview> { define_guid(0x3CB38370, 0xC02B, 0x4236, 0xB3, 0xE8, 0x6B, 0xDC, 0xA4, 0x9C, 0x31, 0x29);};
template<> struct uuid<Windows::AI::MachineLearning::Preview::IImageVariableDescriptorPreview> { define_guid(0x7AE1FA72, 0x29E, 0x4DC5, 0xA2, 0xF8, 0x5F, 0xB7, 0x63, 0x15, 0x41, 0x50);};

// types

namespace Windows { namespace AI { namespace MachineLearning { namespace Preview {

// IInferencingOptionsPreview
struct IInferencingOptionsPreview_raw : IInspectable {
	virtual STDMETHODIMP _get_PreferredDeviceKind(LearningModelDeviceKindPreview *value);
	virtual STDMETHODIMP _put_PreferredDeviceKind(LearningModelDeviceKindPreview value);
	virtual STDMETHODIMP _get_IsTracingEnabled(bool *value);
	virtual STDMETHODIMP _put_IsTracingEnabled(bool value);
	virtual STDMETHODIMP _get_MaxBatchSize(int *value);
	virtual STDMETHODIMP _put_MaxBatchSize(int value);
	virtual STDMETHODIMP _get_MinimizeMemoryAllocation(bool *value);
	virtual STDMETHODIMP _put_MinimizeMemoryAllocation(bool value);
	virtual STDMETHODIMP _get_ReclaimMemoryAfterEvaluation(bool *value);
	virtual STDMETHODIMP _put_ReclaimMemoryAfterEvaluation(bool value);
};
template<typename X> struct IInferencingOptionsPreview_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IInferencingOptionsPreview_adaptor::IsTracingEnabled)->_get_IsTracingEnabled(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IInferencingOptionsPreview_adaptor::IsTracingEnabled)->_put_IsTracingEnabled(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} IsTracingEnabled;
		struct : property {
			int get() { int value; hrcheck(enc(&IInferencingOptionsPreview_adaptor::MaxBatchSize)->_get_MaxBatchSize(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
			void put(int value) { hrcheck(enc(&IInferencingOptionsPreview_adaptor::MaxBatchSize)->_put_MaxBatchSize(value)); }
			void operator=(int value) { put(value); }
			void operator()(int value) { put(value); }
		} MaxBatchSize;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IInferencingOptionsPreview_adaptor::MinimizeMemoryAllocation)->_get_MinimizeMemoryAllocation(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IInferencingOptionsPreview_adaptor::MinimizeMemoryAllocation)->_put_MinimizeMemoryAllocation(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} MinimizeMemoryAllocation;
		struct : property {
			LearningModelDeviceKindPreview get() { LearningModelDeviceKindPreview value; hrcheck(enc(&IInferencingOptionsPreview_adaptor::PreferredDeviceKind)->_get_PreferredDeviceKind(&value)); return value; }
			LearningModelDeviceKindPreview operator()() { return get(); }
			operator LearningModelDeviceKindPreview () { return get(); }
			void put(LearningModelDeviceKindPreview value) { hrcheck(enc(&IInferencingOptionsPreview_adaptor::PreferredDeviceKind)->_put_PreferredDeviceKind(value)); }
			void operator=(LearningModelDeviceKindPreview value) { put(value); }
			void operator()(LearningModelDeviceKindPreview value) { put(value); }
		} PreferredDeviceKind;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IInferencingOptionsPreview_adaptor::ReclaimMemoryAfterEvaluation)->_get_ReclaimMemoryAfterEvaluation(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
			void put(bool value) { hrcheck(enc(&IInferencingOptionsPreview_adaptor::ReclaimMemoryAfterEvaluation)->_put_ReclaimMemoryAfterEvaluation(value)); }
			void operator=(bool value) { put(value); }
			void operator()(bool value) { put(value); }
		} ReclaimMemoryAfterEvaluation;
	};
	IInferencingOptionsPreview_adaptor() {}
};
template<typename X> struct adapt<IInferencingOptionsPreview, X> : Windows::AI::MachineLearning::Preview::IInferencingOptionsPreview_adaptor<X> { typedef adapt IInferencingOptionsPreview; };
struct IInferencingOptionsPreview : IInferencingOptionsPreview_raw, generate<IInferencingOptionsPreview> {};

// ILearningModelBindingPreview
struct ILearningModelBindingPreview_raw : IInspectable {
	virtual STDMETHODIMP _Bind(HSTRING name, IInspectable* value);
	virtual STDMETHODIMP _BindWithProperties(HSTRING name, IInspectable* value, Foundation::Collections::IPropertySet* metadata);
	virtual STDMETHODIMP _Clear();
};
template<typename X> struct ILearningModelBindingPreview_adaptor : X {
	void Bind(hstring_ref name, object_ref value) { hrcheck(X::get()->_Bind(name, value)); }
	void Bind(hstring_ref name, object_ref value, pptr<Foundation::Collections::IPropertySet> metadata) { hrcheck(X::get()->_BindWithProperties(name, value, metadata)); }
	void Clear() { hrcheck(X::get()->_Clear()); }
};
template<typename X> struct adapt<ILearningModelBindingPreview, X> : Windows::AI::MachineLearning::Preview::ILearningModelBindingPreview_adaptor<X> { typedef adapt ILearningModelBindingPreview; };
struct ILearningModelBindingPreview : ILearningModelBindingPreview_raw, generate<ILearningModelBindingPreview> {};

// ILearningModelBindingPreviewFactory
struct ILearningModelBindingPreviewFactory : IInspectable {
	virtual STDMETHODIMP _CreateFromModel(LearningModelPreview* model, LearningModelBindingPreview* *value);
};

// ILearningModelPreviewStatics
struct ILearningModelPreviewStatics : IInspectable {
	virtual STDMETHODIMP _LoadModelFromStorageFileAsync(Storage::IStorageFile* modelFile, Foundation::IAsyncOperation<LearningModelPreview*>* *modelCreationOperation);
	virtual STDMETHODIMP _LoadModelFromStreamAsync(Storage::Streams::IRandomAccessStreamReference* modelStream, Foundation::IAsyncOperation<LearningModelPreview*>* *modelCreationOperation);
};

// ILearningModelPreview
struct ILearningModelPreview_raw : IInspectable {
	virtual STDMETHODIMP _EvaluateAsync(LearningModelBindingPreview* binding, HSTRING correlationId, Foundation::IAsyncOperation<LearningModelEvaluationResultPreview*>* *evalOperation);
	virtual STDMETHODIMP _EvaluateFeaturesAsync(Foundation::Collections::IMap<HSTRING, IInspectable*>* features, HSTRING correlationId, Foundation::IAsyncOperation<LearningModelEvaluationResultPreview*>* *evalOperation);
	virtual STDMETHODIMP _get_Description(LearningModelDescriptionPreview* *returnValue);
	virtual STDMETHODIMP _get_InferencingOptions(InferencingOptionsPreview* *value);
	virtual STDMETHODIMP _put_InferencingOptions(InferencingOptionsPreview* value);
};
template<typename X> struct ILearningModelPreview_adaptor : X {
	union {
		struct : property {
			ptr<LearningModelDescriptionPreview> get() { LearningModelDescriptionPreview* returnValue; hrcheck(enc(&ILearningModelPreview_adaptor::Description)->_get_Description(&returnValue)); return from_abi(returnValue); }
			ptr<LearningModelDescriptionPreview> operator()() { return get(); }
			operator ptr<LearningModelDescriptionPreview> () { return get(); }
			ptr<LearningModelDescriptionPreview> operator->() { return get(); }
		} Description;
		struct : property {
			ptr<InferencingOptionsPreview> get() { InferencingOptionsPreview* value; hrcheck(enc(&ILearningModelPreview_adaptor::InferencingOptions)->_get_InferencingOptions(&value)); return from_abi(value); }
			ptr<InferencingOptionsPreview> operator()() { return get(); }
			operator ptr<InferencingOptionsPreview> () { return get(); }
			ptr<InferencingOptionsPreview> operator->() { return get(); }
			void put(pptr<InferencingOptionsPreview> value) { hrcheck(enc(&ILearningModelPreview_adaptor::InferencingOptions)->_put_InferencingOptions(value)); }
			void operator=(pptr<InferencingOptionsPreview> value) { put(value); }
			void operator()(pptr<InferencingOptionsPreview> value) { put(value); }
		} InferencingOptions;
	};
	ptr<Foundation::IAsyncOperation<ptr<LearningModelEvaluationResultPreview>>> EvaluateAsync(pptr<LearningModelBindingPreview> binding, hstring_ref correlationId) { Foundation::IAsyncOperation<LearningModelEvaluationResultPreview*>* evalOperation; hrcheck(X::get()->_EvaluateAsync(binding, correlationId, &evalOperation)); return from_abi(evalOperation); }
	ptr<Foundation::IAsyncOperation<ptr<LearningModelEvaluationResultPreview>>> EvaluateFeaturesAsync(pptr<Foundation::Collections::IMap<hstring, object>> features, hstring_ref correlationId) { Foundation::IAsyncOperation<LearningModelEvaluationResultPreview*>* evalOperation; hrcheck(X::get()->_EvaluateFeaturesAsync(to_abi(features), correlationId, &evalOperation)); return from_abi(evalOperation); }
	ILearningModelPreview_adaptor() {}
};
template<typename X> struct adapt<ILearningModelPreview, X> : Windows::AI::MachineLearning::Preview::ILearningModelPreview_adaptor<X> { typedef adapt ILearningModelPreview; };
struct ILearningModelPreview : ILearningModelPreview_raw, generate<ILearningModelPreview> {};

// LearningModelPreview
template<typename> struct LearningModelPreview_statics {
	static ptr<Foundation::IAsyncOperation<ptr<LearningModelPreview>>> LoadModelFromStorageFileAsync(pptr<Storage::IStorageFile> modelFile) { Foundation::IAsyncOperation<LearningModelPreview*>* modelCreationOperation; hrcheck(get_activation_factory<LearningModelPreview, ILearningModelPreviewStatics>()->_LoadModelFromStorageFileAsync(modelFile, &modelCreationOperation)); return from_abi(modelCreationOperation); }
	static ptr<Foundation::IAsyncOperation<ptr<LearningModelPreview>>> LoadModelFromStreamAsync(pptr<Storage::Streams::IRandomAccessStreamReference> modelStream) { Foundation::IAsyncOperation<LearningModelPreview*>* modelCreationOperation; hrcheck(get_activation_factory<LearningModelPreview, ILearningModelPreviewStatics>()->_LoadModelFromStreamAsync(modelStream, &modelCreationOperation)); return from_abi(modelCreationOperation); }
};

template<typename X> struct statics<LearningModelPreview, X> : X, Windows::AI::MachineLearning::Preview::LearningModelPreview_statics<void> {
	typedef typename X::root_type LearningModelPreview;
};
struct LearningModelPreview : generate<LearningModelPreview> {};

// LearningModelBindingPreview
template<typename> struct LearningModelBindingPreview_statics {
	static LearningModelBindingPreview *activate(pptr<LearningModelPreview> model) { LearningModelBindingPreview *value; hrcheck(get_activation_factory<LearningModelBindingPreview, ILearningModelBindingPreviewFactory>()->_CreateFromModel(model, &value)); return value; }
};

template<typename X> struct statics<LearningModelBindingPreview, X> : X, Windows::AI::MachineLearning::Preview::LearningModelBindingPreview_statics<void> {
	using Windows::AI::MachineLearning::Preview::LearningModelBindingPreview_statics<void>::activate;
	typedef typename X::root_type LearningModelBindingPreview;
};
struct LearningModelBindingPreview : generate<LearningModelBindingPreview> {
	using ILearningModelBindingPreview::Bind;
};

// ILearningModelEvaluationResultPreview
struct ILearningModelEvaluationResultPreview_raw : IInspectable {
	virtual STDMETHODIMP _get_CorrelationId(HSTRING *correlationId);
	virtual STDMETHODIMP _get_Outputs(Foundation::Collections::IMapView<HSTRING, IInspectable*>* *value);
};
template<typename X> struct ILearningModelEvaluationResultPreview_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING correlationId; hrcheck(enc(&ILearningModelEvaluationResultPreview_adaptor::CorrelationId)->_get_CorrelationId(&correlationId)); return from_abi(correlationId); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} CorrelationId;
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, object>> get() { Foundation::Collections::IMapView<HSTRING, IInspectable*>* value; hrcheck(enc(&ILearningModelEvaluationResultPreview_adaptor::Outputs)->_get_Outputs(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMapView<hstring, object>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, object>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, object>> operator->() { return get(); }
		} Outputs;
	};
	ILearningModelEvaluationResultPreview_adaptor() {}
};
template<typename X> struct adapt<ILearningModelEvaluationResultPreview, X> : Windows::AI::MachineLearning::Preview::ILearningModelEvaluationResultPreview_adaptor<X> { typedef adapt ILearningModelEvaluationResultPreview; };
struct ILearningModelEvaluationResultPreview : ILearningModelEvaluationResultPreview_raw, generate<ILearningModelEvaluationResultPreview> {};

// LearningModelEvaluationResultPreview
template<typename X> struct statics<LearningModelEvaluationResultPreview, X> : X {
	typedef typename X::root_type LearningModelEvaluationResultPreview;
};
struct LearningModelEvaluationResultPreview : generate<LearningModelEvaluationResultPreview> {};

// ILearningModelDescriptionPreview
struct ILearningModelDescriptionPreview_raw : IInspectable {
	virtual STDMETHODIMP _get_Author(HSTRING *value);
	virtual STDMETHODIMP _get_Name(HSTRING *value);
	virtual STDMETHODIMP _get_Domain(HSTRING *value);
	virtual STDMETHODIMP _get_Description(HSTRING *value);
	virtual STDMETHODIMP _get_Version(__int64 *value);
	virtual STDMETHODIMP _get_Metadata(Foundation::Collections::IMapView<HSTRING, HSTRING>* *value);
	virtual STDMETHODIMP _get_InputFeatures(Foundation::Collections::IIterable<ILearningModelVariableDescriptorPreview*>* *value);
	virtual STDMETHODIMP _get_OutputFeatures(Foundation::Collections::IIterable<ILearningModelVariableDescriptorPreview*>* *value);
};
template<typename X> struct ILearningModelDescriptionPreview_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ILearningModelDescriptionPreview_adaptor::Author)->_get_Author(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Author;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ILearningModelDescriptionPreview_adaptor::Description)->_get_Description(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Description;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ILearningModelDescriptionPreview_adaptor::Domain)->_get_Domain(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Domain;
		struct : property {
			ptr<Foundation::Collections::IIterable<ptr<ILearningModelVariableDescriptorPreview>>> get() { Foundation::Collections::IIterable<ILearningModelVariableDescriptorPreview*>* value; hrcheck(enc(&ILearningModelDescriptionPreview_adaptor::InputFeatures)->_get_InputFeatures(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IIterable<ptr<ILearningModelVariableDescriptorPreview>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IIterable<ptr<ILearningModelVariableDescriptorPreview>>> () { return get(); }
			ptr<Foundation::Collections::IIterable<ptr<ILearningModelVariableDescriptorPreview>>> operator->() { return get(); }
		} InputFeatures;
		struct : property {
			ptr<Foundation::Collections::IMapView<hstring, hstring>> get() { Foundation::Collections::IMapView<HSTRING, HSTRING>* value; hrcheck(enc(&ILearningModelDescriptionPreview_adaptor::Metadata)->_get_Metadata(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IMapView<hstring, hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IMapView<hstring, hstring>> () { return get(); }
			ptr<Foundation::Collections::IMapView<hstring, hstring>> operator->() { return get(); }
		} Metadata;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ILearningModelDescriptionPreview_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
		struct : property {
			ptr<Foundation::Collections::IIterable<ptr<ILearningModelVariableDescriptorPreview>>> get() { Foundation::Collections::IIterable<ILearningModelVariableDescriptorPreview*>* value; hrcheck(enc(&ILearningModelDescriptionPreview_adaptor::OutputFeatures)->_get_OutputFeatures(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IIterable<ptr<ILearningModelVariableDescriptorPreview>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IIterable<ptr<ILearningModelVariableDescriptorPreview>>> () { return get(); }
			ptr<Foundation::Collections::IIterable<ptr<ILearningModelVariableDescriptorPreview>>> operator->() { return get(); }
		} OutputFeatures;
		struct : property {
			__int64 get() { __int64 value; hrcheck(enc(&ILearningModelDescriptionPreview_adaptor::Version)->_get_Version(&value)); return value; }
			__int64 operator()() { return get(); }
			operator __int64 () { return get(); }
		} Version;
	};
	ILearningModelDescriptionPreview_adaptor() {}
};
template<typename X> struct adapt<ILearningModelDescriptionPreview, X> : Windows::AI::MachineLearning::Preview::ILearningModelDescriptionPreview_adaptor<X> { typedef adapt ILearningModelDescriptionPreview; };
struct ILearningModelDescriptionPreview : ILearningModelDescriptionPreview_raw, generate<ILearningModelDescriptionPreview> {};

// LearningModelDescriptionPreview
template<typename X> struct statics<LearningModelDescriptionPreview, X> : X {
	typedef typename X::root_type LearningModelDescriptionPreview;
};
struct LearningModelDescriptionPreview : generate<LearningModelDescriptionPreview> {};

// InferencingOptionsPreview
template<typename X> struct statics<InferencingOptionsPreview, X> : X {
	typedef typename X::root_type InferencingOptionsPreview;
};
struct InferencingOptionsPreview : generate<InferencingOptionsPreview> {};

// ILearningModelVariableDescriptorPreview
struct ILearningModelVariableDescriptorPreview_raw : IInspectable {
	virtual STDMETHODIMP _get_Name(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_Description(HSTRING *value) = 0;
	virtual STDMETHODIMP _get_ModelFeatureKind(LearningModelFeatureKindPreview *value) = 0;
	virtual STDMETHODIMP _get_IsRequired(bool *value) = 0;
};
template<typename X> struct ILearningModelVariableDescriptorPreview_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ILearningModelVariableDescriptorPreview_adaptor::Description)->_get_Description(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Description;
		struct : property {
			bool get() { bool value; hrcheck(enc(&ILearningModelVariableDescriptorPreview_adaptor::IsRequired)->_get_IsRequired(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsRequired;
		struct : property {
			LearningModelFeatureKindPreview get() { LearningModelFeatureKindPreview value; hrcheck(enc(&ILearningModelVariableDescriptorPreview_adaptor::ModelFeatureKind)->_get_ModelFeatureKind(&value)); return value; }
			LearningModelFeatureKindPreview operator()() { return get(); }
			operator LearningModelFeatureKindPreview () { return get(); }
		} ModelFeatureKind;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ILearningModelVariableDescriptorPreview_adaptor::Name)->_get_Name(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Name;
	};
	ILearningModelVariableDescriptorPreview_adaptor() {}
};
template<typename X> struct adapt<ILearningModelVariableDescriptorPreview, X> : Windows::AI::MachineLearning::Preview::ILearningModelVariableDescriptorPreview_adaptor<X> { typedef adapt ILearningModelVariableDescriptorPreview; };
template<typename X> struct ILearningModelVariableDescriptorPreview_unadaptor : X {
	STDMETHODIMP _get_Name(HSTRING *value) { return hrtry([&, this] { get_prop(value, Name); }); }
	STDMETHODIMP _get_Description(HSTRING *value) { return hrtry([&, this] { get_prop(value, Description); }); }
	STDMETHODIMP _get_ModelFeatureKind(LearningModelFeatureKindPreview *value) { return hrtry([&, this] { get_prop(value, ModelFeatureKind); }); }
	STDMETHODIMP _get_IsRequired(bool *value) { return hrtry([&, this] { get_prop(value, IsRequired); }); }
};
template<typename X> struct unadapt<ILearningModelVariableDescriptorPreview, X> : Windows::AI::MachineLearning::Preview::ILearningModelVariableDescriptorPreview_unadaptor<X> {};
struct ILearningModelVariableDescriptorPreview : ILearningModelVariableDescriptorPreview_raw, generate<ILearningModelVariableDescriptorPreview> {};

// ITensorVariableDescriptorPreview
struct ITensorVariableDescriptorPreview_raw : IInspectable {
	virtual STDMETHODIMP _get_DataType(FeatureElementKindPreview *value);
	virtual STDMETHODIMP _get_Shape(Foundation::Collections::IIterable<__int64>* *value);
};
template<typename X> struct ITensorVariableDescriptorPreview_adaptor : X {
	union {
		struct : property {
			FeatureElementKindPreview get() { FeatureElementKindPreview value; hrcheck(enc(&ITensorVariableDescriptorPreview_adaptor::DataType)->_get_DataType(&value)); return value; }
			FeatureElementKindPreview operator()() { return get(); }
			operator FeatureElementKindPreview () { return get(); }
		} DataType;
		struct : property {
			ptr<Foundation::Collections::IIterable<__int64>> get() { Foundation::Collections::IIterable<__int64>* value; hrcheck(enc(&ITensorVariableDescriptorPreview_adaptor::Shape)->_get_Shape(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IIterable<__int64>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IIterable<__int64>> () { return get(); }
			ptr<Foundation::Collections::IIterable<__int64>> operator->() { return get(); }
		} Shape;
	};
	ITensorVariableDescriptorPreview_adaptor() {}
};
template<typename X> struct adapt<ITensorVariableDescriptorPreview, X> : Windows::AI::MachineLearning::Preview::ITensorVariableDescriptorPreview_adaptor<X> { typedef adapt ITensorVariableDescriptorPreview; };
struct ITensorVariableDescriptorPreview : ITensorVariableDescriptorPreview_raw, generate<ITensorVariableDescriptorPreview> {};

// ISequenceVariableDescriptorPreview
struct ISequenceVariableDescriptorPreview_raw : IInspectable {
	virtual STDMETHODIMP _get_ElementType(ILearningModelVariableDescriptorPreview* *value);
};
template<typename X> struct ISequenceVariableDescriptorPreview_adaptor : X {
	union {
		struct : property {
			ptr<ILearningModelVariableDescriptorPreview> get() { ILearningModelVariableDescriptorPreview* value; hrcheck(enc(&ISequenceVariableDescriptorPreview_adaptor::ElementType)->_get_ElementType(&value)); return from_abi(value); }
			ptr<ILearningModelVariableDescriptorPreview> operator()() { return get(); }
			operator ptr<ILearningModelVariableDescriptorPreview> () { return get(); }
			ptr<ILearningModelVariableDescriptorPreview> operator->() { return get(); }
		} ElementType;
	};
	ISequenceVariableDescriptorPreview_adaptor() {}
};
template<typename X> struct adapt<ISequenceVariableDescriptorPreview, X> : Windows::AI::MachineLearning::Preview::ISequenceVariableDescriptorPreview_adaptor<X> { typedef adapt ISequenceVariableDescriptorPreview; };
struct ISequenceVariableDescriptorPreview : ISequenceVariableDescriptorPreview_raw, generate<ISequenceVariableDescriptorPreview> {};

// IMapVariableDescriptorPreview
struct IMapVariableDescriptorPreview_raw : IInspectable {
	virtual STDMETHODIMP _get_KeyKind(FeatureElementKindPreview *value);
	virtual STDMETHODIMP _get_ValidStringKeys(Foundation::Collections::IIterable<HSTRING>* *value);
	virtual STDMETHODIMP _get_ValidIntegerKeys(Foundation::Collections::IIterable<__int64>* *value);
	virtual STDMETHODIMP _get_Fields(ILearningModelVariableDescriptorPreview* *value);
};
template<typename X> struct IMapVariableDescriptorPreview_adaptor : X {
	union {
		struct : property {
			ptr<ILearningModelVariableDescriptorPreview> get() { ILearningModelVariableDescriptorPreview* value; hrcheck(enc(&IMapVariableDescriptorPreview_adaptor::Fields)->_get_Fields(&value)); return from_abi(value); }
			ptr<ILearningModelVariableDescriptorPreview> operator()() { return get(); }
			operator ptr<ILearningModelVariableDescriptorPreview> () { return get(); }
			ptr<ILearningModelVariableDescriptorPreview> operator->() { return get(); }
		} Fields;
		struct : property {
			FeatureElementKindPreview get() { FeatureElementKindPreview value; hrcheck(enc(&IMapVariableDescriptorPreview_adaptor::KeyKind)->_get_KeyKind(&value)); return value; }
			FeatureElementKindPreview operator()() { return get(); }
			operator FeatureElementKindPreview () { return get(); }
		} KeyKind;
		struct : property {
			ptr<Foundation::Collections::IIterable<__int64>> get() { Foundation::Collections::IIterable<__int64>* value; hrcheck(enc(&IMapVariableDescriptorPreview_adaptor::ValidIntegerKeys)->_get_ValidIntegerKeys(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IIterable<__int64>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IIterable<__int64>> () { return get(); }
			ptr<Foundation::Collections::IIterable<__int64>> operator->() { return get(); }
		} ValidIntegerKeys;
		struct : property {
			ptr<Foundation::Collections::IIterable<hstring>> get() { Foundation::Collections::IIterable<HSTRING>* value; hrcheck(enc(&IMapVariableDescriptorPreview_adaptor::ValidStringKeys)->_get_ValidStringKeys(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IIterable<hstring>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IIterable<hstring>> () { return get(); }
			ptr<Foundation::Collections::IIterable<hstring>> operator->() { return get(); }
		} ValidStringKeys;
	};
	IMapVariableDescriptorPreview_adaptor() {}
};
template<typename X> struct adapt<IMapVariableDescriptorPreview, X> : Windows::AI::MachineLearning::Preview::IMapVariableDescriptorPreview_adaptor<X> { typedef adapt IMapVariableDescriptorPreview; };
struct IMapVariableDescriptorPreview : IMapVariableDescriptorPreview_raw, generate<IMapVariableDescriptorPreview> {};

// IImageVariableDescriptorPreview
struct IImageVariableDescriptorPreview_raw : IInspectable {
	virtual STDMETHODIMP _get_BitmapPixelFormat(Graphics::Imaging::BitmapPixelFormat *value);
	virtual STDMETHODIMP _get_Width(unsigned *value);
	virtual STDMETHODIMP _get_Height(unsigned *value);
};
template<typename X> struct IImageVariableDescriptorPreview_adaptor : X {
	union {
		struct : property {
			Graphics::Imaging::BitmapPixelFormat get() { Graphics::Imaging::BitmapPixelFormat value; hrcheck(enc(&IImageVariableDescriptorPreview_adaptor::BitmapPixelFormat)->_get_BitmapPixelFormat(&value)); return value; }
			Graphics::Imaging::BitmapPixelFormat operator()() { return get(); }
			operator Graphics::Imaging::BitmapPixelFormat () { return get(); }
		} BitmapPixelFormat;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IImageVariableDescriptorPreview_adaptor::Height)->_get_Height(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Height;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IImageVariableDescriptorPreview_adaptor::Width)->_get_Width(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} Width;
	};
	IImageVariableDescriptorPreview_adaptor() {}
};
template<typename X> struct adapt<IImageVariableDescriptorPreview, X> : Windows::AI::MachineLearning::Preview::IImageVariableDescriptorPreview_adaptor<X> { typedef adapt IImageVariableDescriptorPreview; };
struct IImageVariableDescriptorPreview : IImageVariableDescriptorPreview_raw, generate<IImageVariableDescriptorPreview> {};

// LearningModelVariableDescriptorPreview
template<typename X> struct statics<LearningModelVariableDescriptorPreview, X> : X {
	typedef typename X::root_type LearningModelVariableDescriptorPreview;
};
struct LearningModelVariableDescriptorPreview : generate<LearningModelVariableDescriptorPreview> {};

// TensorVariableDescriptorPreview
template<typename X> struct statics<TensorVariableDescriptorPreview, X> : X {
	typedef typename X::root_type TensorVariableDescriptorPreview;
};
struct TensorVariableDescriptorPreview : generate<TensorVariableDescriptorPreview> {};

// SequenceVariableDescriptorPreview
template<typename X> struct statics<SequenceVariableDescriptorPreview, X> : X {
	typedef typename X::root_type SequenceVariableDescriptorPreview;
};
struct SequenceVariableDescriptorPreview : generate<SequenceVariableDescriptorPreview> {};

// MapVariableDescriptorPreview
template<typename X> struct statics<MapVariableDescriptorPreview, X> : X {
	typedef typename X::root_type MapVariableDescriptorPreview;
};
struct MapVariableDescriptorPreview : generate<MapVariableDescriptorPreview> {};

// ImageVariableDescriptorPreview
template<typename X> struct statics<ImageVariableDescriptorPreview, X> : X {
	typedef typename X::root_type ImageVariableDescriptorPreview;
};
struct ImageVariableDescriptorPreview : generate<ImageVariableDescriptorPreview> {};
}}}}
} // namespace iso_winrt
