#pragma once
// generated by isopod tools
// namespaces:
// Windows.Devices.Geolocation

#include "Windows.Devices.Geolocation.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Foundation { namespace Collections {
template<typename T> struct IIterable;
template<typename T> struct IVectorView;
}}}

// defs

template<> struct def<Windows::Devices::Geolocation::PositionAccuracy> : enum_type<int> {};
template<> struct def<Windows::Devices::Geolocation::PositionStatus> : enum_type<int> {};
template<> struct def<Windows::Devices::Geolocation::PositionSource> : enum_type<int> {};
template<> struct def<Windows::Devices::Geolocation::GeoshapeType> : enum_type<int> {};
template<> struct def<Windows::Devices::Geolocation::AltitudeReferenceSystem> : enum_type<int> {};
template<> struct def<Windows::Devices::Geolocation::BasicGeoposition> : value_type<double, double, double> {};
template<> struct def<Windows::Devices::Geolocation::GeolocationAccessStatus> : enum_type<int> {};
template<> struct def<Windows::Devices::Geolocation::IGeoshape> : overridable_type<> {};
template<> struct def<Windows::Devices::Geolocation::IGeopoint> : interface_type<Windows::Devices::Geolocation::IGeoshape> {};
template<> struct def<Windows::Devices::Geolocation::IGeopointFactory> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::Geopoint> : class_type<Platform::Object, Windows::Devices::Geolocation::IGeopoint>, custom_activators {};
template<> struct def<Windows::Devices::Geolocation::IGeopath> : interface_type<Windows::Devices::Geolocation::IGeoshape> {};
template<> struct def<Windows::Devices::Geolocation::IGeopathFactory> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::Geopath> : class_type<Platform::Object, Windows::Devices::Geolocation::IGeopath>, custom_activators {};
template<> struct def<Windows::Devices::Geolocation::IGeoboundingBox> : interface_type<Windows::Devices::Geolocation::IGeoshape> {};
template<> struct def<Windows::Devices::Geolocation::IGeoboundingBoxFactory> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::IGeoboundingBoxStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::GeoboundingBox> : class_type<Platform::Object, Windows::Devices::Geolocation::IGeoboundingBox>, custom_activators {};
template<> struct def<Windows::Devices::Geolocation::IGeocoordinateSatelliteData> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::GeocoordinateSatelliteData> : class_type<Platform::Object, Windows::Devices::Geolocation::IGeocoordinateSatelliteData> {};
template<> struct def<Windows::Devices::Geolocation::IVenueData> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::VenueData> : class_type<Platform::Object, Windows::Devices::Geolocation::IVenueData> {};
template<> struct def<Windows::Devices::Geolocation::IGeocoordinate> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::IGeocoordinateWithPositionData> : interface_type<Windows::Devices::Geolocation::IGeocoordinate> {};
template<> struct def<Windows::Devices::Geolocation::IGeocoordinateWithPoint> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::IGeocoordinateWithPositionSourceTimestamp> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::IGeoposition> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::IGeoposition2> : interface_type<Windows::Devices::Geolocation::IGeoposition> {};
template<> struct def<Windows::Devices::Geolocation::Geocoordinate> : class_type<Platform::Object, Windows::Devices::Geolocation::IGeocoordinate, Windows::Devices::Geolocation::IGeocoordinateWithPositionData, Windows::Devices::Geolocation::IGeocoordinateWithPoint, Windows::Devices::Geolocation::IGeocoordinateWithPositionSourceTimestamp> {};
template<> struct def<Windows::Devices::Geolocation::ICivicAddress> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::CivicAddress> : class_type<Platform::Object, Windows::Devices::Geolocation::ICivicAddress> {};
template<> struct def<Windows::Devices::Geolocation::Geoposition> : class_type<Platform::Object, Windows::Devices::Geolocation::IGeoposition, Windows::Devices::Geolocation::IGeoposition2> {};
template<> struct def<Windows::Devices::Geolocation::IPositionChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::PositionChangedEventArgs> : class_type<Platform::Object, Windows::Devices::Geolocation::IPositionChangedEventArgs> {};
template<> struct def<Windows::Devices::Geolocation::IStatusChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::StatusChangedEventArgs> : class_type<Platform::Object, Windows::Devices::Geolocation::IStatusChangedEventArgs> {};
template<> struct def<Windows::Devices::Geolocation::IGeolocator> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::IGeolocatorStatics2> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::IGeolocatorStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::IGeolocator2> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::IGeolocatorWithScalarAccuracy> : interface_type<Windows::Devices::Geolocation::IGeolocator> {};
template<> struct def<Windows::Devices::Geolocation::Geolocator> : class_type<Platform::Object, Windows::Devices::Geolocation::IGeolocator, Windows::Devices::Geolocation::IGeolocatorWithScalarAccuracy, Windows::Devices::Geolocation::IGeolocator2> {};
template<> struct def<Windows::Devices::Geolocation::IGeocircle> : interface_type<Windows::Devices::Geolocation::IGeoshape> {};
template<> struct def<Windows::Devices::Geolocation::IGeocircleFactory> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::Geocircle> : class_type<Platform::Object, Windows::Devices::Geolocation::IGeocircle>, custom_activators {};
template<> struct def<Windows::Devices::Geolocation::VisitMonitoringScope> : enum_type<int> {};
template<> struct def<Windows::Devices::Geolocation::VisitStateChange> : enum_type<int> {};
template<> struct def<Windows::Devices::Geolocation::IGeovisit> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::Geovisit> : class_type<Platform::Object, Windows::Devices::Geolocation::IGeovisit> {};
template<> struct def<Windows::Devices::Geolocation::IGeovisitStateChangedEventArgs> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::GeovisitStateChangedEventArgs> : class_type<Platform::Object, Windows::Devices::Geolocation::IGeovisitStateChangedEventArgs> {};
template<> struct def<Windows::Devices::Geolocation::IGeovisitMonitor> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::IGeovisitMonitorStatics> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::GeovisitMonitor> : class_type<Platform::Object, Windows::Devices::Geolocation::IGeovisitMonitor> {};
template<> struct def<Windows::Devices::Geolocation::IGeovisitTriggerDetails> : interface_type<> {};
template<> struct def<Windows::Devices::Geolocation::GeovisitTriggerDetails> : class_type<Platform::Object, Windows::Devices::Geolocation::IGeovisitTriggerDetails> {};

// uuids

template<> struct uuid<Windows::Devices::Geolocation::IGeoshape> { define_guid(0xC99CA2AF, 0xC729, 0x43C1, 0x8F, 0xAB, 0xD6, 0xDE, 0xC9, 0x14, 0xDF, 0x7E);};
template<> struct uuid<Windows::Devices::Geolocation::IGeopoint> { define_guid(0x6BFA00EB, 0xE56E, 0x49BB, 0x9C, 0xAF, 0xCB, 0xAA, 0x78, 0xA8, 0xBC, 0xEF);};
template<> struct uuid<Windows::Devices::Geolocation::IGeopointFactory> { define_guid(0xDB6B8D33, 0x76BD, 0x4E30, 0x8A, 0xF7, 0xA8, 0x44, 0xDC, 0x37, 0xB7, 0xA0);};
template<> struct uuid<Windows::Devices::Geolocation::IGeopath> { define_guid(0xE53FD7B9, 0x2DA4, 0x4714, 0xA6, 0x52, 0xDE, 0x85, 0x93, 0x28, 0x98, 0x98);};
template<> struct uuid<Windows::Devices::Geolocation::IGeopathFactory> { define_guid(0x27BEA9C8, 0xC7E7, 0x4359, 0x9B, 0x9B, 0xFC, 0xA3, 0xE0, 0x5E, 0xF5, 0x93);};
template<> struct uuid<Windows::Devices::Geolocation::IGeoboundingBox> { define_guid(0x896C80B, 0x274F, 0x43DA, 0x9A, 0x6, 0xCB, 0xFC, 0xDA, 0xEB, 0x4E, 0xC2);};
template<> struct uuid<Windows::Devices::Geolocation::IGeoboundingBoxFactory> { define_guid(0x4DFBA589, 0x411, 0x4ABC, 0xB3, 0xB5, 0x5B, 0xBC, 0xCB, 0x57, 0xD9, 0x8C);};
template<> struct uuid<Windows::Devices::Geolocation::IGeoboundingBoxStatics> { define_guid(0x67B80708, 0xE61A, 0x4CD0, 0x84, 0x1B, 0x93, 0x23, 0x37, 0x92, 0xB5, 0xCA);};
template<> struct uuid<Windows::Devices::Geolocation::IGeocoordinateSatelliteData> { define_guid(0xC32A74D9, 0x2608, 0x474C, 0x91, 0x2C, 0x6, 0xDD, 0x49, 0xF, 0x4A, 0xF7);};
template<> struct uuid<Windows::Devices::Geolocation::IVenueData> { define_guid(0x66F39187, 0x60E3, 0x4B2F, 0xB5, 0x27, 0x4F, 0x53, 0xF1, 0xC3, 0xC6, 0x77);};
template<> struct uuid<Windows::Devices::Geolocation::IGeocoordinate> { define_guid(0xEE21A3AA, 0x976A, 0x4C70, 0x80, 0x3D, 0x8, 0x3E, 0xA5, 0x5B, 0xCB, 0xC4);};
template<> struct uuid<Windows::Devices::Geolocation::IGeocoordinateWithPositionData> { define_guid(0x95E634BE, 0xDBD6, 0x40AC, 0xB8, 0xF2, 0xA6, 0x5C, 0x3, 0x40, 0xD9, 0xA6);};
template<> struct uuid<Windows::Devices::Geolocation::IGeocoordinateWithPoint> { define_guid(0xFEEA0525, 0xD22C, 0x4D46, 0xB5, 0x27, 0xB, 0x96, 0x6, 0x6F, 0xC7, 0xDB);};
template<> struct uuid<Windows::Devices::Geolocation::IGeocoordinateWithPositionSourceTimestamp> { define_guid(0x8543FC02, 0xC9F1, 0x4610, 0xAF, 0xE0, 0x8B, 0xC3, 0xA6, 0xA8, 0x70, 0x36);};
template<> struct uuid<Windows::Devices::Geolocation::IGeoposition> { define_guid(0xC18D0454, 0x7D41, 0x4FF7, 0xA9, 0x57, 0x9D, 0xFF, 0xB4, 0xEF, 0x7F, 0x5B);};
template<> struct uuid<Windows::Devices::Geolocation::IGeoposition2> { define_guid(0x7F62F697, 0x8671, 0x4B0D, 0x86, 0xF8, 0x47, 0x4A, 0x84, 0x96, 0x18, 0x7C);};
template<> struct uuid<Windows::Devices::Geolocation::ICivicAddress> { define_guid(0xA8567A1A, 0x64F4, 0x4D48, 0xBC, 0xEA, 0xF6, 0xB0, 0x8, 0xEC, 0xA3, 0x4C);};
template<> struct uuid<Windows::Devices::Geolocation::IPositionChangedEventArgs> { define_guid(0x37859CE5, 0x9D1E, 0x46C5, 0xBF, 0x3B, 0x6A, 0xD8, 0xCA, 0xC1, 0xA0, 0x93);};
template<> struct uuid<Windows::Devices::Geolocation::IStatusChangedEventArgs> { define_guid(0x3453D2DA, 0x8C93, 0x4111, 0xA2, 0x5, 0x9A, 0xEC, 0xFC, 0x9B, 0xE5, 0xC0);};
template<> struct uuid<Windows::Devices::Geolocation::IGeolocator> { define_guid(0xA9C3BF62, 0x4524, 0x4989, 0x8A, 0xA9, 0xDE, 0x1, 0x9D, 0x2E, 0x55, 0x1F);};
template<> struct uuid<Windows::Devices::Geolocation::IGeolocatorStatics2> { define_guid(0x993011A2, 0xFA1C, 0x4631, 0xA7, 0x1D, 0xD, 0xBE, 0xB1, 0x25, 0xD, 0x9C);};
template<> struct uuid<Windows::Devices::Geolocation::IGeolocatorStatics> { define_guid(0x9A8E7571, 0x2DF5, 0x4591, 0x9F, 0x87, 0xEB, 0x5F, 0xD8, 0x94, 0xE9, 0xB7);};
template<> struct uuid<Windows::Devices::Geolocation::IGeolocator2> { define_guid(0xD1B42E6D, 0x8891, 0x43B4, 0xAD, 0x36, 0x27, 0xC6, 0xFE, 0x9A, 0x97, 0xB1);};
template<> struct uuid<Windows::Devices::Geolocation::IGeolocatorWithScalarAccuracy> { define_guid(0x96F5D3C1, 0xB80F, 0x460A, 0x99, 0x4D, 0xA9, 0x6C, 0x47, 0xA5, 0x1A, 0xA4);};
template<> struct uuid<Windows::Devices::Geolocation::IGeocircle> { define_guid(0x39E45843, 0xA7F9, 0x4E63, 0x92, 0xA7, 0xBA, 0xC, 0x28, 0xD1, 0x24, 0xB1);};
template<> struct uuid<Windows::Devices::Geolocation::IGeocircleFactory> { define_guid(0xAFD6531F, 0x72B1, 0x4F7D, 0x87, 0xCC, 0x4E, 0xD4, 0xC9, 0x84, 0x9C, 0x5);};
template<> struct uuid<Windows::Devices::Geolocation::IGeovisit> { define_guid(0xB1877A76, 0x9EF6, 0x41AB, 0xA0, 0xDD, 0x79, 0x3E, 0xCE, 0x76, 0xE2, 0xDE);};
template<> struct uuid<Windows::Devices::Geolocation::IGeovisitStateChangedEventArgs> { define_guid(0xCEB4D1FF, 0x8B53, 0x4968, 0xBE, 0xED, 0x4C, 0xEC, 0xD0, 0x29, 0xCE, 0x15);};
template<> struct uuid<Windows::Devices::Geolocation::IGeovisitMonitor> { define_guid(0x80118AAF, 0x5944, 0x4591, 0x83, 0xC1, 0x39, 0x66, 0x47, 0xF5, 0x4F, 0x2C);};
template<> struct uuid<Windows::Devices::Geolocation::IGeovisitMonitorStatics> { define_guid(0xBCF976A7, 0xBBF2, 0x4CDD, 0x95, 0xCF, 0x55, 0x4C, 0x82, 0xED, 0xFB, 0x87);};
template<> struct uuid<Windows::Devices::Geolocation::IGeovisitTriggerDetails> { define_guid(0xEA770D9E, 0xD1C9, 0x454B, 0x99, 0xB7, 0xB2, 0xF8, 0xCD, 0xD2, 0x48, 0x2F);};

// types

namespace Windows { namespace Devices { namespace Geolocation {

// IGeoshape
struct IGeoshape_raw : IInspectable {
	virtual STDMETHODIMP _get_GeoshapeType(Geolocation::GeoshapeType *value) = 0;
	virtual STDMETHODIMP _get_SpatialReferenceId(unsigned *value) = 0;
	virtual STDMETHODIMP _get_AltitudeReferenceSystem(Geolocation::AltitudeReferenceSystem *value) = 0;
};
template<typename X> struct IGeoshape_adaptor : X {
	union {
		struct : property {
			Geolocation::AltitudeReferenceSystem get() { Geolocation::AltitudeReferenceSystem value; hrcheck(enc(&IGeoshape_adaptor::AltitudeReferenceSystem)->_get_AltitudeReferenceSystem(&value)); return value; }
			Geolocation::AltitudeReferenceSystem operator()() { return get(); }
			operator Geolocation::AltitudeReferenceSystem () { return get(); }
		} AltitudeReferenceSystem;
		struct : property {
			Geolocation::GeoshapeType get() { Geolocation::GeoshapeType value; hrcheck(enc(&IGeoshape_adaptor::GeoshapeType)->_get_GeoshapeType(&value)); return value; }
			Geolocation::GeoshapeType operator()() { return get(); }
			operator Geolocation::GeoshapeType () { return get(); }
		} GeoshapeType;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IGeoshape_adaptor::SpatialReferenceId)->_get_SpatialReferenceId(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
		} SpatialReferenceId;
	};
	IGeoshape_adaptor() {}
};
template<typename X> struct adapt<IGeoshape, X> : Windows::Devices::Geolocation::IGeoshape_adaptor<X> { typedef adapt IGeoshape; };
template<typename X> struct IGeoshape_unadaptor : X {
	STDMETHODIMP _get_GeoshapeType(Geolocation::GeoshapeType *value) { return hrtry([&, this] { get_prop(value, GeoshapeType); }); }
	STDMETHODIMP _get_SpatialReferenceId(unsigned *value) { return hrtry([&, this] { get_prop(value, SpatialReferenceId); }); }
	STDMETHODIMP _get_AltitudeReferenceSystem(Geolocation::AltitudeReferenceSystem *value) { return hrtry([&, this] { get_prop(value, AltitudeReferenceSystem); }); }
};
template<typename X> struct unadapt<IGeoshape, X> : Windows::Devices::Geolocation::IGeoshape_unadaptor<X> {};
struct IGeoshape : IGeoshape_raw, generate<IGeoshape> {};

// IGeopoint
struct IGeopoint_raw : IInspectable {
	virtual STDMETHODIMP _get_Position(BasicGeoposition *value);
};
template<typename X> struct IGeopoint_adaptor : X {
	union {
		struct : property {
			BasicGeoposition get() { BasicGeoposition value; hrcheck(enc(&IGeopoint_adaptor::Position)->_get_Position(&value)); return value; }
			BasicGeoposition operator()() { return get(); }
			operator BasicGeoposition () { return get(); }
		} Position;
	};
	IGeopoint_adaptor() {}
};
template<typename X> struct adapt<IGeopoint, X> : Windows::Devices::Geolocation::IGeopoint_adaptor<X> { typedef adapt IGeopoint; };
struct IGeopoint : IGeopoint_raw, generate<IGeopoint> {};

// IGeopointFactory
struct IGeopointFactory : IInspectable {
	virtual STDMETHODIMP _Create(BasicGeoposition position, Geopoint* *value);
	virtual STDMETHODIMP _CreateWithAltitudeReferenceSystem(BasicGeoposition position, AltitudeReferenceSystem altitudeReferenceSystem, Geopoint* *value);
	virtual STDMETHODIMP _CreateWithAltitudeReferenceSystemAndSpatialReferenceId(BasicGeoposition position, AltitudeReferenceSystem altitudeReferenceSystem, unsigned spatialReferenceId, Geopoint* *value);
};

// Geopoint
template<typename> struct Geopoint_statics {
	static Geopoint *activate(const BasicGeoposition& position) { Geopoint *value; hrcheck(get_activation_factory<Geopoint, IGeopointFactory>()->_Create(position, &value)); return value; }
	static Geopoint *activate(const BasicGeoposition& position, Geolocation::AltitudeReferenceSystem altitudeReferenceSystem) { Geopoint *value; hrcheck(get_activation_factory<Geopoint, IGeopointFactory>()->_CreateWithAltitudeReferenceSystem(position, altitudeReferenceSystem, &value)); return value; }
	static Geopoint *activate(const BasicGeoposition& position, Geolocation::AltitudeReferenceSystem altitudeReferenceSystem, unsigned spatialReferenceId) { Geopoint *value; hrcheck(get_activation_factory<Geopoint, IGeopointFactory>()->_CreateWithAltitudeReferenceSystemAndSpatialReferenceId(position, altitudeReferenceSystem, spatialReferenceId, &value)); return value; }
};

template<typename X> struct statics<Geopoint, X> : X, Windows::Devices::Geolocation::Geopoint_statics<void> {
	using Windows::Devices::Geolocation::Geopoint_statics<void>::activate;
	typedef typename X::root_type Geopoint;
};
struct Geopoint : generate<Geopoint> {};

// IGeopath
struct IGeopath_raw : IInspectable {
	virtual STDMETHODIMP _get_Positions(Foundation::Collections::IVectorView<BasicGeoposition>* *value);
};
template<typename X> struct IGeopath_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::Collections::IVectorView<BasicGeoposition>> get() { Foundation::Collections::IVectorView<BasicGeoposition>* value; hrcheck(enc(&IGeopath_adaptor::Positions)->_get_Positions(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<BasicGeoposition>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<BasicGeoposition>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<BasicGeoposition>> operator->() { return get(); }
		} Positions;
	};
	IGeopath_adaptor() {}
};
template<typename X> struct adapt<IGeopath, X> : Windows::Devices::Geolocation::IGeopath_adaptor<X> { typedef adapt IGeopath; };
struct IGeopath : IGeopath_raw, generate<IGeopath> {};

// IGeopathFactory
struct IGeopathFactory : IInspectable {
	virtual STDMETHODIMP _Create(Foundation::Collections::IIterable<BasicGeoposition>* positions, Geopath* *value);
	virtual STDMETHODIMP _CreateWithAltitudeReference(Foundation::Collections::IIterable<BasicGeoposition>* positions, AltitudeReferenceSystem altitudeReferenceSystem, Geopath* *value);
	virtual STDMETHODIMP _CreateWithAltitudeReferenceAndSpatialReference(Foundation::Collections::IIterable<BasicGeoposition>* positions, AltitudeReferenceSystem altitudeReferenceSystem, unsigned spatialReferenceId, Geopath* *value);
};

// Geopath
template<typename> struct Geopath_statics {
	static Geopath *activate(pptr<Foundation::Collections::IIterable<BasicGeoposition>> positions) { Geopath *value; hrcheck(get_activation_factory<Geopath, IGeopathFactory>()->_Create(to_abi(positions), &value)); return value; }
	static Geopath *activate(pptr<Foundation::Collections::IIterable<BasicGeoposition>> positions, Geolocation::AltitudeReferenceSystem altitudeReferenceSystem) { Geopath *value; hrcheck(get_activation_factory<Geopath, IGeopathFactory>()->_CreateWithAltitudeReference(to_abi(positions), altitudeReferenceSystem, &value)); return value; }
	static Geopath *activate(pptr<Foundation::Collections::IIterable<BasicGeoposition>> positions, Geolocation::AltitudeReferenceSystem altitudeReferenceSystem, unsigned spatialReferenceId) { Geopath *value; hrcheck(get_activation_factory<Geopath, IGeopathFactory>()->_CreateWithAltitudeReferenceAndSpatialReference(to_abi(positions), altitudeReferenceSystem, spatialReferenceId, &value)); return value; }
};

template<typename X> struct statics<Geopath, X> : X, Windows::Devices::Geolocation::Geopath_statics<void> {
	using Windows::Devices::Geolocation::Geopath_statics<void>::activate;
	typedef typename X::root_type Geopath;
};
struct Geopath : generate<Geopath> {};

// IGeoboundingBox
struct IGeoboundingBox_raw : IInspectable {
	virtual STDMETHODIMP _get_NorthwestCorner(BasicGeoposition *value);
	virtual STDMETHODIMP _get_SoutheastCorner(BasicGeoposition *value);
	virtual STDMETHODIMP _get_Center(BasicGeoposition *value);
	virtual STDMETHODIMP _get_MinAltitude(double *value);
	virtual STDMETHODIMP _get_MaxAltitude(double *value);
};
template<typename X> struct IGeoboundingBox_adaptor : X {
	union {
		struct : property {
			BasicGeoposition get() { BasicGeoposition value; hrcheck(enc(&IGeoboundingBox_adaptor::Center)->_get_Center(&value)); return value; }
			BasicGeoposition operator()() { return get(); }
			operator BasicGeoposition () { return get(); }
		} Center;
		struct : property {
			double get() { double value; hrcheck(enc(&IGeoboundingBox_adaptor::MaxAltitude)->_get_MaxAltitude(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} MaxAltitude;
		struct : property {
			double get() { double value; hrcheck(enc(&IGeoboundingBox_adaptor::MinAltitude)->_get_MinAltitude(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} MinAltitude;
		struct : property {
			BasicGeoposition get() { BasicGeoposition value; hrcheck(enc(&IGeoboundingBox_adaptor::NorthwestCorner)->_get_NorthwestCorner(&value)); return value; }
			BasicGeoposition operator()() { return get(); }
			operator BasicGeoposition () { return get(); }
		} NorthwestCorner;
		struct : property {
			BasicGeoposition get() { BasicGeoposition value; hrcheck(enc(&IGeoboundingBox_adaptor::SoutheastCorner)->_get_SoutheastCorner(&value)); return value; }
			BasicGeoposition operator()() { return get(); }
			operator BasicGeoposition () { return get(); }
		} SoutheastCorner;
	};
	IGeoboundingBox_adaptor() {}
};
template<typename X> struct adapt<IGeoboundingBox, X> : Windows::Devices::Geolocation::IGeoboundingBox_adaptor<X> { typedef adapt IGeoboundingBox; };
struct IGeoboundingBox : IGeoboundingBox_raw, generate<IGeoboundingBox> {};

// IGeoboundingBoxFactory
struct IGeoboundingBoxFactory : IInspectable {
	virtual STDMETHODIMP _Create(BasicGeoposition northwestCorner, BasicGeoposition southeastCorner, GeoboundingBox* *value);
	virtual STDMETHODIMP _CreateWithAltitudeReference(BasicGeoposition northwestCorner, BasicGeoposition southeastCorner, AltitudeReferenceSystem altitudeReferenceSystem, GeoboundingBox* *value);
	virtual STDMETHODIMP _CreateWithAltitudeReferenceAndSpatialReference(BasicGeoposition northwestCorner, BasicGeoposition southeastCorner, AltitudeReferenceSystem altitudeReferenceSystem, unsigned spatialReferenceId, GeoboundingBox* *value);
};

// IGeoboundingBoxStatics
struct IGeoboundingBoxStatics : IInspectable {
	virtual STDMETHODIMP _TryCompute(Foundation::Collections::IIterable<BasicGeoposition>* positions, GeoboundingBox* *value);
	virtual STDMETHODIMP _TryComputeWithAltitudeReference(Foundation::Collections::IIterable<BasicGeoposition>* positions, AltitudeReferenceSystem altitudeRefSystem, GeoboundingBox* *value);
	virtual STDMETHODIMP _TryComputeWithAltitudeReferenceAndSpatialReference(Foundation::Collections::IIterable<BasicGeoposition>* positions, AltitudeReferenceSystem altitudeRefSystem, unsigned spatialReferenceId, GeoboundingBox* *value);
};

// GeoboundingBox
template<typename> struct GeoboundingBox_statics {
	static ptr<GeoboundingBox> TryCompute(pptr<Foundation::Collections::IIterable<BasicGeoposition>> positions) { GeoboundingBox* value; hrcheck(get_activation_factory<GeoboundingBox, IGeoboundingBoxStatics>()->_TryCompute(to_abi(positions), &value)); return from_abi(value); }
	static ptr<GeoboundingBox> TryCompute(pptr<Foundation::Collections::IIterable<BasicGeoposition>> positions, Geolocation::AltitudeReferenceSystem altitudeRefSystem) { GeoboundingBox* value; hrcheck(get_activation_factory<GeoboundingBox, IGeoboundingBoxStatics>()->_TryComputeWithAltitudeReference(to_abi(positions), altitudeRefSystem, &value)); return from_abi(value); }
	static ptr<GeoboundingBox> TryCompute(pptr<Foundation::Collections::IIterable<BasicGeoposition>> positions, Geolocation::AltitudeReferenceSystem altitudeRefSystem, unsigned spatialReferenceId) { GeoboundingBox* value; hrcheck(get_activation_factory<GeoboundingBox, IGeoboundingBoxStatics>()->_TryComputeWithAltitudeReferenceAndSpatialReference(to_abi(positions), altitudeRefSystem, spatialReferenceId, &value)); return from_abi(value); }
	static GeoboundingBox *activate(const BasicGeoposition& northwestCorner, const BasicGeoposition& southeastCorner) { GeoboundingBox *value; hrcheck(get_activation_factory<GeoboundingBox, IGeoboundingBoxFactory>()->_Create(northwestCorner, southeastCorner, &value)); return value; }
	static GeoboundingBox *activate(const BasicGeoposition& northwestCorner, const BasicGeoposition& southeastCorner, Geolocation::AltitudeReferenceSystem altitudeReferenceSystem) { GeoboundingBox *value; hrcheck(get_activation_factory<GeoboundingBox, IGeoboundingBoxFactory>()->_CreateWithAltitudeReference(northwestCorner, southeastCorner, altitudeReferenceSystem, &value)); return value; }
	static GeoboundingBox *activate(const BasicGeoposition& northwestCorner, const BasicGeoposition& southeastCorner, Geolocation::AltitudeReferenceSystem altitudeReferenceSystem, unsigned spatialReferenceId) { GeoboundingBox *value; hrcheck(get_activation_factory<GeoboundingBox, IGeoboundingBoxFactory>()->_CreateWithAltitudeReferenceAndSpatialReference(northwestCorner, southeastCorner, altitudeReferenceSystem, spatialReferenceId, &value)); return value; }
};

template<typename X> struct statics<GeoboundingBox, X> : X, Windows::Devices::Geolocation::GeoboundingBox_statics<void> {
	using Windows::Devices::Geolocation::GeoboundingBox_statics<void>::activate;
	typedef typename X::root_type GeoboundingBox;
};
struct GeoboundingBox : generate<GeoboundingBox> {};

// IGeocoordinateSatelliteData
struct IGeocoordinateSatelliteData_raw : IInspectable {
	virtual STDMETHODIMP _get_PositionDilutionOfPrecision(Foundation::IReference<double>* *ppValue);
	virtual STDMETHODIMP _get_HorizontalDilutionOfPrecision(Foundation::IReference<double>* *ppValue);
	virtual STDMETHODIMP _get_VerticalDilutionOfPrecision(Foundation::IReference<double>* *ppValue);
};
template<typename X> struct IGeocoordinateSatelliteData_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<double>> get() { Foundation::IReference<double>* ppValue; hrcheck(enc(&IGeocoordinateSatelliteData_adaptor::HorizontalDilutionOfPrecision)->_get_HorizontalDilutionOfPrecision(&ppValue)); return from_abi(ppValue); }
			ptr<Foundation::IReference<double>> operator()() { return get(); }
			operator ptr<Foundation::IReference<double>> () { return get(); }
			ptr<Foundation::IReference<double>> operator->() { return get(); }
		} HorizontalDilutionOfPrecision;
		struct : property {
			ptr<Foundation::IReference<double>> get() { Foundation::IReference<double>* ppValue; hrcheck(enc(&IGeocoordinateSatelliteData_adaptor::PositionDilutionOfPrecision)->_get_PositionDilutionOfPrecision(&ppValue)); return from_abi(ppValue); }
			ptr<Foundation::IReference<double>> operator()() { return get(); }
			operator ptr<Foundation::IReference<double>> () { return get(); }
			ptr<Foundation::IReference<double>> operator->() { return get(); }
		} PositionDilutionOfPrecision;
		struct : property {
			ptr<Foundation::IReference<double>> get() { Foundation::IReference<double>* ppValue; hrcheck(enc(&IGeocoordinateSatelliteData_adaptor::VerticalDilutionOfPrecision)->_get_VerticalDilutionOfPrecision(&ppValue)); return from_abi(ppValue); }
			ptr<Foundation::IReference<double>> operator()() { return get(); }
			operator ptr<Foundation::IReference<double>> () { return get(); }
			ptr<Foundation::IReference<double>> operator->() { return get(); }
		} VerticalDilutionOfPrecision;
	};
	IGeocoordinateSatelliteData_adaptor() {}
};
template<typename X> struct adapt<IGeocoordinateSatelliteData, X> : Windows::Devices::Geolocation::IGeocoordinateSatelliteData_adaptor<X> { typedef adapt IGeocoordinateSatelliteData; };
struct IGeocoordinateSatelliteData : IGeocoordinateSatelliteData_raw, generate<IGeocoordinateSatelliteData> {};

// GeocoordinateSatelliteData
template<typename X> struct statics<GeocoordinateSatelliteData, X> : X {
	typedef typename X::root_type GeocoordinateSatelliteData;
};
struct GeocoordinateSatelliteData : generate<GeocoordinateSatelliteData> {};

// IVenueData
struct IVenueData_raw : IInspectable {
	virtual STDMETHODIMP _get_Id(HSTRING *value);
	virtual STDMETHODIMP _get_Level(HSTRING *value);
};
template<typename X> struct IVenueData_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVenueData_adaptor::Id)->_get_Id(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Id;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IVenueData_adaptor::Level)->_get_Level(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Level;
	};
	IVenueData_adaptor() {}
};
template<typename X> struct adapt<IVenueData, X> : Windows::Devices::Geolocation::IVenueData_adaptor<X> { typedef adapt IVenueData; };
struct IVenueData : IVenueData_raw, generate<IVenueData> {};

// VenueData
template<typename X> struct statics<VenueData, X> : X {
	typedef typename X::root_type VenueData;
};
struct VenueData : generate<VenueData> {};

// IGeocoordinate
struct IGeocoordinate_raw : IInspectable {
	virtual STDMETHODIMP _get_Latitude(double *value);
	virtual STDMETHODIMP _get_Longitude(double *value);
	virtual STDMETHODIMP _get_Altitude(Foundation::IReference<double>* *value);
	virtual STDMETHODIMP _get_Accuracy(double *value);
	virtual STDMETHODIMP _get_AltitudeAccuracy(Foundation::IReference<double>* *value);
	virtual STDMETHODIMP _get_Heading(Foundation::IReference<double>* *value);
	virtual STDMETHODIMP _get_Speed(Foundation::IReference<double>* *value);
	virtual STDMETHODIMP _get_Timestamp(Foundation::DateTime *value);
};
template<typename X> struct IGeocoordinate_adaptor : X {
	union {
		struct : property {
			double get() { double value; hrcheck(enc(&IGeocoordinate_adaptor::Accuracy)->_get_Accuracy(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} Accuracy;
		struct : property {
			ptr<Foundation::IReference<double>> get() { Foundation::IReference<double>* value; hrcheck(enc(&IGeocoordinate_adaptor::Altitude)->_get_Altitude(&value)); return from_abi(value); }
			ptr<Foundation::IReference<double>> operator()() { return get(); }
			operator ptr<Foundation::IReference<double>> () { return get(); }
			ptr<Foundation::IReference<double>> operator->() { return get(); }
		} Altitude;
		struct : property {
			ptr<Foundation::IReference<double>> get() { Foundation::IReference<double>* value; hrcheck(enc(&IGeocoordinate_adaptor::AltitudeAccuracy)->_get_AltitudeAccuracy(&value)); return from_abi(value); }
			ptr<Foundation::IReference<double>> operator()() { return get(); }
			operator ptr<Foundation::IReference<double>> () { return get(); }
			ptr<Foundation::IReference<double>> operator->() { return get(); }
		} AltitudeAccuracy;
		struct : property {
			ptr<Foundation::IReference<double>> get() { Foundation::IReference<double>* value; hrcheck(enc(&IGeocoordinate_adaptor::Heading)->_get_Heading(&value)); return from_abi(value); }
			ptr<Foundation::IReference<double>> operator()() { return get(); }
			operator ptr<Foundation::IReference<double>> () { return get(); }
			ptr<Foundation::IReference<double>> operator->() { return get(); }
		} Heading;
		struct : property {
			double get() { double value; hrcheck(enc(&IGeocoordinate_adaptor::Latitude)->_get_Latitude(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} Latitude;
		struct : property {
			double get() { double value; hrcheck(enc(&IGeocoordinate_adaptor::Longitude)->_get_Longitude(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} Longitude;
		struct : property {
			ptr<Foundation::IReference<double>> get() { Foundation::IReference<double>* value; hrcheck(enc(&IGeocoordinate_adaptor::Speed)->_get_Speed(&value)); return from_abi(value); }
			ptr<Foundation::IReference<double>> operator()() { return get(); }
			operator ptr<Foundation::IReference<double>> () { return get(); }
			ptr<Foundation::IReference<double>> operator->() { return get(); }
		} Speed;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IGeocoordinate_adaptor::Timestamp)->_get_Timestamp(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} Timestamp;
	};
	IGeocoordinate_adaptor() {}
};
template<typename X> struct adapt<IGeocoordinate, X> : Windows::Devices::Geolocation::IGeocoordinate_adaptor<X> { typedef adapt IGeocoordinate; };
struct IGeocoordinate : IGeocoordinate_raw, generate<IGeocoordinate> {};

// IGeocoordinateWithPositionData
struct IGeocoordinateWithPositionData_raw : IInspectable {
	virtual STDMETHODIMP _get_PositionSource(Geolocation::PositionSource *pValue);
	virtual STDMETHODIMP _get_SatelliteData(GeocoordinateSatelliteData* *ppValue);
};
template<typename X> struct IGeocoordinateWithPositionData_adaptor : X {
	union {
		struct : property {
			Geolocation::PositionSource get() { Geolocation::PositionSource pValue; hrcheck(enc(&IGeocoordinateWithPositionData_adaptor::PositionSource)->_get_PositionSource(&pValue)); return pValue; }
			Geolocation::PositionSource operator()() { return get(); }
			operator Geolocation::PositionSource () { return get(); }
		} PositionSource;
		struct : property {
			ptr<GeocoordinateSatelliteData> get() { GeocoordinateSatelliteData* ppValue; hrcheck(enc(&IGeocoordinateWithPositionData_adaptor::SatelliteData)->_get_SatelliteData(&ppValue)); return from_abi(ppValue); }
			ptr<GeocoordinateSatelliteData> operator()() { return get(); }
			operator ptr<GeocoordinateSatelliteData> () { return get(); }
			ptr<GeocoordinateSatelliteData> operator->() { return get(); }
		} SatelliteData;
	};
	IGeocoordinateWithPositionData_adaptor() {}
};
template<typename X> struct adapt<IGeocoordinateWithPositionData, X> : Windows::Devices::Geolocation::IGeocoordinateWithPositionData_adaptor<X> { typedef adapt IGeocoordinateWithPositionData; };
struct IGeocoordinateWithPositionData : IGeocoordinateWithPositionData_raw, generate<IGeocoordinateWithPositionData> {};

// IGeocoordinateWithPoint
struct IGeocoordinateWithPoint_raw : IInspectable {
	virtual STDMETHODIMP _get_Point(Geopoint* *value);
};
template<typename X> struct IGeocoordinateWithPoint_adaptor : X {
	union {
		struct : property {
			ptr<Geopoint> get() { Geopoint* value; hrcheck(enc(&IGeocoordinateWithPoint_adaptor::Point)->_get_Point(&value)); return from_abi(value); }
			ptr<Geopoint> operator()() { return get(); }
			operator ptr<Geopoint> () { return get(); }
			ptr<Geopoint> operator->() { return get(); }
		} Point;
	};
	IGeocoordinateWithPoint_adaptor() {}
};
template<typename X> struct adapt<IGeocoordinateWithPoint, X> : Windows::Devices::Geolocation::IGeocoordinateWithPoint_adaptor<X> { typedef adapt IGeocoordinateWithPoint; };
struct IGeocoordinateWithPoint : IGeocoordinateWithPoint_raw, generate<IGeocoordinateWithPoint> {};

// IGeocoordinateWithPositionSourceTimestamp
struct IGeocoordinateWithPositionSourceTimestamp_raw : IInspectable {
	virtual STDMETHODIMP _get_PositionSourceTimestamp(Foundation::IReference<Foundation::DateTime>* *value);
};
template<typename X> struct IGeocoordinateWithPositionSourceTimestamp_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<Foundation::DateTime>> get() { Foundation::IReference<Foundation::DateTime>* value; hrcheck(enc(&IGeocoordinateWithPositionSourceTimestamp_adaptor::PositionSourceTimestamp)->_get_PositionSourceTimestamp(&value)); return from_abi(value); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator()() { return get(); }
			operator ptr<Foundation::IReference<Foundation::DateTime>> () { return get(); }
			ptr<Foundation::IReference<Foundation::DateTime>> operator->() { return get(); }
		} PositionSourceTimestamp;
	};
	IGeocoordinateWithPositionSourceTimestamp_adaptor() {}
};
template<typename X> struct adapt<IGeocoordinateWithPositionSourceTimestamp, X> : Windows::Devices::Geolocation::IGeocoordinateWithPositionSourceTimestamp_adaptor<X> { typedef adapt IGeocoordinateWithPositionSourceTimestamp; };
struct IGeocoordinateWithPositionSourceTimestamp : IGeocoordinateWithPositionSourceTimestamp_raw, generate<IGeocoordinateWithPositionSourceTimestamp> {};

// IGeoposition
struct IGeoposition_raw : IInspectable {
	virtual STDMETHODIMP _get_Coordinate(Geocoordinate* *value);
	virtual STDMETHODIMP _get_CivicAddress(Geolocation::CivicAddress* *value);
};
template<typename X> struct IGeoposition_adaptor : X {
	union {
		struct : property {
			ptr<Geolocation::CivicAddress> get() { Geolocation::CivicAddress* value; hrcheck(enc(&IGeoposition_adaptor::CivicAddress)->_get_CivicAddress(&value)); return from_abi(value); }
			ptr<Geolocation::CivicAddress> operator()() { return get(); }
			operator ptr<Geolocation::CivicAddress> () { return get(); }
			ptr<Geolocation::CivicAddress> operator->() { return get(); }
		} CivicAddress;
		struct : property {
			ptr<Geocoordinate> get() { Geocoordinate* value; hrcheck(enc(&IGeoposition_adaptor::Coordinate)->_get_Coordinate(&value)); return from_abi(value); }
			ptr<Geocoordinate> operator()() { return get(); }
			operator ptr<Geocoordinate> () { return get(); }
			ptr<Geocoordinate> operator->() { return get(); }
		} Coordinate;
	};
	IGeoposition_adaptor() {}
};
template<typename X> struct adapt<IGeoposition, X> : Windows::Devices::Geolocation::IGeoposition_adaptor<X> { typedef adapt IGeoposition; };
struct IGeoposition : IGeoposition_raw, generate<IGeoposition> {};

// IGeoposition2
struct IGeoposition2_raw : IInspectable {
	virtual STDMETHODIMP _get_VenueData(Geolocation::VenueData* *value);
};
template<typename X> struct IGeoposition2_adaptor : X {
	union {
		struct : property {
			ptr<Geolocation::VenueData> get() { Geolocation::VenueData* value; hrcheck(enc(&IGeoposition2_adaptor::VenueData)->_get_VenueData(&value)); return from_abi(value); }
			ptr<Geolocation::VenueData> operator()() { return get(); }
			operator ptr<Geolocation::VenueData> () { return get(); }
			ptr<Geolocation::VenueData> operator->() { return get(); }
		} VenueData;
	};
	IGeoposition2_adaptor() {}
};
template<typename X> struct adapt<IGeoposition2, X> : Windows::Devices::Geolocation::IGeoposition2_adaptor<X> { typedef adapt IGeoposition2; };
struct IGeoposition2 : IGeoposition2_raw, generate<IGeoposition2> {};

// Geocoordinate
template<typename X> struct statics<Geocoordinate, X> : X {
	typedef typename X::root_type Geocoordinate;
};
struct Geocoordinate : generate<Geocoordinate> {};

// ICivicAddress
struct ICivicAddress_raw : IInspectable {
	virtual STDMETHODIMP _get_Country(HSTRING *value);
	virtual STDMETHODIMP _get_State(HSTRING *value);
	virtual STDMETHODIMP _get_City(HSTRING *value);
	virtual STDMETHODIMP _get_PostalCode(HSTRING *value);
	virtual STDMETHODIMP _get_Timestamp(Foundation::DateTime *value);
};
template<typename X> struct ICivicAddress_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICivicAddress_adaptor::City)->_get_City(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} City;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICivicAddress_adaptor::Country)->_get_Country(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} Country;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICivicAddress_adaptor::PostalCode)->_get_PostalCode(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} PostalCode;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&ICivicAddress_adaptor::State)->_get_State(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} State;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&ICivicAddress_adaptor::Timestamp)->_get_Timestamp(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} Timestamp;
	};
	ICivicAddress_adaptor() {}
};
template<typename X> struct adapt<ICivicAddress, X> : Windows::Devices::Geolocation::ICivicAddress_adaptor<X> { typedef adapt ICivicAddress; };
struct ICivicAddress : ICivicAddress_raw, generate<ICivicAddress> {};

// CivicAddress
template<typename X> struct statics<CivicAddress, X> : X {
	typedef typename X::root_type CivicAddress;
};
struct CivicAddress : generate<CivicAddress> {};

// Geoposition
template<typename X> struct statics<Geoposition, X> : X {
	typedef typename X::root_type Geoposition;
};
struct Geoposition : generate<Geoposition> {};

// IPositionChangedEventArgs
struct IPositionChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Position(Geoposition* *value);
};
template<typename X> struct IPositionChangedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Geoposition> get() { Geoposition* value; hrcheck(enc(&IPositionChangedEventArgs_adaptor::Position)->_get_Position(&value)); return from_abi(value); }
			ptr<Geoposition> operator()() { return get(); }
			operator ptr<Geoposition> () { return get(); }
			ptr<Geoposition> operator->() { return get(); }
		} Position;
	};
	IPositionChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IPositionChangedEventArgs, X> : Windows::Devices::Geolocation::IPositionChangedEventArgs_adaptor<X> { typedef adapt IPositionChangedEventArgs; };
struct IPositionChangedEventArgs : IPositionChangedEventArgs_raw, generate<IPositionChangedEventArgs> {};

// PositionChangedEventArgs
template<typename X> struct statics<PositionChangedEventArgs, X> : X {
	typedef typename X::root_type PositionChangedEventArgs;
};
struct PositionChangedEventArgs : generate<PositionChangedEventArgs> {};

// IStatusChangedEventArgs
struct IStatusChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Status(PositionStatus *value);
};
template<typename X> struct IStatusChangedEventArgs_adaptor : X {
	union {
		struct : property {
			PositionStatus get() { PositionStatus value; hrcheck(enc(&IStatusChangedEventArgs_adaptor::Status)->_get_Status(&value)); return value; }
			PositionStatus operator()() { return get(); }
			operator PositionStatus () { return get(); }
		} Status;
	};
	IStatusChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IStatusChangedEventArgs, X> : Windows::Devices::Geolocation::IStatusChangedEventArgs_adaptor<X> { typedef adapt IStatusChangedEventArgs; };
struct IStatusChangedEventArgs : IStatusChangedEventArgs_raw, generate<IStatusChangedEventArgs> {};

// StatusChangedEventArgs
template<typename X> struct statics<StatusChangedEventArgs, X> : X {
	typedef typename X::root_type StatusChangedEventArgs;
};
struct StatusChangedEventArgs : generate<StatusChangedEventArgs> {};

// IGeolocator
struct IGeolocator_raw : IInspectable {
	virtual STDMETHODIMP _get_DesiredAccuracy(PositionAccuracy *value);
	virtual STDMETHODIMP _put_DesiredAccuracy(PositionAccuracy value);
	virtual STDMETHODIMP _get_MovementThreshold(double *value);
	virtual STDMETHODIMP _put_MovementThreshold(double value);
	virtual STDMETHODIMP _get_ReportInterval(unsigned *value);
	virtual STDMETHODIMP _put_ReportInterval(unsigned value);
	virtual STDMETHODIMP _get_LocationStatus(PositionStatus *value);
	virtual STDMETHODIMP _GetGeopositionAsync(Foundation::IAsyncOperation<Geoposition*>* *value);
	virtual STDMETHODIMP _GetGeopositionAsyncWithAgeAndTimeout(Foundation::TimeSpan maximumAge, Foundation::TimeSpan timeout, Foundation::IAsyncOperation<Geoposition*>* *value);
	virtual STDMETHODIMP _add_PositionChanged(Foundation::TypedEventHandler<Geolocator*, PositionChangedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_PositionChanged(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_StatusChanged(Foundation::TypedEventHandler<Geolocator*, StatusChangedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_StatusChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IGeolocator_adaptor : X {
	union {
		struct : property {
			PositionAccuracy get() { PositionAccuracy value; hrcheck(enc(&IGeolocator_adaptor::DesiredAccuracy)->_get_DesiredAccuracy(&value)); return value; }
			PositionAccuracy operator()() { return get(); }
			operator PositionAccuracy () { return get(); }
			void put(PositionAccuracy value) { hrcheck(enc(&IGeolocator_adaptor::DesiredAccuracy)->_put_DesiredAccuracy(value)); }
			void operator=(PositionAccuracy value) { put(value); }
			void operator()(PositionAccuracy value) { put(value); }
		} DesiredAccuracy;
		struct : property {
			PositionStatus get() { PositionStatus value; hrcheck(enc(&IGeolocator_adaptor::LocationStatus)->_get_LocationStatus(&value)); return value; }
			PositionStatus operator()() { return get(); }
			operator PositionStatus () { return get(); }
		} LocationStatus;
		struct : property {
			double get() { double value; hrcheck(enc(&IGeolocator_adaptor::MovementThreshold)->_get_MovementThreshold(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
			void put(double value) { hrcheck(enc(&IGeolocator_adaptor::MovementThreshold)->_put_MovementThreshold(value)); }
			void operator=(double value) { put(value); }
			void operator()(double value) { put(value); }
		} MovementThreshold;
		struct : property {
			unsigned get() { unsigned value; hrcheck(enc(&IGeolocator_adaptor::ReportInterval)->_get_ReportInterval(&value)); return value; }
			unsigned operator()() { return get(); }
			operator unsigned () { return get(); }
			void put(unsigned value) { hrcheck(enc(&IGeolocator_adaptor::ReportInterval)->_put_ReportInterval(value)); }
			void operator=(unsigned value) { put(value); }
			void operator()(unsigned value) { put(value); }
		} ReportInterval;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<Geolocator>, ptr<PositionChangedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGeolocator_adaptor::PositionChanged)->_add_PositionChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGeolocator_adaptor::PositionChanged)->_remove_PositionChanged(token)); }
		} PositionChanged;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<Geolocator>, ptr<StatusChangedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGeolocator_adaptor::StatusChanged)->_add_StatusChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGeolocator_adaptor::StatusChanged)->_remove_StatusChanged(token)); }
		} StatusChanged;
	};
	ptr<Foundation::IAsyncOperation<ptr<Geoposition>>> GetGeopositionAsync() { Foundation::IAsyncOperation<Geoposition*>* value; hrcheck(X::get()->_GetGeopositionAsync(&value)); return from_abi(value); }
	ptr<Foundation::IAsyncOperation<ptr<Geoposition>>> GetGeopositionAsync(const Foundation::TimeSpan& maximumAge, const Foundation::TimeSpan& timeout) { Foundation::IAsyncOperation<Geoposition*>* value; hrcheck(X::get()->_GetGeopositionAsyncWithAgeAndTimeout(maximumAge, timeout, &value)); return from_abi(value); }
	IGeolocator_adaptor() {}
};
template<typename X> struct adapt<IGeolocator, X> : Windows::Devices::Geolocation::IGeolocator_adaptor<X> { typedef adapt IGeolocator; };
struct IGeolocator : IGeolocator_raw, generate<IGeolocator> {};

// IGeolocatorStatics2
struct IGeolocatorStatics2 : IInspectable {
	virtual STDMETHODIMP _get_IsDefaultGeopositionRecommended(bool *value);
	virtual STDMETHODIMP _put_DefaultGeoposition(Foundation::IReference<BasicGeoposition>* value);
	virtual STDMETHODIMP _get_DefaultGeoposition(Foundation::IReference<BasicGeoposition>* *value);
};

// IGeolocatorStatics
struct IGeolocatorStatics : IInspectable {
	virtual STDMETHODIMP _RequestAccessAsync(Foundation::IAsyncOperation<GeolocationAccessStatus>* *result);
	virtual STDMETHODIMP _GetGeopositionHistoryAsync(Foundation::DateTime startTime, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Geoposition*>*>* *result);
	virtual STDMETHODIMP _GetGeopositionHistoryWithDurationAsync(Foundation::DateTime startTime, Foundation::TimeSpan duration, Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Geoposition*>*>* *result);
};

// IGeolocator2
struct IGeolocator2_raw : IInspectable {
	virtual STDMETHODIMP _AllowFallbackToConsentlessPositions();
};
template<typename X> struct IGeolocator2_adaptor : X {
	void AllowFallbackToConsentlessPositions() { hrcheck(X::get()->_AllowFallbackToConsentlessPositions()); }
};
template<typename X> struct adapt<IGeolocator2, X> : Windows::Devices::Geolocation::IGeolocator2_adaptor<X> { typedef adapt IGeolocator2; };
struct IGeolocator2 : IGeolocator2_raw, generate<IGeolocator2> {};

// IGeolocatorWithScalarAccuracy
struct IGeolocatorWithScalarAccuracy_raw : IInspectable {
	virtual STDMETHODIMP _get_DesiredAccuracyInMeters(Foundation::IReference<unsigned>* *value);
	virtual STDMETHODIMP _put_DesiredAccuracyInMeters(Foundation::IReference<unsigned>* value);
};
template<typename X> struct IGeolocatorWithScalarAccuracy_adaptor : X {
	union {
		struct : property {
			ptr<Foundation::IReference<unsigned>> get() { Foundation::IReference<unsigned>* value; hrcheck(enc(&IGeolocatorWithScalarAccuracy_adaptor::DesiredAccuracyInMeters)->_get_DesiredAccuracyInMeters(&value)); return from_abi(value); }
			ptr<Foundation::IReference<unsigned>> operator()() { return get(); }
			operator ptr<Foundation::IReference<unsigned>> () { return get(); }
			ptr<Foundation::IReference<unsigned>> operator->() { return get(); }
			void put(pptr<Foundation::IReference<unsigned>> value) { hrcheck(enc(&IGeolocatorWithScalarAccuracy_adaptor::DesiredAccuracyInMeters)->_put_DesiredAccuracyInMeters(to_abi(value))); }
			void operator=(pptr<Foundation::IReference<unsigned>> value) { put(to_abi(value)); }
			void operator()(pptr<Foundation::IReference<unsigned>> value) { put(to_abi(value)); }
		} DesiredAccuracyInMeters;
	};
	IGeolocatorWithScalarAccuracy_adaptor() {}
};
template<typename X> struct adapt<IGeolocatorWithScalarAccuracy, X> : Windows::Devices::Geolocation::IGeolocatorWithScalarAccuracy_adaptor<X> { typedef adapt IGeolocatorWithScalarAccuracy; };
struct IGeolocatorWithScalarAccuracy : IGeolocatorWithScalarAccuracy_raw, generate<IGeolocatorWithScalarAccuracy> {};

// Geolocator
template<typename> struct Geolocator_statics {
	static struct _DefaultGeoposition : property {
		ptr<Foundation::IReference<BasicGeoposition>> get() { Foundation::IReference<BasicGeoposition>* value; hrcheck(get_activation_factory<Geolocator, IGeolocatorStatics2>()->_get_DefaultGeoposition(&value)); return from_abi(value); }
		ptr<Foundation::IReference<BasicGeoposition>> operator()() { return get(); }
		operator ptr<Foundation::IReference<BasicGeoposition>> () { return get(); }
		ptr<Foundation::IReference<BasicGeoposition>> operator->() { return get(); }
		void put(pptr<Foundation::IReference<BasicGeoposition>> value) { hrcheck(get_activation_factory<Geolocator, IGeolocatorStatics2>()->_put_DefaultGeoposition(to_abi(value))); }
		void operator=(pptr<Foundation::IReference<BasicGeoposition>> value) { put(to_abi(value)); }
		void operator()(pptr<Foundation::IReference<BasicGeoposition>> value) { put(to_abi(value)); }
	} DefaultGeoposition;
	static struct _IsDefaultGeopositionRecommended : property {
		bool get() { bool value; hrcheck(get_activation_factory<Geolocator, IGeolocatorStatics2>()->_get_IsDefaultGeopositionRecommended(&value)); return value; }
		bool operator()() { return get(); }
		operator bool () { return get(); }
	} IsDefaultGeopositionRecommended;
	static ptr<Foundation::IAsyncOperation<GeolocationAccessStatus>> RequestAccessAsync() { Foundation::IAsyncOperation<GeolocationAccessStatus>* result; hrcheck(get_activation_factory<Geolocator, IGeolocatorStatics>()->_RequestAccessAsync(&result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<Geoposition>>>>> GetGeopositionHistoryAsync(const Foundation::DateTime& startTime) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Geoposition*>*>* result; hrcheck(get_activation_factory<Geolocator, IGeolocatorStatics>()->_GetGeopositionHistoryAsync(startTime, &result)); return from_abi(result); }
	static ptr<Foundation::IAsyncOperation<ptr<Foundation::Collections::IVectorView<ptr<Geoposition>>>>> GetGeopositionHistoryAsync(const Foundation::DateTime& startTime, const Foundation::TimeSpan& duration) { Foundation::IAsyncOperation<Foundation::Collections::IVectorView<Geoposition*>*>* result; hrcheck(get_activation_factory<Geolocator, IGeolocatorStatics>()->_GetGeopositionHistoryWithDurationAsync(startTime, duration, &result)); return from_abi(result); }
};
template<typename X> typename Geolocator_statics<X>::_DefaultGeoposition Geolocator_statics<X>::DefaultGeoposition;
template<typename X> typename Geolocator_statics<X>::_IsDefaultGeopositionRecommended Geolocator_statics<X>::IsDefaultGeopositionRecommended;

template<typename X> struct statics<Geolocator, X> : X, Windows::Devices::Geolocation::Geolocator_statics<void> {
	typedef typename X::root_type Geolocator;
};
struct Geolocator : generate<Geolocator> {
	using IGeolocator::GetGeopositionAsync;
};

// IGeocircle
struct IGeocircle_raw : IInspectable {
	virtual STDMETHODIMP _get_Center(BasicGeoposition *value);
	virtual STDMETHODIMP _get_Radius(double *value);
};
template<typename X> struct IGeocircle_adaptor : X {
	union {
		struct : property {
			BasicGeoposition get() { BasicGeoposition value; hrcheck(enc(&IGeocircle_adaptor::Center)->_get_Center(&value)); return value; }
			BasicGeoposition operator()() { return get(); }
			operator BasicGeoposition () { return get(); }
		} Center;
		struct : property {
			double get() { double value; hrcheck(enc(&IGeocircle_adaptor::Radius)->_get_Radius(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} Radius;
	};
	IGeocircle_adaptor() {}
};
template<typename X> struct adapt<IGeocircle, X> : Windows::Devices::Geolocation::IGeocircle_adaptor<X> { typedef adapt IGeocircle; };
struct IGeocircle : IGeocircle_raw, generate<IGeocircle> {};

// IGeocircleFactory
struct IGeocircleFactory : IInspectable {
	virtual STDMETHODIMP _Create(BasicGeoposition position, double radius, Geocircle* *value);
	virtual STDMETHODIMP _CreateWithAltitudeReferenceSystem(BasicGeoposition position, double radius, AltitudeReferenceSystem altitudeReferenceSystem, Geocircle* *value);
	virtual STDMETHODIMP _CreateWithAltitudeReferenceSystemAndSpatialReferenceId(BasicGeoposition position, double radius, AltitudeReferenceSystem altitudeReferenceSystem, unsigned spatialReferenceId, Geocircle* *value);
};

// Geocircle
template<typename> struct Geocircle_statics {
	static Geocircle *activate(const BasicGeoposition& position, double radius) { Geocircle *value; hrcheck(get_activation_factory<Geocircle, IGeocircleFactory>()->_Create(position, radius, &value)); return value; }
	static Geocircle *activate(const BasicGeoposition& position, double radius, Geolocation::AltitudeReferenceSystem altitudeReferenceSystem) { Geocircle *value; hrcheck(get_activation_factory<Geocircle, IGeocircleFactory>()->_CreateWithAltitudeReferenceSystem(position, radius, altitudeReferenceSystem, &value)); return value; }
	static Geocircle *activate(const BasicGeoposition& position, double radius, Geolocation::AltitudeReferenceSystem altitudeReferenceSystem, unsigned spatialReferenceId) { Geocircle *value; hrcheck(get_activation_factory<Geocircle, IGeocircleFactory>()->_CreateWithAltitudeReferenceSystemAndSpatialReferenceId(position, radius, altitudeReferenceSystem, spatialReferenceId, &value)); return value; }
};

template<typename X> struct statics<Geocircle, X> : X, Windows::Devices::Geolocation::Geocircle_statics<void> {
	using Windows::Devices::Geolocation::Geocircle_statics<void>::activate;
	typedef typename X::root_type Geocircle;
};
struct Geocircle : generate<Geocircle> {};

// IGeovisit
struct IGeovisit_raw : IInspectable {
	virtual STDMETHODIMP _get_Position(Geoposition* *value);
	virtual STDMETHODIMP _get_StateChange(VisitStateChange *value);
	virtual STDMETHODIMP _get_Timestamp(Foundation::DateTime *value);
};
template<typename X> struct IGeovisit_adaptor : X {
	union {
		struct : property {
			ptr<Geoposition> get() { Geoposition* value; hrcheck(enc(&IGeovisit_adaptor::Position)->_get_Position(&value)); return from_abi(value); }
			ptr<Geoposition> operator()() { return get(); }
			operator ptr<Geoposition> () { return get(); }
			ptr<Geoposition> operator->() { return get(); }
		} Position;
		struct : property {
			VisitStateChange get() { VisitStateChange value; hrcheck(enc(&IGeovisit_adaptor::StateChange)->_get_StateChange(&value)); return value; }
			VisitStateChange operator()() { return get(); }
			operator VisitStateChange () { return get(); }
		} StateChange;
		struct : property {
			Foundation::DateTime get() { Foundation::DateTime value; hrcheck(enc(&IGeovisit_adaptor::Timestamp)->_get_Timestamp(&value)); return value; }
			Foundation::DateTime operator()() { return get(); }
			operator Foundation::DateTime () { return get(); }
		} Timestamp;
	};
	IGeovisit_adaptor() {}
};
template<typename X> struct adapt<IGeovisit, X> : Windows::Devices::Geolocation::IGeovisit_adaptor<X> { typedef adapt IGeovisit; };
struct IGeovisit : IGeovisit_raw, generate<IGeovisit> {};

// Geovisit
template<typename X> struct statics<Geovisit, X> : X {
	typedef typename X::root_type Geovisit;
};
struct Geovisit : generate<Geovisit> {};

// IGeovisitStateChangedEventArgs
struct IGeovisitStateChangedEventArgs_raw : IInspectable {
	virtual STDMETHODIMP _get_Visit(Geovisit* *value);
};
template<typename X> struct IGeovisitStateChangedEventArgs_adaptor : X {
	union {
		struct : property {
			ptr<Geovisit> get() { Geovisit* value; hrcheck(enc(&IGeovisitStateChangedEventArgs_adaptor::Visit)->_get_Visit(&value)); return from_abi(value); }
			ptr<Geovisit> operator()() { return get(); }
			operator ptr<Geovisit> () { return get(); }
			ptr<Geovisit> operator->() { return get(); }
		} Visit;
	};
	IGeovisitStateChangedEventArgs_adaptor() {}
};
template<typename X> struct adapt<IGeovisitStateChangedEventArgs, X> : Windows::Devices::Geolocation::IGeovisitStateChangedEventArgs_adaptor<X> { typedef adapt IGeovisitStateChangedEventArgs; };
struct IGeovisitStateChangedEventArgs : IGeovisitStateChangedEventArgs_raw, generate<IGeovisitStateChangedEventArgs> {};

// GeovisitStateChangedEventArgs
template<typename X> struct statics<GeovisitStateChangedEventArgs, X> : X {
	typedef typename X::root_type GeovisitStateChangedEventArgs;
};
struct GeovisitStateChangedEventArgs : generate<GeovisitStateChangedEventArgs> {};

// IGeovisitMonitor
struct IGeovisitMonitor_raw : IInspectable {
	virtual STDMETHODIMP _get_MonitoringScope(VisitMonitoringScope *value);
	virtual STDMETHODIMP _Start(VisitMonitoringScope value);
	virtual STDMETHODIMP _Stop();
	virtual STDMETHODIMP _add_VisitStateChanged(Foundation::TypedEventHandler<GeovisitMonitor*, GeovisitStateChangedEventArgs*>* handler, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_VisitStateChanged(Foundation::EventRegistrationToken token);
};
template<typename X> struct IGeovisitMonitor_adaptor : X {
	union {
		struct : property {
			VisitMonitoringScope get() { VisitMonitoringScope value; hrcheck(enc(&IGeovisitMonitor_adaptor::MonitoringScope)->_get_MonitoringScope(&value)); return value; }
			VisitMonitoringScope operator()() { return get(); }
			operator VisitMonitoringScope () { return get(); }
		} MonitoringScope;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<GeovisitMonitor>, ptr<GeovisitStateChangedEventArgs>>> handler) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGeovisitMonitor_adaptor::VisitStateChanged)->_add_VisitStateChanged(to_abi(handler), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGeovisitMonitor_adaptor::VisitStateChanged)->_remove_VisitStateChanged(token)); }
		} VisitStateChanged;
	};
	void Start(VisitMonitoringScope value) { hrcheck(X::get()->_Start(value)); }
	void Stop() { hrcheck(X::get()->_Stop()); }
	IGeovisitMonitor_adaptor() {}
};
template<typename X> struct adapt<IGeovisitMonitor, X> : Windows::Devices::Geolocation::IGeovisitMonitor_adaptor<X> { typedef adapt IGeovisitMonitor; };
struct IGeovisitMonitor : IGeovisitMonitor_raw, generate<IGeovisitMonitor> {};

// IGeovisitMonitorStatics
struct IGeovisitMonitorStatics : IInspectable {
	virtual STDMETHODIMP _GetLastReportAsync(Foundation::IAsyncOperation<Geovisit*>* *value);
};

// GeovisitMonitor
template<typename> struct GeovisitMonitor_statics {
	static ptr<Foundation::IAsyncOperation<ptr<Geovisit>>> GetLastReportAsync() { Foundation::IAsyncOperation<Geovisit*>* value; hrcheck(get_activation_factory<GeovisitMonitor, IGeovisitMonitorStatics>()->_GetLastReportAsync(&value)); return from_abi(value); }
};

template<typename X> struct statics<GeovisitMonitor, X> : X, Windows::Devices::Geolocation::GeovisitMonitor_statics<void> {
	typedef typename X::root_type GeovisitMonitor;
};
struct GeovisitMonitor : generate<GeovisitMonitor> {};

// IGeovisitTriggerDetails
struct IGeovisitTriggerDetails_raw : IInspectable {
	virtual STDMETHODIMP _ReadReports(Foundation::Collections::IVectorView<Geovisit*>* *values);
};
template<typename X> struct IGeovisitTriggerDetails_adaptor : X {
	ptr<Foundation::Collections::IVectorView<ptr<Geovisit>>> ReadReports() { Foundation::Collections::IVectorView<Geovisit*>* values; hrcheck(X::get()->_ReadReports(&values)); return from_abi(values); }
};
template<typename X> struct adapt<IGeovisitTriggerDetails, X> : Windows::Devices::Geolocation::IGeovisitTriggerDetails_adaptor<X> { typedef adapt IGeovisitTriggerDetails; };
struct IGeovisitTriggerDetails : IGeovisitTriggerDetails_raw, generate<IGeovisitTriggerDetails> {};

// GeovisitTriggerDetails
template<typename X> struct statics<GeovisitTriggerDetails, X> : X {
	typedef typename X::root_type GeovisitTriggerDetails;
};
struct GeovisitTriggerDetails : generate<GeovisitTriggerDetails> {};
}}}
} // namespace iso_winrt
