#pragma once
// generated by isopod tools
// namespaces:
// Windows.Gaming.Input

#include "Windows.Gaming.Input.0.h"
#include "Windows.Foundation.0.h"

namespace iso_winrt {

// forward types

namespace Windows { namespace Devices { namespace Haptics {
struct SimpleHapticsController;
}
namespace Power {
struct BatteryReport;
}}
namespace Foundation { namespace Collections {
template<typename T> struct IVectorView;
}}
namespace Gaming { namespace Input { namespace ForceFeedback {
struct ForceFeedbackMotor;
}}}
namespace System {
struct UserChangedEventArgs;
struct User;
}}

// defs

template<> struct def<Windows::Gaming::Input::ArcadeStickButtons> : enum_type<unsigned> {};
template<> struct def<Windows::Gaming::Input::FlightStickButtons> : enum_type<unsigned> {};
template<> struct def<Windows::Gaming::Input::GameControllerButtonLabel> : enum_type<int> {};
template<> struct def<Windows::Gaming::Input::GameControllerSwitchKind> : enum_type<int> {};
template<> struct def<Windows::Gaming::Input::GameControllerSwitchPosition> : enum_type<int> {};
template<> struct def<Windows::Gaming::Input::GamepadButtons> : enum_type<unsigned> {};
template<> struct def<Windows::Gaming::Input::RacingWheelButtons> : enum_type<unsigned> {};
template<> struct def<Windows::Gaming::Input::RequiredUINavigationButtons> : enum_type<unsigned> {};
template<> struct def<Windows::Gaming::Input::OptionalUINavigationButtons> : enum_type<unsigned> {};
template<> struct def<Windows::Gaming::Input::ArcadeStickReading> : value_type<unsigned __int64, Windows::Gaming::Input::ArcadeStickButtons> {};
template<> struct def<Windows::Gaming::Input::FlightStickReading> : value_type<unsigned __int64, Windows::Gaming::Input::FlightStickButtons, Windows::Gaming::Input::GameControllerSwitchPosition, double, double, double, double> {};
template<> struct def<Windows::Gaming::Input::GamepadReading> : value_type<unsigned __int64, Windows::Gaming::Input::GamepadButtons, double, double, double, double, double, double> {};
template<> struct def<Windows::Gaming::Input::GamepadVibration> : value_type<double, double, double, double> {};
template<> struct def<Windows::Gaming::Input::RacingWheelReading> : value_type<unsigned __int64, Windows::Gaming::Input::RacingWheelButtons, int, double, double, double, double, double> {};
template<> struct def<Windows::Gaming::Input::UINavigationReading> : value_type<unsigned __int64, Windows::Gaming::Input::RequiredUINavigationButtons, Windows::Gaming::Input::OptionalUINavigationButtons> {};
template<> struct def<Windows::Gaming::Input::IGameController> : overridable_type<> {};
template<> struct def<Windows::Gaming::Input::IGameControllerBatteryInfo> : overridable_type<> {};
template<> struct def<Windows::Gaming::Input::IHeadset> : interface_type<> {};
template<> struct def<Windows::Gaming::Input::Headset> : class_type<Platform::Object, Windows::Gaming::Input::IHeadset, Windows::Gaming::Input::IGameControllerBatteryInfo> {};
template<> struct def<Windows::Gaming::Input::IArcadeStick> : interface_type<Windows::Gaming::Input::IGameController> {};
template<> struct def<Windows::Gaming::Input::IArcadeStickStatics> : interface_type<> {};
template<> struct def<Windows::Gaming::Input::IArcadeStickStatics2> : interface_type<Windows::Gaming::Input::IArcadeStickStatics> {};
template<> struct def<Windows::Gaming::Input::ArcadeStick> : class_type<Platform::Object, Windows::Gaming::Input::IArcadeStick, Windows::Gaming::Input::IGameControllerBatteryInfo> {};
template<> struct def<Windows::Gaming::Input::IFlightStick> : interface_type<Windows::Gaming::Input::IGameController> {};
template<> struct def<Windows::Gaming::Input::IFlightStickStatics> : interface_type<> {};
template<> struct def<Windows::Gaming::Input::FlightStick> : class_type<Platform::Object, Windows::Gaming::Input::IFlightStick, Windows::Gaming::Input::IGameControllerBatteryInfo> {};
template<> struct def<Windows::Gaming::Input::IGamepad> : interface_type<Windows::Gaming::Input::IGameController> {};
template<> struct def<Windows::Gaming::Input::IGamepad2> : interface_type<Windows::Gaming::Input::IGamepad> {};
template<> struct def<Windows::Gaming::Input::IGamepadStatics> : interface_type<> {};
template<> struct def<Windows::Gaming::Input::IGamepadStatics2> : interface_type<Windows::Gaming::Input::IGamepadStatics> {};
template<> struct def<Windows::Gaming::Input::Gamepad> : class_type<Platform::Object, Windows::Gaming::Input::IGamepad, Windows::Gaming::Input::IGameControllerBatteryInfo, Windows::Gaming::Input::IGamepad2> {};
template<> struct def<Windows::Gaming::Input::IRacingWheel> : interface_type<Windows::Gaming::Input::IGameController> {};
template<> struct def<Windows::Gaming::Input::IRacingWheelStatics> : interface_type<> {};
template<> struct def<Windows::Gaming::Input::IRacingWheelStatics2> : interface_type<Windows::Gaming::Input::IRacingWheelStatics> {};
template<> struct def<Windows::Gaming::Input::RacingWheel> : class_type<Platform::Object, Windows::Gaming::Input::IRacingWheel, Windows::Gaming::Input::IGameControllerBatteryInfo> {};
template<> struct def<Windows::Gaming::Input::IRawGameController> : interface_type<Windows::Gaming::Input::IGameController> {};
template<> struct def<Windows::Gaming::Input::IRawGameController2> : interface_type<Windows::Gaming::Input::IRawGameController> {};
template<> struct def<Windows::Gaming::Input::IRawGameControllerStatics> : interface_type<> {};
template<> struct def<Windows::Gaming::Input::RawGameController> : class_type<Platform::Object, Windows::Gaming::Input::IRawGameController, Windows::Gaming::Input::IRawGameController2, Windows::Gaming::Input::IGameControllerBatteryInfo> {};
template<> struct def<Windows::Gaming::Input::IUINavigationController> : interface_type<Windows::Gaming::Input::IGameController> {};
template<> struct def<Windows::Gaming::Input::IUINavigationControllerStatics> : interface_type<> {};
template<> struct def<Windows::Gaming::Input::IUINavigationControllerStatics2> : interface_type<Windows::Gaming::Input::IUINavigationControllerStatics> {};
template<> struct def<Windows::Gaming::Input::UINavigationController> : class_type<Platform::Object, Windows::Gaming::Input::IUINavigationController, Windows::Gaming::Input::IGameControllerBatteryInfo> {};
template<> struct def<Windows::Gaming::Input::GamingInputPreviewContract> : value_type<> {};

// uuids

template<> struct uuid<Windows::Gaming::Input::IGameController> { define_guid(0x1BAF6522, 0x5F64, 0x42C5, 0x82, 0x67, 0xB9, 0xFE, 0x22, 0x15, 0xBF, 0xBD);};
template<> struct uuid<Windows::Gaming::Input::IGameControllerBatteryInfo> { define_guid(0xDCECC681, 0x3963, 0x4DA6, 0x95, 0x5D, 0x55, 0x3F, 0x3B, 0x6F, 0x61, 0x61);};
template<> struct uuid<Windows::Gaming::Input::IHeadset> { define_guid(0x3FD156EF, 0x6925, 0x3FA8, 0x91, 0x81, 0x2, 0x9C, 0x52, 0x23, 0xAE, 0x3B);};
template<> struct uuid<Windows::Gaming::Input::IArcadeStick> { define_guid(0xB14A539D, 0xBEFB, 0x4C81, 0x80, 0x51, 0x15, 0xEC, 0xF3, 0xB1, 0x30, 0x36);};
template<> struct uuid<Windows::Gaming::Input::IArcadeStickStatics> { define_guid(0x5C37B8C8, 0x37B1, 0x4AD8, 0x94, 0x58, 0x20, 0xF, 0x1A, 0x30, 0x1, 0x8E);};
template<> struct uuid<Windows::Gaming::Input::IArcadeStickStatics2> { define_guid(0x52B5D744, 0xBB86, 0x445A, 0xB5, 0x9C, 0x59, 0x6F, 0xE, 0x2A, 0x49, 0xDF);};
template<> struct uuid<Windows::Gaming::Input::IFlightStick> { define_guid(0xB4A2C01C, 0xB83B, 0x4459, 0xA1, 0xA9, 0x97, 0xB0, 0x3C, 0x33, 0xDA, 0x7C);};
template<> struct uuid<Windows::Gaming::Input::IFlightStickStatics> { define_guid(0x5514924A, 0xFECC, 0x435E, 0x83, 0xDC, 0x5C, 0xEC, 0x8A, 0x18, 0xA5, 0x20);};
template<> struct uuid<Windows::Gaming::Input::IGamepad> { define_guid(0xBC7BB43C, 0xA69, 0x3903, 0x9E, 0x9D, 0xA5, 0xF, 0x86, 0xA4, 0x5D, 0xE5);};
template<> struct uuid<Windows::Gaming::Input::IGamepad2> { define_guid(0x3C1689BD, 0x5915, 0x4245, 0xB0, 0xC0, 0xC8, 0x9F, 0xAE, 0x3, 0x8, 0xFF);};
template<> struct uuid<Windows::Gaming::Input::IGamepadStatics> { define_guid(0x8BBCE529, 0xD49C, 0x39E9, 0x95, 0x60, 0xE4, 0x7D, 0xDE, 0x96, 0xB7, 0xC8);};
template<> struct uuid<Windows::Gaming::Input::IGamepadStatics2> { define_guid(0x42676DC5, 0x856, 0x47C4, 0x92, 0x13, 0xB3, 0x95, 0x50, 0x4C, 0x3A, 0x3C);};
template<> struct uuid<Windows::Gaming::Input::IRacingWheel> { define_guid(0xF546656F, 0xE106, 0x4C82, 0xA9, 0xF, 0x55, 0x40, 0x12, 0x90, 0x4B, 0x85);};
template<> struct uuid<Windows::Gaming::Input::IRacingWheelStatics> { define_guid(0x3AC12CD5, 0x581B, 0x4936, 0x9F, 0x94, 0x69, 0xF1, 0xE6, 0x51, 0x4C, 0x7D);};
template<> struct uuid<Windows::Gaming::Input::IRacingWheelStatics2> { define_guid(0xE666BCAA, 0xEDFD, 0x4323, 0xA9, 0xF6, 0x3C, 0x38, 0x40, 0x48, 0xD1, 0xED);};
template<> struct uuid<Windows::Gaming::Input::IRawGameController> { define_guid(0x7CAD6D91, 0xA7E1, 0x4F71, 0x9A, 0x78, 0x33, 0xE9, 0xC5, 0xDF, 0xEA, 0x62);};
template<> struct uuid<Windows::Gaming::Input::IRawGameController2> { define_guid(0x43C0C035, 0xBB73, 0x4756, 0xA7, 0x87, 0x3E, 0xD6, 0xBE, 0xA6, 0x17, 0xBD);};
template<> struct uuid<Windows::Gaming::Input::IRawGameControllerStatics> { define_guid(0xEB8D0792, 0xE95A, 0x4B19, 0xAF, 0xC7, 0xA, 0x59, 0xF8, 0xBF, 0x75, 0x9E);};
template<> struct uuid<Windows::Gaming::Input::IUINavigationController> { define_guid(0xE5AEEFDD, 0xF50E, 0x4A55, 0x8C, 0xDC, 0xD3, 0x32, 0x29, 0x54, 0x81, 0x75);};
template<> struct uuid<Windows::Gaming::Input::IUINavigationControllerStatics> { define_guid(0x2F14930A, 0xF6F8, 0x4A48, 0x8D, 0x89, 0x94, 0x78, 0x6C, 0xCA, 0xC, 0x2E);};
template<> struct uuid<Windows::Gaming::Input::IUINavigationControllerStatics2> { define_guid(0xE0CB28E3, 0xB20B, 0x4B0B, 0x9E, 0xD4, 0xF3, 0xD5, 0x3C, 0xEC, 0xD, 0xE4);};

// types

namespace Windows { namespace Gaming { namespace Input {

// IGameController
struct IGameController_raw : IInspectable {
	virtual STDMETHODIMP _add_HeadsetConnected(Foundation::TypedEventHandler<IGameController*, Input::Headset*>* value, Foundation::EventRegistrationToken *token) = 0;
	virtual STDMETHODIMP _remove_HeadsetConnected(Foundation::EventRegistrationToken token) = 0;
	virtual STDMETHODIMP _add_HeadsetDisconnected(Foundation::TypedEventHandler<IGameController*, Input::Headset*>* value, Foundation::EventRegistrationToken *token) = 0;
	virtual STDMETHODIMP _remove_HeadsetDisconnected(Foundation::EventRegistrationToken token) = 0;
	virtual STDMETHODIMP _add_UserChanged(Foundation::TypedEventHandler<IGameController*, System::UserChangedEventArgs*>* value, Foundation::EventRegistrationToken *token) = 0;
	virtual STDMETHODIMP _remove_UserChanged(Foundation::EventRegistrationToken token) = 0;
	virtual STDMETHODIMP _get_Headset(Input::Headset* *value) = 0;
	virtual STDMETHODIMP _get_IsWireless(bool *value) = 0;
	virtual STDMETHODIMP _get_User(System::User* *value) = 0;
};
template<typename X> struct IGameController_adaptor : X {
	union {
		struct : property {
			ptr<Input::Headset> get() { Input::Headset* value; hrcheck(enc(&IGameController_adaptor::Headset)->_get_Headset(&value)); return from_abi(value); }
			ptr<Input::Headset> operator()() { return get(); }
			operator ptr<Input::Headset> () { return get(); }
			ptr<Input::Headset> operator->() { return get(); }
		} Headset;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IGameController_adaptor::IsWireless)->_get_IsWireless(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} IsWireless;
		struct : property {
			ptr<System::User> get() { System::User* value; hrcheck(enc(&IGameController_adaptor::User)->_get_User(&value)); return from_abi(value); }
			ptr<System::User> operator()() { return get(); }
			operator ptr<System::User> () { return get(); }
			ptr<System::User> operator->() { return get(); }
		} User;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<IGameController>, ptr<Input::Headset>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGameController_adaptor::HeadsetConnected)->_add_HeadsetConnected(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGameController_adaptor::HeadsetConnected)->_remove_HeadsetConnected(token)); }
		} HeadsetConnected;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<IGameController>, ptr<Input::Headset>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGameController_adaptor::HeadsetDisconnected)->_add_HeadsetDisconnected(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGameController_adaptor::HeadsetDisconnected)->_remove_HeadsetDisconnected(token)); }
		} HeadsetDisconnected;
		struct : property {
			Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::TypedEventHandler<ptr<IGameController>, ptr<System::UserChangedEventArgs>>> value) { Foundation::EventRegistrationToken token; hrcheck(enc(&IGameController_adaptor::UserChanged)->_add_UserChanged(to_abi(value), &token)); return token; }
			void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(enc(&IGameController_adaptor::UserChanged)->_remove_UserChanged(token)); }
		} UserChanged;
	};
	IGameController_adaptor() {}
};
template<typename X> struct adapt<IGameController, X> : Windows::Gaming::Input::IGameController_adaptor<X> { typedef adapt IGameController; };
template<typename X> struct IGameController_unadaptor : X {
	STDMETHODIMP _add_HeadsetConnected(Foundation::TypedEventHandler<IGameController*, Input::Headset*>* value, Foundation::EventRegistrationToken *token) { return hrtry([&, this] { *token = X::get()->HeadsetConnected+=value; }); }
	STDMETHODIMP _remove_HeadsetConnected(Foundation::EventRegistrationToken token) { return hrtry([&, this] { X::get()->HeadsetConnected-=token; }); }
	STDMETHODIMP _add_HeadsetDisconnected(Foundation::TypedEventHandler<IGameController*, Input::Headset*>* value, Foundation::EventRegistrationToken *token) { return hrtry([&, this] { *token = X::get()->HeadsetDisconnected+=value; }); }
	STDMETHODIMP _remove_HeadsetDisconnected(Foundation::EventRegistrationToken token) { return hrtry([&, this] { X::get()->HeadsetDisconnected-=token; }); }
	STDMETHODIMP _add_UserChanged(Foundation::TypedEventHandler<IGameController*, System::UserChangedEventArgs*>* value, Foundation::EventRegistrationToken *token) { return hrtry([&, this] { *token = X::get()->UserChanged+=value; }); }
	STDMETHODIMP _remove_UserChanged(Foundation::EventRegistrationToken token) { return hrtry([&, this] { X::get()->UserChanged-=token; }); }
	STDMETHODIMP _get_Headset(Input::Headset* *value) { return hrtry([&, this] { get_prop(value, Headset); }); }
	STDMETHODIMP _get_IsWireless(bool *value) { return hrtry([&, this] { get_prop(value, IsWireless); }); }
	STDMETHODIMP _get_User(System::User* *value) { return hrtry([&, this] { get_prop(value, User); }); }
};
template<typename X> struct unadapt<IGameController, X> : Windows::Gaming::Input::IGameController_unadaptor<X> {};
struct IGameController : IGameController_raw, generate<IGameController> {};

// IGameControllerBatteryInfo
struct IGameControllerBatteryInfo_raw : IInspectable {
	virtual STDMETHODIMP _TryGetBatteryReport(Devices::Power::BatteryReport* *value) = 0;
};
template<typename X> struct IGameControllerBatteryInfo_adaptor : X {
	ptr<Devices::Power::BatteryReport> TryGetBatteryReport() { Devices::Power::BatteryReport* value; hrcheck(X::get()->_TryGetBatteryReport(&value)); return from_abi(value); }
};
template<typename X> struct adapt<IGameControllerBatteryInfo, X> : Windows::Gaming::Input::IGameControllerBatteryInfo_adaptor<X> { typedef adapt IGameControllerBatteryInfo; };
template<typename X> struct IGameControllerBatteryInfo_unadaptor : X {
	STDMETHODIMP _TryGetBatteryReport(Devices::Power::BatteryReport* *value) { return hrtry([&, this] { *value = to_abi(X::get()->TryGetBatteryReport()); }); }
};
template<typename X> struct unadapt<IGameControllerBatteryInfo, X> : Windows::Gaming::Input::IGameControllerBatteryInfo_unadaptor<X> {};
struct IGameControllerBatteryInfo : IGameControllerBatteryInfo_raw, generate<IGameControllerBatteryInfo> {};

// IHeadset
struct IHeadset_raw : IInspectable {
	virtual STDMETHODIMP _get_CaptureDeviceId(HSTRING *value);
	virtual STDMETHODIMP _get_RenderDeviceId(HSTRING *value);
};
template<typename X> struct IHeadset_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHeadset_adaptor::CaptureDeviceId)->_get_CaptureDeviceId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} CaptureDeviceId;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IHeadset_adaptor::RenderDeviceId)->_get_RenderDeviceId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} RenderDeviceId;
	};
	IHeadset_adaptor() {}
};
template<typename X> struct adapt<IHeadset, X> : Windows::Gaming::Input::IHeadset_adaptor<X> { typedef adapt IHeadset; };
struct IHeadset : IHeadset_raw, generate<IHeadset> {};

// Headset
template<typename X> struct statics<Headset, X> : X {
	typedef typename X::root_type Headset;
};
struct Headset : generate<Headset> {};

// IArcadeStick
struct IArcadeStick_raw : IInspectable {
	virtual STDMETHODIMP _GetButtonLabel(ArcadeStickButtons button, GameControllerButtonLabel *value);
	virtual STDMETHODIMP _GetCurrentReading(ArcadeStickReading *value);
};
template<typename X> struct IArcadeStick_adaptor : X {
	GameControllerButtonLabel GetButtonLabel(ArcadeStickButtons button) { GameControllerButtonLabel value; hrcheck(X::get()->_GetButtonLabel(button, &value)); return value; }
	ArcadeStickReading GetCurrentReading() { ArcadeStickReading value; hrcheck(X::get()->_GetCurrentReading(&value)); return value; }
};
template<typename X> struct adapt<IArcadeStick, X> : Windows::Gaming::Input::IArcadeStick_adaptor<X> { typedef adapt IArcadeStick; };
struct IArcadeStick : IArcadeStick_raw, generate<IArcadeStick> {};

// IArcadeStickStatics
struct IArcadeStickStatics : IInspectable {
	virtual STDMETHODIMP _add_ArcadeStickAdded(Foundation::EventHandler<ArcadeStick*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ArcadeStickAdded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_ArcadeStickRemoved(Foundation::EventHandler<ArcadeStick*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_ArcadeStickRemoved(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_ArcadeSticks(Foundation::Collections::IVectorView<ArcadeStick*>* *value);
};

// IArcadeStickStatics2
struct IArcadeStickStatics2 : IInspectable {
	virtual STDMETHODIMP _FromGameController(IGameController* gameController, ArcadeStick* *value);
};

// ArcadeStick
template<typename> struct ArcadeStick_statics {
	static struct _ArcadeSticks : property {
		ptr<Foundation::Collections::IVectorView<ptr<ArcadeStick>>> get() { Foundation::Collections::IVectorView<ArcadeStick*>* value; hrcheck(get_activation_factory<ArcadeStick, IArcadeStickStatics>()->_get_ArcadeSticks(&value)); return from_abi(value); }
		ptr<Foundation::Collections::IVectorView<ptr<ArcadeStick>>> operator()() { return get(); }
		operator ptr<Foundation::Collections::IVectorView<ptr<ArcadeStick>>> () { return get(); }
		ptr<Foundation::Collections::IVectorView<ptr<ArcadeStick>>> operator->() { return get(); }
	} ArcadeSticks;
	static struct _ArcadeStickAdded : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<ArcadeStick>>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<ArcadeStick, IArcadeStickStatics>()->_add_ArcadeStickAdded(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<ArcadeStick, IArcadeStickStatics>()->_remove_ArcadeStickAdded(token)); }
	} ArcadeStickAdded;
	static struct _ArcadeStickRemoved : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<ArcadeStick>>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<ArcadeStick, IArcadeStickStatics>()->_add_ArcadeStickRemoved(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<ArcadeStick, IArcadeStickStatics>()->_remove_ArcadeStickRemoved(token)); }
	} ArcadeStickRemoved;
	static ptr<ArcadeStick> FromGameController(pptr<IGameController> gameController) { ArcadeStick* value; hrcheck(get_activation_factory<ArcadeStick, IArcadeStickStatics2>()->_FromGameController(gameController, &value)); return from_abi(value); }
};
template<typename X> typename ArcadeStick_statics<X>::_ArcadeSticks ArcadeStick_statics<X>::ArcadeSticks;
template<typename X> typename ArcadeStick_statics<X>::_ArcadeStickAdded ArcadeStick_statics<X>::ArcadeStickAdded;
template<typename X> typename ArcadeStick_statics<X>::_ArcadeStickRemoved ArcadeStick_statics<X>::ArcadeStickRemoved;

template<typename X> struct statics<ArcadeStick, X> : X, Windows::Gaming::Input::ArcadeStick_statics<void> {
	typedef typename X::root_type ArcadeStick;
};
struct ArcadeStick : generate<ArcadeStick> {};

// IFlightStick
struct IFlightStick_raw : IInspectable {
	virtual STDMETHODIMP _get_HatSwitchKind(GameControllerSwitchKind *value);
	virtual STDMETHODIMP _GetButtonLabel(FlightStickButtons button, GameControllerButtonLabel *value);
	virtual STDMETHODIMP _GetCurrentReading(FlightStickReading *value);
};
template<typename X> struct IFlightStick_adaptor : X {
	union {
		struct : property {
			GameControllerSwitchKind get() { GameControllerSwitchKind value; hrcheck(enc(&IFlightStick_adaptor::HatSwitchKind)->_get_HatSwitchKind(&value)); return value; }
			GameControllerSwitchKind operator()() { return get(); }
			operator GameControllerSwitchKind () { return get(); }
		} HatSwitchKind;
	};
	GameControllerButtonLabel GetButtonLabel(FlightStickButtons button) { GameControllerButtonLabel value; hrcheck(X::get()->_GetButtonLabel(button, &value)); return value; }
	FlightStickReading GetCurrentReading() { FlightStickReading value; hrcheck(X::get()->_GetCurrentReading(&value)); return value; }
	IFlightStick_adaptor() {}
};
template<typename X> struct adapt<IFlightStick, X> : Windows::Gaming::Input::IFlightStick_adaptor<X> { typedef adapt IFlightStick; };
struct IFlightStick : IFlightStick_raw, generate<IFlightStick> {};

// IFlightStickStatics
struct IFlightStickStatics : IInspectable {
	virtual STDMETHODIMP _add_FlightStickAdded(Foundation::EventHandler<FlightStick*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_FlightStickAdded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_FlightStickRemoved(Foundation::EventHandler<FlightStick*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_FlightStickRemoved(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_FlightSticks(Foundation::Collections::IVectorView<FlightStick*>* *value);
	virtual STDMETHODIMP _FromGameController(IGameController* gameController, FlightStick* *value);
};

// FlightStick
template<typename> struct FlightStick_statics {
	static struct _FlightSticks : property {
		ptr<Foundation::Collections::IVectorView<ptr<FlightStick>>> get() { Foundation::Collections::IVectorView<FlightStick*>* value; hrcheck(get_activation_factory<FlightStick, IFlightStickStatics>()->_get_FlightSticks(&value)); return from_abi(value); }
		ptr<Foundation::Collections::IVectorView<ptr<FlightStick>>> operator()() { return get(); }
		operator ptr<Foundation::Collections::IVectorView<ptr<FlightStick>>> () { return get(); }
		ptr<Foundation::Collections::IVectorView<ptr<FlightStick>>> operator->() { return get(); }
	} FlightSticks;
	static struct _FlightStickAdded : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<FlightStick>>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<FlightStick, IFlightStickStatics>()->_add_FlightStickAdded(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<FlightStick, IFlightStickStatics>()->_remove_FlightStickAdded(token)); }
	} FlightStickAdded;
	static struct _FlightStickRemoved : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<FlightStick>>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<FlightStick, IFlightStickStatics>()->_add_FlightStickRemoved(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<FlightStick, IFlightStickStatics>()->_remove_FlightStickRemoved(token)); }
	} FlightStickRemoved;
	static ptr<FlightStick> FromGameController(pptr<IGameController> gameController) { FlightStick* value; hrcheck(get_activation_factory<FlightStick, IFlightStickStatics>()->_FromGameController(gameController, &value)); return from_abi(value); }
};
template<typename X> typename FlightStick_statics<X>::_FlightSticks FlightStick_statics<X>::FlightSticks;
template<typename X> typename FlightStick_statics<X>::_FlightStickAdded FlightStick_statics<X>::FlightStickAdded;
template<typename X> typename FlightStick_statics<X>::_FlightStickRemoved FlightStick_statics<X>::FlightStickRemoved;

template<typename X> struct statics<FlightStick, X> : X, Windows::Gaming::Input::FlightStick_statics<void> {
	typedef typename X::root_type FlightStick;
};
struct FlightStick : generate<FlightStick> {};

// IGamepad
struct IGamepad_raw : IInspectable {
	virtual STDMETHODIMP _get_Vibration(GamepadVibration *value);
	virtual STDMETHODIMP _put_Vibration(GamepadVibration value);
	virtual STDMETHODIMP _GetCurrentReading(GamepadReading *value);
};
template<typename X> struct IGamepad_adaptor : X {
	union {
		struct : property {
			GamepadVibration get() { GamepadVibration value; hrcheck(enc(&IGamepad_adaptor::Vibration)->_get_Vibration(&value)); return value; }
			GamepadVibration operator()() { return get(); }
			operator GamepadVibration () { return get(); }
			void put(const GamepadVibration& value) { hrcheck(enc(&IGamepad_adaptor::Vibration)->_put_Vibration(value)); }
			void operator=(const GamepadVibration& value) { put(value); }
			void operator()(const GamepadVibration& value) { put(value); }
		} Vibration;
	};
	GamepadReading GetCurrentReading() { GamepadReading value; hrcheck(X::get()->_GetCurrentReading(&value)); return value; }
	IGamepad_adaptor() {}
};
template<typename X> struct adapt<IGamepad, X> : Windows::Gaming::Input::IGamepad_adaptor<X> { typedef adapt IGamepad; };
struct IGamepad : IGamepad_raw, generate<IGamepad> {};

// IGamepad2
struct IGamepad2_raw : IInspectable {
	virtual STDMETHODIMP _GetButtonLabel(GamepadButtons button, GameControllerButtonLabel *value);
};
template<typename X> struct IGamepad2_adaptor : X {
	GameControllerButtonLabel GetButtonLabel(GamepadButtons button) { GameControllerButtonLabel value; hrcheck(X::get()->_GetButtonLabel(button, &value)); return value; }
};
template<typename X> struct adapt<IGamepad2, X> : Windows::Gaming::Input::IGamepad2_adaptor<X> { typedef adapt IGamepad2; };
struct IGamepad2 : IGamepad2_raw, generate<IGamepad2> {};

// IGamepadStatics
struct IGamepadStatics : IInspectable {
	virtual STDMETHODIMP _add_GamepadAdded(Foundation::EventHandler<Gamepad*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_GamepadAdded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_GamepadRemoved(Foundation::EventHandler<Gamepad*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_GamepadRemoved(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_Gamepads(Foundation::Collections::IVectorView<Gamepad*>* *value);
};

// IGamepadStatics2
struct IGamepadStatics2 : IInspectable {
	virtual STDMETHODIMP _FromGameController(IGameController* gameController, Gamepad* *value);
};

// Gamepad
template<typename> struct Gamepad_statics {
	static struct _Gamepads : property {
		ptr<Foundation::Collections::IVectorView<ptr<Gamepad>>> get() { Foundation::Collections::IVectorView<Gamepad*>* value; hrcheck(get_activation_factory<Gamepad, IGamepadStatics>()->_get_Gamepads(&value)); return from_abi(value); }
		ptr<Foundation::Collections::IVectorView<ptr<Gamepad>>> operator()() { return get(); }
		operator ptr<Foundation::Collections::IVectorView<ptr<Gamepad>>> () { return get(); }
		ptr<Foundation::Collections::IVectorView<ptr<Gamepad>>> operator->() { return get(); }
	} Gamepads;
	static struct _GamepadAdded : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<Gamepad>>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<Gamepad, IGamepadStatics>()->_add_GamepadAdded(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<Gamepad, IGamepadStatics>()->_remove_GamepadAdded(token)); }
	} GamepadAdded;
	static struct _GamepadRemoved : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<Gamepad>>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<Gamepad, IGamepadStatics>()->_add_GamepadRemoved(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<Gamepad, IGamepadStatics>()->_remove_GamepadRemoved(token)); }
	} GamepadRemoved;
	static ptr<Gamepad> FromGameController(pptr<IGameController> gameController) { Gamepad* value; hrcheck(get_activation_factory<Gamepad, IGamepadStatics2>()->_FromGameController(gameController, &value)); return from_abi(value); }
};
template<typename X> typename Gamepad_statics<X>::_Gamepads Gamepad_statics<X>::Gamepads;
template<typename X> typename Gamepad_statics<X>::_GamepadAdded Gamepad_statics<X>::GamepadAdded;
template<typename X> typename Gamepad_statics<X>::_GamepadRemoved Gamepad_statics<X>::GamepadRemoved;

template<typename X> struct statics<Gamepad, X> : X, Windows::Gaming::Input::Gamepad_statics<void> {
	typedef typename X::root_type Gamepad;
};
struct Gamepad : generate<Gamepad> {};

// IRacingWheel
struct IRacingWheel_raw : IInspectable {
	virtual STDMETHODIMP _get_HasClutch(bool *value);
	virtual STDMETHODIMP _get_HasHandbrake(bool *value);
	virtual STDMETHODIMP _get_HasPatternShifter(bool *value);
	virtual STDMETHODIMP _get_MaxPatternShifterGear(int *value);
	virtual STDMETHODIMP _get_MaxWheelAngle(double *value);
	virtual STDMETHODIMP _get_WheelMotor(ForceFeedback::ForceFeedbackMotor* *value);
	virtual STDMETHODIMP _GetButtonLabel(RacingWheelButtons button, GameControllerButtonLabel *value);
	virtual STDMETHODIMP _GetCurrentReading(RacingWheelReading *value);
};
template<typename X> struct IRacingWheel_adaptor : X {
	union {
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRacingWheel_adaptor::HasClutch)->_get_HasClutch(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasClutch;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRacingWheel_adaptor::HasHandbrake)->_get_HasHandbrake(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasHandbrake;
		struct : property {
			bool get() { bool value; hrcheck(enc(&IRacingWheel_adaptor::HasPatternShifter)->_get_HasPatternShifter(&value)); return value; }
			bool operator()() { return get(); }
			operator bool () { return get(); }
		} HasPatternShifter;
		struct : property {
			int get() { int value; hrcheck(enc(&IRacingWheel_adaptor::MaxPatternShifterGear)->_get_MaxPatternShifterGear(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} MaxPatternShifterGear;
		struct : property {
			double get() { double value; hrcheck(enc(&IRacingWheel_adaptor::MaxWheelAngle)->_get_MaxWheelAngle(&value)); return value; }
			double operator()() { return get(); }
			operator double () { return get(); }
		} MaxWheelAngle;
		struct : property {
			ptr<ForceFeedback::ForceFeedbackMotor> get() { ForceFeedback::ForceFeedbackMotor* value; hrcheck(enc(&IRacingWheel_adaptor::WheelMotor)->_get_WheelMotor(&value)); return from_abi(value); }
			ptr<ForceFeedback::ForceFeedbackMotor> operator()() { return get(); }
			operator ptr<ForceFeedback::ForceFeedbackMotor> () { return get(); }
			ptr<ForceFeedback::ForceFeedbackMotor> operator->() { return get(); }
		} WheelMotor;
	};
	GameControllerButtonLabel GetButtonLabel(RacingWheelButtons button) { GameControllerButtonLabel value; hrcheck(X::get()->_GetButtonLabel(button, &value)); return value; }
	RacingWheelReading GetCurrentReading() { RacingWheelReading value; hrcheck(X::get()->_GetCurrentReading(&value)); return value; }
	IRacingWheel_adaptor() {}
};
template<typename X> struct adapt<IRacingWheel, X> : Windows::Gaming::Input::IRacingWheel_adaptor<X> { typedef adapt IRacingWheel; };
struct IRacingWheel : IRacingWheel_raw, generate<IRacingWheel> {};

// IRacingWheelStatics
struct IRacingWheelStatics : IInspectable {
	virtual STDMETHODIMP _add_RacingWheelAdded(Foundation::EventHandler<RacingWheel*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_RacingWheelAdded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_RacingWheelRemoved(Foundation::EventHandler<RacingWheel*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_RacingWheelRemoved(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_RacingWheels(Foundation::Collections::IVectorView<RacingWheel*>* *value);
};

// IRacingWheelStatics2
struct IRacingWheelStatics2 : IInspectable {
	virtual STDMETHODIMP _FromGameController(IGameController* gameController, RacingWheel* *value);
};

// RacingWheel
template<typename> struct RacingWheel_statics {
	static struct _RacingWheels : property {
		ptr<Foundation::Collections::IVectorView<ptr<RacingWheel>>> get() { Foundation::Collections::IVectorView<RacingWheel*>* value; hrcheck(get_activation_factory<RacingWheel, IRacingWheelStatics>()->_get_RacingWheels(&value)); return from_abi(value); }
		ptr<Foundation::Collections::IVectorView<ptr<RacingWheel>>> operator()() { return get(); }
		operator ptr<Foundation::Collections::IVectorView<ptr<RacingWheel>>> () { return get(); }
		ptr<Foundation::Collections::IVectorView<ptr<RacingWheel>>> operator->() { return get(); }
	} RacingWheels;
	static struct _RacingWheelAdded : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<RacingWheel>>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<RacingWheel, IRacingWheelStatics>()->_add_RacingWheelAdded(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<RacingWheel, IRacingWheelStatics>()->_remove_RacingWheelAdded(token)); }
	} RacingWheelAdded;
	static struct _RacingWheelRemoved : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<RacingWheel>>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<RacingWheel, IRacingWheelStatics>()->_add_RacingWheelRemoved(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<RacingWheel, IRacingWheelStatics>()->_remove_RacingWheelRemoved(token)); }
	} RacingWheelRemoved;
	static ptr<RacingWheel> FromGameController(pptr<IGameController> gameController) { RacingWheel* value; hrcheck(get_activation_factory<RacingWheel, IRacingWheelStatics2>()->_FromGameController(gameController, &value)); return from_abi(value); }
};
template<typename X> typename RacingWheel_statics<X>::_RacingWheels RacingWheel_statics<X>::RacingWheels;
template<typename X> typename RacingWheel_statics<X>::_RacingWheelAdded RacingWheel_statics<X>::RacingWheelAdded;
template<typename X> typename RacingWheel_statics<X>::_RacingWheelRemoved RacingWheel_statics<X>::RacingWheelRemoved;

template<typename X> struct statics<RacingWheel, X> : X, Windows::Gaming::Input::RacingWheel_statics<void> {
	typedef typename X::root_type RacingWheel;
};
struct RacingWheel : generate<RacingWheel> {};

// IRawGameController
struct IRawGameController_raw : IInspectable {
	virtual STDMETHODIMP _get_AxisCount(int *value);
	virtual STDMETHODIMP _get_ButtonCount(int *value);
	virtual STDMETHODIMP _get_ForceFeedbackMotors(Foundation::Collections::IVectorView<ForceFeedback::ForceFeedbackMotor*>* *value);
	virtual STDMETHODIMP _get_HardwareProductId(unsigned short *value);
	virtual STDMETHODIMP _get_HardwareVendorId(unsigned short *value);
	virtual STDMETHODIMP _get_SwitchCount(int *value);
	virtual STDMETHODIMP _GetButtonLabel(int buttonIndex, GameControllerButtonLabel *value);
	virtual STDMETHODIMP _GetCurrentReading(unsigned buttonArraySize, bool *buttonArray, unsigned switchArraySize, GameControllerSwitchPosition *switchArray, unsigned axisArraySize, double *axisArray, unsigned __int64 *timestamp);
	virtual STDMETHODIMP _GetSwitchKind(int switchIndex, GameControllerSwitchKind *value);
};
template<typename X> struct IRawGameController_adaptor : X {
	union {
		struct : property {
			int get() { int value; hrcheck(enc(&IRawGameController_adaptor::AxisCount)->_get_AxisCount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} AxisCount;
		struct : property {
			int get() { int value; hrcheck(enc(&IRawGameController_adaptor::ButtonCount)->_get_ButtonCount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} ButtonCount;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<ForceFeedback::ForceFeedbackMotor>>> get() { Foundation::Collections::IVectorView<ForceFeedback::ForceFeedbackMotor*>* value; hrcheck(enc(&IRawGameController_adaptor::ForceFeedbackMotors)->_get_ForceFeedbackMotors(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<ForceFeedback::ForceFeedbackMotor>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<ForceFeedback::ForceFeedbackMotor>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<ForceFeedback::ForceFeedbackMotor>>> operator->() { return get(); }
		} ForceFeedbackMotors;
		struct : property {
			unsigned short get() { unsigned short value; hrcheck(enc(&IRawGameController_adaptor::HardwareProductId)->_get_HardwareProductId(&value)); return value; }
			unsigned short operator()() { return get(); }
			operator unsigned short () { return get(); }
		} HardwareProductId;
		struct : property {
			unsigned short get() { unsigned short value; hrcheck(enc(&IRawGameController_adaptor::HardwareVendorId)->_get_HardwareVendorId(&value)); return value; }
			unsigned short operator()() { return get(); }
			operator unsigned short () { return get(); }
		} HardwareVendorId;
		struct : property {
			int get() { int value; hrcheck(enc(&IRawGameController_adaptor::SwitchCount)->_get_SwitchCount(&value)); return value; }
			int operator()() { return get(); }
			operator int () { return get(); }
		} SwitchCount;
	};
	GameControllerButtonLabel GetButtonLabel(int buttonIndex) { GameControllerButtonLabel value; hrcheck(X::get()->_GetButtonLabel(buttonIndex, &value)); return value; }
	unsigned __int64 GetCurrentReading(const szarray<bool>& buttonArray, const szarray<GameControllerSwitchPosition>& switchArray, const szarray<double>& axisArray) { unsigned __int64 timestamp; hrcheck(X::get()->_GetCurrentReading(buttonArray.size, to_abi(buttonArray.p), switchArray.size, to_abi(switchArray.p), axisArray.size, to_abi(axisArray.p), &timestamp)); return timestamp; }
	GameControllerSwitchKind GetSwitchKind(int switchIndex) { GameControllerSwitchKind value; hrcheck(X::get()->_GetSwitchKind(switchIndex, &value)); return value; }
	IRawGameController_adaptor() {}
};
template<typename X> struct adapt<IRawGameController, X> : Windows::Gaming::Input::IRawGameController_adaptor<X> { typedef adapt IRawGameController; };
struct IRawGameController : IRawGameController_raw, generate<IRawGameController> {};

// IRawGameController2
struct IRawGameController2_raw : IInspectable {
	virtual STDMETHODIMP _get_SimpleHapticsControllers(Foundation::Collections::IVectorView<Devices::Haptics::SimpleHapticsController*>* *value);
	virtual STDMETHODIMP _get_NonRoamableId(HSTRING *value);
	virtual STDMETHODIMP _get_DisplayName(HSTRING *value);
};
template<typename X> struct IRawGameController2_adaptor : X {
	union {
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRawGameController2_adaptor::DisplayName)->_get_DisplayName(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} DisplayName;
		struct : property {
			hstring get() { HSTRING value; hrcheck(enc(&IRawGameController2_adaptor::NonRoamableId)->_get_NonRoamableId(&value)); return from_abi(value); }
			hstring operator()() { return get(); }
			operator hstring_ref () { return get(); }
		} NonRoamableId;
		struct : property {
			ptr<Foundation::Collections::IVectorView<ptr<Devices::Haptics::SimpleHapticsController>>> get() { Foundation::Collections::IVectorView<Devices::Haptics::SimpleHapticsController*>* value; hrcheck(enc(&IRawGameController2_adaptor::SimpleHapticsControllers)->_get_SimpleHapticsControllers(&value)); return from_abi(value); }
			ptr<Foundation::Collections::IVectorView<ptr<Devices::Haptics::SimpleHapticsController>>> operator()() { return get(); }
			operator ptr<Foundation::Collections::IVectorView<ptr<Devices::Haptics::SimpleHapticsController>>> () { return get(); }
			ptr<Foundation::Collections::IVectorView<ptr<Devices::Haptics::SimpleHapticsController>>> operator->() { return get(); }
		} SimpleHapticsControllers;
	};
	IRawGameController2_adaptor() {}
};
template<typename X> struct adapt<IRawGameController2, X> : Windows::Gaming::Input::IRawGameController2_adaptor<X> { typedef adapt IRawGameController2; };
struct IRawGameController2 : IRawGameController2_raw, generate<IRawGameController2> {};

// IRawGameControllerStatics
struct IRawGameControllerStatics : IInspectable {
	virtual STDMETHODIMP _add_RawGameControllerAdded(Foundation::EventHandler<RawGameController*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_RawGameControllerAdded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_RawGameControllerRemoved(Foundation::EventHandler<RawGameController*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_RawGameControllerRemoved(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_RawGameControllers(Foundation::Collections::IVectorView<RawGameController*>* *value);
	virtual STDMETHODIMP _FromGameController(IGameController* gameController, RawGameController* *value);
};

// RawGameController
template<typename> struct RawGameController_statics {
	static struct _RawGameControllers : property {
		ptr<Foundation::Collections::IVectorView<ptr<RawGameController>>> get() { Foundation::Collections::IVectorView<RawGameController*>* value; hrcheck(get_activation_factory<RawGameController, IRawGameControllerStatics>()->_get_RawGameControllers(&value)); return from_abi(value); }
		ptr<Foundation::Collections::IVectorView<ptr<RawGameController>>> operator()() { return get(); }
		operator ptr<Foundation::Collections::IVectorView<ptr<RawGameController>>> () { return get(); }
		ptr<Foundation::Collections::IVectorView<ptr<RawGameController>>> operator->() { return get(); }
	} RawGameControllers;
	static struct _RawGameControllerAdded : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<RawGameController>>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<RawGameController, IRawGameControllerStatics>()->_add_RawGameControllerAdded(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<RawGameController, IRawGameControllerStatics>()->_remove_RawGameControllerAdded(token)); }
	} RawGameControllerAdded;
	static struct _RawGameControllerRemoved : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<RawGameController>>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<RawGameController, IRawGameControllerStatics>()->_add_RawGameControllerRemoved(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<RawGameController, IRawGameControllerStatics>()->_remove_RawGameControllerRemoved(token)); }
	} RawGameControllerRemoved;
	static ptr<RawGameController> FromGameController(pptr<IGameController> gameController) { RawGameController* value; hrcheck(get_activation_factory<RawGameController, IRawGameControllerStatics>()->_FromGameController(gameController, &value)); return from_abi(value); }
};
template<typename X> typename RawGameController_statics<X>::_RawGameControllers RawGameController_statics<X>::RawGameControllers;
template<typename X> typename RawGameController_statics<X>::_RawGameControllerAdded RawGameController_statics<X>::RawGameControllerAdded;
template<typename X> typename RawGameController_statics<X>::_RawGameControllerRemoved RawGameController_statics<X>::RawGameControllerRemoved;

template<typename X> struct statics<RawGameController, X> : X, Windows::Gaming::Input::RawGameController_statics<void> {
	typedef typename X::root_type RawGameController;
};
struct RawGameController : generate<RawGameController> {};

// IUINavigationController
struct IUINavigationController_raw : IInspectable {
	virtual STDMETHODIMP _GetCurrentReading(UINavigationReading *value);
	virtual STDMETHODIMP _GetOptionalButtonLabel(OptionalUINavigationButtons button, GameControllerButtonLabel *value);
	virtual STDMETHODIMP _GetRequiredButtonLabel(RequiredUINavigationButtons button, GameControllerButtonLabel *value);
};
template<typename X> struct IUINavigationController_adaptor : X {
	UINavigationReading GetCurrentReading() { UINavigationReading value; hrcheck(X::get()->_GetCurrentReading(&value)); return value; }
	GameControllerButtonLabel GetOptionalButtonLabel(OptionalUINavigationButtons button) { GameControllerButtonLabel value; hrcheck(X::get()->_GetOptionalButtonLabel(button, &value)); return value; }
	GameControllerButtonLabel GetRequiredButtonLabel(RequiredUINavigationButtons button) { GameControllerButtonLabel value; hrcheck(X::get()->_GetRequiredButtonLabel(button, &value)); return value; }
};
template<typename X> struct adapt<IUINavigationController, X> : Windows::Gaming::Input::IUINavigationController_adaptor<X> { typedef adapt IUINavigationController; };
struct IUINavigationController : IUINavigationController_raw, generate<IUINavigationController> {};

// IUINavigationControllerStatics
struct IUINavigationControllerStatics : IInspectable {
	virtual STDMETHODIMP _add_UINavigationControllerAdded(Foundation::EventHandler<UINavigationController*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_UINavigationControllerAdded(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _add_UINavigationControllerRemoved(Foundation::EventHandler<UINavigationController*>* value, Foundation::EventRegistrationToken *token);
	virtual STDMETHODIMP _remove_UINavigationControllerRemoved(Foundation::EventRegistrationToken token);
	virtual STDMETHODIMP _get_UINavigationControllers(Foundation::Collections::IVectorView<UINavigationController*>* *value);
};

// IUINavigationControllerStatics2
struct IUINavigationControllerStatics2 : IInspectable {
	virtual STDMETHODIMP _FromGameController(IGameController* gameController, UINavigationController* *value);
};

// UINavigationController
template<typename> struct UINavigationController_statics {
	static struct _UINavigationControllers : property {
		ptr<Foundation::Collections::IVectorView<ptr<UINavigationController>>> get() { Foundation::Collections::IVectorView<UINavigationController*>* value; hrcheck(get_activation_factory<UINavigationController, IUINavigationControllerStatics>()->_get_UINavigationControllers(&value)); return from_abi(value); }
		ptr<Foundation::Collections::IVectorView<ptr<UINavigationController>>> operator()() { return get(); }
		operator ptr<Foundation::Collections::IVectorView<ptr<UINavigationController>>> () { return get(); }
		ptr<Foundation::Collections::IVectorView<ptr<UINavigationController>>> operator->() { return get(); }
	} UINavigationControllers;
	static struct _UINavigationControllerAdded : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<UINavigationController>>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<UINavigationController, IUINavigationControllerStatics>()->_add_UINavigationControllerAdded(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<UINavigationController, IUINavigationControllerStatics>()->_remove_UINavigationControllerAdded(token)); }
	} UINavigationControllerAdded;
	static struct _UINavigationControllerRemoved : property {
		Foundation::EventRegistrationToken operator+=(handler_ref<Foundation::EventHandler<ptr<UINavigationController>>> value) { Foundation::EventRegistrationToken token; hrcheck(get_activation_factory<UINavigationController, IUINavigationControllerStatics>()->_add_UINavigationControllerRemoved(to_abi(value), &token)); return token; }
		void operator-=(const Foundation::EventRegistrationToken& token) { hrcheck(get_activation_factory<UINavigationController, IUINavigationControllerStatics>()->_remove_UINavigationControllerRemoved(token)); }
	} UINavigationControllerRemoved;
	static ptr<UINavigationController> FromGameController(pptr<IGameController> gameController) { UINavigationController* value; hrcheck(get_activation_factory<UINavigationController, IUINavigationControllerStatics2>()->_FromGameController(gameController, &value)); return from_abi(value); }
};
template<typename X> typename UINavigationController_statics<X>::_UINavigationControllers UINavigationController_statics<X>::UINavigationControllers;
template<typename X> typename UINavigationController_statics<X>::_UINavigationControllerAdded UINavigationController_statics<X>::UINavigationControllerAdded;
template<typename X> typename UINavigationController_statics<X>::_UINavigationControllerRemoved UINavigationController_statics<X>::UINavigationControllerRemoved;

template<typename X> struct statics<UINavigationController, X> : X, Windows::Gaming::Input::UINavigationController_statics<void> {
	typedef typename X::root_type UINavigationController;
};
struct UINavigationController : generate<UINavigationController> {};
}}}
} // namespace iso_winrt
